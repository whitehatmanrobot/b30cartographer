his space and compact interpreter-specific entries
;	to the top of the Runtime Heap. 
;	Note that this routine is ONLY called by interpreter code, 
;	and never by the shared-runtime code.
;
;	NOTE: after this operation is complete, the 'pbCurrent' field in
;		bdp's will still be correct and useable, assuming that
;		such pointers weren't pointing beyond cbLogical ...
;Input:
;	none.
;Output:
;	none.
;Modifies:
;	no permanent registers.
;Exceptions:
;	Chance of string space corrupt.
;
;***************************************************************************
cProc	BdCompressAll,<PUBLIC,FAR,NODATA>
cBegin
	call	BdCompressHeap		;compress the active heap
	call	B$TglHeapSpt		;activate the other heap
	call	BdCompressHeap		;compress the active heap
	call	B$TglHeapSpt		;reactivate the originally active heap
cEnd

;***
;BdAdjust(pBd)
;	This routine takes a pointer to a bd as a parameter and assumes
;	that an adjustment factor (the bd is being moved) is in DI.
;	It calls a heap manager routine which updates the entry backpointer,
;	if the bd is an owner (i.e., if the pb field is not NULL).
;Entry:
;	pBd - pointer to a bd that's being moved
;	DI contains adjustment factor it's being moved by
;Exit:
;	none.
;Modifies:
;	none. (no permanent registers)
;Exceptions:
;	if anything wrong with heap entry for this bd, can end up calling
;	the non-trapable "String Space Corrupt" error.
;***************************************************************************
cProc	BdAdjust,<PUBLIC,FAR,NODATA>
	parmW	pBd
cBegin	BdAdjust
	mov	bx,[pBd]
	mov	ax,[bx.BD_pb]
	cmp	ax,NULL
	jz	BdAdjust_Done

	call	B$ILHADJ		;get heap manager to do adjustment
BdAdjust_Done:
cEnd	BdAdjust
	page


;***
;BdAllocVar - Allocate a Runtime Heap entry in the variable heap
;Purpose:
;	Allocate an Interpreter-specific Heap entry from the variable heap.
;	Uses the same interface and BdAlloc (see below).
;Entry, Exit, Modifies:
;	Same as BdAlloc (see below).
;Note: Shares and exits via BdAlloc, below
;***************************************************************************
cProc	BdAllocVar,<PUBLIC,FAR,NODATA>
cBegin	<nogen>
	DbAssertRel grs.GRS_otxCONT,z,UNDEFINED,RT,<BdAllocVar: CAN continue>
	call	B$TglHeapSpt		;make variable heap the active one
cEnd	<nogen>				;fall into BdAlloc, below

;***
;BdAlloc - Allocate a Runtime Heap entry
;Purpose:
;	Allocate an Interpreter-specific Heap entry from the Runtime
;	Heap.
;	Note that this routine should ask for only the amount of space asked
;	for; growing a buffer will increase requests to some minimal block size,
;	but many buffers need to be initially allocated to some minimal 
;	(possibly zero) size.
;	NOTE: current heap manager interface demands that the owner-to-be
;	should not be subject to heap movement (i.e., not in heap, or
;	heap locked). 
;Entry:
;	parm: bd *pbdOwner - points to owner-to-be of new heap entry
;	parm: ushort cbSize - number of bytes needed
;if	NOT FV_LMEM
;	parm: char interpType - type of interp. table (IT_VALUE etc)
;endif
;Exit:
;	if entry was successfully allocated:
;	   pbdOwner->cbLogical = cbSize
;if	FV_LMEM
;	   pbdOwner->ppb = ptr to ptr to new heap entry (and is now owner)
;else
;	   pbdOwner->pb = pointer to new heap entry (and is now a heap owner)
;	   pbdOwner->cbPhysical = cbSize
;endif
;	   [AX] = TRUE (non-zero)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;Modifies:
;	none  (NOTE: DOES modify ES)
;
;***************************************************************************
cProc	BdAlloc,<PUBLIC,FAR,NODATA>,<SI>
	parmW	pbdOwner
	parmW	cbSize
	parmB	interpType
cBegin
	DbShiftLH			;ife RELEASE cause some heap movement
	DbChk	Heaps
	mov	dl,[interpType]
	mov	cx,[cbSize]
	mov	bx,[pbdOwner]
	DbChk	BdNotOwner,bx		;ensure that given bd isn't an owner now
	mov	[bx.BD_pb],NULL		;in case allocation fails and caller
					;  blindly calls BdFree with this bd
	DbOMCnt	BD_END
	xchg	bx,cx			;input order required by B$ILHALC
	inc	cx			;'owner' to heap manager is the actual
	inc	cx			;  pointer to the heap entry, not a pbd
	call	B$ILHALC		;call heap manager to allocate memory
	jc	BD_Crunch_BDs		;brif OM return; trim bd's, try again

BdAlloc_Success:
	mov	bx,[pbdOwner]		;assumes bdOwner not moved by allocation
	mov	[bx.BD_pb],si		;SI is data ptr returned from B$ILHALC
	mov	ax,[cbSize]		;save requested size as both logical
	mov	[bx.BD_cbLogical],ax	;  and physical size, and return it as
	mov	[bx.BD_cbPhysical],ax	;  our non-zero (i.e., 'TRUE') result
	mov	al,TRUE			;in case input size was zero
BD_END:
	cmp	[b$fVarHeapActive],FALSE
	jz	BdAlloc_Exit		;brif variable heap not active

	call	B$TglHeapSpt		;reactivate the local heap
BdAlloc_Exit:
cEnd

BD_Crunch_BDs:
	push	dx
	push	cx
	call	far ptr BdCompressAll	;trim bd's, compress heap space
	pop	cx
	pop	dx
	call	B$ILHALC		;try allocation again
	jnc	BdAlloc_Success		;  brif it worked this time
	xor	ax,ax			;OM error return
	jmp	short BD_END

;***
;BdFree(pbdOwner) - Release a Heap entry
;Purpose:
;	Release a Runtime Heap entry. If pbdOwner.BD_pb is NULL,
;	just return (as input wasn't really an owner).
;Entry:
;	parm: bd *pbdOwner - points to owner of new heap entry
;
;***************************************************************************
cProc	BdFree,<PUBLIC,FAR,NODATA>,<SI>
	parmW	pbdOwner
cBegin
	mov	bx,[pbdOwner]
	mov	si,[bx.BD_pb]
	cmp	si,NULL
	jz	BdFree_Exit		;brif bd isn't an owner

	mov	[bx.BD_pb],NULL
	call	B$LHDALC
BdFree_Exit:
cEnd

;***
;BdChgContents(pbd, psdNew) - Change contents of a buffer
;Purpose:
;	Change the contents of a given buffer. Note that the buffer may or
;	may not be an owner already; if it is an owner, it will be Free'd.
;	The buffer will then be allocated, and the input sd contents copied in.
;
;	NOTE: psdNew must not point into a heap entry!
;Entry:
;	parm: bd *pbd - points to current owner of heap entry
;	parm: bd *psdNew -   points to sd, contents of which are to be put
;				in the input bd.
;Exit:
;	if operation successful
;		[AX] = TRUE (non-zero)
;	else
;		[AX] = FALSE (0) (Out of memory), and the original contents
;							of the bd are lost.
;***************************************************************************
cProc	BdChgContents,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW	pbd
	parmW	psdNew
cBegin
	mov	si,[pbd]
	cCall	BdFree,<si>		;free original contents if any

	mov	di,[psdNew]
	DbChk	PtrNotInHeap,di

	mov	cx,[di.SD_cb]
	push	cx			;save across call

	push	si
	push	cx
	PUSHI	dx,IT_NO_OWNERS
	call	BdAlloc			;alloc to size of desired contents

	pop	cx
	or	ax,ax
	jz	BdChgContents_Exit	;brif OM error on allocation

	mov	ax,[si.BD_pb]
	mov	bx,[di.SD_pb]
	cCall	CopyBlk,<bx,ax,cx>	;copy sd contents into bd
BdChgContents_Exit:
cEnd

;***
;BdChgOwner(pbdOwner, pbdNew) - Change the owner of a Heap entry
;BdChgOwner_NoCopy(pbdOwner, pbdNew) - Change the owner of a Heap entry
;Purpose:
;	Change the owner of an Interpreter-specific Heap entry. If 
;	pbdOwner.BD_pb is NULL, just return (as it wasn't really an owner to 
;	begin with).
;	BdChgOwner copies the bd contents to the new bd.
;	BdChgOwner_NoCopy is provided as a speed improvement, and should be
;		called in cases where the bd has already been copied BEFORE
;		this routine is called.
;
;	NOTE: This routine is guaranteed not to cause heap movement to occur.
;
;	NOTE: This routine must be called AFTER a block containing the bd is
;		moved if such movement is to take place, because this routine
;		changes the contents of bdOwner to indicate that it's no longer
;		an owner.
;Entry:
;	parm: bd *pbdOwner - points to current owner of heap entry
;	parm: bd *pbdNew -   points to new owner of heap entry
;
;***************************************************************************
	PUBLIC BdChgOwner
BdChgOwner:
	mov	cx,SIZE BD		;non-zero - - - do the copy
	SKIP2_PSW			;skip to start of common code
	PUBLIC BdChgOwner_NoCopy
BdChgOwner_NoCopy:
	xor	cx,cx
cProc	Chg_The_Owner,<FAR,NODATA>,<SI>
	parmW	pbdOwner
	parmW	pbdNew
cBegin
	mov	si,[pbdOwner]
	cmp	[si.BD_pb],NULL
	jz	BdChg_Exit

	DbChk	BdOwner,si		;ensure that given bd is an owner

	jcxz	BdChg_CopyDone		;brif caller already did this copy

	push	si
	push	pbdNew
	push	cx			;set to SIZE BD for BdChgOwner
	call	CopyBlk
BdChg_CopyDone:
	mov	cx,[pbdNew]
	inc	cx			;to heap manager, 'owner' is the actual
	inc	cx			;  pointer to heap data, not a pbd
	push	si			;si is an input to B$LHChgBakPtr
	mov	si,[si.BD_pb]
	call	B$LHChgBakPtr
	pop	si			;so we can set bd.pb to NULL

	mov	[si.BD_pb],NULL		;mark that this is no longer an owner
BdChg_Exit:
cEnd

;***
;EnsPhysicalSize - ensure physical size of near heap >= ax
;Purpose:
;	Change physical size of an Interpreter-specific Heap entry if necessary.
;	This is used by BdGrow and BdCheckFree. 
;	Note that this is not an external entry point, only for use
;	within this module, and can thus use register calling conventions.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;Entry:
;	[di] - points to owner of heap entry
;	[ax] = new total size requested for the buffer (i.e., new minimum
;		cbPhysical desired).
;Exit:
;	if enough memory is available:
;          [ax] = TRUE (non-zero)
;	   [bx] = new value for cbLogical (i.e., [ax] exit = entry)
;	otherwise,
;	   [ax] = 0
;	
;***************************************************************************
EnsPhysicalSize PROC	NEAR
	DbChk	BdOwner,di		;ensure that given bd is an owner
	DbChk	Heaps
	push	ax			;save input requested size
	DbOMCnt Ens_End2
	cmp	ax,[di.BD_cbPhysical]
	jbe	NoChange		;branch if already big enough

	push	si			;save caller's si
	push	ax			;in case initial try fails
	sub	ax,[di.BD_cbPhysical]	;ax=amount to grow
	cmp	ax,CBBUFBLOCK
	jae	Big_Enough		;branch if growing by significant amount

	mov	ax,CBBUFBLOCK		;never grow by less than this amount
Big_Enough:
	add	ax,[di.BD_cbPhysical]	;ax=(hopefully) new cbPhysical
	push	ax			;save (hopefully) new cbPhysical
	mov	si,[di.BD_pb]
	call	B$LHREALC		;call heap manager to realloc
	pop	bx			;size we realloced to
	or	ax,ax			;test result
	jz	Ens_Crunch_BDs		;brif realloc failed

	pop	cx			;clean stack
Ens_Phy_Success:
	mov	[di.BD_cbPhysical],bx
	mov	[di.BD_pb],si		;in case realloc moved the entry
Ens_End1:
	pop	si			;restore caller's si
Ens_End2:
	pop	bx			;restore input size for retval
	ret

NoChange:
	mov	al,TRUE			;ensure TRUE return, even if passed ax=0
	jmp	short Ens_End2

EnsPhysicalSize ENDP

Ens_Crunch_BDs:
	call	far ptr BdCompressAll	;trim all bd's, compress heaps
	pop	ax			;input to B$LHREALC
	push	ax			;save for return
	mov	si,[di.BD_pb]		;may be trashed on error return
	call	B$LHREALC
	pop	bx			;cb we tried to realloc to
	or	ax,ax			;did we succeed this time?
	jz	Ens_End1		;  brif not
	jmp	short Ens_Phy_Success	;succeeded this time - - go wrap up

;***
;BdGrowVar - Grow a Runtime Heap entry in the variable heap
;Purpose:
;	Same as BdGrow (below), but for an entry in the variable heap.
;	Uses the same interface and BdGrow (see below).
;Entry, Exit, Modifies:
;	Same as BdGrow (see below).
;Note: Shares and exits via BdGrow, below
;***************************************************************************
cProc	BdGrowVar,<PUBLIC,FAR,NODATA>
cBegin	<nogen>
	DbAssertRel grs.GRS_otxCONT,z,UNDEFINED,RT,<BdlGrowVar: CAN continue>
	call	B$TglHeapSpt		;make variable heap the active one
cEnd	<nogen>				;fall into BdGrow, below

;***
;BdGrow - Increase the logical size of a Heap entry
;Purpose:
;	Change logical size of an Interpreter-specific Heap entry.  This can
;	result in the movement of this and other heap entries as well
;	as strings.  
;	When this routine actually needs to grow the physical size
;	of the heap, it grows more than needed for this request, to
;	reduce heap thrashing.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;Entry:
;	parm: bd *pbdOwner - points to owner of heap entry
;	parm: ushort cbGrow - number of bytes needed
;Exit:
;	if enough memory is available:
;	   pbdOwner->cbLogical += cbGrow,
;	   pbdOwner->cbPhysical >= pbdOwner->cbLogical
;	   [AX] = TRUE (non-zero)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************

cProc	BdGrow,<PUBLIC,FAR,NODATA>,<di>
	parmW	pbdOwner
	parmW	cbGrow
cBegin
	mov	di,[pbdOwner]		;di points to bd descriptor
	mov	ax,[cbGrow]		;[AX] == increase desired
	add	ax,[di.BD_cbLogical]	;[AX] == new logical size
	jc	GrowOmErr		;branch if overflow (can't grow > 64k)

	;*****************************
	;NOTE: BdRealloc jumps in here
	;*****************************
BdRealloc1:
	call	EnsPhysicalSize		;change physical size (inputs ax & di)
	or	ax,ax			;test boolean result
	jz	BdGrow_End		;brif out-of-memory case
	
	mov	[di.BD_cbLogical],bx	;new cbLogical - successful return
BdGrow_End:
	cmp	[b$fVarHeapActive],FALSE
	jz	BdGrow_Exit		;brif variable heap not active

	call	B$TglHeapSpt		;reactivate the local heap
BdGrow_Exit:
cEnd

GrowOmErr:
	xor	ax,ax
	jmp	short BdGrow_End

;***
;BdRealloc - Change the logical size of a Heap entry
;Purpose:
;	Change logical size of an Interpreter-specific Heap entry.  This can
;	result in the movement of this and other heap entries as well
;	as strings.  
;	When this routine actually needs to grow the physical size
;	of the heap, it grows more than needed for this request, to
;	reduce heap thrashing.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;Entry:
;	parm: bd *pbdOwner - points to owner of heap entry
;	parm: ushort cbLogicalNew - new size of heap entry
;Exit:
;	if enough memory is available:
;	   pbdOwner->cbLogical = cbLogicalNew,
;	   pbdOwner->cbPhysical >= pbdOwner->cbLogical
;	   [AX] = TRUE (non-zero)
;	else
;	   pbdOwner->cbLogical is unchanged
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************

cProc	BdRealloc,<PUBLIC,FAR,NODATA>,<di>
	parmW	pbdOwner
	parmW	cbNew
cBegin
	mov	di,[pbdOwner]		;di points to bd descriptor
	mov	ax,[cbNew]		;[AX] == increase desired
	jmp	SHORT BdRealloc1
cEnd	<nogen>

;***
;BdCheckFree - Make sure buffer has some free space
;Purpose:
;	This is identical to BdGrow, but it does not alter the
;	descriptor's cbLogical field.  Some typical cases when it is
;	called include:
;	1-  Before calling BdAppend to copy from one bd to another.
;	    By calling this first, we know BdAppend won't have to
;	    grow the heap entry, causing movement, which could invalidate
;	    BdAppend's pb argument.
;	2-  When the caller is about to do an operation which will
;	    append information to a bd, but the caller doesn't know
;	    exactly how many bytes will be added, but an upper limit is known.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;Entry:
;	parm: bd *pbdOwner - points to owner of heap entry
;	parm: ushort cbFree - number of free bytes needed
;Exit:
;	pbdOwner->cbLogical is ALWAYS UNCHANGED
;	If enough memory is available:
;	   pbdOwner->cbPhysical >= pbdOwner->cbLogical + cbFree
;	   [AX] = TRUE (non-zero)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdCheckFree,<PUBLIC,FAR,NODATA>,<DI>
	parmW	pbdOwner
	parmW	cbFree
cBegin
	mov	di,[pbdOwner]		;di points to bd descriptor
	mov	ax,[cbFree]		;[AX] == increase desired
	add	ax,[di.BD_cbLogical]	;[AX] == resulting size
	jc	CheckOmErr		;branch if overflow (can't grow > 64k)

	call	EnsPhysicalSize		;change physical size (inputs ax & di)
BdCheck_End:
cEnd

CheckOmErr:
	xor	ax,ax
	jmp	short BdCheck_End

;***
; boolean BdShiftRight(pbd, obStart, cb)
;
; Purpose:
;	Grow the buffer descriptor, and shift its contents right
;	(copying content to higher addresses) starting at offset
;	obStart until the end of the buffer.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;
; Entry:
;	parmW pbd points to the buffer descriptor
;	parmW obStart = byte offset for 1st byte to be shifted right
;	parmW cb = number of bytes each byte is to be shifted
;
; Exit:
;	If not enough memory can be obtained,
;		[AX] = FALSE
;	else
;		pbdDst->cbLogical is updated
;		[AX] = TRUE
;
;   Before BdShiftRight(pbd, 2, 2):
;	high memory 	
;	  pbd->cbLogical------->+-----+
;				|  E  |
;				|  D  |
;				|  C  |
;				|  B  |
;				|  A  |
;	low memory		+-----+
;
;   After:
;	high memory 	
;	  pbd->cbLogical------->+-----+
;				|  E  |
;				|  D  |
;				|  C  |
;				|  D  |
;				|  C  |
;				|  B  |
;				|  A  |
;	low memory		+-----+
;
;***************************************************************************
cProc	BdShiftRight,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW pbd
	parmW obStart
	parmW cb
cBegin
	push	pbd
	push	cb
	call	BdCheckFree		;1st grow the buffer
	or	ax,ax
	je	BdShiftExit		;branch if out-of-memory, return 0
	mov	bx,pbd			;bx -> descriptor
	mov	cx,[bx.BD_cbLogical]	;[CX] = current size of buffer
	mov	si,[bx.BD_pb]		;si points to start of buffer
	add	si,cx			;si points beyond end of current content
	dec	si			;si points to 1st byte to copy
	mov	di,si
	mov	ax,cb
	add	di,ax			;di points to dst for 1st byte to copy
	add	[bx.BD_cbLogical],ax	;update size of buffer
	sub	cx,obStart		;[CX] = number of bytes to copy
	jcxz	Copy0Bytes
	push	ds
	pop	es			;es=ds
	std				;copy from high to low address
	rep movsb			;do the block copy
	cld
Copy0Bytes:
	mov	ax,TRUE
BdShiftExit:
cEnd

;***
; boolean BdShiftLeft(pbd, obStart, cb)
;
; Purpose:
;	Shrink the buffer descriptor, and shift its contents left
;	(copying content to lower addresses) starting at offset
;	obStart until the end of the buffer.
;
; Entry:
;	parmW pbd points to the buffer descriptor
;	parmW obStart = byte offset for 1st byte to be deleted
;	parmW cb = number of bytes to be deleted
;
; Exit:
;	pbdDst->cbLogical is updated
;	no return value
;
;   Before BdShiftLeft(pbd, 2, 2):
;	high memory 	
;	  pbd->cbLogical------->+-----+
;				|  E  |
;				|  D  |
;				|  C  |
;				|  B  |
;				|  A  |
;	low memory		+-----+
;
;   After:
;	high memory 	
;	  pbd->cbLogical------->+-----+
;				|  E  |
;				|  B  |
;				|  A  |
;	low memory		+-----+
;
;***************************************************************************
cProc	BdShiftLeft,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW pbd
	parmW obStart
	parmW cb
cBegin
	mov	bx,pbd			;bx -> descriptor
	mov	di,[bx.BD_pb]		;di points to start of buffer
	add	di,obStart		;di points to 1st byte to delete
	mov	si,di
	add	si,cb			;si points beyond last byte to delete
	mov	cx,[bx.BD_cbLogical]	;[CX] = current size of buffer
	sub	cx,cb			;cx = new size of buffer
	mov	[bx.BD_cbLogical],cx	;update descriptor
	sub	cx,obStart		;cx = # bytes to copy
	jcxz	LeftExit		;brif 0 bytes to copy
	push	ds
	pop	es			;es=ds
	rep movsb			;do the block copy
LeftExit:
cEnd

;***
; boolean BdAppend(pbdDst, pbSrc, cb)
;
; Purpose:
;	Append a string of bytes to a Buffer Descriptor.
;	If this is preceeded by a call to BdCheckFree(pbdDst, cb)
;	then pbSrc can point within another heap entry with no
;	fear of movement before the copy is complete.  Otherwise,
;	pbSrc had better not point within a heap entry.
;
;	NOTE: current heap manager interface demands that the owner
;	should not be subject to heap movement. 
;
; Entry:
;	parmW pbdDst points to the destination buffer descriptor
;	parmW pbSrc points to 1st byte to be copied into buffer
;	parmW cb = number of bytes to be copied
;
; Exit:
;	If not enough memory can be obtained,
;		[AX] = FALSE
;	else
;		pbdDst->cbLogical is updated
;		[AX] = TRUE
;
;***************************************************************************
cProc	BdAppend,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW pbdDst
	parmW pbSrc
	parmW cb
	localW pbDst
	localW cbTemp
cBegin
	push	pbdDst
	push	cb
	call	BdCheckFree
	or	ax,ax
	je	BdAppendExit		;branch if out-of-memory, return 0
	mov	cx,cb			;[CX] = # bytes to copy
	mov	di,pbdDst		;di -> destination descriptor
	mov	ax,[di.BD_cbLogical]	;ax = current size of buffer
	add	[di.BD_cbLogical],cx	;update size of buffer
	mov	di,[di.BD_pb]		;di points to start of dest buffer
	add	di,ax			;add new bytes at end of buffer
	mov	si,pbSrc		;si = source byte ptr
	push	ds
	pop	es			;es=ds
	rep movsb			;do the block copy
	mov	ax,TRUE
BdAppendExit:
cEnd


;-----------------------------------------------------------------
;---   Large Far Heap Buffer Descriptor Management Routines    ---
;-----------------------------------------------------------------


FAR_EXTRA = 512		;never grow a far heap entry by less than 512 bytes

;***
;AllocBdl - Allocate a Far Heap entry (workhorse for BdlAlloc)
;AllocBdl_Sb - same, but allocates a given sb for this
;Purpose:
;	Allocate a Heap entry from the Far Heap.  This can cause
;	movement of Runtime and String heap entries.
;	Note that this routine should ask for only the amount of space asked
;	for; growing a buffer will increase requests to some minimal block size,
;	but many buffers need to be initially allocated to some minimal 
;	(possibly zero) size.
;Entry:
;	di = pbdlOwner - points to owner of new heap entry
;	si = cbSize - number of bytes needed
;	For EB versions, bx = type constant for type of bdl buffer
;	For AllocBdl_Sb, cx = sb to use
;Exit:
;	if entry was successfully allocated:
;	   pbdlOwner->cbLogical = cbSize
;	   pbdlOwner->cbPhysical = cbSize
;	   [AX] = TRUE (non-zero)
;	   pbdlOwner->status != NOT_OWNER
;	else
;	   [AX] = FALSE (0) (Out of memory)
;	PSW.Z is set on exit based on an 'OR AX,AX' instruction
;
;***************************************************************************
cProc	AllocBdl,<NEAR,NODATA>
cBegin	<nogen>
	mov	cx,0			; use any sb that's free
cEnd	<nogen>
cProc	AllocBdl_Sb,<NEAR,NODATA>
cBegin
	mov	ax,si

	DbAssertRel ax,be,0FFF0H,RT,<BdlAlloc: caller asked for more than FFF0H>
	;The above assertion is based on the problem where a request to
	;   B$IFHAlloc for greater than 0FFF0H bytes will be rounded UP to past
	;   64k, with no error reported.
	xor	dx,dx			;DX:AX is input size to B$IFHAlloc
	mov	bx,di
	DbChk	BdlNotOwner,di
	mov	[bx.BDL_cbLogical],ax
	call	B$IFHAlloc		;allocate a far heap entry (0 if can't)
	or	ax,ax			;set zero flag for caller
cEnd	AllocBdl


;***
;BdlAlloc - Allocate a Far Heap entry
;Purpose:
;	Allocate a Heap entry from the Far Heap.  This can cause
;	movement of Runtime and String heap entries.
;	Note that this routine should ask for only the amount of space asked
;	for; growing a buffer will increase requests to some minimal block size,
;	but many buffers need to be initially allocated to some minimal 
;	(possibly zero) size.
;
;	[5] Note that at least some callers depend on the new block being zero-
;	[5] filled (EB varmgr code, for one).
;Entry:
;	parm: bdl *pbdlOwner - points to owner of new heap entry
;	parm: ushort cbSize - number of bytes needed
;Exit:
;	if entry was successfully allocated:
;	   pbdlOwner->cbLogical = cbSize
;	   pbdlOwner->cbPhysical = cbSize
;	   [AX] = TRUE (non-zero)
;	   pbdlOwner->status != NOT_OWNER
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdlAlloc,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	pbdlOwner
	parmW	cbSize
cBegin
	DbOMCnt	BdlAlloc_Exit
	mov	di,[pbdlOwner]
	mov	si,[cbSize]
	cCall	AllocBdl
	jnz	BdlAlloc_Exit		;brif success

	call	far ptr BdCompressAll	;trim bd's, compress heap space
	cCall	AllocBdl
BdlAlloc_Exit:
cEnd

;***
;BdlAllocSb - Allocate a Far Heap entry, given a desired sb
;Purpose:
;	Same as BdlAlloc, but accepts as a third parm the sb value that
;	is to be used.
;	Added as revision [13].
;Entry:
;	parm: bdl *pbdlOwner - points to owner of new heap entry
;	parm: ushort cbSize - number of bytes needed
;	parm: ushort sbInput - sb we must use for this allocation
;			(caller guarantees this is unallocated).
;Exit:
;	if entry was successfully allocated:
;	   pbdlOwner->cbLogical = cbSize
;	   pbdlOwner->cbPhysical = cbSize
;	   [AX] = TRUE (non-zero)
;	   pbdlOwner->status != NOT_OWNER
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdlAllocSb,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	pbdlOwner
	parmW	cbSize
	parmW	sbInput
cBegin
	DbOMCnt BdlAllocSb_Exit
	mov	di,[pbdlOwner]
	mov	si,[cbSize]
	mov	cx,[sbInput]		
	cCall	AllocBdl_Sb
BdlAllocSb_Exit:
cEnd

;***
;BdlFree - Release a far Heap entry
;Purpose:
;	Release a far Heap entry. If bdl is not an owner, this routine just
;	returns, with no error.
;Entry:
;	parm: bdl *pbdlOwner - points to owner of new heap entry
;Exit:
;	bdl is released; pbdlOwner->status = NOT_OWNER
;
;***************************************************************************
cProc	BdlFree,<PUBLIC,FAR,NODATA>
	parmW	pbdlOwner
cBegin
	mov	bx,[pbdlOwner]
	cmp	[bx.BDL_status],NOT_OWNER
	jz	BdlFree_Exit		;brif bdl already free

	DbChk	BdlOwner,bx		;ensure that given bdl is an owner
	push	bx
	call	B$FHDealloc		;free an allocated far heap entry
	pop	bx
	mov	[bx.BDL_status],NOT_OWNER ;indicate that bdl is not an owner
BdlFree_Exit:
cEnd

;***
;BdlChgOwner(pbdlOwner, pbdlNew) - Change the owner of a Far Heap entry
;Purpose:
;	Change the owner of a Far Heap entry. If pbdlOwner.BDL_status is 
;	NOT_OWNER, just return (as it wasn't really an owner to begin with).
;
;	NOTE: This routine is guaranteed not to cause heap movement to occur.
;
;	NOTE: This routine must be called AFTER a block containing the bdl is
;		copied, as the far heap manager modifies the FHD according to
;		its original location. This copy MUST be done by the caller
;		prior to this routine being called.
;		Note also that it is NOT safe to block copy a range containing
;		multiple bdl's and then call this routine once per bdl - - -
;		Since the far heap code chains all bdl's together, a call to
;		BdlChgOwner can cause another bdl to be modified (in the 
;		'status' a.k.a. 'pNext' field).
;Entry:
;	parm: bdl *pbdlOwner - points to current owner of far heap entry
;	parm: bdl *pbdlNew -   points to new owner of far heap entry
;Exit:
;	none.
;
;***************************************************************************
cProc	BdlChgOwner,<PUBLIC,FAR,NODATA>,<SI>
	parmW	pbdlOwner
	parmW	pbdlNew
cBegin
	mov	si,[pbdlOwner]
	cmp	[si.BDL_status],NOT_OWNER
	jz	BdlChg_Exit		;brif bdl wasn't an owner

	DbChk	BdlOwner,si		;ensure that bdlOwner is an owner

	mov	dx,si			;pFHD for FHD that's being moved
	mov	cx,[pbdlNew]
	sub	cx,si			;cx = pNew - pOld (adjustment factor)
	call	B$FHAdjOneDesc

	mov	[si.BDL_status],NOT_OWNER
BdlChg_Exit:
cEnd

;***
;BdlRealloc - reallocate a Far Heap entry
;Purpose:
;	reallocate a Heap entry from the Far Heap.  This can cause
;	movement of String and Runtime heap entries.
;
;	[5] Note that at least some callers depend on additional space being
;	[5] zero-filled (EB varmgr code, for one).
;Entry:
;	parm: bdl *pbdlOwner - points to owner of heap entry
;	parm: ushort cbNew - new buffer size desired
;Exit:
;	if entry was successfully reallocated:
;	   pbdlOwner->cbLogical = cbNew
;	   pbdlOwner->cbPhysical >= cbNew
;	   [AX] = TRUE (non-zero)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdlRealloc,<PUBLIC,FAR,NODATA>,<di>
	parmW	pbdlOwner
	parmW	cbNew
	localB	fTryAgain
cBegin
	mov	[fTryAgain],TRUE
	DbOMCnt	BdlRealloc_Exit
	mov	di,[pbdlOwner]
	mov	bx,[di.BDL_cPhysical]
	SHIFT	H,L,bx,4		;shift left to convert cPara to cbytes
	mov	ax,[cbNew]
	cmp	bx,ax
	jae	Change_cbLogical	;brif physical size is big enough

	cmp	ax,0FFE0H		;if ask far heap for > FFE0H, it will
					;  round request up to para boundary ...
	jbe	BdlRealloc_Cont		;brif request not too large

	xor	ax,ax			;Out of Memory return
	jmp	short BdlRealloc_Exit

BdlRealloc_Crunch:
	cmp	[fTryAgain],FALSE
	jz	BdlRealloc_Exit		;brif we've already tried this - give up

	mov	[fTryAgain],FALSE	;remember this is the 2nd attempt
	call	far ptr BdCompressAll	;trim all bd's, compress heaps,
	mov	ax,[cbNew]		;and try again w/o blocking factor
	jmp	short BdlRealloc_Cont1

BdlRealloc_Cont:
	add	ax,FAR_EXTRA		;ax = ax + FAR_EXTRA to reduce thrashing
	;Under DOS 3, we know the heap manager actually allocates in 16-byte
	;  (paragraph) quantities, so to ensure we don't waste an average of
	;  8 bytes per bdl, pay a few bytes of code here to round up
	jc	RealcForMax		;brif this puts us over 64k

BdlRealloc_Cont1:
	add	ax,000FH		;constant for rounding up to paragraph
	jnc	TryToRealloc		;brif still under 64k

RealcForMax:
	mov	ax,0FFE0H		; try for maximum - - - note that
					;'maximum' can't be FFFFH, because
					;the far heap code will round this
					;up to the nearest paragraph boundary
TryToRealloc:
	and	al,0F0H 		;[9] finish rounding size up to para
	mov	dx,0FFE0H		
	cmp	ax,dx			; is result > legal max?
	jbe	ReallocAttempt		; brif not

	xchg	ax,dx			
ReallocAttempt:
	DbChk	BdlOwner,di		;ensure that bdlOwner is an owner
	xor	dx,dx
	mov	bx,di
	call	B$FHRealloc
	or	ax,ax
	jz	BdlRealloc_Crunch	;brif insufficient memory
	mov	ax,[cbNew]		;requested size
Change_cbLogical:
	mov	[di.BDL_cbLogical],ax	;save new logical size
	mov	ax,sp			;signal success (cbNew could be zero ..)
BdlRealloc_Exit:
cEnd

;***
;BdlCheckFree - Make sure far heap entry has some free space
;Purpose:
;	Change size of a far Heap entry if necessary to
;	ensure that there is a certain number of free bytes at the
;	end of the entry.  This can result in the movement of this
;	and other heap entries.
;	This routine does not work with HUGE heap entries (i.e. > 64k)
;Entry:
;	parm: bdl *pbdlOwner - points to owner of heap entry
;	parm: ushort cbFree - number of free bytes needed
;Exit:
;	If enough memory is available:
;	   pbdlOwner->cbLogical is unchanged
;	   pbdlOwner->cbPhysical >= pbdlOwner->cbLogical + cbFree
;	   [AX] = TRUE (non-zero) (successful return)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdlCheckFree,<PUBLIC,FAR,NODATA>,<di>
	parmW	pbdlOwner
	parmW	cbFree
cBegin
	DbOMCnt	BdlCheckFreeExit
	mov	di,[pbdlOwner]
	mov	ax,[di.BDL_cPhysical]	;ax = current physical size
	SHIFT	H,L,ax,4		;shift left to convert cPara to cbytes
	push	ax
	sub	ax,[di.BDL_cbLogical]	;ax = current free size
	sub	ax,cbFree		;ax = new free size
	jnc	SizeIsOk		;brif we're already big enough

	neg	ax
	pop	bx
	add	ax,bx			;ax = minimum new free size
	jc	BdlCheckDenied		;error if attempting to grow > 64k

	push	[di.BDL_cbLogical]	;save this across call to BdlRealloc
	cCall	BdlRealloc,<di,ax>
	pop	[di.BDL_cbLogical]
BdlCheckFreeExit:
cEnd

BdlCheckDenied:
	xor	ax,ax			;return ERROR result (zero)
	SKIP1_PSW			;this 'eats' the next instruction
SizeIsOk:
	pop	ax			;cPhysical known to be non-zero
	jmp	short BdlCheckFreeExit

;***
;BdlGrow - Increase the logical size of a Heap entry
;Purpose:
;	Change logical size of a bdl.  This can result in the movement of this
;	and other heap entries.
;	When this routine actually needs to grow the physical size
;	of the bdl, it grows more than needed for this request, to
;	reduce heap thrashing.
;
;	Added as part of revision [9].
;Entry:
;	parm: bd *pbdlOwner
;	parm: ushort cbGrow - number of additional bytes needed
;Exit:
;	if enough memory is available:
;	   pbdlOwner->cbLogical += cbGrow,
;	   pbdlOwner->cPhysical increased to account for >= cbLogical bytes
;	   [AX] = TRUE (non-zero)
;	else
;	   [AX] = FALSE (0) (Out of memory)
;
;***************************************************************************
cProc	BdlGrow,<PUBLIC,FAR>
	parmW	pbdlOwner
	parmW	cbGrow
cBegin
	mov	bx,[pbdlOwner]
	mov	ax,[cbGrow]
	add	ax,[bx.BDL_cbLogical]
	cCall	BdlRealloc,<bx,ax>
cEnd

;***
;BdlCopyFrom - Copy data from a far Heap entry to DS
;Purpose:
;	Copy data from a far Heap entry to DS
;	Does not work with HUGE heap entries (i.e. > 64k)
;Entry:
;	parm: bdl *pbdlOwner - points to owner of new heap entry
;	parm: ushort oSrc - 16 bit offset into bdl to source
;	parm: char *pbDst - points to 1st byte of destination
;	parm: ushort cb - number of bytes to copy
;
;***************************************************************************
cProc	BdlCopyFrom,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	pbdlOwner
	parmW	oSrc
	parmW	pbDst
	parmW	cb
cBegin
	mov	si,[oSrc]		;si = source offset
	mov	di,[pbDst]		;di = destination offset
	mov	bx,[pbdlOwner]
	DbChk	BdlOwner,bx		;ensure that bdlOwner is an owner
	GETSEG	ax,[bx.BDL_seg],,<SIZE,LOAD> ;[4] seg of far heap entry
	mov	bx,ds			;bx -> DGROUP
	mov	ds,ax			;set up source seg (heap entry)
	mov	es,bx			;set up destination seg (DGROUP)
CopyCommon:
	mov	cx,cb			;cx = byte count
	shr	cx,1			;convert to word count
	rep	movsw			;transfer from ds:si to es:di
	jnc	CopyFrom_Even		;no carry if count was even
	movsb				;move the last (odd) byte
CopyFrom_Even:
	mov	ds,bx			;restore ds->DGROUP
cEnd

;***
;BdlCopyTo - Copy data from DS into a far Heap entry
;Purpose:
;	Copy data from DS into a far Heap entry
;	Does not work with HUGE heap entries (i.e. > 64k)
;Entry:
;	parm: bdl *pbdlOwner - points to owner of new heap entry
;	parm: ushort oDst - 16 bit offset into bdl to destination
;	parm: char *pbSrc - points to 1st byte of source
;	parm: ushort cb - number of bytes to copy
;
;***************************************************************************
cProc	BdlCopyTo,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	pbdlOwner
	parmW	oDst
	parmW	pbSrc
	parmW	cb
cBegin
	mov	si,[pbSrc]		;si = source offset
	mov	di,[oDst]		;di = destination offset
	mov	bx,[pbdlOwner]
	DbChk	BdlOwner,bx		;ensure that bdlOwner is an owner
	GETSEG	ax,[bx.BDL_seg],,<SIZE,LOAD> ;[4] seg of far heap entry
	mov	es,ax			;set up destination seg
	mov	bx,ds
	jmp	short CopyCommon
cEnd	nogen


;***
;BdlCopyFromTo - Copy data from one bdl to another
;Purpose:
;	Copy data from one far heap entry into another.
;	Does not work with HUGE heap entries (i.e. > 64k)
;
;	Added as part of revison [7]
;Entry:
;	parm: bdl *pbdlSrc - points to source bdl
;	parm: ushort oSrc - 16 bit offset into bdl to source
;	parm: bdl *pbdlDst - points to destination bdl
;	parm: ushort oDst - 16 bit offset into bdl to destination
;	parm: ushort cb - number of bytes to copy
;Exit:
;	none.
;***************************************************************************
cProc	BdlCopyFromTo,<PUBLIC,FAR,NODATA>,<si,di,ds>
	parmW	pbdlSrc
	parmW	oSrc
	parmW	pbdlDst
	parmW	oDst
	parmW	cb
cBegin
	mov	si,[pbdlDst]		
	DbChk	BdlOwner,si		;ensure that bdlDst is an owner
	GETSEG	dx,[si.BDL_seg],,<SIZE,LOAD>  
					; dx = seg of far heap entry (dst)
	mov	bx,[pbdlSrc]
	DbChk	BdlOwner,bx		;ensure that bdlSrc is an owner
	GETSEG	ds,[bx.BDL_seg],,<SIZE,LOAD,NOFLUSH>	
					; ds = seg of far heap entry (src)
assumes DS,NOTHING
	mov	es,dx			
	mov	si,[oSrc]		;si = source offset
	mov	di,[oDst]		;di = destination offset
	mov	cx,[cb]
	shr	cx,1			;convert to word count
	rep	movsw			;transfer from ds:si to es:di
	jnc	CopyFrom_Even2		;no carry if count was even
	movsb				;move the last (odd) byte
CopyFrom_Even2:
cEnd
assumes DS,DATA


;***
;BdlTrim - trim given bdl down to cbLogical
;Purpose:
;	Releases excess space in a given bdl
;Entry:
;	parm: bdl *pbdl
;
;***************************************************************************
cProc	BdlTrim,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	pbdl
cBegin
	mov	bx,[pbdl]
	DbChk	BdlOwner,bx		;ensure that bdlOwner is an owner
	mov	ax,[bx.BDL_cbLogical]	;size to realloc to
	xor	dx,dx
	call	B$FHRealloc		;must succeed; we're either reducing
					;  or asking for existing entry size
cEnd


;seg_rt = segment address for the RT segment
;It can be referenced from any module as follows:
	;	EXTRN	seg_rt:abs
	;	mov	ax,SEG seg_rt
	
	PUBLIC	seg_rt
	seg_rt	EQU	SEG BdlTrim

sEnd	RT


;------------------------------------------------------------
;---  Interpreter Buffer Descriptor Management Routines   ---
;------------------------------------------------------------
sBegin	DATA
	staticB	bdGrabSpace,NULL,<SIZE BD>
sEnd	DATA

sBegin 	CODE
assumes	CS,CODE

CBNEAR_GRAB equ 2 * CBBUFBLOCK

;***
;GrabSpace - grab some heap space
;Purpose:
;	Allocates CBNEAR_GRAB bytes via BdAlloc. 
;	Called to lock up a chunk of heap space so we ensure that
;	enough space exists to do simple things like CLEAR for more memory!
;
;	NOTE: It's important that grabspace just grab space from the near
;		heap, not the far heap; if we grabbed far space instead,
;		this could allow the user to tie up all of DGROUP with
;		variable tables with plenty of DGROUP space free.
;Entry:
;	none.
;Exit:	
;	ax = 0 if insufficient memory, else ax != 0
;***************************************************************************
cProc	GrabSpace,<PUBLIC,FAR,NODATA>
cBegin
	mov	ax,[bdGrabSpace.BD_pb]
	or	ax,ax
	jnz	GotSpace		;return ax<>0 if already have space
	PUSHI	ax,<dataOFFSET bdGrabSpace>
	PUSHI	ax,CBNEAR_GRAB
	PUSHI	ax,IT_NO_OWNERS
	call	BdAlloc
	or	ax,ax
GotSpace:
cEnd

;***
;ReleaseSpace - Release the space grabbed by GrabSpace
;Purpose:
;	Deallocates the bd allocated by GrabSpace if it is currently allocated.
;	Note that it's perfectly o.k. to call this even when no space has
;	been grabbed.
;Entry:
;	none.
;Exit:
;	ax = 0.
;***************************************************************************
cProc	ReleaseSpace,<PUBLIC,FAR,NODATA>
cBegin
	PUSHI	ax,<dataOFFSET bdGrabSpace>
	call	BdFree			;deallocate bd if couldn't allocate bdl
cEnd

sEnd	CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\debug.c ===
/*** 
*debug.c - utility routines for internal debugging of the interpreter
*
*	Copyright <C> 1986, Microsoft Corporation
*
*Purpose:
*	This module provides general purpose utilities for writing internal
*	debugging and other non-release code for the interpreter.
*
*******************************************************************************/
#include "version.h"

#if !CONTEXT_H
#include "context.h"
#endif

#if !HEAP_H
#include "heap.h"
#endif

#if !TXTMGR_H
#include "txtmgr.h"
#endif

#if !VARIABLE_H
#include "variable.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\condebug.c ===
/*** 
*condebug.c - non-release code to validate context.asm
*
*  Copyright <C> 1986, Microsoft Corporation
*
*Purpose:
*  contains routines used for debugging the context manager.
*
*******************************************************************************/
#include "version.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\context.asm ===
TITLE	context.asm - context manager

;***
;context.asm - context manager for the Quick Basic Interpreter
;
;	Copyright <C> 1986, 1987 Microsoft Corporation
;
;Purpose:
;   -  Creation and Deletion of entries in the Module and Procedure Register Set
;       tables.
;   -  Swapping module and procedure register sets between the global table
;	of Rs's and the static current working register sets 'mrsCur' and
;       'prsCur'.
;
;   Note: static handling of Procedure Register Sets is performed by this
;		module; frame (per invocation) handling is performed by
;		the Procedure Manager.
;
;
;******************************************************************************

	.xlist

	include version.inc
	CONTEXT_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	conint
	includeOnce	heap
	includeOnce	names
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	parser
	includeOnce	sb			
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	util
	includeOnce	variable
	includeOnce edit			

	.list

	assumes CS,CP
	assumes DS,DATA
	assumes SS,DATA
	assumes ES,NOTHING


sBegin	DATA
	globalB	conFlags,F_CON_StaticStructs	;static bit flags
	staticB	fCouldBeBogusPrs,FALSE		;TRUE if there's a possiblity of
	staticW	oRsTest,UNDEFINED		;For use in ValidORs
	globalW	oRsDupErr,0			;MrsMake and PrsMake tell
						; caller duplicate oRs
	globalW	oPrsFirst,UNDEFINED		; head of prs chain in tRs
	staticW	oFreePrsFirst,UNDEFINED		; head of free prs chain
	staticW	oFreeMrsFirst,UNDEFINED		; head of free mrs chain

sEnd	DATA

	extrn	B$ClearRange:FAR		;clears all owners in given rg



sBegin CP

;==============================================================================
;Notes On mrs and prs structures:
;	There is a single global table which contains both mrs and prs
;	structures. The first entry in this table MUST be the global mrs
;	(code exists which assumes the oMrs for the global mrs is OMRS_GLOBAL).
;	We also assume that, if there is an empty unnamed mrs, it is the 
;	very next struct in the table after the global mrs.
;
;	All mrs valid mrs entries are chained from this entry via the
;	oMrsNext entry; UNDEFINED marks the end of the chain.
;	Prs's are similarly chained together, with the global 'oPrsFirst'
;	pointing to the first prs.   It is NOT safe to assume that these
;	chains relate to table position; the only safe way to walk the
;	Rs table in any way is via the appropriate chain.
;
;	Table entries are fixed in place; oRs/oMrs/oPrs's are known and
;	saved outside of this component, so an mrs or prs can never move
;	within this structure. If an entry is discarded, it is added to
;	a free chain, for later re-use. Since mrs and prs structs are of
;	different size, there are two free chains; oFreePrsFirst and
;	oFreeMrsFirst are the head pointers for these chains.
;
;	Note that when an mrs or prs is 'active' (i.e., copied to mrsCur/
;	prsCur) the copy in the table should not be referenced or modified
;	but that entry remains linked in place. Care should be taken when
;	updating an Rs chain to consider the active prs and/or mrs, i.e.,
;	mrsCur and prsCur are not and cannot be linked in an rs chain.
;	
;	The actual first entries in the mrs & prs structs are the count of
;	frame temps and frame vars allocated for each instance of that
;	module or procedure. There are definite dependancies on the fact
;	that these are in the same spot in the mrs & prs structs.
;
;	For all prs's, there is guaranteed to be a name table entry for the 
;	prs name. This eliminates some OM_ERR checking when obtaining the oNam 
;	of a prs (generally via FieldsOfPrs).
;
;	At execution time, the heap-update & block copy time required by the
;	normal context switching code is too slow for CALL speed. For this
;	reason, whenever program execution is started, DisStaticStructs is
;	called to set a static flag and deactivate mrsCur, prsCur, and txdCur.
;	At execution time (only), a couple of grs fields are used to allow
;	for quickly fetching the segment address of the current text table.
;	Note that whenever this flag (F_CON_StaticStructs) is reset (FALSE), 
;	the mrsCur and prsCur structures contain garbage; only the oMrsCur, 
;	oPrsCur, and oRsCur fields in grs can be used to access current 
;	context information.
;
.errnz	SIZE MRS AND 1
.errnz	SIZE PRS AND 1
;	The two assertions above are based on the procedure manager depending
;	on an oRs always being an even number (so the low bit can be used
;	as a boolean in a special case). For oRs's to always be even, mrs
;	and prs structs must in turn both be even.
;	
;==============================================================================


;##############################################################################
;#									      #
;#			  Initialization Functions			      #
;#									      #
;##############################################################################

sEnd	CP				;initialization code goes in RARE seg
sBegin	RARE
	assumes CS,RARE

;***
;InitContext()
;
;Purpose:
;    This function is called once during BASIC initialization to initialize:
;     - the global register set (grs)
;     - the Rs table (grs.bd[l]Rs), mrsCur, and the global mrs via MrsMake
;Entry:
;	none.
;Exit:
;	grs, mrsCur initialized.
;	ax = 0 if no error, else		[18]
;	ax = standard error code.		[18]
;	PSW flags set up based on an OR AX,AX	[18]
;*******************************************************************************
cProc	InitContext,<NEAR,PUBLIC,NODATA>	
cBegin	InitContext
	mov	ax,dataOFFSET grs	;ax == pointer to global 'grs' struct
	mov	bx,SIZE GRSTYPE		;bx == size of 'grs' struct
	mov	cx,GRS_CB_ZERO_INIT	;cx == cb @ start of grs to 0-fill
	push	ax			; parm to ZeroFill
	push	cx			; parm to ZeroFill

	shr	bx,1			; convert cbStruct to cwStruct
	cCall	FillUndef,<ax,bx>	; fill whole struct with UNDEFINED
	cCall	ZeroFill		; fill first 'cbZeroes' with zeroes

	PUSHI	ax,<dataOFFSET grs.GRS_bdlDirect>
	PUSHI	ax,CB_PCODE_MIN 	;it must never be < CB_PCODE_MIN bytes
	PUSHBDL_TYPE  pgtypEBPcode,ax	; pass sb type for EB version
	call	BdlAlloc		;allocate direct mode buffer (far heap)
	or	ax,ax
	DJMP	jz	OM_Err_In_Init	
	PUSHI	ax,<dataOFFSET grs.GRS_bdRs>
	PUSHI	ax,0
	PUSHI	ax,IT_MRS
	call	BdAlloc 		;allocate table of register sets
	or	ax,ax
	jz	OM_Err_In_Init

	PUSHI	ax,OGNAM_GMRS		; make global module
	PUSHI	ax,<100h * FM2_File>

	call	far ptr MrsMake		; make initial (untitled) mrs 
	or	ax,ax			
	jnz	InitContext_Exit	; return error code to caller

	call	far ptr MakeInitMrs	;make initial mrs, ax=errCode
	; just pass retval to caller for non FV_QB4LANG case
	or	ax,ax			
	jnz	InitContext_Exit	

	PUSHI	ax,<dataOFFSET grs.GRS_bdtComBlk>
	PUSHI	ax,0
	PUSHI	ax,IT_COMMON_BLOCK
	call	BdAlloc			;allocate table of common blocks
	or	ax,ax
	jz	OM_Err_In_Init

	PUSHI	ax,UNDEFINED
	call	MakeCommon		;allocate table(s) for blank common
	inc	ax			;UNDEFINED returned if OM error
	.errnz	UNDEFINED - 0FFFFH
	jz	OM_Err_In_Init

	DbAssertRel ax,z,1,RARE,<InitContext: Unnamed block not at offset 0>
	mov	[grs.GRS_fDirect],al	;so UserInterface() thinks opEot was
					;from direct mode buffer
	sub	ax,ax			; retval; 0 == 'no errors'
InitContext_Exit:			
	or	ax,ax			
cEnd	InitContext

OM_Err_In_Init:
	mov	ax,ER_OM		
	jmp	short InitContext_Exit	

sEnd	RARE
sBegin	CP
	assumes CS,CP



;##############################################################################
;#									      #
;#	  	Context Manager Functions Common to mrs's and prs's	      #
;#									      #
;##############################################################################

;***
;InitStruct
;
;Purpose:
;	This function is designed to initialize a structure by filling
;	it partly with UNDEFINED words, and partly with zeroes. The input
;	pointer is to the start of the structure, and the input count
;	is for the number of zeroes to fill in at the beginning of the
;	structure, after first filling the entire structure with UNDEFINED.
;	The result is a structure with the first cbZeroes bytes initialized
;	to zero, the remainder filled with UNDEFINED.
;
;	Made NEAR in CP (moved from RARE) as part of revision [17].
;Entry:
;	ax = pStruct -	pointer to the start of the structure.
;	bx = cbStruct -	count of bytes in the structure
;	cx = cbZeroes -	count of bytes to fill (@ start of struct) w/0
;Exit:
;	none.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
InitStruct PROC	NEAR
	push	ax			;parm to ZeroFill
	push	cx			;parm to ZeroFill

	shr	bx,1			;convert cbStruct to cwStruct
	cCall	FillUndef,<ax,bx>	;fill whole struct with UNDEFINED
	cCall	ZeroFill		;fill first 'cbZeroes' with zeroes
	ret
InitStruct ENDP

;***
;MrsTableEmpty - see if there are any mrs entries
;
;Purpose:
;	This function is called to check to see if there are any active 
;	mrs entries in tRs.
;	We ignore any text mrs's, i.e., if the only mrs's in the table are for 
;	text objects (rather than for modules), say that the table is empty. 
;	Also ignore the global mrs.
;
;	NOTE: it is assumed that this routine will only be called when there
;		is no current entry, i.e., grs.oMrsCur is UNDEFINED. 
;
;Entry:
;	es set to rs table segment
;Exit:
;	PSW.Z set if table empty, clear if it has one or more active entries.
;	if table not empty, bx = oMrs for active entry.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	MrsTableEmpty,<NEAR>,<ES>
cBegin	MrsTableEmpty
	GETRS_SEG   es,bx,<SIZE,LOAD>	
	mov	bx,OMRS_GLOBAL		; es:bx points to the global mrs
					;  (ignore the global mrs)
	RS_BASE  add,bx 		;add base of tRs to bx
Walk_Loop:
	mov	bx,PTRRS[bx.MRS_oMrsNext] ;advance to next mrs
	inc	bx			;end of chain?
	.errnz	UNDEFINED - 0FFFFH
	jz	Exit_Table_Walk		;  brif so - - - no module mrs's found
	dec	bx

	RS_BASE  add,bx 		;add base of tRs to bx
	test	BPTRRS[bx.MRS_flags2],FM2_Include
	jnz	Walk_Loop		;brif found an include file - ignore
	test	BPTRRS[bx.MRS_flags2],FM2_NoPcode
	jnz	Walk_Loop		;brif active mrs found for a non-file 
					;  mrs (ignore it)
	RS_BASE  sub,bx 		;subtract base of tRs from bx
	or	sp,sp			;clear PSW.Z
Exit_Table_Walk:
cEnd	MrsTableEmpty

;***
;RsTableSearch - search the Rs table
;
;Purpose:
;	This function is shared by mrs-specific and prs-specific code to
;	search for a matching structure entry. 'procType' (ax input value) 
;	indicates whether we're to search the mrs or prs chain; in addition, 
;	it cues us in on additional search logic needed in the case we're to 
;	search for a DEF FN (must then also match oMrs and oTyp).
;	
;	[10] This shared routine is only possible so long as the ogNam fields
;	[10] are in the same place relative to the start of prs & mrs structs,
;	[10] and the ogNam field of an valid prs or mrs entry can never be 
;	[10] UNDEFINED (which is the signal that an entry is active,
;	[10] and is thus a 'hole' in the table).
;	[10] Also, note that a special case (mrs chain only) exists where
;	[10] an "untitled" entry can exist, whose ogNam field will be 
;	[13] OGNAM_UNNAMED.
;
;	[10] Note that the global mrs has an ogNam that can't possibly be a
;	[10] valid ogNam, yet is not UNDEFINED, so no tMrs search should ever 
;	[10] 'find' the global mrs unless it's specifically being looked for
;	[10] but it shouldn't be, since it ALWAYS exists, and is always at 
;	[10] offset 0.
;
;	NOTE: This routine assumes that names are unique - - - a simple
;	NOTE: comparison is done to see if they match, so any differences
;	NOTE: w.r.t. file paths will cause no match to occur. Case Sensitivity
;	NOTE: is, however, ignored in the comparison (i.e., 'a' == 'A' for
;	NOTE: the search).
;
;Entry:
;       al == procType - If this is PT_NOT_PROC, then the mrs chain is searched
;			otherwise, it must be PT_SUB, PT_FUNCTION, or PT_DEFFN.
;			PT_SUB and PT_FUNCTION use the same search logic as
;			PT_NOT_PROC, but for PT_DEFFN, additional matching logic
;			is used.
;       dl == oTyp, IF ax == PT_DEFFN; only used in the case we're searching
;			the prs table for a DEF FN. If ax is not PT_DEFFN,
;			then dl is undefined, and not used in search.
;			Only used for FV_QB4LANG versions.
;	es set to rs table segment (if FV_FAR_RSTBL)
;	ogNam -	Name of entry to search for (ogNam field).
;			If ogNam == OGNAM_UNNAMED, then we know we're searching
;			for an entry (in the mrs chain) whose ogNam entry is 
;			also OGNAM_UNNAMED.
;	NOTE: it is assumed on entry that there is no 'current' entry for
;		the table being searched, i.e., if the prs chain is to be 
;		searched, it is assumed that grs.oPrsCur == UNDEFINED - - - 
;		therefore, callers of this routine should call 
;		Mrs/PrsDeActivate first.
;	NOTE: it is assumed by at least one caller of this routine that it
;		cannot trigger any heap movement.
;Exit:
;	AX == offset into the appropriate table if the search is successful,
;		or UNDEFINED if it is not.
;	BX == if AX is UNDEFINED, then this is an offset into the 
;		appropriate table to the last 'hole', or UNDEFINED if there 
;		are no holes in the table.
;		If, however, AX is a table offset, BX is a pointer to the
;		found entry.
;	ES will be set to the tRs seg (if FV_FAR_RSTBL)
;Uses:
;	none.
;Exceptions:
;	none. 
;*******************************************************************************
cProc	RsTableSearch,<NEAR,NODATA>,<SI,DI>
	parmW	ogNam			
	LocalB	oTyp
	LocalB	procType
	LocalW	oRsFree
cBegin	RsTableSearch
	mov	[oTyp],0
	mov	[procType],al
	mov	di,[ogNam]		
	mov	bx,[oFreePrsFirst]	;assume we're searching prs chain
	cmp	al,PT_NOT_PROC		;Should we search the prs chain?
	jnz	Search_tPRS		;  brif so

	DbAssertRel grs.GRS_oMrsCur,e,UNDEFINED,CP,<grs.oMrsCur not UNDEFINED in RsTableSearch in context.asm>
	mov	si,OMRS_GLOBAL		; offset to the global mrs
	mov	bx,[oFreeMrsFirst]
	jmp	short	Search_Table

Search_tPRS:
	DbAssertRel grs.GRS_oPrsCur,e,UNDEFINED,CP,<grs.oPrsCur not UNDEFINED in RsTableSearch context.asm>
	mov	si,[oPrsFirst]
	cmp	al,PT_DEFFN		;are we searching for a DEF FN?
	jnz	Search_Table		;brif not

	mov	[oTyp],dl		;save type of DEF FN (else oTyp stays 0)
	DbAssertRelB ET_MAX,ae,dl,CP,<RsTableSearch input oTyp not predefined>

Search_Table:
	mov	[oRsFree],bx		;offset to first free struct
	GETRS_SEG   es,bx,<SIZE,LOAD>	
;At this point, [oTyp]=0 for MRS, SUB, FUNCTION, non-zero for DEF FN
;		si is the oRs for the first struct to examine
;	        [procType] = PT_xxx of entry being searched for
;		di = input ogNam
Search_Loop:
	inc	si
	.errnz	UNDEFINED - 0FFFFH
	jz	Quit_Search		;brif end of chain found

	dec	si
	RS_BASE add,si			;add base of table
	DbAssertRel PTRRS[si.MRS_ogNam],nz,UNDEFINED,CP,<RsTableSearch: err 1>
	
	mov	ax,PTRRS[si.MRS_ogNam]
	.errnz	OGNAM_UNNAMED - 0	
	or	di,di			; special case where ogNam = 0?
	jz	Untitled_Mrs		;brif so

	cmp	di,ax
	jnz	Not_A_Match		;brif names don't match
	mov	al,[oTyp]
	or	al,al			;searching for a DEF FN?
	jz	Match_Found		;  brif not

	mov	dx,[grs.GRS_oMrsCur]	;oMrs of the DEF must be oMrsCur ...
	cmp	dx,PTRRS[si.PRS_oMrs]
	jnz	Not_A_Match		;  brif they're not the same
	
	mov	ah,BPTRRS[si.PRS_oType] 
	and	ah,M_PT_OTYPE		; mask out any flags in this byte
	cmp	al,ah			; oTyp's must match if it's a DEF
	jz	Match_Found
Not_A_Match:
	cmp	[procType],PT_NOT_PROC
	jz	MrsSearch		;brif we're walking the mrs chain

	mov	si,PTRRS[si.PRS_oPrsNext] ;move to next entry
	jmp	Search_Loop		;loop to consider next entry
MrsSearch:
	mov	si,PTRRS[si.MRS_oMrsNext] ;move to next entry
	jmp	Search_Loop		;loop to consider next entry

Untitled_Mrs:
	or	ax,ax			;is this the special 'untitled' entry?
	.errnz	OGNAM_UNNAMED - 0	
	jnz	Not_A_Match		;brif not
Match_Found:
	xchg	ax,si			;pointer to found entry
	RS_BASE sub,ax			;pRs --> oRs
	jmp	short Exit_Table_Search	;found entry - exit routine

Quit_Search:
	mov	ax,UNDEFINED		;entry not found
	mov	bx,[oRsFree]		;first free struct of appropriate
					;  size
Exit_Table_Search:
cEnd	RsTableSearch

;***
;PrsFind - find a prs in the tRs
;Purpose:
;	Given the name of a prs, return the oPrs for it, or UNDEFINED if it's
;	not found.
;	Preserve the Mrs & Prs state of the caller.
;
;	NOTE: This should never be called to search for a DEF FN's, only
;	NOTE: a SUB or a FUNCTION.
;
;	For complete details of the matching algorithm, see RsTableSearch.
;Entry:
;	ogNam - name of the prs to search for
;Exit:
;	AX = UNDEFINED if no match found, otherwise it's the oPrs for the
;		desired prs.
;Exceptions:
;	none.
;****
;***
;MrsFind - find an mrs in tRs
;Purpose:
;	Given the name of an mrs, return the oMrs for it, or UNDEFINED if it's
;	not found.
;	Preserve the Mrs & Prs state of the caller.
;
;	For complete details of the matching algorithm, see RsTableSearch.
;Entry:
;	ogNam - name of the mrs to search for
;Exit:
;	AX = UNDEFINED if no match found, otherwise it's the oMrs for the
;		desired mrs.
;Exceptions:
;	none.
;****
cProc	PrsFind,<PUBLIC,FAR,NODATA>
cBegin	<nogen>
	mov	al,PT_SUB		;search for prs's
	SKIP2_PSW			;skip MrsFind, fall into RsFind
cEnd	<nogen>

cProc	MrsFind,<PUBLIC,FAR,NODATA>
cBegin	<nogen>
	mov	al,PT_NOT_PROC		;search for mrs's
cEnd	<nogen>

?DFP = DFP_NONE 			; don't smash regs on entry
cProc	RsFind,<FAR,NODATA>,<si>
	parmW	ogNam			
cBegin
?DFP = DFP_CP				; restore switch
	DbChk	ogNam,ogNam		
	push	ax
	mov	si,[grs.GRS_oRsCur]	;save, so we can restore at exit 
	cCall	MrsDeActivate
	pop	ax
	cCall	RsTableSearch,<ogNam>	
	push	ax			;save retval
	cCall	RsActivateCP,<si>	;reactivate original RsCur
	pop	ax			;restore retval
cEnd

;***
;MoveTheMrs
;
;Purpose:
;	This code is intended to be used by the Mrs[De]Activate routines,
;	to copy a structure from static data into the table or vice versa.
;
;	Changed significantly and renamed (was CopyNchg2Bds) as part of
;	revision [10].
;Entry:
;	si == pointer to the start of the source mrs
;	bx == pointer to the start of the dest. mrs
;	if FV_FAR_RSTBL, ds is source seg, es is dest. seg
;	NOTE: if FV_FAR_RSTBL, one CANNOT assume ds == ss!
;Exit:
;	none.
;Uses:
;	si
;Exceptions:
;	None.
;****
MoveTheMrs	PROC	NEAR	
	push	di
	mov	di,bx				;so pDst is saved across calls

	mov	cx,SIZE MRS			;    cx == cbMrs
	mov	dx,MRS_txd.TXD_bdlText
	call	CopyNchgMrs			;Common code for mrs's and prs's
	mov	ax,[si.MRS_bdlnam.FHD_pNext]	;special case: in case call to
	mov	[di.MRS_bdlnam.FHD_pNext],ax	;  BdlChgOwner in CopyNchgMrs
						;  changed the pNext field
						;  in source bdl
	mov	ax,MRS_bdlnam
	mov	bx,di
	add	bx,ax				;bx = destination pBdlNam 
	add	ax,si				;ax = source pBdlNam
	cCall	BdlChgOwner,<ax,bx>		;NOTE: We MUST call this AFTER
						;  the block copy
	mov	ax,MRS_bdVar

	add	si,ax
	add	di,ax
	cCall	BdChgOwner_NoCopy,<si,di>	;change owner of 2nd bd
						;  copies the mrs
	pop	di
	ret
MoveTheMrs	ENDP

;***
;CopyNchgMrs, CopyNchgPrs
;
;Purpose:
;	This code is intended to be used by the Mrs/Prs[De]Activate routines,
;	for copying a structure from static data into a table or vice versa.
;	In addition, the owner to the bdlText is also updated (via bdmgr)
;	for CopyNchgMrs.
;Entry:
;		si == pointer to the start of the source struct
;		bx == pointer to the start of the dest. struct	
;	For Mrs callers:
;		cx == count of bytes in the structure to copy
;		dx == offset into structure to prs/mrs text bdl
;	For Prs callers:
;	if FV_FAR_RSTBL, ds is source seg, es is dest. seg,
;	    and NOTE that in this case, one CANNOT assume ss == ds
;Exit:
;	none.
;Exceptions:
;	None.
;****
CopyNchgPrs PROC NEAR
	mov	ax,sp
	mov	cx,SIZE PRS - SIZE TXD
	.errnz (SIZE PRS - SIZE TXD) - PRS_txd	;we're counting on the txd
						;  being the last element in
						;  the prs structure
	SKIP2_PSW
CopyNChgMrs:
	sub	ax,ax
	push	di
	push	ss
	pop	es
	xchg	di,ax				;save flag in di

	mov	ax,dx
	add	ax,bx				;points to dest. bdlText
	add	dx,si				;points to source bdlText
	push	dx				;pass to BdlChgOwner
	push	ax				;pass to BdlChgOwner

	push	si				;pass pbSrc to CopyBlk
	push	bx				;pass bpDst to CopyBlk
	push	cx				;pass cbStruct to CopyBlk
	call	CopyBlk
	
	or	di,di
	jnz	CopyNchg_Cont			;brif don't want to move bdl
						;  owner from the table
	cCall	BdlChgOwner			;must do this AFTER block copy
	SKIP2_AX				
CopyNchg_Cont:
	pop	ax				;disgard parms to BdlChgOwner
	pop	ax
	mov	[si.MRS_ogNam],UNDEFINED	; indicate struct not active
	pop	di
	ret
CopyNchgPrs ENDP

;***
;SetMrsUndef, SetMrsAx
;Purpose:
;	Set grs.oMrsCur and grs.oRsCur to [ax] or UNDEFINED
;Entry:
;	SetMrsAx: ax = new grs.oMrsCur
;Preserves:
;	Caller's assume that no registers other than ax are modified
;
;***************************************************************************
SetMrsUndef PROC NEAR
	mov	ax,UNDEFINED
SetMrsUndef ENDP
	;fall into SetMrsAx
SetMrsAx PROC NEAR
	mov	[grs.GRS_oMrsCur],ax
	mov	[grs.GRS_oRsCur],ax
	ret
SetMrsAx ENDP

;***
;SetPrsUndef, SetPrsAx
;Purpose:
;	Set grs.oPrsCur to [ax] or UNDEFINED, keeping grs.oRsCur consistent.
;Entry:
;	SetPrsAx: ax = new grs.oPrsCur
;Preserves:
;	Caller's assume that no registers other than ax are modified
;
;***************************************************************************
SetPrsUndef PROC NEAR
	mov	ax,UNDEFINED
SetPrsUndef ENDP
	;fall into SetPrsAx
SetPrsAx PROC NEAR
	mov	[grs.GRS_oPrsCur],ax
	inc	ax			;test for UNDEFINED
	jz	NoPrs			;brif no prs is active
	dec	ax
	or	ah,80h			;high bit indicates prs active
	mov	[grs.GRS_oRsCur],ax
	ret
NoPrs:
	mov	ax,[grs.GRS_oMrsCur]
	mov	[grs.GRS_oRsCur],ax	;oRsCur = oMrsCur (no prs active)
	ret
SetPrsAx ENDP


;##############################################################################
;#									      #
;#		  Module related Context Manager Functions		      #
;#									      #
;##############################################################################

;***
;MrsDiscard()
;
;Purpose:
;     Release all resources associated with current module. This includes the
;     module's type table, static value table, and text table.
;     This routine calls DiscardPrs for every procedure in this module.
;
;     TxtDiscard is also called (prior to setting grs.oMrsCur to UNDEFINED).
;
;Entry:
;     static bit flag F_CON_LeaveTMrsEmpty in conFlags - - - if we're 
;		discarding the last mrs and this bit flag is set (TRUE), just 
;		leave no mrs in tRs, otherwise, call MrsMake to create a
;		new unnamed module.
;Exit:
;     AX = non-zero
;	   Special case: AX = UNDEFINED if MakeInitMrs is called. [47]
;     grs.oMrsCur = grs.oPrsCur = UNDEFINED
;Uses:
;	none.
;Exceptions:
;	if the module has been modified and user cancels, triggers a runtime
;	error.
;*******************************************************************************
cProc	MrsDiscard,<PUBLIC,FAR,NODATA>
cBegin	MrsDiscard
	DbAssertRel  mrsCur.MRS_ogNam,nz,OGNAM_GMRS,CP,<MrsDiscard: global mrs!>
	DbAssertRel  mrsCur.MRS_ogNam,nz,OGNAM_CLIPBOARD,CP,<MrsDiscard: err 1>
	DbAssertRel  mrsCur.MRS_ogNam,nz,OGNAM_IMMEDIATE,CP,<MrsDiscard: err 2>

	cCall	PrsDeActivate
	call	AlphaORsFree			;release table of sorted oRs's
	call	VarDealloc			;deallocate any owners in
						; the module variable table

	cCall	DiscardHistoryORs,<grs.GRS_oMrsCur> ; throw away help
						; history for mrs.

	;Note that the below scheme depends on the fact that NextPrsInMrs
	;finds the first prs in the table if grs.GRS_oPrsCur is UNDEFINED, and
	;then subsequent prs's based on grs.GRS_oPrsCur.  It is not safe to
	;call ForEachCP to do this, because that scheme depends on walking
	;the prs chain, and PrsDiscard1 might discard the current entry.
	;In essense we are starting from the top of the prs chain each time
	;through the loop below.
	; To further complicate things, PrsDiscard1 might or might not
	; free the prs; if it does not, the below still works, but we
	; walk from prs to prs, not freeing them, but marking them as
	; undefined proc.s and freeing associated resources.
PrsDiscard_Loop:
	call	far ptr NextPrsInMrs		;activate next prs in this mrs
	inc	ax				;no more prs's in this module?
	jz	MrsDiscard_Cont 		;  brif so
	call	PrsDiscard1			;discard active prs it
	jmp	short PrsDiscard_Loop
MrsDiscard_Cont:
	cCall	PrsDeActivate			; ensure TxtDeleteAll
						; deletes txt in MODULE
						; text table, so any
						; declares to proc.s in
						; this module are removed
						; prior to calling
						; ChkAllUndefPrsSaveRs

	call	TxtDeleteAll			;delete all text in txt table,
						; but don't free bdl yet
	call	ChkAllUndefPrsSaveRs		;search for new defining
						;references for Prs entries
						;which had their "defining"
						;reference deleted.
	cCall	TxtDiscard			;discard current text table

	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdVar>
	cCall	BdFree

	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdlNam>
	call	BdlFree				;free module name table

	test	[mrsCur.mrs_flags2],FM2_NoPcode ; is a document mrs?
	jz	NoDocBuffer			; brif not
	push	[mrsCur.MRS_pDocumentBuf]	; document table to delete
	call	FreeBuf				; Free the buffer
NoDocBuffer:					

	;don't need to modify entry in table - - - without an active mrs,
	;  it will automatically look like a 'hole'.

	mov	ax,[grs.GRS_oMrsCur]
	cmp	ax,[grs.GRS_oMrsMain]		;discarding Main module?
	jnz	Not_Main_Module			;brif not

	mov	[grs.GRS_oMrsMain],UNDEFINED	;now there is no current Main
	jmp	SHORT UndefCur

Not_Main_Module:
	call	MainModified			;mark main module as modified
						; if current mrs is pcode
						; mrs (so we will be sure
						; to save updated xxx.MAK)
						; (preserves ax)
UndefCur:
	push	ax
	call	SetMrsUndef			;grs.oMrsCur=oRsCur=UNDEFINED
	pop	ax				;restore ax = oMrsCur

	;now unlink this entry from the mrs chain and link it into the free
	;  mrs chain
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,ax				;ax = bx = oMrs we're unlinking
	RS_BASE add,bx				;PTRRS:bx = pMrs we're unlinking
	mov	cx,ax
	xchg	cx,[oFreeMrsFirst]		;cx = offset to first free mrs,
						;  this mrs is new first free
	xchg	PTRRS[bx.MRS_oMrsNext],cx	;mrs now linked into free list
	;now, cx is the offset to the next mrs in the active chain; use
	;  that to unlink this mrs from the active chain
	mov	bx,OMRS_GLOBAL			; start from global mrs
UnLink_Loop:
	RS_BASE add,bx
	mov	dx,PTRRS[bx.MRS_oMrsNext]	;offset to next mrs in chain
	cmp	dx,ax				;found previous chain entry?
	jz	UnLinkIt			;  brif so

	mov	bx,dx				;advance to next entry
	jmp	UnLink_Loop

UnLinkIt:
	mov	PTRRS[bx.MRS_oMrsNext],cx	;unlink the discarded mrs

	push	sp				; Default return value
						; Assumes:
						;	 sp != 0
						;	 sp != UNDEFINED

	test	[conFlags],F_CON_LeaveTMrsEmpty ;should we just leave tMrs
						;  empty if this was only mrs?
	jnz	MrsDiscard_Exit			;brif so

Mrs_No_Trim:
	push	ax				;pass oMrsCur to WnReAssign

	call	MrsTableEmpty			;PSW.Z clear if no mrs's
						; bx = remaining oMrs (if any)
	push	bx				;pass oMrsNew to WnReAssign
	jnz	MrsDiscard_Exit1		;brif mrs table not empty

	call	far ptr MakeInitMrs		;make initial mrs
						;  (certain it won't run out
						;   of memory here ...)
	DbAssertRel  ax,z,0,CP,<MrsDiscard: MakeInitMrs returned an error code>	
	pop	bx				;discard invalid oMrsNew
	pop	dx				; Get oMrsOld
	pop	ax				; discard default ret val
	pushi	ax, UNDEFINED			; return UNDEFINED to
						; indicate MakeInitMrs called
	push	dx				; Put oMrsOld back
	push	[grs.GRS_oMrsCur]		;pass oMrsNew to WnReAssign

	cCall	MrsDeActivate			;don't want it active
	
MrsDiscard_Exit1:
	PUSHI	ax,0				;not just renaming an oRs
	call	WnReAssign			;parms already pushed

MrsDiscard_Exit:
	pop	ax				; Get return value
MrsDiscard_Exit2:				
cEnd	MrsDiscard

;***
;UnlinkFreeMrs
;Purpose:
;	Given an oMrs, search the free mrs chain for the oMrs and unlink it
;	from the chain if found.
;Input:
;	ax = oMrs to be unlinked from the free list
;Exit:
;	none
;******************************************************************************
UnlinkFreeMrs  PROC    NEAR
	GETRS_SEG   es,bx,<SIZE,LOAD>		; prepare for link work
	mov	dx,[oFreeMrsFirst]
	inc	dx
	jz	UnlinkEmpty_Done		;free chain is empty

	dec	dx
	cmp	ax,dx
	jnz	Unlink_Unnamed_Entry		;brif unnamed hole not first free

	mov	bx,dx
	RS_BASE add,bx
	mov	dx,PTRRS[bx.MRS_oMrsNext]
	mov	[oFreeMrsFirst],dx		;unlink complete
	jmp	short UnlinkEmpty_Done
Unlink_Unnamed_Entry:
	mov	bx,dx
	RS_BASE add,bx
	mov	dx,PTRRS[bx.MRS_oMrsNext]
	inc	dx
	jz	UnlinkEmpty_Done		;unnamed mrs hole not in free list

	dec	dx
	cmp	ax,dx
	jnz	Unlink_Unnamed_Entry
	xchg	dx,bx
	RS_BASE add,bx
	mov	cx,PTRRS[bx.MRS_oMrsNext]
	xchg	dx,bx
	mov	PTRRS[bx.MRS_oMrsNext],cx	;unlink complete
UnlinkEmpty_Done:
	ret
UnlinkFreeMrs  ENDP

;***
;MrsMake(ogNam, flags)
;
;Purpose:
;     The user-interface is the only QBI component which deals in any way with
;     module names. A module's name is the same as the path name from which it
;     was loaded. This function searches for a module by the name 'ogNam'. If
;     found, an error code is returned (ER_DD).  If not found, it creates
;     a new Mrs entry and names it 'ogNam'.  Calls the TextMgr routine
;     TxtCurInit() to initialize the text table. Calls the Variable Manager's
;     MakeMrsTVar() if this mrs is not for a text object.
;
;	Note that if we're making a named mrs and there exists an empty unnamed
;	mrs (which can only be at a specific offset from the start of the 
;	table), we'll just discard the empty unnamed one, and use that as a 
;	hole to put the new mrs in. 
;
;	Note also that, if there is no MAIN module on successful conclusion of
;	this routine, the new current module will be made the MAIN one.
;
;Entry:
;     ogNam:
;	 If module's name is to be 'Untitled',
;	    ogNam = OGNAM_UNNAMED
;	 else if module is the global module (created only once)
;           ogNam = OGNAM_GMRS
;	 else if module is for some other special purpose
;		ogNam <= OGNAM_PSEUDO_MAX
;        else
;	    ogNam is an offset into the global name table for this module name
;     flags:
;	low byte = initial value of MRS_flags
;	high byte = initial value of MRS_flags2
;	  Command Window:  FM2_NoPcode
;	  ClipBoard:       FM2_NoPcode
;	  Module:          FM2_File
;	  Include File:    FM2_File + FM2_Include
;	  Document File:   FM2_File + FM2_NoPcode
;	  If either FM2_Include or FM2_NoPcode are set:
;	    - we must NOT replace the existing first module even if it's empty
;	    - this mrs can never be made the MAIN module
;	    - it can never have oMrs of 0
;	    - this mrs can never have a variable table (or be scanned to
;	      SS_PARSE or SS_EXECUTE)
;Exit:
;        if no error 
;	    AX = 0
;	    grs.oMrsCur = new module's oMrs
;	    grs.oPrsCur = UNDEFINED
;	    all fields in mrsCur are setup
;	    all fields in txdCur are setup
;	    rsNew = module's oMrs (tell's user interface to show list window)
;	 else
;	    caller can count on the input mrsCur being still active
;	    if out of memory error, AX = ER_OM
;	    if a matching module is found, AX = ER_DD and [oRsDupErr] =
;	       oRs of existing module with same name.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	MrsMake,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW	ogNam				
	parmW	flags
	localB	fUsingUnNamed_Mrs
	localB	fGrewRsTable			
cBegin	MrsMake
	mov	word ptr [fGrewRsTable],FALSE	; initialize both
						; fUsingUnNamed_Mrs and
						; fGrewRsTable with one mov
	mov	di,[grs.GRS_oMrsCur]		; save grs.oMrsCur
	cmp	[ogNam],OGNAM_GMRS		; making global mrs?
	DJMP	jz  Make_gMrs			;	brif so - special case
	call	AlphaORsFree			;release table of sorted oRs's
	cCall	MrsDeActivate			;save existing mrs, empty mrsCur

	mov	al,PT_NOT_PROC			;signal to search tMrs, not tPrs
	cCall	RsTableSearch,<ogNam>		; returns oMrs if entry 
						;   found, or
	mov	dx,UNDEFINED
	cmp	ax,dx				;   UNDEFINED if not found
						;   also puts oHole in bx
	jnz	Make_Mrs_DD_ER			;brif entry was found

	inc	dx				;now dx == 0
	.errnz	OGNAM_UNNAMED - 0
	mov	cx,[ogNam]			
	cmp	cx,dx				; making an unnamed mrs?
	jz	Make_Unnamed_Mrs		;  brif so

	cmp	cx,OGNAM_PSEUDO_MAX		; some other special ogNam?
	jbe	Make_Mrs			;   brif so

	DbChk	ogNam,ogNam			
	test	byte ptr ([flags+1]),FM2_NoPcode OR FM2_Include	
						;is this mrs for a text object?
	jnz	Make_Mrs			;  brif so; keep unnamed mrs

	call	EmptyMrs			;see if there's an empty
						;  unnamed mrs
	jcxz	Make_Mrs			; brif there isn't one
	jmp	short Use_Empty_Mrs		

Make_Mrs_DD_ER:
	mov	[oRsDupErr],ax			;tell caller oRs of conflict
	mov	ax,ER_DD
	jmp	MrsMake_Err_Exit1		;reactivate input mrsCur & exit

Use_Empty_Mrs:
	mov	si,SIZE MRS + OMRS_GLOBAL	; oMrs for unnamed entry
	push	si				;parm to MrsActivateCP
	call	MrsActivateCP

	or	[conFlags],F_CON_LeaveTMrsEmpty ;so MrsDiscard won't create a
						;  new module after discarding!
	cCall	MrsDiscard			;discard empty unnamed mrs
	and	[conFlags],NOT F_CON_LeaveTMrsEmpty ;reset to default
	mov	[fUsingUnNamed_Mrs],TRUE	;in case of later OM error
	mov	ax,si				;oMrs to unlink from free list
	call	UnlinkFreeMrs			;unlink the entry from the
						;  free list, (MrsDiscard
						;  linked it in)
	jmp	SHORT Init_New_Mrs1		

Make_Text_Mrs:
	or	bx,bx
	jnz	Make_Mrs

	dec	bx				;if making a text mrs, CANNOT
						;  allow it to go in @ offset 0
	jmp	short Make_Mrs

Make_Unnamed_Mrs:
	mov	ax,SIZE MRS + OMRS_GLOBAL	;offset that empty unnamed mrs
						;  MUST go at (parm to UnlinkFree Mrs)
	mov	si,ax
	call	UnlinkFreeMrs			;unlink the entry from the
	mov	bx,si				; offset that empty unnamed
						;   mrs MUST go at
	cmp	bx,[grs.GRS_bdRs.BD_cbLogical]	;is the table empty?
	jz	Make_Mrs_Grow
Init_New_Mrs1:					
	jmp	short Init_New_Mrs
Make_gMrs:
	mov	si,OMRS_GLOBAL			; new oMrs
	PUSHI	ax,<dataOFFSET grs.GRS_bdRs>	
	PUSHI	ax,<SIZE MRS + OMRS_GLOBAL>	
	call	BdGrow				
	jmp	short Make_Mrs_Grow_1		
Make_Mrs:
	mov	si,bx				;save hole location
	cmp	si,UNDEFINED			;is there a hole in table?
	jz	Make_Mrs_Grow			;  brif not

	DbAssertRel bx,z,oFreeMrsFirst,CP,<MrsMake: given hole not first free>
	RS_BASE add,bx
	mov	bx,PTRRS[bx.MRS_oMrsNext]
	mov	[oFreeMrsFirst],bx		;free entry now unlinked from
						;  free mrs chain
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	jmp	short Init_New_Mrs
Make_Mrs_Grow:
	mov	si,[grs.GRS_bdRs.BD_cbLogical]	;new oMrs
	or	si,si				; Rs table > 32k?
	js	J_MrsMake_OM_Err		; brif so ... give OM error

	PUSHI	ax,<dataOFFSET grs.GRS_bdRs>
	PUSHI	ax,<SIZE MRS>
	call	BdGrow
Make_Mrs_Grow_1:				
	or	ax,ax
	jnz	@F				; brif successful
J_MrsMake_OM_Err:				
	jmp	MrsMake_OM_Err
@@:						
	mov	[fGrewRsTable],TRUE		; remember we grew in case
						; later error
Init_New_Mrs:
	mov	ax,dataOFFSET mrsCur
	mov	bx,SIZE MRS
	mov	cx,MRS_CB_ZERO_INIT
	call	InitStruct
	mov	[mrsCur.MRS_cbFrameVars],-FR_FirstVar	;	
						; reset to init. value. This
						; value is 2 to account for
						; the fact that b$curframe 
						; is always pushed on the
						; stack after bp, so we
						; treat this word as a frame
						; var for ref'ing the real
						; frame vars off of bp
	mov	ax,[flags]
	mov	[mrsCur.MRS_flags],al
	mov	[mrsCur.MRS_flags2],ah
	mov	ax,si
	call	SetMrsAx			;grs.oMrsCur = oRsCur = ax
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,si				;oMrsNew
	RS_BASE add,bx				;add base of tRs to bx
	mov	PTRRS[bx.MRS_ogNam],UNDEFINED	;mark entry as inactive, since
						;  mrsCur has actual mrs
	mov	PTRRS[bx.MRS_oMrsNext],UNDEFINED ;in case someone tries to walk
						 ;  the mrs chain before this
						 ;  mrs gets deactivated
	cCall	TxtCurInit			;init txdCur
	jnz	no_error
	jmp	MrsMake_TxtInit_Err
no_error:

	test	byte ptr ([flags+1]),FM2_NoPcode; is a document mrs?
	jz	MakeVarTables			; brif not, create tables
	call	NewBuf				; allocate document buffer
	mov	WORD PTR [mrsCur.MRS_pDocumentBuf],ax ; set ptr to buffer
	or	ax,ax				; was it successful?
	mov	al,ER_OM			; assume not, set error
	jz	MrsMake_OM_2_Err		; brif out of memory
	jmp	SHORT MrsMake_Name		; finish creating txt tbl

MakeVarTables:

	cCall	MakeMrsTVar			; set up module var table
	or	ax,ax
	jz	MrsMake_OM_2_Err

	mov	ax,SbGNam			; assume global mrs
	cmp	[ogNam],OGNAM_GMRS		; making global mrs?
	jz	MrsMake_TNam			;	brif so

	sub	ax,ax				; don't use special sb
MrsMake_TNam:					
	cCall	TNamInit,<ax>			; set up module name table
	or	ax,ax
	jz	MrsMake_OM_3_Err

MrsMake_Name:
	mov	ax,[ogNam]			
	mov	[mrsCur.MRS_ogNam],ax		; set module name
	mov	[mrsCur.MRS_oMrsNext],UNDEFINED 
	.errnz	1 - OGNAM_GMRS			
	dec	ax				; is this the global module?
	jz	MrsMake_Exit			;  brif so - exit (this
						;      mrs doesn't have to be
						;      linked, as it's known
						;      to be at offset 0)
	;After this point, no errors can occur, so its ok to tell
	;user interface the oRs of the new module
	
	xchg	ax,dx
	mov	ax,[grs.GRS_oMrsCur]
	mov	[rsNew],ax			;tell user interface to
						; show new mrs in list window
Link_Mrs:
	;Now, link this module into mrs chain
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,OMRS_GLOBAL			;start with global mrs
MrsLink_Loop:
	RS_BASE add,bx
	mov	dx,PTRRS[bx.MRS_oMrsNext]
	inc	dx
	.errnz	UNDEFINED - 0FFFFH
	jz	GotChainEnd			;brif bx points to last current
						;  entry in the mrs chain
	dec	dx
	mov	bx,dx
	jmp	MrsLink_Loop
GotChainEnd:
	mov	PTRRS[bx.MRS_oMrsNext],ax	;link new entry at end of chain
	;Note that the oMrsNext field in the new entry will automatically be
	;UNDEFINED in the new entry, and we set it to UNDEFINED earlier in
	;this routine

	xor	ax,ax
	test	byte ptr ([flags+1]),FM2_NoPcode OR FM2_Include	
						;is this mrs for a text or
						;  INCLUDE object?
	jnz	Main_Set2			;  brif so - IT can't be MAIN

	dec	ax
	.errnz	UNDEFINED - 0FFFFh
	cmp	[grs.GRS_oMrsMain],ax		;is there already a MAIN module?
	jz	Main_Set0			;  brif not
	call	MainModified			;mark main module as modified
						; if current mrs is pcode
						; mrs (so we will be sure
						; to save updated xxx.MAK)
	jmp	SHORT Main_Set1

Main_Set0:
	mov	dx,[grs.GRS_oMrsCur]
	mov	[grs.GRS_oMrsMain],dx		;this mrs gets set as MAIN
Main_Set1:
	inc	ax				;inc ax back to 0
Main_Set2:
	.errnz	FALSE
MrsMake_Exit:
cEnd	MrsMake

MrsMake_OM_3_Err:
	mov	bx,dataOFFSET mrsCur.MRS_bdVar	
	cCall	BdFree,<bx>			
	mov	bx,dataOFFSET mrsCur.MRS_bdlNam 
	cCall	BdlFree,<bx>			
MrsMake_OM_2_Err:
	call	TxtDiscard
MrsMake_TxtInit_Err:
	cmp	[fGrewRsTable],FALSE		; did we grow Rs table?
	jz	@F				; brif not
	sub	[grs.GRS_bdRs.BD_cbLogical],SIZE MRS
@@:						
MrsMake_OM_Err: ;Tried to grow the Rs table but failed
	call	SetMrsUndef			;grs.oMrsCur=oRsCur=UNDEFINED
	cmp	[fUsingUnNamed_Mrs],FALSE	;special case where we tried
						;  to reuse unnamed mrs?
	jz	Not_Unnamed			;  brif not

	cmp	di,SIZE MRS + OMRS_GLOBAL	; was the unnamed one the
						;  active one on entry?
	jnz	Not_Unnamed			;  brif not

	;can't reactivate the one that was active on input, as we've 
	;  tried to reuse that one but failed. For this special case, we
	;  must recurse to restore the unnamed empty mrs
	call	far ptr MakeInitMrs		;remake empty unnamed mrs
						;  (certain it won't run out
						;   of memory here ...)
	DbAssertRel  ax,z,0,CP,<MrsMake: MakeInitMrs returned an error code>	
	DbAssertRel  di,z,grs.GRS_oMrsCur,CP,<MrsMake: di not equal to oMrsCur>
Not_Unnamed:
	mov	ax,ER_OM
MrsMake_Err_Exit1:
	push	ax				;save error code
	push	di				;input oMrsCur 
	call	MrsActivateCP			;re-activate original mrs
	pop	ax				;restore error code for retval
	jmp	MrsMake_Exit

;***
; MakeInitMrs
; Purpose:
;	Make an unnamed module mrs.
; Entry:
;	none
; Exit:
;	ax = error code
;
;*******************************************************************************
cProc	MakeInitMrs,<FAR,NODATA>
cBegin	MakeInitMrs
	xor	ax,ax			; set to OGNAM_UNNAMED
	.errnz	OGNAM_UNNAMED - 0	
	push	ax			;make untitled module
	PUSHI	ax,<100h * FM2_File>	;initial flags for module mrs
	call	MrsMake			;make initial (untitled) mrs 
cEnd	MakeInitMrs
;***
; MainModified
; Purpose:
;	Mark main module as modified if current mrs is pcode mrs.
;	This is done so we will be sure to save updated xxx.MAK)
; Preserves:
;	ax (caller's assume this)
;	es is either preserved, or explicitly set to seg of tRs
;
;*******************************************************************************
PUBLIC	MainModified	;for debugging only
MainModified PROC NEAR
DbAssertRel [grs.GRS_oMrsMain],ne,[grs.GRS_oMrsCur],CP,<MainModified: err1>
	mov	bx,[grs.GRS_oMrsMain]
	inc	bx			;test for UNDEFINED
	jz	MmExit			;brif no main module
					; (can happen when we're terminating
					;  and main module discarded before
					;  command window's mrs)
	test	[mrsCur.MRS_flags2],FM2_NoPcode OR FM2_Include
	jnz	MmExit			;brif current mrs is not a pcode mrs

	dec	bx
	RS_BASE add,bx			;bx now points to main mrs
					; (we know mrs oMrsMain is in table,
					;  i.e. not in mrsCur struct)
	or	BPTRRS[bx.MRS_flags2],FM2_Modified
	GETRS_SEG   es,bx,<SIZE,LOAD>	
MmExit:
	ret
MainModified ENDP

;***
;MrsDeActivate()
;
;Purpose:
;     Save the	current module's register set (mrsCur) back into the tRs
;     entry. This includes a call to TxtDeActivate prior to actually
;     deactivating the mrs, as well as deactivating the current procedure 
;     (via PrsDeActivate).
;
;     NOTE: This routine is guaranteed to cause no heap movement.
;
;Entry:
;	 grs.oMrsCur = current module to be deactivated
;	   UNDEFINED if there is no current module
;Exit:
;	 grs.oMrsCur = UNDEFINED
;	 grs.oPrsCur = UNDEFINED
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	MrsDeActivate,<PUBLIC,NEAR,NODATA>,<SI>
cBegin	MrsDeActivate
	cmp	[grs.GRS_oMrsCur],UNDEFINED	;is there an active mrs?
	jz	MrsDeAct_Exit			;just return if not

	DbHeapMoveOff				;assert no heap movement here
	DbChk	ConStatStructs
	cCall	PrsDeActivate			;deactivate current prs, if any

	cCall	TxtDeActivate			;deactivate current txd, if any

	mov	bx,[grs.GRS_oMrsCur]
	RS_BASE add,bx
	GETRS_SEG   es,si,<SIZE,LOAD>		; es set to mrs dst. seg
	mov	si,dataOFFSET mrsCur		;now ds:si == mrs src. address
	call	MoveTheMrs			; move mrsCur into tRs

	call	SetMrsUndef			;grs.oMrsCur=oRsCur=UNDEFINED
	DbHeapMoveOn
MrsDeAct_Exit:
cEnd	MrsDeActivate

;***
;MrsActivate(oMrsNew)
;
;Purpose:
;     Make the module indicated by oMrsNew the current active module. The
;     current module's register set (if any) will be saved via MrsDeActivate, 
;     and TxtActivate will be called at the end.
;
;     NOTE: This routine is guaranteed to cause no heap movement.
;
;Entry:
;	 'oMrsNew' is an offset into the tRs for module to be made current.
;	Note that if oMrsNew is UNDEFINED or if the entry at offset oMrsNew is
;		a discarded entry, the current mrs (if any) will be
;		deactivated, and no new mrs will be activated.
;Exit:
;	 grs.oMrsCur = oMrsNew
;	 grs.oPrsCur = UNDEFINED
;	 if oMrsNew != UNDEFINED,
;		all fields in mrsCur are setup
;		all fields in txdCur are setup
;Uses:
;	none.
;Exceptions:
;	none.
;     
;*******************************************************************************
cProc	MrsActivate,<PUBLIC,FAR,NODATA>
	parmW	oMrsNew
cBegin	MrsActivate
	cCall	MrsActivateCP,<oMrsNew>
cEnd	MrsActivate

cProc	MrsActivateCP,<PUBLIC,NEAR,NODATA>,<SI>
	parmW	oMrsNew
cBegin	MrsActivateCP

	DbHeapMoveOff				;assert no heap movement here
	call	PrsDeActivate
	mov	ax,[oMrsNew]
	cmp	ax,[grs.GRS_oMrsCur]
	jz	MrsActivate_Exit

	push	ax				;save oMrsNew
	cCall	MrsDeActivate			;deactivate current mrs, if any
	pop	ax				;ax = oMrsNew
	inc	ax				;test for UNDEFINED
	jz	MrsActivate_Exit		;brif no mrs is to be activated
	dec	ax				;restore ax = oMrsNew

	DbChk	oMrs,ax 			;ife RELEASE - ensure validity
	xchg	ax,si				;si = oMrs to activate
	RS_BASE add,si				;si = pMrs to activate
	GETRS_SEG   ds,bx,<SIZE,LOAD>		; ds set to mrs src. seg
	assumes DS,NOTHING
	mov	bx,dataOFFSET mrsCur		;bx == mrs dest. address
	SETSEG_EQ_SS	es			;es:bx = mrs dest. address
	call	MoveTheMrs			; move mrsCur into tRs
	SETSEG_EQ_SS	ds			;restore ds = ss
	assumes DS,DATA

	mov	ax,[oMrsNew]			;note new oMrsCur
	call	SetMrsAx			;grs.oMrsCur = oRsCur = ax

	cCall	TxtActivate			;activate txdCur from this mrs
MrsActivate_Exit:
	DbHeapMoveOn
cEnd	MrsActivate

;***
;EmptyMrs
;Purpose:
;	This boolean function is used to determine whether there is an
;	empty unnamed module.
;	[52] NOTE: more than one caller of this routine assumes that if
;	[52]	   there IS an empty unnamed mrs, then there is no other
;	[52]	   (pcode) mrs loaded.
;Entry:
;	none.
;Exit:
;	CX = 0 if there is not an empty unnamed module
;	else CX is the offset in the Rs table to the empty unnamed module
;Uses:
;	none.
;Preserves:
;	BX
;Exceptions:
;	none.
;*******************************************************************************
PUBLIC	EmptyMrs
EmptyMrs	PROC	NEAR
	push	bx
	;---------------------------------------------------------------------
	;NOTE: an inherent assumption is that, if there exists an unnamed mrs,
	;	it will be at offset SIZE MRS + OMRS_GLOBAL in the table (the
	;	global mrs is at offset OMRSGLOBAL in the table). The user
	;	cannot create an unnamed mrs, so this seems a safe assumption.
	;---------------------------------------------------------------------
	mov	cx,SIZE MRS + OMRS_GLOBAL   ;[60]
	mov	bx,OFFSET DGROUP:mrsCur	;assume this is the current module
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	SETSEG_EQ_SS	es		;seg of mrsCur is always same as ss
	cmp	[grs.GRS_oMrsCur],cx	;is this the current module?
	jz	EmptyMrs_Cont		;  brif so

	GETRS_SEG   es,bx,<SIZE,LOAD>	
	mov	bx,cx			;bx = oMrs
	RS_BASE add,bx			;bx = pMrs
	mov	ax,PTRRS[bx.MRS_txd.TXD_bdlText_cbLogical]
EmptyMrs_Cont:
	cmp	PTRRS[bx.MRS_ogNam],OGNAM_UNNAMED  ;[10] is MAIN mrs unnamed?
	jnz	EmptyMrs_FalseExit	;  brif not

	cmp	ax,CB_EMPTY_TEXT	;is it's text table empty?
	ja	EmptyMrs_FalseExit	;  brif not

	;This block checks to see if module has any procedures
	mov	ax,UNDEFINED
	mov	bx,cx			;bx == oMrs of interest for call below
	DbAssertRel grs.GRS_oPrsCur,z,UNDEFINED,CP,<EmptyMrs: prsCur active>
	call	GetNextPrsInMrs		;ax = oPrs of 1st prs in module
	js	EmptyMrs_Exit		; brif module contains no prs's

EmptyMrs_FalseExit:
	xor	cx,cx			; indicate no empty unnamed mrs
EmptyMrs_Exit:
	pop	bx
	ret
EmptyMrs	ENDP


;##############################################################################
;#									      #
;#		  Procedure related Context Manager Functions		      #
;#									      #
;##############################################################################

;------------------------------------------------------------------------------
;
;                           Prs Transition States
;
; Due to the user interface, prs handling is more complicated than mrs
; handling. For a Module Register Set, there are just 2 states: no mrs, or
; an mrs, with two arcs connecting the states: MrsMake, and MrsDiscard.
;
; Procedure Register Sets have the following states and transitions:
;
;       S0 - No prs entry
;       S1 - SUB has been referenced, but not declared or defined
;            This only applies to SUBs, not FUNCTIONS or DEFFNs.
;            (i.e. FUNCTIONS and DEF FNs never enter this state)
;            If a prs entry is still in this state at runtime,
;            We bind to a compiled SUB on first execution.
;       S2 - procedure has no text tbl, has been DECLAREd but not defined.
;            If a prs entry is still in this state at runtime,
;            We bind to a compiled SUB/FUNCTION on first execution.
;            The procedure may or may not have declarations.
;            (DEF FNs never enter this state)
;       S3 - procedure text tbl & window allocated, but no definition.
;            The procedure may or may not have declarations.
;            (DEF FNs never enter this state)
;       S4 - procedure has a definition (i.e. SUB/FUNCTION/DEF FN stmt)
;
; These states can be uniquely determined by these fields in the prs structure:
;		(But note: txd.bdlText.status should only be tested while the
;		 prs is not active, i.e., in the tPrs. To see if prsCur has
;		 a text table, test txdCur.TXD_flags - - if FTX_mrs is set,
;		 prsCur has no text table)
;       S0:  bdName.pb == NULL
;       S1:  bdName.pb != NULL, txd.bdlText.status == NOT_OWNER,
;            FP_DECLARED and FP_DEFINED are NOT set,
;            (mrs,prs,otx refer to the CALL reference)
;       S2:  bdName.pb != NULL, txd.bdlText.status == NOT_OWNER
;            FP_DECLARED IS set, FP_DEFINED is NOT set,
;            (mrs,prs,otx refer to DECLARE stmt's pcode),
;       S3:  bdName.pb != NULL, txd.bdlText.status != NOT_OWNER,
;            FP_DEFINED is NOT set,
;       S4:  bdName.pb != NULL, txd.bdlText.status != NOT_OWNER for SUB/FUNC
;            but is UNDEFINED for DEF FNs, FP_DEFINED is set, The setting of
;            FP_DECLARED is not important in this state.
;            (mrs,prs,otx refer to SUB/FUNCTION/ DEF FN statement's pcode)
;
; With these states defined, and arcs connecting them being functions
; defined below, the following table shows how the arcs connect the states:
; In this table, PrsDefine refers to when PrsDefine is called with fNotDefine=0,
; i.e. for a SUB/FUNCTION/DEF FN statement.
; PrsDeclare refers to when PrsDefine is called with fNotDefine != 0,
; i.e. for a DECLARE SUB/FUNCTION/DEF FN statement.
;
;	Initial State	  Arc       Final State
;	-------------	  ---       -----------
;	    S0		PrsRef(FUNC/DEF)S0
;	    S0		PrsRef(SUB)	S1
;           S0          PrsDeclare      S2
;	    S0		PrsMake		S3
;	    S0		PrsDefine	S4
;
;           S1          <txt mgr sees defining reference deleted and:
;                        finds another SUB reference -> S1
;                        finds no other references -> PrsFree -> S0
;	    S1		PrsRef(SUB)	S1
;           S1          PrsDeclare      S2
;	    S1		PrsMake		S3
;	    S1		PrsDefine	S4
;
;           S2          <txt mgr sees defining DECLARE stmt deleted and:
;                        finds another DECLARE -> S2
;                        finds another SUB reference -> S1
;                        finds no other declares or references -> PrsFree -> S0
;	    S2		PrsRef          S2
;	    S2          PrsDeclare      S2
;	    S2          PrsMake		S3
;	    S2          PrsDefine       S4
;
;	    S3		PrsRef		S3
;	    S3		PrsMake		S3
;	    S3		PrsDeclare	S3
;	    S3		PrsDefine	S4
;           S3		<txt mgr sees text table and window removed and:
;			 finds a SUB reference -> S1
;			 finds no SUB reference -> PrsFree -> S0
;
;	    S4		PrsRef		S4
;	    S4		PrsMake		S4
;           S4          PrsDeclare      S4
;           S4          <txt mgr sees defining SUB/FUNC/DEF stmt deleted and:
;			 finds text table and window still active -> S3
;                        finds a DECLARE -> S2
;                        finds a SUB reference -> S1
;                        finds no declares or references -> PrsFree -> S0
;
;
; Note that PrsDiscard cannot directly eliminate the Prs Entry if there
; are references to the prs in other text tables.  It can only
; eliminate the text table associated with the entry by calling TxdDiscard,
; which will cause the text manager to see the definition be deleted.
; If the text manager is unable to find a DECLARE to replace as the new
; definition of the prs, the text manager calls PrsFree to completely
; eliminate the Prs entry.
;
; The above table describes a state-transition diagram, which was not
; attempted in this source file due to the number of transitions.
;------------------------------------------------------------------------------

;***
;PrsRef(oNam,procType,oTyp)
;
;Purpose:
;     This function searches for a procedure in the tRs by the name oNam.
;     If a match is found to a prs entry, the oPrs is returned, otherwise, 
;     UNDEFINED.
;     This function will not normally affect prsCur; if, however, procType
;     is PT_SUB and the entry does not already exist, instead of returning
;     UNDEFINED, it will create the entry and return the oPrs.
;
;     The procType field is primarily used to indicate whether the procedure
;     is a DEF FN or not; if not, then the oTyp input is not used. If it
;     is a DEF FN, however, the search logic is different - - - rather than
;     just matching on the name, the search algorithm must match on the oTyp
;     and oMrs as well.
;
;     This routine is called by the parser when a procedure reference is seen,
;     and probably by the scanner when it sees a function entry in a variable
;     table.
;
;Entry:
;	oNam is an offset into current module's name table for proc name
;       procType is either PT_SUB, PT_FUNCTION, or PT_DEFFN.
;	oTyp is only valid if procType == PT_DEFFN, in which case it is
;		the oTyp of the DEF; otherwise, this input is undefined.
;Exit:
;	AX == oPrs if found, UNDEFINED otherwise.
;	In the event that the input procType is PT_SUB and no matching prs
;		is found, the prs will be created; if an error occurs in
;		creating the prs, the same standard error code will be returned,
;		(as is returned by PrsDefine) OR'd with 0x8000. If no error
;		occurs, the oPrs of the new prs will be returned.
;	In all cases, prsCur will be the same on exit as on entry.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	PrsRef,<PUBLIC,NEAR,NODATA>,<SI>
	parmW	oNam
	parmB	procType
	parmB	oTyp
cBegin	PrsRef
	DbChk	oNam,oNam			;sanity check on input oNam
	mov	si,[grs.GRS_oPrsCur]		;save for later restoring
	cCall	PrsDeActivate			;must deactivate for search

	cCall	OgNamOfONam,<oNam>		; given oNam, fetch ogNam
	xchg	ax,cx				; cx = ogNam or 0
	mov	ax,08000H OR ER_OM		;[10] in case of OM err ret
	jcxz	PrsRef_Exit			;[10]  brif OM error

	mov	al,[procType]			;tell RsTableSearch to use tPrs
	mov	dl,[oTyp]
	cCall	RsTableSearch,<cx>		; search tRs for entry

	cmp	ax,UNDEFINED
	jnz	PrsRef_Exit			;brif found

PrsRef_No_Match:
	cmp	[procType],PT_SUB		;looking for a SUB?
	jnz	PrsRef_Exit			;  brif not - exit

	;special case; reference to a SUB which was not found. Create the
	;	entry, return the oPrs or error code
	push	[oNam]
	push	Word Ptr [procType]
	push	ax				;push garbage for oTyp parm
	mov	al,1
	push	ax				;push a non-zero word (true)
	call	far ptr PrsDefine		; create the entry
PrsRef_Err_Check:
	or	ah,080h				;set high bit in case of error
	cmp	ax,08000h			;FALSE return if no error
	jnz	PrsRef_Exit			;  brif error; pass code back

	mov	ax,[grs.GRS_oPrsCur]		;retval

PrsRef_Exit:
	push	ax				;save retval
	push	si				;parm to PrsActivateCP
	call	PrsActivateCP			;reactivate original prs
	pop	ax				;retval
cEnd	PrsRef

;***
;PrsMake(ogNam, procType)
;
;Purpose:
;     This function searches for a procedure by the name ogNam.
;     If found, it gives an ER_DD if the found procedure has
;     a text table; otherwise, it just activates the found procedure and gives
;     it a text table.  If a new entry is created, it calls the TextMgr
;     routine TxtCurInit() to initialize the text table,
;     and calls the Variable Manager's MakePrsTVar().
;Entry:
;	 ogNam for the proc name
;	 procType - PT_SUB or PT_FUNCTION (should never get PT_DEFFN here)
;Exit:
;        AX == FALSE if no error, ER_OM if out of memory, MSG_IdTooLong
;		if the input name is too long, and ER_DD if a matching
;		entry is found that already has a text table, or if a
;		match is found to a compiled module name.
;	 if ER_DD, [oRsDupErr] = oRs of existing proc with same name.
;        Note that is an error code is returned, there will be no active prs
;	 grs.oMrsCur = procedure's oMrs (unchanged if new proc)
;	 grs.oPrsCur = procedure's oPrs
;	 all fields in prsCur are setup if we're making an existing prs active
;		if we're creating a new prs, then prsCur will have the correct 
;		ogNam, oVarHash, oMrs, and oPrs fields; other fields must be 
;		set up by caller as appropriate.
;	 all fields in txdCur are setup
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	PrsMake,<PUBLIC,FAR,NODATA>,<SI>
	parmW	ogNam			
	parmB	procType
	LocalW	oPrsSave
	LocalW	oMrsSave
	LocalW	searchResult
cBegin	PrsMake
	mov	ax,[grs.GRS_oPrsCur]
	mov	[oPrsSave],ax		;save original oPrs
	mov	ax,[grs.GRS_oMrsCur]
	mov	[oMrsSave],ax		;save original oMrs
	cCall	PrsDeActivate
	mov	si,[ogNam]		
	cCall	ONamOfOgNam,<si>	; given ogNam, fetch oNam
	jnz	PrsMake_Cont		;  Catch possible OM error
					;  now, so later callers of FieldsOfPrs
					;  don't have to consider it.
	jmp	PrsMake_ER_OM1		;brif ONamOfOgNam returned Out of Memory
PrsMake_Cont:
	;---------------------------------------------------------------------
	cmp	[procType],PT_SUB
	jnz	PrsMake_Namespace_OK	;brif not a SUB - leave name space alone

	push	ax			;save oNam across call
	mov	dl,NMSP_Sub
	cCall	SetONamSpace,<ax,dx>	;set namespace bit to remember that this
					;  is a procedure name
	pop	ax
	jnz	PrsMake_ER_DD_1		;brif namespace conflict	

PrsMake_Namespace_OK:
	cCall	GetVarNamChar,<ax>	;ah non-zero if name starts with FN
	or	ah,ah
	jz	No_FN_Name_Error

	cmp	[procType],PT_DEFFN
	jz	No_FN_Name_Error

	mov	ax,MSG_FNstart		;"Can't start with 'FN'"
	jmp	PrsMake_ER_Exit
No_FN_Name_Error:
	DbAssertRelB procType,nz,PT_DEFFN,CP,<PrsMake got called with PT_DEFFN>
	mov	al,[procType]
	cCall	RsTableSearch,<ogNam>	; if err code in CX on retn, ignore
	mov	[searchResult],ax	;save in case of OM error
	inc	ax			;matching entry found?
	.errnz	UNDEFINED - 0FFFFh
	jz	No_Match_Found		;  brif not

	dec	ax			;restore search result
	push	ax			;parm to PrsActivate
	call	PrsActivateCP		;activate this oPrs
	test	[txdCur.TXD_flags],FTX_mrs
	jnz	PrsMake_EnsureTxd	;no error
	;txdCur is for found prs - - error

PrsMake_ER_DD_1:
	jmp	short PrsMake_ER_DD

No_Match_Found:
	call	MakeNewPrs		;make a new entry in prsCur
	jz	PrsMake_ER_OM		;  brif so

	mov	[prsCur.PRS_ogNam],si	; set ogNam in new entry to input
PrsMake_EnsureTxd:
 	mov	al,[procType]		;if we found a match on a FUNCTION or a
 	mov	[prsCur.PRS_procType],al;  DEF FN, FORCE it's proctype to the
	cCall	EnsurePrsTVar		;ax = prs's oVarHash
	jz	PrsMake_ER_OM

	call	AlphaORsFree		;release table of sorted oRs's
	cCall	TxtDeActivate		;save the txd for mrsCur
					; table. leave txdCur as mrs

	;This assignment is necessary for case where prs ref preceded prs
	;definition.  When prs was created for reference, prs's oMrs field
	;was set to mrs with reference.  Now that definition is here, the
	;oMrs field must be set to the mrs which 'owns' the prs.
	
	mov	ax,[oMrsSave]		;ax = caller's oMrs
	mov	[prsCur.PRS_oMrs],ax
;
; At this point mrsCur may not be the same as prsCur.PRS_oMrs, so let's
; ensure that it is.
;
	cmp	[grs.GRS_oMrsCur], ax	
	je	@F			;[477
	push	[grs.GRS_oPrsCur]	; For PrsActivate
	call	PrsDeactivate		
	call	far ptr PrsActivate	
@@:					

	cCall	TxtCurInit		;init txdCur for this new prs
	jz	PrsMake_ER_OM_Txd

	.errnz	FALSE
	xor	ax,ax			;return FALSE
PrsMake_Exit:
cEnd	PrsMake

PrsMake_ER_DD:
	mov	ax,[grs.GRS_oRsCur]
	mov	[oRsDupErr],ax			;tell caller oRs of conflict
	mov	ax,ER_DD
	jmp	short PrsMake_ER_Exit

PrsMake_ER_OM_Txd:
	call	TxtActivate		;reactivate txd for mrsCur
	call	PrsDeActivate		; Set oPrsCur to UNDEFINED,
					;so TxtActivate will activate txd for
					;mrsCur, not this aborted prs
					; Also, in case prsCur on entry was
					; the given prs, must deactivate it
					; here so shared code below will
					; succeed in activating oPrsSave
PrsMake_ER_OM:
	mov	ax,[searchResult]
	inc	ax
	.errnz	UNDEFINED - 0FFFFh
	jnz	PrsMake_ER_OM1		;brif we did not create this prs

	;O.K. - we created it, so we must remove it from the prs table
	mov	ax,dataOFFSET prsCur
	push	ax
	add	ax,SIZE PRS
	dec	ax			;pointer to last byte in range to free
	push	ax
	call	B$ClearRange		;free any owners in prsCur
	call	SetPrsUndef		;grs.oPrsCur=UNDEFINED, oRsCur=oMrsCur
PrsMake_ER_OM1:
	mov	ax,ER_OM
PrsMake_ER_Exit:
	push	ax
	push	oPrsSave		;parm to PrsActivate
	call	PrsActivateCP		;reactivate prsCur
	pop	ax
	jmp	short PrsMake_Exit


;***
;MakeNewPrs
;
;Purpose:
;	Common code to PrsDefine and PrsMake. Sets up prsCur as a new prs.
;Entry:
;	bx = offset to hole in prs table, or UNDEFINED if there is no hole
;	This function assumes that no prs is active (i.e. txdCur reflects
;	   the module's text table)
;Exit:
;	PSW.Z set if out-of-memory
;	grs.oPrsCur is set, meaning prsCur now contains valid info
;Uses:
;	none.
;Exceptions:
;	none.
;****
MakeNewPrs PROC	NEAR
	push	di

	inc	bx				;was there a hole in the table?
	.errnz	UNDEFINED - 0FFFFh
	jz	Prs_GrowTbl			;brif not

	;Unlink the hole from the free list
	GETRS_SEG   es,di,<SIZE,LOAD>		
	dec	bx
	mov	di,bx				;put oHole in di
	DbAssertRel bx,z,oFreePrsFirst,CP,<MakeNewPrs: hole not 1st in free list>
	RS_BASE add,bx
	mov	ax,PTRRS[bx.PRS_oPrsNext]
	mov	[oFreePrsFirst],ax		;free entry now unlinked
	jmp	short PRS_Hole_Found

Prs_GrowTbl:
	sub	ax,ax				
	mov	di,[grs.GRS_bdRs.BD_cbLogical]	;offset to new prs in table
	or	di,di				; Rs table > 32k?
	js	@F				; brif so - OM error

	PUSHI	ax,<dataOFFSET grs.GRS_bdRs>
	PUSHI	ax,<SIZE PRS>
	call	BdGrow
@@:						
	or	ax,ax
	jz	MakeNewPrs_Ret
	
PRS_Hole_Found:
	mov	ax,di
						;new entry put in hole location
	call	SetPrsAx			;grs.oPrsCur = ax
						;grs.oRsCur = 8000h + ax
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,di				;bx = offset to prs in table
	RS_BASE add,bx				;bx = pointer to prs in table
	mov	PTRRS[bx.PRS_ogNam],UNDEFINED	; mark tbl entry as inactve,
						;  since prs is in prsCur
	;Now, link this new prs entry into the prs chain
	mov	PTRRS[bx.PRS_oPrsNext],UNDEFINED ; terminate chain
	mov	dx,bx				; save pPrsNew

	mov	ax,[oPrsFirst]			
	inc	ax				; is this the first prs?
	jnz	LastPrs_Loop			; brif not

	mov	[oPrsFirst],di			; point to new entry
	jmp	short After_Link		; link complete - continue

LastPrs_Loop:					
	dec	ax				; bx == oPrs
	xchg	ax,bx				; advance to next prs
	RS_BASE add,bx				; bx = ptr to prs in table
	mov	ax,PTRRS[bx.PRS_oPrsNext]	; fetch pointer to next prs
	inc	ax				; no more prs's?
	jz	@F				; brif so

	jmp	short LastPrs_Loop		; loop until end of chain
@@:
	mov	PTRRS[bx.PRS_oPrsNext],di	; link new prs in @ end
After_Link:					
	mov	ax,dataOFFSET prsCur		;initialize prsCur, filling it
	mov	bx,SIZE PRS			;  with UNDEFINED, and zeroes 
	mov	cx,PRS_CB_ZERO_INIT		;  as appropriate
	call	InitStruct			; note that this sets
						; the PRS_oPrsNext field to
						; UNDEFINED
	mov	[prsCur.PRS_cbFrameVars],-FR_FirstVar	;	
						; reset to init. value. This
						; value is 2 to account for
						; the fact that b$curframe 
						; is always pushed on the
						; stack after bp, so we
						; treat this word as a frame
						; var for ref'ing the real
						; frame vars off of bp

	mov	ax,[grs.GRS_oMrsCur]		;set oMrs field
	mov	[prsCur.PRS_oMrs],ax
	mov	[fCouldBeBogusPrs],TRUE		;note that there's now a chance
						;  of an unref'd prs
	or	sp,sp				;normal return - reset PSW.Z
MakeNewPrs_Ret:
	pop	di				;restore caller's di
	ret
MakeNewPrs ENDP

;***
;EnsurePrsTVar
;Purpose:
;	Create a local variable table (i.e. allocate oVarHash in
;	module's variable table for local variables) iff:
;	  (1) prs doesn't already have one AND
;	  (2) prs's scan state != SS_RUDE
;Entry:
;	none
;Exit:
;	If didn't need to make local variable table, because prs already
;	   had one, or procedure's scan state == SS_RUDE, ax = UNDEFINED
;	Else if out-of-memory,
;	   ax = 0
;	Else
;	   ax = prs's newly created oVarHash
;	PSW is set based on value in ax
;Exceptions:
;	none
;
;*******************************************************************************
EnsurePrsTVar PROC NEAR
	mov	ax,UNDEFINED
	cmp	[txdCur.TXD_scanState],SS_RUDE	;test table's scan state
	jae	NoTVar			; don't make hash table if there
					; is no variable table
	cmp	[prsCur.PRS_oVarHash],ax
	jnz	NoTVar			;brif prs already has oVarHash
	cCall	MakePrsTVar		;ax = prs's oVarHash, (0 if no memory)
NoTVar:
	or	ax,ax			;set PSW for caller
	ret
EnsurePrsTVar ENDP

;***
;PrsDefine(oNam, procType, oTyp, fNotDefine)
;
;Purpose:
;	Declare or Define a procedure. grs.oPrsCur will be UNDEFINED if we 
;	must first create a new prs entry, or prsCur will be set up to the 
;	appropriate prs entry otherwise; in this latter case, caller
;	wants to rename an existing prs so, we'll create 
;	a new prs for the input name if different from the name of prsCur, 
;	leaving the existing prs (without a text table) in case there are 
;	references (oPrs's) to it.
;
;	This routine is only called when an actual procedure definition
;	is found or when a declaration of a procedure is found.
;
;Entry:
;	oNam -		offset into the name table for mrsCur to the proc name.
;	procType -	PT_SUB, PT_FUNCTION, or PT_DEFFN.
;	oTyp -		only defined if procType == PT_DEFFN; used in searching
;			the Rs table for a matching DEF. Note that this is
;			accepted as a Byte - - we know it must be a predefined
;			type, and the oTyp in the PRS is just stored as a byte.
;	fNotDefine -	non zero if called for DECLARE SUB/FUNCTION
;	                If a prs by this name already exists, it is activated,
;                       otherwise, a new one is created with no text table
;                       allocated to it.
;
;Exit:
;        AX == FALSE if no error, ER_OM if out of memory, ER_DD if a matching
;		entry belongs in another module, and ER_CN if grs.otxCONT is
;		not UNDEFINED (i.e. CONT is possible) and the module variable
;		table would have to grow for this to succeed.
;        Note that if an error code is returned, there may or may not be a
;		current prs.
;	 if a matching module is found, AX = ER_DD and [oRsDupErr] =
;	    oRs of existing module with same name.
;	 grs.oMrsCur will be unchanged.
;	 grs.oPrsCur = procedure's oPrs
;	 prsCur will have the correct bdName, procType, fDefined, oTyp,
;		oVarHash, oMrs, and oPrs fields; other 
;		fields must be set up by caller as appropriate.
;	 all fields in txdCur are setup (will be for mrsCur if PT_DEFFN or
;		input fNotDefine is TRUE)
;        NOTE: In the special case where we're changing the name of an
;		existing prs entry (prsCur on input), we'll create a new
;		entry, copy the old one to the new one, but with the new
;		name, and mark the old one as having no text table or
;		definition. This is because references (oPrs's) may still
;		exist to the old prs name. The new entry will be prsCur, set
;		up as described above.
;	 PSW set based on value in ax
;Uses:
;	none.
;Exceptions:
;	none.
;     
;*******************************************************************************
cProc	PrsDefine,<PUBLIC,FAR,NODATA>,<SI,DI>	
	parmW	oNam
	parmB	procType
	parmB	oTyp
	parmB	fNotDefine
	LocalV	bdName,%(SIZE BD)
	LocalW	oPrsSave
	LocalW	oMrsSave
	LocalW	SearchResult
cBegin	PrsDefine
	DbChk	oNam,oNam			;sanity check on input oNam
	mov	ax,[grs.GRS_oPrsCur]
	mov	[oPrsSave],ax			;save original oPrs
	xchg	ax,di				;in case of error exit
	mov	ax,[grs.GRS_oMrsCur]
	mov	[oMrsSave],ax			;save original oMrs
	cCall	PrsDeActivate			;for table search, below

	cCall	OgNamOfONam,<oNam>		; given oNam, fetch ogNam
	xchg	ax,si				; si = ogNam or 0
	mov	ax,ER_OM
	jz	PrsDefine_Exit1			;brif OM error return

	mov	bx,[oNam]
	mov	al,NMSP_SUB

	;--------------------------------------------------------------------
	cmp	[procType],PT_SUB
	jnz	PrsDefine_Reset_Namespace	;brif not a SUB - reset SUB
						;  bit in name entry in case
						;  we're converting a SUB to
						;  a FUNCTION
	
	cCall	SetONamSpace,<bx,ax>		
	jnz	JNZ_PrsDefine_DD_1		;[69]brif namespace already
						;	 set to something else
	jmp	short PrsDefine_Namespace_OK
PrsDefine_Reset_Namespace:
	call	ResetONamMask			;reset the NMSP_SUB bit	
PrsDefine_Namespace_OK:
	mov	ax,ER_CN
	cmp	[grs.GRS_otxCONT],UNDEFINED	;is user able to CONTinue?
	jnz	PrsDefine_Exit1			;  brif so - - - don't want
						;  to risk moving var tab
	mov	dl,[oTyp]
	mov	al,[procType]			;tell RsTableSearch to use tPrs
	cmp	al,PT_SUB
	jnz	PrsDefine_NotSub		;brif not a sub

	mov	[oTyp],0			; scanner depends on 0 in
						; oTyp field of SUB prs's
PrsDefine_NotSub:
	cCall	RsTableSearch,<si>		;search Rs table for entry
						;bx=offset to hole if not found
	mov	dx,[oPrsSave]			;for later reference
	mov	[SearchResult],ax		;save in case of OM error
	inc	ax				;was a matching entry found?
	jz	PrsDefine_No_Match		;  brif not

	dec	ax
	jmp	SHORT PrsDefine_Match_OK	;brif no match error in search

PrsDefine_Exit1:
	jmp	PrsDefine_ER_Exit		;exit with error code

PrsDefine_Match_OK:
	inc	dx				;was prsCur active on input?
	jz	Change_Entry			;  brif not

	dec	dx
	cmp	ax,dx				;was match made w/ input prsCur?
	jz	Change_Entry			;  brif so - change that entry

	xchg	di,ax				;di = oPrsFound.

	cCall	FieldsOfPrs,<di>		;dh = prs flags,
	GETRS_SEG   es,ax,<SIZE,LOAD>		; es:bx = pPrsFound
	test	dh,FP_DEFINED
JNZ_PrsDefine_DD_1:				
	jnz	PrsDefine_DD_1			;Error - caller trying to change
						;    name to prsCur to the name
						;    of an already existing 
						;    defined prs
	cmp	PTRRS[bx.PRS_txd.TXD_bdlText_status],NOT_OWNER
	jnz	PrsDefine_DD_1			;Error - found prs has text
						;    table.
	mov	ax,PTRRS[bx.PRS_oPrsNext]	; save link field so we
	mov	[prsCur.PRS_oPrsNext],ax	; can restore after blk cpy
	DJMP	jmp SHORT PrsDefine_Cont1	;jmp to copy input prsCur to 
						;    this one - - found prs
						;    not defined, so we'll just
						;    copy prsCur to it, and make
						;    it defined, leaving the
						;    input current prs around,
						;    but w/out a text table
						;    (in case of ref.s to it)

PrsDefine_No_Match:
	cmp	dx,UNDEFINED			;was a prs active?
	jnz	Change_Entry_1			;  brif so - change the entry

	call	MakeNewPrs			;make a new entry in prsCur
	jz	PrsDefine_OM_1			;  brif OM error return
	jmp	PrsDefine_Cont

Change_Entry_1:
	xchg	ax,dx				;ax = oPrsSave, dx = garbage
	mov	[searchResult],ax		;in case of OM error when
						;  changing the name
Change_Entry:
	xchg	di,ax				;di = oPrsFound
	push	di				;parm to PrsActivate: oPrsFound
	call	PrsActivateCP			;activate entry to change
	cmp	[fNotDefine],FALSE
	jnz	PrsDefine_No_Err		;brif called for DECLARE

	test	[prsCur.PRS_flags],FP_DEFINED
	jz	PrsDefine_No_Err1

;error - prs [di] was already defined
PrsDefine_DD_1:
	xchg	ax,di				;ax = existing duplicate oPrs
	or	ah,80h				;ax = existing duplicate oRs
	mov	[oRsDupErr],ax			;tell caller oRs of conflict
	mov	ax,ER_DD
	jmp	PrsDefine_ER_Exit

PrsDefine_No_Err1:
	test	[txdCur.TXD_flags],FTX_Mrs	;does this prs have a text table
	jnz	PrsDefine_No_Err		;  brif not

	cmp	[oPrsSave],UNDEFINED		;was a prs active at entry?
	je	PrsDefine_DD_1			;brif not - must be entering
						; a SUB at module level, when
						; the SUB line has been deleted,
						; or commented out. If we don't
						; do this, a Prs could change
						; from one Mrs to another
						; unexpectedly.
PrsDefine_No_Err:
	cmp	[prsCur.PRS_ogNam],si		; change name of current prs
						;  if it was different
	jz	Names_Match			; brif no change

	;changing name of an existing prs. Must create a new prs for the new
	;	name, and leave the old one around (minus its text table) in
	;	case there are references to it hanging around (oPrs's) in
	;	text or variable tables
	
	DbAssertRelB [fNotDefine],z,FALSE,CP,<PrsDefine got Change_Entry error>
	cCall	PrsDeActivate

	mov	di,[grs.GRS_bdRs.BD_cbLogical]	;offset to new prs in table
	mov	bx,UNDEFINED			; just grow the table
	call	MakeNewPrs			
	jnz	PrsDefine_Cont1 		
PrsDefine_OM_1:
	jmp PrsDefine_ER_OM			

;di = oPrsNew
PrsDefine_Cont1:
	mov	bx,[grs.GRS_bdRs.BD_pb] 	;base pointer to prs table
	mov	cx,bx
	add	cx,di				;cx = pPrsNew
	add	bx,[oPrsSave]			;bx = pPrsOld
	push	bx				;save pPrsOld
	push	cx				;save pPrsNew

	push	bx				;pass pPrsOld to CopyBlk
	push	cx				;pass pPrsNew to CopyBlk
	PUSHI	ax,<SIZE PRS>
	cCall	CopyBlk 			;copy prs

	;After duplicating the entry, we need to initialize a few fields
	;in both the old and new prs entries.  Note that prs.oVarHash
	;is now meaningless in both entries since the only way we could
	;be here is after the user has edited the name of a procedure,
	;which the text manager guarentees is a Rude Edit (causing
	;the module's variable table to be discarded).
	
	call	SetPrsUndef			; in case MakeNewPrs set
	mov	ax,[oPrsSave]
	push	[prsCur.PRS_oPrsNext]		; preserve across call
	call	UndefPrs			;old prs is no longer defined
						;It is up to text mgr
						;ChkAllUndefPrs
						;function to redefine it if
						;any other refs exist
	GETRS_SEG   es,bx,<SIZE,LOAD>		; in case modified by call
	pop	ax				; link field for new entry
	pop	bx				;es:bx = pPrsNew
	mov	PTRRS[bx.PRS_oPrsNext],ax	; so link field is correct
	mov	PTRRS[bx.PRS_ogNam],NULL	; new prs entry has no name

	xchg	ax,bx				;  yet hang onto pPrsNew for
						;  a moment
	pop	bx				;bx = pPrsOld
	add	bx,PRS_txd.TXD_bdlText		;make this a pBdl for old prs
	add	ax,PRS_txd.TXD_bdlText		;make this a pBdl for new prs
	cCall	BdlChgOwner,<bx,ax>
	call	AlphaORsFree			;release table of sorted oRs's
	
	push	di				;oPrsNew	
	call	PrsActivateCP			;reactivate prsCur

Names_Match:

PrsDefine_Cont:
	;If this PRS has the defined bit set, then we have a more powerful
	;reference, don't arbitrarily change the proc type.  If we did this,
	;changing a DECLARE from SUB to FUNCTION for a defined SUB would
	;cause us to list the SUB with an END FUNCTION.  If we are editting,
	;the SUB/FUNCTION definition line, then the txtmgr will have already
	;turned off the FP_DEFINED bit for this prs.
	
	test	[prsCur.PRS_flags],FP_DEFINED	;Is this prs already defined?
	jnz	PrsAlreadyDefined		;brif so
	mov	al,[procType]
	mov	[prsCur.PRS_procType],al
PrsAlreadyDefined:
	cmp	[fNotDefine],FALSE
	jnz	PrsDefine_Declare		;brif called for DECLARE/REF

	mov	ax,[oMrsSave]			;ax = caller's oMrs
	mov	[prsCur.PRS_oMrs],ax

	call	EnsurePrsTVar			;make local var table if
						; none already
	jz	PrsDefine_TVar_Err

PrsDefine_Declare:
	mov	al,[oTyp]
	and	[prsCur.PRS_oType],NOT M_PT_OTYPE   
	or	[prsCur.PRS_oType],al		
	mov	[prsCur.PRS_ogNam],si		; set name of prs
	xor	ax,ax				; retval
PrsDefine_Exit:
	or	ax,ax				;set PSW for caller
cEnd	PrsDefine

;NOTE: The error handling code is fairly large due to the constraint that,
;NOTE: on any error, the error code is returned, and the context is left just
;NOTE: as it was prior to the call.

PrsDefine_TVar_Err:
	cmp	[SearchResult],UNDEFINED	;did prs already exist?
	jnz	PrsDefine_ER_OM_2		;  brif so - leave prs entry
PrsDefine_ER_OM:
	mov	ax,dataOFFSET prsCur
	push	ax
	add	ax,SIZE PRS
	dec	ax				;pointer to last byte in range
	push	ax
	call	B$ClearRange			;free any owners in prsCur
	call	SetPrsUndef			;grs.oPrsCur=UNDEFINED,
						;oRsCur=oMrsCur
PrsDefine_ER_OM_2:
	mov	ax,ER_OM
PrsDefine_ER_Exit:
	push	ax
	push	oMrsSave			;parm to MrsActivateCP
	call	MrsActivateCP			;reactivate prsCur
	push	oPrsSave			;parm to PrsActivate
	call	PrsActivateCP			;reactivate prsCur
	pop	ax				
	jmp	short PrsDefine_Exit

;***
;OTypeOfTypeChar
;Purpose:
;	Returns the oType associated with the specified type character.
;
;	Split from oRsOfHstProc and rewritten in revision [90]
;
;Entry:
;	AL - The character.
;Exit:
;	AX - otype of the specified type character
;	     ET_IMP if not a valid type character.
;	     Z flag is set if ax == ET_IMP.
;
;*******************************************************************************
tcEt LABEL BYTE
cEt_SD: db	'$'
cEt_R8:
	db	'#'
cEt_R4: db	'!'
cEt_I4: db	'&'
cEt_I2: db	'%'
tcEtEnd LABEL BYTE

	.erre	ET_R4 EQ (tcEtEnd - cEt_R4)
	.erre	ET_SD EQ (tcEtEnd - cEt_SD)
	.erre	ET_R8 EQ (tcEtEnd - cEt_R8)
	.erre	ET_I4 EQ (tcEtEnd - cEt_I4)
	.erre	ET_I2 EQ (tcEtEnd - cEt_I2)


DbPub OTypeOfTypeChar
cProc OTypeOfTypeChar,<NEAR>,<DI>
cBegin
	push	cs
	pop	es
	mov	di,CPoffset tcEt
	mov	cx,tcEtEnd - tcEt
	repnz	scasb			;NZ and cx == 0 if not found
					; Z and cx == oType-1 if found
	jnz	@F
	inc	cx			;cx == oType
@@:
	.errnz	ET_IMP
	mov	ax, cx			;ax == ET_IMP if not found
					;   == ET_ type if found
	or	ax,ax
cEnd

cProc OTypeOfTypeCharFar,<FAR,PUBLIC>
	parmB	TypeChar
cBegin
	mov	al,[TypeChar]
	call	OTypeOfTypeChar
cEnd


;***
;PrsDeActivate, PrsDeAct_NoTxd
;
;Purpose:
;     Save the	current procedure's  register set  (prsCur) back into the tRs.
;     TxtDeActivate is called to handle the procedure text table.
;
;     PrsDeAct_NoTxd is the same as PrsDeActivate, except that it doesn't
;     activate mrsCur's txd - - - i.e., there is no txd active on exit, unless
;     the routine is called without an active prs - - - in this latter case,
;     no action is taken.
;
;     NOTE: This routine is guaranteed to cause no heap movement.
;
;Entry:
;	 grs.oPrsCur = current procedure to be DeActivated
;	   UNDEFINED if there is no current procedure
;Exit: 
;	 grs.oPrsCur = UNDEFINED
;        For PrsDeActivate, txdCur is setup for mrsCur 
;		(unless grs.oMrsCur == UNDEFINED on input)
;Uses:
;	none.
;Preserves:
;	ES
;Exceptions:
;	none.
;     
;*******************************************************************************
PUBLIC	PrsDeActivate
PrsDeActivate:
	mov	ax,sp
	SKIP2_PSW
PrsDeAct_NoTxd:
	xor	ax,ax
cProc	PrsDeAct,<PUBLIC,NEAR,NODATA>
cBegin	PrsDeAct
	DbHeapMoveOff				;assert no heap movement here
	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jz	PrsDeAct_Exit

	push	si
	push	di
	push	es
	xchg	ax,di				;save flag in di
	DbChk	ConStatStructs
	mov	si,[grs.GRS_oPrsCur]		;si = pointer to prs entry
	RS_BASE add,si
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	PTRRS[si.PRS_txd.TXD_bdlText_status],NOT_OWNER
	mov	BPTRRS[si.PRS_txd.TXD_flags],FTX_mrs  ;ensure txd looks invalid in
						;  table, in case this prs has
						;  no text table
	cCall	TxtDeActivate			;copies txd into prs table or
						;  mrs table, as appropriate
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,si				;bx = pointer to prs entry
	mov	si,dataOFFSET prsCur		;si = pointer to prsCur
	call	CopyNchgPrs			;copy prs & move bdName owner

	call	SetPrsUndef			;grs.oPrsCur=UNDEFINED,
						;oRsCur=oMrsCur
	or	di,di
	jz	PrsDeAct_NoTxd_Exit		;brif want no txd active on exit

	cCall	TxtActivate			;activate txdCur for mrsCur
PrsDeAct_NoTxd_Exit:
	pop	es
	pop	di
	pop	si
PrsDeAct_Exit:
	DbHeapMoveOn
cEnd	PrsDeAct

;***
;PrsDeActivateFar()
;
;Purpose:
;	Same as PrsDeActivate, but accessible from other code segments.
;
;Entry:
;	 grs.oPrsCur = current procedure to be DeActivated
;	   UNDEFINED if there is no current procedure
;Exit: 
;	 grs.oPrsCur = UNDEFINED
;        txdCur is setup for mrsCur (unless grs.oMrsCur == UNDEFINED on input)
;Uses:
;	none.
;Exceptions:
;	none.
;     
;*******************************************************************************
cProc	PrsDeActivateFar,<PUBLIC,FAR,NODATA>
cBegin	PrsDeActivateFar
	cCall	PrsDeActivate
cEnd	PrsDeActivateFar

;***
;PrsActivate(oPrsNew)
;
;Purpose:
;     Make the procedure indicated by oPrsNew the current active procedure. The
;     current procedure's register set is saved via PrsDeActivate. If oPrsNew's
;     module is different from grs.oMrsCur and the procedure has an associated
;     text table, MrsActivate() is called to make the procedure's module 
;     current. TxtActivate is called at the end.
;
;     NOTE: This routine is guaranteed to cause no heap movement.
;
;Entry:
;	 'oPrsNew' is an offset into the Rs table
;	   for procedure to be made current.
;	 Note that, if oPrsNew == UNDEFINED or if the entry at offset oPrsNew
;		is a discarded entry, the current procedure (if any)
;		will be deactivated, and no new prs will be activated.
;Exit:
;	 grs.oPrsCur = oPrsNew
;	 if oPrsNew != UNDEFINED
;		all fields in prsCur are setup
;		all fields in txdCur are setup
;        If prs @ offset oPrsNew has a text table, then mrsCur is activated
;		for prsNew.oMrs.
;Uses:
;	none.
;Preserves:
;	ES
;Exceptions:
;	none.
;     
;*******************************************************************************
cProc	PrsActivate,<PUBLIC,FAR,NODATA>
	parmW	oPrsNew
cBegin	PrsActivate
	cCall	PrsActivateCP,<oPrsNew>
cEnd	PrsActivate

cProc	PrsActivateCP,<PUBLIC,NEAR,NODATA>,<SI,ES>
	parmW	oPrsNew
cBegin	PrsActivateCP
	DbHeapMoveOff				;assert no heap movement here
	mov	ax,[oPrsNew]
	mov	bx,[grs.GRS_oPrsCur]
	cmp	ax,bx
	DJMP	jz  PrsActivate_Exit		;brif desired prs is already
						;  active
	mov	si,ax				;si = ax = oPrsNew
	inc	ax
	jz	PrsActivate_Cont		;brif oPrsNew == UNDEFINED

	DbChk	oPrs,si				;ife RELEASE - ensure validity

	;we're actually activating a prs. If we currently have a prs active,
	;then we can avoid activating and then just deactivating the txd for
	;mrsCur if both prs's are in the same module  - - - that's a 
	;considerable speed savings.
	RS_BASE add,si				;si = pPrs
	GETRS_SEG   es,cx,<SIZE,LOAD>		
	mov	cx,PTRRS[si.PRS_oMrs]		;is oMrs for this prs the same
	cmp	[grs.GRS_oMrsCur],cx		;  as oMrsCur?
	jnz	PrsActivate_Cont1		;  brif not -

	inc	bx
	jz	NoPrs_Active			;brif no prs active

	call	PrsDeAct_NoTxd			;deactivate existing prs,
						;  don't activate txd for mrsCur
	jmp	short MrsCur_Is_Correct
NoPrs_Active:
	;no prs currently active, and we're activating a prs in mrsCur
	cCall	TxtDeActivate			;deactivate txd for mrsCur
	jmp	short MrsCur_Is_Correct
PrsActivate_Cont1:
	dec	ax
	xchg	ax,si				;si = oPrsNew
PrsActivate_Cont:
	cCall	PrsDeActivate			;deactivate current prs, if any

	inc	si				;test for UNDEFINED
	jz	PrsActivate_Exit		;brif not
	dec	si				;restore si = oPrsNew

	RS_BASE add,si				;si = pPrs
	GETRS_SEG   es,bx,<SIZE,LOAD>		

	mov	ax,PTRRS[si.PRS_oMrs]		;is oMrs for this prs the same
	mov	dx,[grs.GRS_oMrsCur]		
	cmp	dx,ax				;	as oMrsCur?
	jz	MrsCur_Is_Correct1		;  brif so

	;When activating a PRS, we must activate the PRS's MRS iff:
	; - the procedure has a Text Table or
	; - the procedure has a Definition (i.e. SUB/FUNCTION stmt)
	;A PRS could have a text table and no Definition after PrsMake
	; (i.e. after user does a File/New/Sub)
	;A DEF FN PRS could have a Definition and no text table
	;A SUB/FUNCTION PRS could have a Definition and no text table
	; after a SUB/FUNCTION statement is seen by Parser during
	; ASCII Load, but before the TxtMgr calls PrsMake to give the
	; prs a text table.
	
	cmp	PTRRS[si.PRS_txd.TXD_bdlText_status],NOT_OWNER
	jnz	PrsHasText			;brif prs has a text tbl
						; (if so, its mrs must also
						;  be activated)
	inc	dx				; is there an active mrs?
	jz	PrsHasText			; brif not - make sure that
						; an mrs is active

	test	BPTRRS[si.PRS_flags],FP_DEFINED
	jz	MrsCur_Is_Correct1		;brif prs is DECLAREd but not
						;defined
PrsHasText:
	cCall	MrsActivateCP,<ax>		;activate the mrs for this prs	
MrsCur_Is_Correct1:
	cCall	TxtDeActivate			;deactivate txdCur for mrsCur
MrsCur_Is_Correct:
	DbChk	MrsCur				;in case mrsCur not active on
						;  input, and FP_DEFINED not set
	GETRS_SEG   ds,bx,<SIZE,LOAD>		
	assumes ds,nothing
	mov	bx,dataOFFSET prsCur		;now bx == prsCur dest address
	SETSEG_EQ_SS	es			;es:bx == dest address
	call	CopyNchgPrs			;copy prs & move bdName owner
	SETSEG_EQ_SS	ds
	assumes ds,DATA

	mov	ax,[oPrsNew]			;note new oPrsCur
	call	SetPrsAx			;grs.oPrsCur = ax
						;grs.oRsCur = 8000h + ax

	cCall	TxtActivate			;activate txdCur for this prsCur
						;  from the Rs table
PrsActivate_Exit:
	DbHeapMoveOn
cEnd	PrsActivateCP

;***
;PrsFree()
;
;Purpose:
;     This is called to remove prsCur from the Rs table. It releases all
;     resources associated with current procedure including its dynamic value 
;     table and text table (the latter via TxtDiscard). Note that it also 
;     causes ALL variables to be cleared! Note that it also resets the
;     flags byte in the name table entry.
;     Note also that this function should only be called after PrsDiscard
;     has been called for the procedure.
;
;     NOTE: some callers of this routine expect no heap movement to occur.
;
;Entry:
;     grs.oPrsCur assumed != UNDEFINED, and prsCur is a valid, active prs.
;     It is assumed that the txd for prsCur (i.e., txdCur) has already been
;     discarded via a call to PrsDiscard.
;Exit:
;     AX != FALSE (for use with ForEach...)
;Uses:
;     none.
;Exceptions:
;     none.
;	 
;*******************************************************************************
cProc	PrsFree,<PUBLIC,FAR,NODATA>
cBegin	PrsFree
	DbHeapMoveOff				;assert no heap movement here

	DbChk	ogNam,prsCur.PRS_ogNam		
	mov	ax,[prsCur.PRS_oMrs]		
	cmp	ax,[grs.GRS_oMrsCur]		; 'defining' mrs active?
	jz	@F				; brif so

	push	[grs.GRS_oPrsCur]		; parm to PrsActivateCP
	cCall	MrsActivateCP,<ax>		; activate mrs for this prs
	call	PrsActivateCP			; reactivate prsCur
@@:						
	cCall	ONamOfOgNam,<prsCur.PRS_ogNam>	; get oNam for this prs
	DbAssertRel ax,nz,0,CP,<PrsFree: Out of memory return from ONamOfOgNam>
	xchg	ax,bx				;bx=oNam, parm to ResetONamMask
	mov	al,NMSP_SUB OR NM_fShared	;reset these bit flags, i.e.,
	call	ResetONamMask			;  free the module namespace
						;  for this name

	cCall	DiscardHistoryORs,<grs.GRS_oRsCur> ; throw away help
						; history for prs.

	;Now, unlink from the prs chain, and link into the prs free chain
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	ax,[grs.GRS_oPrsCur]
	mov	cx,ax
	xchg	[oFreePrsFirst],ax		;link at head of prs free chain
	mov	bx,[oPrsFirst]
	cmp	bx,cx				;was this prs at head of chain?
	jnz	UnlinkPrs_Loop			;  brif not

	RS_BASE add,bx
	xchg	ax,PTRRS[bx.PRS_oPrsNext]	;finish free chain link,
						;  set ax for unlink
	mov	[oPrsFirst],ax
	jmp	short PrsFree_LinksOk

UnlinkPrs_Loop:
	RS_BASE add,bx
	mov	dx,PTRRS[bx.PRS_oPrsNext]
	cmp	dx,cx				;is this the previous entry?
	jz	GotPrevEntry			;  brif so

	mov	bx,dx
	jmp	UnlinkPrs_Loop

GotPrevEntry:
	xchg	bx,dx
	RS_BASE add,bx
	xchg	ax,PTRRS[bx.PRS_oPrsNext]	;finish free chain link,
						;  set ax for unlink
	xchg	bx,dx
	mov	PTRRS[bx.PRS_oPrsNext],ax	;link now complete
PrsFree_LinksOk:
	call	SetPrsUndef			;grs.oPrsCur=UNDEFINED,
						;oRsCur=oMrsCur
	mov	ax,sp				;non-zero retval
	DbHeapMoveOn
cEnd	PrsFree

;***
;PrsDiscard()
;
;Purpose:
;     This is called by the user-interface in response to the Discard Procedure
;     menu selection. It releases all resources associated with current
;     procedure including its dynamic value table and text table (the latter
;     via TxtDiscard). Note that it also causes ALL variables to be cleared!
;     This is also called by MrsDiscard for all prs's that have a text table.
;
;     PrsDiscard1 is identical to PrsDiscard, except that it doesn't try
;     to find new "defining" references for prs entries which lost their
;     defining references.  This is a speed opt for cases which need to
;     call PrsDiscard multiple times.  After all calls to PrsDiscard1 have
;     been made, the caller should call ChkAllUndefPrs, to update the
;     prs entries.
;
;Entry:
;     grs.oPrsCur assumed != UNDEFINED, and prsCur is a valid, active prs.
;     mrsCur assumed set up correctly as well.
;     grs.oMrsCur assumed == prsCur.oMrs
;     txdCur assumed to be set up correctly for prsCur if the prs has a
;	 text table.
;Exit:
;     AX == TRUE (non-zero)
;Uses:
;	none.
;Exceptions:
;	none.
;	 
;*******************************************************************************
cProc	PrsDiscard,<PUBLIC,FAR,NODATA>
cBegin	PrsDiscard
	call	PrsDiscard1
	call	ChkAllUndefPrs			;search for new defining
						;references for Prs entries
						;which had their "defining"
						;reference deleted.
PrsDiscardX:
	mov	ax,sp				;reval = true
cEnd	PrsDiscard

cProc	PrsDiscard1,<PUBLIC,NEAR,NODATA>
cBegin	PrsDiscard1
	DbChk	ConStatStructs

	or	[mrsCur.MRS_flags],FM_VARNEW	;tell CLEAR code we want to
						; deallocate $static arrays,
						; not just zero-fill them (in
						; this module only)
	call	ClearTheWorld
	and	[mrsCur.MRS_flags],NOT FM_VARNEW ;reset bit in mrs flags
	test	[txdCur.TXD_flags],FTX_mrs
	jnz	PrsHasNoTxtTbl			;brif DECLARE or DEF FN prs

	call	AlphaORsFree			;release table of sorted oRs's
	push	[grs.GRS_oRsCur]		;force module level code to
	push	[grs.GRS_oMrsCur]		; be visible in any windows
						; that show this prs (if any)
	PUSHI	ax,0				;not just renaming an oRs
	call	WnReAssign		

	cCall	DiscardHistoryORs,<grs.GRS_oRsCur> ; throw away help
						; history for prs.

	cCall	TxtDiscard			;discard prs's text table
	cCall	TxtActivate			;activate txdCur for mrsCur
PrsHasNoTxtTbl:
	test	[grs.GRS_flagsDir],FDIR_new
	jz	PrsMayHaveRefs			;brif NewStmt isn't active
	call	PrsFree 			;delete entry from table
PrsMayHaveRefs:
	mov	ax,sp				;retval = true
cEnd	PrsDiscard1

;***************************************************************************
; GetNextPrsInMrs, GetNextPrs
; Purpose:
;	For GetNextPrs, find next prs.
;	For GetNextPrsInMrs, find next prs in given module.
;
;	GetNextPrs added as part of revision [40].
; Note:
;	[13] This function now handles the case where the next prs in
;	[13] the Rs table (or the first prs, if ax = UNDEFINED on entry)
;	[13] is a hole for prsCur.  Note, therefore, that the oPrs returned
;	[13] could be for prsCur, i.e., do not assume that this can be
;	[13] used to access the prs in the Rs table. Suggestion: Use
;	[13] PPrsOPrs or FieldsOfPrs to access prs information.
; Entry:
;	ax = oPrs of current prs (UNDEFINED if caller wants oPrs of
;	     1st prs [in module].
;	bx = module of interest (only used for GetNextPrsInMrs)
; Exit:
;	ax = UNDEFINED if there are no more prs's that meet the requirement
;	else it is the offset into the prs table for the current prs.
;	Since no oPrs can exceed 7FFFH (for global reasons), it
;	is safe for the caller to do:
;		js	NoPrs
;	es = seg of Rs table in far Rs table versions.
;Uses:
;	none.
;Preserves:
;	cx
;Exceptions:
;	none.
;
;***************************************************************************
cProc	GetNextPrs,<PUBLIC,NEAR,NODATA> 	
cBegin	<nogen> 				
	sub	dx,dx				
	jmp	short GetNext_Prs		
cEnd	<nogen> 				

cProc	GetNextPrsInMrs,<PUBLIC,NEAR,NODATA>	
cBegin	<nogen> 				
	mov	dx,sp				
cEnd	<nogen> 				

?DFP = DFP_NONE 				; don't smash regs on entry
cProc	GetNext_Prs,<NEAR,NODATA>,<DI,CX>	
cBegin
?DFP = DFP_CP					; restore switch
	mov	cx,dx				; cx == 0 ==> ignore oMrs
	mov	dx,bx				;dx = oMrs
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	mov	bx,ax				;bx = UNDEFINED/oPrs
	inc	ax
	jnz	NextPrs_Loop_Start		;brif a prs is active

	mov	bx,[oPrsFirst]			;bx == oPrsCur
	jmp	short NextPrs_Start
NextPrs_Loop_Start:
	RS_BASE add,bx
NextPrs_Loop:
	mov	bx,PTRRS[bx.PRS_oPrsNext]
NextPrs_Start:
	mov	ax,UNDEFINED
	inc	bx
	.errnz	UNDEFINED - 0FFFFH
	jz	NextPrs_Exit			;brif no more prs's in table

	dec	bx
	mov	ax,bx				;potential return value
	RS_BASE add,bx
	cmp	PTRRS[bx.PRS_ogNam],UNDEFINED	; is current entry valid?
	jnz	Got_Valid_Entry			;   brif so

	DbAssertRel ax,z,grs.GRS_oPrsCur,CP,<NextPrs err>
						;UNDEFINED ogNam, must be active
	mov	bx,dataOFFSET prsCur		
	SETSEG_EQ_SS	es
Got_Valid_Entry:				
	jcxz	NextPrs_Exit			; brif we want all prs's,
						; not just those for a
						; given module
	cmp	dx,PTRRS[bx.PRS_oMrs]		;is this prs in current module?
	jnz	NextPrs_Loop			;  brif not, loop to next entry

NextPrs_Exit:
	or	ax,ax				;set condition codes for caller
cEnd

;***************************************************************************
; NextMrsFile
; Purpose:
;	Find and activate the next mrs for which has FM2_File set.
; Entry:
;	grs.oMrsCur = oMrs of current mrs (UNDEFINED if caller wants first
;	     module in the Rs table.
;	Note that this does NOT find or activate the global module.
; Exit:
;	next mrs is loaded into mrsCur,
;	ax = grs.oMrsCur = UNDEFINED if there are no more mrs's in the
;		Rs table to be activated,
;	else it is actually oMrsCur.
;	Note that if ax = UNDEFINED on exit, no mrs will be active.
;Uses:
;	none.
;Exceptions:
;	none.
;
;***************************************************************************
cProc	NextMrsFile_All,<PUBLIC,FAR,NODATA>	
cBegin	<nogen> 				
	sub	ax,ax				; do find empty unnamed
	jmp	short NextMrsFile_Common	
cEnd	<nogen> 				

cProc	NextMrsFile,<PUBLIC,FAR,NODATA> 	
cBegin	<nogen> 				
	mov	ax,sp				; don't find empty unnamed
cEnd	<nogen> 				

?DFP = DFP_NONE 				; don't smash regs on entry
cProc	NextMrsFile_Common,<PUBLIC,FAR,NODATA>	
cBegin
?DFP = DFP_CP					; restore switch
	; NOTE: shares exit with PrevMrsFile
	push	ax				; preserve flag
	push	[grs.GRS_oMrsCur]
	cCall	MrsDeActivate
	GETRS_SEG   es,bx,<SIZE,LOAD>		
	pop	bx
	.errnz	UNDEFINED - 0FFFFh
	inc	bx				;want first module?
	jnz	Got_oMrs			;brif not

	mov	bx,OMRS_GLOBAL + 1		; start looking w/1st entry
						;   after the global mrs
Got_oMrs:
	dec	bx				;bx = oMrs for global mrs
	RS_BASE add,bx
NextMrs_Loop:
	mov	bx,PTRRS[bx.MRS_oMrsNext]
	mov	ax,bx				;retval in case of no more mrs's
	inc	bx
	.errnz	UNDEFINED - 0FFFFH
	jz	NextMrs_Exit			;brif no more mrs's in table

	dec	bx

	RS_BASE add,bx
	test	BPTRRS[bx.MRS_flags2],FM2_File
	jz	NextMrs_Loop			;brif not a File mrs

	cmp	PTRRS[bx.MRS_ogNam],OGNAM_UNNAMED ; UNNAMED mrs?
	jnz	@F				; brif not

	pop	cx				; fetch flag
	push	cx				; restore to stack for
						;	next time thru loop
	jcxz	@F				; brif want ALL file mrs's

	call	EmptyMrs			; cx = 0 if no empty unnamed
	GETRS_SEG   es,ax,<SIZE,LOAD>		; refresh ES
	jcxz	@F				; brif unnamed mrs not empty

	jmp	short NextMrs_Loop		; skip empty unnamed mrs
@@:						

	RS_BASE sub,bx				;pMrs --> oMrs
	push	bx				; parm to MrsActivateCP
Skip_Empty_Unnamed:				; shared exit point
	cCall	MrsActivateCP			
NextMrs_Exit:
	pop	cx				; clean flag off stack
	mov	ax,[grs.GRS_oMrsCur]
cEnd


;***************************************************************************
; NextTextPrsInMrs
; Purpose:
;	Find and activate the next prs in current module for which there
;	is a text table.
; Entry:
;	grs.oPrsCur = oPrs of current prs (UNDEFINED if caller wants oPrs of
;	     1st prs in module.
;	grs.oMrsCur identifies current module
; Exit:
;	next prs is loaded into prsCur,
;	ax = grs.oPrsCur = UNDEFINED if there are no more prs's in this mrs
;		with text tables
;	else it is the offset into the Rs table for the current prs.
;Uses:
;	none.
;Exceptions:
;	none.
;
;***************************************************************************
cProc	NextTextPrsInMrs,<PUBLIC,FAR,NODATA>
cBegin
	mov	cx,sp			;want only prs's w/text tables
	jmp	short NextPrs_Shared
cEnd	<nogen>

;***************************************************************************
; NextPrsInMrs
; Purpose:
;	Find and activate the next prs in current module
; Entry:
;	grs.oPrsCur = oPrs of current prs (UNDEFINED if caller wants oPrs of
;	     1st prs in module.
;	grs.oMrsCur identifies current module
; Exit:
;	next prs is loaded into prsCur,
;	ax = grs.oPrsCur = UNDEFINED if there are no more prs's in this mrs.
;	else it is the offset into the Rs table for the current prs.
;Uses:
;	none.
;Exceptions:
;	none.
;
;***************************************************************************
cProc	NextPrsInMrs,<PUBLIC,FAR,NODATA>
cBegin
	xor	cx,cx			;want all valid prs's
NextPrs_Shared:
	mov	ax,[grs.GRS_oPrsCur]
	mov	bx,[grs.GRS_oMrsCur]
	push	cx			;save fText
	call	GetNextPrsInMrs		;ax = next prs
					;or UNDEFINED if no more
	cCall	PrsActivateCP,<ax>	;activate current entry
					;or deactivate prs if ax=UNDEFINED
	pop	cx
	jcxz	NextPrs_IgnoreText	;brif don't care about text tbl

	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jz	NextPrs_IgnoreText	;brif beyond last prs in mrs

	test	[txdCur.TXD_flags],FTX_mrs
	jnz	NextPrs_Shared		;brif prs has no text table

NextPrs_IgnoreText:
	mov	ax,[grs.GRS_oPrsCur]
cEnd

;***
;FreeAllUnrefdPrs
;
;Purpose:
;	This frees all prs entries which have no more references to them.
;	Calls PrsFree for each prs that doesn't have PRS_otxDef = UNDEFINED.
;	This is done in case the user does something which causes a prs
;	entry to be made for which there is no reference in a text table
;	(such as simply typing 'foo' in direct mode - - - don't want a
;	prs for SUB foo hanging around ...).
;Entry:
;	none.
;Exit:
;	Since it is called from Executors, we preserve grs.fDirect
;	and grs.oRsCur.
;Uses:
;       none.
;Exceptions:
;       none.
;
;*******************************************************************************
cProc	FreeAllUnrefdPrs,<PUBLIC,FAR,NODATA>
cBegin
	xor	cx,cx
	xchg	cl,[fCouldBeBogusPrs]	;reset, and get existing setting to test
	jcxz	FreeAllUnrefdPrs_Exit	;brif no chance of bogus prs's around
					;  (this is a speed optimization)
	push	WORD PTR [grs.GRS_fDirect]
	push	[grs.GRS_oRsCur]
	call	FreeAllUndefinedPrs	;call common code to do the work
	call	RsActivateCP
	PopfDirect ax			;set fDirect to pushed value
FreeAllUnrefdPrs_Exit:
cEnd

;***
;PPrsOPrs
;Purpose:
;	Given an oPrs, return a pointer to the actual prs entry.
;Entry:
;	ax = oPrs
;Exit:
;	bx = pPrs
;	if FV_FAR_RSTBL
;	    es is set to the seg of the prs (i.e., retval is es:bx)
;	ax = oPrs (same as input)
;Exceptions:
;	none.
;Preserves:
;	All but bx
;
;***************************************************************************
PPrsOPrs	PROC	NEAR
public	PPrsOPrs
	assumes ds,NOTHING
	DbChk	oPrs,ax 		;ife RELEASE - ensure oPrs is valid
	test	conFlags,F_CON_StaticStructs
	jz	PrsInTable		;brif static structs are disabled

	mov	bx,dataOFFSET prsCur	;assume oPrs is for prsCur
	SETSEG_EQ_SS	es		;es:bx points to desired prs
	cmp	ax,[grs.GRS_oPrsCur]
	jz	Got_pPrs		;brif oPrs is for prsCur

PrsInTable:
	GETRS_SEG   es,bx,<SIZE,LOAD>	
	mov	bx,ax
	RS_BASE add,bx
Got_pPrs:
	ret
	assumes ds,DATA
PPrsOPrs	ENDP

sEnd	CP				
sBegin	SCAN				
	assumes CS,SCAN 		

;***
;PPrsOPrsSCAN
;Purpose:
;	Given an oPrs, return a pointer to the actual prs entry.
;	Added as revision [46].
;	[69] For FV_SBSWAP versions, sets sbRsScan to the sb of the
;	[69] segment containing the prs, to facilitate refreshing this
;	[69] this segment value.
;Entry:
;	ax = oPrs
;Exit:
;	bx = pPrs
;	if FV_FAR_RSTBL
;	    es is set to the seg of the prs (i.e., retval is es:bx)
;	ax = oPrs (same as input)
;Exceptions:
;	none.
;Preserves:
;	All but bx
;
;***************************************************************************
PPrsOPrsSCAN	PROC	NEAR
public	PPrsOPrsSCAN
	assumes ds,NOTHING
	DbChk	oPrs,ax 		;ife RELEASE - ensure oPrs is valid
	DbChk	ConStatStructs		

	mov	bx,dataOFFSET prsCur	;assume oPrs is for prsCur
	SETSEG_EQ_SS	es		;es:bx points to desired prs
	cmp	ax,[grs.GRS_oPrsCur]
	jz	@F			;brif oPrs is for prsCur

	GETRS_SEG   es,bx,<SIZE,LOAD>	
	mov	bx,ax
	RS_BASE add,bx
@@:
	ret
	assumes ds,DATA
PPrsOPrsSCAN	ENDP

sEnd	SCAN				
sBegin	CP				
	assumes CS,CP			

;***
;FFreePrs
;Purpose:
;	Given an oPrs, return zero in AX if it is a free prs
;	This is useful when a routine wants to activate a caller's prs
;	if it has not been freed during the course of the routine.
;Entry:
;	ax = oPrs
;Exit:
;	bx = pPrs
;	ax = zero if invalid prs, non-zero if valid prs
;	condition codes set based on value in AX
;Exceptions:
;	none.
;Preserves:
;	All but bx
;***************************************************************************
FFreePrs PROC	NEAR
	DbChk	ConStatStructs
	mov	bx,dataOFFSET prsCur	;assume oPrs is for prsCur
	SETSEG_EQ_SS	es
	cmp	ax,[grs.GRS_oPrsCur]
	jz	Got_pPrs1		;brif oPrs is for prsCur

	GETRS_SEG   es,bx,<SIZE,LOAD>	
	xchg	ax,bx
	RS_BASE add,bx			;bx points to prs in the Rs table
Got_pPrs1:
	mov	ax,PTRRS[bx.PRS_ogNam]	; ax = UNDEFINED if free prs
	inc	ax			;ax (and condition codes) = zero if free
	ret
FFreePrs ENDP

;***
;RsActivateIfNotFree
;Purpose:
;	Activate a register set if it is not a free prs
;	This is useful when a routine wants to activate a caller's prs
;	if it has not been freed during the course of the routine.
;	If oRs is a free prs, the current oRs is left active.
;Entry:
;	ax = oRs
;Exit:
;	none.
;Exceptions:
;	none.
;
;***************************************************************************
PUBLIC	RsActivateIfNotFree
RsActivateIfNotFree PROC NEAR
	or	ax,ax
	jns	NotAPrs			;brif activating an MRS
	push	ax
	and	ah,7Fh			;ax = oPrs (instead of an oRs)
	call	FFreePrs		;see if it is a free prs
	pop	ax			;restore ax = oRs
	jz	ItsFree			;brif prs is not active
NotAPrs:
	cCall	RsActivateCP,<ax>
ItsFree:
	ret
RsActivateIfNotFree ENDP

;***
;FieldsOfPrs
;Purpose:
;	Given an oPrs, get its oNam, Fields, and flags without changing 
;	the current prs.
;
;	Note: it costs nothing for this routine to return a pointer to the
;	prs in bx, BUT: caller beware! This represents a pointer either to
;	prsCur, OR into the global table of prs's. If the latter, then
;	the knowledge of what information is valid when in the table and
;	how to use it is best left internal to the contextmgr.
;Entry:
;	oPrs
;Exit:
;	ax = oNam (offset into the MODULE name table)
;	bx = pointer to the prs
;	cx = oPrs (same as input parm)
;	dl = procType
;	dh = proc's flags (only useful to masm callers)
;	es = seg of the prs (far Rs table versions only)
;
;	NOTE: The code that creates a new prs explicitly calls the namemgr
;		to create a name entry, even though it doesn't need the oNam.
;		This ensures that FieldsOfPrs doesn't need an out-of-memory
;		error return.
;Exceptions:
;	none.
;Preserves:
;	es
;***************************************************************************
cProc	FieldsOfPrs,<PUBLIC,NEAR,NODATA>
	parmW	oPrs
cBegin	FieldsOfPrs
	mov	ax,[oPrs]
	push	ax			;save for retval
	push	es			; preserve
	call	PPrsOPrs		;bx = pPrs
	DbHeapMoveOff			;assert no heap movement here

	push	bx			;save pPrs across call
	push	es			;save seg of Rs table across call
	push	PTRRS[bx.PRS_ogNam]	
	call	ONamOfOgNam		; get oNam for this prs

	DbHeapMoveOn
	DbAssertRel ax,nz,0,CP,<Out of memory error in FieldsOfPrs>
	pop	es
	pop	bx
	mov	dl,BPTRRS[bx.PRS_procType]
	mov	dh,BPTRRS[bx.PRS_flags]
	pop	es
	pop	cx			;return input oPrs
cEnd	FieldsOfPrs

cProc	FieldsOfPrsFar,<PUBLIC,FAR,NODATA>
	parmW	oPrs
cBegin	FieldsOfPrsFar
	cCall	FieldsOfPrs,<[oPrs]>
cEnd	FieldsOfPrsFar

;***
;SetPrsField
;Purpose:
;	Given an oPrs, an offset into the prs and a 16-bit value, set
;	the field at the given offset in the prs to that value.
;	This function is provided to eliminate the requirement to
;	activate and then deactivate a prs to set one field.
;
;	NOTE: This routine should not be used to set fields in the txd,
;	unless the caller first ensures that the prs (and thus, the txd)
;	is not active.
;
;Entry:
;	oPrs, oField, wValue
;Exit:
;	ax = oPrs (same as input)
;Exceptions:
;	none.
;Preserves:
;	es
;***************************************************************************
cProc	SetPrsField,<PUBLIC,NEAR,NODATA>,<es>
	parmW	oPrs
	parmW	oField
	parmW	wValue
cBegin	SetPrsField
	mov	ax,[oPrs]
	call	PPrsOPrs		;bx = pPrs, ax = oPrs
	add	bx,[oField]		;bx now points to desired field
	mov	cx,[wValue]		;fetch given value
	mov	PTRRS[bx],cx		;set the field with given value
cEnd	SetPrsField

;***
;OMrsORs
;Purpose:
;	Given an oRs, return the oMrs for the associated module.
;Entry:
;	ax = oRs
;Exit:
;	ax = oMrs for the module of the given oRs
;Exceptions:
;	none.
;Preserves:
;	all but bx and es
;***************************************************************************
	PUBLIC OMrsORs
OMrsORs	PROC NEAR
	test	ah,080H			;is this already an oMrs?
	jz	OMrsORs_Exit		;  brif so
	and	ah,07FH			;ax = an oPrs
	DbChk	oPrs,ax
	call	PPrsOPrs		;bx = pPrs
	mov	ax,PTRRS[bx.PRS_oMrs]
OMrsORs_Exit:
	DbChk	oMrs,ax
	ret
OMrsORs	ENDP
	

;***
;EnStaticStructs
;Purpose:
;	Called to ensure that mrsCur, prsCur (if a prs is active), and
;	txdCur are set up correctly for the current context. Used in
;	conjunction with DisStaticStructs.
;Entry:
;	grs.GRS_oRsCur set correctly for current context.
;	if conFlags bit flag F_CON_StaticStructs is reset (FALSE) on
;		entry, it is assumed that mrsCur, prsCur, and txdCur
;		contain no heap owners.
;Exit:
;	conFlags bit flag F_CON_StaticStructs is set (TRUE).
;	mrsCur and txdCur are activated.
;	if high bit of oRsCur is set, oPrsCur is activated.
;	ax = 0 if no action taken, non-zero otherwise. This allows the
;		caller an easy determination as to whether he should call
;		DisStaticStructs at some later point or not.
;***************************************************************************
cProc	EnStaticStructs,<PUBLIC,FAR,NODATA>
cBegin	EnStaticStructs
	xor	ax,ax			; assume no work to do
	test	[conFlags],F_CON_StaticStructs
	jnz	EnStatic_Exit		;brif things are already set correctly

	or	[conFlags],F_CON_StaticStructs
	mov	ax,UNDEFINED
	mov	[grs.GRS_oMrsCur],ax	;so MrsDeActivate doesn't get confused
	mov	[grs.GRS_oPrsCur],ax	;so PrsDeActivate doesn't get confused
	xchg	[grs.GRS_oRsCur],ax
	push	ax			;ax = oRsCur
	call	RsActivateCP		;reactivate mrsCur, prsCur, and txdCur
	mov	ax,sp			; non-zero indicates we changed the
					;  state of things
EnStatic_Exit:
cEnd	EnStaticStructs

;***
;DisStaticStructs
;Purpose:
;	Called to deactivate mrsCur, prsCur, and txdCur, and set a flag
;	such that RsActivateCP will do just the minimal amount of work, 
;	realizing that the actual register sets are in the tables, rather
;	than in their static structures.
;	This is the state of things whenever execution is begun, so procedure
;	call/return speed will be reasonable. GetEsDi fetches ES from the
;	appropriate table based on GRS fields set in this routine.
;Entry:
;	if conFlags bit flag F_CON_StaticStructs is set (TRUE) on
;		entry, it is assumed that mrsCur, prsCur, and txdCur
;		are set up.
;Exit:
;	conFlags bit flag F_CON_StaticStructs is reset (set to FALSE).
;	prsCur, mrsCur, and txdCur are deactivated, but the oRsCur and
;	oMrsCur & oPrsCur fields in grs are left correctly set.
;
;	In non-RELEASE code, mrsCur, prsCur, and txdCur get filled with
;	0FFFFH to help catch cases where code is depending on values in
;	these static structures when deactivated.
;***************************************************************************
cProc	DisStaticStructs,<PUBLIC,FAR,NODATA>
cBegin	DisStaticStructs
	test	[conFlags],F_CON_StaticStructs
	jz	DisStatic_Exit		;brif things are already set correctly

	push	[grs.GRS_oRsCur]	;preserve across MrsDeActivate call
	call	MrsDeActivate		;deactivate mrsCur, prsCur, and txdCur
	and	[conFlags],NOT F_CON_StaticStructs
	call	RsActivateCP		;oRsCur is still on the stack

DisStatic_Exit:
cEnd	DisStaticStructs

;***
; RsActivate, RsActivateCP
; Purpose:
;	Activate a given Module's or Procedure's register set.
;
;	NOTE: This function does one of two very different things based
;		on the current setting of the F_CON_StaticStructs bit flag
;		in 'conFlags'. If static structures are currently being used
;		to maintain mrsCur, prsCur & txdCur, then this just calls
;		MrsActivate or PrsActivate; if not, then the only action
;		is to update some grs fields.
; Entry:
;	parm1: ushort oRsNew - If high bit is set, low 15 bits = oPrs
;	                       else low 15 bits = oMrs to activate
; Exit: Preserves input AX value, and sets PSW based on an OR AX,AX on exit
;
; Preserves:
;	AX
;
;***************************************************************************
cProc	RsActivateCP,<PUBLIC,NEAR,NODATA>
	parmW	oRsNew
cBegin	RsActivateCP
	push	ax			;preserve input value
	mov	ax,[oRsNew]

	test	[conFlags],F_CON_StaticStructs
	jz	No_StaticStr		;brif no static structures

	inc	ax
	js	GotAPrs			;brif not mrs or UNDEFINED
	dec	ax			;ax = oMrs or UNDEFINED
	push	ax
	call	MrsActivateCP
	jmp	SHORT RsActCPExit
GotAPrs:
	dec	ax			;ax = 8000h + oPrs
	and	ah,7Fh			;mask off high bit, ax = oPrs
	push	ax
	call	PrsActivateCP
	jmp	short RsActCPExit

No_StaticStr:				;no static structures; mrsCur and
					;  prsCur are to be found in the Rs tbl
	push	ax
	call	far ptr RsActivateCODEFar
RsActCPExit:
	pop	ax			; restore input value
	or	ax,ax			; set PSW based on input ax, as a
					;   service to some callers
cEnd	RsActivateCP

cProc	RsActivate,<PUBLIC,FAR,NODATA>
	parmW	oRsNew
cBegin	RsActivate
	push	oRsNew
	call	RsActivateCP
cEnd	RsActivate

;NOTE: For EB, the ForEach... varients which take a far pointer cannot be
;NOTE: supported, because code segments could move. The only callers which
;NOTE: use FE_FarCall (below) are the QB User Interface, and a couple of
;NOTE: non-Release routines; these latter are okay for EB, as we'll make the
;NOTE:
;***
;ForEachMrs(pFunction)
;
;Purpose:
;	 Invoke *pFunction for each module, after first making that module the
;	 current module.
;	 If pFunction ever returns FALSE,
;	    ForEachMrs() returns FALSE without examining
;	    any further modules
;	 Else
;	    returns TRUE (non-zero)
;
;     NOTE: This routine is guaranteed to cause no heap movement in and of
;		itself; the function if CALLS may cause heap movement however.
;
;Usage:
;	 boolean ClearModule()
;	 if (ForEachMrs(ClearModule)) {...
;Entry:
;	 pFunction is the FAR address of a the function to be
;	    invoked for each module.
;        the static fMrsTextMask is a flags mask; if we're to search for ALL
;		mrs's (i.e., those for user text objects as well as for modules)
;		then this will be 0, otherwise, it will be set so we can filter
;		out mrs's for which the fText flag is set, and call the given
;		function only for each module. The default is to call it for
;		modules only.
;		NOTE: Even though the flags byte in the mrs structure is a byte,
;			this static mask is a word, so we can keep it in SI - -
;			all the high bits are zero in the mask all the time, so
;			we can safely TEST it against the flags byte as if it
;			were a word.
;Exit:
;	 returns TRUE (non-zero) iff pFunction returned TRUE for each module.
;        ALWAYS restores initial module on exit.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	ForEachMrs,<PUBLIC,FAR,NODATA>
	parmD	pFunction
cBegin	ForEachMrs
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_FarCall+FE_SaveRs
	les	bx,[pFunction]
	call	ForEachCP
cEnd	ForEachMrs

;***
;ForEachPrsInMrs(pFunction)
;
;Purpose:
;	 Invoke *pFunction for each procedure in the current module after first
;	 making that procedure current.
;	 If pFunction ever returns FALSE,
;	    ForEachPrsInMrs() returns FALSE without examining
;	    any further procedures
;	 Else
;	    returns TRUE (non-zero)
;
;     NOTE: This routine is guaranteed to cause no heap movement in and of
;		itself; the function if CALLS may cause heap movement however.
;
;     NOTE: This routine assumes that, if a prs is active on entry, it can
;		safely be reactivated on exit.
;Usage:
;	 boolean ClearPrs()
;	 if (ForEachPrsInMrs(ClearPrs) {...
;Entry:
;	 pFunction is the FAR address of the function to be
;	    invoked for each procedure in the module.
;Exit:
;	 returns TRUE (non-zero) iff pFunction returned TRUE for each prs.
;	 Always restores initial Mrs and Prs on exit.
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	ForEachPrsInMrs,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmD	pFunction
cBegin	ForEachPrsInMrs
	mov	al,FE_PcodePrs+FE_NoPcodePrs+FE_FarCall+FE_SaveRs
	les	bx,[pFunction]
	call	ForEachCP
cEnd	ForEachPrsInMrs

;*******************************************************************************
;ForEach(flags, pFunction)
;Purpose:
;	Same as ForEachCP
;Entry:
;	flags identifies what is to be done (FE_xxx)
;	pFunction = adr of FAR function to call
;Exit:
;	Same as ForEach
;Uses:
;	none.
;Exceptions:
;	none.
;
;*******************************************************************************
cProc	ForEach,<PUBLIC,FAR>
	parmB	flags
	parmD	pFunction
cBegin
	mov	al,[flags]
	les	bx,[pFunction]
	call	ForEachCP
cEnd

;*******************************************************************************
;ForEachTxtTblInMrs
;Purpose:
;	Same as ForEachCP, except pFunction is called for the
;	mrs's text table, and for every SUB and FUNCTION's text table
;Entry:
;	bx = offset into CP segment to function to be called
;
;*******************************************************************************
cProc	ForEachTxtTblInMrs,<PUBLIC,NEAR>
cBegin	<nogen> 			
	mov	al,FE_CallMrs+FE_PcodePrs+FE_SaveRs
	jmp	SHORT ForEachCP
cEnd	<nogen> 			

;*******************************************************************************
;ForEachTxtTbl
;Purpose:
;	Same as ForEachCP, except pFunction is called for each
;	mrs's text table, and for every SUB and FUNCTION's text table
;Entry:
;	bx = offset into CP segment to function to be called
;
;*******************************************************************************

;*******************************************************************************
;ForEachCP
;Purpose:
;	If pFunction ever returns FALSE,
;	   ForEachCP() returns FALSE without examining any further register sets
;	Else
;	   returns TRUE (non-zero)
;	This function can be called recursively
;NOTE:
;	This routine is guaranteed to cause no heap movement in and of
;	itself; the function it CALLS may cause heap movement however.
;NOTE:
;	None of the ForEach routines invoke the given function with the 
;	global mrs active EVER, regardless of the passed flag combinations.
;Entry:
;	if near (CP) callee, bx = adr of function to call
;	else es:bx = adr of function to call
;	flags identifies what is to be done (FE_xxx)
;	 These flags indicate for what contexts pFunction is to be called:
;	  FE_PcodeMrs	TRUE if mrs's containing pcode are to be visited
;			(NOTE: This does not include INCLUDE mrs's, even
;			 though they have the FM2_NoPcode bit set to 0)
;	  FE_TextMrs	TRUE if FM2_NoPcode mrs's are to be visited (i.e.
;			INCLUDE files, command window's mrs, document files)
;	  FE_CallMrs	TRUE if pFunc is to be called for mrs's text table
;	  FE_PcodePrs	TRUE if prs's with text tables (SUBs/FUNCTIONs)
;			are to be visited
;	  FE_NoPcodePrs	TRUE if DEF FN and DECLARE prs's are to be visited
;	 These flags indicate how pFunction is to be called:
;	  FE_FarCall	TRUE if function to be called is FAR
;			(NOTE: only available in non-Release and non-windows
;				code)
;	  FE_SaveRs	TRUE if ForEach is to restore caller's oRsCur on exit
;
;For Example, (ignoring FE_FarCall and FE_SaveRs):
;	if pFunction is to be called for File (pcode or document):
;	   al=FE_PcodeMrs+FE_TextMrs+FE_CallMrs
;	if pFunction is to be called for every pcode text table in the system
;          and it is to be called for the MRS BEFORE all prs's in that module:
;	   al=FE_PcodeMrs+FE_CallMrs+FE_PcodePrs
;	if pFunction is to be called for every pcode text table in the system
;          and it is to be called for the MRS AFTER all prs's in that module:
;	   al=FE_PcodeMrs+FE_CallMrsAfter+FE_PcodePrs
;	if pFunction is to be called for every pcode text table in the system
;          and it is to be called for the MRS BEFORE AND AFTER all prs's in
;	   that module:
;	   al=FE_PcodeMrs+FE_CallMrs+FE_CallMrsAfter+FE_PcodePrs
;	if pFunction is to be called for every prs in the system:
;	   al=FE_PcodeMrs+FE_PcodePrs+FE_NoPcodePrs
;	if pFunction is to be called for every prs in current module:
;	   al=FE_PcodePrs+FE_NoPcodePrs
;	if pFunction is to be called for every prs in the system which
;	   has no text table (DEF FNs and DECLAREs):
;	   al=FE_PcodeMrs+FE_NoPcodePrs
;Exit:
;	Returns TRUE (non-zero) iff pFunction returned TRUE for each module.
;       If FALSE is returned and caller didn't have FE_SaveRs set in the
;		input flags byte, the active prs and/or mrs is/are for
;		the context from which pFunction returned FALSE.
;Uses:
;	none.
;Exceptions:
;	none.
;
;*******************************************************************************

cProc	ForEachTxtTbl,<PUBLIC,NEAR>
cBegin	<nogen> 			
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_PcodePrs+FE_SaveRs
cEnd	<nogen> 			
	;fall into ForEachCP
;Register usage:
;	si = current oMrs
;	di = current oPrs
;
cProc	ForEachCP,<PUBLIC,NEAR>,<si,di>
	localD	pFunction
	localW	oMrsSave
	localW	oPrsSave
	localB	flags
	localB	fDoneWithPrss
cBegin
	DbChk	ConStatStructs
	mov	[flags],al
	mov	[OFF_pFunction],bx
	mov	[SEG_pFunction],es
	mov	ax,[grs.GRS_oMrsCur]	;save caller's register set
	mov	[oMrsSave],ax
	mov	ax,[grs.GRS_oPrsCur]	;save caller's register set
	mov	[oPrsSave],ax

	mov	di,UNDEFINED		;start with 1st prs in mrs
	test	[flags],FE_PcodeMrs OR FE_TextMrs
	jz	ThisMrsOnly		;brif not visiting all mrs's
	mov	si,OMRS_GLOBAL		; start with 1st mrs, skip gMrs
MrsLoop:
	GETRS_SEG   es,bx,<SIZE,LOAD>	
	RS_BASE add,si
	mov	si,PTRRS[si.MRS_oMrsNext]
	inc	si			;Any more mrs's left?
	jnz	NotDone 		;  brif not
	jmp	FeExitTrue		;exit if beyond end of table

NotDone:
	dec	si
	mov	bx,si
	RS_BASE add,bx			; swapped these ...
	cmp	[grs.GRS_oMrsCur],si	; ... two instructions
	jnz	MrsNotActive		;brif desired mrs is not mrsCur

	mov	bx,dataOFFSET mrsCur
	SETSEG_EQ_SS	es		;mrsCur is in DGROUP, not rs table seg
MrsNotActive:
	mov	al,FE_PcodeMrs
	test	BPTRRS[bx.MRS_flags2],FM2_NoPcode OR FM2_Include
	jz	GotPcodeMrs		;brif got a REAL pcode mrs (not ascii
					; text or INCLUDE file)
	shl	al,1			;al = FE_TextMrs
.errnz	FE_TextMrs - (FE_PcodeMrs + FE_PcodeMrs)
GotPcodeMrs:
	test	[flags],al
	jz	MrsLoop			;brif this mrs is not to be visited

	cCall	MrsActivateCP,<si>	;activate next entry
;We're interested in this mrs.  Call pFunction with one or more of:
; - the mrs's active,
; - each prs which has a text table active,
; - each prs which has no text table active.
;
ThisMrsOnly:
	mov	[fDoneWithPrss],0
	call	PrsDeactivate		;make module's text table active
	test	[flags],FE_CallMrs
	jnz	CallFunc		;brif pFunction is to be called for mrs

PrsLoop:
	xchg	ax,di			;ax = current oPrs
	mov	bx,[grs.GRS_oMrsCur]	;cx = module of interest
	call	GetNextPrsInMrs		;ax = next prs
	xchg	di,ax			;save oPrs in di
	or	di,di
	js	PrsDone			;brif no more prs's
	mov	al,FE_PcodePrs
	GETRS_SEG   es,bx,<SIZE,LOAD>	
	mov	bx,di			;bx = oPrs
	RS_BASE add,bx			;bx = pPrs of prs we propose activating
	;NOTE: [13] we can safely add the table base here because we explicitly
	;NOTE: [13] called PrsDeactivate, above
	DbAssertRel di,nz,grs.GRS_oPrsCur,CP,<ForEachCP: active prs in PrsLoop>
	cmp	PTRRS[bx.PRS_txd.TXD_bdlText_status],NOT_OWNER
	jnz	GotPcodePrs		;brif got a prs with pcode-text-table
					; i.e. a SUB or FUNCTION
	shl	al,1			;al = FE_NoPcodePrs
.errnz	FE_NoPcodePrs - (FE_PcodePrs + FE_PcodePrs)
GotPcodePrs:
	test	[flags],al
	jz	PrsLoop			;brif this prs is not to be visited
CallFunc:
	cCall	PrsActivateCP,<di>	;activate next prs (or activate module
					; if di==UNDEFINED
	test	[flags],FE_FarCall
	jnz	CallFarFunc
	mov	bx,[OFF_pFunction]
	call	bx			;call given NEAR function
	jmp	SHORT CallRet

CallFarFunc:
	cCall	pFunction		;call given FAR function
CallRet:
	or	ax,ax			;is retval FALSE?
	jz	FeExit			;  brif so
	cmp	[fDoneWithPrss],0
	jne	DoneWithThisMrs		;brif just called for MRS after PRSs
	test	[flags],FE_PcodePrs OR FE_NoPcodePrs
	jnz	PrsLoop			;brif visiting prs's
PrsDone:
	call	PrsDeactivate		;make module's text table active
	mov	[fDoneWithPrss],1	;remember that we're done with this
					;module's prss
	test	[flags],FE_CallMrsAfter
	jnz	CallFunc		;brif pFunction is to be called for mrs
DoneWithThisMrs:
	test	[flags],FE_PcodeMrs OR FE_TextMrs
	jz	FeExitTrue
	jmp	MrsLoop			;brif visiting mrs's
					;ax is still = pFunction's return value
FeExitTrue:
	mov	ax,sp			;return TRUE (non-zero)
FeExit:
	xchg	ax,si			;save ret value in si

	test	[flags],FE_SaveRs
	jz	FeNoRestore		;brif caller wants to restore oRs
	push	[oMrsSave]
	cCall	MrsActivateCP		;activate caller's mrs
	push	[oPrsSave]
	cCall	PrsActivateCP		;activate caller's prs

	;Note that saving grs.oRsCur on entry and calling RsActivate
	;on exit is not sufficient, because if the caller's prs was
	;not defined, RsActivate would not activate the caller's mrs.

FeNoRestore:
	xchg	ax,si			;ax = return value
	or	ax,ax			;set condition codes for caller
cEnd

;***
;ForEachPrsInPlaceCP, ForEachPrsInPlaceCPSav
;
;Purpose:
;	This function walks through each prs, and passes a POINTER to the
;	current PRS to the specified function.	This function is guaranteed
;	not to cause ANY heap movement of and by itself.  The called function
;	is responsible for any adjustment to the entry pPrs to account for
;	heap movement that it may cause.
;	[63] If the called function returns AX == 0 then
;	     the ForEach is aborted. Note: called function
;	     must return with CC reflecting contents of AX.
;
;	This routine exists primarily to speed up text editting.  It can
;	be used when an innocuous action needs to be taken for each PRS
;	in the system (eg - checking PRS flags for particular conditions).
;	This routine is SIGNIFICANTLY faster than the generalized ForEach
;	construct since it just walks the table of Prs's instead of activating
;	each PRS individually.
;
;	ForEachPrsInPlaceCPSav - restores callers oRs on Exit
;
;Entry:
;	bx = CP adr of function to call
;Exit:
;	ax = last value return by the called function
;	Condition Codes reflect contents of ax
;Uses:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	ForEachPrsInPlaceCPSav,<NEAR,PUBLIC,NODATA>
cBegin	ForEachPrsInPlaceCPSav
	push	[grs.GRS_oRsCur]	;remember current oRs for RsActivate
	call	ForEachPrsInPlaceCP
	pop	bx			
	push	ax			
	push	bx			
	call	RsActivateCP		;oRsCur already on stack
	pop	ax			
	or	ax, ax			
cEnd

cProc	ForEachPrsInPlaceCP,<NEAR,PUBLIC,NODATA>,<SI,DI>
cBegin	ForEachPrsInPlaceCP
	xchg	bx,di			;di = function address
	call	PrsDeactivate		;deactivate prs
	mov	si,[oPrsFirst]		;first prs in Rs table
	GETRS_SEG   es,bx,<SIZE,LOAD>	

	DbHeapMoveOff			;assert no heap movement in this section

	;------------------------------------------------------
	;Now,	si == offset to current entry
	;	di == CP addr of ForEach function
	;------------------------------------------------------
	push	sp			; TRUE return value (when no prs's)
PrsInPlaceLoop:
	inc	si			;any entries remaining in table?
	.errnz	UNDEFINED - 0FFFFH
	jz	PrsInPlaceExit		;end of table

	dec	si
	RS_BASE add,si
	pop	ax			; toss last return value
	call	di			;call function
	push	ax			; save return value
	jz	PrsInPlaceExit		; Exit and return Z
	GETRS_SEG   es,bx,<SIZE,LOAD>	

	mov	si,PTRRS[si.PRS_oPrsNext]
	jmp	PrsInPlaceLoop		;loop to consider next entry

PrsInPlaceExit:

	DbHeapMoveOn			;heap movement allowed again

	pop	ax			; Return value
	or	ax,ax			

cEnd	ForEachPrsInPlaceCP

;***
; ValidORs_Check
; Purpose:
;	Given what might be an oRs, return FALSE if it matches oMrsCur or
;	oPrsCur.
;	Used in conjunction with ValidORs.
; Entry:
;	grs.GRS_oRsCur
;	
; Exit:
;	AX = FALSE if oRs looks valid, otherwise TRUE.
;
;***************************************************************************
cProc	ValidORs_Check,<NEAR,NODATA>
cBegin	ValidORs_Check
	mov	ax,sp			;non-zero
	mov	bx,[oRsTest]
	cmp	bx,[grs.GRS_oRsCur]
	jnz	ValidORs_Check_Exit	;brif oRs's don't match

	or	bx,bx
	jns	ValidORs_Check_Done	;brif oRs not an oPrs - - - success
	cmp	[prsCur.PRS_procType],PT_DEFFN
	jz	ValidORs_Check_Done	;brif oRs for an active DEF FN - okay
	test	[txdCur.TXD_flags],FTX_mrs
	jnz	ValidORs_Check_Exit	;brif oRsCur is for prsCur, but the
					;  active text table for mrsCur.
ValidORs_Check_Done:
	xor	ax,ax			;success
ValidORs_Check_Exit:
cEnd	ValidORs_Check

;***
; ValidORs
; Purpose:
;	Given what might be an oRs and an oTx, tell caller if they look
;	valid or not.
;	If they look valid, activate the oRs.
;	[10] NOTE: given the oRs for the global mrs (i.e., OMRS_GLOBAL),
;	[10]	ValidOrs will say that it looks Invalid.
; Entry:
;	[di+4] = possible oRs
;	[di+2] = possible oTx
; Exit:
;	AX != 0 if oRs and oTx don't look valid; otherwise,
;		AX = 0, and the given oRs is activated.
;
;***************************************************************************
cProc	ValidORs,<PUBLIC,NEAR,NODATA>
cBegin	ValidORs
	mov	ax,[di+4]
	mov	[oRsTest],ax
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_PcodePrs+FE_NoPcodePrs
	push	cs
	pop	es
	mov	bx,OFFSET CP:ValidORs_Check
	call	ForEachCP		;returns AX = 0 if oRs valid
cEnd	ValidORs

sEnd CP

sBegin CODE
	assumes CS,CODE


;***
; RsActivateCODE
; Purpose:
;	Activate a given Module's or Procedure's register set.
;
;	NOTE: This function is only callable when static structures are
;		disabled.
; Entry:
;	ax = oRsNew - If high bit is set, low 15 bits = oPrs
;	              else low 15 bits = oMrs to activate
; Exit:
;	Updates the oRsCur, oMrsCur, oPrsCur and offsetTxdSeg fields in the 
;	grs structure as appropriate, based on the input oRs.
;	if FV_FAR_RSTBL, es is set to the seg of the Rs table on exit.
;	if SizeD, ds is set to the seg of the variable table for mrsCur.
;***************************************************************************
PUBLIC RsActivateCODE
RsActivateCODE	PROC	NEAR
	DbChk	oRs,ax
	mov	[grs.GRS_oRsCur],ax
	GETRS_SEG   es,bx,<SIZE,LOAD>	

	or	ax,ax
	js	Activate_oPrs		;brif oRsNew is an oPrs

	mov	[grs.GRS_oMrsCur],ax
	mov	bx,ax
	RS_BASE add,bx			;bx = pMrsCur
	mov	[grs.GRS_pMrsCur],bx	;set up to save code when accessing
	mov	[grs.GRS_pRsCur],bx	;set up to save code when accessing
	add	ax,MRS_txd.TXD_bdlText_seg
					;ax = offset in tRs to the segment
					;     address of the current text table
	mov	[grs.GRS_oPrsCur],UNDEFINED

	mov	[grs.GRS_offsetTxdSeg],ax

	DbChk	ConNoStatStructs
;start of [20]
;end of [20]
	ret

Activate_oPrs:
	and	ah,7Fh			;mask off high bit, ax = oPrs
	mov	[grs.GRS_oPrsCur],ax
	mov	bx,ax			;bx = oPrsNew
	RS_BASE add,bx			;bx = pPrsNew
	mov	cx,PTRRS[bx.PRS_oMrs]
	mov	[grs.GRS_oMrsCur],cx
	mov	[grs.GRS_pRsCur],bx
	add	cx,[grs.GRS_bdRs.BD_pb]
	mov	[grs.GRS_pMrsCur],cx
	DbChk	ConNoStatStructs
	cmp	PTRRS[bx.PRS_txd.TXD_bdlText_status],NOT_OWNER
	jz	Activate_oPrs_Def	;brif oPrsNew is for a DEF FN/DECLARE

	add	ax,PRS_txd.TXD_bdlText_seg
					;ax = offset in Rs table to the segment
					;     address of the current text table
	mov	[grs.GRS_offsetTxdSeg],ax
;start of [20]
;end of [20]
	ret

Activate_oPrs_Def:
	sub	cx,[grs.GRS_bdRs.BD_pb]
	add	cx,MRS_txd.TXD_bdlText_seg
	mov	[grs.GRS_offsetTxdSeg],cx
	ret
RsActivateCODE	ENDP

;***
; RsActivateCODEFar
; Purpose:
;	Activate a given Module's or Procedure's register set.
;	Far interface to RsActivateCODE
;
;	NOTE: This function is only callable when static structures are
;		disabled.
; Entry:
;	ax = oRsNew - If high bit is set, low 15 bits = oPrs
;	              else low 15 bits = oMrs to activate
;
;***************************************************************************
cProc	RsActivateCODEFar,<PUBLIC,FAR,NODATA>
	parmW	oRsNew
cBegin	RsActivateCODEFar
assumes ds,NOTHING
	mov	ax,[oRsNew]
	call	RsActivateCODE
assumes ds,DATA
cEnd	RsActivateCODEFar

sEnd	CODE


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\binxlat.asm ===
TITLE	BINXLAT.ASM - Binaray file translation code
;*** 
;BinXlat.ASM - Provides binaray file translation
;
;	Copyright (C) 1988-1989, Microsoft Corporation
;
;Purpose:
;	BinXlat.ASM contains the product to product binary file translation
;	code.  in general, the translation is done by a routine called a
;	"specific translator" which is geared toward the translation of a
;	specific product's (or group of products) into our own.  currently
;	the following specific translators are defined:
;	    Xlat4045	    QB 4.0 -> QB 4.5
;	    XlatGeneral     general translation
;
;Specific Translators:
;	the specific translator is called for each text table in the program.
;	it should translate the text table and then return.
;
;	the following guidelines should be followed when adding specific
;	translators to the system:
;	    - the following registers and memory will be set up upon entry:
;		es:si		points to first opcode in text table
;	    - the offset of the translator data (in DS) set up by InitBinXlat
;	      is in oXlatData.
;	    - if an error which requires the load to be aborted occurs:
;		- return ax == 0
;		- set the word at [oXlatData] to a message number to display
;	    - if a warning error occurs:
;		- return ax != 0
;		- set the appropriate flag in the flag byte at [oXlatData]
;	    - if the translation succeeds:
;		- return ax != 0
;	    - the specific translator does not need to save di and si.
;
;Notes:
;	before calling any of the binary translation routines InitBinXlat
;	should be called.  InitBinXlat sets up internal data, and checks
;	to see if translation is required.
;
;	the main entrypoint in this module is BinaryXlat.  BinaryLoad should
;	call this routine if InitBinXlat says that binary translation is
;	necessary (in other words, the format and revision bytes in the binary
;	files header don't match).
;
;	all of the information required by XlatTxtTbl is placed on the stack
;	since the translator resides in both the SCAN and CP segments.
;
;	the translation is performed with ForEachTxtTblInMrs with the routine
;	XlatTxtTbl as the function to call.  XlatTxtTbl calls the specific xlatr.
;
;*******************************************************************************

	.xlist

	include 	version.inc
	include 	cw/cowdef.inc

	IncludeOnce	architec
	includeOnce	conint
	includeOnce	context
	includeOnce	opcodes
	includeOnce	optables
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtps
	includeOnce	txtint
	includeOnce	txtmgr

	includeOnce	ssint

	.list


;WARNING: much of this code ASSUMES that SS and DS are the SAME!  do not change
;WARNING: the assumes at the beginning of this file or BinarySav.ASM without
;WARNING: making appropriate changes to the source.

	assumes DS,DATA
	assumes SS,DATA
	assumes ES,NOTHING


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\dshcmd.c ===
/*** 
*dshcmd.c - dumb shell debug command processor
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*Purpose:
*	For versions of QB-technology based BASIC built without the real user-
*	interface.
*
*******************************************************************************/

#include "version.h"

#if !CONTEXT_H
#include "context.h"
#endif

#if !CONINT_H
#include "conint.h"
#endif

#if !EXECUTOR_H
#include "executor.h"
#endif

#if !HEAP_H
#include "heap.h"
#endif

#if !LISTER_H
#include "lister.h"
#endif

#if !NAMES_H
#include "names.h"
#endif

#if !PARSER_H
#include "parser.h"
#endif

#ifndef RTINTERP_H
# include "rtinterp.h"
#endif

#if !RTTEMP_H
# include "rttemp.h"
#endif

#if !SCANNER_H
#include "scanner.h"
#endif

#if !TXTMGR_H
# include "txtmgr.h"
#endif

#if !UI_H
#include "ui.h"
#endif

#if !UTIL_H
#include "util.h"
#endif

#if !VARIABLE_H
#include "variable.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\dshstrng.c ===
/*** 
*dshstrngs.c - print strings for dumb shell debug command processor
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*Purpose:
*	For versions of QB-technology based BASIC built without the real user-
*	interface.
*
*******************************************************************************/

#include "version.h"

#if !SCANNER_H
#include "scanner.h"
#endif

#if !UI_H
#include "ui.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\conmisc.asm ===
TITLE   conmisc.asm - miscellaneous context-related routines
;***
;conmisc.asm - miscellaneous context-related routines for QBI
;
;       Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;       - CLEAR support
;       - NEW support
;       - Runtime Initialization
;       - Context-sensitive heap management support (updating backpointers ...)
;       - other miscellaneous context-related support
;
;
;*******************************************************************************

        .xlist

        include version.inc 
        CONMISC_ASM = ON 
	includeOnce	architec
	includeOnce	conint
	includeOnce	context
	includeOnce	executor
	includeOnce	heap
	includeOnce	names
	includeOnce	parser
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	scanner 	
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	variable

        .list

        assumes CS,CP
        assumes DS,DATA
        assumes SS,DATA
        assumes ES,NOTHING


sBegin  DATA
	globalB	fChaining,FALSE		;TRUE while reinit code is being used
					;  while loading a new program we're
					;  CHAINing to
	staticW	oMrsDesired,0		;used to find an oMrs of specified type
	externB	fInitialized
	externB b$CtrlFlags		;a byte of various runtime bit flags
	externB b$ScreenRestored	;flag set by B$RUNINI
sEnd    DATA

	EXTRN	B$RUNINI:FAR
	EXTRN	B$CHNINI:FAR


sBegin	RT				;so RTOFFSET is defined
sEnd	RT


sBegin CP

;***
;AdjustRsTable
;Purpose:
;	Adjust owners in the global Rs table when it moves.
;	This amounts to walking the mrs chain, adjust the var table
;	backpointers.
;Entry:
;	SI = pbTable = pointer to the start of the appropriate table
;       DI = an adjustment factor to be passed via BdAdjust to update the
;               backpointer for each bd in grs.bdtComBlk.
;Exit:
;       none.
;Exceptions:
;       none.
;
;***************************************************************************
cProc	AdjustRsTable,<PUBLIC,NEAR,NODATA>
cBegin
	mov	si,OMRS_GLOBAL		
	test	[conFlags],F_CON_StaticStructs
	jnz	RsAdjust_Cont		  ;brif static structs - pMrsCur not used

	add	[grs.GRS_pMrsCur],di	;update pointer to mrsCur for use
					;  at execution
	TESTM	grs.GRS_oRsCur,08000H	; is active Rs an mrs?
	jnz	RsAdjust_Cont		  ;  brif so
	
	add	[grs.GRS_pRsCur],di	;update pointer to current Rs for use
					;  at execution
RsAdjust_Cont:
        ;--------------------------------------------------------------------
	; now,	SI = offset to current mrs
	;	DI = adjustment factor for the backpointer into this table
        ;--------------------------------------------------------------------
RsAdjust_Entry:
	cmp	si,[grs.GRS_oMrsCur]
	jnz	RsAdjust_It

	test	[conFlags],F_CON_StaticStructs
	jz	RsAdjust_It		;brif not static structs

	mov	si,dataOFFSET mrsCur
	jmp	short RsAdjust_Next	;brif this is mrsCur - - - static struct
					;  won't move
RsAdjust_It:
	add	si,[grs.GRS_bdRs.BD_pb] ;si points to an mrs in table
	mov	ax,si
	add	ax,MRS_bdVar
	cCall	BdAdjust,<ax>		;adjust bdVar in current mrs
RsAdjust_Next:
	mov	si,[si.MRS_oMrsNext]
	inc	si
	jz	RsAdjust_Done
	dec	si
	jmp	short RsAdjust_Entry
RsAdjust_Done:
cEnd

;***
;AdjustITable
;Purpose:
;       Given a pointer to either grs.bdtMrs or grs.bdtComBlk
;       and the constant IT_MRS or IT_COMMON_BLOCK to indicate which
;       one, walk through through the table, calling the Heap Manager (via
;       BdAdjust) to adjust the backpointer for each of the bd structures in
;       each entry by the constant given in DI.
;
;       This routine is called when the heap manager finds it necessary to
;       move one of these tables, in order to update backpointers to owners
;       in the table as quickly as possible.
;
;       Note that this routine depends on the fact that each of these tables
;	contain entries which have one or two bd structures, depending
;	on the table type. We also assume that the bd structures are contiguous.
;Entry:
;       pbTable = pointer to the start of the appropriate table
;       oPastLast is the cbLogical of the appropriate table. This amounts
;               to an offset to where the NEXT entry would go into the table,
;               and is thus a measure of where the table ends (cbLogical is
;               kept to the actual size of the table).
;       heapType is one of IT_MRS or IT_COMMON_BLOCK.
;       DI = an adjustment factor to be passed via BdAdjust to update the
;               backpointer for each bd in grs.bdtComBlk.
;Exit:
;       none.
;Exceptions:
;       none.
;
;***************************************************************************
cProc   AdjustITable,<PUBLIC,FAR,NODATA>,<SI>
        parmW   pbTable
        parmW   oPastLast
        parmB   heapType
        LocalW  cbAdvance               ;cb to advance to next entry
        LocalW  pbInvalid               ;pointer to 1st byte past last entry
cBegin  AdjustITable
        mov     cx,[oPastLast]		
	jcxz	Adjust_Done		;Stop right now if empty table
        mov     al,[heapType]		
        mov     si,[pbTable]
	cmp	al,IT_COMMON_BLOCK	;is it grs.bdtComBlk?
        jz      Adjust_Cont             ;  brif so

	DbAssertRelB  al,z,IT_MRS,CP,<AdjustITable: unknown heapType>
	call	AdjustRsTable
	jmp	short Adjust_Done

Adjust_Cont:
        add     cx,si                   ;now cx equals end-of-table pointer
        mov     [pbInvalid],cx		

	add	si,COM_bdType		
	mov	[cbAdvance],(SIZE COM - SIZE BD)  
        ;--------------------------------------------------------------------
        ; now,  SI = pointer to current bd to be adjusted
        ;       DI = adjustment factor for each backpointer into this table
	;	cbAdvance = count of bytes from start of last bd to first
	;		    bd in next entry
        ;       pbInvalid = pointer to first byte past last entry in table
        ;--------------------------------------------------------------------
Adjust_Entry:
        cmp     si,[pbInvalid]          ;any entries left?
        jae     Adjust_Done             ;  brif not

        cCall   BdAdjust,<si>           ;adjust first bd in current entry

        add     si,SIZE BD              ;move to next bd
	cmp	[si.BD_cbPhysical],UNDEFINED
					;is this bd really used to store info.
					;  about a U.L. COMMON block?
	jz	Adjust_Advance		;  brif so
        cCall   BdAdjust,<si>           ;adjust it
Adjust_Advance:
	add	si,[cbAdvance]		;advance to next entry in table
	jnc	Adjust_Entry		; brif not special case: wrap
					;	past FFFF
Adjust_Done:
cEnd    AdjustITable



;***
;ClearTheWorld()
;
;Purpose:
;       Clear all common variables and clear all module and procedure static 
;	variables. Does NOT clear (release) frame variables.
;Entry:
;       none.
;Exit:
;       none.
;*******************************************************************************
cProc   ClearTheWorld,<PUBLIC,NEAR,NODATA>
cBegin  ClearTheWorld
	DbChk	ConStatStructs			;ensure static structures
	test	[grs.GRS_flagsDir],FDIR_cleared	;is the world already clear?
	jnz	ClearWorld_Exit			;  brif so - no work to do

Clear_Common:
        cCall  ClearCommon
	mov	bx,OFFSET CP:ClearPV
	call	ForEachPrsInPlaceCPSav		;clear all prs var tables

	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
        mov	bx,OFFSET CP:ClearMV
        call    ForEachCP			;clear all mrs tables
						;retval guaranteed TRUE
	or	[grs.GRS_flagsDir],FDIR_cleared	;note that world is now clear

	and	[mrsCur.MRS_flags],NOT FM_VARNEW ;reset bit in mrs flags, in
						 ; case we were called as
						 ; VarDealloc
ClearWorld_Exit:
cEnd	ClearTheWorld


;***
;VarDealloc()
;
;Purpose:
;       Use ClearTheWorld to deallocate all variables in the current module
;
;	Note: shares exit with ClearTheWorld.
;
;	Note: For QB, this clears all variables in the system, whereas for
;	      EB, just the variables for the current module (and all proc-
;	      level statics for procedures in the module) are cleared.
;Entry:
;	none in FV_QB4LANG versions.
;	in other versions, fClearPV TRUE means we should clear proc-level
;		(static) vars as well as module-level vars for the module
;Exit:
;       none.
;*******************************************************************************
cProc	VarDealloc,<PUBLIC,NEAR,NODATA>
cBegin  VarDealloc
	DbChk	ConStatStructs			;ensure static structures
	or	[mrsCur.MRS_flags],FM_VARNEW	;tell CLEAR code we want to
						; deallocate $static arrays,
						; not just zero-fill them (in
						; this module only)
	jmp	short Clear_Common		;share exit with ClearTheWorld
cEnd	<nogen>

						
						
;***
;NewStmt()
;
;Purpose:
;     This is  called by  the NEW,  CHAIN, LOAD  statement executers  to do  the
;     following:
;     - ForEachMrs, discard the mrs
;     - Calls RunInit()
;     - Trims the mrs table so that it includes only the mrs for module Untitled
;     - releases all prs table entries
;     - reinitializes the procedure table
;     - Calls  the variable  manager's ResetCommon()  function  to  discard  all
;       COMMON value and type blocks and reset the grs.bdComBlk block to empty.
;     - Perform the equivalent of a TROFF
;     - Calls ParseNewInit
;     - Collapse the heap (garbage collect)
;
;     Before doing anything, this function calls the user-interface function
;     NotSaved(), which lets the user save any unsaved modules, or CANCEL the
;     action.  If the user selected the CANCEL button (in response to NotSaved),
;     a Runtime Error occurs, which allows us to get back to UserInterface and
;     cancel the current operation.  The user-interface does not report this 
;     error to the user.
;     
;Entry:
;       none.
;Exit:
;       none.
;Uses:
;       DI (preserves ES since this is used by exStNew).
;Exceptions:
;       If a module was modified and not saved, NotSaved will allow user to
;       cancel - - - if he does so, a runtime error is generated, and this
;       routine does not return.
;       Does not return in the case of a runtime error.
;
;*******************************************************************************
	extrn  EmptyMrs:near
cProc   NewStmt,<PUBLIC,FAR,NODATA>,<ES,SI>
cBegin  NewStmt
	call	EnStaticStructs			;ensure static mrsCur and 
						;  prsCur are activated
	cCall	NotSaved			;notify user, get his response.
						; if CANCEL, ax=MSG_GoDirect
						; if user said NO, ax=FFFF
						; if I/O error, ax = error code
						; if files saved ok, ax=0
	DJMP	jg	J1_RtError		;brif runtime error while
						; saving files, or CANCEL

	or	[grs.GRS_flagsDir],FDIR_new	;note that NewStmt is active
						; (speed optimization)
        mov     [grs.GRS_otxCONT],UNDEFINED	;NOTE must be done before any
						;text tables are discarded
						;so we don't tell user "This
						;will prevent CONT"
	call	CmdWatchDelAll			;eliminate all Watch expressions

        cCall   ResetCommon			;note: must call this BEFORE
						;NewDiscard; otherwise, if there
						;exists some common value of
						;user defined type, and we've
						;tossed the type table, then
						;access of that variable will
						;cause an error
	;Note that the below scheme depends on the fact that NextMrsFile
	;finds the first mrs in the table if grs.GRS_oMrsCur is UNDEFINED, and
	;that MrsDiscard will set that field to UNDEFINED.  It is not safe to
	;call ForEachCP to do this, because that scheme depends on walking
	;the mrs chain, and MrsDiscard discards the current entry. In essense
	;we are starting from the top of the mrs chain each time through the
	;loop below.
	call	MrsDeactivate			;required so NextMrsFile
						;starts from the beginning
MrsDiscard_Loop:
	call	far ptr NextMrsFile		;activate next file mrs
	inc	ax				; no more file mrs's?
	jz	MrsDiscard_Cont 		; brif so - exit loop

	call	MrsDiscard			;discard active mrs
	jmp	short MrsDiscard_Loop
MrsDiscard_Cont:
	mov	[fTraceOn],0			; do the equivalent of TROFF
	PUSHI	ax,OMRS_GLOBAL			
	cCall	MrsActivateCP			;[16] activate the global mrs
	PUSHI	ax,SbGNam			; parm to TNamInit
	call	TNamInit			; reinit global name table
	call	VarRudeReset			

	mov	ax,SIZE MRS + OMRS_GLOBAL	; we know new empty unnamed
						;  mrs will be at this offset
	cCall	MrsActivateCP,<ax>		;activate the empty unnamed mrs
	call	ParseNewInit			;parser reinit stuff
	DbAssertRel ax,nz,0,CP,<NewStmt: ParseNewInit returned an error code>


       	or	[b$CtrlFlags],NoSTACKINIT	;speed optimization for LOAD
						;  don't bother to reinit the
						;  stack
	call    far ptr RunInit                 ;note that this alters si & di
       	and	[b$CtrlFlags],NOT NoSTACKINIT	;reset to default value
	cmp	[fChaining],FALSE
	jnz	NewStmt_Exit			;brif we're CHAINing
	test	[conFlags], F_CON_RunFile
	jnz	NewStmt_Cont			;brif we're clearing the decks
						;  to load and run a file -
						;  don't want to show debug 
						;  screen yet in this case
	call	EnsShowDebugScrFar
NewStmt_Cont:
	or	[conFlags],F_CON_ResetStkSize	;reset the stack to default
						;  size on next BOS or BOL
NewStmt_Exit:
	and	[grs.GRS_flagsDir],NOT FDIR_new	;NewStmt no longer active

cEnd    NewStmt

J1_RtError:
	call	RtError				;error(ax), never returns

;***
;TrimBdlDirect - Trim the direct mode buffer
;
;Purpose:
;	We trim the direct mode buffer to give back most of the space to
;	the user when we reinitialize basic (NewStmt) or prior to running
;	a program, but we must never trim it to less than CB_PCODE_MIN - - -
;	this is to ensure that the user can ALWAYS do a CLEAR, SETMEM,
;	SYSTEM, etc., even when essentially out of memory.
;Entry:
;       none.
;Exit:
;       none.
;Uses:
;       none.
;Exceptions:
;       none.
;*******************************************************************************
cProc	TrimBdlDirect,<NEAR,NODATA>
cBegin
	PUSHI	ax,<dataOFFSET grs.GRS_bdlDirect>
	mov	ax,[grs.GRS_bdlDirect_cbLogical]
	cmp	ax,CB_PCODE_MIN
	ja	Trim_It				;brif cbLogical > CB_PCODE_MIN

	mov	ax,CB_PCODE_MIN
Trim_It:
	push	ax				;size to realloc to
	call	BdlRealloc			;trim Direct mode buffer to
						;  minimum safe size
cEnd

;***
;ContReinit, ContReinitStat
;
;Purpose:
;	This routine does a subset of the work that RunInit does, and is
;	called when a user continues.
;Entry:
;       none.
;Exit:
;       none.
;	ContReinit Disables static structs if they weren't already disabled
;	ContReinitStat always leaves static structs active.
;Uses:
;       none.
;Exceptions:
;       none.
;*******************************************************************************
	PUBLIC ContReinit
	PUBLIC ContReinitStat
ContReinit:
	xor	ax,ax
	SKIP2_PSW				;fall into ContReinitGen
ContReinitStat:
	mov	ax,sp
?DFP = DFP_NONE 				; don't smash regs ...
cProc   ContReinitGen,<FAR,NODATA>,<SI>
cBegin	ContReinit
?DFP = DFP_CP					; restore switch
	xchg	ax,si				;save input flag
	call	EnStaticStructs			;activate static structs for
						;  call to ForEachCP
	mov	al,FE_PcodeMRS+FE_CallMRS+FE_SaveRs
	mov	bx,OFFSET CP:CompressTNam
	call	ForEachCP			;crunch all module name tables
						;  down to cbLogical

	cCall   BdCompressAll                   ;reduce all entries to cbLogical
						;  size, compress heap
	cCall	TrimBdlDirect
	or	si,si
	jnz	ContReinit_Exit			;brif want static structs active

	call	DisStaticStructs		;deactivate static structs
ContReinit_Exit:
cEnd	ContReinitGen

;***
;CompressTNam
;
;Purpose:
;	Realloc mrsCur.MRS_bdlNam down to it's cbLogical size (to free up as
;	much heap space as possible for execution).
;Entry:
;       mrsCur assumed set up.
;Exit:
;       always returns TRUE
;Uses:
;       none.
;Exceptions:
;       none.
;*******************************************************************************
cProc   CompressTNam,<NEAR,NODATA>
cBegin	CompressTNam
	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdlNam>
	call	BdlTrim				;crunch module name table down
						;  to free all unused space 
						;  for execution
	mov	ax,sp				;return TRUE
cEnd	CompressTNam

;***
;FindAnMrs
;Purpose:
;	Used to find the first mrs in the mrs table with some special
;	characteristics. Called by any of the ForEachXXX routines, just
;	saves grs.GRS_oMrsCur in the static 'oMrsDesired' and returns FALSE,
;	to terminate the ForEachXXX caller.
;Entry:
;       mrsCur is a pcode mrs.
;Exit:
;       returns FALSE (ax = 0).
;Exceptions:
;       none.
;*******************************************************************************
cProc	FindAnMrs,<NEAR,NODATA>
cBegin	FindAnMrs
	mov	ax,[grs.GRS_oMrsCur]
	mov	[oMrsDesired],ax
	xor	ax,ax				;terminate ForEachXXX caller.
cEnd	FindAnMrs

;***
;RunInit()
;
;Purpose:
;    This is called by NewStmt(), and the RUN statement executer to do the
;    following:
;        - Call ClearStmt
;        - reset event handlers and error traps
;        - deactivate current prs, if any
;        - Set grs.oPrsCur = UNDEFINED,
;        - Call RT entry point B$RUNINI to do runtime reinit.
;
;Entry:
;       none.
;Exit:
;       ax = 0 if no error, else contains a standard error message.
;Uses:
;       SI and DI
;Exceptions:
;       Does not return in the case of a runtime error.
;
;*******************************************************************************
cProc   RunInit,<PUBLIC,FAR,NODATA>
cBegin  RunInit
	and	[grs.GRS_flags],NOT FG_RetDir	;remember there's no ret adr to
						; direct mode buffer on stack.
	call	EnStaticStructs			;activate static mrsCur and 
						;  prsCur for this routine
	push	ax				; save returned flag
	test	[mrsCur.MRS_flags2],FM2_NoPcode
	jz	RunInit_Cont			;brif active module can be
						; counted on to have a var tbl,
						; a name table, etc.
	;search the mrs table and activate the first one encountered that
	;  is a pcode mrs (MUST be one ...) - - - this is so we don't try to
	;  CLEAR a non-existent var table, for example, in, say, the mrs for
	;  Immediate mode (B$RUNINI can also make a call-back that uses the
	;  nammgr ...)
	mov	al,FE_PcodeMrs+FE_CallMrs
        mov	bx,OFFSET CP:FindAnMrs
	cCall	ForEachCP
	push	[oMrsDesired]
	cCall	MrsActivateCP			;activate pcode mrs
RunInit_Cont:
        call    far ptr Clear_RunInit           ;retval must be TRUE, since
                                                ; we're not changing memory size
        mov     [grs.GRS_otxCONT],UNDEFINED
	cCall	DebugReset			;release WATCH str descriptors,
						;  reset history buffer

	cCall	BdCompressAll			;reduce all entries to cbLogical
						;  size, compress heap
	cCall	TrimBdlDirect			;trim direct mode buffer	
	pop	cx
	jcxz	Static_Structs_OK		;brif static structs were 
						;  active on entry

	call	DisStaticStructs		;deactivate static structs
						;  (as they were on input)
Static_Structs_OK:
	push	[grs.GRS_oMrsCur]
        cCall   RsActivateCP			;ensure no procedure is active
						; note we can't just call
						; PrsDeActivate here, as static
						; structures might not be active
	cmp	[fChaining],FALSE
	jnz	Chaining			;brif this is for CHAIN, not RUN

	push	WORD PTR ([fDebugScr])
	call	EnsMouseOff			;otherwise, B$RUNINI leaves a
						; ghost of mouse cursor
	
	PUSHI	ax,<RTOFFSET B$RUNINI>
	call	CallRtTrap_RT			;ax = 0 if no error, error code
						;runtime reinit. for RUN, NEW
	pop	cx				;cl = old value of fDebugScr
	push	ax				;error return from B$RUNINI
	or	cl,cl
	je	RunInit_Exit1			;brif debug screen wasn't active

	cmp	[b$ScreenRestored],0
	je	NotRestored			;brif B$RUNINI didn't change
						; screen modes
	call	TossOutputScreen		;output screen is activ
NotRestored:
	call	EnsShowDebugScrFar		;reactivate debug screen
RunInit_Exit1:
	pop	ax				;error return from B$RUNINI
	jmp	short RunInit_Exit
Chaining:
	mov	bx,[grs.GRS_bdtComBlk.BD_pb]
	;NOTE: we're depending on there always being an entry for blank COMMON,
	;NOTE: and that it's always the entry at offset zero in this table
	add	bx,COM_bdValue			;point to bdValue for blank
						;  COMMON
	xor	ax,ax				;assume no QBI blank common,
						;  or that it's empty
	cmp	[bx.BD_cbLogical],ax		;is blank COMMON empty?
	jz	Chaining_Cont			;   brif so

	TESTM	[bx.BD_pb],1			; if pb is odd, then this is
						;  not an owner, but is for
						;  U.L. blank COMMON
	jnz	Chaining_Cont			;brif not QBI blank COMMON

	xchg	ax,bx				;pass pBdValue to B$CHNINI
						;  so it won't release owners
						;  in this block
Chaining_Cont:
	xchg	ax,bx				;bx is a parm to B$CHNINI
	EXTRN	seg_rt:abs
	PUSHI	ax,<SEG seg_rt>
	PUSHI	ax,<RTOFFSET B$CHNINI>		;runtime reinit. for CHAIN
	call	CallRtTrap_Parm			;ax = 0 if no error, error code
RunInit_Exit:
cEnd    RunInit

;***
;ResetData() - reset the data pointer for mrsCur
;
;Purpose:
;       Called to reset the data pointer for a given module
;	Called as part of CLEAR, NEW, RUN, CHAIN, and whenever scanning
;	a text table and Cant CONT. This latter case ensures that DATA
;	statements get set correctly for READ's in Direct Mode.
;Entry:
;       mrsCur is set up.
;Exit:
;       Returns AX != 0
;Preserves:
;	es
;*******************************************************************************

	PUBLIC	ResetData
ResetData	 PROC       NEAR
        mov     ax,[mrsCur.MRS_data_otxFirst]	;oTx of link field of first DATA
						;  statement
	cmp	ax,UNDEFINED
	jz	ResetData_Exit			;brif no DATA, in case there's a
						;  READ statement (so we give
						;  the proper error @ runtime)
        mov     [mrsCur.MRS_data_oLineCur],6	;offset into current DATA stmt
       	sub	ax,4				;oTx of first exStData pcode
ResetData_Exit:
	mov     [mrsCur.MRS_data_otxCur],ax	;otxFirst - 4  or UNDEFINED
	mov	ax,sp
        ret
ResetData	ENDP


;***
;Clear_Mod
;Purpose:
;	Tasks that must be performed for each module, lumped together here
;	to reduce context switching (for speed)
;Entry:
;	none.
;Exit:
;	always returns AX != 0
;*******************************************************************************
Clear_Mod	 PROC	    NEAR
	mov	[mrsCur.MRS_otxHandler],UNDEFINED
						;reset module error trap
	call	ResetData			;reset DATA statements
	;Reclaim space in module name table. Only really needs to be done for
	;RUN init, but who cares about the extra time for CLEAR ...
	call	CompressTNam			;returns AX != 0
        ret
Clear_Mod	ENDP

;***
;ClearStmt, Clear_RunInit
;
;Purpose:
;
;     This is  called by  CLEAR and by RunInit() for  RUN, LOAD, NEW, CHAIN etc.
;     statements to do the following:
;
;        - Call the Variable Mgr functions ClearCommon,
;          ClearMV() for each module, and ClearPVStat() for
;          each procedure in each module, and ClearPVFrame()
;          for each procedure on the stack to:
;          - Set all numeric static variables to zero
;          - Release all string variables
;          - Do the equivalent of an ERASE on all arrays
;        - Remember that we can't CONT
;        - Reset the module data pointer for each module
;        - Reset the module error trap for each module
;        - Reclaim free space in each module name table
;        - Close all user files (not system files like the
;          file being loaded etc.)
;        - Perform special version-specific reinitialization
;          (graphics, sound, pen, strig, etc.)
;        - Reinitialize the random number seed
;    	 - Sets bosFlags FBOSRESETSTK bit to cause stack to be reset @ next 
;		BOS/BOL
;
;     Since CLEAR  causes the  stack to get reset, we have chosen not to allow a
;     program to  execute CLEAR  from within  a procedure  or function; the text
;     manager will issue an error message to prevent this.
;
;     Clear_RunInit is just like ClearStmt, except that it is assumed that
;     static structs are already set up on input, and that this routine need
;     not reset the DATA statements in each module; this is a speed optimization
;     to prevent needless context switching.
;Entry:
;     none.
;Exit:
;     none.
;Uses:
;       none.
;Exceptions:
;       none.
;
;*******************************************************************************
cProc   Clear_RunInit,<FAR,NODATA>		
cBegin  Clear_RunInit				
        push    es                              ;save for executor
	xor	ax,ax				
	jmp	short Clear_Spt_Common		
cEnd	Clear_RunInit,<nogen>			

cProc   ClearStmt,<PUBLIC,FAR,NODATA>		
cBegin  ClearStmt				
        push    es                              ;save for executor

	call	EnStaticStructs			;activate static mrsCur and 
						;  prsCur for this routine
Clear_Spt_Common:
	push	ax				; save flag
	
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
        mov	bx,OFFSET CP:Clear_Mod
        call    ForEachCP			;retval guaranteed to be TRUE

        call    ClearTheWorld

	or	BosFlags,FBOSRESETSTK		;cause stack to be reset @ next
						;  BOS/BOL
	mov	[pGosubLast],0			;reset - - - can't RETURN now


	and	[grs.GRS_flagsDir],NOT FDIR_cleared ;reset flag, so next call to
						    ;    ClearTheWorld doesn't
						    ;    assume world is clear
	pop	cx
	jcxz	StaticStructs_OK		;brif context state is okay

	call	DisStaticStructs		;deactivate static prsCur & 
						;  mrsCur again (as they were
						;  on input)
StaticStructs_OK:
	pop     es
cEnd						

;***
;CantCont()
;
;Purpose:
;       Sets grs.otxCONT to UNDEFINED, i.e., makes it so the user
;       can no longer CONTINUE.
;Note:
;	When UserInterface() is entered, if we were not executing out of the
;	direct mode buffer, grs.otxCONT is set to the current
;	text pointer (grs.otxCur).
;Entry:
;       none.
;Exit:
;       none.
;Uses:
;       none.
;Exceptions:
;       none.
;
;*******************************************************************************
cProc   CantCont,<PUBLIC,FAR,NODATA>
cBegin  CantCont
	mov	cx,UNDEFINED
        xchg    [grs.GRS_otxCONT],cx	;ensure this gets set to UNDEFINED
	inc	cx
	.errnz	0FFFFH - UNDEFINED
	jcxz	CantCont_Exit		;brif already couldn't CONTinue
					; (because RunInit closes files)
	test	[conFlags], F_CON_RunFile
	jnz	CantCont_Exit		;brif we're clearing the decks
					;  to load and run a file -
					;  don't want to show debug screen
	push	[grs.GRS_oRsCur]	;pass caller's oRs to RsActivateCP below
					; RunInit deactivates current prs
	call	RunInit
	call	RsActivateCP		;parm pushed above
	call	EnsShowDebugScrFar
CantCont_Exit:
cEnd	CantCont



sEnd	CP				
sBegin	SCAN				
assumes cs,SCAN 			

;***
;FCanCont
;
;Purpose:
;       tests grs.otxCONT for UNDEFINED, i.e., sees if the user
;       can CONTINUE.
;Entry:
;       none.
;Exit:
;       ax = 0 and psw.Z is set if the user cannot continue
;Uses:
;       none.
;Exceptions:
;       none.
;
;*******************************************************************************
cProc	FCanCont,<PUBLIC,NEAR,NODATA>	
cBegin
	mov	ax,[grs.GRS_otxCONT]
	inc	ax			;ax = 0 if can't continue
cEnd

sEnd	SCAN				
sBegin	CP				
assumes cs,CP				


;***
;NextQBI_Frame
;Purpose:
;	Given a frame pointer, return the next higher frame pointer if it's
;	a QBI frame. Indicate whether a QBI frame was found or not, and if
;	the end of frame chain or broken chain or non-QBI frame was found.
;Input: 
;	di = pointer to a pointer to a frame
;Output:
;	PSW.C set if invalid frame found (broken chain, or non-QBI frame found)
;	if PSW.C clear,
;	    PSW.Z set if end of BP chain found ,i.e., there exist no more frames
;	    If both of the above flags are clear, di on exit points to the next
;	    higher QBI frame on the stack, and the oRs for this frame is 
;	    activated
;	ax also contains PSW flags
;*******************************************************************************
cProc	NextQBI_Frame,<PUBLIC,FAR>
cBegin
	mov	ax,[di]
	mov	bx,[b$mainframe]
	DbAssertRel  [bx],z,0,CP,<NextQBI_Frame: BP chain not zero terminated>
	cmp	bx,ax				;end of frame chain?
	jc	Flags_Set_Exit			;  brif new ptr above stack
	jz	No_Carry_Exit			;  brif so

	cmp	ax,di				;is new ptr > old?
	jc	Flags_Set_Exit			;  brif not - broken chain

	mov	di,ax

	shr	al,1				;is the new frame ptr odd?
	jc	Flags_Set_Exit			;  brif so - broken chain

	call	ValidORs			;ax = 0 if valid QBI frame
	or	ax,ax
	jnz	Set_Carry_Exit			;brif QBI frame not found

	;success - ensure PSW.Z and PSW.C are reset and exit
	inc	ax				;reset PSW.Z
	SKIP2_AX				;skip to No_Carry_Exit
Set_Carry_Exit:
	stc
	SKIP1_AL				;skip the clc, leave PSW intact
No_Carry_Exit:
	clc					;success or end of BP chain
Flags_Set_Exit:
	pushf					
	pop	ax				
cEnd	NextQBI_Frame


;***
;ActiveORs_Frame
;Purpose:
;	Given a pointer to a pointer to a frame and grs.GRS_oRsCur, walk
;	the stack checking each QBI frame on the stack until we find
;	one that was pushed from the context of the given oRs, or until
;	we find the end of the chain, a broken chain, or a non-QBI frame.
;Input:
;	ppFrame == pointer to a pointer to a frame (ex: mov bx,dataOFFSET
;		   b$curframe)
;	grs.GRS_oRsCur is set for the register set we're looking for on stack.
;Output: 
;	PSW.C set if given oRs definitely has no active frame on the stack.
;	PSW.C clear if given oRs IS found, OR if it MIGHT have an active 
;		frame on the stack.
;
;	ax == 0 if given oRs definitely has no active frame on the stack.
;	ax != 0 if given oRs IS found, OR if it MIGHT have an active
;		frame on the stack.
;Note:
;	Note that this routine could THINK a frame is a QBI frame
;	when it really isn't. It only checks the oRs part of the frame.
;*******************************************************************************
cProc	ActiveORs_Frame,<PUBLIC,FAR>,<SI,DI>	 
	parmW	ppFrame 		
cBegin
	mov	bx,[ppFrame]
	mov	si,[grs.GRS_oRsCur]	;oRs we're looking for
	cmp	word ptr [bx],0
	jz	ORsFrame_Exit		;brif special case of no frames to
					;  search
	mov	di,bx
ORsFrame_Loop:
	call	NextQBI_Frame
	push	ax			
	popf				
	jc	ORsFrame_Success	;brif broken chain or non-QBI frame
	jz	ORsFrame_Exit		;brif end of frame chain found

	cmp	si,[grs.GRS_oRsCur]
	jnz	ORsFrame_Loop		;brif this frame for a different oRs

	;success - - - given oRs frame IS on stack
ORsFrame_Success:
	clc
	SKIP1_AL			;skip stc and exit
ORsFrame_Exit:
	stc				;indicate failure
	pushf
	cCall	RsActivate,<si> 	; reactivate input oRsCur
	mov	bx,di			;retval if success
	sub	ax,ax			; assume no active frame found
	popf
	jc	@F			; brif no active frame found
	mov	ax,sp			
@@:					

cEnd

;***
;FindORsFrame
;Purpose:
;	Given b$curframe and grs.GRS_oRsCur, walk the stack checking each 
;	QBI frame on the stack until we find one that was pushed from the 
;	context of the given oRs, or until we find the end of the chain, a 
;	broken chain, or a non-QBI frame.
;
;	NOTE: This does NOT look at the active frame, only previously pushed
;		frames. If you want to examine the active frame, use oRsCont.
;Input:
;	b$curframe is the first frame to examine.
;	grs.GRS_oRsCur is set for the register set we're looking for on stack.
;Output: 
;	AX = 0 if the given oRs has no active frame on the stack.
;	AX != 0 means that there is PROBABLY an active frame for this oRs.
;*******************************************************************************
cProc	FindORsFrame,<PUBLIC,NEAR>
cBegin
	mov	bx,dataOFFSET b$curframe	;ptr to ptr to first frame
	cCall	ActiveORs_Frame,<bx>		
cEnd

sEnd	CP


        end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exarray.asm ===
page	49,132
TITLE	exarray - Array statement executors
;***
;exarray.asm - interpreter specific array support.
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module includes:
;   - DIM, REDIM, and OPTION BASE executors.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXARRAY_ASM	= ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opid
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	pcode
	IncludeOnce	scanner
	IncludeOnce	ui
	IncludeOnce	variable

	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

	extrn	ScanExExit:far
	extrn	B$ERAS:far

	    extrn   B$ADIM:far



sBegin	DATA
	extrn	SsScanExSrc:word

	public	DimAtScanType		
DimAtScanType	db	SSDIM_EXECUTE	; Type of Dim initiated by scanner

sEnd	DATA


sBegin	CODE

;***
;exStOptionBase<0|1>
;Purpose:
;	Handled at scan time so it doesn't need to be executed
;
;***************************************************************************
MakeExe exStOptionBase0,opStOptionBase0
	SkipExHeader
MakeExe exStOptionBase1,opStOptionBase1
	jmp	short Disp1

;***
;exDimOptionBase - executor to push current option base
;Purpose:
;	Emit the current OPTION BASE setting.
;	One use for this executor is as follows:
;	Array dimension clauses in DIM and REMDIM may or may not use the
;	TO keyword.  This executor is used in cases where TO is not used
;	so that DIM and REDIM executors always get both the lower and upper
;	bound for each dimension.
;Input:
;	none
;Output:
;	stack contains current OPTION BASE (ET_I2).
;Modifies:
;	none
;***************************************************************************
MakeExe exDimOptionBase,opDimOptionBase
	GETRS_SEG es,bx,<SIZE,LOAD>	
	mov	bx,[grs.GRS_oMrsCur]	
	RS_BASE add,bx			
	xor	ax,ax
	test	BPTRRS[bx.MRS_flags],FM_OptionBase1  
	je	OptBase0		;brif Current OPTION BASE setting is 0
	inc	ax			;else it is 1
OptBase0:
	push	ax			;Return result on stack
Disp1:
	jmp	DispMov 		; refresh es and dispatch

	subttl	Value Table Reference Ids
	page
;***
;exAVtRf - variable table reference executor
;
;Purpose:
;
;   This executor is used in the Dim, COMMON, SHARED, STATIC, Auto,
;   and Public statements.  The only executable statement in the
;   group is Dim and this is only executable with FV_QB4LANG.
;
;   There are two possible situations for these executors to be
;   executed.  The first is during scan time, these can be dispatched
;   to allocate the storage for the array.  Currently, this occurs for
;   $Static Common arrays only and then during the Dim statement processing.
;   The second situation is during normal execution with FV_QB4LANG.  In this
;   case, the array is checked if $Static or $Dynamic.	If $Static, no
;   action is taken if already allocated.  If $Dynamic, allocation occurs.
;
;Input:
;Output:
;Modifies:
;***************************************************************************

MakeExe exAVtRfSD,opAVtRf,ET_SD
	SkipExHeader
MakeExe exAVtRfR8,opAVtRf,ET_R8
	SkipExHeader
MakeExe exAVtRfI4,opAVtRf,ET_I4
	SkipExHeader
MakeExe exAVtRfR4,opAVtRf,ET_R4
	SkipExHeader
MakeExe exAVtRfI2,opAVtRf,ET_I2
	SkipExHeader
MakeExe exAVtRfImp,opAVtRf,ET_Imp
	inc	si			; Ignore argument count
	inc	si			
	LODSWTX
	xchg	ax,bx			;BX = oVar
DoDim:					
	xor	cx,cx			;Indicate Dim
	    jmp     short DimReDim	;Jump into shared code



	public	DimImplicit
DimImplicit:

	GETRS_SEG es
	    mov     bx,[grs.GRS_oMrsCur]
	    RS_BASE add,bx
	mov	al,BPTRRS[bx.MRS_flags] ;Low bound is option base
	.erre	FM_OptionBase1 EQ 1
	and	ax,FM_OptionBase1	;AX = option base (0 or 1)
	mov	dx,10			;Upper bound is 10

	call	GetEsDi 		;Setup to access pcode
	mov	cx,PTRTX[si]		;CX = cDims
	mov	bx,PTRTX[si+2]		;BX = oVar
@@:
	push	ax			;Push low bound
	push	dx			;Push upper bound
	loop	@B			;Brif more dimensions

	mov	[DimAtScanType],SSDIM_STATIC
	jmp	short DoDim



	page
;***
;exStReDimTo - REDIM executors.
;
;Purpose:
;
;   For DIM:
;   =======
;      Syntax: DIM <id>(x TO y,...) or DIM <id>(x,...)
;      Runtime Entry Point for DIM for arrays.
;      DIM Statement for dynamic arrays.  If the array is
;      already defined, an error is returned.
;
;   For REDIM:
;   =========
;      Syntax: REDIM <id>(x TO y,...) or REDIM <id>(x,...)
;      Runtime Entry Point for REDIM for arrays.
;      This algorithm depends on:
;      1. VarMgr setting up an array template, even for dynamic or common
;	  variables.
;      2. Scanner verifying correctness of index argument count
;
;Input:
;
;   Stack contains:
;	Variable Table Offset
;	Index count
;	count index arguments, consisting of lower and upper bounds
;
;Output:
;
;   none
;
;Modifies:
;
;*************************************************************************

MakeExe exStReDimTo,opStReDimTo
	pop	cx			; cx = pAD.  This is never 0!!!
	DbAssertRel cx,ne,0,CODE,<exStReDimTo: pAD == 0>
	mov	bx,PTRTX[si-4]		; Get Offset to Variable table
DimReDim:

	DbChk	oVar,bx 		;Verify that this is a variable
	mov	dx,[pVarBx-VAR_value].VAR_flags 
	mov	ax,dx
	and	ax,FV_TYP_MASK
	jz	RecArray		
	.erre	ET_MAX LT 100h		; Assure we can use AL
	cmp	al,ET_FS		;[9]
	jb	HavOTyp 		
	    .erre   ET_FS EQ ET_MaxStr	;[9]
	    if	    ET_MaxStr NE ET_MAX 
		ja	HavOTyp 	
	    endif			; ET_MaxStr NE ET_MAX
	    push    ax			; Save oTyp
	push	[pVarBx-VAR_Value].VAR_cbFixed	; Push length
	jmp	short HaveSize		

RecArray:
	mov	ax,[pVarBx-VAR_value].VAR_oTyp	; Get type while we have pVt

HavOTyp:
	    push    ax			; Save oTyp
	call	OTypCbTyp		;ax = bytes in oType passed in ax
	push	ax			;push cbElement

HaveSize:				

	    ;Look for $STATIC array in COMMON

	    cmp     [DimAtScanType],SSDIM_COMMON
	    jne     NotStaticCommon	; Brif not Dim'ing $Static common

	    pop     cx			; cbElement
	    pop     ax			; oTyp
	    push    cx			; Restore cbElement
	    mov     dl,[pVarBx].ACOM_cDims  
	    mov     dh,FADF_STATIC+FADF_NEAR
	    cmp     ax,ET_SD		;See if string
	    jne     @F
	    or	    dh,FADF_SD		;Tell runtime this is a string array
@@:
	    push    dx			;Push flags/cDims
	    push    [SsScanExSrc]	;Push pAd

	    ;Compute size of $Static array and set up array descriptor

	    call    B$ADIM		;Compute array size, don't allocate
	    mov     [SsScanExSrc],ax	;Save return value
	    jmp     short DimXds	;Return to scanner

NotStaticCommon:

	jcxz	@F			; Brif Dim
	mov	bx,cx			; DI:BX = sbAd:oAd
	mov	cx,1			; Needed below
	jmp	short GotPAd		

@@:
	call	oVarToPAd		;on exit bx = pAd
					; sets FADF_STATIC & cDims in array desc

GotPAd: 				
	;It's OK to execute a single $STATIC DIM more than once.  Multiple DIMs
	;are caught at scan time.  However, DIM of a $STATIC array passed as a
	;parameter is illegal.	In EB this test is not necessary because Dim
	;statements are not executable.  Therefore, a $Static array will
	;never be allocated more than once.

	    TestX   dx,FVFORMAL 	;Passed as parameter?
	    pop     dx			; cbElement
	    pop     ax			;AX = oTyp
	    push    dx			; Restore cbElement

	mov	dx,word ptr [bx].AD_cDims ;get flags byte & cDimensions (set up
					  ;  by oVarToPAd)

	    jnz     @F			;Brif parameter, always attempt Dim

	    ;Allow multiple DIM of $STATIC arrays

	    test    dh,FADF_STATIC	;$STATIC array?
	    jz	    @F			;If not, always DIM it

	    cmp     [bx].FHD_hData,0	;Space allocated to $STATIC array?
	    jnz     CleanUp		;If so, don't DIM again, no error
@@:

	;ax = oTyp
	;ds:bx = pAD
	;cx = 0 for DIM, 1 for REDIM
	;dh = Feature flags
	;dl = cDims
	;Stack has cbElement followed by bounds

	cmp	ax,ET_SD
	je	SetSD

	    or	    dh,FADF_FAR 	;Assume array is far not huge
	    test    dh,FADF_STATIC	;$STATIC array?
	    jnz     @F			;They can never be huge
	    test    [cmdSwitches],CMD_SW_HAR
	    jz	    @F			;Brif /AH switch not specified
	    or	    dh,FADF_HUGE	;Set Huge indicator for runtime
@@:

Flags_Set:
	push	dx			;flags/cDims
	push	bx			;pAD
SizeSet:
	jcxz	Dim_The_Array		;Brif Dim

	CALLRT	B$RDIM,Mov		;ReDim array via runtime code
	jmp	short After_Dim


SetSD:

	    or	    dh,FADF_SD OR FADF_NEAR ;Tell runtime this is a string array
	    jmp     short Flags_Set



CleanUp:
	    mov     dh,0		;dx=cDims
	    shl     dx,1		;Two words/dimension
	    inc     dx			; Plus one word for cbElement
	    shl     dx,1		;Two bytes/index
	    add     sp,dx		;Clear indices off stack
	    jmp     short DimX

Dim_The_Array:
	CALLRT	B$DDIM,Mov		;Dimension array via runtime code

After_Dim:

DimXds:
	;Determine how to return.

	mov	al,SSDIM_EXECUTE
	xchg	al,[DimAtScanType]	;Get Dim type and reset
	cmp	al,SSDIM_EXECUTE	;Is this execute scan time Dim?
	jne	DimAtScanExit		;Brif not

	;Exit for case that DIM executed as part of normal pcode execution

DimX:
	DispMac

	;Exit for a Dim that was executed at scan time for a $Static array

DimAtScanExit:
	jmp	ScanExExit		; Exit


	subttl	exStErase
	page
;***
;exStErase - erase one or more arrays
;
;Purpose:
;
;   Support for ERASE statement.
;
;Input:
;
;   es:si = pcode address of argument count
;   count pAD arguments on the stack
;
;Output:
;
;   none
;
;************************************************************************

MakeExe exStErase,opStErase
	LODSWTX 			;Load argument count
	mov	di,ax			;Arg count to di
EraseNext:
	call	B$ERAS			;erase this array descriptor

	;Note: this CAN cause heap movement

	dec	di
	jnz	EraseNext		;Go erase next array
	jmp	DispMov


	subttl	UnlinkArray
	page
;***
;UnlinkArray
;
;Purpose:
;
;   This routine unlinks Auto non-string arrays from the owners frame
;
;Input:
;
;   sbAd:pAd on stack
;
;Output:
;
;   none
;
;Preserves:
;
;   DI
;
;************************************************************************


;***
;exFn<U|L>bound<1|2>
;
;Purpose:
;
;   Support for LBOUND function
;
;Input:
;
;   pAD on the stack
;   iDim on stack   (exFnLbound2 only)
;
;Output:
;
;   none
;
;************************************************************************
;
MakeExe ExFnLbound1,opFnLbound1
	PushI	ax,1			
	SkipExHeader			
MakeExe ExFnLbound2,opFnLbound2
	CALLRT	B$LBND,DispAx


MakeExe ExFnUbound1,opFnUbound1
	PushI	ax,1			
	SkipExHeader			
MakeExe ExFnUbound2,opFnUbound2
	CALLRT	B$UBND,DispAx


;=============================================================================
	subttl	Utilities
	page
;***
;OTypCbTyp
;Purpose:
;	This routine returns the number of bytes of data required for
;	the input type.
;	Significantly rewritten for revision [7].
;
;Input:
;	ax = oTyp
;Output:
;	ax = cbTyp
;Modifies:
;	none
;Preserves:
;	all
;***************************************************************************

mpCbTyp equ	$-1

	.erre	ET_I2 EQ ($-mpCbTyp)
	DB	2			;ET_I2
	.erre	ET_I4 EQ ($-mpCbTyp)
	DB	4			;ET_I4

	.erre	ET_R4 EQ ($-mpCbTyp)
	DB	4			;ET_R4

	.erre	ET_R8 EQ ($-mpCbTyp)
	DB	8			;ET_R8


	.erre	ET_SD EQ ($-mpCbTyp)
	    db	    SIZE SD



OTypCbTyp:
	push	bx
	DbChk	oTyp,ax 		;sanity check on input oTyp
	cmp	ax,ET_MAX		;Is it a fundamental type?
	ja	NotPredefinedType	;  brif not - user defined

	    DbAssertRel ax,be,ET_SD,CODE,<OTypCbTyp: Invalid oTyp>

	mov	bx,offset cs:mpCbTyp	;base of lookup table in CS
	xlat	byte ptr cs:[bx]	;al == desired size

OTypCbTyp_Exit:
	pop	bx
	ret

NotPredefinedType:
	push	cx
	push	dx
	push	es

	cCall	CbTypFar,<ax>
	pop	es
	pop	dx
	pop	cx
	jmp	OTypCbTyp_Exit

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exaid.asm ===
page	49,132
	TITLE	exAId	-	Array Id Executors
;***
;exaid.asm - executors for simple id references.
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains all exAId executors and all exAVtRf executors.
;
;	In general, these executors are very speed critical.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
	IncludeOnce	architec
	IncludeOnce	array
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opid
	IncludeOnce	pcode		
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	variable
	.list


assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA


sBegin	CODE

	subttl	I2 Load Executors
	page
	;Indirect

MakeExe exAIdIILd2,opAIdLd,ET_Imp
	SkipExHeader
MakeExe exAIdEILdI2,opAIdLd,ET_I2
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;ds:bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	ALdI2
	jmp	IndexCountErr
	
;Common
MakeExe exAIdECLdI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdICLd2,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ALdI2

;Frame
MakeExe exAIdIFLd2,opAIdLd,ET_Imp
	SkipExHeader
MakeExe exAIdEFLdI2,opAIdLd,ET_I2
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;ss:bx = pointer to array descriptor
	jmp	short ALdI2

	;Public


	;Static

MakeExe exAIdESLdI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdISLd2,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Load operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
ALdI2S: 				
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
ALdI2:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	push	[bx]			;Push the I2
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

	;Optimized I2 load/store executors for 1 index

	;Frame load

MakeExe exA1IdIFLdI2,opAIdLd,ET_Imp
	SkipExHeader
MakeExe exA1IdEFLdI2,opAIdLd,ET_I2
	inc	si
	inc	si			;Skip cDims
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;bx = pointer to array descriptor
	    mov     dx,ds		;Save psVariableTable
	jmp	short A1LdI2

	;Static load

MakeExe exA1IdESLdI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exA1IdISLdI2,opAIdLd,ET_Imp
	inc	si
	inc	si			;Skip count ot indices
	LODSWTX 			;Load operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
	    mov     dx,ds		;Save psVariableTable
A1LdI2:
	mov	cx,[bx].AD_fhd.FHD_hData
	jcxz	RangeErr		; Brif array not allocated
	pop	ax			;Get index
	sub	ax,[bx].AD_tDM.DM_iLbound	;Subtract lower bound
	jl	RangeErr
	cmp	ax,[bx].AD_tDM.DM_cElements	;Test for range
	jge	RangeErr
	shl	ax,1
	add	ax,[bx].AD_fhd.FHD_oData ;Add base offset
	GETSEG	ds,cx,bx,<SPEED,LOAD>	; Move to array element segment
	xchg	bx,ax
	push	[bx]			;Push the I2
	    mov     ds,dx		;Restore module var table
	DispMac

IndexCountErr:
RangeErr:
	mov	al,ER_SOR		;Subscript out of range
	call	RtErrorCODE		;generate error, don't return

	;Frame store

MakeExe exA1IdIFStI2,opAIdSt,ET_Imp
	SkipExHeader
MakeExe exA1IdEFStI2,opAIdSt,ET_I2
	inc	si
	inc	si			;Skip count ot indices
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;bx = pointer to array descriptor
	    mov     dx,ds		;Save psVariableTable
	jmp	short A1StI2

	;Static store

MakeExe exA1IdESStI2,opAIdSt,ET_I2
	SkipExHeader
MakeExe exA1IdISStI2,opAIdSt,ET_Imp
	inc	si
	inc	si			;Skip count ot indices
	LODSWTX 			;Load operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
	    mov     dx,ds		;Save psVariableTable
A1StI2:
	mov	cx,[bx].AD_fhd.FHD_hData
	jcxz	RangeErr		; Brif array not allocated
	pop	ax			;Get index
	sub	ax,[bx].AD_tDM.DM_iLbound	;Subtract lower bound
	jl	RangeErr
	cmp	ax,[bx].AD_tDM.DM_cElements	;Test for range
	jge	RangeErr
	shl	ax,1
	add	ax,[bx].AD_fhd.FHD_oData ;Add base offset
	GETSEG	ds,cx,bx,<SPEED,LOAD>	; Move to array element segment
	xchg	bx,ax
	pop	[bx]			;Store the I2
	    mov     ds,dx		;Restore module var table
	DispMac 			; and dispatch next executor


	subttl	I2 Store Executors
	page
	;Common

MakeExe exAIdICSt2,opAIdSt,ET_Imp
	SkipExHeader
MakeExe exAIdECStI2,opAIdSt,ET_I2
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short AStI2

;Indirect
MakeExe exAIdIISt2,opAIdSt,ET_Imp
	SkipExHeader
MakeExe exAIdEIStI2,opAIdSt,ET_I2
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	AStI2
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFStI2,opAIdSt,ET_I2
	SkipExHeader
MakeExe exAIdIFSt2,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;bx = pointer to array descriptor
	jmp	short AStI2

	;Public


	;Static

MakeExe exAIdESStI2,opAIdSt,ET_I2
	SkipExHeader
MakeExe exAIdISSt2,opAIdSt,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Load operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
AStI2S: 				
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
AStI2:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	pop	[bx]			;Pop the I2 to the variable value
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

	subttl	I4 Load Executors
	page
	;Indirect

MakeExe exAIdEILdI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdIILd4,opAIdLd,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		    ;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	    ;Correct number of indices?
	jz	ALd4
	jmp	IndexCountErr

;Common
MakeExe exAIdECLdI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdICLd4,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ALd4

;Frame
MakeExe exAIdEFLdI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdIFLd4,opAIdLd,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]   
	add	bx,bp			    ;bx = pointer to array descriptor
	jmp	short ALd4

	;Public


;Static
MakeExe exAIdESLdI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdISLd4,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
ALd4S:
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
ALd4:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
SLoad4X:
	push	[bx+2]			;Push second word
	push	[bx]			;Push first word
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

;Added with [15]
subttl	R4 Load Executors
page

;Indirect
MakeExe exAIdEILdR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdIILdR4,opAIdLd,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		    ;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	    ;Correct number of indices?
	jz	ALdR4
	jmp	IndexCountErr

;Common
MakeExe exAIdECLdR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdICLdR4,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ALdR4

;Frame
MakeExe exAIdEFLdR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdIFLdR4,opAIdLd,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]   
	add	bx,bp			    ;bx = pointer to array descriptor
	jmp	short ALdR4

	;Public


;Static
MakeExe exAIdESLdR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdISLdR4,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
ALdR4S:
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
ALdR4:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	fld	dword ptr [bx]
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

;End of [15]

subttl	I4 Store Executors
page
;Common
MakeExe exAIdECStI4,opAIdSt,ET_I4
	SkipExHeader
MakeExe exAIdICSt4,opAIdSt,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ASt4

;Indirect
MakeExe exAIdEIStI4,opAIdSt,ET_I4
	SkipExHeader
MakeExe exAIdIISt4,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	ASt4
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFStI4,opAIdSt,ET_I4
	SkipExHeader
MakeExe exAIdIFSt4,opAIdSt,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]   
	add	bx,bp			    ;bx = pointer to array descriptor
	jmp	short ASt4

	;Public


;Static
MakeExe exAIdESStI4,opAIdSt,ET_I4
	SkipExHeader
MakeExe exAIdISSt4,opAIdSt,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
ASt4S:
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
ASt4:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
SStoreR4X:
	pop	[bx]			;Pop first word
	pop	[bx+2]			;Pop second word
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

;Added with [15]
subttl	R4 Store Executors
page
;Common
MakeExe exAIdECStR4,opAIdSt,ET_R4
	SkipExHeader
MakeExe exAIdICStR4,opAIdSt,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short AStR4

;Indirect
MakeExe exAIdEIStR4,opAIdSt,ET_R4
	SkipExHeader
MakeExe exAIdIIStR4,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	AStR4
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFStR4,opAIdSt,ET_R4
	SkipExHeader
MakeExe exAIdIFStR4,opAIdSt,ET_Imp
	LODSWTX 			    ;Index argument count
	xchg	ax,cx
	LODSWTX 			    ;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]   
	add	bx,bp			    ;bx = pointer to array descriptor
	jmp	short AStR4

	;Public


;Static
MakeExe exAIdESStR4,opAIdSt,ET_R4
	SkipExHeader
MakeExe exAIdISStR4,opAIdSt,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
AStR4S:
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
AStR4:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	fstp	dword ptr [bx]
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	fwait
	DispMac

;End of [15]


;Added with [15]
subttl	R8 Load Executors
page
;Common
MakeExe exAIdECLdR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdICLdR8,opAIdLd,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue	;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ALdR8

;Indirect
MakeExe exAIdEILdR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdIILdR8,opAIdLd,ET_Imp		
	LODSWTX 				;Index argument count
	xchg	ax,cx
	LODSWTX 				;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]			;bx points to array descriptor
	cmp	cl,[bx].AD_cDims		;Correct number of indices?
	jz	ALdR8				
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFLdR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdIFLdR8,opAIdLd,ET_Imp		
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	short ALdR8			

;Public

;Static
MakeExe exAIdESLdR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdISLdR8,opAIdLd,ET_Imp	
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
ALdR8S:
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
ALdR8:					
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	fld	qword ptr [bx]
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	DispMac

;End of [15]


;Start of [15]
subttl	R8 Store Executors
page
;Indirect
MakeExe exAIdEIStR8,opAIdSt,ET_R8
	SkipExHeader
MakeExe exAIdIIStR8,opAIdSt,ET_Imp		
	LODSWTX 				;Index argument count
	xchg	ax,cx
	LODSWTX 				;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]			;bx points to array descriptor
	cmp	cl,[bx].AD_cDims		;Correct number of indices?
	jz	AStR8				
	jmp	IndexCountErr

;Common
MakeExe exAIdECStR8,opAIdSt,ET_R8
	SkipExHeader
MakeExe exAIdICStR8,opAIdSt,ET_Imp		
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue	;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short AStR8			

;Frame
MakeExe exAIdEFStR8,opAIdSt,ET_R8
	SkipExHeader
MakeExe exAIdIFStR8,opAIdSt,ET_Imp		
	LODSWTX 				;Index argument count
	xchg	ax,cx
	LODSWTX 				;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]	
	add	bx,bp		;bx = pointer to array descriptor
	jmp	short AStR8			;jmp is faster from here

;Public

;Static
MakeExe exAIdESStR8,opAIdSt,ET_R8
	SkipExHeader
MakeExe exAIdISStR8,opAIdSt,ET_Imp	
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
AStR8S:
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
AStR8:					
	call	ResolveArray		;resolve to segment and offset in dx:bx
	GETSEG	ds,dx,di,<SPEED,LOAD>	; Move to array element segment
	fstp	qword ptr [bx]
	    mov     ax,ss
	    mov     ds,ax		;Restore the data segment
	fwait
	DispMac

;End of [15]

subttl	Sd Load Executors
page
;Common
MakeExe exAIdECRfSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdICRfSD,opAIdLd,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short ALdSd

;Indirect
MakeExe exAIdEIRfSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIIRfSD,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	ALdSD
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFRfSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIFRfSD,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;bx = pointer to array descriptor
	jmp	short ALdSD

;public


;Static
MakeExe exAIdESRfSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdISRfSD,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	; ds:bx = array descriptor address
ALdSd:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	push	bx			;Load pointer to SD
	DispMac

subttl	Sd Store Executors
page
;Common
MakeExe exAIdECStSD,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdICStSD,opAIdSt,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short AStSD

;Indirect
MakeExe exAIdEIStSD,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdIIStSD,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	AStSD
	jmp	IndexCountErr

;Frame
MakeExe exAIdEFStSD,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdIFStSD,opAIdSt,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	short AStSD

;public


;Static
MakeExe exAIdESStSD,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdISStSD,opAIdSt,ET_Imp
	LODSWTX 		;Load argument count
	xchg	ax,cx
	LODSWTX 		;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad ;ds:bx = array descriptor address
AStSd:
	call	ResolveArray	;resolve to segment and offset in dx:bx
	push	bx		;Push pSD
	CALLRT	B$SASS,DispMov

	subttl	FS load/store executors
	page


MakeExe exAIdESRfFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdISRfFS,opAIdLd,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad ;ds:bx = array descriptor address
FsRf:
	call	ResolveArray	;resolve to segment and offset in dx:bx
	push	dx		;Push segment
	push	bx		; and offset
	mov	bx,PTRTX[si-2]	;Get oVar again
	push	[pVarBx-VAR_value].VAR_cbFixed	; Push length of FS
	DispMac

MakeExe exAIdEIRfFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIIRfFS,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	FsRf
	jmp	IndexCountErr

MakeExe exAIdEFRfFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIFRfFS,opAIdLd,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	FsRf

MakeExe exAIdECRfFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdICRfFS,opAIdLd,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	FsRf



MakeExe exAIdESLdFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdISLdFS,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
FsLd:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	push	dx			;Push segment
	push	bx			; and offset
	mov	bx,PTRTX[si-2]		;Get oVar again
	push	[pVarBx-VAR_value].VAR_cbFixed	; Push length of FS
	CALLRT	B$LDFS,DispMovSd	

MakeExe exAIdEILdFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIILdFS,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	FsLd
	jmp	IndexCountErr

MakeExe exAIdEFLdFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdIFLdFS,opAIdLd,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	FsLd

MakeExe exAIdECLdFS,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAIdICLdFS,opAIdLd,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	FsLd



MakeExe exAIdESStFS,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdISStFS,opAIdSt,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad ;ds:bx = array descriptor address
FsSt:
	call	ResolveArray	;resolve to segment and offset in dx:bx
	push	dx		;Push segment
	push	bx		; and offset
	mov	bx,PTRTX[si-2]	;Get oVar again
	push	[pVarBx-VAR_value].VAR_cbFixed	; Push length of FS
	CALLRT	B$LSET,Disp

MakeExe exAIdEIStFS,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdIIStFS,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	FsSt
	jmp	IndexCountErr

MakeExe exAIdEFStFS,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdIFStFS,opAIdSt,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	FsSt

MakeExe exAIdECStFS,opAIdSt,ET_SD
	SkipExHeader
MakeExe exAIdICStFS,opAIdSt,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	FsSt

subttl	Record store executors
page

MakeExe exAIdICStTyp,opAIdSt,ET_Imp
	LODSWTX 				;Load argument count
	xchg	ax,cx
	LODSWTX 				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	short AStTyp

MakeExe exAIdIIStTyp,opAIdSt,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	AStTyp
	jmp	IndexCountErr

MakeExe exAIdIFStTyp,opAIdSt,ET_Imp
	LODSWTX 		;Index argument count
	xchg	ax,cx
	LODSWTX 		;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp		;bx = pointer to array descriptor
	jmp	short AStTyp



MakeExe exAIdISStTyp,opAIdSt,ET_Imp
	LODSWTX 		;Load argument count
	xchg	ax,cx
	LODSWTX 		;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
AStTyp:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	push	dx			;Need segment on stack
	xchg	ax,bx			;Offset in ax
	mov	bx,PTRTX[si-2]		;Go back and get oVar
	mov	bx,[pVarBx].VAR_oTyp-VAR_value	;oTyp in bx
	xchg	di,ax			;Offset in di, di saved in ax
;ax = saved di	(SizeD = 0 only)
;bx = oTyp of record
;di = offset of destination
;[sp] = segment of destination
;[sp+4]:[sp+2] = pointer to source
	jmp	MoveRec			;Copy the record

subttl	Rf executors
page
;Frame
MakeExe exAIdEFRfR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdEFRfI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdEFRfI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdEFRfR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdIFRf,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	bx,[pVarBx+AFRAME_oFrame]
	add	bx,bp			;bx = pointer to array descriptor
	jmp	short Ref

	;Public


;Static
MakeExe exAIdESRfR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdESRfI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdESRfR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdESRfI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdISRf,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX 			;Operand
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	lea	bx,[pVarBx].ASTAT_ad	;ds:bx = array descriptor address
Ref:
	call	ResolveArray		;resolve to segment and offset in dx:bx
	push	dx
	push	bx			;Put far address on stack
	DispMac 			; and dispatch next executor



MakeExe exAIdECRfI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdECRfI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdECRfR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdECRfR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdICRf,opAIdLd,ET_Imp
	LODSWTX 			;Load argument count
	xchg	ax,cx
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	mov	dx,[pVarBx].ACOM_oValue		;Offset into common block
	test	byte ptr [pVarBx-VAR_value].VAR_fStat,FV_STATIC 
						;Is the array $STATIC?
	mov	bx,[pVarBx].ACOM_oCommon	;oCommon
	jz	@F
	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
@@:

	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,dx				;Offset in block
	jmp	Ref

MakeExe exAIdEIRfI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAIdEIRfI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAIdEIRfR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAIdEIRfR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAIdIIRf,opAIdLd,ET_Imp
	LODSWTX 			;Index argument count
	xchg	ax,cx
	LODSWTX 			;oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame
	mov	bx,[pFrame]		;bx = pointer to array descriptor
	cmp	cl,[bx].AD_cDims	;Correct number of indices?
	jz	Ref
	jmp	IndexCountErr


	;Array descriptor references

MakeExe exAdRfSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exAdRfR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exAdRfI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exAdRfR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exAdRfI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exAdRfImp,opAIdLd,ET_Imp
	;Push addr of array descriptor

	inc	si
	inc	si			;Skip over count of indices
	LODSWTX				;Get oVar
	xchg	ax,bx			; BX = oVar
	DbChk	oVar,bx 		; Check for valid oVar
	call	oVarToPAd		;BX = pAd
	push	bx			;Return pAd
	DispMac

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exconv.asm ===
page	49,132
	TITLE	exConv.asm - Data Type Conversion Functions
;***
;exConv.asm - Data type conversion functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module includes:
;	- all implicit and explicit data type conversion functions
;
;
;****************************************************************************

	.8087

	.xlist
	include 	version.inc
EXCONV_ASM = ON
	IncludeOnce	architec
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	pcode
	.list



assumes ss, DATA


sBegin	CODE
assumes cs, CODE



	subttl	Coercion executors
	page

	;Identity transformations first

MakeExe exFnCSngR8,opCoerce,ET_R4	
	SkipExHeader
MakeExe exFnCDblR8,opCoerce,ET_R8	
	SkipExHeader
MakeExe exFnCLngI4,opCoerce,ET_I4	
	SkipExHeader
MakeExe exFnCIntI2,opCoerce,ET_I2	
	DispMac

	;Coercions from I2

MakeExe exCoII4I2,opNoList0
	SkipExHeader			
MakeExe exFnCLngI2,opCoerce,ET_I4
	pop	ax
	cwd				;Convert to I4
	push	dx
	push	ax
	DispMac

MakeExe exFnCSngI2,opCoerce,ET_R4	
	SkipExHeader
MakeExe exCoIR8I2,opNoList0
	SkipExHeader
MakeExe exFnCDblI2,opCoerce,ET_R8	
	mov	bx,sp			;Source operand
	fild	word ptr DGROUP:[bx]	;Load source
	fwait				
	pop	ax			;Throw away I2
	DispMac




	;Coercions from I4


MakeExe exCoII2I4,opNoList0
	SkipExHeader
MakeExe exFnCIntI4,opCoerce,ET_I2	
	pop	ax
	cwd
	pop	cx
	push	ax			;Assume success
	cmp	cx,dx
	jnz	ErrOVF			;Overflow error
	DispMac

ErrOVF:
	jmp	exMathErrOVF		;Declare overflow error


MakeExe exFnCSngI4,opCoerce,ET_R4	
	SkipExHeader
MakeExe exCoIR8I4,opNoList0
	SkipExHeader
MakeExe exFnCDblI4,opCoerce,ET_R8	
	mov	bx,sp			;Source address
	fild	dword ptr DGROUP:[bx]	;Load
	fwait				
	add	sp,4			
	DispMac				



	;Coercions from R4/R8 and Any

MakeExe exCoII2R8,opNoList0
	SkipExHeader
MakeExe exFnCIntR8,opCoerce,ET_I2	
	sub	sp,2			;Destination address
i87ToI2:
	mov	bx,sp
	fistp	word ptr DGROUP:[bx]	;And xlat the chip value to the stack
	fwait				;Wait for the coprocessor to cool
	DispMac 			; and continue

MakeExe exCoII4R8,opNoList0
	SkipExHeader
MakeExe exFnCLngR8,opCoerce,ET_I4	
	sub	sp,4			
i87ToI4:				
	mov	bx,sp
	fistp	dword ptr DGROUP:[bx]	
	fwait
	DispMac





	;Coercions from Currency



	;Coercions from String




sEnd	CODE

	subttl	Table of Implicit Coercions
	page

;This table is entered by the scanner to get executors for performing
;implicit coercions.  The table is a two dimension array entered by current
;type and required result type.  Identity coercion occur with R4/R8, since
;these are the same on the 8087 stack.  The 0 entry flags the scanner not
;to insert an excutor.

sBegin	SCAN				    
assumes cs, SCAN			    

	;The table below is index as tImpCo[Source][Target], assuming the
	;right index varies most rapidly.

	;The table contains either an executor address or the special values
	;0 and 1.  ) and 1 can not be value executor addresses because each
	;executor must be preceeded by the opcode it maps to.  The special
	;value 0 indicates that the two types have identical representations
	;on the runtime stack and need no conversion.  The value 1 indicates
	;that the values are not compatible and a type mismatch error should
	;be generated at scan time.


	public	tImpCo
tImpCo	label	word

	Dw	0
	Dw	exCoII4I2
	Dw	exCoIR8I2
	Dw	exCoIR8I2
	Dw	1

	Dw	exCoII2I4
	Dw	0
	Dw 	exCoIR8I4
	Dw	exCoIR8I4
	Dw	1


	Dw	exCoII2R8
	Dw	exCoII4R8
	Dw	0
	Dw	0
	Dw	1


	Dw	exCoII2R8
	Dw	exCoII4R8
	Dw	0
	Dw	0
	Dw	1


	Dw	1
	Dw	1
	Dw	1
	Dw	1
	Dw	1
	Dw	0




sEnd	SCAN				
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exaryutl.asm ===
page	49,132
TITLE	exaryutl - Array Utilities

;***
;exaryutl.asm - interpreter specific array support.
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module includes support routines for array related executors:
;   - ResolveArray - a procedure that resolves indices and an array
;     descriptor to a memory address.
;
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXARYUTL_ASM	= ON
	IncludeOnce	architec
	IncludeOnce	array
	IncludeOnce	context
	IncludeOnce	exint
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	variable
	.list


assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

	    assumes ds,DATA

sBegin	CODE
	page
;***
;oVarToPAd - Find/Make array descriptor for a variable table entry
;
;Purpose:
;
;   This routine returns address of the array descriptor.
;   The space for the array descriptor will always be allocated.
;
;Input:
;
;   bx = oVar of array
;
;Output:
;
;   ax = SB of array descriptor if SizeD
;   ds:bx = address of array descriptor.
;   cDims and fFeatures (FADF_STATIC only) fields set from variable table
;
;Preserves:
;
;   cx,dx
;
;***************************************************************************
	public	oVarToPAd
oVarToPAd:
	push	cx
	DbChk	OVar,bx 		;Verify that this is a variable

	mov	cl,byte ptr [pVarBx-VAR_value].VAR_fStat; Get FV_STATIC flag
	mov	ch,[pVarBx].ASTAT_cDims

	    mov     ax,[pVarBx-VAR_value].VAR_Flags ;Get flags
	    TestX   ax,FVVALUESTORED	;Static?
	    jnz     StaticDescr
	    TestX   ax,FVFORMAL 	;Parameter?
	    jnz     ParamDescr
	    TestX   ax,FVCOMMON 	;Common?
	    jnz     CommonDescr

	;Array descriptor is local variable

	mov	bx,[pVarBx].AFRAME_oFrame; oBP of array descriptor
	add	bx,bp			;Point at array descriptor in stack
	jmp	short SetupAD


StaticDescr:

	lea	bx,[pVarBx].ASTAT_ad	; Get address of array descriptor

SetupAD:
	;ch = dim count

	or	ch,ch			; cDims unknown?
	jz	SetStatic		
	mov	[bx].AD_cDims,ch	;Set the count of dimensions in AD
SetStatic:				
	test	cl,FV_STATIC		;Is this a $STATIC array?
	jz	ArrayDescr		;Not $STATIC
	or	[bx].AD_fFeatures,FADF_STATIC	;Indicate $STATIC array
ArrayDescr:
	pop	cx
	ret

ParamDescr:
	;Array descriptor already set up - just point to it

	    mov     bx,[pVarBx].AFORMAL_oFrame	;oBP of pAd
	    add     bx,bp		;BX = Pointer to pAd
	mov	bx,[pFrame]		;ds:bx = pAD

;Added with [10]
	cmp	[bx].AD_cDims,ch	;cDims correct?
	jz	ArrayDescr
	or	ch,ch			;Unknown cDims?
	jz	ArrayDescr
	jmp	RangeErr		; cDims mismatch
;End of [10]


CommonDescr:
	mov	ax,[pVarBx].ACOM_oValue ;Offset into common block
	mov	bx,[pVarBx].ACOM_oCommon;oCommon
	test	cl,FV_STATIC		;Is the array $STATIC?
	jz	GetComDesc		;  brif not

	;$STATIC array descr. is in COMMON type table

	add	bx,COM_bdType - COM_bdValue	;Adjust to point to type table
GetComDesc:
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	jmp	SetupAD



	subttl ResolveArray
	page
;***
;ResolveArray - Resolve array reference to address
;
;Purpose:
;
;   Resolve an array reference to an element address.
;
; NOTE:
;
;   This algorithm requires that:
;      1. No more than 255 indices are allowed.
;      2. The number of indices is correct.  This has been verified by SsScan.
;
;Input:
;
;   ds:bx = address of array descriptor
;      cx = index count
;   stack contains cx ET_I2 index arguments
;
;Output:
;
;   dx:bx = element address
;      ax = address of array descriptor
;      ds = base of module variable table if SizeD
;   index parameters cleaned from stack
;
;Preserves:
;
;   none
;
;Exceptions:
;
;   $ERR_BS - error for bad subscript
;
;*************************************************************************

	public	ResolveArray
ResolveArray:
	cmp	[bx].AD_fhd.FHD_hData,0	;this field is 0 when array not DIMed
	jz	UnDimmedErr		;Brif not allocated.  Error.
	dec	cx			;Special case single dimension array
	jnz	ResolveMulDims		;Go resolve multiple dimension case
	pop	cx			;Return address
	pop	ax			;Get index
	push	cx			;Return address back
	sub	ax,[bx].AD_tDM.DM_iLbound	;Subtract lower bound
	jl	RangeErr
	cmp	ax,[bx].AD_tDM.DM_cElements	;Test for range
	jge	RangeErr
	xor	dx,dx			;Index in dx:ax
	mov	cx,[bx].AD_cbElement	;Size of each element
;Need to multiply index in dx:ax by size of element in cx
	cmp	cx,2			;I2?
	jz	TwoByte
	cmp	cx,4			;I4,R4,SD?
	jnz	OddSize
;Handle 4-byte element
	shl	ax,1
TwoByte:
	shl	ax,1
	rcl	dx,1

HugeArray:
	;dx:ax has 32-bit offset
	;bx = pAD

	add	ax,[bx].AD_fhd.FHD_oData;Add base offset

	    adc     dx,0		;Ripple carry
	    jz	    GetArraySeg

	    ;Multiply dx by 64K/16 = 1000H to get relative segment

	    ror     dx,1
	    ror     dx,1
	    ror     dx,1
	    ror     dx,1

GetArraySeg:
	    add     dx,[bx].AD_fhd.FHD_hData;Load segment from AD

	xchg	bx,ax			;Offset to bx, pAD to ax
	ret

OddSize:
	mul	cx
	jmp	HugeArray

MulRangeErr:
	pop	cx
	pop	di
	pop	si			;Restore location of error

UnDimmedErr:
RangeErr:
	mov	al,ER_SOR		;Subscript out of range
	call	RtErrorCODE		;generate error, don't return


	page
;ResolveMulDims
;
;Purpose:
;
;   Handle the multiple dimension, R8 or user defined record type varients
;   of array access.  These varients can not be optimized in the same way as
;   single dimension I2/I4/SD array resolution.
;
;Input:
;
;   bx = address of AD
;   cx = cDims minus one

ResolveMulDims:
	push	si
	mov	si,sp
	add	si,4			;Point to first index
	push	di
	lea	di,[bx].AD_tDM		;Point to first dimension in descriptor
	push	cx
	xor	cx,cx			;Initialize byte offset value
	    mov     dx,cx
	jmp	short IndexLoopEntry	;Start element offset comp with add

	;Within this loop:
	;ax    = count of remaining indices
	;dx:cx = current offset value (dx is high word). EB uses CX only!
	;bx    = pAD
	;si points to next index
	;di points into array descriptor


IndexLoop:
	push	ax
	add	di,SIZE DM		;Move to next descriptor field

	;[di] * dx:cx multiplication (current offset by dimension in array descriptor)

	    mov     ax,dx
	    mul     [di].DM_cElements
	xchg	cx,ax			;High word has to be zero (DIM worked)
	mul	[di].DM_cElements
	    add     dx,cx		;Can't be carry (DIM worked)
	mov	cx,ax

IndexLoopEntry:
	lods	word ptr DGROUP:[si]	; get index argument
	sub	ax,[di].DM_iLbound	;Account for TO or OPTION BASE
	jl	MulRangeErr 		;Index error
	cmp	ax,[di].DM_cElements	;test for index out of bounds
	jge	MulRangeErr 		;error - index too high
	add	cx,ax			;add index to offset value
	    adc     dx,0		; with carry into high word
					; Can't be overflow - DIM worked
	pop	ax
	dec	ax			;Decrement argument count
	jns	IndexLoop		;Loop to process next argument

	;DX:AX = DX:CX * cbElement.  For EB: AX = CX * cbElement.

	    mov     ax,dx		;Prepare for mult
	    mul     [bx].AD_cbElement	;cbElement * high word

	xchg	cx,ax			;Save low word (high word is zero, since
					; there was no error during DIM)
	mul	[bx].AD_cbElement	;cbElement * low word
	    add     dx,cx		;Add in result of cbType * high word
	dec	si
	dec	si			;New top of stack
	pop	di
	pop	cx			;Old si
	pop	DGROUP:[si]		; Move return address to stack top
	mov	sp,si			;Clean off arguments
	mov	si,cx
	jmp	HugeArray	 	;Exit through single dim code
					; with:
					;   ax = data offset low word
					;   bx = AD address
					;   dx = data offset high word
	page

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exdebug.asm ===
page	49,132
	TITLE	EXDEBUG - Debugging executors

;***
;exdebug.asm - Debugging executors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include		version.inc
	EXDEBUG_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opmin
	IncludeOnce	opstmt
	IncludeOnce	opcontrl
	IncludeOnce	ui
	IncludeOnce	rtps
	.list

assumes es, NOTHING
assumes ss, DATA

	EXTRN	B$SASS:FAR

sBegin	CODE
assumes cs, CODE



	extrn	ExBos:near

;==============================================================================
;			Watch Window executors
;==============================================================================

;***********************************************************************
; exWatchExpI2, exWatchExpI4, exWatchExpR4, exWatchExpR8, exWatchExpSD
; Purpose:
;	evaluate a Watch expression and display its value in watch window
; Entry:
;	[top of stack] = number or ptr to string descriptor
; Exit:
;	exWatchExpSD releases string if it was a temporary
;
;***********************************************************************
MakeExe	exWatchStop,opWatchStop
	mov	bx,[pWatchVal]
	mov	BYTE ptr DGROUP:[bx],12h; indicate value is a WatchPoint
	pop	ax
	pop	dx
	or	ax,dx
	je	DontBreak		;brif not TRUE
	cmp	word ptr DGROUP:[bx+1],0 ; If expression was already true
	jne	DontBreak		;    then don't break.
	or	[debugFlags],DEBUG_WATCHPOINT
					;tell next opBos/Bol to stop program,
					; we've hit a Watch Point
DontBreak:
	mov	DGROUP:[bx+1],ax	; store value
	jmp	SHORT WatchExit


MakeExe	exWatchExpI2,opWatchExp
	mov	al,VT_I2		; Runtime code for ET_I2
DebugDisplay:
	push	ss			
	pop	es			;es = DGROUP for movsw
	mov	di,[pWatchVal]		;Note: di restored by GetEsDi
	stosb				;save type of value
	and	ax,0Fh			;ax = length of value in bytes
	shr	ax,1			;ax = length of value in words
	xchg	cx,ax			;cx = length of value in words
WatchLoop:
	pop	ax
	stosw
	loop	WatchLoop
WatchExit:
	call	GetEsDi			;reload es,di for current context
	jmp	ExBos			; return to User Interface

MakeExe	exWatchExpI4,opWatchExp
	mov	al,VT_I4		; Runtime code for ET_I4
	jmp	SHORT DebugDisplay

	;Rewritten with [7]


MakeExe	exWatchExpR4,opWatchExp
	mov	di,[pWatchVal]		;Note: di restored by GetEsDi
	fstp	dword ptr DGROUP:[di+1]
	mov	byte ptr DGROUP:[di],VT_R4  ; Runtime code for ET_R4
	fwait
	jmp	SHORT WatchExit


MakeExe	exWatchExpR8,opWatchExp
	mov	di,[pWatchVal]		;Note: di restored by GetEsDi
	fstp	qword ptr DGROUP:[di+1]
	mov	byte ptr DGROUP:[di],VT_R8  ; Runtime code for ET_R8
	fwait
	jmp	SHORT WatchExit

	;End of [7]


MakeExe	exWatchExpSD,opWatchExp
	mov	bx,[pWatchVal]
	mov	BYTE ptr DGROUP:[bx],24h; indicate value is a string
	inc	bx			;bx points to value
	push	bx			;pass to B$SASS
	CALLRT	B$SASS			;assign string(psdSrc, psdDst)
	jmp	SHORT WatchExit



;***********************************************************************
; ExStTron, ExStTroff
; Purpose:
;	Executors for TRON/TROFF statements.  Cause animation to be
;	turned on/off.  Does not stop program execution.
;
;***********************************************************************


MakeExe	exStTron,opStTron
	mov	al,1
	jmp	SHORT SetTraceMode

MakeExe	exStTroff,opStTroff
	sub	ax,ax
SetTraceMode:
	mov	[fTraceOn],al
	call	SetTronTroff
	or	[BosFlags],FBOSDEBUG
	DispMac


sEnd	CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\excase.asm ===
page	49,132
	TITLE	excase - executors for SELECT CASE varients
;***
;excase - executors for SELECT CASE varients
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Executors for SELECT CASE varients.
;	Note that the actual comparison executors for case are in
;	exmathop.asm.
;
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opcontrl
	IncludeOnce	opcodes
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	CODE

subttl	SELECT CASE
page
;exStSelectCase2,exStSelectCase4,exStSelectCase8
;
;Purpose:
;      Syntax:	SELECT CASE <exp>
;
;      Pcode:	<exSelexp> opStSelectCase(oTx to <exp> before first CASE)
;
;	<exp> exStSelectCase<2|4|8> (oText)
;	      - Push an additional copy of <exp> on the stack
;		and unconditionally branch to oText.
;
;	The additional copy of the expression will be removed when a
;	successful CASE branch is taken.
;


MakeExe exStSelectCaseR8,opStSelectCase	
	fld	st			;Make additional copy
	jmp	short exStCaseDisp

MakeExe exStSelectCase4,opStSelectCase	
	pop	ax			;Pop top four bytes
	pop	dx
	push	dx			;Restore copy
	push	ax
	push	dx			;Make additional copy
	push	ax
	jmp	short exStCaseDisp

MakeExe exStSelectCase2,opStSelectCase	
	pop	ax			;Pop top two bytes
	push	ax			;Restore copy
	push	ax			;Make additional copy

exStCaseDisp:
	mov	si,PTRTX[si]		;Set up for dispatch
	DispMac

subttl	CASE
page
;exStCase<Lt|Le|Eq|Ge|Gt|Ne|><I2|I4|R8|SD>, exStCaseTo<I2|I4|R8|SD>
;
;Purpose:
;      Syntax:	CASE [IS <relop>] <const>
;
;      Pcode:	[opBol] <const> opStCase[<relop>]
;
;				 +-to beyond END SELECT
;				 |
;      Bound:	[exBol exBranch(oTx)] <const> exStCase[<relop>]<type>
;		exCaseBranch<type>(oTxF, oTxT)
;				    |	  |
;				    |	  +-To next exBol
;				    |
;				    +-To next CASE,ELSE CASE,or END SELECT
;
;      Syntax:	CASE IS <const> TO <const>
;
;      Pcode:	[opBol] <const> <const> opStCaseTo
;
;				 +-to beyond END SELECT
;				 |
;      Bound:	[exBol exBranch(oTx)] <const> <const> exStCaseTo<type>
;		exCaseBranch<type>(oTxF, oTxT)
;				    |	  |
;				    |	  +-To next exBol
;				    |
;				    +-To next CASE,ELSE CASE,or END SELECT
;
;      NOTE: The scanner inserts the non-listable exBranch and exStCaseBranch
;	     pcodes.
;
;
;
;	<exp> <exp1> exStCase<Lt|Le|Eq|Ge|Gt|Ne|><I2|I4|R4|R8|SD>
;	      - Evaluates and consumes top two expressions on stack
;		and emits TRUE or FALSE on stack based upon result.
;		These executors share code with the MathOp executors,
;		except for the SD variants which will not cause
;		the <exp> SD to be released if it was a temp.
;
;	<exp> <exp1> <exp2> exStCaseTo<I2|I4|R4|R8|SD>
;	      - Evaluates <exp> and determines if it falls within
;		the range defined by <exp1> and <exp2>.  All three
;		expressions are consumed, and a TRUE or FALSE is
;		emitted to the stack based on the result of the
;		evaluation.
;
;BIG NOTE:  These executors live in exmathop.asm, since they are very
;	    similar to many existing math executors.



subttl	Case Branch
page
;exCaseBranch2,exCaseBranch4,exCaseBranch8,exCaseBranchSD
;
;Purpose:
;	<exp> exCaseBranch<2|4|8|SD> (oTextF, oTextT)
;	      - Branches to oTextF or oTextT based on TRUE or FALSE
;		condition on stack.  Before taking a false branch, an
;		additional copy of the exStSelectCase expression is
;		placed on the stack. Before taking a TRUE branch, the
;		saved copy of the exStSelectCase exp is consumed and
;		deallocated if it is a string temp. This is non-listable
;		and inserted by the scanner.
;


MakeExe exCaseBranchR8,opNoList2 	
	pop	cx			;Pop off Boolean
	jcxz	exStSelectCaseR8 	;brif false, Copy <exp> and branch
	fstp	st(0)			;Remove operand
	jmp	short exCaseBranchTrueDispSd	

MakeExe exCaseBranch4,opNoList2 	
	pop	cx			;Pop off Boolean
	jcxz	exStSelectCase4 	;brif false, Copy <exp> and branch
exCaseBranchCom:
	pop	ax			;Remove 1/2 of <exp> copy
	jmp	short exCaseBranchTrueDisp  ;and take true branch

MakeExe exCaseBranch2,opNoList2 	
	pop	cx			;Pop off Boolean
	jcxz	exStSelectCase2 	;brif false, Copy <exp> and branch
exCaseBranchTrueDisp:
	pop	ax			;Remove <exp>
exCaseBranchTrueDispSd:
	inc	si			; skip false branch
	inc	si			
	jmp	short exStCaseDisp	;and take true branch

MakeExe exCaseBranchSd,opNoList2
	pop	cx			;Pop off Boolean
	    jcxz    exStSelectCase2	;brif false, Copy <exp> and branch
	call	B$FLEN			;dealc string if temp, <psd> on stack
	jmp	short exCaseBranchTrueDispSd ;take the TRUE path

subttl	CASE ELSE
page

;exStCaseElse2,exStCaseElse4,exStCaseElse8,exStCaseElseSD
;
;Purpose:
;	exStCaseElse<2|4|8|SD>
;	      - Consume both the copy of and the exStSelectCase exp.
;		Deallocate if it is a string temp.

MakeExe exStEndSelectR8,opStEndSelect	
	SkipExHeader			
MakeExe exStCaseElseR8,opStCaseElse	
	fpoptwo				;[6]Eat two operands
	DispMac

MakeExe exStEndSelect4,opStEndSelect	
	SkipExHeader			
MakeExe exStCaseElse4,opStCaseElse	
	add	sp,4
	SkipExHeader
MakeExe exStEndSelect2,opStEndSelect	
	SkipExHeader			
MakeExe exStCaseElse2,opStCaseElse	
	add	sp,4
exStCaseElseCom:
	DispMac

MakeExe exStEndSelectSD,opStEndSelect	
	SkipExHeader			
MakeExe exStCaseElseSD,opStCaseElse
	    pop     ax		    	;pop off val
	call	B$FLEN		    	;dealc string if temp, <psd> on stack
	jmp	short exStCaseElseCom


sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exevent.asm ===
page	49,132
	TITLE	exevent.asm - event executors
;***
;exevent.asm - event executors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXEVENT_ASM = ON
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opmin
	IncludeOnce	opcontrl
	IncludeOnce	opaftqb4
	IncludeOnce	context
	IncludeOnce	rttemp
	IncludeOnce	architec
	IncludeOnce	extort
	.list

assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
sEnd	DATA

;The following constants are used to identify the event type. 

EV_COM		EQU	0d
EV_KEY		EQU	1d
EV_PEN		EQU	2d
EV_PLAY		EQU	3d
EV_SIGNAL	EQU	4d
EV_STRIG	EQU	5d
EV_TIMER	EQU	6d
EV_UEVENT	EQU	7d

sBegin	CODE
assumes cs, CODE

externNP	RtDispatch		

;==============================================================================
;	Event-specific executors - 
;		The following executors just push a constant which identifies
;		the associated event type, and dispatch.
;==============================================================================

MakeExe	exEvCom,opEvCom
	mov	al,EV_COM
	jmp	short Push_n_Disp

MakeExe	exEvKey,opEvKey
	mov	al,EV_KEY
	jmp	short Push_n_Disp

MakeExe	exEvPen,opEvPen
	mov	al,EV_PEN
	jmp	short Push_n_Disp

MakeExe	exEvPlay0,opEvPlay0
	SkipExHeader
MakeExe	exEvPlay1,opEvPlay1
	mov	al,EV_PLAY
	jmp	short Push_n_Disp

MakeExe	exEvSignal,opEvSignal
	mov	al,EV_SIGNAL
	jmp	short Push_n_Disp

MakeExe	exEvStrig,opEvStrig
	mov	al,EV_STRIG
	jmp	short Push_n_Disp

MakeExe	exEvTimer0,opEvTimer0
	SkipExHeader
MakeExe	exEvTimer1,opEvTimer1
	mov	al,EV_TIMER
Push_n_Disp:
	xor	ah,ah
	jmp	DispAx			;push event ID and dispatch

MakeExe exEvUEvent,opEvUEvent		
	mov	al,EV_UEVENT		
	jmp	short Push_n_Disp	

page
;==============================================================================
;	Postbyte tables -
;		The following 4 tables contain postbytes used in conjunction
;		with ExToRt.asm to allow a size-efficient gate to the runtime
;		for the 28 runtime event-specific entry points.
;==============================================================================

tON_GOSUB:
	db	PB$ONCA
	db	PB$ONKA
	db	PB$ONPA
	db	PB$ONLA
	db	PB$ONSG
	db	PB$ONSA
	db	PB$ONTA
	dw	PB$ONUE 		

;If any of the above 7 constants become larger than 255, make tON_GOSUB a 
;  table of words instead of bytes (for 2-byte postbytes)

tEVENT_ON:
	db	PB$ETC0
	db	PB$ETK0
	db	PB$EPE0
	db	PB$ETL0
	db	PB$ESG0
	db	PB$ETS0
	db	PB$ETT0
	dw	PB$EUE0 		

;If any of the above 7 constants become larger than 255, make tEVENT_ON a 
;  table of words instead of bytes (for 2-byte postbytes)

tEVENT_OFF:
	db	PB$ETC1
	db	PB$ETK1
	db	PB$EPE1
	db	PB$ETL1
	db	PB$ESG1
	db	PB$ETS1
	db	PB$ETT1
	dw	PB$EUE1 		

;If any of the above 7 constants become larger than 255, make tEVENT_OFF a 
;  table of words instead of bytes (for 2-byte postbytes)

tEVENT_STOP:
	db	PB$ETC2
	db	PB$ETK2
	db	PB$EPE2
	db	PB$ETL2
	db	PB$ESG2
	db	PB$ETS2
	db	PB$ETT2
	dw	PB$EUE2 		

;If any of the above 7 constants become larger than 255, make tEVENT_STOP a 
;  table of words instead of bytes (for 2-byte postbytes)

page
;==============================================================================
;	ON <event> GOSUB and <event> ON|OFF|STOP executors -
;		The following 4 executors all pop the event ID constant
;		pushed by an event-specific executor (guaranteed to have
;		just been executed), and use this as an index in one of the
;		associated 4 postbyte tables, above.
;==============================================================================

MakeExe	exEvGosub,opEvGosub
	LODSWTX				;ax = gosub target oTx
	pop	bx			;fetch event-ID index
	push	[grs.GRS_oMrsCur]	;pass oMrs for gosub target
	push	ax			;pass oTx for gosub target
	mov	ax,codeOFFSET tON_GOSUB	;start of ON <event> GOSUB postbytes
	jmp	short EventDisp

MakeExe	exEvOn,opEvOn
	mov	ax,codeOFFSET tEVENT_ON	;start of <event> ON postbytes
On_Off_Stop:
	pop	bx			;fetch event-ID index
EventDisp:
	cmp	bx,EV_UEVENT		;UEVENT?
	jz	UEvent			;brif so
	add	ax,bx			;ax = address of appropriate postbyte
	push	ax			;make this look like return address
	jmp	ExToRtDisp		;call runtime and dispatch

UEvent: 				
	add	bx,ax			;bx = address of appropriate postbyte
	mov	al,cs:[bx+1]		;2nd postbyte for UEVENT
	mov	ah,01H			
	mov	cx,CODEOFFSET DispMov	
	jmp	RtDispatch		;call runtime, dispatch on return

MakeExe	exEvOff,opEvOff
	mov	ax,codeOFFSET tEVENT_OFF ;start of <event> OFF postbytes
	jmp	short On_Off_Stop

MakeExe	exEvStop,opEvStop
	mov	ax,codeOFFSET tEVENT_STOP ;start of <event> STOP postbytes
	jmp	short On_Off_Stop

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exgoto.asm ===
page	49,132
	TITLE	EXGOTO - executors for goto and gosub varients
;***
;exgoto - executors for goto and gosub varients
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include 	version.inc
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	debug
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opcontrl
	IncludeOnce	opstmt
	IncludeOnce	opid
	IncludeOnce	opaftqb4
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	rtps
	IncludeOnce	txtmgr
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	externB	b$ErrInfo
sEnd	DATA

	extrn	B$EVTRET:far		;RT reentry point for event RETURN

sBegin	CODE
subttl	GOTO for program and direct mode

	EXTRN	SetProgramMode:NEAR
page

;------------------------------------------------------------------------------
; GOSUB Frames:
;	There are three different GOSUB frames used by QBI -
;	(1) Standard frame
;	(2) Event GOSUB frame
;	(3) GOSUB frame when GOSUB statement occurs in Direct Mode buffer
;
; 	Standard Frame:		 Event Frame:           Direct Mode Frame:
;  Himem       
;                                +--------------+         
;                                |     oRs      |                           
;                                +--------------+                        
;                                |     oTx      |                        
;                                +--------------+                         
;                                |     BP       |                         
;                                +--------------+                         
;                                |  b$curframe  |
;                                +--------------+                         
;                                |    Module    |
;                                |    Frame     |                        
;                                |    Temps     |                         
;                                +--------------+                       
;                                | bcurlevel_QBI|                       
;                                +--------------+                       
;                                |fNonQBI_Active|                       
;       +--------------+         +--------------+       +--------------+
;       |     oTx      |         |      1       |       |   oTx OR 1   |
;       +--------------+         +--------------+       +--------------+
;       |  pGosubLast  |         |  pGosubLast  |       |  pGosubLast  |
;       +--------------+         +--------------+       +--------------+
;  Lomem
;
;	Note that only the QBI specific part of the Event Frame is shown above,
;	the part that's pushed at the point we know an event has occured and
;	the handler is interpreted code. 
;	Note that valid oTx's will never have the low bit set, so if the
;	word on the frame above pGosubLast has the low bit set, it must be
;	for an Event GOSUB or a GOSUB from Direct Mode.
;------------------------------------------------------------------------------

;***
;exStGoto,exStGotoDirect, exStGosubDirect, exStGosub
;Purpose:
;	Handle direct and program mode versions of GOTO and GOSUB.
;
;	For speed, GOTO and GOSUB have special executors for direct and
;	program mode.
;
;	The GOTO and GOSUB operand is fully bound, that is, it is the oTx
;	of the label definition.
;
;	Direct mode versions must...
;
;Input:
;	es:si = pcode address of operand
;Output:
;	es:si	updated
;**********************************************************************
MakeExe exStGotoDirect,opStGotoDirect
	mov	si,PTRTX[si]		;Load destination offset
GotoDirect:
	call	SetProgramMode		;Preserves si
	jmp	short DoDisp


MakeExe exStCommon,opStCommon
	SkipExHeader
MakeExe exStShared,opStShared		
	SkipExHeader			
MakeExe exStStatic,opStStatic		
	SkipExHeader			
MakeExe	exStExitProc,opStExitProc
	SkipExHeader
MakeExe exBranch,opNoList1
	SkipExHeader
MakeExe exStGoto,opStGoto
	mov	si,PTRTX[si]		;Make the branch
DoDisp:
	DispMac 			; and on with the show

MakeExe exBranchRel,opNoList1		
	add	si,PTRTX[si]		;Do a relative branch
	jmp	SHORT DoDisp		

;***
;exStOnGosub,exStOnGoto
;Purpose:
;	Handle both direct mode and program mode ON GOTO and ON GOSUB.
;
;	ON GOTO and ON GOSUB fall through to the next statement if the
;	I2 index argument is out of range, unless the argument is negative
;	or greater than 255, in which case an Illegal Function Call error
;	is issued.
;
;	ON GOSUB pushes a standard GOSUB entry on the stack.  See exStGosub.
;
;	On entry the pcode contains a word operand which is the count of
;	bytes of bound label operands.	Following this is the next executor.
;
;Input:
;	es:si = pcode address of first operand
;	parmW	I2 index
;Output:
;	es:si updated
;	stack cleaned
;***********************************************************************
MakeExe exStOnGosub,opStOnGosub
	mov	cx,sp			;cx non-zero ON GOSUB
	jmp	short StOnShared	;to code shared by ON GOSUB/ON GOTO

MakeExe exStOnGoto,opStOnGoto
	xor	cx,cx			;cx zero indicates ON GOTO
StOnShared:
	LODSWTX 			;Load operand byte count
	pop	bx			;I2 index into label list
	or	bh,bh			;negative number or > 255d?
	jnz	Ill_Fcn_Call		;  brif so

	dec	bx			;Index is 1-based
	shl	bx,1			;To byte index
	cmp	ax,bx			;Test for branch within range
	jbe	OnGoRange		;Not in range

	add	ax,si			;Address of return executor (if GOSUB)
	mov	si,PTRTX[si+bx]		;setup for Branch
	jcxz	GotoDirect		;Not an ON GOSUB - skip building a frame

	call	SetProgramMode		;initialization work if we're coming
					; from direct mode. cx = previous value
					; of fDirect flag
	xchg	ax,si			;si = return address oTx, ax = new oTx
	jcxz	StGosub_Common1		;  brif not Direct Mode GOSUB

	jmp	short Direct_Gosub
OnGoRange:
	add	si,ax			;Index to end
	jmp	short Disp1

Ill_Fcn_Call:
	mov	al,ER_FC		;Illegal Function Call
	SKIP2_PSW			;  skip the next MOV instruction
Stack_Overflow:				;insufficient stack space left for
	mov	al,ER_OM		; recursion
	mov	[b$ErrInfo],OMErr_STK	;note that this is really Out of Stack
	call	RtErrorCODE

;***
;exStGosubDirect, exStGosub
;Purpose:
;	Handle direct mode and program mode GOSUB.
;
;	GOSUB pushes a GOSUB frame on the stack. See top of module for
;	description of frame contents.
;
;	The static variable pGosubLast identifies the last pushed
;	GOSUB frame for the current scope.  When a procedure is invoked,
;	this static variable is preserved as part of the stack frame, to
;	be used for:
;	1. detection of RETURN without GOSUB error.
;	2. walking the stack for edit and continue.
;
;	At procedure return, pGosubLast is updated to reflect the GOSUB
;	frames active in the return scope.
;
;	The location pGosubLast is also used for detecting the lowest
;	stack address valid across user error handlers.
;
;******************************************************************************
MakeExe exStGosubDirect,opStGosubDirect
	LODSWTX 			;Get branch offset
	call	SetProgramMode		;initialize as necessary (can reset stk)
Direct_Gosub:
	or	si,1			;signal that this is a Direct Mode gosub
	or	[grs.GRS_flags],FG_RetDir
					;remember there's a ret adr to
					; direct mode buffer on stack.
	jmp	short StGosub_Common1

MakeExe exStGosub,opStGosub
	LODSWTX 			;Get destination offset
StGosub_Common1:
	push	si			;oTx - return address
	mov	si,ax			;Branch
StGosub_Common:
	push	pGosubLast		;Frame - last previous GOSUB frame
	mov	pGosubLast,sp		;Update frame head pointer
	cmp	sp,[b$pendchk]		;check for stack overflow
	jbe	Stack_Overflow
	DispMac 			; and on with the show.

;***
;exStReturn
;Purpose:
;	Handle RETURN statement without line number.
;
;Input:
;Output:
;***************************************************************************
MakeExe exStReturn0,opStReturn0
	cmp	[pGosubLast],sp 	;Make sure that's a gosub on the stack
	jnz	RetWithoutGosub 	;NULL,so Return without gosub error
	pop	[pGosubLast]		;Frame - Update last active gosub frame
	pop	si			;Frame - Text branch to return
	test	si,1
	jnz	EventOrDirectModeReturn	;Handle ON <event> return or 
					;  return to direct mode buffer
Return_Exit:				
	cmp	[grs.GRS_fDirect],FALSE ;RETURN from Direct Mode?
	jnz	DirectMode_Return	;  brif so
Disp1:
	DispMac 			; and on with the show.

RetWithoutGosub:
	mov	al,ER_RG		;RETURN without GOSUB error
	SKIP2_PSW
CantCont_Err:
	mov	al,ER_CN		;"Cant Continue" error
	call	RtErrorCODE


	EXTRN	Cont_Otx:NEAR		;part of exStCont code

DirectMode_Return:
	cmp	[grs.GRS_otxCONT],UNDEFINED
					;exists context that can be CONTinued?
	jz	CantCont_Err		;  brif not - - issue 'Cant Continue'

	jmp	Cont_Otx		;share code with exStCont


MakeExe exStReturn1,opStReturn1
	;NOTE: if event frame is on stack, can never return to
	;NOTE: context of where event occured now? That seems okay.
	cmp	[pGosubLast],sp 	;Make sure that's a gosub on the stack
	jnz	RetWithoutGosub 	;NULL,so Return without gosub error

	pop	[pGosubLast]		;Frame - Update last active gosub frame
	LODSWTX 			;load oTx of line to return to
	pop	si			;Frame - Text branch to return
	xchg	ax,si			;si = oTx to RETURN to
	dec	ax			;Event GOSUB?
	jnz	Return_Exit		; brif not

	cmp	WORD PTR [bp+8],0	; did event take place in QB code?
	jnz	KeepThisFrame		; brif not - keep this module frame

	mov	ax,[grs.GRS_oRsCur]	
	cmp	ax,[bp+4]		; did event take place at mod. level,
					;  and in the same module as this
					;  handler lives in?
	jz	EventReturn_LineNo	; brif so - - - pop this frame, so
					;  module-level frame and any active
					;  gosub frames are useable again ...
KeepThisFrame:				
	pop	ax			;pop off all but the module frame.
	pop	ax
	jmp	short Return_Exit	

EventReturn_LineNo:			
	call	SetProgramMode		; in case of RETURN from direct mode
	pop	[fNonQBI_Active]	; restore to previous setting	
	pop	[bcurlevel_QBI]		; restore to previous setting	
	mov	sp,bp			
	pop	bp			
	pop	ax			; discard oTx part of return address
	jmp	short EventReturn	

EventOrDirectModeReturn:
	cmp	si,1
	ja	DirectReturn		;brif a RETURN to Direct Mode buffer

	call	SetProgramMode		;in case of a RETURN from direct mode
	pop	[fNonQBI_Active]	;restore to previous setting	
	pop	[bcurlevel_QBI]		;restore to previous setting	
	mov	sp,bp
	pop	bp
	pop	si
EventReturn:
	mov	[b$curframe],bp
	mov	[grs.GRS_oTxCur],si	;in case of an event to QBI code from
					;  non-QBI code now
	pop	ax			;ax = oRs to restore
	call	RsActivateCODE
	jmp	B$EVTRET		;transfer control back to runtime -
					;  runtime returns control to the
					;  context where the event was detected

DirectReturn:
	;Returning into direct mode buffer
	and	si,NOT 1		;make this a normal oTx
	mov	[grs.GRS_fDirect],TRUE	;make Direct Mode text buffer active
	and	[grs.GRS_flags],NOT FG_RetDir
					;remember there's no ret adr to
					; direct mode buffer on stack.
	jmp	DispMov 		;set up ES and dispatch

;***
;B$IEvHandler - runtime call-back to start an event gosub
;
;Purpose:
;	When an event has occured, and the runtime determines that the
;	handler exists and is in QBI code, it calls this routine to start
;	the event gosub.
;Input:
;	DS:BX points to the oTx of the event handler
;	DS:BX+2 points to the oMrs of the event handler
;Exit:
;	none - just starts the subroutine going. A RETURN executor (above)
;	will be responsible returning control back to runtime arbitration.
;***************************************************************************
cProc	B$IEvHandler,<FAR,PUBLIC,NODATA>
cBegin
	push	[grs.GRS_oRsCur]	;so RETURN can restore
	push	[grs.GRS_oTxCur]	;so RETURN can restore
	mov	si,[bx] 		;fetch gosub oTx from RT event table
	mov	ax,[bx+2]		;oMrs to activate for event handler
	call	RsActivateCode

	push	bp			;push a new module level frame
	mov	bp,sp
	push	[b$curframe]		
	mov	[b$curframe],bp
	mov	bx,[grs.GRS_oMrsCur]	
	RS_BASE add,bx			; bx points to mrsCur in the Rs table
	GETRS_SEG es			
	xor	ax,ax
	xchg	ax,[fNonQBI_Active]	;must reset this here in case of error
					; i.e., remember QBI code is active now
	mov	dx,sp
	mov	cx,PTRRS[bx.MRS_cbFrameTemp]	
	add	cx,PTRRS[bx.MRS_cbFrameVars]	
	dec	cx			; pushed b$curframe already accounted
	dec	cx			; for in sp (cbFrameVars cnts it too
	sub	dx,cx
	jc	EvHandler_Overflow	;brif proposed sp value wraps around

	cmp	dx,[b$pendchk]		;check for stack overflow - - - MUST
					; check for this now, so SP can never
					; be set to an illegal value
	ja	EvHandler_Cont		;brif no overflow
EvHandler_Overflow:
	jmp	Stack_Overflow		;note that the rest of the key context
					;  (oRsCur, SI) has been set up to
					;  report the error correctly. Stack
					;  overflow causes stack to be blasted
					;  and a CLEAR to occur anyway, so no
					;  problem that all items didn't get
					;  pushed on the stack.
EvHandler_Cont:
	mov	sp,dx			;make room for module level frame stuff
	DbAssertTst   sp,z,1,CODE,<B$IEvHandler: SP contains an odd number>

	;NOTE: No reason to copy existing module frame vars+temps to and back
	;NOTE: from this new frame, nor to zero them. Frame temps are only
	;NOTE: meaningful within the context of a statement. Frame vars are
	;NOTE: only used by FOR loops; not too worried about what happens if
	;NOTE: user jumps into the middle of a FOR loop; we can't match what
	;NOTE: BC does for that case anyway.

	push	[bcurlevel_QBI]		;save in case this is modified
	push	ax			;previous value of fNonQBI_Active - 
					; remember whether QBI code is active
					; or not at context we're to return
					; to later
	PUSHI	ax,1			;1 (instead of oTx) says "event gosub"
	call	GetEsDi 		;ensure ES & DI setup for execution
	jmp	StGosub_Common
cEnd	<nogen>

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exfnmisc.asm ===
page	49,132
	TITLE	exfnmisc.asm - misc. intrinsic function executors
;***
;exfnmisc.asm - misc. intrinsic function executors for QBI
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXFNMISC_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	heap
	IncludeOnce	opintrsc
	IncludeOnce	opmin
	IncludeOnce	opaftqb4
	.list

assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	;NOTE: these next two data externs are for RUNTIME data
	externW	b$errlin		;basic error line number
	externW b$errnum		;basic error number


sEnd	DATA

sBegin	CODE
assumes cs, CODE

	    extrn   I4ToU2:near





;=============================================================================
;		Error Handling Functions
;=============================================================================
MakeExe	exFnErr,opFnErr
	push	[b$errnum]
	jmp	short Disp1		;that's it - dispatch


MakeExe	exFnErl,opFnErl
	xor	ax,ax
	push	ax			;force this to be a positive long int
	push	[b$errlin]
Disp1:
	jmp	Disp			;that's it - dispatch

MakeExe	exFnErdev,opFnErdev
	CALLRT	B$ERDV,DispAx

MakeExe	exFnErdev_,opFnErdev_
	CALLRT	B$ERDS,DispMovAx

;=============================================================================
;		Math-related Functions
;=============================================================================
MakeExe	exFnRnd,opFnRnd
	CALLRT	B$RND0,DispR4

MakeExe	exFnRnd1,opFnRnd1
;Added with [6]
	sub	sp,4			;Make room for argument
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Copy to local stack
	fwait
;End of [6]
	CALLRT	B$RND1,DispR4

;=============================================================================
;		Heap-related Functions
;=============================================================================
MakeExe	exFnFreI2,opFnFre
	CALLRT	B$FRI2,DispMovDxAx


MakeExe	exFnFreSD,opFnFre
	CALLRT	B$FRSD,DispMovDxAx

MakeExe	exFnVarPtr,opFnVarPtr
	pop	ax			;Get the offset
	pop	dx			;Throw away the segment
	jmp	DispAx			;Push ax and dispatch

MakeExe	exFnPeek,opFnPeek
	call	I4toU2			;coerce I4 addr on stack to a U2
	CALLRT	B$PEEK,DispAx

MakeExe	exFnSetmem,opFnSetmem
	mov	di,sp			;di points to I4 argument to SETMEM
	test	byte ptr [di+3],080H	;are we passing a negative number
					;  to SETMEM?
	jz	SetMem_Cont		;brif not (don't want to give OM
					;  error in this case ...)
	call	GrabSpace		;don't let the user squeeze memory
					;  down to the point that we can't 
					;  get back into the user interface ...
	jnz	SetMem_Cont		;brif we did grab enough space

	xor	ax,ax			;change this to a SETMEM(0) call
	mov	word ptr [di],ax
	mov	word ptr [di+2],ax
SetMem_Cont:
	CALLRT	B$SETM
	push	dx
	push	ax
	call	ReleaseSpace		;give back space if we grabbed any
	jmp	DispMov

MakeExe	exFnVarSeg,opFnVarSeg
	pop	ax			;Throw away the offset
	jmp	Disp			;Leave the seg on the stack

MakeExe	exFnVarPtr_,opFnVarPtr_
	LODSWTX				;fetch type constant for variable
	push	ax			;pass type constant to B$VARP
	CALLRT	B$VARP,DispMovAx

MakeExe	exFnPlay,opFnPlay
	CALLRT	B$FPLY,DispAx

	;Added with [8]


	;End of [8]

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exid.asm ===
page	49,132
	TITLE	ExId	-	SImple Id Executors
;***
;exid.asm - executors for simple id references.
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains all exId executors.
;
;   Simple variables may also be referenced by exVtRfxx executors.
;   These are always nops, and are maintained with the nonspeed-
;   critical nop executors.
;
;   In general, these executors are very speed critical.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opaftqb4
	IncludeOnce	opid
	IncludeOnce	opstmt
	IncludeOnce	pcode		
	IncludeOnce	pointers
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	scanner
	IncludeOnce	variable
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA



RestoreVarTable equ	<mov ds,cx>


sBegin	CODE

subttl	Public Load

;Added with [15]
;End of [15]

subttl	Static Load
MakeExe exIdISLd2,opIdLd,ET_Imp
	LODSWTX 			;Pick up variable address operand
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx
	push	[pVarBx]
	DispMac 			;Dispatch to next executor

MakeExe exIdESLdI2,opIdLd,ET_I2
	LODSWTX 			;Pick up variable address operand
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx
	push	[pVarBx]		;Push the I2
	DispMac 			;Dispatch to next executor

MakeExe exIdESLdI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdISLd4,opIdLd,ET_Imp
	LODSWTX
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx
	push	[pVarBx+2]
	push	[pVarBx]
	DispMac


;Added with [18]
MakeExe exIdESLdR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdISLdR4,opIdLd,ET_Imp
	LODSWTX
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx
	fld	dword ptr [pVarBx]
	DispMac

MakeExe exIdESLdR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdISLdR8,opIdLd,ET_Imp 	
	LODSWTX
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx
	fld	qword ptr [pVarBx]
	DispMac
;End of [18]

subttl Common Load

MakeExe exIdECLdI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdICLd2,opIdLd,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	push	[bx]
	DispMac


MakeExe exIdECLdI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdICLd4,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	push	[bx+2]
	push	[bx]
	DispMac



;Added with [18]
MakeExe exIdECLdR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdICLdR4,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	fld	dword ptr [bx]
	DispMac

MakeExe exIdECLdR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdICLdR8,opIdLd,ET_Imp 		
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	fld	qword ptr [bx]
	DispMac
;End of [18]

subttl Indirect Load
page

MakeExe exIdEILdI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdIILd2,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame]		;Load address of variable
	push	[bx]			;Push the I2
	DispMac

MakeExe exIdEILdI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdIILd4,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame]		;Load address of variable
	push	[bx+2]
	push	[bx]
	DispMac


;Start of [18]

MakeExe exIdEILdR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdIILdR4,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame]		;Load address of variable
	fld	dword ptr [bx]
	DispMac


MakeExe exIdEILdR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdIILdR8,opIdLd,ET_Imp 		
	LODSWTX 				;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	GetpFrame				;Get pointer into frame
	mov	bx,[pFrame]			;Load address of variable
	fld	qword ptr [bx]
	DispMac

;End of [18]

subttl Frame Load and Indirect Reference
page

;  The executors for loading two byte and four byte frame variables are
;  also used for references to indirect variables.  For a load of a frame
;  variable, the variable table contains the value which is pushed on the
;  stack.  For a reference to an indirect variable, the variable table
;  contains the address which is then pushed on the stack.  Since addresses
;  are either two or four bytes, only these entries serve two purposes.

MakeExe exIdIIRfTyp,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	mov	bx,[pVarBx]			;Get oFrame
	add	bx,bp				;oFrame to pFrame entry
	push	ds
	push	[bx]
	DispMac

MakeExe exIdEIRfR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdEIRfSD,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdEIRfI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdEIRfR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdEFLdI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdIFLd2,opIdLd,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	GetpFrame				;Get pointer into frame
	push	[pFrame]			;Push the I2
	DispMac


MakeExe exIdEFLdI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdIFLd4,opIdLd,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	GetpFrame				;Get pointer into frame
	push	[pFrame+2]
	push	[pFrame]
	DispMac


;Added with [18]
MakeExe exIdEFLdR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdIFLdR4,opIdLd,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	GetpFrame				;Get pointer into frame
	fld	dword ptr [pFrame]
	DispMac

MakeExe exIdEFLdR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdIFLdR8,opIdLd,ET_Imp 		
	LODSWTX 				;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	GetpFrame				;Get pointer into frame
	fld	qword ptr [pFrame]
	DispMac
;End of [18]

subttl	Public Store
page
;Added with [15]

	;End of [15]



	subttl	Static Store
	page

MakeExe exIdESStSD,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdISStSD,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	    add     ax,di		;ax = pSdStore
	    push    ax
	CALLRT	B$SASS,DispMov


MakeExe exIdISSt2,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	pop	[pVarBx]		;Store stack in value
	DispMac

MakeExe exIdESStI2,opIdSt,ET_I2
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	pop	[pVarBx]		;Store stack in value
	DispMac

MakeExe exIdESStI4,opIdSt,ET_I4
	SkipExHeader
MakeExe exIdISSt4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	pop	[pVarBx]		;Store stack in value
	pop	[pVarBx+2]
	DispMac


	;Added with [18]

MakeExe exIdESStR4,opIdSt,ET_R4
	SkipExHeader
MakeExe exIdISStR4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	fstp	dword ptr [pVarBx]
	fwait
	DispMac

MakeExe exIdESStR8,opIdSt,ET_R8
	SkipExHeader
MakeExe exIdISStR8,opIdSt,ET_Imp 	
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	fstp	qword ptr [pVarBx]
	fwait
	DispMac

	;End of [18]

MakeExe exIdISStTyp,opIdSt,ET_Imp
	LODSWTX 			    ;Get oVar
	DbChk	oVar,ax 		    ; Check for valid oVar
	    add     ax,di		    ;oVar --> pVar
	xchg	di,ax			    ;Destination (points to value field)
	mov	bx,[di-VAR_value].VAR_oTyp  ;Get oTyp
	    push    ds
	jmp	MoveRec

subttl	Common Store
page


MakeExe exIdECStI2,opIdSt,ET_I2
	SkipExHeader
MakeExe exIdICSt2,opIdSt,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	pop	[bx]
	DispMac


MakeExe exIdECStI4,opIdSt,ET_I4
	SkipExHeader
MakeExe exIdICSt4,opIdSt,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	pop	[bx]
	pop	[bx+2]
	DispMac


;Added with [18]
MakeExe exIdECStR4,opIdSt,ET_R4
	SkipExHeader
MakeExe exIdICStR4,opIdSt,ET_Imp
	LODSWTX 				;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	fstp	dword ptr [bx]
	fwait
	DispMac

MakeExe exIdECStR8,opIdSt,ET_R8
	SkipExHeader
MakeExe exIdICStR8,opIdSt,ET_Imp 		
	LODSWTX 				;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	fstp	qword ptr [bx]
	fwait
	DispMac
;End of [18]

MakeExe exIdECStSD,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdICStSD,opIdSt,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	push	bx			;Push pSD
	CALLRT	B$SASS,DispMov


MakeExe exIdICStTyp,opIdSt,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx
	DbChk	oVar,bx 			; Check for valid oVar
	mov	cx,[pVarBx].COMREF_oValue	;Offset into common block
	mov	ax,[pVarBx].COMREF_oCommon	;oCommon
	mov	bx,[pVarBx-VAR_value].VAR_oTyp	;Get oTyp
	add	ax,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	xchg	ax,di
	mov	di,[di].COM_bdValue.BD_pb	;Common block
	add	di,cx				;Offset in block
	push	ds
;ax = saved di
;bx = oTyp of record
;di = offset of destination
;[sp] = segment of destination
;[sp+4]:[sp+2] = pointer to source
	jmp	MoveRec


subttl	Frame Store
page

MakeExe exIdEFStI2,opIdSt,ET_I2
	SkipExHeader
MakeExe exIdIFSt2,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	pop	[pFrame]
	DispMac

MakeExe exIdEFStI4,opIdSt,ET_I4
	SkipExHeader
MakeExe exIdIFSt4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	pop	[pFrame]
	pop	[pFrame+2]
	DispMac


;Added with [18]
MakeExe exIdEFStR4,opIdSt,ET_R4
	SkipExHeader
MakeExe exIdIFStR4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	fstp	dword ptr [pFrame]
	fwait
	DispMac

MakeExe exIdEFStR8,opIdSt,ET_R8
	SkipExHeader
MakeExe exIdIFStR8,opIdSt,ET_Imp 	
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	fstp	qword ptr [pFrame]
	fwait
	DispMac
;End of [18]

MakeExe exIdEFStSD,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdIFStSD,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	mov	ax,[pVarBx]		;Get oBP
	add	ax,bp			;ax = pSD
	push	ax			;Push pSD
	CALLRT	B$SASS,DispMov

MakeExe exIdIFStTyp,opIdSt,ET_Imp
	LODSWTX 			    ;Get oVar
	DbChk	oVar,ax 		    ; Check for valid oVar
	    add     ax,di		    ;oVar --> pVar
	xchg	bx,ax			    ;pVar to bx
	xchg	ax,di			    ;Save di in ax
	mov	di,[bx] 		    ;Get oBP
	add	di,bp
	mov	bx,[bx-VAR_value].VAR_oTyp  ;Get oTyp
	    push    ss
	jmp	MoveRec

subttl	Indirect Store

MakeExe exIdEIStI2,opIdSt,ET_I2
	SkipExHeader
MakeExe exIdIISt2,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame] 		;Near address to bx
	pop	[bx]
	DispMac 			;Dispatch to next executor

MakeExe exIdEIStI4,opIdSt,ET_I4
	SkipExHeader
MakeExe exIdIISt4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame]		;Near address to bx
	pop	[bx]
	pop	[bx+2]
	DispMac 			;Dispatch to next executor


;Added with [18]
MakeExe exIdEIStR4,opIdSt,ET_R4
	SkipExHeader
MakeExe exIdIIStR4,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame]		;Near address to bx
	fstp	dword ptr [bx]
	fwait
	DispMac 			;Dispatch to next executor


MakeExe exIdEIStR8,opIdSt,ET_R8
	SkipExHeader
MakeExe exIdIIStR8,opIdSt,ET_Imp 	
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	mov	bx,[pFrame] 		;Near address to bx
	fstp	qword ptr [bx]
	fwait
	DispMac 			;Dispatch to next executor
;End of [18]

MakeExe exIdEIStSD,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdIIStSD,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	xchg	ax,bx			;Move to base register
	DbChk	oVar,bx 		; Check for valid oVar
	GetpFrame			;Get pointer into frame
	push	[pFrame]		; Push pSD/handle
	CALLRT	B$SASS,DispMov

MakeExe exIdIIStTyp,opIdSt,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	    add     ax,di		;oVar --> pVar
	xchg	bx,ax			;pVar to bx
	    xchg    ax,di		;Save di in ax
	mov	di,[bx] 		;Get oBP
	mov	bx,[bx-VAR_value].VAR_oTyp ;Get oTyp
	    push    ds
	mov	di,[bp+di]		;Near address to di
	jmp	MoveRec

subttl	Public IdRf Executors
page

;Added with [15]

	;End of [15]

	subttl	Static IdRf Executors
	page

MakeExe exIdISRfTyp,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	add	ax,di			;oVar --> pVar
	push	ds			;Push far pointer
	push	ax
	DispMac

MakeExe exIdESRfR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdESRfI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdESRfSD,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdESRfR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdESRfI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdISRf,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	    add     ax,di		;oVar --> pVar
	push	ax
	DispMac


SameExe exIdISLdSD,exIdISRf		
SameExe exIdESLdSD,exIdESRfSD



	subttl	Frame IdRf Executors
	page

MakeExe exIdIFRfTyp,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	xchg	bx,ax			;Move to base register
	mov	ax,[pVarBx]		;Get oFrame
	add	ax,bp			;oFrame to pValue
	push	ds
	push	ax
	DispMac

MakeExe exIdEFRfR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdEFRfSD,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdEFRfI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdEFRfR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdEFRfI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdIFRf,opIdLd,ET_Imp
	LODSWTX 			;Get oVar
	DbChk	oVar,ax 		; Check for valid oVar
	xchg	bx,ax			;Move to base register
	mov	ax,[pVarBx]		;Get oFrame
	add	ax,bp			;oFrame to pValue
	push	ax
	DispMac


SameExe exIdIFLdSD,exIdIFRf		


	subttl	Common IdRf Executors
	page


MakeExe exIdICRfTyp,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	push	ds
	push	bx
	DispMac


MakeExe exIdECRfR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exIdECRfSD,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdECRfI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exIdECRfR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exIdECRfI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exIdICRf,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,ax				;Offset in block
	push	bx
	DispMac



SameExe exIdICLdSD,exIdICRf		
SameExe exIdECLdSD,exIdECRfSD



	subttl	FS load/store/ref executors
	page


MakeExe exIdESRfFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdISRfFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	    add     ax,di			;oVar --> pVar
	xchg	bx,ax				;pVar to bx
	    push    ds
	push	bx				;Far address to stack
	push	[bx-VAR_value].VAR_cbFixed	; Push length of FS
	DispMac

MakeExe exIdEIRfFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdIIRfFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	xchg	ax,bx				;Move to base register
	DbChk	oVar,bx 			; Check for valid oVar
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	GetpFrame				;Get pointer into frame
	push	ds
	push	[pFrame]		;Push offset
	push	ax			;Push cb in FS
	DispMac

MakeExe exIdEFRfFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdIFRfFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax				;Move to base register
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	bx,[pVarBx]			;Get oFrame
	add	bx,bp				;oFrame to pFrame entry
	    push    ss
	push	bx
	push	ax				;Push cb in FS
	DispMac


MakeExe exIdESLdFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdISLdFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	    add     ax,di			;oVar --> pVar
	xchg	bx,ax				;pVar to bx
	    push    ds
	push	bx				;Far address to stack
	push	[bx-VAR_value].VAR_cbFixed	; Push length of FS
	CALLRT	B$LDFS,DispMovSd

MakeExe exIdEILdFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdIILdFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax				;Move to base register
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	GetpFrame			;Get pointer into frame
	push	ds
	push	[pFrame]			;Push offset
	push	ax				;Push cb in FS
	CALLRT	B$LDFS,DispMovSd

MakeExe exIdEFLdFS,opIdLd,ET_SD
	SkipExHeader
MakeExe exIdIFLdFS,opIdLd,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax				;Move to base register
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	bx,[pVarBx]			;Get oFrame
	add	bx,bp				;oFrame to pFrame entry
	push	ss
	push	bx
	push	ax				;Push cb in FS
	CALLRT	B$LDFS,DispMovSd



MakeExe exIdESStFS,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdISStFS,opIdSt,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	    add     ax,di			;oVar --> pVar
	xchg	bx,ax				;pVar to bx
	    push    ds
	push	bx				;Far address to stack
	push	[bx-VAR_value].VAR_cbFixed	; Push length of FS
	CALLRT	B$LSET,Disp

MakeExe exIdEIStFS,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdIIStFS,opIdSt,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax				;Move to base register
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	GetpFrame				;Get pointer into frame
	push	ds
	push	[pFrame]			;Push offset
	push	ax				;Push cb in FS
	CALLRT	B$LSET,Disp

MakeExe exIdEFStFS,opIdSt,ET_SD
	SkipExHeader
MakeExe exIdIFStFS,opIdSt,ET_Imp
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax				;Move to base register
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	bx,[pVarBx]			;Get oFrame
	add	bx,bp				;oFrame to pFrame entry
	push	ss
	push	bx
	push	ax				;Push cb in FS
	CALLRT	B$LSET,Disp


MakeExe exIdICRfFS,opIdLd,ET_Imp
	SkipExHeader
MakeExe exIdECRfFS,opIdLd,ET_SD
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	cx,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,cx				;Offset in block
	push	ds
	push	bx
	push	ax			;Push cb in FS
	DispMac


MakeExe exIdICLdFS,opIdLd,ET_Imp
	SkipExHeader
MakeExe exIdECLdFS,opIdLd,ET_SD
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	cx,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,cx				;Offset in block
	push	ds
	push	bx
	push	ax			;Push cb in FS
	CALLRT	B$LDFS,DispMovSd


MakeExe exIdICStFS,opIdSt,ET_Imp
	SkipExHeader
MakeExe exIdECStFS,opIdSt,ET_SD
	LODSWTX					;Get oVar
	DbChk	oVar,ax 			; Check for valid oVar
	xchg	bx,ax
	mov	ax,[pVarBx-VAR_value].VAR_cbFixed   ; Get length
	mov	cx,[pVarBx].COMREF_oValue	;Offset into common block
	mov	bx,[pVarBx].COMREF_oCommon	;oCommon
	add	bx,[grs.GRS_bdtComBlk.BD_pb]	;pCommon
	mov	bx,[bx].COM_bdValue.BD_pb	;Common block
	add	bx,cx				;Offset in block
	push	ds
	push	bx
	push	ax				;Push cb in FS
	CALLRT	B$LSET,Disp




SameExe	exIdIIRf,exIdIFLd2
SameExe	exIdEIRfI2,exIdEFLdI2

;*************************************************************************

MakeExe exStDim,opStDim
	inc	si
	inc	si			;Eat the operand
	DispMac

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exif.asm ===
page	49,132
	TITLE	exif - executors for IF and ELSE, DO/LOOP, and WHILE/WEND varients
;***
;exif - executors for IF and ELSE, DO/LOOP, and WHILE/WEND varients
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Executors for IF and ELSE varients.
;	Also contains Executors for WHILE/WEND, and DO/LOOP varients
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opcontrl
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	CODE

	EXTRN	SetProgramMode:NEAR

subttl	IF
page
;exStIfR8
;Purpose:
;	These handle the case of
;	   IF a!
;	and
;	   IF a#
;


MakeExe exStR8While,opStWhile
	SkipExHeader
MakeExe exStLoopR8Until,opStLoopUntil
	SkipExHeader
MakeExe exStDoR8While,opStDoWhile
	SkipExHeader
MakeExe	exStElseIfR8,opStElseIf
	SkipExHeader
MakeExe	exStIfR8,opStIf
	SkipExHeader			;Fall through 
MakeExe	exStIfBlockR8,opStIfBlock
;Re-written with [4]
	fldz			;Put zero on stack
	fcompp			;Compare with zero and remove operands
	fstsw	[Stat]		;Save result of comparison
	fwait
	mov	ax,[Stat]
	sahf
	jz	IfFalse
	jmp	short IfTrue
;End of [4]

MakeExe exStI4While,opStWhile
	SkipExHeader
MakeExe exStLoopI4Until,opStLoopUntil
	SkipExHeader
MakeExe exStDoI4While,opStDoWhile
	SkipExHeader
MakeExe	exStElseIfI4,opStElseIf
	SkipExHeader
MakeExe	exStIfI4,opStIf
	SkipExHeader
MakeExe	exStIfBlockI4,opStIfBlock
	pop	ax
	pop	dx
AxDxZtest:				
	or	ax,dx			;PSW.Z set = FALSE
	jnz	IfTrue			;TRUE
IfFalse:
	mov	si,PTRTX[si]		;Take the false branch
	DispMac

MakeExe exStI2While,opStWhile
	SkipExHeader
MakeExe exStLoopI2Until,opStLoopUntil
	SkipExHeader
MakeExe exStDoI2While,opStDoWhile
	SkipExHeader
MakeExe	exStElseIfI2,opStElseIf
	SkipExHeader
MakeExe	exStIfBlockI2,opStIfBlock
	SkipExHeader
MakeExe	exStIfI2,opStIf
	pop	cx			;I2 TRUE or FALSE
	jcxz	IfFalse			;FALSE
IfTrue:
IfLabFalse:
	add	si,2			;Skip operand
	DispMac

MakeExe exStDoI2Until,opStDoUntil
	SkipExHeader
MakeExe exStLoopI2While,opStLoopWhile
	SkipExHeader
MakeExe	exStIfGotoLabI2,opStIfGotoLab
	SkipExHeader			;Fall into next executor
MakeExe	exStIfLabI2,opStIfLab
	pop	cx
	jcxz	IfLabFalse		;False case - fall through label
IfLabTrue:
	mov	si,PTRTX[si]		;TRUE - branch to label
	DispMac

subttl	IfLabDirect
page
;IfLabDirect
;Purpose:
;	Handle the case that there is an IfLab in a direct mode statment.
;	This is kept separate from program mode IfLab as it is speed critical.
;
MakeExe	exStIfLabDirectI2,opStIfLabDirect
	xor	dx,dx
IfLabDirectCom:
	pop	ax
IfLabDirectIntCom:
	or	ax,dx
IfLabDirectFlag:
	jz	IfLabFalse
IfLabDirectTrue:
	mov	si,PTRTX[si]		;Load start offset
	call	SetProgramMode
	DispMac


MakeExe	exStIfLabDirectR8,opStIfLabDirect
;Re-written with [4]
	fldz			;Put zero on stack
	fcompp			;Compare with zero and remove operands
	fstsw	[Stat]		;Save result of comparison
	fwait
	mov	ax,[Stat]
	sahf
	jmp	IfLabDirectFlag
;End of [4]

MakeExe	exStIfLabDirectI4,opStIfLabDirect
	pop	dx
	jmp	short IfLabDirectCom
subttl	IfLab
page

MakeExe exStDoI4Until,opStDoUntil
	SkipExHeader
MakeExe exStLoopI4While,opStLoopWhile
	SkipExHeader
MakeExe	exStIfGotoLabI4,opStIfGotoLab
	SkipExHeader			;Fall into next executor
MakeExe	exStIfLabI4,opStIfLab
	pop	dx
IfLabFalseOrTrue:
	pop	ax
	or	ax,dx
IfLabFlag:
	jz	IfLabFalse		;FALSE - fall through label
	jmp	short IfLabTrue		;TRUE - branch to label


MakeExe exStDoR8Until,opStDoUntil
	SkipExHeader
MakeExe exStLoopR8While,opStLoopWhile
	SkipExHeader
MakeExe	exStIfGotoLabR8,opStIfGotoLab
	SkipExHeader			;Fall into next executor
MakeExe	exStIfLabR8,opStIfLab
;Re-written with [4]
	fldz			;Put zero on stack
	fcompp			;Compare with zero and remove operands
	fstsw	[Stat]		;Save result of comparison
	fwait
	mov	ax,[Stat]
	sahf
	jmp	IfLabFlag
;End of [4]

subttl Else
page
MakeExe	exStElseLabDirect,opStElseLabDirect
	mov	si,PTRTX[si]		;Load start offset
	call	SetProgramMode		;Set up for execution
	SkipExHeader			;Fall into next executor
MakeExe exStDo,opStDo
	SkipExHeader
MakeExe	exStEndIfBlock,opStEndIfBlock
	SkipExHeader			;Fall into next executor
MakeExe	exStElseNop,opStElseNop
	DispMac				;Speed critical NOP for ElseNop

MakeExe exStWend,opStWend
	SkipExHeader
MakeExe exStLoop,opStLoop
	SkipExHeader
MakeExe	exStElseLab,opStElseLab
	SkipExHeader			;Fall into next executor
MakeExe	exStElse,opStElse
	mov	si,PTRTX[si]		;Perform the branch
	DispMac				; and on with the show

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exfor.asm ===
page	49,132
	TITLE	exfor - FOR/NEXT executors
;***
;exfor - FOR/NEXT executors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains all executors for FOR and NEXT.
;
;	In general, these executors are very speed critical.
;
;	FOR executors are:
;
;	exStFor<Step|><I2|I4|R4|R8|CY>
;
;	<Step|> - indicates whether there is a STEP clause.  This variant has
;		  one more argument then other variants.
;
;	<type> - FOR receives stack arguments of a specific type
;
;	NEXT executors are:
;
;	exStNext<Step|><Id|><type>
;
;	<Step|> - NEXT in the case that no STEP clause was found can be made
;		  faster, as the STEP need not be loaded, and no checking is
;		  necessary for the STEP sign.
;
;	<Id|> - This variation is for listability.  Due to memory movement,
;		it is always necessary to execute a exIdRf before the NEXT.
;		The lister can't tell whether to list this op without help.
;		This is a usability issue.  The variants without Id are made
;		to share code with Id variants to conserve size.
;
;	<type> - NEXT is specific by type.  R8 data type FOR/NEXT are less
;		 speed critical than other types.  Size considerations require
;		 that R8 NEXT variants share code.
;
;
;****************************************************************************

	.8087

	.xlist
	include 	version.inc
EXFOR_ASM	=	ON
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opcontrl
	IncludeOnce	rtinterp
	IncludeOnce	variable
	.list

extrn	B$CMI4:far			



GetpFrame   MACRO			;Re-defining macro in exint.inc
	xchg	bx,ax			;;Get oBP to bx
	add	bx,bp
	ENDM



assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	CODE

	subttl	FOR I2 Variants
	page
MakeExe exStForI2,opStFor
	LODSWTX 			;Pick up offset to FOR block
	GetpFrame
	pop	cx
	mov	[pFrame],cx 		;Limit to FOR block
	pop	ax			;Initial value for variable
	pop	bx			;Address of variable value
	mov	si,PTRTX[si]		;Text branch to the operand of NEXT
	jmp	StNextForI2		;FOR entry in matching NEXT executor


MakeExe exStForStepI2,opStForStep
	LODSWTX 			;Pick up offset to FOR block
	GetpFrame
	pop	cx			;Step
	mov	[pFrame],cx 		;Step to FOR block
	pop	ax			;Limit
	mov	[pFrame+2],ax		;Limit to FOR block
	pop	dx			;Initial value
	pop	bx			;Address of index variable value
	mov	[bx],dx 		;Assign initial value to variable
	mov	si,PTRTX[si]		;Branch to the NEXT operand
	jmp	StNextStepForI2 	;FOR entry in matching NEXT executor

subttl	FOR I4 Variants
page
MakeExe exStForI4,opStFor
	xor	ax,ax			;Supply the STEP for the user
	push	ax
	inc	ax
	push	ax			; push an (I4)1 and use the same NEXT
	SkipExHeader
MakeExe exStForStepI4,opStForStep
	LODSWTX 			;Pick up offset to FOR block
	GetpFrame
	pop	[pFrame]		;Step second word
	pop	[pFrame+2]		;Step first word
	pop	[pFrame+4]		;Limit second word
	pop	[pFrame+6]		;Limit first word
	pop	cx			;Initial value second word
	pop	dx			;Init value first word
	xchg	ax,FrameReg		;ax = FOR block address
	pop	bx			;pVar
	mov	si,PTRTX[si]		;Branch to the NEXT operand
	jmp	StNextForI4		;Exit through NEXT code

;ax    = FOR block address
;ds:bx = var address
;dx/cx = initial value

subttl	FOR R4 Variants
page
;NonSTEP variants
MakeExe exStForR4,opStFor
	fld1				;NonSTEP variants push a 1 for STEP
	SkipExHeader
;Step variants
MakeExe exStForStepR4,opStForStep
	LODSWTX 			;Pick up offset to FOR block
	GetpFrame
	fstp	dword ptr [pFrame]	;Get step
	fstp	dword ptr [pFrame+4]	;Get limit
	xchg	ax,FrameReg		;ax = FOR block address
	mov	si,PTRTX[si]		;Skip to NEXT
	pop	bx			;pVar
	jmp	StForNextR4		;Exit through NEXT with
					;  pFrame = FOR block address
					;  bx = variable

subttl	FOR R8 Variants
page

MakeExe exStForR8,opStFor
;R8 without step is fast enough and smaller if FOR simply supplies the step
	fld1
	SkipExHeader
MakeExe exStForStepR8,opStForStep
	LODSWTX 			;Pick up offset to FOR block
	GetpFrame
	fstp	qword ptr [pFrame]	;Get step
	fstp	qword ptr [pFrame+8]	;Get limit
	xchg	ax,FrameReg		;ax = FOR block address
	mov	si,PTRTX[si]		;Skip to NEXT
	pop	bx			;Variable address
	jmp	StForNextR8		;Exit through NEXT with
					;  pFrame or ax = FOR block address
					;  bx = variable

subttl	FOR CY Variants
page


subttl	NEXT I2 Variants Without STEP
page

MakeExe exStNextI2,opStNext
	SkipExHeader
MakeExe exStNextIdI2,opStNextId
	LODSWTX 			;Pick up oBp of parameters
	GetpFrame
	mov	cx,[pFrame] 		;Pick up Limit
	pop	bx			;Var ref
	mov	ax,[bx] 		;Load index value
	inc	ax			;Perform the step
	jo	NextI2OverflowErr	;Error - overflow
StNextForI2:				;FOR entry in matching NEXT executor
	mov	[bx],ax 		;Store in variable
	cmp	ax,cx			;Test var against limit
	jg	ExitLoop		;Loop end conditions met
NextCont:
	mov	si,PTRTX[si]		;Branch to beyond FOR
	DispMac 			;And on with the show

ExitLoop:
	inc	si			;Skip operand
	inc	si
	DispMac 			; and go

NextI2OverflowErr:
	jmp	exMathErrOVF

	subttl	NEXT I2 Variants With STEP
	page

StepDown:
	cmp	[bx],ax 		;Test var against limit
	jge	NextCont		;Take another lap
	jmp	short ExitLoop		;Skip operand and continue

MakeExe exStNextStepI2,opStNext
	SkipExHeader
MakeExe exStNextIdStepI2,opStNextId
	LODSWTX 			;Pick up oBp of parameters
	GetpFrame
	mov	cx,[pFrame] 		;Pick up step
	mov	ax,[pFrame+2]		;Pick up Limit
	pop	bx			;Var ref
	add	[bx],cx 		;Add step to variable
NextI2OverflowErrJ:
	jo	NextI2OverflowErr	;Error - overflow
StNextStepForI2:			;FOR continuation
	or	cx,cx			;Test sign of step
	js	StepDown		;Negative step
	cmp	[bx],ax 		;Test var against limit
	jg	ExitLoop		;Loop end conditions met
	mov	si,PTRTX[si]		;Branch to beyond FOR
	DispMac 			;And on with the show

	subttl	Next I4 Variants
	page

MakeExe exStNextStepI4,opStNext
	SkipExHeader			;Extra op for listability
MakeExe exStNextIdStepI4,opStNextId
	LODSWTX 			;Pick up oBp of parameters
	GetpFrame
	mov	cx,[pFrame]
	mov	dx,[pFrame+2]		;dx/ax = step
	xchg	ax,FrameReg		;ax = FOR block address
	pop	bx			;Var ref

;Add in step - error if overflow.
	add	cx,[bx] 		;Add in low word of value
	adc	dx,[bx+2]		;Add in high word of value + PSW.C
	jo	NextI2OverflowErrJ	;Error if overflow

	;Entry for FOR code.
	;dx/cx = index value
	;ds:bx = pVar
	;ax    = pFOR block
StNextForI4:

	;Perform assignment to variable

	mov	[bx+2],dx
	mov	[bx],cx 		;Assignment complete

;Compare var to limit.
	push	dx
	push	cx			;Push current value
	xchg	FrameReg,ax		;Restore FOR block address
	push	[pFrame+6]
	push	[pFrame+4]		;Push limit
	call	B$CMI4			; Compare two I4s on the stack
	    lahf			;Put flags in AH

	test	byte ptr [pFrame+3],80H	;Test sign of step
	jnz	NextNegStepI4		;Negative step
	sahf
	ja	NextLeave		;Leave loop if index > limit
	jmp	short NextContI4R4R8	;Exit through shared code

NextNegStepI4:				
	sahf				
	jb	NextLeave		;Leave loop if index < limit
	jmp	short NextContI4R4R8	


subttl	NEXT R4 Variants
page
;There are no nonSTEP versions of R4 NEXT as FOR simply supplies the STEP
; when the user doesn't.

MakeExe exStNextStepR4,opStNext
	SkipExHeader
MakeExe exStNextIdStepR4,opStNextId
	LODSWTX 			;Pick up oBp of parameters
	GetpFrame
	pop	ax			;Address of variable

;Need to:
; 1. add STEP to the variable whose address is in ax
; 2. compare LIMIT to variable whose value is on the stack.
; 3. compare sign of step with this previous compare to get the
;    final disposition.

;Add STEP.
;   The mathpack entry point does not modify the variable in the case
;   that an error (such as overflow or underflow) is detected.
;   ax     = index variable address
;   pFrame = FOR block address

	fld	dword ptr [pFrame]	;Load the step
	xchg	ax,bx			;bx points to variable
	fadd	dword ptr [bx]		;Add variable to step

DbPub StForNextR4
StForNextR4:				;Entry from R4 FOR executors

;Compare index variable with limit
;   bx = index variable address
;   ax or pFrame = FOR block address

	fst	dword ptr [bx]		; and store in variable
	xchg	ax,FrameReg
	fld	dword ptr [pFrame+4]	;Load the limit
	fcompp				;Compare to the variable
	fstsw	DGROUP:stat		;fstsw	ax is 80287 only
	fwait
	mov	ax,DGROUP:stat 		;Put status word in ax
	.errnz	LOW MATH_R4SignMask
	test	byte ptr[pFrame+3],HIGH MATH_R4SignMask	;Test for Sign of step

NextComR4R8X:
	jnz	NextNegStep		;Negative step
	sahf
	jb	NextLeave		;Leave loop if si > di
NextContI4R4R8:
	mov	si,PTRTX[si]		;Continue loop
	DispMac

NextLeave:
	inc	si		;Skip oTxt field
	inc	si
	DispMac 		; and continue

NextNegStep:
	sahf
	ja	NextLeave	;Leave loop
	jmp	short NextContI4R4R8

sEnd	CODE
sBegin	DATA
	public	Stat
Stat	dw	(?)
sEnd	DATA
sBegin	CODE

subttl	EXIT FOR
page
;exStExitFor and exStExitDo are simply a GOTO at execution time.

MakeExe exStExitDo,opStExitDo
	SkipExHeader
MakeExe exStExitFor,opStExitFor
	jmp	short NextContI4R4R8	;Branch to the exit point
					; like a NEXT loop continuation

subttl	NEXT R8 Variants
page
;There are no nonSTEP versions of R8 NEXT as FOR simply supplies the STEP
; when the user doesn't.

MakeExe exStNextStepR8,opStNext
	SkipExHeader
MakeExe exStNextIdStepR8,opStNextId
	LODSWTX 			;Pick up oBp of parameters
	GetpFrame
	pop	ax			;Address of variable

;Need to:
; 1. add STEP to the variable whose address is in ax.
; 2. compare LIMIT to variable whose value is on the stack.
; 3. compare sign of step with this previous compare to get the
;    final disposition.

;Add STEP.
;   The mathpack entry point does not modify the variable in the case
;   that an error (such as overflow or underflow) is detected.
;
;   ax     = index variable address
;   pFrame = FOR block address

	fld	qword ptr [pFrame]	;Load the step
	xchg	ax,bx			;bx points to variable
	fadd	qword ptr [bx]		;Add variable to step

StForNextR8:				;Entry from R8 FOR executors
;Compare index variable with limit
;   bx = index variable address
;   ax or pFrame = FOR block address

	fst	qword ptr [bx]		;Store in variable
	xchg	ax,FrameReg
	fld	qword ptr [pFrame+8]	;Load the limit
	fcompp				;Compare to the variable
	fstsw	stat			;fstsw	ax is 80287 only
	fwait
	mov	ax,stat 		;Put status word in ax
.errnz	LOW MATH_R8SignMask
	test	byte ptr[pFrame+7],HIGH MATH_R8SignMask ;Test for Sign of step check
	jmp	NextComR4R8X

subttl	NEXT CY Variants
page

;There are no nonSTEP versions of CY NEXT as FOR simply supplies the STEP
; when the user doesn't.


sEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exgraph.asm ===
page	49,132
	TITLE	exgraph.asm - graphics function and statement executors
;***
;exgraph.asm - graphics function and statement executors for QBI
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXGRAPH_ASM = ON
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	context
	IncludeOnce	architec
	IncludeOnce	extort
	IncludeOnce	rttemp
	IncludeOnce	array
	.list

assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	staticW	fGetPutPalette,-1
sEnd	DATA

sBegin	CODE
assumes cs, CODE

;==============================================================================
;		Intrinsic Graphics Function Executors
;==============================================================================
MakeExe exFnPmap,opFnPmap		;(R4, I2)
;Added with [3]
	pop	ax			;Clear I2 off stack
	sub	sp,4			;Make room for R4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	push	ax			;I2 follows it
	fwait
;End of [3]
	CALLRT	B$PMAP,DispR4

MakeExe exFnPoint1,opFnPoint1
	CALLRT	B$PNT1,DispR4

MakeExe exFnPoint2I2,opFnPoint2
	CallRt	B$PNI2,DispAx

MakeExe exFnPoint2R4,opFnPoint2		
;Added with [3]
	sub	sp,8			;Make room for two R4s
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fstp	dword ptr DGROUP:[bx+4]
	fwait
;End of [3]
	CallRt	B$PNR4,DispAx

;==============================================================================
;		Graphics Statement Executors
;==============================================================================
MakeExe exCoordI2,opCoord
	CALLRT	B$N1I2,Disp

MakeExe exCoordStepI2,opCoordStep
	CALLRT	B$S1I2,Disp

MakeExe exCoordSecondI2,opCoordSecond
	CALLRT	B$N2I2,Disp

MakeExe exCoordStepSecondI2,opCoordStepSecond
	CALLRT	B$S2I2,Disp

MakeExe exCoordR4,opCoord
;Added with [3]
	sub	sp,8			;Make room for two R4s
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fstp	dword ptr DGROUP:[bx+4]
	fwait
;End of [3]
	CALLRT	B$N1R4,Disp

MakeExe exCoordStepR4,opCoordStep
;Added with [3]
	sub	sp,8			;Make room for two R4s
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fstp	dword ptr DGROUP:[bx+4]
	fwait
;End of [3]
	CALLRT	B$S1R4,Disp

MakeExe exCoordSecondR4,opCoordSecond
;Added with [3]
	sub	sp,8			;Make room for two R4s
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fstp	dword ptr DGROUP:[bx+4]
	fwait
;End of [3]
	CALLRT	B$N2R4,Disp

MakeExe exCoordStepSecondR4,opCoordStepSecond
;Added with [3]
	sub	sp,8			;Make room for two R4s
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fstp	dword ptr DGROUP:[bx+4]
	fwait
;End of [3]
	CALLRT	B$S2R4,Disp


MakeExe exCircleStart,opCircleStart
;Added with [3]
	sub	sp,4			;Make room for R4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fwait
;End of [3]
	CALLRT	B$CSTT,Disp

MakeExe exCircleEnd,opCircleEnd
;Added with [3]
	sub	sp,4			;Make room for R4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fwait
;End of [3]
	CALLRT	B$CSTO,Disp

MakeExe exCircleAspect,opCircleAspect
;Added with [3]
	sub	sp,4			;Make room for R4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	fwait
;End of [3]
	CALLRT	B$CASP,Disp

MakeExe exStCircle,opStCircle
	PUSHI	ax,-1			;default color attribute
	SkipExHeader
MakeExe exStCircleColor,opStCircleColor
;Added with [3]
	pop	ax			;Clear I2 off stack
	sub	sp,4			;Make room for R4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Transfer R4 to local stack
	push	ax			;I2 follows it
	fwait
;End of [3]
	CALLRT	B$CIRC,Disp

MakeExe exStColor,opStColor
	LODSWTX 			;fetch count of parms already on stack
	push	ax
	CALLRT	B$COLR,Disp

MakeExe exStDraw,opStDraw
	CALLRT	B$DRAW,Disp

MakeExe exStGraphicsGet,opStGraphicsGet
PaletteUsing:
	inc	[fGetPutPalette]	;tell shared code this is a GET
	SkipExHeader
MakeExe exStGraphicsPut,opStGraphicsPut
	;This executes may be preceeded by either a exAdRf or an exAIdRf.
	;The exAdRf is used when cDims == 0 and the exAIdRf is used otherwise.

	cmp	byte ptr es:[si-6],0	; Is cDims == 0
	je	NoDims			; Brif yes

	;The preceeding executor was an exAIdRf which consumed the indices
	;and left the far pointer to the data on the stack.  We need to push
	;the pointer to the array descriptor.

	mov	bx,PTRTX[si-4]		; BX = oVar
	call	OVarToPAd		; BX = pAd
	push	bx			

GetPutUsingCom:
	mov	cx,-1
	xchg	cx,[fGetPutPalette]	;fetch flag, and reset to default
	jcxz	GraphicsGet		;brif we want to do a GET here

	inc	cx			;cx = 0 if doing a PUT
	jcxz	GraphicsPut

	CALLRT	B$PALU,DispMov 	;not GET or PUT, must be PALETTE USING

NoDims:
	;The preceeding executor was an exAdRf which left pAd on the stack.
	;We need to push the far address of the data and then the pAd.

	pop	bx			; BX = pAD
	push	[bx.AD_fhd.FHD_hData]	;Segment of first data item
        push    [bx.AD_fhd.FHD_oData]   ;Offset to first data item
        push    bx                      ;pAD
        jmp     short GetPutUsingCom    ;Back to common code

GraphicsPut:
	LODSWTX 			;fetch 'function' operand
	or	ah,ah
	jns	Not_Defaulted		;brif an action code was specified

	mov	ax,4			;'XOR', the default action code
Not_Defaulted:
	push	ax
	CALLRT	B$GPUT,DispMov

GraphicsGet:
	CALLRT	B$GGET,DispMov

MakeExe exStLineStyle,opStLineStyle
	pop	ax
	PUSHI	bx,-1			;default for the color parm
	jmp	short Line_Common	;push style parm back on and go

MakeExe exStLine,opStLine
	PUSHI	ax,-1			;default for first (color) parm
	SkipExHeader
MakeExe exStLineColor,opStLineColor
	mov	ax,-1			;default for second (style) parm
Line_Common:
	push	ax			;push second parm and go
	SkipExHeader
MakeExe exStLineStyleColor,opStLineStyleColor
	LODSWTX 			;fetch BorF parameter and push it
	push	ax
	CALLRT	B$LINE,Disp

MakeExe exStPaint2,opStPaint2
	CALLRT	B$PAIN,Disp

MakeExe exStPaint2Tile,opStPaint2
	PUSHI	ax,-1			;Push p to null descriptor
	SkipExHeader
MakeExe exStPaint3,opStPaint3
	CALLRT	B$PNTC,Disp

MakeExe exStPaletteUsing,opStPaletteUsing
	inc	[fGetPutPalette]	;tell shared code this is PALETTE USING
	jmp	PaletteUsing

MakeExe exStPalette0,opStPalette0
	CALLRT	B$PAL0,Disp

MakeExe exStPalette2,opStPalette2
	CALLRT	B$PAL2,Disp

MakeExe	exStPCopy,opStPCopy
	CALLRT	B$PCPY,Disp

MakeExe exStPreset,opStPreset
	CALLRT	B$PRST,Disp

MakeExe exStPresetColor,opStPresetColor
	SkipExHeader
MakeExe exStPsetColor,opStPsetColor
	CALLRT	B$PSTC,Disp

MakeExe exStPset,opStPset
	CALLRT	B$PSET,Disp

MakeExe exStView0,opStView0
	CALLRT	B$VEW0,Disp

MakeExe exStView,opStView
	xor	ax,ax			;set SCREEN flag to 0 (FALSE)
	SkipExHeader
MakeExe exStViewScreen,opStViewScreen	;NOTE: depending on ax != zero here ...
	DbAssertRel	ax,nz,0,CODE,<exStViewScreen: ax == 0 on entry>
View_Common:
	push	ax			;push flag stating whether SCREEN was
					;  given
	CALLRT	B$VIEW,Disp

MakeExe exStWindow0,opStWindow0
	CALLRT	B$WIN0,Disp

MakeExe exStWindow,opStWindow
	xor	ax,ax			;set SCREEN flag to 0 (FALSE)
	SkipExHeader
MakeExe exStWindowScreen,opStWindowScreen ;NOTE: depending on ax != zero here ..
	DbAssertRel	ax,nz,0,CODE,<exStWindowScreen: ax == 0 on entry>
Window_Common:
;Added with [3]
;Pop 4 R4s from 8087 stack onto 8086 stack
	sub	sp,16
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Top of 8087 stack to top of 8086 stack
	fstp	dword ptr DGROUP:[bx+4]
	fstp	dword ptr DGROUP:[bx+8]
	fstp	dword ptr DGROUP:[bx+12]
	fwait
;End of [3]
	push	ax			;push flag stating whether SCREEN was
					;  given
	CALLRT	B$WIND,Disp

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exprint.asm ===
page	49,132
	TITLE	exprint.asm - executors for [L]PRINT | WRITE [USING]
;***
;exprint.asm - executors for [L]PRINT | WRITE [USING]
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXPRINT_ASM = ON
	IncludeOnce	architec
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	context
	IncludeOnce	extort
	IncludeOnce	ui
	.list

assumes es, NOTHING
assumes ss, DATA

	EXTRN	B$IfScrnDev:FAR

sBegin	DATA
	globalB executorFlags,0		;flags that get reset whenever a runtime
					;  error occurs, i.e., flags whose
					;  meaning is only valid within a single
					;  statement
sEnd	DATA

	    externW b$nuldes


sBegin	CODE
assumes cs, CODE

;=============================================================================
;		PRINT-specific Statement Executors
;=============================================================================

;Most of the PRINT executors call the runtime via non-standard means. Since
;  All of these guys must set or reset the F_EXEC_ItemPrinted flag (so that 
;  exPrintEos will know whether it needs to perform special work for the case
;  of PRINT with no arguments), the below code is somewhat jumbled to share
;  this task.
;  Instead of using the CALLRT macro, each of these executors just puts the
;  postbyte for the associated runtime entry point into al. This value is
;  increased by one to match the table of actual executor addresses.
;  A special ExToRt variant is jumped to with the postbyte already set 
;  correctly in ax.
;  
;  NOTE: If any of these postbytes become greater that 254, the assembler will
;  NOTE: give an error; strive to keep these within a single byte.

MakeExe exPrintItemCommaI2,opPrintItemComma
	mov	al,PB$PCI2+1
	jmp	short Print_Disp
	
MakeExe exPrintItemCommaI4,opPrintItemComma
	mov	al,PB$PCI4+1
	jmp	short Print_Disp
	
MakeExe exPrintItemCommaR4,opPrintItemComma
	mov	al,PB$PCR4+1
	jmp	short PrintR4		
	
MakeExe exPrintItemCommaR8,opPrintItemComma
	mov	al,PB$PCR8+1
	jmp	short PrintR8		
	
	
MakeExe exPrintComma,opPrintComma
	PUSHI	ax,<dataOFFSET b$nuldes>
	SkipExHeader		;fall into exPrintItemCommaSD
MakeExe exPrintItemCommaSD,opPrintItemComma
	mov	al,PB$PCSD+1
	jmp	short Print_Disp
	

MakeExe exPrintItemSemiI2,opPrintItemSemi
	mov	al,PB$PSI2+1
	jmp	short Print_Disp
	
MakeExe exPrintItemSemiI4,opPrintItemSemi
	mov	al,PB$PSI4+1
	jmp	short Print_Disp
	
;Rewritten with [7]
MakeExe exPrintItemSemiR4,opPrintItemSemi
	mov	al,PB$PSR4+1
PrintR4:
	or	[executorFlags],F_EXEC_ItemPrinted
					;remember that we've printed something
PrintR4Eos:
	sub	sp,4			;Make room in stack
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]
	jmp	short PrintWait
	
MakeExe exPrintItemSemiR8,opPrintItemSemi
	mov	al,PB$PSR8+1
PrintR8:
	or	[executorFlags],F_EXEC_ItemPrinted
					;remember that we've printed something
PrintR8Eos:
	sub	sp,8			;Make room in stack
	mov	bx,sp
	fstp	qword ptr DGROUP:[bx]
PrintWait:
	fwait
	jmp	short Print_Disp2
;End of [7]


MakeExe exPrintSemi,opPrintSemi
	PUSHI	ax,<dataOFFSET b$nuldes>
	SkipExHeader		;fall into exPrintItemCommaSD
MakeExe exPrintItemSemiSD,opPrintItemSemi
	mov	al,PB$PSSD+1
	jmp	short Print_Disp
	

MakeExe exPrintItemEosI2,opPrintItemEos
	mov	al,PB$PEI2+1
PrintEos_Disp:
	and	[executorFlags],not F_EXEC_ItemPrinted
					;reset flag
	jmp	short Print_Disp2
;al = runtime index
Print_Disp:
	or	[executorFlags],F_EXEC_ItemPrinted
					;remember that we've printed something
Print_Disp2:
	test	[executorFlags],F_EXEC_Write
	jz	Print_Disp3		;brif not WRITE

	push	ax
	CALLRT	B$WRIT			;tell runtime this is WRITE, not PRINT
	pop	ax
	and	[executorFlags],not F_EXEC_Write
					;turn off Write flag
Print_Disp3:
	cmp	[fDebugScr],0
	jne	ShowOutputScr		;brif debug screen is visible

Print_Disp1:
	xor	ah,ah			;ax = runtime index
	jmp	ExToRtByteDisp

;Branched to when user is tracing through a PRINT stmt.
;native code can cause screen output, we need to swap to output screen
;just in case.
;
ShowOutputScr:
	push	ax			;preserve al = runtime index
	call	B$IfScrnDev		;see if current channel's output
					; will go to screen
	or	ax,ax
	je	NotScrnDev
	call	ShowOutScr
	DbAssertRelB [fDebugScr],e,0,CODE,<exprint: ShowOutScr failed>
NotScrnDev:
	pop	ax			;restore al = runtime index
	jmp	SHORT Print_Disp1

MakeExe exPrintItemEosI4,opPrintItemEos
	mov	al,PB$PEI4+1
	jmp	short PrintEos_Disp
	
MakeExe exPrintItemEosR4,opPrintItemEos
	mov	al,PB$PER4+1
	and	[executorFlags],not F_EXEC_ItemPrinted	;reset flag
	jmp	PrintR4Eos		


MakeExe exPrintItemEosR8,opPrintItemEos
	mov	al,PB$PER8+1
	and	[executorFlags],not F_EXEC_ItemPrinted	;reset flag
	jmp	PrintR8Eos		


Print_No_Arg:
	and	[executorFlags],NOT F_EXEC_Write
					;in case of WRITE [#n,]
	PUSHI	ax,<dataOFFSET b$nuldes>
	SkipExHeader		;fall into exPrintItemCommaSD
MakeExe exPrintItemEosSD,opPrintItemEos
	mov	al,PB$PESD+1
	jmp	PrintEos_Disp
	

MakeExe exPrintEos,opPrintEos
	test	[executorFlags],F_EXEC_ItemPrinted
	jz	Print_No_Arg

	mov	al,PB$PEOS+1
	jmp	PrintEos_Disp

MakeExe exPrintSpc,opPrintSpc
	or	[executorFlags],F_EXEC_ItemPrinted
					;remember that we've printed something
	CALLRT	B$FSPC,Disp
	
MakeExe exPrintTab,opPrintTab
	or	[executorFlags],F_EXEC_ItemPrinted
					;remember that we've printed something
	CALLRT	B$FTAB,Disp
	


MakeExe	exStLprint,opStLprint
	CALLRT	B$LPRT,Disp
	
MakeExe	exStWrite,opStWrite
	;must defer calling the runtime to handle this special case:
	;   WRITE [#n,]
	or	[executorFlags],F_EXEC_Write
	jmp	Disp
	
MakeExe	exUsing,opUsing
	CALLRT	B$USNG,Disp
	

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exio.asm ===
page	49,132
	TITLE	exio.asm - executors for IO-specific statements and functions
;***
;exio.asm - executors for IO-specific statements and functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXIO_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context 	
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	opcontrl
	IncludeOnce	extort
	IncludeOnce	rtps
	.list

assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	externW b$nuldes		;pointer to an SD for a NULL string
sEnd	DATA

sBegin	CODE
assumes cs, CODE

	page


;***
;I4toU2
;
;Purpose:
;
;   Given an I4 on the stack (before near return address), coerce it to
;   an equivalent U2, replacing the I4 with the U2.
;   Runtime error if overflow.
;
;Preserves:
;
;   bx
;
;****

	public	I4toU2
I4toU2	proc	near
	pop	cx			;near return address
	pop	ax
	pop	dx			;dx:ax is the I4
	push	ax			;assume success
	ror	dx,1			;put low bit of high word in PSW.C
	adc	dx,0			;set PSW.Z if PSW.C == sense of all bits
	jnz	@F			;brif overflow error
	jmp	cx			;return

@@:
	jmp	exMathErrOVF		;Declare overflow error
I4toU2	endp


;=============================================================================
;		IO-specific Instrinsic Function Executors
;=============================================================================


MakeExe exFnCsrlin,opFnCsrlin
	CALLRT	B$CSRL,DispAx

MakeExe exFnInkey_,opFnInkey_
	CALLRT	B$INKY,DispAx

MakeExe exFnIoctl_,opFnIoctl_
	CALLRT	B$FICT,DispAx

MakeExe exFnLpos,opFnLpos
	CALLRT	B$LPOS,DispAx

MakeExe exFnPen,opFnPen
	CALLRT	B$FPEN,DispAx

MakeExe exFnPos,opFnPos
	CALLRT	B$FPOS,DispAx

MakeExe exFnScreen2,opFnScreen2
	xor	ax,ax			;pass 0 for defaulted third parameter
	push	ax
	SkipExHeader
MakeExe exFnScreen3,opFnScreen3
	CALLRT	B$FSCN,DispAx

MakeExe exFnStick,opFnStick
	CALLRT	B$STIK,DispAx

MakeExe exFnStrig,opFnStrig
	CALLRT	B$FSTG,DispAx

MakeExe exFnInp,opFnInp	
	call	I4toU2			;coerce I4 port address to U2
	CALLRT	B$PINP,DispAx

MakeExe exFnEof,opFnEof
	CALLRT	B$FEOF,DispAx

MakeExe exFnFileAttr,opFnFileAttr
	CALLRT	B$FATR,DispDxAx

MakeExe exFnFreefile,opFnFreefile
	CALLRT	B$FREF,DispAx

MakeExe exFnInput_1,opFnInput_1
	xor	ax,ax
	push	ax			;default if no channel number specified
	SkipExHeader
MakeExe exFnInput_2,opFnInput_2
	CALLRT	B$FINP,DispMovSd	

MakeExe exFnLoc,opFnLoc
	CALLRT	B$FLOC,DispDxAx

MakeExe exFnLof,opFnLof
	CALLRT	B$FLOF,DispDxAx

MakeExe	exFnSeek,opFnSeek
	CALLRT B$FSEK,DispDxAx        ;Return I4 file position on stack

;=============================================================================
;		IO-specific Statement Executors
;=============================================================================

MakeExe exStBload1,opStBload1
	xor	ax,ax
	push	ax			;garbage here, but ax = 0 used below
	jmp	short Bload_Common

MakeExe exStBload2,opStBload2
	call	I4toU2			;coerce I4 on stack to a U2
	mov	al,1			;flag - - 2nd parm specified
Bload_Common:
	push	ax			;flag: 0 == 2nd parm defaulted
	CALLRT	B$BLOD,DispMov

MakeExe exStBsave,opStBsave
	call	I4toU2			;coerce length to U2
	pop	bx			;save U2 length in bx
	call	I4toU2			;coerce offset to U2
	push	bx			;put length back on (bx was preserved)
	CALLRT	B$BSAV,DispMov

MakeExe exStCls,opStCls
	CALLRT	B$SCLS,Disp

MakeExe exFieldInit,opFieldInit
	CALLRT	B$FLDP,DispMov

MakeExe exFieldItem,opFieldItem
	CALLRT	B$FIEL,DispMov		;call RT for single FIELD parm pair

MakeExe exStIoctl,opStIoctl
	CALLRT	B$SICT,Disp

MakeExe exStKey,opStKey
	LODSWTX 			;ax = constant for ON, OFF, or LIST
	push	ax
	CALLRT	B$KFUN,Disp

MakeExe exStKeyMap,opStKeyMap
	CALLRT	B$KMAP,Disp

MakeExe exStLocate,opStLocate
	LODSWTX 			;ax = count of parms on stack
	push	ax
	CALLRT	B$LOCT,Disp

MakeExe exStScreen,opStScreen
	LODSWTX 			;ax = count of parms on stack
	push	ax
	CALLRT	B$CSCN,Disp

MakeExe exStViewPrint0,opStViewPrint0
	mov	ax,-1			;pass -1 for two defaulted parameters
	push	ax
	push	ax
	SkipExHeader
MakeExe exStViewPrint2,opStViewPrint2
	CALLRT	B$VWPT,Disp

MakeExe exStWidthLprint,opStWidthLprint
	CALLRT	B$LWID,Disp


MakeExe exStClose,opStClose
	LODSWTX 			;get count of parms
	push	ax
	CALLRT	B$CLOS,DispMov

MakeExe exStGet1,opStGet1
	CALLRT	B$GET1,Disp

MakeExe exStGet2,opStGet2
	CALLRT	B$GET2,DispMov

MakeExe exStGetRec2,opStGetRec2
	LODSWTX 			;get size parm
	cmp	ax,-1			;FS?
	jz	NoCbG2
	push	ax
NoCbG2:
	CALLRT	B$GET3,DispMov

MakeExe exStGetRec3,opStGetRec3
	LODSWTX 			;get size parm
	cmp	ax,-1			;FS?
	jz	NoCbG3
	push	ax
NoCbG3:
	CALLRT	B$GET4,DispMov

MakeExe exStPut1,opStPut1
	CALLRT	B$PUT1,Disp

MakeExe exStPut2,opStPut2
	CALLRT	B$PUT2,Disp

MakeExe exStPutRec2,opStPutRec2
	LODSWTX 			;get size parm
	cmp	ax,-1			;FS?
	jz	NoCbP2
	push	ax
NoCbP2:
	CALLRT	B$PUT3,DispMov

MakeExe exStPutRec3,opStPutRec3
	LODSWTX 			;get size parm
	cmp	ax,-1			;FS?
	jz	NoCbP3
	push	ax
NoCbP3:
	CALLRT	B$PUT4,DispMov

MakeExe exInputEos,opInputEos
	CALLRT	B$PEOS,Disp

MakeExe exInputChan,opInputChan
	CALLRT	B$DSKI,Disp

MakeExe exInputPrompt,opInputPrompt
	test	BYTE PTR es:[si+2],FINP_Prompt
	jnz	Got_Prompt		;brif user specified a prompt string

	PUSHI	ax,<dataOFFSET b$nuldes> ;push pointer to null SD
Got_Prompt:
	push	es
	push	si			;far pointer to input preamble block
	LODSWTX
	inc	ax			;round cbBlock up, because the parser
	and	al,0FEh 		;  never emits odd-size pcodes
	add	si,ax			;move txtptr to next pcode
	CALLRT	B$INPP,DispMov

MakeExe exStReadI2Near,opStRead
	SkipExHeader
MakeExe exStInputI2Near,opStInput
	pop	ax			;convert near pointer to far pointer
	push	ds
	push	ax
	SkipExHeader
MakeExe exStReadI2,opStRead
	SkipExHeader
MakeExe exStInputI2,opStInput
	CALLRT	B$RDI2,Disp

MakeExe exStReadI4Near,opStRead
	SkipExHeader
MakeExe exStInputI4Near,opStInput
	pop	ax			;convert near pointer to far pointer
	push	ds
	push	ax
	SkipExHeader
MakeExe exStReadI4,opStRead
	SkipExHeader
MakeExe exStInputI4,opStInput
	CALLRT	B$RDI4,Disp


MakeExe exStReadR4Near,opStRead
	SkipExHeader
MakeExe exStInputR4Near,opStInput
	pop	ax			;convert near pointer to far pointer
	push	ds
	push	ax
	SkipExHeader
MakeExe exStReadR4,opStRead
	SkipExHeader
MakeExe exStInputR4,opStInput
	CALLRT	B$RDR4,Disp


MakeExe exStReadR8Near,opStRead
	SkipExHeader
MakeExe exStInputR8Near,opStInput
	pop	ax			;convert near pointer to far pointer
	push	ds
	push	ax
	SkipExHeader
MakeExe exStReadR8,opStRead
	SkipExHeader
MakeExe exStInputR8,opStInput
	CALLRT	B$RDR8,Disp


MakeExe exStReadSD,opStRead
	SkipExHeader
MakeExe exStInputSD,opStInput
	pop	ax			;convert near pointer (psd) to far ptr
	push	ds
	push	ax
	xor	ax,ax
	push	ax			;note this is for an SD, not an FS
	SkipExHeader
MakeExe exStReadFS,opStRead
	SkipExHeader
MakeExe exStInputFS,opStInput
	CALLRT	B$RDSD,Disp

MakeExe exStLineInput,opStLineInput
	xor	bx,bx			;note this is for an SD, not an FS
	pop	cx			;pSD
	mov	dx,ds			;Segment of SD to dx
	jmp	short LineInput		

MakeExe exStLineInputFS,opStLineInput
	pop	bx			;cbFS
	pop	cx			;Offset of FS
	pop	dx			;Segment of FS
LineInput:				
	LODSWTX 			;fetch fPromptWord
	test	al,FINP_Prompt		;see if SDPrompt is present on stack
	jnz	Prompt_Present		;  brif it is

	PUSHI	di,<dataOFFSET b$nuldes> ;push pointer to null SD
Prompt_Present:
	push	dx			;Segment
	push	cx			;offset part of far pSd/pFS
	push	bx			;cbFS or 0
	push	ax			;pass fPromptWord as final parameter
	CALLRT	B$LNIN,DispMov		;No movement, but restore DI

MakeExe exStLock,opStLock
	SkipExHeader			;the mode parm differentiates these
MakeExe exStUnLock,opStUnLock
.errnz	LOCK_Def1stArg	-  4000H
.errnz	LOCK_DefLastArg -  8000H

	LODSWTX 			;get mode word, and advance si
	test	al,LOCK_1stToLast	;see if user said 'All records'
	jz	PushRecParms		;  brif so; push garbage record numbers

	test	ah,040H 		;Is "TO" present?
	jnz	Parms_OK		;Both on stack - no more work to do
	test	ah,080H 		;Is "from" the only arg present?
	jz	Parms_OK		;"TO" present only - args both provided
					; by the parser

					;Here if only "from" is present
					; so, duplicate the arg
	pop	bx			;Duplicate the arg on the stack
	pop	cx			
PushRecParms:
	push	cx			;push first I4 record parm
	push	bx
	push	cx			;push second I4 record parm
	push	bx
Parms_OK:
	push	ax			;push mode word
	CALLRT	B$LOCK,Disp		;lock/unlock approriate records

MakeExe exStOpen2,opStOpen2
	PUSHI	ax,-1			;default record length
	SkipExHeader
MakeExe exStOpen3,opStOpen3
	LODSWTX 			;get mode word, and advance si
	push	ax			;push mode parameter
	CALLRT	B$OPEN,DispMov

MakeExe exStOpenOld3,opStOpenOld3
	PUSHI	ax,-1			;default record length
	SkipExHeader
MakeExe exStOpenOld4,opStOpenOld4
	CALLRT	B$OOPN,DispMov

MakeExe exStReset,opStReset
	CALLRT	B$REST,Disp

MakeExe exStSeek,opStSeek
	CALLRT	B$SSEK,Disp		;Return I4 file position on stack


MakeExe exStOut,opStOut
	pop	bx			;data to output
	call	I4toU2			;coerce I4 port address to U2 on stack
	push	bx
	CALLRT	B$POUT,Disp

MakeExe exStWait2,opStWait2
	xor	bl,bl			;make the xor-expression a nop
	jmp	short StWait_Common
MakeExe exStWait3,opStWait3
	pop	bx			;fetch xor-expression
StWait_Common:
	pop	di			;fetch and-expression
	call	I4toU2			;coerce I4 port address to U2 (on stack)
	push	di			;and-expression
	push	bx			;xor-expression
	CALLRT	B$WAIT,DispMov		;NOTE: only using 'Mov' varient because
					;NOTE: we used DI above


MakeExe exStWidth2I2,opStWidth2 	;WIDTH n,m
	CALLRT	B$WIDT,Disp


MakeExe exStWidth2SD,opStWidth2 	;WIDTH "def:",m
	CALLRT	B$DWID,Disp


MakeExe exStWidthfile,opStWidthfile	;WIDTH #n,m
	CALLRT	B$FWID,Disp

MakeExe exChanOut,opChanOut
	CALLRT	B$CHOU,Disp

MakeExe exNop,opNop
	SkipExHeader
MakeExe exLbs,opLbs
	SkipExHeader
MakeExe exStLet,opStLet
Disp1:
	DispMac 		;speed critical - - dispatch directly here

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exmisc.asm ===
page	49,132
	TITLE	EXMISC - Miscellaneous Executors
;***
;exmisc.asm - executors for simple id references.
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains:
;	- all BOS executor varients.
;	- nonspeed-critical NOP executors.  They are kept in one
;	  place for size reduction.
;	- WATCH statement executors.
;
;   This module also contains the following debugging aids:
;	- Dispatch - nonRELEASE versions jmp to a single dispatch entrypoint
;	  in this module for easier debugging.
;
;
;****************************************************************************

	.xlist

	NOTEXT = 1
	NORASTOPS = 1
	NOMB = 1
	NOWM = 1
	NOMST = 1
	include 	windows.inc

	include 	version.inc
EXMISC_ASM = ON
	IncludeOnce	architec
	IncludeOnce	conint
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	heap
	IncludeOnce	opmin
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	opcontrl
	IncludeOnce	opid
	IncludeOnce	opaftqb4
	IncludeOnce	pcode
	IncludeOnce	ui
	IncludeOnce	variable
	.list

assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	staticW tempWord,0		;temp storage for a word value
sEnd	DATA

	externFP B$EVCK
	externFP B$Break
	externFP B$StackReset
	externFP B$ClearRange

sBegin	CODE
assumes cs, CODE


;-----------------------------------------------------------------------------
; Dispatch - non-RELEASE versions dispatch each pcode from here
;-----------------------------------------------------------------------------
Public	Dispatch
Dispatch:
	mov	cx,es		; for later verification
	SETSEG_EQ_SS es 	; in case fDirect is TRUE
	lea	bx,[grs.GRS_bdlDirect_seg]
	cmp	[grs.GRS_fDirect],FALSE
	jnz	Dispatch_Cont	;brif active text table is bdlDirect


	GETRS_SEG es,bx,<SIZE,LOAD>  ;[14]
	mov	bx,[grs.GRS_offsetTxdSeg]	
	RS_BASE add,bx		; bx points to appropriate Rs
Dispatch_Cont:
	cmp	si,PTRRS[bx.BDL_cbLogical - BDL_seg]	  ;[14]
	jae	SI_Error

	GETSEG	ax,PTRRS[bx],,<SIZE,LOAD> ;[14][9] ax == segment address for current seg
	cmp	ax,cx		
	jnz	ES_Error	;brif ES incorrect
ES_Okay:			
	xchg	ax,cx		; ensure cx has correct seg address
	mov	bx,[grs.GRS_pMrsCur]
	mov	ax,PTRRS[bx.MRS_bdVar.BD_pb]	
	add	ax,VAR_value
	cmp	di,ax
	jz	DispEx_Cont	; brif di is okay

DI_Error:
	DbHalt	CODE,<DI Error in exmisc.asm at Dispatch>
DispEx_Cont:			
	DbChk	Heaps		;Check the heap if -tglCheckHeaps set
	mov	es,cx		; restore pcode segment
	LODSWTX 		;Pick up an executor
Public	DispEx
DispEx:				;useful public for debugging
	jmp	ax		;And dispatch

ES_Error:
	DbHalt	CODE,<ES Error in exmisc.asm at Dispatch>
SI_Error:
	DbHalt	CODE,<Error in exmisc.asm at Dispatch: si past end of text tbl>


subttl	Begin of Statement Handling
page

;Table of exception handlers
ExDispTbl LABEL WORD
	DW	codeOFFSET DoFBosResetStk
	DW	codeOFFSET DoFBosEvent
	DW	codeOFFSET DoFBosStop
	DW	codeOFFSET DoFBosDebug
;ExDispTbl assumes following mask values:
	.errnz	FBOSRESETSTK - 01h		
	.errnz	FBOSEVENT    - 02h		
	.errnz	FBOSSTOP     - 04h		
	.errnz	FBOSDEBUG    - 08h		

;***
;B$IEvSet - set the FBOSEVENT bit in BosFlags
;
; NOTE: This routine will be called with interrupts disabled.
;
;Input:
;	none.
;Output:
;	The FBOSEVENT bit is set in BosFlags
;Preserves:
;	ALL but flags
;*******************************************************************************
cProc	B$IEvSet,<PUBLIC,FAR,NODATA>
cBegin
	.errnz	HIGH FBOSEVENT		      ;assuming FBOSEVENT in low byte of word
	or	BYTE PTR [BosFlags],FBOSEVENT ; set the bit
cEnd

;***
;B$IEvReset - reset the FBOSEVENT bit in BosFlags
;
; NOTE: This routine will be called with interrupts disabled.
;
;Input:
;	none.
;Output:
;	The FBOSEVENT bit is reset in BosFlags
;Preserves:
;	ALL but flags
;*******************************************************************************
cProc	B$IEvReset,<PUBLIC,FAR,NODATA>
cBegin
	and	[BosFlags],NOT FBOSEVENT
cEnd


;*******************************************************************************
;DoFBosStop - handle BOS flag FBOSSTOP
;Purpose:
;	This routine is invoked the runtime calls us back to inform us that
;	the user hit Ctl-Break.
;
;	This routine does not return - - execution is halted, control is
;	returned to Direct Mode.
;
;Input:
;	ax contains the FBOSSTOP bit
;*******************************************************************************
DoFBosStop:
	pop	ax			;Throw away the return address
FBosStop_Event:				;(entry from DoFBosEvent if untrapped
					;  ctl-break detected)
	and	[BosFlags],NOT FBOSSTOP	;turn off bit
	jmp	B$Break 		;ends up jumping to exStStop

;***
;B$IBreak - call-back from runtime to cause us to STOP at next BOS/BOL
;
;Input:
;	none.
;Exit:
;	none.
;Preserves:
;	ALL but PSW
;
;***************************************************************************
cProc	B$IBreak,<PUBLIC,FAR,NODATA>
cBegin
	.errnz	HIGH FBOSSTOP		     ;assuming FBOSSTOP in low byte of word
	or	BYTE PTR [BosFlags],FBOSSTOP ; set the bit
cEnd


;*******************************************************************************
;DoFBosEvent - handle BOS flag FBOSEVENT
;Purpose:
;	This routine is invoked when an event has occured during the previous
;	statement (and the runtime set FBOSEVENT via B$IEVSet).
;
;	We push our current context on the stack, and call the runtime; the
;	runtime will in turn call back to QBI code if there's an event handler
;	in QBI text, or start a compiled-basic event handler, or just return
;	if there's no handler for the posted event. 
;	If there is a handler invoked, as long as it returns, we'll get control
;	back here, to take up execution where it was left off.
;
;	NOTE: the other Bos exception handlers turn off their own bit in 
;	NOTE: BosFlags. This had been done just prior to the call, but it's
;	NOTE: important that our code NEVER change the FBOSEVENT bit in
;	NOTE: BosFlags, or we introduce the possiblity of missing events.
;
;*******************************************************************************
DoFBosEvent:
	pop	dx			;Throw away the return address.
					;  Must not re-execute BOS code; to be
					;  compatable with BC3, must allow
					;  at least one statement to execute
					;  between event traps
	cmp	[grs.GRS_fDirect],FALSE	;Are we executing in Direct Mode?
	jnz	BosEvent_Exit		;  brif so - - - ignore events
					;    (note that ax, bx, cx are still
					;     set up from BOS exception loop)
	test	[grs.GRS_flags],FG_WatchActive
	jnz	BosEvent_Exit		;Ignore events while WATCH expression
					; is being evaluated.

	mov	[grs.GRS_oTxCur],si	;must do this for case where QBI event
					;  handler fires up - - - IT preserves
					;  oTxCur and oRsCur in event frame
	mov	[fNonQBI_Active],bp	;in case non-QBI code is envoked
	push	[b$curlevel]
	pop	[bcurlevel_QBI]		;in case we must later restore 
					;  b$curlevel to what it is now
	push	[BosFlags]		;remember if FBOSDEBUG bit was on
	and	[BosFlags],NOT FBOSDEBUG ;don't allow user to trace into an
					 ;  event handler
	call	B$EVCK			;runtime invokes event handler if
					;  there is one.
					;B$EVCK returns:
					;	al = non-zero if an untrapped 
					;		ctl-break occured
	pop	bx			;old BosFlags
	and	bx,FBOSDEBUG
	or	[BosFlags],bx		;if FBOSDEBUG bit had been set prior to
					;  calling B$EVCK, turn it back on. If
					;  it was turned on in a QBI event 
					;  handler, leave it on

	mov	[fNonQBI_Active],0	;reset (QBI code is definitely active
					;  now)
	mov	si,[grs.GRS_oTxCur]	;in case a non-QBI event occured
	or	al,al
	jnz	FBosStop_Event		;brif untrapped ctl-break

	;go back to BOS Flag handling loop, but only if one or more flags
	;of lower priority (than the Event flag) are set. This ensures that 
	;we'll allow at least one statement to be executed between event 
	;handler invocations (which is compatable with the compiler design), 
	;and that we'll allow break-points to function correctly after an event 
	;handler returns
	mov	ax,FBOSEVENT
	.errnz	FBOSEVENT - 2		
	mov	bx,ax			;FBOSEVENT == 2^N, then bx must be 2*N
					;  here we're depending on the fact that
					;  for N = 1, 2^N == 2*N (N is the bit#)
	mov	cx,[BosFlags]
BosEvent_Exit:
	TESTX	cx,<NOT (FBOSEVENT OR (FBOSEVENT - 1))>
					;are any lower priority bits set?
	jnz	BosContLoop		;  brif so - handle other bit(s)

	jmp	DispMov			;  brif not - - - infinite loop would
					;	result if we went back to 
					;	BosContLoop without any other
					;	bits set

DbCheckBos	MACRO
	DispMac
	ENDM


;***
;exBreakPoint
;Purpose:
;	This pcode follows the opBol[Lab][Sp] opcode on any line which
;	has a breakpoint set.  It causes the executor to call UserInterface().
;Exit:
;	DEBUG_STOP flag is set in [debugFlags]
;
;******************************************************************************

;***
;BosException - Handle the beginning of statement flags

;Purpose:

;   Some executor has set a begin of statement flag.  This routine
;   handles the case that BosFlags have been set.  Flag specific
;   handlers may be invoked.
;
;   Some flags have no handlers.

;Entry:

;   si points beyond the bos/bol for current statement

;Exit:
;Modifies:
;*******************************************************************************

;***
;exBos,exBosSp,exBol,exBolSp,exBolLab,exBolLabSp,exBolInclude,exBolIncludeSp
;Pupose:
;	Handle begin of statement.
;	Each of these handlers performs any unique work (skipping operands, etc)
;	and Then checks end of statement flags.
;Inpup:
;Output:
;Modifies:
;******************************************************************************
;NOTE: Even though we could share code in following executors, we don't
;      for the sake of execution speed.
;

MakeBol	MACRO	cSpace
MakeExe	exBol&cSpace,opBol+cSpace*(OPCODE_MASK+1)
	endm

MakeBol	23
	SkipExHeader
MakeBol	22
	SkipExHeader
MakeBol	21
	SkipExHeader
MakeBol	20
	SkipExHeader
MakeBol	19
	SkipExHeader
MakeBol	18
	SkipExHeader
MakeBol	17
	SkipExHeader
MakeBol	24
	SkipExHeader
MakeBol	16
	cmp	BosFlags,0
	jnz	BosException1
	DbCheckBos

MakeBol	15
	SkipExHeader
MakeBol	14
	SkipExHeader
MakeBol	13
	SkipExHeader
MakeBol	12
	SkipExHeader
MakeBol	11
	SkipExHeader
MakeBol	10
	SkipExHeader
MakeBol	9
	SkipExHeader
MakeBol	8
	cmp	BosFlags,0
	jnz	BosException
	DbCheckBos

NotBosDebug:
	sub	bx,bx			;offset into table of exception handlers
	mov	ax, 1
BosExLoop:
	test	cx, ax
	jnz	GotExc
BosContLoop:				;possible reentry point from DoFBosEvent
	DbAssertRel ax,nz,0,CODE,<exmisc: ax = 0 in BosException handling loop>
	inc	bx			;advance to next exception handler
	inc	bx
	shl	ax,1			;check next bit from BosFlags
	jmp	BosExLoop

GotExc:
	call	ExDispTbl[bx]		; call handler if bit was set
	SkipExHeader			;fall into exBos
MakeExe exBos,opBos
	cmp	BosFlags,0
BosException1:				
	jnz	BosException
	DbCheckBos	

MakeExe exBolLab,opBolLab
	add	si,4			;skip operands
	cmp	BosFlags,0
	jnz	BosException
	DbCheckBos


MakeExe exBreakPoint,opBreakPoint
	or	[debugFlags],DEBUG_STOP ;tell UserInterface() we've hit a
	or	[BosFlags],FBOSDEBUG	; breakpoint
	;fall into BosException code
BosExcpt:
BosException:
	mov	cx,BosFlags		;Load flags
	DbAssertRel cx,b,FBOSDEBUG*2,CODE,<invalid BosFlags at BosException>
	cmp	cx,FBOSDEBUG
	DJMP	jne NotBosDebug
;Come here if FBOSDEBUG is only bit set at opBol
; Optimization for fast WatchPoints.
	cmp	[debugFlags],DEBUG_WATCH
NotBosDebugJne:
	DJMP	jne NotBosDebug		;brif need to do more than just Watch
	cmp	[fDebugScr],FALSE
	DJMP	jne NotBosDebug
	mov	[grs.GRS_otxCur],si
	call	DebugWatch
	mov	si,[grs.GRS_otxCur]	;get value as updated by DebugWatch
	RestorePcodeVar 		;es->cur txt tbl, di->cur var tbl
	DispMac 			;and resume execution


MakeExe exBolInclude,opBolInclude
	inc	si			;skip $INCLUDE nesting depth operand
	inc	si
	SkipExHeader			;this one need not be super fast
MakeBol	7
	SkipExHeader
MakeBol	6
	SkipExHeader
MakeBol	5
	SkipExHeader
MakeBol	4
	SkipExHeader
MakeBol	3
	SkipExHeader
MakeBol	2
	SkipExHeader
MakeBol	1
	SkipExHeader
MakeBol	0
	cmp	BosFlags,0
BosExcpt2:				
	jnz	BosExcpt
	DbCheckBos



MakeExe exBolIncludeSp,opBolIncludeSp
	inc	si			;skip $INCLUDE nesting depth operand
	inc	si
	SkipExHeader			;this one need not be super fast
MakeExe exBosSp,opBosSp
	SkipExHeader			;this one need not be super fast
MakeExe exBolSp,opBolSp
	inc	si			;skip operand
	inc	si
	cmp	BosFlags,0
	jnz	BosExcpt2		
	DbCheckBos

MakeExe exBolLabSp,opBolLabSp
	add	si,6			;skip operands
	cmp	BosFlags,0
BosExcpt1:
	jnz	BosExcpt2		
	DbCheckBos


;*******************************************************************************
;DoFBosDebug - handle BOS flag FBOSDEBUG
;Purpose:
;	This routine is invoked when a runtime error occurs in a module for
;	which there is no active error handler. [debugFlags] should already
;	be set up at this point, so we just have to transfer control to
;	UserInterface().
;	NOTE: since FBOSDEBUG is the last bit checked, we don't need to return
;	      to BosException
;
;Input:
;	ax contains the FBOSDEBUG bit
;
;*******************************************************************************
DoFBosDebug:
	xor	[BosFlags], ax		; turn off bit.
	pop	ax			; Throw away the return address.
	jmp	StopGrsContext		;save si in grs, call UserInterface()

;*******************************************************************************
;DoFBosResetStk - handle BOS flag FBOSRESETSTK
;Purpose:
;	This routine causes the stack pointers to be reset to their
;	[re]initialization values.
;
;Preserves:
;	si
;*******************************************************************************
DoFBosResetStk:
PUBLIC DoFBosResetStk			;called from exEndProg if bit is set
	pop	[tempWord]		;altering stack so save retval
	and	[BosFlags],NOT FBOSRESETSTK		
					; turn off bit. Can't expect ax set up
					;  as this is called from exEndProg too
	mov	ax,sp
	push	ax			;points to bottom of range that could
					;  have owners
	mov	bp,[b$mainframe]
	push	bp			;points to top of range that could have
					;  owners
	call	B$ClearRange		;release any owners found in given range
	test	[conFlags],F_CON_ResetStkSize
	jz	StackSize_Okay		;brif don't want to reset stack size

	and	[conFlags],NOT F_CON_ResetStkSize
	call	B$StackReset		;Reset the stack to initial location
	mov	[b$mainframe],sp
	mov	bp,sp
StackSize_Okay:
	mov	word ptr [bp],0		;reinitialize end of bp chain
	mov	word ptr [bp-2],0	
	mov	sp,bp

	mov	[b$curframe],bp

	GETRS_SEG es,bx,<SIZE,LOAD>	;[14] es == Rs table seg, trashes bx
	mov	bx,[grs.GRS_oMrsCur]	
	RS_BASE add,bx			
	mov	cx,PTRRS[bx.MRS_cbFrameTemp] 
	add	cx,PTRRS[bx.MRS_cbFrameVars] 
	sub	sp,cx			;make room for module level frame stuff
	DbAssertTst   sp,z,1,CODE,<DoFBosResetStk: SP contains an odd number>
	push	ss			
	pop	es
	mov	di,sp
	mov	al,0
	rep	stosb			;initialize module frame vars
	call	GetEsDi
	mov	[b$cNonQBIFrames],0	;reset count of non-QBI frames on stack
	jmp	[tempWord]		;stack reset - - return to BOS/BOL code

;***
;exLab,exLabSp,exInclude,ex_Static,ex_Dynamic,ex_Include,exReParse
;Purpose:
;	These executors have no work other than to skip their operands.
;Input:
;Output:
;Modifies:
;*******************************************************************************
MakeExe exLab,opLab
	add	si,4			;skip operands (link, oNam)
	DispMac

MakeExe exStDefType,opStDefType
	SkipExHeader			;skip operands (link,I4mask)
MakeExe exLabSp,opLabSp
	add	si,6			;skip operands (link, oNam, cSpaces)
	DispMac

MakeExe exReParse,opReParse
	DbHalt	CODE,<exReParse executed ...>

MakeExe ex_Static,op_Static
	SkipExHeader
MakeExe ex_Dynamic,op_Dynamic
	SkipExHeader
MakeExe ex_Include,op_Include
	SkipExHeader
MakeExe exStDeclare,opStDeclare
	SkipExHeader
MakeExe exStData,opStData
	SkipExHeader
MakeExe exStRem,opStRem
	SkipExHeader
MakeExe exQuoteRem,opQuoteRem
SkipNAtrs:				;this is pretty speed critical, due to
					;  the REM executors
	LODSWTX 			;fetch cntEos
	inc	ax			;cntEos could be odd - - round up if so
	and	ax,not 1
	add	si,ax			;skip to next pcode and dispatch
	DispMac

;***
;exShared, exStatic, exVtRfxx, exAsType<Fixed|Exp|>
;Purpose:
;	These are executors requiring absolutely no work, and are
;	not speed critical.
;Input:
;Output:
;Modifies:
;*************************************************************************

MakeExe exAsTypeFixed,opAsTypeFixed	
	inc	si			
	inc	si			
	SkipExHeader			
MakeExe exAsType,opAsType
	SkipExHeader
MakeExe exAsTypeExp,opAsTypeExp
	inc	si
	inc	si
	SkipExHeader
MakeExe exVtRfI4,opVtRf,ET_I4
	SkipExHeader
MakeExe exVtRfR4,opVtRf,ET_R4
	SkipExHeader
MakeExe exVtRfR8,opVtRf,ET_R8
	SkipExHeader
MakeExe exVtRfSD,opVtRf,ET_SD
	SkipExHeader
MakeExe exVtRfI2,opVtRf,ET_I2
	SkipExHeader
MakeExe exVtRfImp,opVtRf,ET_Imp
	inc	si			;skip operand
	inc	si
	SkipExHeader
MakeExe	exNoType,opNoType
	SkipExHeader
MakeExe	exStConst,opStConst
	SkipExHeader
MakeExe exShared,opShared
	SkipExHeader			
MakeExe exNop0,opNoList0		
	SkipExHeader			;Fall through to exLParen

;***
;exLParen - left paren executor
;Purpose:
;	exLParen is present for listability.  No execution time work is
;	performed.
;****
MakeExe exLParen,opLParen
	DispMac 			;speed critical - dispatch immediately

subttl	Executors for non-release code only
page

; exInvalid - Called only when an error occured in the scanner
;
;   Several of the executor maps in the scanner have slots needed for
; filler only.	If for some reason, one of these is referenced, the
; executor exInvalid will be written to the execute state code.
;

MakeExe exInvalid,opEot 	    ;[?] opcode is arbitrary
	DbHalt	CODE, <exInvalid has been encountered>

sEnd	CODE

sBegin	UI
assumes	CS,UI
;***
;B$EnsShowOutputScr - ensure the output screen is active
;Purpose:
;	Called from the runtime at the point where an event handler is
;	about to be invoked; this is to ensure that an event handler doesn't
;	end up printing output to our debug screen.
;****
extrn	EnsShowOutSaveRs:near
cProc	B$EnsShowOutputScr,<PUBLIC,FAR,NODATA>,<ES,BX>
cBegin
	cCall	EnsShowOutSaveRs
cEnd
sEnd	UI

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exrec.asm ===
page	49,132
	TITLE	ExRec - Executors for records
;***
;exrec.asm - executors for records
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains all exOff other record-related executors.
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXREC_ASM	= ON
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	pcode		
	IncludeOnce	scanner
	IncludeOnce	variable
	IncludeOnce	opid
	.list




GetElemOffset	MACRO
	xchg	ax,bx			;;BX = oElem
	mov	ax,[pVarBx].ELEM_oVar	;;AX = Offset of this element
	pop	bx			;;BX = Offset of record
	add	bx,ax			;;Add offset of this element
	ENDM





GetElemSeg  MACRO
	mov	dx,ds			;;Save DS in DX
	pop	ds			;;Segment of record
	ENDM






RestoreVarTable equ	<mov ds,dx>



assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA
sBegin	DATA				
sEnd	DATA				


sBegin	CODE

MakeExe exStEndType,opStEndType 	;Can't be executed
	DbHalt	CODE,<exStEndType>

MakeExe	exElemRef,opElemRef
	DbHalt	CODE,<exElemRef>

MakeExe	exStType,opStType
	LODSWTX				;Get offset of EndType
	inc	ax
	inc	ax			;Skip over EndType's link field
	xchg	si,ax			;Jump over type definition
	DispMac				;Dispatch to next executor

MakeExe exOffELdI2,opOffLd,ET_I2
	SkipExHeader
MakeExe exOffILdI2,opOffLd,ET_Imp
	LODSWTX 			;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
	push	[bx]			;Push integer onto stack
	RestoreVarTable 		;DS = psVarTable
	DispMac

MakeExe exOffELdI4,opOffLd,ET_I4
	SkipExHeader
MakeExe exOffILd4,opOffLd,ET_Imp
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
	push	[bx+2]			;Push High Word/SB
	push	[bx]			;Push Low Word/Handle
	RestoreVarTable 		;DS = psVarTable
	DispMac




	;Added with [11]


MakeExe exOffELdR4,opOffLd,ET_R4
	SkipExHeader
MakeExe exOffILdR4,opOffLd,ET_Imp
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
	fld	dword ptr [bx]
	RestoreVarTable 		;DS = psVarTable
	DispMac


MakeExe exOffELdR8,opOffLd,ET_R8
	SkipExHeader
MakeExe exOffILdR8,opOffLd,ET_Imp	
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
	fld	qword ptr [bx]
	RestoreVarTable 		;DS = psVarTable
	DispMac

	;End of [11]

MakeExe exOffERfR8,opOffLd,ET_R8
	SkipExHeader
MakeExe exOffERfI4,opOffLd,ET_I4
	SkipExHeader
MakeExe exOffERfR4,opOffLd,ET_R4
	SkipExHeader
MakeExe exOffERfI2,opOffLd,ET_I2
	SkipExHeader
MakeExe exOffIRf,opOffLd,ET_Imp
	LODSWTX				;Get oElem
	xchg	bx,ax
	pop	ax			;Get current offset
	add	ax,[pVarBx].ELEM_oVar	; Get offset of element
	push	ax
	DispMac

MakeExe exOffEStI2,opOffSt,ET_I2
	SkipExHeader
MakeExe exOffIStI2,opOffSt,ET_Imp
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
OffSt2: 				
	pop	[bx]			;Pop integer from stack
	RestoreVarTable 		;DS = psVarTable
	DispMac


MakeExe exOffEStI4,opOffSt,ET_I4
	SkipExHeader
MakeExe exOffISt4,opOffSt,ET_Imp
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
OffSt4: 				
	pop	[bx]
	pop	[bx+2]			;Pop 4-byte number from stack
	RestoreVarTable 		;DS = psVarTable
	DispMac




	;Added with [11]


MakeExe exOffEStR4,opOffSt,ET_R4
	SkipExHeader
MakeExe exOffIStR4,opOffSt,ET_Imp
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
OffStR4: 				
	fstp	dword ptr [bx]
	RestoreVarTable 		;DS = psVarTable
	fwait
	DispMac



MakeExe exOffEStR8,opOffSt,ET_R8
	SkipExHeader			;Fall through to next executor
MakeExe exOffIStR8,opOffSt,ET_Imp	
	LODSWTX				;Get oElem
	GetElemOffset			;BX = Offset of this element
	GetElemSeg			;DX = psVarTable ife FV_SBSWAP
OffStR8: 				
	fstp	qword ptr [bx]
	RestoreVarTable 		;DS = psVarTable
	fwait
	DispMac


	;End of [11]

MakeExe exOffIStTyp,opOffSt,ET_Imp
	LODSWTX				;Get oElem
	add	ax,di			
	xchg	bx,ax			;bx = pElem
	xchg	ax,di			;Save di
	pop	di			;Current offset
	add	di,[bx].ELEM_oVar	;Add offset of element
	mov	bx,[bx].ELEM_oTyp

	public	MoveRec
MoveRec:
	;ax = saved di
	;bx = oTyp of record
	;di = offset of destination
	;[sp] = segment of destination
	;[sp+4]:[sp+2] = pointer to source
	add	bx,ax			;oTyp --> pTyp
	mov	cx,[bx].TYP_cbData	;Get length of this element
	mov	dx,es			;Save ES
	mov	bx,si			;Save SI
	pop	es			;ES:DI points to destination
	pop	si
	pop	ds			;DS:SI points to source
	shr	cx,1			;Move by words
	rep	movsw
	adc	cx,cx			;CX = 1 iff CY set
	rep	movsb			;copy odd byte if struct size odd
	mov	si,bx			;Restore SI
	xchg	ax,di			;Restore DI
	push	ss
	pop	ds			;Restore DS
	mov	es,dx			;Restore ES
	DispMac

	;Strings


public	exOffIStSd,exOffEStSd
public	exOffIRfSd,exOffERfSd
public	exOffILdSd,exOffELdSd

;Never referenced if not FV_FARSTR, but must be defined
exOffIStSd	=	0
exOffEStSd	=	0
exOffIRfSd	=	0
exOffERfSd	=	0
exOffILdSd	=	0
exOffELdSd	=	0





MakeExe exOffERfFS,opOffLd,ET_SD
	SkipExHeader
MakeExe exOffIRfFS,opOffLd,ET_Imp
	LODSWTX				;Get oElem
	xchg	bx,ax			;pElem to bx
	pop	ax			
	add	ax,[pVarBx].ELEM_oVar	; [3] Add offset of element
	push	ax			; Far address to stack
	push	[pVarBx].ELEM_cbFixed	; Get length
	DispMac

MakeExe exOffELdFS,opOffLd,ET_SD
	SkipExHeader			;Fall through to next executor
MakeExe exOffILdFS,opOffLd,ET_Imp
	LODSWTX				;Get oElem
	xchg	bx,ax			;pElem to bx
	pop	ax			
	add	ax,[pVarBx].ELEM_oVar	; [3] Add offset of element
	push	ax			; Far address to stack
	push	[pVarBx].ELEM_cbFixed	; Get length
	CALLRT	B$LDFS,DispMovSd	

MakeExe exOffEStFS,opOffSt,ET_SD
	SkipExHeader
MakeExe exOffIStFS,opOffSt,ET_Imp
	LODSWTX 			;Get oElem
	xchg	bx,ax			;pElem to bx
	pop	ax			
	add	ax,[pVarBx].ELEM_oVar	; [3] Add offset of element
	push	ax			; Far address to stack
OffStFS:				
	push	[pVarBx].ELEM_cbFixed	; Get length
	CALLRT	B$LSET,Disp


sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exmathop.asm ===
page	49,132
	TITLE	exMathOp - I2 Math Operators
;***
;exmathop.asm - executors for math operators and functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module includes:
;	- the I2 calculator functions.
;	- interface to the mathpack for all mathpack resident functions.
;
;
;****************************************************************************

	.8087

	.xlist
	include 	version.inc
EXMATHOP_ASM = ON
	IncludeOnce	architec
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	opcontrl
	IncludeOnce	opintrsc
	IncludeOnce	opaftqb4
	IncludeOnce	rtinterp
	IncludeOnce	context
	IncludeOnce	qbimsgs
	IncludeOnce	extort
	IncludeOnce	ssint
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA



PREC53	MACRO				;NOOP if NOT FV_PREC53
	ENDM

PREC64	MACRO				;NOOP if NOT FV_PREC53
	ENDM



extrn	B$CMI4:far	
extrn	__aFlmul:far

sBegin	CODE
;===============================================================================
subttl	I2 Math Support
page
MakeExe exAddI2,opAdd
	pop	ax
	mov	bx,sp
	add	DGROUP:[bx],ax
	jo	MulI2OVF
	DispMac

MakeExe exSubI2,opSub
	pop	ax		;Right hand arg
	mov	bx,sp
	sub	DGROUP:[bx],ax
	jo	MulI2OVF
	DispMac

MakeExe exMulI2,opMul
	pop	cx
	pop	ax
	imul	cx
	jo	MulI2OVF
	push	ax
	DispMac
MulI2OVF:
FnAbsI2OVF:				
UMiI2OVF:				
	jmp	exMathErrOVF

MakeExe exIdvI2,opIdv
	pop	cx		;Right hand arg
	pop	ax		;Left hand arg
	cwd
	jcxz	IdvI2DV0
	idiv	cx
	push	ax
	DispMac
exMod0:
IdvI2DV0:
	jmp	exMathErrDV0

MakeExe exUMiI2,opUMi
	mov	bx,sp
	neg	word ptr DGROUP:[bx]
	jo	UMiI2OVF		
	DispMac

MakeExe exModI2,opMod
	pop	cx
	pop	ax
	cwd
	jcxz	exMod0
	idiv	cx
	push	dx
exModDisp:
	DispMac

MakeExe exModI4,opMod
	pop	ax
	pop	bx
	pop	cx
	pop	dx
	push	bx
	push	ax
	push	dx
	push	cx			;MS Math(?)
	CALLRT	B$RMI4,DispMovDxAx	;MOD function

MakeExe exIDvI4,opIDv
	pop	ax
	pop	bx
	pop	cx
	pop	dx
	push	bx
	push	ax
	push	dx
	push	cx			;MS Math(?)
	CALLRT	B$DVI4,DispMovDxAx

MakeExe exFnAbsI2,opFnAbs
	pop	ax
	cwd
	xor	ax,dx
	sub	ax,dx
	jo	FnAbsI2OVF		
	push	ax
	DispMac

MakeExe exStCaseEQI2,opStCaseEQ
	SkipExHeader
MakeExe exStCaseI2,opStCase
	SkipExHeader
MakeExe exEQI2,opEQ
	pop	ax
	pop	cx
	xor	bx,bx
	cmp	ax,cx
	jnz	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exStCaseNEI2,opStCaseNE
	SkipExHeader
MakeExe exNEI2,opNE
	pop	ax
	pop	cx
	xor	bx,bx
	cmp	ax,cx
	jz	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exStCaseLEI2,opStCaseLE
	SkipExHeader
MakeExe exLEI2,opLE
	pop	cx		;Right arg
	pop	ax		;Left arg
	xor	bx,bx
	cmp	ax,cx
	jg	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exStCaseGEI2,opStCaseGE
	SkipExHeader
MakeExe exGEI2,opGE
	pop	cx		;Right arg
	pop	ax		;Left arg
	xor	bx,bx
	cmp	ax,cx
	jl	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exStCaseGTI2,opStCaseGT
	SkipExHeader
MakeExe exGTI2,opGT
	pop	cx		;Right arg
	pop	ax		;Left arg
	xor	bx,bx
	cmp	ax,cx
	jle	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exStCaseLTI2,opStCaseLT
	SkipExHeader
MakeExe exLTI2,opLT
	pop	cx		;Right arg
	pop	ax		;Left arg
	xor	bx,bx
	cmp	ax,cx
	jge	@F
	dec	bx
@@:
	push	bx
	DispMac

MakeExe exNotI2,opNot
	mov	bx,sp
	not	word ptr DGROUP:[bx]
	DispMac

MakeExe exAndI2,opAnd
	pop	ax
	pop	cx
	and	ax,cx
	push	ax
	DispMac

MakeExe exOrI2,opOr
	pop	ax
	mov	bx,sp
	or	DGROUP:[bx],ax
	DispMac

MakeExe exXorI2,opXor
	pop	ax
	mov	bx,sp
	xor	DGROUP:[bx],ax
	DispMac

MakeExe exEqvI2,opEqv
	pop	ax		;Right operand
	pop	cx		;Left operand
	xor	ax,cx
	not	ax
	push	ax
	DispMac

MakeExe exImpI2,opImp
	pop	ax		;Right hand arg
	pop	cx		 ;Left hand arg
	not	cx
	or	ax,cx
	push	ax
	DispMac

MakeExe exFnIntInt,opFnInt		
	SkipExHeader
MakeExe exFnFixInt,opFnFix		
	DispMac

MakeExe exFnSgnI2,opFnSgn
	xor	ax,ax			;Assume 0
	pop	bx
	or	bx,bx
	jz	PushAxDisp
	js	SgnSgn
	inc	ax
	jmp	short PushAxDisp
SgnSgn:
	dec	ax
	jmp	short PushAxDisp

;===============================================================================
subttl	I4 Math Support
page
MakeExe exAddI4,opAdd
	pop	ax
	pop	dx
	mov	bx,sp
	add	DGROUP:[bx],ax
	adc	DGROUP:[bx+2],dx
	jo	SubI4OVF
	DispMac

MakeExe exSubI4,opSub
	pop	ax
	pop	dx
	mov	bx,sp
	sub	DGROUP:[bx],ax
	sbb	DGROUP:[bx+2],dx
	jo	SubI4OVF
	DispMac
SubI4OVF:
FnAbsI4OVF:				
UMiI4OVF:				
	jmp	exMathErrOVF

MakeExe exMulI4,opMul
	call	__aFlmul		;Perform the multiply
	jb	SubI4OVF		;Declare overflows
	push	dx
	push	ax
	DispMac

MakeExe exFnSgnI4,opFnSgn
	pop	ax
	pop	dx
	or	ax,dx			;Test for zero
	jz	PushAxDisp		;Result = 0
	shl	dx,1			;PSW.C
	sbb	ax,ax			;PSW.NZ indicates input was neg
	jnz	PushAxDisp		; so return -1
	inc	ax			;Must have been positive
	jmp	short PushAxDisp

MakeExe exFnAbsI4,opFnAbs
	pop	ax
	pop	dx
	or	dx,dx
	jns	PushDxAxDisp
	not	ax			
	not	dx			
	add	ax,1			
	adc	dx,0
	jo	FnAbsI4OVF		
PushDxAxDisp:
	push	dx
PushAxDisp:
	push	ax
	DispMac

MakeExe exNotI4,opNot
	mov	bx,sp
	not	word ptr DGROUP:[bx]
	not	word ptr DGROUP:[bx+2]
	DispMac

MakeExe exUMiI4,opUMi
	pop	ax
	pop	dx
	not	ax			
	not	dx			
	add	ax,1			
	adc	dx,0
	jo	UMiI4OVF		
	jmp	short PushDxAxDisp

MakeExe exAndI4,opAnd
	pop	ax
	pop	dx
	mov	bx,sp
	and	DGROUP:[bx],ax
	and	DGROUP:[bx+2],dx
	DispMac

MakeExe exOrI4,opOr
	pop	ax
	pop	dx
	mov	bx,sp
	or	DGROUP:[bx],ax
	or	DGROUP:[bx+2],dx
	DispMac

MakeExe exXorI4,opXor
	pop	ax
	pop	dx
	mov	bx,sp
	xor	DGROUP:[bx],ax
	xor	DGROUP:[bx+2],dx
	DispMac

MakeExe exEqvI4,opEqv
	pop	ax
	pop	dx
	pop	cx
	pop	bx
	xor	ax,cx
	not	ax
	xor	dx,bx
	not	dx
	jmp	short PushDxAxDisp

MakeExe exImpI4,opImp
	pop	ax
	pop	dx		;Right hand arg
	pop	cx
	pop	bx		;Left hand arg
	not	cx
	not	bx
	or	ax,cx
	or	dx,bx
	jmp	short PushDxAxDisp

;***
;CompareI4 - I4 signed comparison routine
;Purpose:
;	Signed compare of two I4 numbers.
;
;Inputs:
;	ParmD Left	left hand argument
;	ParmD Right	right hand argument
;
;Function:
;	Set Carry and Zero flags based on input arguments.
;	Left > Right	Zero clear and carry clear
;	Left < Right	Zero clear and carry set
;	Left = Right	Zero set
;
;	Note: These are the flag conventions used by
;	      unsigned jumps, NOT signed jumps.
;
;Outputs:
;	Zero and carry flags have result (set up for signed jmp)
;***************************************************************************
Public	CompareI4
CompareI4:
	pop	ax		;Near
	push	cs		; to far
	push	ax		;   return address
	jmp	B$CMI4		;Perform and return to caller

MakeExe exStCaseLTI4,opStCaseLT
	SkipExHeader
MakeExe exLTI4,opLT
	call	CompareI4
	jb	I4TrueDisp	
	jmp	short I4FalseDisp

MakeExe exStCaseLEI4,opStCaseLE
	SkipExHeader
MakeExe exLEI4,opLE
	call	CompareI4
	ja	I4FalseDisp	
	jmp	short I4TrueDisp

MakeExe exStCaseGEI4,opStCaseGE
	SkipExHeader
MakeExe exGEI4,opGE
	call	CompareI4
	jae	I4TrueDisp	
	jmp	short I4FalseDisp

MakeExe exStCaseGTI4,opStCaseGT
	SkipExHeader
MakeExe exGTI4,opGT
	call	CompareI4
	ja	I4TrueDisp	
	jmp	short I4FalseDisp

MakeExe exStCaseEQI4,opStCaseEQ
	SkipExHeader
MakeExe exStCaseI4,opStCase
	SkipExHeader
MakeExe exEQI4,opEQ
	call	CompareI4
	jz	I4TrueDisp
I4FalseDisp:
	PUSHI	AX,FALSE
	DispMac

MakeExe exStCaseNEI4,opStCaseNE
	SkipExHeader
MakeExe exNEI4,opNE
	call	CompareI4
	jz	I4FalseDisp
I4TrueDisp:
	PUSHI	AX,<NOT FALSE>
	DispMac

;===============================================================================

	subttl	R8 math Support
	page

MovAxDisp MACRO RtEnt
if LOW (P&RtEnt+1)
	mov	ax,P&RtEnt+1
else
	mov	ax,(HIGH P&RtEnt)+100h
endif
	ENDM

;Rewritten with [21]
MakeExe exAddR8,opAdd
	PREC53				
	fadd
	PREC64				
	DispMac

MakeExe exSubR8,opSub
	PREC53				
	fsub
	PREC64				
	DispMac

MakeExe exMulR8,opMul
	PREC53				
	fmul
	PREC64				
	DispMac

MakeExe exDivR8,opDiv
	PREC53				
	fdiv
	PREC64				
	DispMac

MakeExe exPwrR8,opPwr
	call	CheckCONST		;Declare error if in CONST
	fxch				;Reverse order for runtime
	MovAxDisp	B$POW8		;Runtime entrypoint
	jmp	short DispR8		;Go do rt call, and exit


	subttl	R8 Math Support - Single argument executors
	page

MakeExe exFnSin,opFnSin
	MovAxDisp	B$SIN8
DispR8:
	call	ExToRtCall		;Perform the function in ax
	DispMac

	;End of [21]
	

MakeExe exFnCos,opFnCos
	MovAxDisp	B$COS8
	jmp	DispR8


MakeExe exFnTan,opFnTan
	MovAxDisp	B$TAN8
	jmp	DispR8


MakeExe exFnAtn,opFnAtn
	MovAxDisp	B$ATN8
	jmp	DispR8


MakeExe exFnExp,opFnExp
	MovAxDisp	B$EXP8
	jmp	DispR8



MakeExe exFnSqr,opFnSqr
	PREC53				
	fsqrt				;Do the root
	PREC64				
	DispMac



MakeExe exFnLog,opFnLog
	MovAxDisp	B$LOG8
	jmp	DispR8


MakeExe exFnIntR8,opFnInt
	MovAxDisp	B$INT8
	jmp	DispR8


MakeExe exFnFixR8,opFnFix
	MovAxDisp	B$FIX8
	jmp	DispR8


	;Rewritten with [21]

MakeExe exUMiR8,opUMi
	fchs
	DispMac

MakeExe exFnAbsR8,opFnAbs
	fabs
	DispMac

MakeExe exFnSgnR8,opFnSgn
	fldz			;Put zero on stack
	fcompp			;Compare with zero and remove operands
	fstsw	[Stat]		;Save result of comparison
	fwait
	mov	ax,[Stat]
	sahf
;Unsigned flags now set like 0 - operand
	mov	ax,1
	jb	SgnDone		;If operand was +, return 1
	jz	DecOnce
	dec	ax
DecOnce:
	dec	ax
SgnDone:
	push	ax
	DispMac

	subttl	R8 Compare Routines
	page

	DbPub	CompareR8
CompareR8:
	fxch				;Compare in right order
	fcompp				;Compare to other arg on the stack
	fstsw	[Stat]
	fwait
	mov	ax,[Stat]		;Load 87 status to ax
	sahf
	ret

	;End of [21]

;EQ
MakeExe exStCaseEQR8,opStCaseEQ
	SkipExHeader
MakeExe exStCaseR8,opStCase
	SkipExHeader
MakeExe exEQR8,opEQ
	call	CompareR8
	mov	ax,0
	jnz	@F		;NE
	dec	ax
@@:
	push	ax
	DispMac

;NE
MakeExe exStCaseNER8,opStCaseNE
	SkipExHeader
MakeExe exNER8,opNE
	call	CompareR8
	mov	ax,0
	jz	@F		;EQ
	dec	ax
@@:
	push	ax
	DispMac

;GT
MakeExe exStCaseGTR8,opStCaseGT
	SkipExHeader
MakeExe exGTR8,opGT
	call	CompareR8
	mov	ax,-1
	ja	@F		;GT
	inc	ax
@@:
	push	ax
	DispMac

;GE
MakeExe exStCaseGER8,opStCaseGE
	SkipExHeader
MakeExe exGER8,opGE
	call	CompareR8
	mov	ax,-1
	jnb	@F		;GE
	inc	ax
@@:
	push	ax
	DispMac

;LE
MakeExe exStCaseLER8,opStCaseLE
	SkipExHeader
MakeExe exLER8,opLE
	call	CompareR8
	mov	ax,0
	ja	@F		;GT
	dec	ax
@@:
	push	ax
	DispMac

;LT
MakeExe exStCaseLTR8,opStCaseLT
	SkipExHeader
MakeExe exLTR8,opLT
	call	CompareR8
	mov	ax,-1
	jb	@F		;LT
	inc	ax
@@:
	push	ax
	DispMac

;===============================================================================
subttl	CY Math Support
page


;===============================================================================
subttl	SD Math Support
page

MakeExe exAddSD,opAdd
	call	CheckCONST		;Declare error if in CONST
	CALLRT	B$SCAT,DispMovSd	;add strings

;***
;CompareSD, CompareSDNoRel - Compare for type ET_SD
;Purpose:
;	Near interface to B$SCMP.
;	Near interface to B$ISCMPNoRel.
;
; Function:
;	Set sign and Zero flags based on comparing left and right strings
;	[left] > [right]     carry clear and zero clear
;	[left] < [right]     carry set	 and zero clear
;	[left] = [right]     carry clear and zero set
;Input:
;	Two SDs on the stack.
;Output:
;	ax = FALSE
;	PSW set as per compare
;
;******************************************************************************

sEnd	CODE
sBegin	DATA

Vector	DW	(?)

sEnd	DATA
sBegin	CODE



	DbPub	CompareSDNoRel	    ;string compare without releasing temps
CompareSDNoRel:
	pop	[Vector]	    ;remove retaddr to access other values on stack
	    call    B$ISCMPNoRel    ;compare without releasing left side if temp.
	jmp	short CompareSDCom

	DbPub	CompareSD
CompareSD:
	pop	[Vector]	    ;remove retaddr to access other values on stack
	    call    B$SCMP
CompareSDCom:
	mov	ax,FALSE	    ;in case we want to return FALSE
	jmp	[Vector]	    ;return to caller

;CASE string comparisons

MakeExe exStCaseGESD,opStCaseGE
	call	CompareSDNoRel
	jae	SD_TrueRet	;brif greater than or equal to
	jmp	short SD_Ret

MakeExe exStCaseGTSD,opStCaseGT
	call	CompareSDNoRel
	ja	SD_TrueRet	;brif greater than (z, s clear)
	jmp	short SD_Ret

MakeExe exStCaseLTSD,opStCaseLT
	call	CompareSDNoRel
	jb	SD_TrueRet	;brif less than
	jmp	short SD_Ret

MakeExe exStCaseLESD,opStCaseLE
	call	CompareSDNoRel
	jna	SD_TrueRet	;brif less than or equal to
	jmp	short SD_Ret	;brif greater than - return false

MakeExe exStCaseEQSD,opStCaseEQ
	SkipExHeader
MakeExe exStCaseSD,opStCase
	call	CompareSDNoRel
	je	SD_TrueRet	;brif strings are equal
	jmp	short SD_Ret

MakeExe exStCaseNESD,opStCaseNE
	call	CompareSDNoRel
	jne	SD_TrueRet	;brif strings are not equal
	jmp	short SD_Ret

;String comparisons

MakeExe exGESD,opGE
	call	CompareSD
	jae	SD_TrueRet	;brif greater than or equal to
	jmp	short SD_Ret

MakeExe exGTSD,opGT
	call	CompareSD
	ja	short SD_TrueRet;brif greater than (z, c clear)
	jmp	short SD_Ret

MakeExe exLTSD,opLT
	call	CompareSD
	jb	SD_TrueRet	;brif less than
	jmp	short SD_Ret

MakeExe exLESD,opLE
	call	CompareSD
	jbe	SD_TrueRet	; brif less than or equal to
	jmp	short SD_Ret	

MakeExe exEQSD,opEQ
	call	CompareSD
	je	SD_TrueRet	;brif strings are equal
	jmp	short SD_Ret

MakeExe exNESD,opNE
	call	CompareSD
	je	SD_Ret		;brif strings are equal
SD_TrueRet:
	dec	ax
SD_Ret:
	push	ax
	DispMac

;CASE text comparisons



;===============================================================================
subttl	CASE TO comparison support for I2/I4/R4/R8/SD
page
;exStCaseToI2, exStCaseToI4, exStCaseToR4, exStCaseToR8, exStCaseToSD
;
;The stack contains three values coerced to the same type.  These
;routines emit a NOT FALSE onto the stack if exp1 is in inclusive
;range defined by [exp2,exp3], else a FALSE is emitted.

MakeExe exStCaseToR8,opStCaseTo
	fld	st(2)		;Duplicate input value
	call	CompareR8	;is upper bound < val?
	jb	ToR8_FalsePop	;brif so
	call	CompareR8	;is val < lower bound?
	jb	ToI4_False	;brif so
	jmp	short ToI4_True

ToR8_FalsePop:
	fpoptwo			;[21]Pop two values
	jmp	short ToI4_False

MakeExe exStCaseToI2,opStCaseTo
	pop	bx		;upper bound
	pop	cx		;lower bound
	pop	dx		;value
	xor	ax,ax		;initially FALSE
	cmp	dx,cx		;is val < lower bound?
	jl	ToI2_Ret	;brif so
	cmp	dx,bx		;is val > upper bound?
	jg	ToI2_Ret	;brif so
	dec	ax		;TRUE
ToI2_Ret:
	push	ax
	DispMac

MakeExe exStCaseToI4,opStCaseTo
	mov	bx,sp		;set up frame ptr
	push	DGROUP:[bx+10]	;push High word of val
	push	DGROUP:[bx+8]	;push low word of val
	call	CompareI4	;is upper bound < val?
	jb	ToI4_FalsePop	;brif so - pop off lower bound/val
	call	CompareI4	;is val < lower bound ?
	jb	ToI4_False	;brif so
ToI4_True:
	mov	ax,NOT FALSE
	jmp	short ToI2_Ret
ToI4_FalsePop:
	add	sp,8		;pop off lower bound and value
ToI4_False:
	xor	ax,ax
	jmp	short ToI2_Ret




MakeExe exStCaseToSD,opStCaseTo
	mov	bx,sp
	    push    DGROUP:[bx+4]   ;duplicate string descriptor
	    push    DGROUP:[bx]     ;duplicate upper bound
	call	CompareSDNoRel	    ;is val > upper bound?
	    pop     ax		    ;(pop off copy of upper bound)
	ja	ToSD_FalsePop	    ;brif so
	call	CompareSDNoRel	    ;is val < lower bound?
	jb	ToI4_False	    ;brif so
	jmp	short ToI4_True

ToSD_FalsePop:
	call	B$FLEN		    ;dealloc lower bound if it was a temp
	    pop     ax		    ;pop off val
	jmp	short ToI4_False

;======================================================================
	subttl	Like operator support (EB only)
	page


;======================================================================
	subttl	Math Error Handler Support
	page
;***
;exMathErr
;Purpose:
;	Route math errors to the BASIC error handler.
;
;Input:
;	bx = BASIC error number
;	si = <garbage>
;	di = <garbage>
;	sp = <garbage>
;	bp = <garbage>
;	es = <garbage>
;
;	grs.GRS_oTxCur = oTx of error
;
;Output:
;	none
;
;Exit:
;	B$SERR
;
;******************************************************************************
sEnd	CODE
extrn	B$SERR:far
sBegin	CODE

	;Declare error if in a CONST statement

CheckCONST:
	test	[SsFlags],SSF_ScanAndExec;Implies CONST is in progress
	jnz	exMathErrFC		;Inside ScanAndExec implies CONST
	ret				;evaluation is in progress

exMathErrFC:
	mov	bx,ER_FC		;Illegal Function call error
	jmp	short Err

	public	exMathErrOVF
exMathErrOVF:
	mov	bx,ER_OV		;Overflow error
	jmp	short Err

	public	exMathErrDV0
exMathErrDV0:
	mov	bx,ER_DV0		;/0 error
Err:
	mov	[grs.GRS_oTxCur],si	;Save oTx of error
exMathErr:
	cCall	B$SERR,bx		;Declare the error
	DbHalt	CODE,<exMathOp.asm - B$SERR Returned!>


;===============================================================================

	subttl	Any type executors needed for Forms
	page


;===============================================================================

	subttl	opcode to executor maps for math routines
	page

	;These tables are used by scan routines to map opcodes to executors.

sEnd	CODE
sBegin	SCAN				
assumes cs, SCAN			

NOTIMP	MACRO
	DW	0
	ENDM

	public	mUMiOpExe
mUMiOpExe:
	DW	exUMiI2
	DW	exUMiI4
	DW	exUMiR8
	DW	exUMiR8

	public	mNEOpExe
mNEOpExe:
	DW	exNEI2
	DW	exNEI4
	DW	exNER8
	DW	exNER8
	DW	exNESD

	public	mGEOpExe
mGEOpExe:
	DW	exGEI2
	DW	exGEI4
	DW	exGER8
	DW	exGER8
	DW	exGESD

	public	mLEOpExe
mLEOpExe:
	DW	exLEI2
	DW	exLEI4
	DW	exLER8
	DW	exLER8
	DW	exLESD

	public	mEQOpExe
mEQOpExe:
	DW	exEQI2
	DW	exEQI4
	DW	exEQR8
	DW	exEQR8
	DW	exEQSD

	public	mGTOpExe
mGTOpExe:
	DW	exGTI2
	DW	exGTI4
	DW	exGTR8
	DW	exGTR8
	DW	exGTSD

	public	mLTOpExe
mLTOpExe:
	DW	exLTI2
	DW	exLTI4
	DW	exLTR8
	DW	exLTR8
	DW	exLTSD

	public	mOrOpExe
mOrOpExe:
	DW	exOrI2
	DW	exOrI4

	public	mAndOpExe
mAndOpExe:
	DW	exAndI2
	DW	exAndI4

	public	mXorOpExe
mXorOpExe:
	DW	exXorI2
	DW	exXorI4

	public	mNotOpExe
mNotOpExe:
	DW	exNotI2
	DW	exNotI4

	public	mFnSgnOpExe
mFnSgnOpExe:
	DW	exFnSgnI2
	DW	exFnSgnI4
	DW	exFnSgnR8
	DW	exFnSgnR8

	public	mImpOpExe
mImpOpExe:
	DW	exImpI2
	DW	exImpI4

	public	mEqvOpExe
mEqvOpExe:
	DW	exEqvI2
	DW	exEqvI4

	public	mPwrOpExe
mPwrOpExe:
	DW	exPwrR8 		; Need I2 entry in case of type mismatch
	NOTIMP
	DW	exPwrR8
	DW	exPwrR8

	public	mMulOpExe
mMulOpExe:
	DW	exMulI2
	DW	exMulI4
	DW	exMulR8
	DW	exMulR8

	public	mAddOpExe
mAddOpExe:
	DW	exAddI2
	DW	exAddI4
	DW	exAddR8
	DW	exAddR8
	DW	exAddSD

	public	mSubOpExe
mSubOpExe:
	DW	exSubI2
	DW	exSubI4
	DW	exSubR8
	DW	exSubR8

	public	mDivOpExe
mDivOpExe:
	DW	exDivR8 		; Need I2 entry in case of type mismatch
	NOTIMP
	DW	exDivR8
	DW	exDivR8

	public	mIdvOpExe
mIdvOpExe:
	DW	exIdvI2
	DW	exIdvI4

	public	mModOpExe
mModOpExe:
	DW	exModI2
	DW	exModI4

	public	mFnAbsOpExe
mFnAbsOpExe:
	DW	exFnAbsI2
	DW	exFnAbsI4
	DW	exFnAbsR8
	DW	exFnAbsR8

	public	mFnIntOpExe
mFnIntOpExe:
	DW	exFnIntInt		
	DW	exFnIntInt		
	DW	exFnIntR8
	DW	exFnIntR8

	public	mFnFixOpExe
mFnFixOpExe:
	DW	exFnFixInt		
	DW	exFnFixInt		
	DW	exFnFixR8
	DW	exFnFixR8


sEnd	SCAN				
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exlit.asm ===
page	49,132
	TITLE	ExLit	- exLiteral Executors
;***
;exLit.asm - executors for literals
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains all literal executors.
;
;   Numeric literal executors include:
;	- support for arbitrary literals.  This includes literal executors
;	  of each numeric data type with an operand of the size of the data
;	  type.
;	- special support for common numeric literals.  For text size reasons
;	  I2 and R4 literal executors for the literals 0 through 10 are
;	  provided.  These executors are also considered  speed critical.
;
;   The string literal executor has two operands - a word sized byte
;   count and the actual string literal.  The text pointer must be
;   updated to the next even byte boundary by the string literal executor
;   as all text is on even byte boundaries.
;
;
;****************************************************************************


	.xlist
	include		version.inc
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	variable
	IncludeOnce	opintrsc
	IncludeOnce	opaftqb4
	IncludeOnce	pcode
	IncludeOnce	debug
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	CODE

I2	dw	2
I3	dw	3
I4	dw	4
I5	dw	5
I6	dw	6
I7	dw	7
I8	dw	8
I9	dw	9
I10	dw	10

;Rewritten with [9]
MakeExe exLitR80,opLitI2,0		
	fldz
	DispMac

MakeExe exLitR81,opLitI2,1		
	fld1
	DispMac

MakeExe exLitR82,opLitI2,2		
	mov	bx,codeOFFSET I2
LitR8:
	fild	word ptr cs:[bx]
	DispMac

MakeExe exLitR83,opLitI2,3		
	mov	bx,codeOFFSET I3
	jmp	LitR8

MakeExe exLitR84,opLitI2,4		
	mov	bx,codeOFFSET I4
	jmp	LitR8

MakeExe exLitR85,opLitI2,5		
	mov	bx,codeOFFSET I5
	jmp	LitR8

MakeExe exLitR86,opLitI2,6		
	mov	bx,codeOFFSET I6
	jmp	LitR8

MakeExe exLitR87,opLitI2,7		
	mov	bx,codeOFFSET I7
	jmp	LitR8

MakeExe exLitR88,opLitI2,8		
	mov	bx,codeOFFSET I8
	jmp	LitR8

MakeExe exLitR89,opLitI2,9		
	mov	bx,codeOFFSET I9
	jmp	LitR8

MakeExe exLitR810,opLitI2,10		
	mov	bx,codeOFFSET I10
	jmp	LitR8
;End of [9]

MakeExe	exNull,opNull
	SkipExHeader			;fall through to share exLitI20 code
MakeExe exLitI20,opLitI2,0		
	xor	ax,ax
	push	ax
	DispMac

MakeExe exLitI21,opLitI2,1		
	mov	al,1
LitI2_Gen:
	xor	ah,ah
	push	ax
	DispMac

MakeExe exLitI22,opLitI2,2		
	mov	al,2
	jmp short LitI2_Gen
MakeExe exLitI23,opLitI2,3		
	mov	al,3
	jmp short LitI2_Gen
MakeExe exLitI24,opLitI2,4		
	mov	al,4
	jmp short LitI2_Gen
MakeExe exLitI25,opLitI2,5		
	mov	al,5
	jmp short LitI2_Gen
MakeExe exLitI26,opLitI2,6		
	mov	al,6
	jmp short LitI2_Gen
MakeExe exLitI27,opLitI2,7		
	mov	al,7
	jmp short LitI2_Gen
MakeExe exLitI28,opLitI2,8		
	mov	al,8
	jmp short LitI2_Gen
MakeExe exLitI29,opLitI2,9		
	mov	al,9
	jmp short LitI2_Gen
MakeExe exLitI210,opLitI2,10		
	mov	al,10
	jmp short LitI2_Gen

MakeExe	exLitHI2,opLitHI2
	SkipExHeader			;Fall through to the next executor
MakeExe	exLitOI2,opLitOI2
	SkipExHeader			;Fall through to the next executor
MakeExe	exLitDI2,opLitDI2
LitI2:
	LODSWTX
Disp_Ax:
	push	ax
	DispMac

MakeExe	exUndef,opUndef
	mov	ax,UNDEFINED
	jmp	short Disp_Ax		;push UNDEFINED and dispatch



MakeExe	exLitR4,opLitR4
	fld	dword ptr es:[si]	
	add	si,4			
	DispMac				

MakeExe	exLitR8,opLitR8
	fld	qword ptr es:[si]	
	add	si,8			
	DispMac				

MakeExe	exLitHI4,opLitHI4
	SkipExHeader			;Fall through to the next executor
MakeExe	exLitOI4,opLitOI4
	SkipExHeader			;Fall through to the next executor
MakeExe	exLitDI4,opLitDI4
	LODSWTX
	xchg	ax,dx
	LODSWTX
Lit4:
	push	ax
Lit4_Exit:
	push	dx
	DispMac

MakeExe	exLitSD,opLitSD
	LODSWTX				;ax = length of string in bytes
	push	es			;3 parms to B$LDFS
	push	si
	push	ax
	inc	ax			;round count up - - - pcodes always
	and	al,0FEh			;  fall on even byte boundaries, so if
					;  string size is odd, a byte of garbage
					;  filler is put in pcode here
	add	si,ax			;move text ptr to next opcode
	CALLRT	B$LDFS,DispMovSd

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exproc.asm ===
page	49,132
	TITLE	EXPROC - Executors for procedures
;***
;exproc.asm - executors for procedures
;
;	Copyright <C> 1986, Microsoft Corporation
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXPROC_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opcontrl
	IncludeOnce	opid
	IncludeOnce	opstmt
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	rtps
	IncludeOnce	scanner
	IncludeOnce	ui
	IncludeOnce	variable
	IncludeOnce	pcode		
	.list


PUSHSS	MACRO
	endm

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	externB	b$ErrInfo

ParamCnt	dw	0		
sEnd	DATA



extrn	B$STMakeTemp:far		;Copy string to temp

	externFP __fpmath		

sBegin	CODE

subttl	exStCall,exStCallLess,exStCallS
page


;***
;exStCall - Execute CALL statement
;
;Purpose:
;	1.  Activate target PRS
;
;	2.  Push return address, allocate and zero frame variables.
;
;	3.  Execute the SUB.
;
;	The stack frame looks like this:
;	<arg 1>
;	<arg 2>
;	. . .
;	<arg n>
;	<oRS of return address>
;	<oText of return address>
; BP-->	<old BP>
;	<old b$curframe>			[2]
;	<local variables and FOR temps>
;
;
;******************************************************************

MakeExe exFuncNArgSD,opAIdLd,ET_SD
	SkipExHeader
MakeExe exFuncNArgI4,opAIdLd,ET_I4
	SkipExHeader
MakeExe exFuncNArgR8,opAIdLd,ET_R8
	SkipExHeader
MakeExe exFuncNArgI2,opAIdLd,ET_I2
	SkipExHeader
MakeExe exFuncNArgR4,opAIdLd,ET_R4
	SkipExHeader
MakeExe exFuncNArgImp,opAIdLd,ET_Imp
	inc	si
	inc	si			;Skip over arg count
	jmp	short Func0Arg

MakeExe exFunc0ArgSD,opIdLd,ET_SD
	SkipExHeader
MakeExe exFunc0ArgI4,opIdLd,ET_I4
	SkipExHeader
MakeExe exFunc0ArgR8,opIdLd,ET_R8
	SkipExHeader
MakeExe exFunc0ArgI2,opIdLd,ET_I2
	SkipExHeader
MakeExe exFunc0ArgR4,opIdLd,ET_R4
	SkipExHeader
MakeExe exFunc0ArgImp,opIdLd,ET_Imp
Func0Arg:
	LODSWTX				;Get oVar
	xchg	ax,bx
	mov	ax,[pVarBx]		;Get oPRS
	jmp	short FuncCall

CallCompiledJ:
	jmp	CallCompiled

MakeExe	exStCallS,opStCallS
	SkipExHeader
MakeExe	exStCallLess,opStCallLess
	SkipExHeader
MakeExe	exStCall,opStCall
	inc	si
	inc	si			;Skip over count of arguments
	LODSWTX				;Get oPRS
FuncCall:
;ax = oPRS of target
	GETRS_SEG es,bx,<SPEED,LOAD>	
	mov	bx,ax
	RS_BASE add,bx			; es:bx points to prs
	test	BPTRRS[bx.PRS_flags],FP_DEFINED   ; Interpreted?
	jz	CallCompiledJ		

CallInterpreted:			

	inc	[b$CurLevel]		;Save any temps from deallocation
	push	[pGosubLast]		;Save current head of Gosub list
	push	[grs.GRS_oRsCur]	;Push current oRS
	xchg	dx,ax			;Save oPRS in dx
	mov	al,0
	xchg	al,[grs.GRS_fDirect]	;Get fDirect and set to FALSE
	or	al,al			;Leaving direct mode?
	jz	NotInDirect
	inc	si			;Set LSB to indicate direct mode
	or	[grs.GRS_flags],FG_RetDir
					;remember there's a ret adr to
					; direct mode buffer on stack.
NotInDirect:
; Warning:	SI is assumed to be at [bp+2] for out of stack error recovery.
; We need to make sure that fDirect gets reset correctly if we couldn't
; transfer control to the procedure.

	push	si			;Push current oTx
	push	bp
	mov	bp,sp			;Set up frame pointer
	push	[b$curframe]		; set up BASIC-frame chain
	mov	cx,PTRRS[bx].PRS_cbFrameVars ; Local variables
	add	cx,PTRRS[bx].PRS_cbFrameTemp ; Plus temps
	dec	cx			; cbFrameVars includes 2 bytes to
	dec	cx			;  account for pushed b$curframe
	mov	di,sp
	sub	di,cx			;Allocate local variables and temps
	jc	OutOfStack		;Underflow?
	cmp	di,[b$pEndChk]
	jbe	OutOfStack		;Not enough stack space left
	mov	sp,di
	mov	[b$CurFrame],bp 	;must change b$CurFrame AFTER this chk
					; there will always be a block fill
					; needed
	jcxz	NoLocals
	xor	ax,ax
	push	es			
	push	ss
	pop	es			;es = ss
	shr	cx,1			;Word count
	rep	stosw			;Zero out local variables
	pop	es			
NoLocals:
	mov	si,PTRRS[bx.PRS_otxDef] ; si points to procedure header
	xchg	ax,dx			;Restore oPRS to ax
	or	ah,80H			;oPrs ==> oRs
	call	RsActivateCODE		;Activate called proc
	RestorePcodeVar 		
	inc	si
	inc	si
	LODSWTX				;Get cbEOS
	add	si,ax			;Start execution after definition
	DispMac

OutOfStack:
	mov	ax,[bp+2]		;LSB is fDirect flag before
					;we started building the frame
	ror	al,1			;move lsb to msb
	cbw				;replicate msb into ah
	mov	[grs.GRS_fDirect],ah	;Set fDirect back to entry state
	mov	al,ER_OM
	mov	[b$ErrInfo],OMErr_STK	;note that this is really Out of Stack
					;  space, not Out of Memory
	call	RtErrorCODE

;Branched to when user is tracing through a native code call.  Since
;native code can cause screen output, we need to swap to output screen
;just in case.
;
ShowOutputScr:
	push	bx			;save pPrs
	call	ShowOutScr
	GETRS_SEG es,bx,<SIZE,LOAD>	;[4] restore seg of Rs table
	pop	bx			;restore pPrs
	DbAssertRelB [fDebugScr],e,0,CODE,<exproc: ShowOutScr failed>
;bx = pPrs of procedure to be called
CallCompiled:
	cmp	[fDebugScr],0
	jne	ShowOutputScr		;brif debug screen is visible
	DbAssertRel fNonQBI_Active,z,0,CODE,<exproc: fNonQBI_Active should be 0>
	mov	[fNonQBI_Active],bp	;save pointer to most recent QBI frame
	inc	[b$cNonQBIFrames]
	mov	ax,[b$curlevel]
	mov	[bcurlevel_QBI],ax	;if we end up having to blast the stack
					;  back to the most recent QBI frame,
					;  we need this to restore the proper
					;  setting of b$curlevel
;Save si and cbParam in last temp
	mov	di,[grs.GRS_oRsCur]	
	and	di,07FFFH		; mask off high bit
	RS_BASE add,di			
.errnz	MRS_cbFrameTemp - PRS_cbFrameTemp
	mov	ax,PTRRS[di].MRS_cbFrameTemp ; Get no. of temps for module
	neg	ax			;Make it oBP
	add	ax,bp
	sub	ax,PTRRS[di.MRS_cbFrameVars] ; Point to last temp
	xchg	di,ax
	mov	[di],si
	xor	ax,ax			;Always leave ParamCnt zero
	xchg	ax,[ParamCnt]		
	mov	[di+2],ax		;Amount of stack to clean up
	mov	[grs.GRS_otxCur],si	;Save here in case of error

	cmp	BPTRRS[bx.PRS_procType],PT_SUB	
	jnz	CallCompiledFunc	;call a User Library SUB
	call	dword ptr [bx.PRS_txd.TXD_oCompiled]	 
	call	RestoreFromCall
CallX:
	DispMac

CallCompiledFunc:
	test	BPTRRS[bx].PRS_flags,FP_CDECL	
	jnz	MakeCall			;Don't push addr. for C
	mov	cl,BPTRRS[bx.PRS_oType] 	
	and	cl,M_PT_OTYPE			; mask out possible flags
	cmp	cl,ET_SD			;[15][4] Value returned in regs?
	jae	MakeCall			;[14]
	cmp	cl,ET_I4			;[15][4] Value returned in regs?
	jbe	MakeCall			
; Type is R4, R8, or CY
;Return value is always just before saved si in temps
;di = pointer to last temp
;cl = PRS_oType
	add	di,4			;Make room for si and cbParam
	push	di
	    cmp     cl,ET_R4		;[14] R4 ? Before ES loaded
	    mov     ax,0		;NOTE: CY flag preserved

	push	ss			
	pop	es			;es:di points to return temp
	stosw
	stosw				;Zero return value if R4
	    je	    @F			;brif R4. Only clear two words
	stosw
	stosw				;Zero rest of R8 or CY
@@:
MakeCall:
	    call    dword ptr [bx.PRS_txd.TXD_oCompiled]
	call	RestoreFromCall
;Returning from function - restore 8087 stack
	pop	cx			;Get no. of 8087 registers saved
	jcxz	NoTemps
RestoreLoop:
	mov	bx,sp
	fld	tbyte ptr DGROUP:[bx]	;Put back on stack
	add	sp,10			;Move pointer up
	loop	RestoreLoop
NoTemps:
	mov	bx,PTRTX[si-2]		;Get oVar
	mov	cl,[pVarBx].VAR_flags	;oTyp in low bits
	and	cl,FV_TYP_MASK
	cmp	cl,ET_I4		;Value in (dx:)ax?
	jb	PushI2
	je	PushI4
	cmp	cl,ET_SD
	jae	PushI2			;If string, push near address in ax
;ax points to R4 or R8
	xchg	ax,bx			;ds:bx points to return value
	cmp     cl,ET_R4
	jnz	PushR8			
	fld	dword ptr [bx]		; copy retval to 87 stack
	jmp	CallX

PushR8:
	fld	qword ptr [bx]		; copy retval to 87 stack
	jmp	CallX

PushI4:
	push	dx
PushI2:
	push	ax
	jmp	CallX

RestoreFromCall:
;Restore es, si, di and NonQBI flags after native code call
;Possible return value in dx:ax preserved
;cx preserved
;Restore return oTx to si
	GETRS_SEG es,bx,<SPEED,LOAD>	;[4] restore seg of Rs table
	mov	bx,[grs.GRS_oRsCur]	
	and	bh,07FH 		; mask off high bit
	RS_BASE add,bx			
.errnz	MRS_cbFrameTemp - PRS_cbFrameTemp
	mov	si,PTRRS[bx].MRS_cbFrameTemp	; Get no. of temps for module
	neg	si			;Make it oBP
	sub	si,PTRRS[bx.MRS_cbFrameVars]	; Point to last temp
	pop	bx			; bx = ret address
	add	sp,[si+bp+2]		;Clean off parameters
	push	bx			; push ret address back
	mov	si,[si+bp]		;Restore return oTx
	DbAssertRel b$cNonQBIFrames,nz,0,CODE,<exproc: b$cNonQBIFrames == 0>
	dec	[b$cNonQBIFrames]
	DbAssertRel fNonQBI_Active,z,bp,CODE,<exproc: fNonQBI_Active not == bp>
	mov	[fNonQBI_Active],0	;reset - - QBI code is active again
	call	GetEsDi
	ret

MakeExe	exStFunction,opStFunction
	SkipExHeader
MakeExe	exStSub,opStSub
	LODSWTX				;Get cntEOS
	add	si,ax
	DispMac


MakeExe	exStDefFN,opStDefFN
	mov	si,PTRTX[si+2]		;Get link to EndDef
	inc	si
	inc	si			;Skip past link to next DefFn
	DispMac

MakeExe	exEndSingleDef,opEndSingleDef
	;Move return value from top of stack to expected location

	mov	bx,[grs.GRS_oPrsCur]	; bx points to active prs in table
	RS_BASE add,bx			
	GETRS_SEG  es			
	mov	cx,PTRRS[bx].PRS_cbFrameVars	;[2] Size of return value + 2
	mov	di,bp
	sub	di,cx			;Location for return value
.erre	FR_FirstVar EQ -2
	dec	cx			; make cx the size of the return 
	dec	cx			; value
	mov	al,BPTRRS[bx].PRS_oType 
	and	al,M_PT_OTYPE		; mask out possible flag bits
	cmp	al, ET_SD		;[4] Returning a string?
	jae	CopySD			
	mov	si,sp			;for integer ret vals
;Added with [35]
	cmp	al,ET_R4
	jb	DefFnInt
	jz	DefFnR4
	fstp	qword ptr [di]		;Store R8 return value in stack
	jmp	short EndProc

DefFnR4:
	fstp	dword ptr [di]		;Store R4 return value in stack
	jmp	short EndProc

DefFnInt:
;End of [35]
	push	ss			
	pop	es
rep	movsb				;Move up return value
	jmp	short EndProc

CopySD:
	;pSD already on stack
	push	di			;Assign string to here
	CALLRT	B$SASS,Mov		;es is now invalid!!

	;Fall into EndDef

	SkipExHeader
MakeExe	exStEndDef,opStEndDef
	SkipExHeader


MakeExe exStEndProc,opStEndProc



	mov	bx,[grs.GRS_oPrsCur]	; bx points to active prs in table
	RS_BASE add,bx			

EndProc:
	GETRS_SEG es,di,<SPEED,LOAD>	;[4] fetch seg of Rs table
	dec	[b$CurLevel]
	mov	ax,[bp].FR_pGosubLast
	mov	[pGosubLast],ax
	mov	al,BPTRRS[bx.PRS_cwParams]	; cw of parameters
	xor	ah,ah
	shl	ax,1			;Change to cb
	add	ax,FR_MinFrame		;Remove frame
	add	ax,bp			;Compute sp w/o arguments
	xchg	ax,di			;destination in stack of return value
	mov	al,BPTRRS[bx.PRS_oType] ; oTyp of return value
	and	al,M_PT_OTYPE		; mask out possible flag bits
	mov	ah,BPTRRS[bx.PRS_procType]	
	push	ax
	mov	si,[bp].FR_otxRet	;Get oTx of return addr
	test	si,1			;LSB = returning to direct mode?
	jz	NotDirect
	mov	[grs.GRS_fDirect],-1	;Going back to direct mode
	dec	si			;Back to true oTx
	and	[grs.GRS_flags],NOT FG_RetDir
					;remember there's no ret adr to
	push	ss
	pop	ds			;ds=DGROUP
					; direct mode buffer on stack.
NotDirect:
	mov	ax,[bp].FR_oRsRet	;oRs of return addr
	call	RsActivateCODE		;Activate caller
	pop	ax			;ah=procType, al=oTyp of RetVal
	lea	bx,[bp-2].FR_FirstVar	;Point to high end of return value
	push	[bp].FR_basBpLink	;[33] Restore old b$curframe
	pop	[b$CurFrame]		
	mov	bp,[bp].FR_bpLink	;Restore old bp
	cmp	ah,PT_SUB		;Is it a SUB?
	jz	NoRetVal		;If a SUB, no return value to copy
	xchg	bx,si			;Save return oTx in bx
;Added with [32]
;Restore values to 8087 stack
	mov	cx,[di]			;Number of temp reals to restore
	jcxz	No87Temps
Restore87Loop:
	fld	tbyte ptr DGROUP:[di+2]	;Put back on stack
	add	di,10			;Move pointer up
	loop	Restore87Loop
No87Temps:
;End of [32]
	push	ss
	pop	es			;es = ss
	std				;Reverse order--possibly overlapping
	cmp	al,ET_SD		;String?
	jae	ReturnSD		
	.erre	ET_SD EQ (ET_MaxNum+1)	
;Rewritten with [24]
	    cmp     al,ET_R4
	    je	    RetR4
	cmp	al,ET_R8
	jz	RetR8

	;Have I2, I4, or CY

	cbw
	xchg	cx,ax
.erre	ET_I2 EQ 1			;cw of I2
.erre	ET_I4 EQ 2			;cw of I4

rep	movsw				;Copy return value

SetSi:
	mov	si,bx			;Return oTx
ValInPlace:
	inc	di
	inc	di
	cld
NoRetVal:
	mov	sp,di			;Return val on top of stack
	RestorePcodeVar 		
	DispMac

ReturnSD:
	dec	si
	dec	si			;Point to low byte of SD
	push	si
	mov	si,bx			;Return oTx
	mov	[grs.GRS_otxCur],si	;Save in case of error
	call	B$STMakeTemp		;Make SD a temp - ax = pSD
	stosw				;pSD/handle to its place in stack
	jmp	ValInPlace

;Added with [24]
RetR4:
	fld	dword ptr DGROUP:[si-2]
	jmp	SetSi

RetR8:
	fld	qword ptr DGROUP:[si-6]
	jmp	SetSi
;End of [24]



MakeExe	exNoList1,opNoList1
	inc	si
	inc	si			;Eat one operand
	SkipExHeader
MakeExe	exSeg,opSeg
	SkipExHeader
MakeExe	exByVal,opByVal
	DispMac

;Added with [32]
MakeExe exSave87,opNoList0
	;The following special interface is used to obtain the number
	;of items on the 87/em stack.  This allows us to account for
	;the extended stack with the emulator, with or without an 80x87.
	mov	bx,10			;arg to __fpmath to get count
	call	__fpmath		;AX = # items on the 87/em stack
	mov	cx,ax			;Count to cx
	jcxz	EmptyStack		;go if nothing to do
Save87Loop:
	sub	sp,10			;Make room for a temp real
	mov	bx,sp
	fstp	tbyte ptr DGROUP:[bx]
	loop	Save87Loop
EmptyStack:
	push	ax			;Remember how much we saved
	DispMac

MakeExe	exParamCnt,opNoList1
	LODSWTX
	mov	[ParamCnt],ax		;Remember how much to release
	DispMac
;End of [32]

MakeExe	exAddStack,opNoList1
	LODSWTX
	add	sp,ax			;De-allocate stack space
	DispMac

MakeExe	exDeallocArray,opNoList1	;oBP
;De-allocate local array vaable
	LODSWTX				;Get oBP
	add	ax,bp			;point to array descriptor
	xchg	bx,ax			;pDescriptor to bx
	and	[bx].AD_fFeatures,not FADF_STATIC	;Make array dynamic
	push	bx
	CALLRT	B$ERAS,DispMov		;Erase the array - CAN cause heap mvmnt!

MakeExe	exDelLocSD,opNoList1		;oBP
;De-allocate local SD variable
	LODSWTX				;Get oBP
	add	ax,bp			;pSD
	push	ax			;Address of SD to stack
	CALLRT	B$STDL,Disp		;De-allocate string space


	;Start of [44]


MakeExe exR4ToStack,opNoList0
	sub	sp,4			;Make room for Single on 80x86 stack
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Move to 80x86 stack from 80x87 stack
	fwait				;Wait for it
	DispMac


MakeExe exR8ToStack,opNoList0
	sub	sp,8			;Make room for Double on 80x86 stack
	mov	bx,sp
	fstp	qword ptr DGROUP:[bx]	;Move to 80x86 stack from 80x87 stack
	fwait				;Wait for it
	DispMac

	;End of [44]


MakeExe	exDelTmpSD,opNoList1		;oTemp
;De-allocate temp SD
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	push	ax			;Address of SD to stack
	CALLRT	B$STDL,Disp		;De-allocate string space

MakeExe	exStTmpSD,opNoList1		;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	bx			;Re-order stack
	push	ax			;Leave address of temp on stack
	push	bx			;1st arg - address of expression SD
	push	ax			;2nd arg - variable to assign to
	xchg	ax,bx			;Destination to bx
	mov	word ptr [bx],0		;Current length of dest. is zero
	CALLRT	B$SASS,DispMov		;Get runtime to do string assign


;Added with [24]
MakeExe	exStTmpR4,opNoList1		;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	fstp	dword ptr [pFrame]
	jmp	short PushPtr
	;DispMac

MakeExe	exStTmpR8,opNoList1		;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	fstp	qword ptr [pFrame]
PushPtr:
	PUSHSS
	push	ax			;Address of temp on stack
	fwait
	DispMac
;End of [24]

MakeExe	exStTmp4,opNoList1		;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	[pFrame]		;Pop stack into the temp
	pop	[pFrame+2]		
	PUSHSS				
	push	ax			;Address of temp on stack
	DispMac

MakeExe	exStTmp2,opNoList1		;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	[pFrame]		;Pop stack into the temp
	PUSHSS				
	push	ax			;Address of temp on stack
	DispMac



public	GetTempAddr
GetTempAddr:
;Get oTemp from pcode, compute pTemp to ax
	LODSWTX
	push	es			
	GETRS_SEG es,bx,<SPEED,LOAD>	;[4] fetch seg of Rs table
	mov	bx,[grs.GRS_oRsCur]	
	and	bh,07Fh 		
	RS_BASE add,bx			
	sub	ax,PTRRS[bx.MRS_cbFrameVars]	;ax is oBP
	add	ax,bp
	mov	bx,ax			;pTemp to bx too
	pop	es			
	ret

;***
;SetSP, SetSpFar
;Purpose:
;	Used to restore SP to what it was at the beginning of a statement
;	which caused a runtime error. Calculates SP based on the assumption
;	that BP is set to the proper frame, using the current context to
;	determine the offset between SP and BP.
;Inputs:
;	BP set to current frame
;	static structs assumed disabled
;	pGosubLast set appropriately
;	grs.GRS_oRsCur set appropriately
;	current mrs/prs structure has the cbFrameTemp and cbFrameVars
;		field(s) correctly set
;Outputs:
;	AX is set to appropriate location for SP to be set to at each
;		BOS based on BP.
;	PSW flags are set so caller can do a JA to jump if no stack overflow.
;	For SetSpFar, dx is a copy of PSW flags, because windows can trash
;		PSW on exit from far routines.
;Exceptions:
;	None.
;****
	PUBLIC	SetSP
SetSP	PROC NEAR
	call	far ptr SetSpFar
	push	dx			
	popf				; ensure flags set correctly
	ret
SetSP	ENDP

sEnd	CODE
sBegin	CP
assumes cs, CP

cProc	SetSpFar,<PUBLIC,FAR>		
cBegin	SegSpFar			
	DbChk	ConNoStatStructs
	mov	dx,[b$curframe] 	
	mov	ax,[pGosubLast]
	or	ax,ax
	jz	No_Gosub		;brif no gosub frame active

	cmp	ax,dx			; exists a gosub frame below?
	jbe	SetSP_Exit		;brif so - set SP to pGosubLast
No_Gosub:
	mov	bx,[grs.GRS_oRsCur]
	and	bh,07FH			;turn off high bit in oRs
	RS_BASE add,bx			; bx points to active Rs in table
	GETRS_SEG es,cx,<SIZE,LOAD>	;[4] fetch seg of Rs table
	.errnz	MRS_cbFrameTemp - PRS_cbFrameTemp
	.errnz	MRS_cbFrameVars - PRS_cbFrameVars
	mov	cx,PTRRS[bx.PRS_cbFrameTemp]	
	add	cx,PTRRS[bx.PRS_cbFrameVars]	
	mov	ax,dx			
	sub	ax,cx
	jc	SetSP_Exit1		;brif pathetic case - - frame size
					;  is greater than BP value
SetSP_Exit:
	cmp	ax,[b$pendchk]		;set status word flags for caller
SetSP_Exit1:
	pushf				
	pop	dx			
cEnd	SetSpFar			

sEnd	CP
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exos.asm ===
page	49,132
	TITLE	exos.asm - executors for OS-specific statements and functions
;***
;exos.asm - executors for OS-specific statements and functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXOS_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	msdos
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	opaftqb4
	IncludeOnce	qbimsgs
	IncludeOnce	ui
	.list

ExToRtDispSd	equ ExToRtDispAx	


sBegin	DATA
	externW	b$nuldes		;SD for a null string
sEnd	DATA

assumes es, NOTHING
assumes ss, DATA

sBegin	CODE
assumes cs, CODE


externNP	RtDispatch		

;=============================================================================
;		OS-specific Instrinsic Function Executors
;=============================================================================

MakeExe exFnCommand_,opFnCommand_
	    CALLRT  B$FCMD,DispSd	

MakeExe	exFnDate_,opFnDate_
	    CALLRT  B$FDAT,DispSd	

MakeExe	exFnTime_,opFnTime_
	    CALLRT  B$FTIM,DispMovSd	


MakeExe exFnEnviron_I2,opFnEnviron_
	CALLRT	B$FEVI,DispSd		

MakeExe exFnEnviron_SD,opFnEnviron_
	CALLRT	B$FEVS,DispSd		

MakeExe	exFnShell,opFnShell
	    CALLRT  B$FSHL,DispAx


MakeExe	exFnTimer,opFnTimer
	DbTimer			;print # of sec.s since last reset if PROFILE
	CALLRT	B$TIMR,DispR4

;=============================================================================
;		OS-specific Statement Executors
;=============================================================================

MakeExe exStChDir,opStChDir
	CALLRT	B$CDIR,Disp



MakeExe	exStDate_,opStDate_
	    CALLRT  B$SDAT,Disp

MakeExe	exStTime_,opStTime_
	    CALLRT  B$STIM,Disp

MakeExe	exStEnviron,opStEnviron
	CALLRT	B$SENV,Disp

MakeExe	exStFiles0,opStFiles0
	PushI	ax,<dataOFFSET b$nuldes>
	SkipExHeader
MakeExe	exStFiles1,opStFiles1
	CALLRT	B$FILS,Disp

MakeExe	exStShell0,opStShell0
	cmp	[grs.GRS_fDirect],FALSE
	jz	StShell0_Cont		;brif not Direct Mode

	;SHELL statement from direct mode. Tell User what he needs to do
	;to get back to QB - - -
	PushI	ax,MSG_ExitToRet	;"Type EXIT to return to QuickBASIC"
	cCall	ListStdMsgFar		;put msg in ds:bufStdMsg
	PushI	bx,<dataOFFSET bufStdMsg> ;pb field of pseudo SD on stack
	push	ax			;cb field of pseudo SD on stack
	mov	ax,sp
	push	ax			;pSD
	CALLRT	B$PESD			;print string to output screen
StShell0_Cont:
	PushI	ax,<dataOFFSET b$nuldes>
	SkipExHeader
MakeExe	exStShell1,opStShell1
	CALLRT	B$SSHL,DispMov



MakeExe	exStKill,opStKill
	CALLRT	B$KILL,Disp

MakeExe	exStMkdir,opStMkdir
	CALLRT	B$MDIR,Disp

MakeExe	exStName,opStName
	CALLRT	B$NAME,Disp

MakeExe	exStRmdir,opStRmdir
	CALLRT	B$RDIR,Disp

MakeExe exStSleep0,opStSleep0		
	xor	ax,ax			
	push	ax			
	push	ax			;default for sleep is 0L
	SkipExHeader

MakeExe exStSleep1,opStSleep1		
	mov	ax,HIGH PB$SLEP + 0100H ; postword for B$SLEP
					; Note that this counts on B$SLEP
					; generating a > 255 postbyte/word
	mov	cx,CODEOFFSET DispMov	; return to DispMov after B$SLEP
	jmp	RtDispatch		; do it

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exstring.asm ===
page	49,132
	TITLE	EXSTRING - string function and statement executors
;***
;exstring.asm - string function and statement executors for QBI
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXSTRING_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opaftqb4
	IncludeOnce	opintrsc
	IncludeOnce	opstmt
	IncludeOnce	pcode		
	IncludeOnce	ui
	.list


assumes es, NOTHING
assumes ss, DATA

sBegin	DATA



sEnd	DATA

sBegin	CODE
assumes cs, CODE





;==============================================================================
;		Intrinsic String Function Executors
;==============================================================================

MakeExe exFnCvi,opFnCvi
	CALLRT	B$FCVI,DispAx

MakeExe exFnCvl,opFnCvl
	CALLRT	B$FCVL,DispDxAx

MakeExe exFnCvs,opFnCvs
	TestM	[cmdSwitches],CMD_SW_MBF
	jnz	exFnCvsmbf		;Brif we want this to act like CVSMBF
	CALLRT	B$FCVS,DispR4

MakeExe exFnCvd,opFnCvd
	TestM	[cmdSwitches],CMD_SW_MBF
	jnz	exFnCvdmbf		;Brif we want this to act like CVDMBF
	CALLRT	B$FCVD,DispR8

MakeExe exFnCvsmbf,opFnCvsmbf
	CALLRT	B$MCVS,DispR4

MakeExe exFnCvdmbf,opFnCvdmbf
	CALLRT	B$MCVD,DispR8

MakeExe exFnMki_,opFnMki_
	CALLRT	B$FMKI,DispMovSd	

MakeExe exFnMkl_,opFnMkl_
	CALLRT	B$FMKL,DispMovSd	

MakeExe exFnMks_,opFnMks_
	TestM	[cmdSwitches],CMD_SW_MBF
	jnz	exFnMksmbf_		;Brif we want this to act like MKSMBF
	sub	sp,4			
	mov	bx,sp			
	fstp	dword ptr DGROUP:[bx]	; Move to local stack
	fwait				
	CALLRT	B$FMKS,DispMovSd	

MakeExe exFnMkd_,opFnMkd_
	TestM	[cmdSwitches],CMD_SW_MBF
	jnz	exFnMkdmbf_		;Brif we want this to act like MKDMBF
	sub	sp,8			
	mov	bx,sp			
	fstp	qword ptr DGROUP:[bx]	; Move to local stack
	fwait				
	CALLRT	B$FMKD,DispMovSd	

MakeExe exFnMksmbf_,opFnMksmbf_
	sub	sp,4			
	mov	bx,sp			
	fstp	dword ptr DGROUP:[bx]	; Move to local stack
	fwait				
	CALLRT	B$FMSF,DispMovSd	

MakeExe exFnMkdmbf_,opFnMkdmbf_
	sub	sp,8			
	mov	bx,sp			
	fstp	qword ptr DGROUP:[bx]	; Move to local stack
	fwait				
	CALLRT	B$FMDF,DispMovSd	


MakeExe exFnAsc,opFnAsc
	CALLRT	B$FASC,DispAx


MakeExe exFnChr_,opFnChr_

	CALLRT	B$FCHR,DispMovSd	


MakeExe exFnHex_I2,opFnHex_
	pop	bx
	xor	ax,ax
	push	ax			;high word
	push	bx			;push back the low word
	SkipExHeader
MakeExe exFnHex_I4,opFnHex_
	CALLRT	B$FHEX,DispMovSd	

MakeExe exFnInstr2,opFnInstr2
	CALLRT	B$INS2,DispAx

MakeExe exFnInstr3,opFnInstr3
	CALLRT	B$INS3,DispAx


MakeExe exFnLCase_,opFnLCase_
	CALLRT	B$LCAS,DispMovSd	

MakeExe exFnLeft_,opFnLeft_
	CALLRT	B$LEFT ,DispMovSd	


MakeExe exFnLenTyp,opFnLen
	add	sp,4			;Pop the far reference
	LODSWTX 			;fetch cbTyp
PushLength:
	xor	dx,dx			; High word of length is 0
	jmp	DispDxAx		; Push result and dispatch

MakeExe exFnLen,opFnLen
	inc	si		;skip unneeded argument (present only for
	inc	si		;  compatability between executors for opFnLen)
	CALLRT	B$FLEN,DispAx

MakeExe exFnLTrim_,opFnLTrim_
	CALLRT	B$LTRM ,DispMovSd	

MakeExe exFnMid_2,opFnMid_2

	PUSHI	ax,07FFFH		;Max legal string length
	SkipExHeader
MakeExe exFnMid_3,opFnMid_3
	CALLRT	B$FMID,DispMovSd	

MakeExe exFnOct_I2,opFnOct_
	pop	bx
	xor	ax,ax
	push	ax			;High word
	push	bx			;Push back the low word
	SkipExHeader
MakeExe exFnOct_I4,opFnOct_
	CALLRT	B$FOCT,DispMovSd	

MakeExe exFnRight_,opFnRight_
	CALLRT	B$RGHT,DispMovSd	

MakeExe exFnRTrim_,opFnRTrim_
	CALLRT	B$RTRM,DispMovSd	

MakeExe exFnSAdd,opFnSAdd
	CALLRT	B$SADD,DispMovSd	

MakeExe exFnSpace_,opFnSpace_
	CALLRT	B$SPAC,DispMovSd	

MakeExe exFnStr_I2,opFnStr_
	CALLRT	B$STI2,DispMovSd	

MakeExe exFnStr_I4,opFnStr_
	CALLRT	B$STI4,DispMovSd	


MakeExe exFnStr_R4,opFnStr_
;Added with [9]
	sub	sp,4
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]
	fwait
;End of [9]
	CALLRT	B$STR4,DispMovSd	


MakeExe exFnStr_R8,opFnStr_
;Added with [9]
	sub	sp,8
	mov	bx,sp
	fstp	qword ptr DGROUP:[bx]
	fwait
;End of [9]
	CALLRT	B$STR8,DispMovSd	



MakeExe exFnString_I2,opFnString_
	CALLRT	B$STRI,DispMovSd	

MakeExe exFnString_SD,opFnString_
	CALLRT	B$STRS,DispMovSd	

MakeExe exFnUCase_,opFnUCase_
	CALLRT	B$UCAS,DispMovSd	

MakeExe exFnVal,opFnVal
	CALLRT	B$FVAL,DispMovR8




;==============================================================================
;		String Statement Executors
;==============================================================================

MakeExe exPushOp,opNolist1		;Push word operand
	LODSWTX
	jmp	DispAx

MakeExe exStLSetRec,opStLSet		;Record version of LSet
	pop	cx			;cb to copy
	pop	di
	    pop     es
	xchg	ax,si			;Preserve SI in AX
	pop	si
	    pop     ds

	shr	cx,1			;Move by words
	rep	movsw
	adc	cx,cx			;CX = 1 iff CY set
	rep	movsb

	xchg	si,ax			;Restore SI
	    push    ss			;Restore DS
	    pop     ds
	jmp	DispMov 		;Reload ES & DI (DS if SizeD) Dispatch

MakeExe exStLSet,opStLSet
	xor	ax,ax			;last parm = 0 == "SD, not an FS"
	push	ax
	SkipExHeader
MakeExe exStLSetFS,opStLSet
	CALLRT	B$LSET,Disp

;NOTE: Yes, we could reduce the opStMid executors (below) to save a few bytes
;NOTE: if we changed the parser. At this point (at least), the few bytes
;NOTE: arn't worth the calender time to make the change. (Oct. 86)

MakeExe exStMid_2,opStMid_2
	xor	ax,ax
	push	ax		;cbFS = 0 ==> SD, not FS
	SkipExHeader
MakeExe exStMid_FS2,opStMid_2
;!!!! WARNING !!!! The KANJI version of these executors assume that no flags
;!!!! WARNING !!!! are changed from here down to the runtime dispatch.

	pop	es		;pull off cbFS
	pop	di		;pull off (far) target address offset
	pop	bx		;pull off (far) target address seg
	pop	ax		;psdExp must be pulled off an max string length
	mov	cx,07FFFH
StMid_Common:
	pop	dx		;start
	push	bx
	push	di
	push	es		;cxFS
	push	ax		;psdSource
	push	cx		;string length (given or defaulted)
	push	dx		;start
	CALLRT	B$SMID,DispMov	;need the Mov variant, so es can be used below

MakeExe exStMid_3,opStMid_3
	xor	ax,ax
	push	ax		;cbFS = 0 ==> SD, not FS
	SkipExHeader
MakeExe exStMid_FS3,opStMid_3
;!!!! WARNING !!!! The KANJI version of these executors assume that no flags
;!!!! WARNING !!!! are changed from here down to the runtime dispatch.

	pop	es		;pull off cbFS
	pop	di		;pull off (far) target address offset
	pop	bx		;pull off (far) target address seg
	pop	ax		;psdExp must be pulled off an max string length
	pop	cx		;pull off specified string length
	jmp	short StMid_Common

MakeExe exStRset,opStRset
	xor	ax,ax		;last parm = 0 == "SD, not an FS"
	push	ax
	SkipExHeader
MakeExe exStRsetFS,opStRset
	CALLRT	B$RSET,Disp


	;Added with [18]


	;End of [18]

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\lsrules.asm ===
TITLE	LSRULES - functions which map opcodes to 'list-node' structs

;======================================================================
; Module: LsRules.asm
;
; Purpose:
;	Contains functions which map opcodes to their equivalent
;	'list-node' structures.  See lsmain.asm for general comments.
;
;
;=======================================================================*/

	include version.inc
	LSRULES_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce heap		
	includeOnce lister
	includeOnce lsint
	includeOnce opmin
	includeOnce pcode
	includeOnce prsorw
	includeOnce qblist
	includeOnce rtps
	includeOnce scanner

	assumes	CS,LIST
	assumes	DS,DGROUP
	assumes	SS,DGROUP
	assumes	ES,NOTHING

sBegin	DATA
PUBLIC		psdLsIncl
psdLsIncl	dw 0		;pointer to buffer filled by Lr_Include
sEnd	DATA

sBegin	LIST
assumes	CS,LIST


subttl	Literal opcode listers

;------------------------------------------------------------------
;		Literal opcode listers
;------------------------------------------------------------------

; List rule for opcode which encodes I2 literal in high bits of opcode
ListRule LrLitI2
	mov	ax,[opList]		;ax = opcode + high bit operand
	.erre	OPCODE_MASK EQ 03ffh	; Assure SHR/SHR is correct
	mov	al,ah			;al = high-bit operand * 4
	shr	al,1			
	shr	al,1			;al = high-bit operand
	cbw				;ax = high-bit operand
	push	si			;preserve si
	xchg	si,ax			;si = literal number
	mov	ax,LIT_LINENUM*256+2	;ah = LIT_LINENUM, al = 2 (bytes)
	call	NewNum			;ax points to new number node(ax)
	pop	si			;restore si
	jmp	SHORT PushRootStg1	

ListRule LrLitNum
	mov	ax,[mpOpLsArg + bx]	;opcode's argument
	xchg	ah,al
	;al = constant value size (2, 4, or 8)
	;ah = constant type 
	;     (LIT_D2, LIT_O2, LIT_H2,
	;      LIT_D4, LIT_O4, LIT_H4,
	;      LIT_R4, LIT_R8)
	
	call	NewNum			;ax points to new number node(ax)
PushRootStg1:
	call	PushRoot
J0_Stg1Loop:
	jmp	Stg1Loop		;return to outer loop



;	[...] ==> [[" string "] ...]
;	Note:	can't be [" string "] because each expression term must
;		be 1 root node.
;
ListRule LrLitSD
	lods	WORD PTR es:[si]	;ax = cbText
	call	PushRootQStr		;push '"' str_node '"' to root stack
	jmp	Stg1Loop		;push temp list to root as 1 node
					;  and return to outer loop


subttl Remark related list rules

;------------------------------------------------------------------
;		Remark related list rules
;------------------------------------------------------------------

;***************************************************************************
; LrStRem
; Purpose:
;	List the opcode opStRem(cbText, text)
;	[] ==> [text REM]
;
;***************************************************************************
ListRule LrStRem
	call	PushRootOpRw		;push "REM" node to root's stack
LrStRem1:
	lods	WORD PTR es:[si]	;ax = cbText
	or	ax,ax
	je	AtLeast1Spc		;brif cbText = 0
	call	NewEnStr		;ax = offset to new node
	jmp	PushRootStg1		;push node ax to root stack
					; and return to outer loop

;so opStRem(0)op_Static will list as REM $STATIC and not REM$STATIC
;
AtLeast1Spc:
PushRootSpcStg1:
	call	PushRootSpc
	jmp	SHORT J0_Stg1Loop	;return to outer loop

str255Include	DB 11,'$INCLUDE',58d,32d,39d	; $INCLUDE: '
str255Static	DB 7,'$STATIC'
str255Dynamic	DB 8,'$DYNAMIC'

ListRule Lr_Static
	mov	[fLsDynArrays],0	;set static flag for AsciiSave
	mov	ax,LISTOFFSET str255Static
Lr_Static1:
	call	NewCsStr
	call	PushRoot
	jmp	SHORT LrStRem1

ListRule Lr_Dynamic
	mov	[fLsDynArrays],1		;set static flag for AsciiSave
	mov	ax,LISTOFFSET str255Dynamic
	jmp	SHORT Lr_Static1


; List opcode op_Include, which is generated for syntax: $INCLUDE: 'filename'
; If the global variable psdLsIncl is non-zero, copy include filename
; to psdLsIncl->pb and set psdLsIncl->cb.
;
ListRule Lr_Include
	mov	ax,LISTOFFSET str255Include
	call	NewCsStr		;ax = node for ($INCLUDE ')
	call	PushRoot
	lods	WORD PTR es:[si]	;ax = cbText
	cmp	[psdLsIncl],NULL
	je	NoSdLsIncl

;es = segment of text table
;si = offset into text table to string
;ax = length of string (including terminating 0)
	push	si
	push	di

	push	ax
	mov	di,si			;es:di points to string
	mov	cx,-1
	mov	al,27H			;look for terminating '
	repne	scasb
	not	cx			;cx = length including '
	dec	cx			;cx = filename length
	pop	ax

	mov	di,[psdLsIncl]		;di points to destination sd
	mov	[di.SD_cb],cx		;save length of string
	mov	di,[di.SD_pb]		;di points to destination buffer

	push	es
	push	ds
	pop	es			;es = DGROUP
	pop	ds			;ds = text table's segment
	assumes	DS,NOTHING
	rep movsb			;copy string to psdLsIncl's buffer
	push	es
	push	ds
	pop	es			;es = text table's segment
	pop	ds			;ds = DGROUP
	assumes	DS,DGROUP

	pop	di
	pop	si
;si = offset into text table to string
;ax = length of string to push
NoSdLsIncl:
	call	PushString		;ax = node for consumed string operand
	jmp	SHORT J1_Stg1Loop	;return to outer loop

ListRule LrQuoteRem
	lods	WORD PTR es:[si]	;ax = cbText (including column field)
	dec	ax			;don't count column field
	dec	ax
	push	ax			;save it
	lods	WORD PTR es:[si]	;ax = column field
	call	NewCol			;ax = "advance to column(ax)" node
	call	PushRoot		;list it
	mov	al,39			;al = ASCII code for single quote '
	call	PushRootChar		;list '
	pop	ax			;restore ax = size of string
	call	NewEnStr		;ax = offset to new string node
	jmp	PushRootStg1		;push node ax to root stack
					; and return to outer loop

PushString2 PROC NEAR
	dec	ax			;don't count link field
	dec	ax
	inc	si			;skip link field
	inc	si
PushString2 ENDP
	;fall into PushString
PushString PROC NEAR
	call	NewStr			;ax = offset to new node
	jmp	PushRoot		;make it new root of tree
					;return to caller
PushString ENDP

ListRule LrStData
	call	PushRootOpRw		;list DATA
	lods	WORD PTR es:[si]	;ax = cbText (including link field)
	push	ax			;save length
	dec	ax			;don't count 0-terminator
	call	PushString2		;ax = node for consumed string operand
	pop	ax
	and	ax,1			;ax = 1 if string was odd length
	shl	ax,1			;ax = 2 if string was odd length
	add	si,ax			;si points beyond 0-terminator
	jmp	SHORT J1_Stg1Loop	

ListRule LrReParse
	lods	WORD PTR es:[si]	;ax = cbText (including link field)
PushString2Stg1:
	call	PushString2		;ax = node for consumed string operand
J1_Stg1Loop:				
	jmp	Stg1Loop		;return to outer loop

;List rule for SQL source lines. Special processing is needed for
;setting colLsCursor in case of error occuring within the SQL statement.


subttl	Control Flow Opcodes

;------------------------------------------------------------------
;			Control Flow Opcodes
;------------------------------------------------------------------

;	[...] ==> [space ELSE space ...] if single line ELSE
;	[...] ==> [ELSE ...] if block ELSE
;
ListRule LrStElse
	inc	si			;skip link field
	inc	si
ListRule LrStElseNop
	mov	[lsBosFlagsWord],0	;reset beginning of stmt flags
	test	[lsBolFlags],FBOL_GotIf
	jne	GotSingleElse		;brif we've seen an IF opcode
	jmp	LrRwSpc			;just list the ELSE
GotSingleElse:
	; If listing ELSE after :<spaces>, we don't have to emit a space
	; before listing the ELSE reserved word, opBosSp already did.
	
	mov	bx,di			
	add	bx,[bdNodes.BD_pb]	; convert offset to ptr 
	cmp	[bx + LN_type - CBLNT_CHAR],LNT_COL 
	je	NoSpc			; brif opBosSp was just listed
	call	PushRootSpc		;emit blank before reserved word
NoSpc:					
	call	PushRootOpRwSpc		;push opcode's reserved word
	jmp	SHORT J1_Stg1Loop	;return to outer loop

;	[...] ==> [END space <opcode's resword> ...]
;
ListRule LrStEndDef
	inc	si			;skip filler field operand
	inc	si
ListRule LrStEndType
	inc	si			;skip link field operand
	inc	si
ListRule LrStEndIfBlock
ListRule LrStEndSelect
	mov	ax,ORW_END
	call	PushRootRwSpc
	jmp	LrRw			;list TYPE, IF, SELECT
					; and return to outer loop

;	[...] ==> [EXIT space <opcode's resword> ...]
;
ListRule LrStExitDo
ListRule LrStExitFor
	inc	si			;consume oText operand
	inc	si
	mov	ax,ORW_EXIT
	call	PushRootRwSpc
	jmp	LrRw			;list DO or FOR
					; and return to outer loop

;	[exp ...] ==> [[THEN space exp space IF/ELSEIF] ...]
;
IfThen	PROC NEAR
	or	[lsBolFlags],FBOL_GotIf	;set static flag for LrStElse
	call	PushTempOpRwSpc		;push IF/ELSEIF onto temp stack
	call	PopRootPushTemp		;move expNode from root to temp stk
	call	PushTempSpc		;emit blank before THEN
	mov	ax,ORW_THEN
	call	PushTempRwSpc		;push THEN
	call	PushList		;move temp stk to root as 1 node
	ret
IfThen	ENDP

ListRule LrNoList3
	inc	si			;skip operand
	inc	si
ListRule LrNoList2
	inc	si			;skip operand
	inc	si
ListRule LrNoList1
Skip1Stg1:
	inc	si			;skip link field
	inc	si
ListRule LrNoType
ListRule LrNoList
	jmp	SHORT J2_Stg1Loop		;return to outer loop


;	[exp ...] ==> [space [THEN space exp space IF] ...]
;
ListRule LrStIfBlock
ListRule LrStElseIf
ListRule LrStIf
	call	IfThen			;push [[THEN space exp space IF]]
	jmp	SHORT Skip1Stg1		;skip operand
					;return to outer loop


;	[exp ...] ==> [label space [THEN space exp space IF] ...]
;
;	[...] ==> [oNamLabel ...]
;
ListRule LrStIfLab
ListRule LrStIfLabDirect
	call	IfThen			;push [[THEN space exp space IF]]
ListRule LrStElseLab
ListRule LrStElseLabDirect
PushRootLabelStg1:
	call	PushRootLabel		;consume and push <label>
	jmp	SHORT J2_Stg1Loop	;return to outer loop

;	[exp ...] ==> [label space [GOTO space exp space IF] ...]
;
ListRule LrStIfGotoLab
	or	[lsBolFlags],FBOL_GotIf	;set static flag for LrStElse
	call	PushTempOpRwSpc		;push IF onto temp stack
	call	PopRootPushTemp		;move expNode from root to temp stk
	call	PushTempSpc		;emit blank before THEN
	mov	ax,ORW_GOTO
	call	PushTempRw
	call	PushList		;move temp stk to root as 1 node
	call	PushRootSpc
	jmp	SHORT LrStElseLab	;consume and push <label> and
					; return to outer loop

;	[exp ...] ==> [<opcode's resword> space exp ...]
;
ListRule LrEvStop
ListRule LrEvOn
ListRule LrEvOff
	call	PushRootSpc		;emit blank before opcode's res word
	jmp	LrRw			;list opcode's reserved word
					; and return to outer loop

;***************************************************************************
; LrEvGosub
; Purpose:
;	List the opcode opEvGosub(label), for example:
;	opLit1 opEvSignal1 opEvGosub(label)  ==> ON SIGNAL(1) GOSUB label
;	[exp ...]  ==>  [label space [GOSUB space exp space ON] ...]
;
;***************************************************************************
ListRule LrEvGosub
	mov	ax,ORW_ON
	call	PushTempRwSpc		;push ON
	call	PopRootPushTemp		;move expNode from root to temp stk
	call	PushTempSpc		;emit blank before THEN
	call	PushTempOpRw		;push GOSUB onto temp stack
	call	PushList		;move temp stk to root as 1 node
	call	PushRootSpc		;emit blank before label's name
	jmp	short PushRootModLabelStg1	;consume and push <label>
					; and return to outer loop

;	[...]  ==>  [label space GOSUB/GOTO/RESTORE/RESUME/RETURN]
;
ListRule LrRwLabel
ListRule LrStGosub
ListRule LrStGosubDirect
ListRule LrStGoto
ListRule LrStGotoDirect
ListRule LrStReturn1
	call	PushRootOpRwSpc		;push opcode's resword
	jmp	PushRootLabelStg1	;consume and push <label>
					; and return to outer loop

ListRule LrStRunLabel
ListRule LrStRestore1
	call	PushRootOpRwSpc		;push opcode's resword
	jmp	short PushRootModLabelStg1	;consume and push <label>
					; and return to outer loop


; If operand is UNDEFINED, list RESUME 0
; else list RESUME label
;
ListRule LrStResume
	cmp	WORD PTR es:[si],UNDEFINED
	jne	LrRwLabel		;brif not RESUME 0
	call	PushRootOpRwSpc		;list "RESUME "
Goto0:
	inc	si			;skip operand
	inc	si
	mov	al,'0'
	call	PushRootChar
J2_Stg1Loop:
	jmp	Stg1Loop		;return to outer loop

;	[...]  ==>  [label space GOSUB space ERROR space ON]
;
ListRule LrStOnError
	mov	ax,ORW_ON
	call	PushRootRwSpc		;push ON
	call	PushRootOpRwSpc		;push ERROR
	mov	ax,ORW_GOTO
	call	PushRootRwSpc		;push GOTO
PushRootModLabelStg1:
	cmp	WORD PTR es:[si],UNDEFINED
	je	Goto0			;brif ON ERROR GOTO 0
	call	NewModLabel		;ax = module level label node
	call	PushRoot
	jmp	SHORT J2_Stg1Loop	;return to outer loop


;	[exp] ==> [[label, ..., label GOSUB/GOTO exp ON]]
;
ListRule LrStOnGosub
ListRule LrStOnGoto
	mov	ax,ORW_ON
	call	PushTempRwSpc		;push ON
	call	PopRootPushTemp		;move exp from root to temp stack
	call	PushTempSpc		;list space between exp and GOTO/GOSUB
	call	PushTempOpRwSpc		;push GOTO/GOSUB
	lods	WORD PTR es:[si]	;ax = byte count of label args
	shr	ax,1			;ax = count of label args
	mov	[cLsArgs],al		;setup for call to PushCommaArgs
					; (guarenteed by parser to be > 0)
	xchg	cx,ax			;cx = count of label args
EmitLabLoop:
	push	cx			;save count of label args
	call	PushRootLabel		;consume and push <label>
	call	GrowBdNodes		;grow list buffer if necessary
					; preserves cx
	pop	cx			;restore count of label args
	je	OnGosubExit		;brif out-of-memory - We'll abort
					; ListLine next time through Stg1Loop
	loop	EmitLabLoop		;repeat for each label in list
	call	PushCommaArgs		;move labels from root to temp
					; stack, inserting commas
OnGosubExit:
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[exp ...]  ==>  [[exp space CASE space SELECT] ...]
;
ListRule LrStSelectCase
	call	PushTempOpRwSpc		;push SELECT onto temp stack
	mov	ax,ORW_CASE
	call	PushTempRwSpc		;push ON
	call	PopRootPushTemp		;move expNode from root to temp stk
	inc	si			;skip operand
	inc	si
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;***************************************************************************
; PushCaseOrComma
; Purpose:
;	1st opCase in a statement gets mapped to CASE,
;	all subsequent ones get mapped to ','.
;
;***************************************************************************
PushCaseOrComma PROC NEAR
	mov	ax,ORW_CASE
	jmp	PushTempRwOrComma
PushCaseOrComma ENDP

;	[exp2 exp1 ...]  ==>  [[exp2 space TO space exp1 space CASE]]
;
ListRule LrStCaseTo
	call	PushCaseOrComma		;emit CASE space or ',' space
	call	PopRoot			;ax = exp2
	push	ax			;save it for later
	call	PopRootPushTemp		;move exp1 from root to temp stk
	call	PushTempSpc
	call	PushTempOpRwSpc		;list opcode's resword (TO)
	pop	ax			;ax = exp1
	call	PushTemp
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[...]  ==>  [ELSE space CASE ...]
;
ListRule LrStCaseElse
	call	PushRootOpRwSpc		;list opcode's resword (CASE)
	mov	ax,ORW_ELSE
PushRootRwStg1:
	call	PushRootRw		;list ELSE
	jmp	Stg1Loop		;return to outer loop

;	[exp ...]  ==>  [[exp space CASE ...]]
;
ListRule LrStCase
	call	PushCaseOrComma		;emit CASE space or ',' space
	call	PopRootPushTemp		;move expNode from root to temp stk
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[exp ...]  ==>  [[exp space <relation> space IS space CASE]]
;
ListRule LrStCaseRel
	call	PushCaseOrComma		;emit "CASE " space or ", " to temp stk
	mov	ax,ORW_IS
	call	PushTempRwSpc		;list "IS "
	call	PushTempOpChars		;list opcode's char(s)
	call	PushTempSpc		;surround operator with blanks
	call	PopRootPushTemp		;move expNode from root to temp stk
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

	
;	[exp ...]  ==>  [[exp space WHILE/UNTIL space DO]]
;
ListRule LrStDoWhile
ListRule LrStDoUntil
	mov	ax,ORW_DO
	call	PushTempRw		;list DO
LrStLoop1:
	call	PushTempSpc
	call	PushTempOpRwSpc		;list WHILE or UNTIL
	call	PopRootPushTemp		;move expNode from root to temp stk
	inc	si			;skip oText operand
	inc	si
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[exp ...]  ==>  [[exp space WHILE/UNTIL space LOOP]]
;
ListRule LrStLoopUntil
ListRule LrStLoopWhile
	mov	ax,ORW_LOOP
	call	PushTempRw		;list LOOP
	jmp	SHORT LrStLoop1		;share code with DO

;	[exp3 exp2 exp1 id ...]  ==>  [[exp3 STEP exp2 TO exp1 = id FOR]]
;
ListRule LrStForStep
	call	PopRootPushTemp		;move exp3 from root to temp stk
	call	PushTempSpc
	mov	ax,ORW_STEP
	call	PushTempRwSpc		;list STEP
	;fall into LrStFor
;	[exp2 exp1 id ...]  ==>  [[exp2 TO exp1 = id FOR]]
;
ListRule LrStFor
	add	si,4			;skip oBP, oText operands
	call	PopRootPushTemp		;move exp2 from root to temp stk
	call	PushTempSpc
	mov	ax,ORW_TO
	call	PushTempRwSpc		;list TO
	call	PopRootPushTemp		;move exp1 from root to temp stk
	call	PushTempSpc
	mov	ax,'= '
	call	PushTempChars		;list ' ='
	call	PopRootPushTemp		;move id node from root to temp stk
	call	PushTempSpc
	call	PushTempOpRw		;list FOR
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop

;  [...]  ==>  [NEXT ...]
;
ListRule LrStNext
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	NotExecute
	call	PopRoot			;discard offset to id node (it was
					; synthetically generated by scanner,
					; will be removed by SsDescan()
NotExecute:
	add	si,4			;skip oBP and oText operands
	jmp	short LrRw		;list NEXT
					; and return to outer loop

;  [id ...]  ==>  [id NEXT ...]
;
ListRule LrStNextId			;advance past oBP, oText operands
	inc	si			;skip oBP operand
	inc	si
ListRule LrStWhile			;advance past oText operand
	inc	si			;skip oText operand
	inc	si
ListRule LrStRead
	call	PushTempOpRwOrComma	;push opcode's reserved word (or comma)
					;followed by a space
	jmp	short PopPushPushListStg1	;list exp and return to Stg1Loop

;  [...]  ==>  [LOOP/WEND ...]
;
ListRule LrStLoop
ListRule LrStWend
	inc	si			;skip link field
	inc	si
	jmp	short LrRw		;list LOOP or WEND
					; and return to outer loop

;	[...]  ==>  [NEXT space RESUME ...]
;
ListRule LrStResumeNext
	call	PushRootOpRwSpc		;list RESUME
	mov	ax,ORW_NEXT
	jmp	PushRootRwStg1		;list NEXT
					;return to outer loop

subttl	Generic opcode listers

;------------------------------------------------------------------
;			Generic opcode listers
;------------------------------------------------------------------

;***************************************************************************
; LrRw
; Purpose:
;	[...]  ==>  [resWord ...]
;
;***************************************************************************
ListRule LrRw
	call	PushRootOpRw		;push opcode's reserved word
	jmp	Stg1Loop		;return to outer loop

;	[...]  ==>  [space <opcode's resword> ...]
;
ListRule LrRwSpc
	call	PushRootOpRwSpc		;push opcode's reserved word
	jmp	Stg1Loop		;return to outer loop

;***************************************************************************
; LrChar
; Purpose:
;	[...]  ==>  [char ...]
;
;***************************************************************************
ListRule LrChar
	mov	ax,[mpOpLsArg + bx]	;ax = char(s) to be listed
PushRootCharsStg1:
	call	PushRootChars		;push char(s) to be listed to root stack
	jmp	Stg1Loop		;return to outer loop

;***************************************************************************
; LrRwExp1
; Purpose:
;	[exp]  ==>  [[exp space resWord]]
;	Examples include opStChain, opStRandomize1, opNot
;
;***************************************************************************
ListRule LrRwExp1
	call	PushTempOpRwSpc		;push opcode's reserved word
					;followed by a space
PopPushPushListStg1:
	call	PopRootPushTemp		;move expNode from root to temp stk
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;***************************************************************************
; LrUnaryChar
; Purpose:
;	[exp]  ==>  [[exp char]]
;
;***************************************************************************
ListRule LrUnaryChar
ListRule LrUnaryOp
	call	PushTempOpChars
	jmp	SHORT PopPushPushListStg1 ;list exp and return to outer loop

;	[exp2 exp1 ...]  ==>
;	 [exp2 space comma exp1 space comma <opcode's resword>]
;
ListRule LrStSwap
	inc	si			;consume opStSwap's operand
	inc	si
ListRule LrRwExp2
	mov	[cLsArgs],2
ListStmtArgs:
	call	PushTempOpRwSpc		;push opcode's reserved word
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[exp3 exp2 exp1 ...]  ==>
;	 [exp3 space comma exp2 space comma exp1 space comma <opcode's resword>]
;
ListRule LrRwExp3
	mov	[cLsArgs],3
	jmp	SHORT ListStmtArgs

;***************************************************************************
; LrFunc1Arg
; Purpose:
;	[exp]  ==>  [[")" exp "(" resWord]]
;
;***************************************************************************
ListRule LrFnLen
ListRule LrFnVarptr_
	inc	si			;skip size operand
	inc	si
ListRule LrFunc1Arg
	mov	[cLsArgs],1
ListFuncArgs:
	call	PushTempOpRw		;push opcode's reserved word
ListFuncArgs2:
	call	PushTempLParen		;push '(' onto temp stack
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	call	PushTempRParen		;push ')' onto temp stack
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrFunc2Args
	mov	[cLsArgs],2
	jmp	SHORT ListFuncArgs

ListRule LrFunc3Args
	mov	[cLsArgs],3
	jmp	SHORT ListFuncArgs



mptypRwCoerce	equ	$-2		
	dw	ORW_CInt		; I2
	dw	ORW_CLng		; I4
	    dw	    ORW_CSng		; R4
	dw	ORW_CDbl		; R8


ListRule LrCoerce			
	mov	[cLsArgs],1
	mov	bl,byte ptr [opList+1]	; BL = ET type * 4 + garbage
	.erre	OPCODE_MASK EQ 03ffh	; Assure SHR is correct
;	and	bx,HIGH (NOT OPCODE_MASK)
	and	bx,0FCh 		
	shr	bx,1			; BX = ET type * 2
	mov	ax,word ptr mptypRwCoerce[bx]	; Translate to reserved word
	call	PushTempRw		; Push opcode's reserved word
	jmp	short ListFuncArgs2	


	;Start of [22]


	;End of [22]



subttl	Misc opcode listers

;------------------------------------------------------------------
;			Misc opcode listers
;------------------------------------------------------------------

ListRule LrScanStop
	DbHalt	LIST,<Illegal opcode found in ListLine>

;Emitted to indicate defaulted parm - lists as nothing
ListRule LrUndef
	mov	ax,100h
	SKIP2_PSW
ListRule LrNull
	sub	ax,ax
	jmp	PushRootCharsStg1	;list null
					;return to outer loop



tOrwKey LABEL WORD
	DW	ORW_OFF
	DW	ORW_ON
	DW	ORW_LIST

ListRule LrStKey
	call	PushRootOpRwSpc		;list KEY
	lods	WORD PTR es:[si]	;ax = 0,1,2 for ON,OFF,LIST
	shl	ax,1
	xchg	bx,ax			;bx = index into tOrwKey
	mov	ax,[tOrwKey+bx]		;ax = ON,OFF,LIST
	jmp	PushRootRwStg1		;list it
					;return to outer loop


PushDefSeg PROC NEAR
	call	PushRootOpRwSpc		;list DEF
	mov	ax,ORW_SEG
	jmp	PushRootRwSpc		;list SEG
					; and return to caller
PushDefSeg ENDP

ListRule LrStDefSeg1
	call	PopRootPushTemp
	call	PushDefSeg		;list "DEF SEG "
	mov	ax,' ='
	call	PushRootChars		;list "= "
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrStDefSeg0
	call	PushDefSeg		;list "DEF SEG "
J3_Stg1Loop:
	jmp	Stg1Loop		;return to outer loop


ListRule LrStOptionBase0
ListRule LrStOptionBase1
	mov	ax,ORW_OPTION
	call	PushRootRwSpc		;list OPTION
	mov	ax,ORW_BASE
	call	PushRootRwSpc		;list BASE
	call	PushRootOpChars		;list opcode's char ('0' or '1')
	jmp	Stg1Loop		;return to outer loop

;***************************************************************************
; LrStWidthLprint
; Purpose:
;	[exp]  ==>  [[exp LPRINT WIDTH]]
;
;***************************************************************************
ListRule LrStWidthLprint
	call	PushTempOpRwSpc		;list WIDTH
	mov	ax,ORW_LPRINT
	jmp	SHORT Palette1		;list LPRINT exp, return to outer loop

ListRule LrStPaletteUsing
	call	PushTempOpRwSpc		;list PALETTE
	mov	ax,ORW_USING
Palette1:
	call	PushTempRwSpc		;list USING
Palette2:
	jmp	PopPushPushListStg1	;list exp and return to outer loop


;	[exp]  ==>  [[exp = DATE$/TIME$]]
;
ListRule LrStDate_
ListRule LrStTime_
	call	PushTempOpRwSpc		;list DATE$/TIME$
	mov	ax,' ='
	call	PushTempChars		;list '= '
	jmp	PopPushPushListStg1	;list exp and return to outer loop


;***************************************************************************
; LrStLocate
; Purpose:
;	List a statement like CLEAR or LOCATE which takes a variable number
;	of optional arguments.
;	[exp, ..., exp]  ==>  [[exp, ... LOCATE]]
;	For example, if the stmt was SCREEN ,,x,y
;	    the pcode would be:
;	       opLit0 opLit0 opIdLd(x) opLit1 opIdLd(y) opLit1 opStScreen
;	    and the root stack on entry would have:
;	       [1 y 1 x 0 0]
;	    On exit, the root stack would have:
;	       [y "," x "," "," LOCATE]
;
;***************************************************************************
ListRule LrStLocate
ListRule LrStScreen
ListRule LrStColor
ListRule LrStClear
	call	PushTempOpRwSpc		;push opcode's resword
	lods	WORD PTR es:[si]	;ax = number of arguments
	mov	[cLsArgs],al
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	jmp	PushListStg1		;move temp stk to root
					; and return to outer loop
ListRule LrStClose
	lods	WORD PTR es:[si]	;ax = number of arguments
	mov	[cLsArgs],al
	jmp	ListStmtArgs		;pop statement args and list with ", "

;	[exp var]  ==>  [[exp = var LSET/RSET]]
;
ListRule LrStRset
ListRule LrStLset
	call	PushTempOpRwSpc		;push opcode's resword (LSET/RSET)
	call	PopRootPushTemp		;move var node from root to temp stk
	mov	ax,'= '
	call	PushTempChars		;list ' ='
	call	PushTempSpc
	call	PopRootPushTemp		;move expNode from root to temp stk
	jmp	PushListStg1		;move temp stk to root as 1 node
					; and return to outer loop

;	[exp4 exp3 exp2 lval]  ==>  [exp4 = (exp3, exp2, lval) MID$]
;	[exp3 exp2 lval]  ==>  [exp3 = (exp2, lval) MID$]
;
ListRule LrStMid_2
	mov	[cLsArgs],1
	jmp	SHORT MidCont
ListRule LrStMid_3
	mov	[cLsArgs],2
MidCont:
	call	PopRoot			;ax = lval node
	xchg	cx,ax			;cx = lval node
	call	PopRoot			;ax = exp4 node
	push	ax			;save exp4 node
	push	cx			;save lval node
	call	PushTempOpRw		;list "MID$"
	call	PushTempLParen		;push '(' onto temp stack
	pop	ax			;ax = lval node
	call	PushTemp		;list lval node
	call	PushTempCommaSpc	;list ", "
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	call	PushTempRParen		;push ')' onto temp stack
	call	PushTempSpc
	mov	ax,' ='
	call	PushTempChars		;list '= '
	pop	ax			;ax = exp4 node
	call	PushTemp		;push it to temp stack	
	jmp	PushListStg1		;move temp stk to root as 1 node
					; and return to outer loop

;	[exp2 exp1]  ==>  [[exp2 AS exp1 NAME]]
;
ListRule LrStName
	call	PopRootPushTemp		;move exp2 node from root to temp stk
	call	PushTempSpc
	mov	ax,ORW_AS
	call	PushTempRwSpc		;list AS
	call	PopRootPushTemp		;move var node from root to temp stk
	call	PushTempSpc
	call	PushTempOpRw		;push opcode's resword
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop



;These constants reside in rtps.inc
;FINP_QSupress	EQU 1	;set if "prompt" was followed by a comma,
;			;not a semicolon, indicating "? " is not to be
;			;output after prompt.
;FINP_CrLf	EQU 2	;set if INPUT was followed by optional ";",
;			;meaning CrLf is not to be output when user
;			;presses return.
;FINP_Prompt	EQU 4	;set if the optional SDPrompt argument is included.


;   [ id optionalPromptExp chan]  ==>  [ id optionalPromptExp chan INPUT LINE]
;
;   [ id optionalPromptExp]  ==>  [ id optionalPromptExp INPUT LINE]
;
;   [ optionalPromptExp ]  ==>  [ optionalPromptExp INPUT ]
;
ListRule LrStLineInput
	call	PopRoot			;ax = offset to id node
	push	ax			;save it
	mov	ax,ORW_LINE
	call	PushTempRwSpc		;list "LINE "
	lods	WORD PTR es:[si]	;ax = FINP_xxx mask
	mov	cl,al			;al = FINP_xxx mask
	call	DoInputPrompt		;list "INPUT ..."
	test	[lsBosFlags],FBOS_Channel
	je	NoChan1			;brif not LINE INPUT #n,
	call	PopPushCommaSpc		;move #chan to temp stack
					;list ", "
NoChan1:
	pop	ax			;ax = offset to id node
	call	PushTemp		;list id node
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrInputPrompt
	lods	WORD PTR es:[si]	;ax = byte count of opcode's operand
	inc	ax			;round up to even byte count
	and	al,0FEH
	mov	cl,BYTE PTR es:[si]	;cl = FINP_xxx mask
	add	si,ax			;advance si beyond opInputPrompt
	call	DoInputPrompt
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;cl = FINP_xxx mask
DoInputPrompt PROC NEAR
	call	PushTempOpRwOrComma	;list "INPUT ", and set flag so
					; opStInput lists as ", "
	or	[lsBosFlags],FBOS_InputPrompt
					;tell LrStInput not to list INPUT
	test	cl,FINP_CrLf
	je	No_CrLf			;brif INPUT not followed by 
	mov	al,';'
	call	PushTempCharSpc		;list "; "
No_CrLf:				;brif INPUT not followed by 
	test	cl,FINP_Prompt
	je	No_Prompt		;brif INPUT not followed by "prompt"
	call	PopRootPushTemp		;move "prompt" from temp to root stack
	mov	al,';'
	test	cl,FINP_QSupress
	je	No_QSupress		;brif prompt not followed by ,
	mov	al,','
No_QSupress:
	call	PushTempCharSpc		;list "; " or ", "
No_Prompt:
	ret
DoInputPrompt ENDP

;	[exp chan]  ==>  [exp ,chan# INPUT]
;	[exp]  ==>  [exp INPUT]
;	[exp]  ==>  [exp ,]
;
ListRule LrStInput
	test	[lsBosFlags],FBOS_InputPrompt
	jne	NoInpPrompt		;brif opInputPrompt has already
					; been scanned in this stmt
	call	PopRoot			;ax = offset to exp node
	push	ax
	call	PushTempOpRwOrComma	;list "INPUT " or ", "
	test	[lsBosFlags],FBOS_Channel
	je	NoChan			;brif not INPUT #n,
	and	[lsBosFlags],0FFH - FBOS_Channel
	call	PopPushCommaSpc		;move #chan to temp stack
					;list ", "
NoChan:
	pop	ax			;ax = offset to exp node
	call	PushTemp		;list it
	jmp	PushListStg1		;push temp list to root
					; and return to outer loop

NoInpPrompt:
	and	[lsBosFlags],0FFH - FBOS_InputPrompt
	jmp	Stg1Loop


;	[expLast exp1st expFileNum] ==>
;	 [expLast TO expFirst , expFileNum LOCK/UNLOCK]
;	or if LOCK_1stToLast bit is not set in operand:
;	[expFileNum] ==> [expFileNum LOCK/UNLOCK]
;
ListRule LrStLock
ListRule LrStUnLock
	lods	WORD PTR es:[si]	;ax = operand for opStLock/opStUnlock
.errnz	LOCK_1stToLast AND 0FF00H	;if error, test ah
	test	al,LOCK_1stToLast	
	je	LockAll			;brif no 1st/last arg
	xchg	cx,ax			;cx = operand
	test	ch,LOCK_DefLastArg/256
	jne	DefLastArg		;brif last arg was defaulted
	call	PopRoot			;ax = offset to expLast node
.errnz	LOCK_DefLastArg AND 0FFH	;if error, test cl
	call	PushTemp		;push expLast to temp stack
	call	PushTempSpc
	mov	ax,ORW_TO
	call	PushTempRw		;list TO
DefLastArg:
	call	PopRoot			;ax = offset to exp1st node
.errnz	LOCK_Def1stArg AND 0FFH		;if error, test cl
	test	ch,LOCK_Def1stArg/256
	jne	Def1stArg		;brif 1st arg was defaulted
	push	ax			;save exp1st
	call	PushTempSpc		;list a SPACE between TO and exp1st
	pop	ax			;ax = exp1st
	call	PushTemp		;push exp1st to temp stack
Def1stArg:
	call	PushTempCommaSpc	;list ", "
LockAll:
	call	PopRootPushTemp		;move filenum from root to temp stk
	call	PushTempSpc
	call	PushTempOpRw		;list LOCK/UNLOCK
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop

;	[exp3 exp2 exp1] ==> [exp3 , exp2 , exp1 OPEN]
;
ListRule LrStOpenOld3
	mov	al,3			;list 3 expressions separated by ", "
	jmp	SHORT ListExps

;	[exp4 exp3 exp2 exp1] ==> [exp4, exp3, exp2, exp1 OPEN]
;
ListRule LrStOpenOld4
	mov	al,4
ListExps:
	mov	[cLsArgs],al		;setup for call to PushCommaArgs
	call	PushTempOpRwSpc		;list OPEN
	call	PushCommaArgs		;list open arguments
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

MASK_INPUT	EQU 01H
MASK_OUTPUT	EQU 02H
MASK_APPEND	EQU 04H
MASK_RANDOM	EQU 08H
MASK_BINARY	EQU 10H
MASK_FOR	EQU 20H
tRwMode:
	DW  ORW_INPUT, ORW_OUTPUT, ORW_APPEND, ORW_RANDOM, ORW_BINARY, ORW_FOR

MASK_WRITE	EQU 01H
MASK_READ	EQU 02H
MASK_SHARED	EQU 04H
MASK_LOCK	EQU 08H
MASK_ACCESS	EQU 10H
tRwAccess:
	DW	ORW_WRITE, ORW_READ, ORW_SHARED, ORW_LOCK, ORW_ACCESS

;This table says, if <mode> == MD_SQI, list FOR INPUT,
;                 if <mode> == MD_SQO, list FOR OUTPUT, etc.
tMaskMode:
	DB	MD_SQI, MASK_INPUT  + MASK_FOR
	DB	MD_SQO, MASK_OUTPUT + MASK_FOR
	DB	MD_APP, MASK_APPEND + MASK_FOR
	DB	MD_RND, MASK_RANDOM + MASK_FOR
	DB	MD_BIN, MASK_BINARY + MASK_FOR
	DB	0	;end of list

;This table says, if <access> == ACCESS_BOTH, list READ WRITE, etc.
tMaskAccess:
	DB	ACCESS_READ, MASK_ACCESS + MASK_READ
	DB	ACCESS_WRITE, MASK_ACCESS + MASK_WRITE
	DB	ACCESS_BOTH, MASK_ACCESS + MASK_WRITE + MASK_READ
	DB	0	;end of list

;This table says, if <lock> == LOCK_BOTH, list LOCK READ WRITE, etc.
tMaskLock:
	DB	LOCK_READ, MASK_READ + MASK_LOCK
	DB	LOCK_WRITE, MASK_WRITE + MASK_LOCK
	DB	LOCK_BOTH, MASK_WRITE + MASK_READ + MASK_LOCK
	DB	LOCK_SHARED, MASK_SHARED
	DB	0	;end of list

;*************************************************************************
; OutRwMask
; Purpose:
;	Output 1 or more reserved words based on a mask value and tables
; Entry:
;	al = value to search for
;	bx = offset to ORW_xxx table (in cs:)
;	dx = offset to mask table (in cs:)
;
;*************************************************************************
OutRwMask PROC NEAR
	push	si			;save caller's si
	push	cx			;save caller's cx
	mov	cl,al			;cl = mode we're looking for
	mov	si,dx			;si points to mask table (in cs)
OpnMdLoop:
	lods	BYTE PTR cs:[si]	;al = comparison value
	or	al,al
	je	OpnMdExit		;brif end of table
	cmp	al,cl
	lods	BYTE PTR cs:[si]	;al = mask of res words to output
	jne	OpnMdLoop		;brif al is not value of interest (cl)
	mov	cl,al			;cl = mask of res words to output
	mov	si,bx			;si points to ORW_xxx table (in cs)
OpnRwLoop:
	or	cl,cl
	je	OpnMdExit		;brif end of reserved word mask
	lods	WORD PTR cs:[si]	;ax = ORW_xxx to be listed
	shr	cl,1
	jnc	OpnRwLoop		;brif this res word not to be listed
	call	PushTempRwSpc		;list it
	jmp	SHORT OpnRwLoop

OpnMdExit:
	pop	cx
	pop	si
	ret
OutRwMask ENDP

;	[exp3 exp2 exp1] ==> [exp3 = LEN, exp2 AS <mode> FOR exp1 OPEN]
;
ListRule LrStOpen3
	call	PopRootPushTemp		;move exp3 node from root to temp stk
	mov	ax,' ='
	call	PushTempChars		;list "= "
	call	PushTempSpc
	mov	ax,ORW_LEN
	call	PushTempRwSpc		;list "LEN "
	;fall into LrStOpen2
;	[exp2 exp1] ==> [exp2 AS <mode> FOR exp1 OPEN]
;
ListRule LrStOpen2
	call	PopRootPushTemp		;move exp2 node from root to temp stk
	call	PushTempSpc		;list " "
	mov	ax,ORW_AS
	call	PushTempRwSpc		;list "AS "
	lods	WORD PTR es:[si]	;ax = opStOpen's operand
	xchg	cx,ax			;save copy in cx

	mov	al,ch			;al = access/locking bits
	and	al,0F0H			;al = locking bits
	mov	bx,LISTOFFSET tRwAccess
	mov	dx,LISTOFFSET tMaskLock
	call	OutRwMask		;list LOCK READ/WRITE/READ WRITE  or
					;     SHARED

	mov	al,ch			;al = access/locking bits
	and	al,0FH			;al = access bits
	mov	bx,LISTOFFSET tRwAccess
	mov	dx,LISTOFFSET tMaskAccess
	call	OutRwMask		;list ACCESS READ/WRITE/READ WRITE

	mov	al,cl			;al = mode bits
	mov	bx,LISTOFFSET tRwMode
	mov	dx,LISTOFFSET tMaskMode
	call	OutRwMask		;list FOR INPUT/OUTPUT/APPEND/
					;         RANDOM/BINARY

	call	PopRootPushTemp		;move exp1 node from root to temp stk
	call	PushTempSpc
	call	PushTempOpRw		;list "OPEN"
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop

; source: FIELD #1 ...
; pcode: opLit1 opLbs opFieldInit ...
;	[ expChan ...] ==> expChan FIELD]
;
ListRule LrFieldInit
	call	PopRootPushTemp		;copy #n to temp stack
	call	PushRootOpRwSpc		;list "FIELD "
	jmp	PushRevListStg1 	;return to outer loop
	

; source: , a as b, c as d
; pcode: opId(a) opId(b) opFieldItem opId(c) opId(d) opFieldItem
;	[ idAs2 expCnt2 ] ==> [idAs2 AS expCnt2 ,]
;
ListRule LrFieldItem
	call	PopRootPushTemp		;copy idAsN to temp stack
	call	PushTempSpc		;list " "
	call	PushTempOpRwSpc		;list "AS "
	call	PopPushCommaSpc		;copy expCntN to temp stack
					;list ", "
	jmp	PushRevListStg1		;return to outer loop


;	opStGetRec2: [exp2 exp1]  ==>  [exp2,,exp1 GET]
;	opStGetRec3: [exp3 exp2 exp1]  ==>  [exp3,exp2,exp1 GET]
;	opStPutRec2: [exp2 exp1]  ==>  [exp2,,exp1 PUT]
;	opStPutRec3: [exp3 exp2 exp1]  ==>  [exp3,exp2,exp1 PUT]
;
ListRule LrStGetRec2
ListRule LrStPutRec2
	call	PopPushCommaSpc		;move exp2 node from root to temp stk
					;list ", "
	jmp	SHORT GetPut1

ListRule LrStGetRec3
ListRule LrStPutRec3
	call	PopPushCommaSpc		;move exp3 node from root to temp stk
					;list ", "
	call	PopRootPushTemp		;move exp2 node from root to temp stk
GetPut1:
	call	PushTempCommaSpc	;list ", "
	call	PopRootPushTemp		;move exp1 node from root to temp stk
	call	PushRootOpRwSpc		;list "GET/PUT "
	inc	si			;skip size operand
	inc	si
	jmp	PushRevListStg1 	;move temp stk to root in reverse order
					; and return to outer loop


;	[exp2 exp1] ==> [exp2, exp1 WIDTH]
;
ListRule LrStWidth2
ListRule LrStWidthfile
	call	PopNilExp		;copy exp2 and "," to temp stack
	call	PopRootPushTemp		;copy exp1 from root to temp stk
	call	PushRootOpRwSpc		;list "WIDTH "
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop

;copy exp from root to temp stack
; if exp is opUndef or opNull, don't copy anything to temp stack.
; If an expression is seen, all subsequent calls for this
; statement list at least ", "
;
PopNilExp PROC NEAR
	call	PopRoot			;ax = offset to exp node
	call	ListOffToPtr		;bx = ptr to node ax
	cmp	BYTE PTR [bx.LN_type],LNT_CHAR
	jne	NotNilExp		;brif not nil expression
	cmp	BYTE PTR [bx.LN_val_char],0
	jne	NotNilExp		;brif this arg's value is defaulted
					;i.e. if node produced by opNull or
					;opUndef
	test	[lsBosFlags2],FBOS2_NonNilExp
	je	GotNilExp
	jmp	SHORT NonNilExp

NotNilExp:
	call	PushTemp		;push node ax onto temp stack
	or	[lsBosFlags2],FBOS2_NonNilExp
NonNilExp:
	call	PushTempCommaSpc	;list ", "
GotNilExp:
	ret
PopNilExp ENDP



subttl PRINT related opcodes

;------------------------------------------------------------------
;			PRINT related opcodes
;------------------------------------------------------------------

;-----------------------------------------------------------------------
; Print related opcodes
;
; The statement:
;	PRINT USING a$; x, TAB(5); y
; produces the pcode:
;	(a$)opUsing
;       (x)opPrintItemComma
;       (5)opPrintTab
;       (y)opPrintItemEos
;
;-----------------------------------------------------------------------
	
;push PRINT [#n] to root stack if 1st time this has been called for this stmt
;if FBOS_PrintSemi is set, push "; " to the root stack
;
PushPrintIfBos PROC NEAR
	sub	ax,ax
	test	[lsBosFlags],FBOS_Channel
	je	NoPrintChan		;brif not PRINT #n
	and	[lsBosFlags],0FFH - FBOS_Channel
	call	PopRoot			;ax = channel node
NoPrintChan:
	push	ax			;save 0/channel
	mov	ax,ORW_PRINT
	call	PushStmtRwIfBos
	pop	ax			;ax = 0/channel
	or	ax,ax
	je	NoPrintChan1		;brif no channel
	call	PushRoot		;list channel again (after PRINT)
	call	PushRootCommaSpc	;list ", "
NoPrintChan1:
	test	[lsBosFlags],FBOS_PrintSemi
	je	NoSemi
	and	[lsBosFlags],0FFH - FBOS_PrintSemi
					;tell next PushPrintIfBos not to list 
	mov	al,';'
	call	PushRootCharSpc		;list "; "
NoSemi:
	ret
PushPrintIfBos ENDP

;	[exp]  ==>  [exp [[n #] PRINT]]
;
ListRule LrPrintItemEos
	call	PopRootPushTemp		;move exp from root to temp stack
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrPrintEos
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	jmp	SHORT J4_Stg1Loop	;return to outer loop

;	[exp]  ==>  [; ( exp ) TAB/SPC ]
;
ListRule LrPrintSpc
ListRule LrPrintTab
	call	PushTempOpRw		;list "TAB" or "SPC"
	call	PushTempLParen		;list "("
	call	PopRootPushTemp		;list exp
	call	PushTempRParen		;list ")"
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	or	[lsBosFlags],FBOS_PrintSemi
					;tell next print item's call to
					; PushPrintIfBos to list ";"
					; if no interviening ","
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrPrintSemi
	or	[lsBosFlags],FBOS_PrintSemi
					;tell next print item's call to
					; PushPrintIfBos to list ";"
					; if no interviening ","
J4_Stg1Loop:
	jmp	Stg1Loop		;return to outer loop

;	[...]  ==>  [,]
;
ListRule LrPrintComma
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	call	PushRootOpChars		;list ","
	call	PushRootSpc		;list " "
	and	[lsBosFlags],0FFH - FBOS_PrintSemi
					;tell next PushPrintIfBos not to list 
	jmp	SHORT J4_Stg1Loop	;return to outer loop

;	[exp]  ==>  [,/; exp]
;
ListRule LrPrintItemComma
ListRule LrPrintItemSemi
	call	PopRootPushTemp		;move exp from root to temp stack
	call	PushTempOpChars		;list opcode's char(s) (,/:)
	call	PushTempSpc		;list " "
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;	[exp]  ==>  [; exp USING]
;
ListRule LrUsing
	call	PushTempOpRwSpc		;list "USING "
	call	PopRootPushTemp		;list exp
	mov	al,';'
	call	PushTempCharSpc		;list "; "
	call	PushPrintIfBos		;list PRINT [#n] if appropriate
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop
ListRule LrStLprint
ListRule LrStWrite
	or	[lsBosFlags],FBOS_StmtRw	;remember not to list "PRINT"
	jmp	LrRwSpc			;list "LPRINT " and return to outer loop

ListRule LrInputChan
ListRule LrChanOut
	or	[lsBosFlags],FBOS_Channel ;remember to list [#]n,
	jmp	SHORT J4_Stg1Loop	;return to outer loop


subttl Graphics related pcodes

;------------------------------------------------------------------
;		Graphics related pcodes
;------------------------------------------------------------------

;	[exp2 exp1]  ==>  [( exp1 , exp2) ]
;
ListCoords PROC NEAR
	call	PushTempRParen		;list ")"
	call	PopPushCommaSpc		;move exp2 node from root to temp stack
					;list ", "
	call	PopRootPushTemp		;move exp1 node from root to temp stack
	jmp	PushTempLParen		;list "("
					;and return to caller
ListCoords ENDP

;copy 1st coord to temp stack if any
;
PushPop1stCoord PROC NEAR
	mov	al,'-'
	call	PushTempChar		;list "-" for 2nd coord pair
	test	[lsBosFlags2],FBOS2_1stCoord
	je	No1stCoord		;brif stmt like LINE -(x,y) instead
					; of LINE (x,y)-(x,y)
	call	PopRootPushTemp		;copy [STEP (x,y)] to temp stack
No1stCoord:
	ret
PushPop1stCoord ENDP


;	[exp2 exp1]  ==>  [[) exp2 , exp1 ( -]]
;
ListRule LrCoordSecond
	call	ListCoords		;list (exp1, exp2) to temp stack
	call	PushPop1stCoord		;copy 1st coord to temp stack if any
	jmp	SHORT J2_PushRevListStg1 ;push temp list to root in rev order
					; and return to outer loop

;	[exp2 exp1]  ==>  [[) exp2 , exp1 ( STEP -]]
;
ListRule LrCoordStepSecond
	call	ListCoords		;list (exp1, exp2) to temp stack
	mov	ax,ORW_STEP
	call	PushTempRw		;list "STEP"
	call	PushPop1stCoord		;copy 1st coord to temp stack if any
J2_PushRevListStg1:
	jmp	PushRevListStg1		;push temp list to root in rev order
					; and return to outer loop

;	[exp2 exp1]  ==>  [[) exp2 , exp1 ( STEP]]
;
ListRule LrCoordStep
	call	ListCoords		;list (exp1, exp2) to temp stack
	mov	ax,ORW_STEP
	call	PushTempRw		;list "STEP"
	jmp	SHORT LrCoord1

;	[exp2 exp1]  ==>  [[) exp2 , exp1 (]]
;
ListRule LrCoord
	call	ListCoords		;list (exp1, exp2) to temp stack
LrCoord1:
	or	[lsBosFlags2],FBOS2_1stCoord
	jmp	SHORT J2_PushRevListStg1 ;push temp list to root in rev order
					; and return to outer loop

;*************************************************************************
;LineBfArg
;Purpose:
;	consume [B[F]] arg and list it
;Exit:
;	condition codes: ZERO if no arg was present
;
;*************************************************************************
LineBfArg PROC NEAR
	lods	WORD PTR es:[si]	;ax = [B[F]] arg
	or	ax,ax
	je	LineBfExit		;brif no BF arg
	dec	al
	mov	al,'B'
	je	GotLineB		;brif got B arg
	mov	ah,'F'			;else it must have been BF
GotLineB:
	call	PushTempChars
	or	sp,sp			;set nz exit condition code
LineBfExit:
	ret
LineBfArg ENDP

;	[coord]  ==> [[BF ,,] coord LINE]
;
ListRule LrStLine
	call	LineBfArg		;consume and list [B[F]] arg
	je	LineNoArg		;brif no BF arg
	call	PushTempCommaSpc	;list ", "
	jmp	SHORT LineComma		;list comma and coord arg

;	[color coord]  ==> [[BF,] color , coord LINE]
;
ListRule LrStLineColor
	call	LineBfArg		;consume and list [B[F]] arg
	je	LineArg			;brif no BF arg
	jmp	SHORT LineCommaArg	;list comma, color and coord arg

;	[style coord]  ==> [style , [BF] ,, coord LINE]
;
ListRule LrStLineStyle
	call	PopPushCommaSpc		;move style from root to temp stk
					;list ", " between BF and style
	call	LineBfArg		;consume and list [B[F]] arg
	call	PushTempCommaSpc	;list ", " between color and BF
	jmp	SHORT LineComma		;list comma and coord arg

;	[style color coord]  ==> [style ,[BF], color, coord LINE]
;
ListRule LrStLineStyleColor
	call	PopPushCommaSpc		;move style from root to temp stk
					;list ", "
	call	LineBfArg		;consume and list [B[F]] arg
	jmp	SHORT LineCommaArg	;list color and coord arg

;Table for mapping PUT function to reserved word
tRwPutFunc LABEL WORD
	DW	ORW_OR
	DW	ORW_AND
	DW	ORW_PRESET
	DW	ORW_PSET
	DW	ORW_XOR

;	[array coord]  ==>  [function array coord PUT]
;
;	[color coord]  ==>  [color coord PSET/PRESET]
;
;	[array coord]  ==>  [array coord GET]
;	
;	[coord]  ==>  [coord PSET/PRESET]
;
ListRule LrStGraphicsPut
	lods	WORD PTR es:[si]	;ax = function mask
	shl	ax,1			;ax = function * 2
	js	NoPutFunc		;brif no function specified
					; i.e. if ax was UNDEFINED
	xchg	bx,ax
	mov	ax,tRwPutFunc[bx]	;ax = ORW_OR .. ORW_XOR
	call	PushTempRw		;list OR .. XOR
LineCommaArg:
	call	PushTempCommaSpc	;list ", "
NoPutFunc:
ListRule LrStPresetColor
ListRule LrStPsetColor
ListRule LrStGraphicsGet
LineArg:
	call	PopRootPushTemp		;move color from root to temp stk
LineComma:
	call	PushTempCommaSpc	;list ", "
ListRule LrStPreset
ListRule LrStPset
LineNoArg:
	call	PopRootPushTemp		;move coord from root to temp stk
	call	PushRootOpRwSpc		;list "PSET " or "PRESET "
	jmp	PushRevListStg1		;move temp stk to root in reverse order
					; and return to outer loop


;---------------------------------------------------------------------
; The statement:
;	CIRCLE (x,y),r,c,astart,astop,aspect 
; generates pcode:
;	(x)(y)opCoord
;	(r)(c)
;	(astart)opCircleStart
;	(astop)opCircleEnd
;	(aspect)opCircleAspect
;	opStCircleColor
; where (r)(c) are operands for opStCircleColor
;
;	CIRCLE (x,y),r,,,,aspect
; generates pcode:
;	(x)(y)opCoord
;	(r)
;	opNull opCircleStart
;	(aspect)opCircleAspect
;	opStCircle
;	  NOTE: opCircleEnd not generated because runtime can't tell
;	        opNull from whether user supplied value
;
;---------------------------------------------------------------------

;------------------------------------
;	[expStart]  ==>  [expStart ,]
;
ListRule LrCircleStart
	call	PopRootPushTemp		;copy expStart to temp stack
	call	PushTempCommaSpc	;emit ", "
	or	[lsBosFlags2],FBOS2_Circle1
					;tell LrCircle[Color] that it
					; has a startEndAspect node
	jmp	SHORT J3_PushRevListStg1 ;copy temp stk to root in rev order

;------------------------------------
;	[expEnd [expStart ,]]  ==>  [expEnd ,[expStart ,]]
;
ListRule LrCircleEnd
	or	[lsBosFlags2],FBOS2_Circle2
					;remember we've gotten an opCircleEnd
	call	PopRootPushTemp		;copy expEnd to temp stack
	call	PushTempCommaSpc	;emit ", "
CE_CopyStart:
	call	PopRootPushTemp		;copy [expStart ,] from root to temp
J3_PushRevListStg1:
	jmp	PushRevListStg1		;copy temp stk to root in rev order

;-------------------------------------------
;	[expAspect ]  ==>  [expAspect , , ,]
;		   or
;	[expAspect [expStart ,]]  ==>  [expAspect , ,[expStart ,]]
;		   or
;	[expAspect [expEnd ,[expStart ,]]]  ==>
;	   [expAspect ,[expEnd ,[expStart ,]]]
;
ListRule LrCircleAspect
	call	PopRootPushTemp		;copy expAspect to temp stack
	call	PushTempCommaSpc	;emit ", " between aspect and start
	test	[lsBosFlags2],FBOS2_Circle2
	jne	CE_CopyStart		;brif stmt has opCircleEnd
	call	PushTempCommaSpc	;emit ", " between aspect and start
	jmp	SHORT CE_CopyStart

;----------------------------------------------------
;	[[startEndAspect] expRadius coord]  ==>
;          [[startEndAspect] expRadius ,coord CIRCLE]
;
ListRule LrStCircle
	test	[lsBosFlags2],FBOS2_Circle1
	je	CirCont2		;brif no start/end/aspect args
	jmp	SHORT CirCont1		;copy expAspect from root to temp

;--------------------------------------------------------------
;	[[startEndAspect] expColor expRadius coord]  ==>
;          [[startEndAspect] expColor ,expRadius ,coord CIRCLE]
;
ListRule LrStCircleColor
	test	[lsBosFlags2],FBOS2_Circle1
	je	CirCont1		;brif no start/end/aspect args
	call	PopRootPushTemp		;copy startEndAspect from root to temp
CirCont1:
	call	PopPushCommaSpc		;copy expColor to temp stack
					; or startEndAspect from root to temp
					; if LrStCircle
					;list ", "
CirCont2:
	call	PopPushCommaSpc		;copy expRadius to temp stack
					;list ", "
	call	PopRootPushTemp		;copy coord to temp stack
	call	PushTempSpc
	call	PushTempOpRw		;list CIRCLE
	jmp	SHORT J3_PushRevListStg1 ;move temp stk to root in reverse order


; [exp3 exp2 exp1 coord] ==> [exp3, exp2, exp1, coord PAINT]
;
ListRule LrStPaint
ListRule LrStPaint3
	call	PopNilExp		;copy exp3 and "," to temp stack
ListRule LrStPaint2
	call	PopNilExp		;copy exp2 and "," to temp stack
	call	PopNilExp		;copy exp1 and "," to temp stack
	call	PopRootPushTemp		;copy coord to temp stack
	call	PushTempSpc
	call	PushTempOpRw		;list PAINT
	jmp	SHORT J4_PushRevListStg1 ;move temp stk to root in reverse order

PushCoordPair PROC NEAR
	call	ListCoords		;list (exp4 ,exp3) to temp stack
	mov	al,'-'
	call	PushTempChar		;list "-"
	jmp	ListCoords		;list (exp2 ,exp1) to tmp stack & return
PushCoordPair ENDP

;  [exp6 exp5 exp4 exp3 exp2 exp1]  ==>
;  [exp6 ,exp5 ,(exp4 ,exp3)-(exp2 ,exp1) VIEW]
;
ListRule LrStView
	call	PopNilExp		;copy exp6 and "," to temp stack
	call	PopNilExp		;copy exp5 and "," to temp stack
ListRule LrStWindow
	call	PushCoordPair		;list (exp4 ,exp3)-(exp2 ,exp1)
	call	PushTempSpc
	call	PushTempOpRw		;list VIEW/WINDOW
	jmp	SHORT J4_PushRevListStg1 ;move temp stk to root in reverse order

;  [exp6 exp5 exp4 exp3 exp2 exp1]  ==>
;  [exp6 ,exp5 ,(exp4 ,exp3)-(exp2 ,exp1) SCREEN VIEW]
;
ListRule LrStViewScreen
	call	PopNilExp		;copy exp6 and "," to temp stack
	call	PopNilExp		;copy exp5 and "," to temp stack
ListRule LrStWindowScreen
	call	PushCoordPair		;list (exp4 ,exp3)-(exp2 ,exp1)
	call	PushTempSpc
	mov	ax,ORW_SCREEN
	call	PushTempRwSpc		;list SCREEN
	call	PushTempOpRw		;list VIEW/WINDOW
J4_PushRevListStg1:
	jmp	PushRevListStg1		;move temp stk to root in reverse order

;	[exp2 exp1 ...]  ==>  [exp2 TO exp1 PRINT VIEW ...]
;
;	[...]  ==>  [PRINT VIEW ...]
;
ListRule LrStViewPrint2
	call	PopRootPushTemp		;move exp2 from root to temp stack
	call	PushTempSpc		;list " "
	mov	ax,ORW_TO
	call	PushTempRwSpc		;list "TO "
	call	PopRootPushTemp		;move exp1 from root to temp stack
	call	PushTempSpc		;list " "
ListRule LrStViewPrint0
	mov	ax,ORW_PRINT
	call	PushTempRw		;list "PRINT"
	call	PushRootOpRwSpc		;list "VIEW "
	jmp	SHORT J4_PushRevListStg1 ;move temp stk to root in reverse order
	

sEnd	LIST

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\namdebug.asm ===
TITLE	NamDebug.asm - Name Table manager debug routines
;****************************************************************************
;NamDebug.asm - Name Table Manager debug routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	To provide routines that are useful during the debugging of NamMgr
;	or QBI routines that use the name manager.
;
;    DebChkoNam		DebChkoNam(oNamW)
;		Verify that oNamW is a valid tNam offset.  DebHalt is called
;		if oNamW isn't valid.
;
;    DebChkogNam	DebChkogNam(ogNamW)
;		Same as DebChkoNam, but checks an ogNam instead of an oNam.
;
;    DebChktNam		DebChktNam()
;		Perform a sanity check on tNam.  DebHalt is called if any
;		inconsistency is found in tNam.
;
;    DebChktgNam	DebChktgNam()
;		Perform a sanity check on global tNam.	DebHalt is called if
;		any inconsistency is found in the global tNam.
;
;
;    DebNamTabNoMem	DebNamTabNoMem()
;		This routine is called from within NamMgr.asm whenever an
;		out of memory situation occurs.  DebHalt is then called.
;
;    DebOoNam		DebOoNam(oNamW)
;		To output the ASCII chars of oNamW to stdout.
;
;    DebOogNam		DebOogNam(ogNamW)
;		To output the ASCII chars of ogNamW to stdout.
;
;    DebOtNam		DebOtNam(fOmitNames)
;		To dump tNam to stdout.
;
;    DebOtgNam		DebOtgNam(fOmitNames)
;		To dump global tNam to stdout.
;
;
;****************************************************************************
MODULE_NAME EQU 'NamDebug'

	.xlist
	.list
	.lall


	NAMDEBUG_ASM = 1
	include			version.inc
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\exstmisc.asm ===
page	49,132
	TITLE	exstmisc.asm - misc. statement executors
;***
;exstmisc.asm - statement executors for QBI
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;****************************************************************************

	.xlist
	include		version.inc
EXSTMISC_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	extort
	IncludeOnce	exint
	IncludeOnce	opstmt
	IncludeOnce	opmin
	IncludeOnce	opcontrl
	IncludeOnce	opintrsc
	IncludeOnce	opaftqb4
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	.list

sBegin	DATA
sEnd	DATA

assumes es, NOTHING
assumes ss, DATA

	EXTRN	B$SERR:FAR

sBegin	CODE
assumes cs, CODE

	    extrn   I4ToU2:near



;==============================================================================
;	Error-related Statements
;==============================================================================
MakeExe	exStError,opStError
	;note that error code is on stack here - - -
	CALLRT	B$SERR,DispMov		;Never returns. DispMov variant used
					;just so non-RELEASE case won't have
					;non-RELEASE static data screwed up.
					;Note that calling via ExToRt ensures
					;that grs.GRS_oTxCur is set up for
					;B$IONERR

;==============================================================================
;	Sound-related Statements
;==============================================================================
MakeExe exStBeep0,opStBeep
	    CALLRT  B$BEEP,Disp



MakeExe	exStPlay,opStPlay
	CALLRT	B$SPLY,Disp

MakeExe	exStSound,opStSound
;Added with [11]
	sub	sp,4			;Make room for argument
	mov	bx,sp
	fstp	dword ptr DGROUP:[bx]	;Copy to local stack
	fwait
;End of [11]
	CALLRT	B$SOND,Disp

;==============================================================================
;	Heap-related Statements
;==============================================================================

MakeExe	exStDefSeg0,opStDefSeg0
	CALLRT	B$DSG0,Disp

MakeExe	exStDefSeg1,opStDefSeg1
	call	I4toU2				;coerce I4 addr on stack to a U2
	CALLRT	B$DSEG,Disp

MakeExe	exStPoke,opStPoke
	pop	bx				;preserve value to be poked
	call	I4toU2				;coerce I4 addr on stack to a U2
	push	bx				;(I4toU2 preserves bx)
	CALLRT	B$POKE,Disp


;==============================================================================
;	Math-related Statements
;==============================================================================
MakeExe	exStRandomize0,opStRandomize0
	CALLRT	B$RNZ0,Disp

MakeExe	exStRandomize1,opStRandomize1
;Added with [11]
	sub	sp,8			;Make room for argument
	mov	bx,sp
	fstp	qword ptr DGROUP:[bx]	;Copy to local stack
	fwait
;End of [11]
	CALLRT	B$RNZP,Disp

;==============================================================================
;	READ/DATA Support
;==============================================================================
;NOTE: The actual READ executors are exactly the same as the INPUT executors,
;NOTE: so they share code in exio.asm

;NOTE: The otxFirst field is a pointer to the link field in the first DATA
;NOTE: statement in the module. The otxCur field, however, is a pointer to
;NOTE: the exStData pcode - - - this inconsistency is required by the scanner,
;NOTE: which treats otxFirst as an otx head-of-chain, and otxCur as a 'normal'
;NOTE: otx - - - each of which is updated differently for Edit & CONTinue.
;NOTE: The oLineCur initialization value is 6 bytes to account for the fact
;NOTE: that otxCur points to the exStData pcode.

MakeExe	exStRestore0,opStRestore0
	xor	cx,cx				;remember this is exStRestore0
	jmp	short Restore_Common
MakeExe	exStRestore1,opStRestore1
	DbAssertRel ax,nz,0,CODE,<exStRestore1 finds AX == 0>
	xchg	ax,cx				;cx != 0 indicates exStRestore1
	LODSWTX					;ax = oTx. We want the next READ
						;  to use the first piece of 
						;  data in the first DATA stmt
						;  found subsequent to this oTx
Restore_Common:
	call	GetDataSeg			;set up bx and es (preserves ax)
	mov	di,PTRRS[bx.MRS_data_otxFirst]	; oTx of link field of first DATA
						;  statement
	mov	es,dx				
	jcxz	Restore_Common1			;brif exStRestore0

Walk_Data_Stmts:
	cmp	ax,di
	jbe	Restore_Common1			;brif di contains oTx we want to
						;  restore to
	DbAssertRel di,nz,UNDEFINED,CODE,<exStRestore1 error2>
		;if di == UNDEFINED, the above branch should have been taken
	mov	di,es:[di]			;move to next DATA stmt, if any
	jmp	short Walk_Data_Stmts

Restore_Common1:				;di = oTx to the link field
						;  of a DATA statement
	inc	di
	.errnz	UNDEFINED - 0FFFFH
	jz	Restore_Common2			;brif no DATA statements

	sub	di,5				;di = oTx to exStData
	GETRS_SEG  es				
	mov	PTRRS[bx.MRS_data_otxCur],di	
	mov	PTRRS[bx.MRS_data_oLineCur],6	; offset into current DATA stmt
Restore_Common2:
	jmp	DispMov				;NOTE: just using the 'Mov'
						;NOTE: varient of 'Disp' so that
						;NOTE: DI & ES will get reloaded


;Helper routine for B$IRDPTR and B$IRDPTRUPD, below - - - returns
;  the segment part of the address of mrsCur in ES. Note that DATA statements
;  are NEVER found at proc level, because QBI moves all DATA statements to
;  module level at text insertion.
;Output:
;	dx = segment of current mrs table
;	bx = pMrsCur
;	es = segment of the global Rs table
;Preserves: ax, cx
GetDataSeg  PROC NEAR				
	mov	bx,[grs.GRS_oMrsCur]		
	RS_BASE add,bx				
	GETRS_SEG  es				
	GETSEG	dx,PTRRS[bx.MRS_txd.TXD_bdlText_seg] ;[4][2]
	ret
GetDataSeg  ENDP				

;***
;B$IRDPTR - call back to give far ptr to runtime for next data item to read
;Input:
;	none
;Output: 
;	far ptr to data item in DS:SI
;Destroys:
;	ES
;Exceptions:
;	Runtime error if no more data to be read
;*******************************************************************************
PUBLIC B$IRDPTR
B$IRDPTR	PROC FAR
	mov	bx,[grs.GRS_oMrsCur]		
	RS_BASE add,bx				
	GETRS_SEG es				; es:bx points to mrsCur
	mov	si,PTRRS[bx.MRS_data_otxCur]	
	inc	si
	.errnz	UNDEFINED - 0FFFFH
	jz	Out_Of_Data

	dec	si
	add	si,PTRRS[bx.MRS_data_oLineCur]	; ax now oTx of next item to read
	call	GetDataSeg			; returns seg in dx
	push	dx				
	pop	ds
	RET

Out_Of_Data:
	mov	al,ER_OD			;Out of Data error
	call	RtErrorNoSi			;never returns - runtime error
B$IRDPTR	ENDP

;***
;B$IRDPTRUPD - call back to allow us to update data ptr after a READ occurs
;Input:
;	AL = 0 if last item was just read in current DATA statement, non-zero
;		otherwise
;	BX = Number of bytes 'eaten' by the latest READ.
;Output:
;	current mrs (in the global Rs table) updated with correct data pointer
;Destroys:
;	ES
;*******************************************************************************
PUBLIC B$IRDPTRUPD
B$IRDPTRUPD	PROC FAR
	xchg	ax,cx				;remember if @ end of DATA stmt
	xchg	ax,bx
	mov	bx,[grs.GRS_oMrsCur]		
	RS_BASE add,bx				
	GETRS_SEG  es				
	add	PTRRS[bx.MRS_data_oLineCur],ax	; assume not end of data stmt
	or	cl,cl
	jnz	RTPTRUPD_Exit			;brif not end of DATA stmt

	call	GetDataSeg			;seg address is in dx, Rs seg in es
	mov	ax,bx
	mov	bx,PTRRS[bx.MRS_data_otxCur]	
	DbAssertRel bx,nz,UNDEFINED,CODE,<B$IRDPTRUPD error in exstmisc.asm>
	mov	es,dx				; mrs text seg
	mov	dx,es:[bx+4]			;dx = pointer to link field of
						; next DATA stmt or UNDEFINED
	inc	dx
	.errnz	UNDEFINED - 0FFFFH
	jnz	Not_EndOf_Data			;brif not end of data

	mov	dl,4				;so sub dx,5 will set dx = FFFF
Not_EndOf_Data:
	xchg	ax,bx
	sub	dx,5				;dx = UNDEFINED or pointer to
						;  an exStData pcode
	GETRS_SEG es				
	mov	PTRRS[bx.MRS_data_otxCur],dx	
	mov	PTRRS[bx.MRS_data_oLineCur],6	
RTPTRUPD_Exit:
	RET
B$IRDPTRUPD	ENDP


;==============================================================================
;	SWAP
;==============================================================================

	.errnz	SizeD

MakeExe exStSwap2,opStSwap
	inc	si
	inc	si
	CALLRT	B$SWP2,Disp

MakeExe	exStSwap4,opStSwap
	inc	si
	inc	si
	CALLRT	B$SWP4,Disp

MakeExe	exStSwap8,opStSwap
	inc	si
	inc	si
	CALLRT	B$SWP8,Disp

MakeExe	exStSwapSD,opStSwap
	inc	si
	inc	si
	pop	ax
	pop	bx
	xor	cx,cx
	push	ds
	push	bx
	push	cx
	push	ds
	push	ax
	push	cx
	CALLRT	B$SWPN,Disp

MakeExe	exStSwapTyp,opStSwap
	LODSWTX				;Get size to swap
	pop	dx
	pop	bx
	push	ax			;Add length to arg on stack
	push	bx
	push	dx
	push	ax
	CALLRT	B$SWPN,Disp



	;seg_code = segment address for the CODE segment
	;It can be referenced from any module as follows:

	;	EXTRN	seg_code:abs
	;	mov	ax,SEG seg_code
	
	PUBLIC	seg_code
	seg_code	EQU	SEG B$IRDPTRUPD

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\lsutil.asm ===
TITLE	LSUTIL - utility module of 'lister' component

;======================================================================
; Module: LsUtil.asm - utility module of 'lister' component
; Subsystem:  Lister
; System:  Quick BASIC Interpreter
;
;
;=======================================================================*/

	include 	version.inc
	LSUTIL_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	lsint
	includeOnce	names
	includeOnce	qblist
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	variable

	PERIOD_ID EQU ON		;record.element, not record->element

	assumes DS,DGROUP
	assumes ES,DGROUP
	assumes SS,DGROUP

sBegin	LIST
assumes CS,LIST

subttl	List Node creation functions

;***************************************************************************
; NewChar, NewChars
; Purpose:
;	Create a new LNT_CHAR node
; Entry:
;	[al] = ASCII value for char
;	for NewChars: [ah] = ASCII value for 2nd char to list
;	di = offset to next free byte in bdNodes
; Exit:
;	di is updated
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewChar
NewChar PROC NEAR
	sub	ah,ah			;only 1 char in this node
NewChar ENDP
	;fall into NewChars
PUBLIC	NewChars
NewChars PROC NEAR
	mov	bx,di			;bx = offset to new node (return value)
	add	di,[bdNodes.BD_pb]	;convert offset to ptr
	stosDsWord 0			;set LN_sib field to 0
	stosDsByte LNT_CHAR		;set LN_type field
	stosDsWord ax			;set LN_val_char field
	sub	di,[bdNodes.BD_pb]	;convert ptr to offset
	mov	ax,bx			;return offset to new node
	ret
NewChars ENDP

;***************************************************************************
; NewId
; Purpose:
;	Fetch the next 2 bytes of pcode, which represent an id
;	reference.  If scanState != SS_RUDE, convert this 16 bit
;	module-value-table offset into a name table offset.
;	Produce the following nodes:
;	->[LNT_oNam(oNam)]
; Entry:
;	es:si points to id's oNam or oVar argument
;	di = offset to next free byte in bdNodes
; Exit:
;	si points beyond id's operand
;	di is updated
;	ax = offset to newly created id node
;	bx = oNam
;
;***************************************************************************
;***************************************************************************
; NewONam
; Purpose:
;	Produce the following nodes:
;	->[LNT_oNam(oNam)]
; Entry:
;	ax = oNam operand
;	di = offset to next free byte in bdNodes
; Exit:
;	di is updated
;	ax = offset to newly created id node
;	bx = oNam
;
;***************************************************************************
PUBLIC	NewId
NewId	PROC NEAR
	lods	WORD PTR es:[si]	;ax = operand
	push	es			;save ptr to text table
	push	ax			;push variable's oNam/oVar
	call	ONamOVarRudeOrParse	;get oNam
	pop	es			;restore es
	
	; fall into NewONam		;produce an oNam node
NewId	ENDP
PUBLIC	NewONam
NewONam PROC NEAR
	DbChk	oNam,ax
	mov	dl,LNT_ONAM		;dl = LN_type field
;ax = node's value, dl = node's type
NewNodeDlAx:
	mov	bx,di			;bx = offset to new node (return value)
	add	di,[bdNodes.BD_pb]	;convert offset to ptr
	stosDsWord 0			;set LN_sib field to 0
	stosDsByte dl			;set LN_type field
	stosDsWord ax			;save oNam in LN_val_oNam field
	sub	di,[bdNodes.BD_pb]	;convert ptr to offset
	xchg	ax,bx			;return offset to new node in ax
					;bx = oNam
	ret
NewONam ENDP

;***************************************************************************
; NewRw
; Purpose:
;	Create a new LNT_RW node
; Entry:
;	[ax] = ORW_xxx (offset into res word table for res word to list)
;	di = offset to next free byte in bdNodes
; Exit:
;	di is updated
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewRw
NewRw	PROC NEAR
	mov	dl,LNT_RW		;dl = LN_type field
	jmp	SHORT NewNodeDlAx	;create new node and return offset in ax
NewRw	ENDP


;***************************************************************************
; NewCsStr
; Purpose:
;	Create a new LNT_CSSTR node
; Entry:
;	[ax] = offset into LIST segment to string constant to list
;	di = offset to next free byte in bdNodes
; Exit:
;	di is updated
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewCsStr
NewCsStr PROC NEAR
	mov	dl,LNT_CSSTR		;dl = LN_type field
	jmp	SHORT NewNodeDlAx	;create new node and return offset in ax
NewCsStr ENDP

;***************************************************************************
; NewSpaces
; Purpose:
;	Create a new LNT_SPACES node
; Entry:
;	[ax] = count of spaces
;	di = offset to next free byte in bdNodes
; Exit:
;	di is updated
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewSpaces
NewSpaces PROC NEAR
	mov	dl,LNT_SPACES		;dl = LN_type field
	jmp	SHORT NewNodeDlAx	;create new node and return offset in ax
NewSpaces ENDP

;***************************************************************************
; NewCol, NewCol1
; Entry:
;	ax = column to advance to
; NewCol1 is the same as NewCol, but it always lists at least 1 column,
; even if we're beyond the specified column.
;
;***************************************************************************
PUBLIC NewCol1
NewCol1 PROC NEAR
	or	ah,80h			;always list at least 1 column, even if
					; we're beyond the specified column.
NewCol1 ENDP
PUBLIC NewCol
NewCol PROC NEAR
	mov	dl,LNT_COL		;dl = LN_type field
	jmp	SHORT NewNodeDlAx	;create new node and return offset in ax
NewCol ENDP

;***************************************************************************
; NewStr/NewEnStr/NewLitStr
; Purpose:
;	Consume a string literal and produce a LNT_STR/LNT_ENSTR/LNT_LITSTR node
; Entry:
;	ax = byte count
;	es:si points to 1st byte
; Exit:
;	si is advanced beyond the string constant
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewEnStr
NewEnStr PROC NEAR
	mov	dl,LNT_ENSTR		;produce an encoded string node
	SKIP2_PSW
NewEnStr ENDP

PUBLIC	NewStr
NewStr	PROC NEAR
	mov	dl,LNT_STR		;produce an standard string node

NewStrCommon:
	mov	bx,di			;bx = offset to new node (return value)
	add	di,[bdNodes.BD_pb]	;convert offset to ptr
	mov	cx,ax			;cx = length of string
	sub	ax,ax			;ax = 0
	stosDsWord ax			;set LN_sib field to 0
	stosDsByte dl			;set LN_type field
	stosDsWord cx			;save offset in LN_val_cbStr field
	stosDsWord si			;save count in LN_val_oStr field
	inc	cx			;round up to even byte count
	and	cl,0FEH
	add	si,cx			;skip past string literal
	sub	di,[bdNodes.BD_pb]	;convert ptr to offset
	mov	ax,bx			;return offset to new node
	ret
NewStr	ENDP

;***************************************************************************
; NewNum
; Purpose:
;	Consume a numeric literal and produce a LNT_NUM node
; Entry:
;	al = constant value size (2, 4, or 8)
;	ah = constant type
;	     (LIT_D2, LIT_O2, LIT_H2,
;	      LIT_D4, LIT_O4, LIT_H4,
;	      LIT_R4, LIT_R8,
;	      LIT_LINENUM)
;	if ah = LIT_LINENUM,
;	   si = value of line number (16 bit unsigned number)
;	else
;	   es:si points to 1st byte of value
; Exit:
;	if ah = LIT_LINENUM,
;	   si contains garbage
;	else
;	   si is advanced beyond the string constant
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewNum
NewNum	PROC NEAR
	mov	bx,di			;bx = return value
	add	di,[bdNodes.BD_pb]	;convert offset to ptr
	stosDsWord 0			;set LN_sib field to 0
	stosDsByte LNT_NUM		;set LN_type field
	stosDsWord ax			;set LN_val_cbNum, LN_val_clNum fields
	stosDsWord si			;set LN_val_otxNum
	sub	di,[bdNodes.BD_pb]	;convert ptr to offset
	sub	ah,ah			;ax = size of constant in bytes
	add	si,ax			;advance past constant's value
	mov	ax,bx			;ax = return value (offset to new node)
	ret
NewNum	ENDP

;***************************************************************************
; NewLabel, NewModLabel
; Purpose:
;	Fetch the  next 2 bytes of pcode, which represent a label
;	reference.  If scanState = SS_EXECUTE, convert this 16 bit
;	text offset into a name table offset.  If name mgr says this
;	is a line-number oNam, create an LNT_NUM node, else create an
;	LNT_ONAM node.
; 	NewModLabel is the same, except the referenced label is known
;	to exist in module level code.  This is used to list the statements
;	ON ERROR GOTO <label>,  ON <event> GOSUB <label>,  RESTORE <label>.
; Entry:
;	es:si points to oNam or otx argument
; Exit:
;	si bumped by 2
;	dl = 0 if it was an alphanumeric label, 1 if it was a line number
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC	NewModLabel
NewModLabel PROC NEAR
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	NewLabel		;brif table isn't in execute state
					; in this case, operand is an oNam
	test	[txdCur.TXD_flags],FTX_mrs
	jne	NewLabel		;brif not within a procedure txt tbl

;It would be an error for a procedure to be in SS_EXECUTE state, and
;a module to be in SS_PARSE state, because the procedure could contain
;invalid otx operands to module level code.  Assert this is not the case.
;
DbAssertRelB[mrsCur.MRS_txd.TXD_scanState],e,SS_EXECUTE,LIST,<NewModLabel err1>
	;convert oTxt to module level label's oNam
	lods	WORD PTR es:[si]	;ax = operand
	xchg	bx,ax			;bx = offset to opBolLab's opcode
	push	ds
	mov	ds,[mrsCur.MRS_txd.TXD_bdlText_seg]
					;ds points to module level pcode seg
	mov	ax,[bx + 4]		;ax = opBolLab's oNam operand
	pop	ds
	jmp	SHORT NewLabelONam
NewModLabel ENDP

PUBLIC	NewLabel
NewLabel PROC NEAR
	lods	WORD PTR es:[si]	;ax = operand
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	NewLabelONam		;brif table isn't in execute state
	;convert oTxt to oNam for referenced label
	mov	bx,ax			;bx = offset to opBolLab's opcode
	mov	ax,es:[bx + 4]		;ax = opBolLab's oNam operand
NewLabel ENDP
	;fall into NewLabelONam
;***************************************************************************
; NewLabelONam
; Purpose:
;	Given an oNam which represent a label reference, create
;	an LNT_ONAM node if its an alpha-label, else a LNT_NUM
;	node if its a line-number.
; Entry:
;	ax = oNam for this label
; Exit:
;	dl = 0 if it was an alphanumeric label, 1 if it was a line number
;	ax = offset to newly created node
;
;***************************************************************************
PUBLIC NewLabelONam
NewLabelONam PROC NEAR
	DbChk	oNam,ax
	push	ax			;save oNam
	push	es			;LnOfONam destroys es
	cCall	LnOfONam,<ax>		; ax = linenum or UNDEFINED
					;dl = 1st letter if alpha name
	pop	es			;restore es = text table seg
	inc	ax			;test for UNDEFINED
	je	GotAlphaLabel		;brif not a line number
	pop	dx			;discard stacked oNam
	dec	ax			;ax = linenum
	push	si			;save caller's si
	mov	si,ax			;si = linenum
	mov	ax,LIT_LINENUM * 256 + 2
	call	NewNum			;ax = create LNT_NUM node
	pop	si			;restore caller's si
NlLineNum:
	mov	dl,1			;tell caller its a line number
NlExit:
	ret

;dl = 1st letter of label
GotAlphaLabel:
	pop	ax			;ax = oNam
	push	dx			;preserve 1st letter of label
	call	NewONam 		;ax = new node for this label
	pop	bx
	sub	dx,dx
	cmp	bl,'0'
	jb	NlExit			;brif not line num > 65529
	cmp	bl,'9'
	jbe	NlLineNum		;brif line num > 65529
	jmp	SHORT NlExit
NewLabelONam ENDP

;***************************************************************************
; ListOffToPtr
; Purpose:
;	Convert a node offset to a node ptr.  This means that list rules
;	need not know about bdNodes or include heap.inc
; Entry:
;	ax = offset to node
; Exit:
;	bx = pointer to node
;
;***************************************************************************
;bx = sibbling(bx)
PUBLIC ListSibPtr
ListSibPtr PROC NEAR
	mov	ax,[bx.LN_sib]		;ax = offset to si's sibbling node
ListSibPtr ENDP
	;fall into ListOffToPtr to convert ax from offset to pointer
PUBLIC ListOffToPtr
ListOffToPtr PROC NEAR
	mov	bx,ax			;bx = offset to node
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr
	ret
ListOffToPtr ENDP


subttl	Root and Temp list manipulation functions

;***************************************************************************
; PushRoot
; Purpose:
;	Push a node onto oNodeRoot's list, for example:
;	[x y z]  ==>  [newNode x y z]
; Entry:
;	ax = offset to new root
; Preserves:
;	cx (depended on by some callers)
;
;***************************************************************************
PUBLIC	PushRoot
PushRoot PROC NEAR
	mov	bx,ax			;bx = offset for new root node
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr (new root)
	xchg	ax,[oNodeRoot]		;save offset for new root
					;ax = offset for old root
	mov	LN_sib[bx],ax		;new.sib = old
	ret
PushRoot ENDP

;***************************************************************************
; PopRoot
; Purpose:
;	Pop a node from oNodeRoot's list, for example:
;	[x y z]  ==>  [y z]
; Exit:
;	ax = offset to popped node
;	bx = pointer to the popped node 
;	popped node's LN_sib field is set to NULL
; Preserves:
;	cx (depended on by some callers)
;
;***************************************************************************
PUBLIC	PopRoot
PopRoot PROC NEAR
	mov	ax,[oNodeRoot]		;ax = offset to current root node
					; (return value)
	mov	bx,ax			;bx = offset to current root node
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr
	mov	dx,LN_sib[bx]		;dx points to new root
	mov	[oNodeRoot],dx
	mov	LN_sib[bx],NULL 	;unlink old root
	ret
PopRoot ENDP

;***************************************************************************
; PushTemp
; Purpose:
;	Push a node onto oNodeTemp's list, for example:
;	[x y z]  ==>  [newNode x y z]
; Entry:
;	ax = offset to node to push onto oNodeTemp's stack
;
;***************************************************************************
;***************************************************************************
; PopRootPushTemp
; Purpose:
;	Move 1 node from top of root stack to top of temp stack.
;
;***************************************************************************
PUBLIC PopRootPushTemp
PopRootPushTemp PROC NEAR
	call	PopRoot			;ax = popped node
PopRootPushTemp ENDP
	;fall into PushTemp
PUBLIC	PushTemp
PushTemp PROC NEAR
	mov	bx,ax			;bx = offset for new temp node
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr (new temp)
	xchg	ax,[oNodeTemp]		;save offset for new temp
					;ax = offset for old temp
	mov	LN_sib[bx],ax		;new.sib = old
	ret
PushTemp ENDP

;***************************************************************************
; PushRevList
; Purpose:
;	Push the entire list headed by oNodeTemp as a child-list-node
;	onto oNodeRoot's list, but reverse the order of the temp list first.
;	For example:
;	  before:
;		root: [x y z]  temp: [a b c]
;	  after:
;		root: [[c b a] x y z]  temp: []
; Entry:
;	oNodeTemp = offset to list of nodes to be pushed as a list
;	onto oNodeRoot's stack
;
;***************************************************************************
;***************************************************************************
; PushList
; Purpose:
;	Push the entire list headed by oNodeTemp as a child-list-node
;	onto oNodeRoot's list
;	For example:
;	  before:
;		root: [x y z]  temp: [a b c]
;	  after:
;		root: [[a b c] x y z]  temp: []
; Entry:
;	oNodeTemp = offset to list of nodes to be pushed as a list
;	onto oNodeRoot's stack
;
;***************************************************************************
PUBLIC	PushRevList
PushRevList PROC NEAR
	mov	bx,[oNodeTemp]		;bx = offset to start of temp list
	DbAssertRel bx,ne,0,LIST,<PushRevList: temp stack empty> 
	sub	ax,ax			;prev node = NULL
;bx = offset to current node,
;ax = offset to previous node (if start of list, ax = 0),
;Traverse bx's list to the end, reversing linkage
;
RevListLoop:
	mov	dx,bx			;save cur nodes offset
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr
	mov	cx,LN_sib[bx]		;cx = offset to next node (if any)
	mov	LN_sib[bx],ax		;swap from prev->next to next->prev
	jcxz	RevListDone		;brif we're at the end-of-list
	mov	ax,dx			;ax = offset to prev node
	mov	bx,cx			;bx = offset to current node
	jmp	SHORT RevListLoop

RevListDone:
	mov	[oNodeTemp],dx		;last node is now head of temp list
PushRevList ENDP
	;fall into PushList
PUBLIC	PushList
PushList PROC NEAR
	mov	bx,di			;bx = offset to new node
	add	di,[bdNodes.BD_pb]	;convert offset to ptr
	mov	ax,[oNodeRoot]		;ax = offset for old root
	stosDsWord ax			;store LN_sib field
	stosDsByte LNT_LIST		;set LN_type field
	mov	ax,[oNodeTemp]
	DbAssertRel ax,ne,0,LIST,<PushList: temp stack empty> 
	stosDsWord ax			;store LN_val_list field
	mov	[oNodeTemp],0
	mov	[oNodeRoot],bx		;save offset for new root
	sub	di,[bdNodes.BD_pb]	;convert ptr to offset
	ret
PushList ENDP

;push '(' onto root stack
PUBLIC	PushRootLParen
PushRootLParen PROC NEAR
	mov	al,'('
	jmp	SHORT PushRootChar	;push a char node (al) onto root stack
PushRootLParen ENDP

;push ')' onto root stack
PUBLIC	PushRootRParen
PushRootRParen PROC NEAR
	mov	al,')'
	jmp	SHORT PushRootChar	;push a char node (al) onto root stack
PushRootRParen ENDP

PUBLIC	PushRootSpc
PushRootSpc PROC NEAR
	mov	al,' '
PushRootSpc ENDP
	;fall into PushRootChar
PUBLIC	PushRootChar
PushRootChar PROC NEAR
	sub	ah,ah			;only 1 char in this node
PushRootChar ENDP
	;fall into PushRootChars
;push a char node (ax) onto root stack
PUBLIC	PushRootChars
PushRootChars PROC NEAR
	call	NewChars
	jmp	PushRoot
PushRootChars ENDP

;push '(' onto temp stack
PUBLIC	PushTempLParen
PushTempLParen PROC NEAR
	mov	al,'('
	jmp	SHORT PushTempChar	;push a char node (al) onto temp stack
PushTempLParen ENDP

;push ')' onto temp stack
PUBLIC	PushTempRParen
PushTempRParen PROC NEAR
	mov	al,')'
	jmp	SHORT PushTempChar	;push a char node (al) onto temp stack
PushTempRParen ENDP

PUBLIC	PushTempSpc
PushTempSpc PROC NEAR
	mov	al,' '
PushTempSpc ENDP
	;fall into PushTempChar
;push a char node (al) onto temp stack
PUBLIC	PushTempChar
PushTempChar PROC NEAR
	sub	ah,ah			;only 1 char in this node
PushTempChar ENDP
	;fall into PushTempChars
;push a char node (ax) onto temp stack
PUBLIC	PushTempChars
PushTempChars PROC NEAR
	call	NewChars		;ax = offset to new node
	jmp	PushTemp		;push it onto temp stack
PushTempChars ENDP

;***************************************************************************
;CharToCharTok
;Purpose:
;	Given the last node created by PushRootChar[s], PushTempChar[s]
;	or NewChar[s], convert its node-type from LNT_CHAR to LNT_CHAR_TOK.
;	This is done for nodes which are known to not begin a lexical token.
;	For example, "string" is 3 nodes, char, string, char, but only
;	1 lexical token, so the 2nd char node is converted to LNT_CHAR_TOK.
;	This is so ChkLineWrap in lsmain.asm knows not to split a logical
;	line into 2 physical lines at this node.
;Entry:
;	di = offset to last node created.
;
;***************************************************************************
PUBLIC	CharToCharTok
CharToCharTok PROC NEAR
	mov	bx,di
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr 
DbAssertRelB <[bx + LN_type - CBLNT_CHAR]>,e,LNT_CHAR,LIST,<CharToCharTok err1>
	mov	[bx + LN_type - CBLNT_CHAR],LNT_CHAR_TOK
	ret
CharToCharTok ENDP

;***************************************************************************
; PushRootONam
; Purpose:
;	Create a new oNam list node and push it onto oNodeRoot's stack.
; Entry:
;	ax = oNam
; Exit:
;	none
;
;***************************************************************************
PUBLIC PushRootONam
PushRootONam PROC NEAR
	call	NewONam 		;ax = offset to new ONam node
	jmp	PushRoot		;push node to root stack
					; and return to caller
PushRootONam ENDP

;***************************************************************************
; PushRootLabel
; Purpose:
;	Fetch the next 2 bytes of pcode, which represent a label
;	reference.  If scanState = SS_EXECUTE, convert this 16 bit
;	text offset into a name table offset.  Create a new oNam list
;	node and push it onto oNodeRoot's stack.
; Entry:
;	es:si points to oNam or otx argument
; Exit:
;	si bumped by 2
;	none
;
;***************************************************************************
PUBLIC	PushRootLabel
PushRootLabel PROC NEAR
	call	NewLabel		;ax = new node for this label
	jmp	PushRoot
PushRootLabel ENDP

;push opcode's reserved word node to root's stack
PUBLIC	PushRootOpRw
PushRootOpRw PROC NEAR
	mov	bx,[opList2]		;bx = opcode being listed * 2
	mov	ax,[mpOpLsArg + bx]	;ax = ORW_xxx to be listed
PushRootOpRw ENDP
	;fall into PushRootRw
;Create a reserved-word node for oRw ax and push it to oNodeRoot's stack
PUBLIC	PushRootRw
PushRootRw PROC NEAR
	call	NewRw			;ax = offset to node for "REM"
	jmp	PushRoot
PushRootRw ENDP

;push opcode's reserved word node followed by space node to root's stack
PUBLIC	PushRootOpRwSpc
PushRootOpRwSpc PROC NEAR
	call	PushRootOpRw
	jmp	PushRootSpc
PushRootOpRwSpc ENDP

;Push a reserved word node followed by a space node to root stack
PUBLIC PushRootRwSpc
PushRootRwSpc PROC NEAR
	call	PushRootRw		;list reserved word [ax]
	jmp	PushRootSpc		;list a space and return to caller
PushRootRwSpc ENDP

;Push '"' literal_string_node '"' onto root stack
;	added as part of revision [6]
; ax = length of string; es:si points to text of string
PUBLIC PushRootQStr
PushRootQStr PROC NEAR
	push	ax			;preserve cbText
	mov	al,34			;al = code for double quote "
	call	PushTempChar
	pop	ax			;restore ax = cbText
	call	NewStr			;ax = offset to new node
	call	PushTemp
	mov	al,34			;al = code for double quote "
	call	PushTempChar
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	call	PushList		;convert to single node on Root stack
	ret
PushRootQStr ENDP

;push opcode's reserved word node to temp stack
PUBLIC	PushTempOpRw
PushTempOpRw PROC NEAR
	mov	bx,[opList2]		;bx = opcode being listed * 2
	mov	ax,[mpOpLsArg + bx]	;ax = ORW_xxx to be listed
PushTempOpRw ENDP
	;fall into PushTempRw
;Create a reserved-word node for oRw ax and push it to oNodeTemp's stack
PUBLIC	PushTempRw
PushTempRw PROC NEAR
	call	NewRw			;ax = offset to node for "REM"
	jmp	PushTemp
PushTempRw ENDP

;push opcode's reserved word node followed by space node to temp stack
PUBLIC	PushTempOpRwSpc
PushTempOpRwSpc PROC NEAR
	call	PushTempOpRw
	jmp	PushTempSpc
PushTempOpRwSpc ENDP

;Push a reserved word node followed by a space node to temp stack
PUBLIC PushTempRwSpc
PushTempRwSpc PROC NEAR
	call	PushTempRw		;list reserved word [ax]
	jmp	PushTempSpc		;list a space and return to caller
PushTempRwSpc ENDP

;***************************************************************************
; PushCommaArgs
; Purpose:
;	Copy cLsArgs from root to temp and separate them by commas.
;	Nodes created by opUndef are not listed.
; Entry:
;	cLsArgs = number of args to be transfered from root to temp stack
; Exit:
;	cLsArgs = 0
;
;***************************************************************************
PUBLIC	PushCommaArgs
PushCommaArgs PROC NEAR
	sub	cx,cx			;cx = 0
	mov	cl,[cLsArgs]		;cx = count of args
	jcxz	EndOfArgs		;brif no args
	mov	bx,[oNodeRoot]		;bx = offset to current root node
MoveIndLoop:
	DbAssertRel bx,ne,0,LIST,<PushCommaArgs: root stack underflow> 
	push	bx			;save offset to index node
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr
	cmp	LN_type[bx],LNT_CHAR
	jne	NotUndefNode		;brif couldn't be opUndef node
	cmp	WORD PTR LN_val_char[bx],100h
	jne	NotUndefNode
	pop	ax			;don't list node's created by opUndef
	dec	[cLsArgs]
NotUndefNode:
	mov	bx,LN_sib[bx]		;bx = offset to next index
	loop	MoveIndLoop		;repeat for all args
	mov	[oNodeRoot],bx		;save new root after all args popped
	pop	ax			;ax = offset to next index node
	call	PushTemp		;transfer it to temp stack
XferIndLoop:
	dec	[cLsArgs] 		;countdown # of args left
	je	EndOfArgs		;brif end of args
	call	GrowBdNodes		;grow list buffer if necessary
	je	XferOmErr		;brif out-of-memory - We'll abort
					; ListLine next time through Stg1Loop
	call	PushTempCommaSpc	;push ", " node onto temp stack
	pop	ax			;ax = offset to next index node
	call	PushTemp		;transfer it to temp stack
	jmp	SHORT XferIndLoop

XferOmErr:
	pop	ax			;ax = offset to next index node
	jmp	SHORT XferIndLoop

EndOfArgs:
	ret
PushCommaArgs ENDP

PUBLIC PushTempCharSpc
PushTempCharSpc PROC NEAR
	call	PushTempChar
	jmp	PushTempSpc
PushTempCharSpc ENDP

PUBLIC PushRootCharSpc
PushRootCharSpc PROC NEAR
	call	PushRootChar
	jmp	PushRootSpc
PushRootCharSpc ENDP

PUBLIC PushTempComma
PushTempComma PROC NEAR
	mov	al,','
	jmp	PushTempChar
PushTempComma ENDP

PUBLIC	PopPushCommaSpc
PopPushCommaSpc PROC NEAR
	call	PopRootPushTemp		;move exp from root to temp stk
PopPushCommaSpc ENDP
	;fall into PushTempCommaSpc
PUBLIC PushTempCommaSpc
PushTempCommaSpc PROC NEAR
	mov	ax,' ,'			;list ", "
	jmp	PushTempChars
PushTempCommaSpc ENDP

PUBLIC PushRootCommaSpc
PushRootCommaSpc PROC NEAR
	mov	ax,' ,'			;list ", "
	jmp	PushRootChars
PushRootCommaSpc ENDP

;list ", " if we're in COMMON/SHARED (i.e. if FBOS_DoIdCommas is set)
;
PUBLIC PushTempIdComma
PushTempIdComma PROC NEAR
	test	lsBosFlags,FBOS_DoIdCommas
	je	NoIdComma		;brif not in COMMON/SHARED stmt
	test	lsBosFlags,FBOS_NextIdComma
	je	FirstId			;brif first id in list, no leading comma
	call	PushTempCommaSpc	;output a ', '
FirstId:
	or	lsBosFlags,FBOS_NextIdComma
NoIdComma:
	ret
PushTempIdComma ENDP

;***************************************************************************
; PushTempOpChars
; Entry:
;	mpOpLsArg[opList2] = ASCII codes for 1 or 2 chars (if only 1 char,
;	high byte = 0)
;
;***************************************************************************
PUBLIC PushTempOpChars
PushTempOpChars PROC NEAR
	mov	bx,[opList2]		;bx = opcode being listed
	mov	ax,[mpOpLsArg + bx]	;ax = char(s) to be listed
	jmp	PushTempChars		;push char(s) to be listed
					; and return to caller
PushTempOpChars ENDP

PUBLIC PushRootOpChars
PushRootOpChars PROC NEAR
	mov	bx,[opList2]		;bx = opcode being listed
	mov	ax,[mpOpLsArg + bx]	;ax = char(s) to be listed
	jmp	PushRootChars		;push char(s) to be listed
					; and return to caller
PushRootOpChars ENDP

;***************************************************************************
; PushTempRwOrComma
; Purpose:
;	Used to list opcodes which list as a reserved word the first time
;	they occur in a statement, and as a comma for the 2nd-nth occurence
;	in the statement.
; Entry:
;	lsBosFlags.FBOS_NextStmtComma is 0 if this is the first time this
;	function has been called this statement.
;	ax = ORW_xxx (reserved word table offset) for res word to list
;	   if FBOS_NextStmtComma = 0
; Exit:
;	lsBosFlags.FBOS_NextStmtComma is set to 1
;	the res word or a comma node is pushed to the temp stack
;
;***************************************************************************
PUBLIC PushTempOpRwOrComma
PushTempOpRwOrComma PROC NEAR
	mov	bx,[opList2]		;bx = opcode * 2
	mov	ax,[mpOpLsArg + bx]	;ax = opcode's reserved word
PushTempOpRwOrComma ENDP
	;fall into PushTempRwOrComma
PUBLIC PushTempRwOrComma
PushTempRwOrComma PROC NEAR
	test	lsBosFlags,FBOS_NextStmtComma
	jne	EmitComma		;brif not 1st time called for this stmt
	or	lsBosFlags,FBOS_NextStmtComma
	jmp	PushTempRwSpc		;push reserved word ax
					; and return to caller
EmitComma:
	call	PushTempComma
	jmp	PushTempSpc		;output a space
					; and return to caller
PushTempRwOrComma ENDP

;push res word ax to root stack if 1st time this has been called for this stmt
PUBLIC PushStmtRwIfBos
PushStmtRwIfBos PROC NEAR
	test	lsBosFlags,FBOS_StmtRw
	jne	PushStmtRet		;brif already called for this stmt
	or	lsBosFlags,FBOS_StmtRw
	call	PushRootRwSpc		;push res word ax to root stack
PushStmtRet:
	ret
PushStmtRwIfBos ENDP

sEnd	LIST

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\extort.asm ===
page	49,132
	TITLE	EXTORT	- Runtime Dispatch Support
;***
;exToRt - Runtime Dispatch Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;     The calling sequence required to get to the runtime is not small.
;     This module supports a size efficient method of getting to the
;     runtime.
;
;     This file must parallel RTM86.asm in the runtime project as a compiled
;     code dispatch will be implemented for the user library feature.  The
;     compiled code dispatch will appear the same as for the compiler runtime
;     module.
;
;     There are two differences between RTM86.ASM and EXTORT.asm at this point:
;	- the vector table is in segment CODE rather than in the runtime
;	  segment.  It can only be in one segment.  The CODE segment is
;	  chosen to prefer speed for interpreted code.
;	- there must be one public label for the start of the entire
;	  vector table.  At present, rtm86.asm treats the vector table as 4
;	  separate tables.  These methods are compatible since the tables
;	  may be adjacent in memory.
;
;     There are 237 entrypoints documented in the runtime specification.
;     These calls are divided as follows:
;
;     returns	     0 word   1 word   n words	 total
;     -------------------------------------------------
;     heap moves      10       37	2	  49
;     no movement    153       24      11	 188
;     -------------------------------------------------
;     total	     163       61      13	 237
;
;     Since there are more than 256 entrypoints in the runtime, some
;     runtime calls will have more than one post byte.	A first byte
;     of 255 indicates that a second post byte exists.	The second byte
;     is added to the first one to form the table offset.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
EXTORT_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	variable
	.list


assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA
assumes ds, DATA		

	.list

DbSetNoMovAssert MACRO
	ENDM

sBegin	DATA
	staticW	retAddr2,0

	labelD  <PUBLIC,RtDispVec>
	globalW	RtDispVecLow,0
	globalW	RtDispVecHigh,<SEG B$ASSN>

sEnd	DATA

	EXTRN	B$ASSN:FAR
	EXTRN	B$POW4:FAR

sBegin	RT
sEnd	RT

;
; Generate externs for runtime entries
;
RTMENT	MACRO entryname,dummy,entryseg,startlabel,callflag,switches

	IFNB	<switches>	;;[J1]
	IF	(switches)	;;[J1]
	EXTRN	entryname:FAR	;;[J1]
	ENDIF			;;[J1]
	ELSE			;;[J1]
	EXTRN	entryname:FAR
	ENDIF			;;[J1]
	ENDM
	include rtmint.inc	;generate table of runtime entry point addresses

sBegin	CODE
;
;Generate the table of runtime entry point addresses
;
	EVEN			;start table on an even-byte boundary

_TEXTOFFSET	EQU	OFFSET _TEXT:

VecTbl	LABEL	WORD
RTMENT	MACRO entryname,dummy,entryseg,startlabel,callflag,switches
	IFNB	<switches>		;;[J1]
	IF	NOT (switches)		;;[J1]
	FO_HOLES = TRUE 		;;[J1]
	DW	RTOFFSET B$FrameFC	;;[J1]
	EXITM				;;[J1]
	ENDIF				;;[J1]
	ENDIF				;;[J1]
	IFNB	<startlabel>
startlabel	LABEL	WORD
	ENDIF
	IFNB	<entryseg>
	DW	entryseg&OFFSET	entryname
	ELSE
	DW	RTOFFSET entryname
	ENDIF
	ENDM
	include rtmint.inc	;generate table of runtime entry point addresses

IFDEF	FO_HOLES			;;[J1]
externNP B$FrameFC			;;[J1]
ENDIF	;FO_HOLES			;;[J1]

;The following table indices are needed by the user library code
PUBLIC	VecTbl
PUBLIC	_TEXT_START
PUBLIC	_TEXT_END		

;***********************************************************************
;ExToRt - Size efficient gateway to the runtime.
;Purpose:
;	Size efficient gateway to runtime entrypoints that can not
;	cause heap movement in any heap.
;
;	There are four varients of this routine they differ as follows:
;	- if the called entrypoint can cause heap movement then the di
;	  register (text table address) must be reloaded.  In DOS 3, es
;	  must also be reloaded.
;	- a large number of executors simply dispatch after calling the
;	  runtime the dispatch is performed here for size efficiency.
;	- most BASIC functions map to a single runtime entrypoint that
;	  returns a result in ax.  For these functions, a varient that
;	  simply pushes ax and dispatches is provided.	This varient
;	  always expects heap movement, as more than half of the functions
;	  can cause movement.
;
;	Varient names are:
;	ExToRt		- expects no heap movement.  Returns to caller.
;	ExToRtMov	- expects heap movement, BUT DOES NOT UPDATE ES or DI.
;							Returns to caller.
;	ExToRtDisp	- expects no heap movement.  Dispatches.
;	ExToRtDispMov	- expects heap movement.  Dispatches.
;	ExToRtDispAx	- expects no heap movement.  Pushes ax, and dispatches.
;	ExToRtDispMovAx - expects heap movement.  Pushes ax, and dispatches.
;	ExToRtDispDxAx	- expects no heap movement. Pushes dx:ax and dispatches.
;	ExToRtDispMovDxAx - expects heap movement. Pushes dx:ax and dispatches.
;
;	See the header for this module for more information.
;
;Entry:
;	return address points to byte index of rt entrypoint.
;
;Exit:
;	Same as X for called RT entrypoint, except as follows:
;	     Heap movement varients reload di and es.
;	     Function return varients push ax on the stack.
;	     Dispatch varients don't return.
;
;***********************************************************************

PUBLIC	ExToRtDispR4
ExToRtDispR4:
	mov	cx,CODEOFFSET ExDispR4	;Return address for Shared Entry
	DbSetNoMovAssert		;remember we expect RT call not to move
					;  near or far heap
	jmp	short GoShared

PUBLIC	ExToRtDispR8
ExToRtDispR8:
	DbSetNoMovAssert		;remember we expect RT call not to move
					;  near or far heap
PUBLIC	ExToRtDispMovR8
ExToRtDispMovR8:
	mov	cx,CODEOFFSET ExDispR8	;Return address for Shared Entry
	jmp	short GoShared


PUBLIC	ExToRtDispDxAx
ExToRtDispDxAx:
PUBLIC	ExToRtDispMovDxAx
ExToRtDispMovDxAx:
	mov	cx,CODEOFFSET ExDispMovDxAx ;Return address for Shared Entry
					  ;  near or far heap
	jmp	short GoShared

PUBLIC	ExToRtDispAx
ExToRtDispAx:
PUBLIC	ExToRtDispMovAx
ExToRtDispMovAx:
	mov	cx,CODEOFFSET ExDispMovAx ;Return address for Shared Entry
GoShared:
	pop	bx			;Location of post byte
	mov	al,cs:[bx]		;Post byte
	inc	ax
	DbAssertRelB  al,nz,0,CODE,<Extort: 2-byte postbyte found (1)>
	jmp	short RtDispatchAl	; Call the runtime
					;Entry: al = index
					;	bx = exe ret
					;	cx = continuation addr

PUBLIC	ExToRtDisp
ExToRtDisp:
PUBLIC	ExToRtDispMov
ExToRtDispMov:
	mov	cx,CODEOFFSET ExDispMov	;Return address for shared entry
	jmp	short GoShared

PUBLIC	ExToRtByteDisp			;Special case: ax already has postbyte
ExToRtByteDisp:
	mov	cx,CODEOFFSET ExDispMov
	;ax = index, cx = continuation address
	jmp	short RtDispatch	;Call the runtime



ExDispR8:
	;common exit from intrinsic function executors which receive a pointer
	;  to an R8 in ax on exit
	xchg	ax,bx			;bx = ptr to R8
	fld	qword ptr DGROUP:[bx]	
	jmp	short ExDisp		

ExDispR4:
	;common exit from intrinsic function executors which receive a pointer
	;  to an R4 in ax on exit
	xchg	ax,bx			;bx = ptr to R4
	fld	dword ptr DGROUP:[bx]	
	jmp	short ExDisp



ExDispDxAx:
	public	ExDispMovDxAx
ExDispMovDxAx:
	push	dx
ExDispAx:
ExDispMovAx:
	push	ax
ExDisp:
ExDispMov:
	RestorePcodeVar 		
	mov	si,[grs.GRS_otxCur]
	DispMac


;NOTE: the below didn't used to be separate from the above, but must be
;NOTE: now that all variants call GetEsDi, they are, for speed
PUBLIC	DispMovDxAx
DispMovDxAx:
	push	dx
PUBLIC	DispMovAx
DispMovAx: 
	push	ax
PUBLIC	DispMov
DispMov:
	RestorePcodeVar 		
	DispMac

PUBLIC	DispDxAx
DispDxAx:
	push	dx
PUBLIC	DispAx
DispAx: 
	push	ax
PUBLIC	Disp
Disp:
	DispMac

;***
;ExToRtCall - Call the runtime
;Purpose:
;	This entrypoint calls the runtime routine indicated by
;	the postword in ax.
;
;Entry:
;	ax = postword + 1
;	si = oTxCur
;
;Exit:
;	as per runtime routine
;	es,si,di updated
;**************************************************************************
PUBLIC	ExToRtCall			;Only used for MATH!!!
ExToRtCall:
	pop	[retAddr2]		;return address
	mov	[RtDispVecHigh],SEG B$POW4 ;dispatch to correct address
	mov	cx,CODEOFFSET ExToRt_Return
	jmp	short RtDispatch

ExToRt_Return:
	mov	[RtDispVecHigh],SEG B$ASSN ;restore default
	RestorePcodeVar 		
	mov	si,[grs.GRS_otxCur]
	jmp	[retAddr2]		;return address

PUBLIC	ExToRt
ExToRt:
PUBLIC	ExToRtMov
ExToRtMov:
	pop	bx			;return offset
	mov	al,cs:[bx]		;post byte
	inc	bx			;Offset after the post byte
	inc	al
	DbAssertRelB  al,nz,0,CODE,<Extort: 2-byte postbyte found (3)>
	mov	[retAddr2],bx		;return address to executor
	mov	cx,CODEOFFSET ExToRt_Return

RtDispatchAl:
	xor	ah,ah

PUBLIC	RtDispatch			
RtDispatch	PROC	FAR
;ax = postbyte value + 1
;cx = RtDispatch return address
	shl	ax,1			;*2 for 1 relative word index
	mov	bx,ax
	mov	ax,cs:[VecTbl.bx-2]	;Offset of runtime routine
	mov	[RtDispVecLow],ax

	;In the event that a runtime entry point has been deemed to be never
	;called by QBI, it's entry in this table will be zero unless QB is
	;invoked with the /L switch. See dennisc for details (brianle 15 May 87)
	DbAssertRel ax,nz,0,CODE,<extort: someone tried to dispatch to a U.L.-specific RT entry point>

	push	cs			;Build first half of far return
	push	cx			;offset part of far return

	mov	[grs.GRS_otxCur],si	;Make text pointer known to error code
DispRt:                                 ;Dispatch point for runtime
	jmp	[RtDispVec]		;far jump to runtime entry point
RtDispatch	ENDP






subttl	Ex to RT Dispatch Helpers
page
;***
;GetEsDi - load di and es for execution
;Purpose:
;	Load execution context di (and es in DOS 3).
;Input:
;	none
;Output:
;	es	= current pcode segment
;	di	= variable table address + VAR_value
;Preserves:
;	ax,cx,dx
;Modifies:
;	none
;****
	PUBLIC GetEsDi
GetEsDi PROC	NEAR
	mov	bx,[grs.GRS_pMrsCur]
	mov	di,PTRRS[bx.MRS_bdVar.BD_pb] ;di = start of variable table
	add	di,VAR_value		;add offset to value part for exe speed
	cmp	[grs.GRS_fDirect],FALSE ;check direct mode - diff. text table
	jnz	GetDirectSeg		;brif executing out of direct mode buf.

	mov	bx,[grs.GRS_bdRs.BD_pb] ;bx points to base of the Rs table
	add	bx,[grs.GRS_offsetTxdSeg] ;bx points to seg adr of active txd
	GETSEG	es,PTRRS[bx],bx,<SPEED,LOAD> ;[6] es = segment adr of text table
	ret
GetDirectSeg:
	GETSEG	es,[grs.GRS_bdlDirect_seg],bx,<SPEED,LOAD> ;[2] Pcode segment of direct buffer
	ret
GetEsDi ENDP



sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\lsmain.asm ===
;======================================================================
; Module: LsMain.asm - main module of 'lister' component
;
; Purpose:
;	The Lister is responsible for converting one logical line
;	of pcode to its ASCII source equivalent.  A logical line
;	may consist of several physical lines, with each physical
;	line terminated by an underscore_remark.  The pcode may
;	be in any scan-state from SS_rude to SS_executable.  The
;	pcode resides in a far (non DS) segment.  The lister's
;	main interface to the rest of BASIC is the entry point
;	ListLine().
;
;
;=======================================================================*/

	include 	version.inc
	LSMAIN_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	lsint
	includeOnce	names
	includeOnce	optables
	includeOnce	parser
	includeOnce	pcode
	includeOnce	prstab
	includeOnce	qblist
	includeOnce	rtps
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	util

	assumes DS,DGROUP
	assumes SS,DGROUP
	assumes ES,NOTHING


;-----------------------------------------------------------------------
;		NOTE NOTE NOTE NOTE NOTE
;
;  A powerful debugging aid is to set a break point at ListLine
;  just before the line of interest is to be listed.  When in
;  the breakpoint, set fDebugList non-zero.  This will cause
;  the intermediate list-node-tree to be symbolically dumped
;
;-----------------------------------------------------------------------



;-----------------------------------------------------------------------
;   Notation:
;
;   This module deals heavily with lists of nodes.
;
;   The list:
;	(a)->(b)->( )->(f)->(g)
;		   |
;		   +-->(c)->(d)->(e)
;
;   is equivalent to the representation:
;
;	[a b [c d e] f g]
;
;   Where b is a sibling of a, d is a sibling of c, and the entire list [c d e]
;   is a sibling of b.
;
;   Functions which operate on a list of nodes use the notation
;	[oldList] ==> [newList]
;   to indicate how the list is transformed.  For example, a function
;   which inserts 'newNode' into a list would be documented as:
;	[x y z]  ==>  [newNode x y z]
;
;   The way a line of pcode is listed (converted to ASCII text) is by
;   dispatching to a "ListRule" for each opcode.  These ListRules are
;   labeled LrXXX (i.e. LrBos handles opBos and LrBinaryOp handles
;   all binary operators).  These ListRule functions all work together
;   to manipulate to global lists, the "Root" list and the "Temp" list.
;   By the time the end-of-line is reached, the Root list contains
;   a complete description of the text to be listed.  The Temp list is
;   only used for 1 ListRule's temporary needs.  Nothing is passed
;   on the Temp list from one ListRule to another.
;
;   All the nodes which make up these lists physically reside within
;   the buffer bdNodes.  Since this buffer is a heap entry that can move,
;   all nodes are refered to as offsets into the buffer.  The first byte
;   of the buffer is not used, allowing 0 to represent end-of-list.
;   Nodes are of different types and lengths length.  The first field
;   in each node is LN_sib (offset to sibling node), followed by LN_type
;   (type of node).
;
; Algorithm:
;
;   ListLine consists of 2 stages.  Stage1 reads the pcode,
;   building an list-node description of the line.  Stage2
;   traverses this node description and appends ASCII text
;   to the output buffer.  Stage2 dumps the last node in the list
;   first, then the next to last, etc.
;
; Example of how an line of pcode is listed.
;
;   Original ASCII Source: a(x,y)=1+2
;   pcode: opBol opLit(1) opLit(2) opAdd
;	     opId(x) opId(y) opAIdSt(a,2) opBol/opEot
;
;   The following chart represents snapshots in time of the
;   current state of the lister's data structures during Stage1:
;
;	next opcode   oNodeRoot's tree
;	-----------   -----------------
;	opBol	      NULL
;	opLit(1)      NULL
;	opLit(2)      [1]
;	opAdd	      [2 1]
;	opId(x)       [[2 + 1]]
;	opId(y)       [x [2 + 1]]
;	opAIdSt(a,2)  [y x [2 + 1]]
;	opBol/opEot   [[2 + 1] = [) y , x ( a]
;
;  Stage2 then output's 'a', '(', 'x', ',', 'y', ')', '=', '1', '+', '2'
;
;-----------------------------------------------------------------------


sBegin	RT
	EXTRN	B$IFOUT:far		;binary to ASCII numeric conversion
	EXTRN	B$FHEX:far		;binary to ASCII base 16 conversion
	EXTRN	B$FOCT:far		;binary to ASCII base 8 conversion
sEnd	RT

sBegin	DATA
;-----------------------------------+
; Inter-component Global variables: |
;-----------------------------------+
PUBLIC	otxListNext, otxListNextInc, cLeadingSpaces
otxListNext	DW 0	;text offset to opBol for next line to be listed
			; by ListLine().  Set by ListLine at exit.
otxListNextInc	DW 0	;text offset to opBol for next line after current
			; line, even if it is from an included file.
			; Set by ListLine at exit.
cLeadingSpaces	DB 0	;Could of leading spaces in listed line
			; Set by ListLine at exit.

PUBLIC	otxLsCursor			;Public to non-lister components
PUBLIC otxLsCursorTmp, ndLsCursor, colLsCursor ;PUBLIC to modules w/i lister
otxLsCursor	DW 0	;See ListLine header for description
otxLsCursorTmp	DW 0	;See ListLine header for description
ndLsCursor	DW 0	;node equivalent to otxLsCursor
colLsCursor	DW 0	;column equivalent to otxLsCursor
lnTypeFindSave	DB 0

PUBLIC	fLsIncluded
fLsIncluded	DB 0	;set TRUE if this line is from an $INCLUDE file
			; (i.e. opInclude was found in it).  This allows
			; ASCII Save to not send it to the file being saved.

;flags which get reset each beginning of line
PUBLIC	lsBolFlags
lsBolFlags DB 0		;FBOL_xxx masks

;flags which get reset each beginning of stmt
PUBLIC	lsBosFlags, lsBosFlags2, lsBosFlagsWord
lsBosFlagsWord LABEL WORD
lsBosFlags DB 0		;FBOS_xxx masks
lsBosFlags2 DB 0	;FBOS2_xxx masks

;variables used by ChkLineWrap to insert _<CrLf> in lines longer than 255 bytes
;
colLastTok	DW 0
colLastLine	DW 0

PUBLIC	fLsDynArrays
fLsDynArrays DB 0	;Initialized to FALSE by AsciiSave, set TRUE when
			; $DYNAMIC is listed, set FALSE when $STATIC is listed
			; Tested by AsciiSave.

QUOTE	=	022H			;quote char (")

;--------------------------+
; Lister Local variables:  |
;--------------------------+
CB_NODES_MIN	equ	200	;never let node buffer get < 200 free bytes
CB_NODES_GROW	equ	400	;when it does, grow it by 400
				;Note: this isn't because one node can be
				; 200 bytes long, its because one dispatch
				; can produce many nodes, which together
				; can be 200 bytes in length.  For example,
				; CALL x (x1,x2,x3,...,x50)

;bdNodes is a table descriptor for a growable buffer in the table-heap used
; to accumulate the generated listing.	It contains node entries
; which represent current line being listed.

	EVEN
PUBLIC	bdNodes
bdNodes bd	<0,0,0>


PUBLIC	fGotBol
fGotBol DB	0			;non-zero after 1st opBol
					;UNDEFINED if no leading spaces on line
					;else count of leading spaces

;oNodeRoot is an offset (initially NULL) into bdNodes for the node which
; is the root of a tree of nodes used to represent current line being listed.
;
PUBLIC	oNodeRoot
oNodeRoot DW	0

;oNodeTemp is an offset (initially NULL) into bdNodes for the node which
; is the root of a temporary tree of nodes used to construct complex
; nodes which will eventyally be pushed onto oNodeRoot's list.
;
PUBLIC	oNodeTemp
oNodeTemp DW	0

PUBLIC	opList2, opList
opList2 DW	0			;2 * opcode being listed.  Used
					; by individual listers to index
					; tables of opcode related data
opList DW	0			;value of current opcode before 
					;masking with OPCODE_MASK


PUBLIC	cLsArgs
cLsArgs DB	0			;temporary for counting down args


sEnd	DATA

subttl	List Debugging Functions




sBegin	LIST
assumes CS,LIST

;===========================================================================
;		Outer Loop of Lister
;===========================================================================

;***************************************************************************
; ushort FAR ListLine(otx, pbdDst)
;
; Purpose:
;	Converts one line of pcode to its ASCII source equivalent.
;	The pcode may be in any scan-state from SS_rude to SS_executable.
;	The pcode resides in a far (non DS) segment indicated by grsCur.oRsCur.
;	The buffer pointed to by pbdDst is grown if necessary EXCEPT FOR
;	THE SPECIAL CASE when pbdDst->cbLogical < 80, in which case,
;	the output is truncated.  This special case is for listing WATCH
;	expressions, which list to a static buffer that can't be grown.
;	All normal callers call this with pbdDst->cbLogical >= 80.
;
; Entry:
;	parm1: ushort oText - the offset into the current text table for
;		for the 1st opcode of the line to be listed.
;	parm2: char *pbdDst - points to destination buffer to
;		filled with the resulting ASCII source.
;	The global variable otxLsCursor = text offset for stmt to isolate
;	   columns for.  Causes column for otxLsCursor to be returned in dx.
;
; Exit:
;	returns UNDEFINED if out-of-memory-error
;	else returns actual number of bytes listed to pbdDst.
;	Text in pbdDst is 0-byte terminated (0 not included in byte count)
;	The global variable 'otxListNext' = text offset to opBol for next
;	   line to be listed by ListLine.  Set by ListLine at exit to speed
;	   up actions like listing 1 screen full, or ASCII Save.
;	The global variable 'otxListNextInc' is set to text offset to opBol
;	   for next line after current line, even if it is from an included
;	   file.
;	dx is set to UNDEFINED if otxLsCursor is not within this line.
;	   Otherwise, it represents the column offset into the ASCII
;	   output buffer where the opcode for otxLsCursor is.
;	   This is used by the User Interface code so it can
;	   highlight the current statement and position the cursor to errors.
;	The global variable 'fLsIncluded' is set TRUE if this line
;	   is from an $INCLUDE file (i.e. opInclude was found in it).
;	   This allows ASCII Save to not send it to the file being saved.
;	cLeadingSpaces is set to the number of leading spaces 
;	   that were on the line.
;
;***************************************************************************

cProc	ListLine <PUBLIC,NODATA,FAR>,<si,di>
	parmW	otxParm
	parmW	pbdDst

	localV	numBuf,8		;holds number for B$IFOUT
	localW	spSave
	localW	pbDstWarning
	localW  hTxdCurSeg		;handle of current text seg 
cBegin	ListLine
	mov	Word Ptr [lsBosFlagsWord],NULL ; clear any leftover flags
ListLineRestart:
	mov	[spSave],sp		;save for restart-ability
	mov	si,[otxParm]		;si = offset for 1st opcode to list
	sub	di,di			;di = offset to 1st node to output
	inc	di			;1st node must not be 0, because
					; we use NULL to indicate end-of-list.
					; This is much cheaper than using
					; UNDEFINED to indicate end-of-list.

	sub	ax,ax			;ax = 0
	mov	[fGotBol],al		;so we can stop at 2nd opBol
	mov	[fLsIncluded],al	;default to FALSE
	mov	[oNodeRoot],ax		;oNodeRoot = 0
	mov	[oNodeTemp],ax		;temp stack head = 0
	dec	ax			;ax = UNDEFINED
	mov	[ndLsCursor],ax
	mov	[colLsCursor],ax

	mov	dx,[otxLsCursor]
	mov	[otxLsCursorTmp],dx
	cmp	dx,si
	jae	StmtInLine		;brif stmt is in or beyond line to list
					; or if otxLsCursor == UNDEFINED
	mov	[otxLsCursorTmp],ax	;otxLsCursorTmp = UNDEFINED
StmtInLine:

	cmp	[bdNodes.BD_pb],NULL
	jne	GotBuffer		;brif we already have node buffer

;	Always allocate the node buffer if this is for compiler list support.

	;Allocate the buffer which holds nodes
	; BdAlloc(&bdNodes, 0, IT_NO_OWNERS)
	PUSHI	ax,<dataOFFSET bdNodes>
	PUSHI	ax,CB_NODES_GROW	;initial size of nodes buffer
	PUSHI	ax,<IT_NO_OWNERS>;heap type
	call	BdAlloc
	or	ax,ax
	je	J1_ListErrExit		;brif out-of-memory error
GotBuffer:

GetTextSegAddr:
	GETSEG	es,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[4]
					;es = segment for current text tbl
	jmp	SHORT Stg1Loop

GetRoom:
	call	GrowBdNodes		;grow node buffer
	jne	GotRoom			;branch if not out-of-memory
J1_ListErrExit:
	DJMP	jmp SHORT ListErrExit

;We created node for token of interest, and it is on top of Root stack.
;Replace topNode with [<topNnode> <LNT_CURSOR node>], so Stage2 loop
;will save column of this token.
;
SetNdLsCursor:
	mov	[ndLsCursor],di
	mov	[otxLsCursorTmp],UNDEFINED ;make sure we don't branch here again
	jmp	SHORT SetNdRet

; Stage1:
;   The outer loop of Stage1 fetches the next opcode, maps it
;   to a function, and jumps to the function, which jumps
;   back to  the top of the loop.  The function for the 2nd encountered
;   opBol/opEot terminates this loop by not jumping back to
;   the top of the loop.  If the text is in SS_Executable
;   state, after fetching the executor, it maps to the opcode
;   associated with this executor.  The functions dispatched
;   to by this loop can expect:
;
;	DS -> DGROUP
;	ES -> the segment with the current text table
;	SI -> the next opcode to be fetched,
;	DI -> next free byte in buffer described by bdNodes.
;
;   The current text table is locked in order to avoid the need to continually
;   update es after each FAR call.
;
;THE FOLLOWING IS TRUE FOR QBx but not EB [11]
;   Stage1's outer loop guarentees at least CB_NODES_MIN free bytes
;   in the buffer, which is large enough for all the nodes that could
;   be emitted by a single dispatch.  Any dispatches that could require
;   more than this call GrowBdNodes themselves.
;   The outer loop is the only place during Stage1 which
;   grows bdNodes, which is the only time heap movement can
;   occur.  When it does this, it fixes up ES and DI.
;
PUBLIC	Stg1Loop
Stg1Loop:
	DbAssertRel [oNodeTemp],e,0,LIST,<node found on temp stack at Stg1Loop>

	;make sure bdNodes > CB_NODES_MIN bytes, updating ES for movement
	
	mov	ax,CB_NODES_MIN 	;ax = min free we need
	add	ax,di			;ax = size we need buffer to be
	sub	ax,[bdNodes.BD_cbLogical] ;ax = free space
	jnc	GetRoom 		;brif not enough free bytes exist
GotRoom:

	cmp	si,[otxLsCursorTmp]
	jae	SetNdLsCursor		;brif caller wants to know column
					; of token for the last opcode listed.
					; Control returns to SetNdRet.
SetNdRet:
	lods	WORD PTR es:[si]	;ax = opcode
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	GotOpcode
	;convert to opcode since text table's scan state is SS_EXECUTE
	xchg	bx,ax			;bx = executor's adr
	GetSegAddr CODE		 	;ax = adr of CODE seg
	mov	ds,ax			;ds = adr of CODE seg
	mov	ax,[bx-2]		;ax = executor's opcode
	push	ss			
	pop	ds			;restore ds = DGROUP
GotOpcode:
	mov	[opList],ax		;save for individual list rules
	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands
	mov	bx,ax			;bx = opcode
	shl	bx,1			;bx = opcode * 2
	mov	[opList2],bx		;save index for individual list rules
	jmp	[mpOpLister + bx]	;dispatch to lister function
					;function will branch back to Stg1Loop
					; or Stage2

;Some serious error has occured while listing (like out-of-memory)
; return error code
;
ListErrExit:
	mov	ax,UNDEFINED		;return error result
	jmp	ListLineExit		;return ax

;!!!WARNING!!!  No heap movement can occur during Stage2, because
; we convert all bdNode offsets to pointers while reversing the direction
; of the list. 
;This is not a problem in EB since the node buffer is static.
;
; Stage2:
;   Taking the tree which was built in step1, do a post-order traversal
;   dispatching to a special function for each node type.  Each of these
;   functions appends text to the current output line.
;   global register conventions:
;
; Stage2Inc is branched to when the terminating bol is for an included
;   line.  In this case, otxListNextInc has already been set.
;   
;
PUBLIC	Stage2, Stage2Inc
Stage2:
	call	GrowBdNodes		;this test will ensure that we
					;  have not written past end of buffer
	mov	[otxListNextInc],si	;save it for caller
Stage2Inc:
	mov	[otxListNext],si	;save it for caller


	;If there was a node that contained token of interest, replace
	;the node type with LNT_CURSOR (similar to a break-point), so
	;we don't have to compare at every stage2 dispatch.
	
	mov	bx,[ndLsCursor]
	inc	bx
	je	NoNdLsCursor		;brif line doesn't contain otxLsCursor
	add	bx,[bdNodes.BD_pb]	;convert offset to ptr
	mov	al,LNT_CURSOR
	xchg	[bx+LN_type-1],al
	mov	[lnTypeFindSave],al
NoNdLsCursor:




	mov	di,[pbdDst]		;di points to destination buffer dsc
	mov	ax,[di.BD_cbLogical]	;ax = max size of buffer
	mov	di,[di.BD_pb]		;di points to destination buffer
	mov	[colLastTok],di
	mov	[colLastLine],di
	add	ax,di			;ax points beyond end of buffer
	sub	ax,42d			;42 bytes is enough for an id, reserved
					; word, number, or char[s] node
					; Spaces/String/Col nodes check
					; for themselves
	DJMP	jc ListDstFull		;brif dst doesn't even have 42 bytes
	mov	[pbDstWarning],ax
	mov	si,[oNodeRoot]		;si = offset to root node
	or	si,si
	je	Stg2Done		;brif nothing to list
	sub	ax,ax			;prev node = NULL
	push	ax			;this will stop EndOfListLoop
;si=offset to start of list of nodes, to be listed in reverse order, i.e. last
;   node in list will be listed first, start of list will be listed last.
FindEndOfList:
	sub	cx,cx			;prev node = NULL
;si = offset to current node,
;cx points to previous node (if start of list, cx = 0),
;Traverse si's list to the end, then start listing nodes in reverse order
;
EndOfListLoop:
	add	si,[bdNodes.BD_pb]	;convert offset to ptr
	xchg	cx,LN_sib[si]		;cx = offset to next node (if any)
					;swap ptr from prev->next to next->prev
					; so we can work our way back
	jcxz	ListNodeSi		;brif we're at the end-of-list
	xchg	cx,si			;cx points to prev node
					;si = offset to current node
	jmp	SHORT EndOfListLoop

;si points to last node in list, list it, then list all the nodes which
; came before it in the linked-list
;di points to destination of next ASCII byte to be listed
;
DbPub	ListNodeSi
ListNodeSi:
	cmp	di,[pbDstWarning]
DJMP	jae	ListDstFull		;brif destination buf almost full
	mov	bl,LN_type[si]		;bx = node type
DispNodeBl:
	sub	bh,bh			;bh = 0
	jmp	[mpNodeLister + bx]	;dispatch to lister function
					;function will branch back to Stg2Cont

;si still points to node which was just listed.
; now, advance to previous sibling to be listed and list it.
;
DbPub	Stg2Cont
Stg2Cont:
	mov	si,LN_sib[si]		;si points to left sibling of node
	FLoadActive
	jne	ChkLineWrap		;see if _CrLf needs to be inserted
					; for a line > 250 chars long
					; (so BASCOM can read it)
					; jumps back to either LineWrapRet
LineWrapRet:
	or	si,si			; we just listed (0 if start-of-list)
	jne	ListNodeSi		;brif not at start of list yet
EndOfList:
	pop	si			;recover node stacked by ListChildList:
	or	si,si			;test for stopper pushed just before
					; FindEndOfList:
	jne	Stg2Cont		;brif still more to list
					;else, we've reached the 0 stopper
					; pushed by ListChildList

;NOTE: This is branched to by StaticBufFull
Stg2Done:
	sub	ch,ch			;clear high byte
	mov	cl,[fGotBol]		;cl = number of leading spaces or
					;UNDEFINED.
	inc	cl			;check for UNDEFINED
	jz	NoLeadingSpc		;return 0 if no leading spaces
	dec	cl			;return number of leading spaces
NoLeadingSpc:
	;Many opcode listers leave a space at the end, in case they are
	;followed by something else.  If the last char in the line is
	;a space, and the line does not contain only white space,
	;eliminate the last space, and then 0-byte terminate the line.
	
	mov	ax,di			;ax points beyond last destination byte
	mov	bx,[pbdDst]
	sub	ax,[bx.BD_pb]		;ax = number bytes listed to buffer
	je	NoTrailSpc		;brif 0 bytes listed
	cmp	BYTE PTR -1[di],' '
	jne	NoTrailSpc		;brif last byte is not " "
	cmp	ax,cx			;is the line blank?
	je	NoTrailSpc		;brif so, preserve trailing space
	dec	di			;eliminate trailing space
	dec	ax			;decrement return value (byte count)
NoTrailSpc:
	mov	BYTE PTR [di],0 	;0-byte terminate text
ListLineExit:				;return ax
	push	cx			;save leading space count
	push	ax			;save byte count
	mov	bx,[pbdDst]		
	call	SetLsCursor		;dx = col equivalent to otxLsCursor
	pop	ax			;ax = byte count
	pop	cx			;cx = leading space count
	mov	[cLeadingSpaces],cl	;record leading space count in 
					;	static
;NOTE: we can't release space held by bdNodes, or else we risk
;causing an out-of-memory error while trying to draw the debug
;screen, which would be an infinite loop.  If necessary, we could
;reset it in ParseNewInit
;;;	mov	[bdNodes.BD_cbLogical],0 ;Reset the buffer which holds nodes

cEnd	ListLine

;******
;NOTE
; Code below this point accesses variables on ListLine's BP frame.
; Don't insert any CEND macros between here and the next CEND.
;
;******
; ListDstFull
;
;Branched to when destination buffer is almost full
;Grows destination buffer (if possible) and tries again from the start
;of ListLine.  We have to do it from the start, since no heap movement
;can occur during stage 2 (for speed of typical case).
;
;For RELEASE code in EB we just assume that when we get here it must be
;  
ListDstFullDS:				
ListDstFull:
	mov	sp,[spSave]
					; destination buffer
	mov	bx,[pbdDst]		;bx points to destination buf desc.
	mov	ax,[bx.BD_cbLogical]
	cmp	ax,80d
	jb	StaticBufFull
	add	ax,128d			;try 128 bytes more
	push	bx			;pass pbdDst to BdRealloc
	push	ax			;pass cbNew to BdRealloc
	call	TxtGrowPsSrcEmScratch	;make sure bdEmScratch and
					;ps.bdpSrc both get updated
	or	ax,ax
	jne	NotOm			;brif not out-of-memory
	jmp	ListErrExit		;return UNDEFINED
NotOm:
	jmp	ListLineRestart

StaticBufFull:

	jmp	Stg2Done		;0-terminate line and return to caller

;We're doing an ASCII Save
;see if _<space><CR><LF> needs to be emitted for a line > 250 chars long
; (so BASCOM can read it)
; si points to node for next token to list
; di = column we're about to write next token to
; [colLastTok] = column we wrote last token to (initially 0)
; [colLastLine] = column which began last physical line (initially 0)
;
DbPub ChkLineWrap
ChkLineWrap:
	.errnz	LNT_CHAR_TOK	- 0
	.errnz	LNT_STR		- 2
	.errnz	LNT_ENSTR	- 4
	.errnz	LNT_CSSTR	- 6
	.errnz  LNT_LITSTR	- 8	
	;The following node types start lexical tokens
	.errnz	LNT_ONAM	- 10
	.errnz	LNT_LIST	- 12
	.errnz	LNT_RW		- 14
	.errnz	LNT_SPACES	- 16
	.errnz	LNT_NUM 	- 18
	.errnz	LNT_COL 	- 20
	.errnz	LNT_CHAR	- 22
	.errnz	LNT_CURSOR	- 24


	or	si,si
	je	EndOfList1		;brif end of linked list of nodes
	cmp	LN_type[si],LNT_ONAM
	jb	J1_LineWrapRet		;brif this node does not necessarily
					; begin a lexical token.  For example:
					; "string" = 3 nodes: char,str,char
					; X$ = 2 nodes: oNam,char
EndOfList1:
	mov	[colLastTok],di
J1_LineWrapRet:
	jmp	LineWrapRet

;***************************************************************************
; ChkDstFull
; Purpose:
;	Make sure there's room in destination buffer for a new item.
;	If pbdDst.cbLogical < 80, buffer is static and cannot be grown,
;	just truncate listing  (used by WatchName)
; Entry:
;	di = current pointer into destination buffer
;	cx = number new bytes needed in destination buffer
;	[18]for EB ds need not point to DGROUP. If there is no room then DS 
;		is restored to DGROUP before restarting ListLine.
; Exit:
;	If there's room, this function returns, else, ListLine
;	is restarted after growing buffer.
; Preserves:
;	all registers except flags and ax
;
;***************************************************************************
assumes	DS,NOTHING			
DbPub	ChkDstFull
ChkDstFull PROC NEAR
	mov	ax,di			;ax = current dest ptr
	add	ax,cx			;ax = result dest ptr (end of string)
	jc	ListDstFullDS		;brif wrapped past FFFF 
					;		(buf too small)
	cmp	ax,[pbDstWarning]
	jae	ListDstFullDS		;brif string too big - 
					;		grow dst buffer
	ret
ChkDstFull ENDP
assumes DS,DGROUP			

;***************************************************************************
; GrowBdNodes
; Purpose:
;	Grow the temporary buffer filled by Stg1Loop if necessary.
; Entry:
;	di = current offset into bdNodes buffer
; Exit:
;	ax = zero if out-of-memory (or out of static buffer space),
;	     condition codes set accordingly
;	es = segment adr of current text table
; Preserves:	cx
;
;***************************************************************************
PUBLIC	GrowBdNodes
GrowBdNodes PROC NEAR
	mov	ax,CB_NODES_MIN 	;ax = min free we need
	add	ax,di			;ax = size we need buffer to be
	sub	ax,[bdNodes.BD_cbLogical] ;ax = free space
	jc	GrowExit		;brif enough free bytes exist
					;ax is nonzero, psw.ZR is FALSE
	push	cx			;save caller's cx
	PUSHI	ax,<dataOFFSET bdNodes>
	PUSHI	ax,CB_NODES_GROW
	call	BdGrow
	GETSEG	es,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[4]
					;es = segment for current text tbl
	pop	cx			;restore caller's cx
	or	ax,ax			;test BdGrow's return value
GrowExit:
	ret
GrowBdNodes ENDP

sEnd	LIST
sBegin	DATA

mpNodeLister LABEL WORD
	DW	LISTOFFSET ListCharsNode
	DW	LISTOFFSET ListStrNode
	DW	LISTOFFSET ListEnStrNode
	DW	LISTOFFSET ListCsStrNode
	DW	LISTOFFSET ListLitStrNode 
	DW	LISTOFFSET ListONamNode
	DW	LISTOFFSET ListChildList
	DW	LISTOFFSET ListRwNode
	DW	LISTOFFSET ListSpacesNode
	DW	LISTOFFSET ListNumNode
	DW	LISTOFFSET ListColNode
	DW	LISTOFFSET ListCharsNode
	DW	LISTOFFSET ListCursorNode
.errnz	LNT_CHAR_TOK	- 0
.errnz	LNT_STR		- 2
.errnz	LNT_ENSTR	- 4
.errnz	LNT_CSSTR	- 6
.errnz	LNT_LITSTR	- 8
.errnz	LNT_ONAM	- 10
.errnz	LNT_LIST	- 12
.errnz	LNT_RW		- 14
.errnz	LNT_SPACES	- 16
.errnz	LNT_NUM 	- 18
.errnz	LNT_COL 	- 20
.errnz	LNT_CHAR	- 22
.errnz	LNT_CURSOR	- 24

sEnd	DATA
sBegin	LIST
assumes CS,LIST

;===========================================================================
;		Stage 2 Node Listing Functions
;
; This section contains one routine for listing each node type.
; On Entry, they can all assume
;	DS points to DGROUP segment
;	DI points to next destination byte (buffer is within DS)
;	SI points to node being listed
;	ES contains garbage
;
;===========================================================================

;***************************************************************************
; ListChildList
; Purpose:
;	This node has no atomic ASCII source directly associated with it,
;	i.e. it is a hierarchy node which exists just to hold children
;	to sibling nodes.
;
;***************************************************************************
ListChildList:
	push	si			;gets popped by EndOfList:
	mov	si,WORD PTR LN_val_list[si]
					;si = offset to start of child list
	jmp	FindEndOfList		;recursively list it

;***************************************************************************
; ListONamNode
; Purpose:
;	Copy the content of an LNT_ONAM node to the output buffer.
;	Value is a 16 bit name table offset for identifier associated with
;	this node.
;
;***************************************************************************
ListONamNode:
	push	di			; pass dest byte ptr to CopyONamPb
	push	word ptr [si.LN_val_oNam] ; pass oNam to CopyONamPb
	call	CopyONamPb		;copy name to destination buffer
					;ax = # bytes in name
	add	di,ax			;update destination ptr
	jmp	Stg2Cont

;***************************************************************************
; ListCursorNode
; Purpose:
;	Return column offset for this node in colLsCursor.
;	It represents the column that corresponds with the opcode
;	at text offset otxLsCursor.
;
;***************************************************************************
ListCursorNode:
	mov	ax,di			;ax points to next destination byte
	mov	bx,[pbdDst]
	sub	ax,[bx.BD_pb]		;ax = number bytes listed to buffer
	mov	[colLsCursor],ax
	mov	bl,[lnTypeFindSave]
	jmp	DispNodeBl

;***************************************************************************
; ListCharsNode
; Purpose:
;	Copy the content of an LNT_CHAR node to the output buffer.
;	Value is 0, 1 or 2 ASCII characters associated with this node.
;
;***************************************************************************
ListCharsNode:
	mov	ax,WORD PTR [si.LN_val_char]
	cmp	ax,"OT"
	je	GotTo
CharLoop:
	or	al,al
	je	NoChar			;brif NULL char in this node
CharLoop1:
	mov	[di],al 		;copy char to destination buffer
	inc	di			;can't use stosb because ES <> DS
	mov	al,ah			;al = 2nd char (if any)
	sub	ah,ah			;don't output more than 2 chars
	jmp	SHORT CharLoop
NoChar:
	jmp	Stg2Cont

;It is space-cheaper to put spaces around TO here than in
;DIM's Stage1 code.
;
GotTo:
	mov	[di],"T "		;list " T"
	inc	di			;can't use stosb because ES <> DS
	inc	di
	mov	ax," O"			;list "O "
	jmp	SHORT CharLoop1


;***************************************************************************
; ListRwNode
; Purpose:
;	Copy the content of an LNT_RW node to the output buffer.
;	value is a 16 bit reserved word table offset for
;	reserved word or special character associated with this node.
;
;***************************************************************************
ListRwNode:
	jmp	FAR PTR ListRwNodeCP	

sEnd	LIST				

sBegin  CP
assumes	CS,CP				


DbPub	ListRwNodeCP
ListRwNodeCP:				
	push	si			;preserve si
	mov	ax,ds			;don't use push, need speed
	mov	es,ax			;es = DGROUP
	mov	ax,WORD PTR [si.LN_val_orw]
	mov	si,ax			;si = resword offset + 1st letter
	mov	al,ah			;al = (1st letter - 'A') * 4
	xor	ah,ah			
	shr	al,1			
	shr	al,1			;al = 1st letter - 'A'
	mov	bx,ax			
	shl	bx,1			;bx = word offset into tRw table
	add	al,'A'			;al = 1st letter
	stosb				;store 1st letter of res word
	and	si,03FFH		;si = offset into res word table
	mov	ax,cs			;ax = current address of CP segment
	mov	es,ax
	assumes ES,CP

	add	si,es:tRw[bx]		;convert offset to ptr
	
	call	GetRwFromTabCP		;cx = size of res word's name
					;dx = size of res word's atr block
					;si points to 1st letter of name
	assumes ES,NOTHING
	mov	ax,es			;don't use push, need speed
	mov	ds,ax			;ds = CP segment
	assumes DS,CP
	mov	ax,ss			;don't use push, need speed
	mov	es,ax			;es = DGROUP
	rep movsb			;copy reserved word from CP segment
					; to DGROUP table
	lodsb				;al = res word's flags
	test	al,RWF_STR
	je	NotStrRw		;brif res word does not end with '$'
	mov	al,'$'
	stosb				;list "$"
NotStrRw:
	mov	ax,ss			;don't use push, need speed
	mov	ds,ax			;ds = DGROUP
	assumes DS,DGROUP
	pop	si			;restore si
	jmp	FAR PTR Stg2Cont	


;*************************************************************************
; GetRwFromTabCP
; Purpose:
;	extract an entry from the reserved word table
; Entry:
;	si points to first char of entry in reserved word table 
;		which is the second char of the reserved word since the
;		first char is not stored in the table
;	for GetRwFromTabList:
;		es = segment address of reserved word table (i.e. CP) [09]
; Exit:
;	cx = size of res word's name
;	dx = size of res word's atr block
;	si points to 1st byte of res word name
;	preserves bx,di,es
;
; GetRwFromTab is a FAR entry point. It has the following DIFFERENCE:
;	es is not expected to be anything on entry,
;	on exit ax = size of res word's name instead of cx
;	Does not guarantee that bx and es are preserved
;*************************************************************************
PUBLIC	GetRwFromTabCP
GetRwFromTabCP PROC NEAR
	lods	BYTE PTR es:[si]	;al = (cbNam << 4) + cbAtr
	inc	al			;test al for FF
	jz	CbsInWord		;brif cbNam and cbAtr stored
					;	in following word
	dec	al			;restore al = Cbs
	sub	ah,ah			;ax = (cbNam << 4) + cbAtr
	mov	dx,ax			;dx = (cbNam << 4) + cbAtr
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1			;ax = cbNam
	mov	cx,ax			;cx = cbNam
	and	dl,15			;dl = cbAtr
	ret

CbsInWord:				
	lods	WORD PTR es:[si]	;al = #bytes of attributes
					;ah = #bytes in reserved word
	mov	cl,ah
	xor	ch,ch			;cx = #bytes in reserved word
	xor	ah,ah
	xchg	dx,ax			;dx = #bytes of attributes
	ret				
GetRwFromTabCP ENDP

sEnd	CP				
sBegin	LIST				
assumes CS,LIST				

;***************************************************************************
; ListStrNode/ListLitStrNode
;	Rewritten for revision [18]
; Purpose:
;	Copy the content of an LNT_STR node to the output buffer.
;	Value is a 16 bit offset followed by 16 bit count
;	which identifies where the string is in the text table.
;	
;       Special processing is needed for listing LitStrNode's 
;	to handle listing '"' in a string.
;
; Entry:
;	bx = LNT_STR or LNT_LITSTR
;
;***************************************************************************
ListLitStrNode:
DbPub ListStrNode
ListStrNode:
	push	si			;preserve si
	mov	cx,WORD PTR [si.LN_val_cbStr]
					;cx = length of string
	mov	si,WORD PTR [si.LN_val_oStr]
					;si = offset into text table to string
	call	ChkDstFull		;make sure there's room for cx bytes
					; in dest buffer.  If not, don't return
	GETSEG	ds,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[4]
					;ds = seg for current text table
	push	ss			
	pop	es			;es = DGROUP
	rep	movsb
	push	es
	pop	ds			;restore ds = DGROUP
LSNZeroLenExit:
	pop	si			;restore si
	jmp	Stg2Cont


;***************************************************************************
; ListEnStrNode
; Purpose:
;	Decode and copy the content of an LNT_ENSTR node to the output buffer.
;	Value is a 16 bit offset followed by 16 bit count
;	which identifies where the encoded string is in the text table.
;	An encoded string consists of standard ascii text, with character
;	runs of > 3 identical chars contained in a "compression" record.
;	The compression record, and format is described in prsutil.asm,
;	and basically consists of a flag byte, followed by a byte containing
;	the repetition factor, and the final byte is the character which
;	was repeated.
;
;***************************************************************************
DbPub	ListEnStrNode
ListEnStrNode:
	push	si			;preserve si
	mov	cx,WORD PTR [si.LN_val_cbEnStr]
					;cx = length of string
	jcxz	ListEnStrExit		;brif no text to list
	mov	si,WORD PTR [si.LN_val_oEnStr]
					;si = offset into text table to string
	call	ChkDstFull		;make sure there's room for cx bytes
					; in dest buffer.  If not, don't return
	GETSEG	ds,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[4]
					;ds = seg for current text table
	push	ss
	pop	es			;es = DGROUP
EnStrLoop:
	lodsb				;get char
	cmp	al,STR_EncodedText	;is this the start of a compression
	je	ExpandText		; record?  brif so
	stosb				;list char
EnStrCont:
	loop	EnStrLoop		;continue until all chars listed

	push	es
	pop	ds			;restore ds = DGROUP
ListEnStrExit:
	pop	si			;restore si
	jmp	Stg2Cont

ExpandText:
	lodsw				;al = cbChars, ah = char
	dec	cx
	dec	cx			;adjust for size of compression record
	push	cx			;save cbCompressed
	mov	bx,di			;bx = current dest ptr
	add	bx,cx			;bx = result dest ptr (end of string)
					; before expanding text
	mov	cl,al
	sub	ch,ch			;cx = cbExpand
	mov	al,ah			;al = char
	add	bx,cx			;bx = result dest ptr after expansion
	jc	J1_ListDstFull		;brif wrapped past FFFF (buf too small)
	cmp	bx,es:[pbDstWarning]
	jae	J1_ListDstFull		;brif string too big - grow dst buffer

	rep	stosb			;blast out the encoded char string
	pop	cx			;recover cbLeft to list
	jmp	short EnStrCont 	;continue listing encoded string

J1_ListDstFull:
	push	es
	pop	ds			;reset ds to DGROUP
	jmp	ListDstFull


;***************************************************************************
; ListCsStrNode
; Purpose:
;	Copy the content of an LNT_CSSTR node to the output buffer.
;	Value is a 16 bit offset followed by 16 bit count
;	which identifies where the string is in the LIST segment.
;
;***************************************************************************
ListCsStrNode:
	push	si			;preserve si
	mov	si,WORD PTR [si.LN_val_CsStr]
					;si = offset into LIST segment to
					; str255 struct for string
	push	ds
	pop	es			;es = DGROUP
	push	cs
	pop	ds			;ds = code segment (LIST)
	lodsb				;al = length of string constant
					;si points to 1st byte of string
	cbw				;ax = length of string constant
					; NOTE: implies no LIST string constant
					; is longer than 128 bytes (very safe)
	xchg	cx,ax			;cx = length of string
	rep movsb			;copy string to destination buffer
	push	es
	pop	ds			;restore ds = DGROUP
	pop	si			;restore si
	jmp	Stg2Cont

;***************************************************************************
; ListSpacesNode
; Purpose:
;	Copy the content of an LNT_SPACES node to the output buffer.
;	Value is a 16 bit count of spaces
;
;***************************************************************************
ListSpacesNode:
	mov	cx,WORD PTR [si.LN_val_cbSpaces]
					;cx = number of spaces to emit
;cx = number of spaces to list
ListCol1:
	call	ChkDstFull		;make sure there's room for cx bytes
					; in dest buffer.  If not, don't return
	push	ds
	pop	es			;es = DGROUP
	mov	al,' '
	rep stosb			;store spaces in destination buffer
J1_Stg2Cont:
	jmp	Stg2Cont		;return to outer loop

;***************************************************************************
; ListColNode
; Purpose:
;	Emit white space until we get to indicated column.
;	Value is a 16 bit column to advance to.
;	High bit of argument is set if at least 1 space needs
;	to be output even if we're beyond the specified column.
;
;***************************************************************************
ListColNode:
	mov	bx,[pbdDst]
	mov	cx,[bx.BD_pb]		;cx points to destination buffer
	mov	ax,WORD PTR [si.LN_val_col]
	mov	dx,ax			;high bit of dx is set if at least
					; 1 space is to be output
	and	ah,7Fh			;ax = column to advance to
	add	cx,ax
					;cx points to column to advance to
	sub	cx,di			;subtract current column
	ja	ListCol1		;brif not already past that column
	mov	cx,1
	or	dx,dx
	js	ListCol1		;always list at least 1 space
	jmp	SHORT J1_Stg2Cont	;return to outer loop

subttl	List a numeric constant

;Table which maps LIT_xxx to runtime library's value types as follows:
;
; If the high bit is set, its a "special" number and:
;    the low 7 bits mean: 00cbbbbb where:
;        c = 0 for 16 bit integer, 1 for 32 bit integer,
;        bbbbb = base value (2, 8 or 16)
; Else the remaining 7 bits are the "runtime" value type
;    The runtime uses the convention that the low 4 bits = length of value
;
OrdConstStart 0
OrdConst LIT_I2		; % suffix
OrdConst LIT_O2		; &O prefix
OrdConst LIT_H2		; &H prefix
OrdConst LIT_I4		; & suffix
OrdConst LIT_O4		; &&O prefix
OrdConst LIT_H4		; &&H prefix
OrdConst LIT_R4		; ! suffix
OrdConst LIT_R8		; # suffix
OrdConst LIT_STR	; "xxx"

SNM_LONG EQU 40H	;indicates LONG special number

mpLtToRt LABEL WORD
	DB	VT_I2,0			;LIT_I2
	DB	084H,'O'		;LIT_O2
	DB	090H,'H'		;LIT_H2
	DB	VT_I4,'&'		;LIT_I4
	DB	0C4H,'O'		;LIT_O4
	DB	0D0H,'H'		;LIT_H4
	DB	VT_R4,'!'		;LIT_R4
	DB	VT_R8,'#'		;LIT_R8


;***************************************************************************
; ListNumNode
; Purpose:
;	List a numeric constant to the output buffer.
;
;***************************************************************************
DbPub ListNumNode
ListNumNode:
	push	si			;preserve node ptr
	GETSEG	es,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[4]
					; es = seg for current text table
	xor	bh,bh
	mov	bl,[si.LN_val_clNum]	;bx = type of num (LIT_D2...LIT_LINENUM)
	mov	si,[si.LN_val_otxNum]	;es:si points to number
	cmp	bl,LIT_LINENUM
	je	ListUnsigned		;brif linenum


.errnz	LIT_I2
	or	bl,bl			;I2?
	jz	ListSigned
	shl	bx,1
	mov	ax,[mpLtToRt+bx]	;al = runtime's value type
					;ah = explicit type char
	or	al,al
	js	HexNum			;brif hex/octal/binary constant
	push	ds			;swap ds,es
	push	es
	pop	ds			;ds = seg adr of text table
	pop	es			;es = DGROUP
	mov	cx,ax			;cx = runtime's value type
	and	cx,000FH		;cx = # bytes in value
	push	di
	lea	di,[numBuf]		;di points to temp 8 byte buffer
	rep movsb			;copy value from pcode to numBuf
	pop	di			;restore di=ptr to next list byte
	push	es
	pop	ds			;restore ds = es = DGROUP

;al=runtime's value type, ah=explicit type char
CallFout:
	lea	bx,[numBuf]		;bx points to temp 8 byte buffer
	cmp	ah,'&'
	jne	NotLong
	push	ax
	mov	ax,[bx]
	cwd				;dx = 0 if ax <= 7FFF, else FFFF
	sub	dx,[bx+2]		;dx = 0 if number could be represented
					; as a short integer (i.e. '&' required)
	pop	ax
	je	NotLong			;brif '&' is necessary
	sub	ah,ah			;else list no explicit char
NotLong:
	call	far ptr ListNum		;copy ASCII number to di
NumDone:
	pop	si			;restore node ptr
	jmp	Stg2Cont		;return to outer loop

ListSigned:
	mov	si,es:[si]		;Get number to si
;	jmp	short ListUnsigned

DbPub	ListUnsigned
ListUnsigned:
;16-bit integer in si
	push	ds
	pop	es			;es=ds=dgroup
	xchg	ax,si			;put number in ax
	xor	cx,cx			;Initialize count of digits
	mov	bx,10
;While >10, divide by 10, counting digits
NextDig:
	inc	cx			;Count all digits
	cmp	ax,bx			;Less than 10?
	jb	SaveDig
	xor	dx,dx			;Extend to DWord
	div	bx			;Next digit is remainder in dx
	push	dx			;Save digit on stack
	jmp	NextDig

SaveDig:
	add	al,"0"			;Add ASCII bias
	stosb				;List a digit
	pop	ax			;Get next digit from stack
	loop	SaveDig
	xchg	si,ax			;Last thing popped was node pointer
	mov	byte ptr [di],0		;Terminate with zero
	jmp	Stg2Cont


;al & SNM_LONG is non-zero if LONG, ah = 'H', 'O', 'B' for hex,octal,binary
;es = text table's segment
;di = pointer to next byte to be listed (destination)
HexNum:
	push	ax			;save fLong
	xchg	bx,ax			;bl = fLong, bh = base char
	lods	WORD PTR es:[si]	;ax = low word of constant
	xchg	dx,ax			;dx = low word of constant
	sub	ax,ax			;default high word = 0
	test	bl,SNM_LONG
	je	NotLongHex		;branch if I2 constant
	lods	WORD PTR es:[si]	;ax = high word of constant
NotLongHex:
	mov	bl,'&'			;list '&'
	mov	[di],bx			;store &H, &O, or &B
	inc	di
	inc	di
	xchg	ax,dx			;dx:ax = I4 to output
	push	dx			;save high-word
	call	far ptr ListBaseNum
	pop	dx			;restore high-word
	pop	ax			;al = fLong
	or	dx,dx
	jne	NumDone			;brif implicitly long
	test	al,SNM_LONG
	je	NumDone			;brif implicitly short
	mov	BYTE PTR [di],'&'	;list second '&' to indicate long
	inc	di
	jmp	SHORT NumDone		;return to outer loop

;***************************************************************************
; ListBaseNum
; Purpose:
;	Copy the ASCII equivalent of a hex/octal number to a buffer
; NOTE:
;	This function assumes that the following runtime functions
;	cannot result in a runtime error: B$FCONVBASE, B$IFOUT
; Entry:
;	dx:ax = I4 to output
;	ds:di points to destination buffer
;	dh = 'H' or 'O' for hex/octal
; Exit:
;	di points beyond last byte of number (i.e. TO 0-byte terminator)
;	es = ds
;	
;***************************************************************************

cProc	ListBaseNum,<PUBLIC,FAR>,<si>

cBegin
; bh = 'H' for Hex, 'O' for Octal
; dx:ax = I4 to convert
; di points to next free byte in output buffer
;
DoConv:
	mov	cx,0F04h		;ch=mask, cl=shift count
	cmp	bh,'H'
	je	GotHex
	mov	cx,0703h		;ch=mask, cl=shift count
	DbAssertRelB bh,e,'O',LIST,<ListBaseNum called with bad dh>

GotHex:
	lea	bx,[di+12d]		;bx points to end of 12 byte buffer
	call	B$FCONVBASE		;dx points to 1st byte of result
					;bx = number of digits
					;es = ds
	mov	cx,bx			;cx = number of digits
	mov	si,dx			;bx points to 1st digit
	rep movsb			;copy ASCII string to list buffer
LBNExit:
	mov	BYTE PTR [di],0		;0 terminate result
cEnd


;***************************************************************************
; ListNum
; Purpose:
;	Copy the ASCII equivalent of a binary number to a buffer
;	Used by WATCH pcode as well as lister.
; Entry:
;	al = type of number (VT_I2, VT_I4, VT_R4, VT_R8, VT_CY (EB specific))
;	ah = explicit terminating char (i.e. %, !, &, #, @ (EB specific))
;	bx points to 1st byte of binary number (in DS)
;	di points to destination buffer (in DS)
; Exit:
;	di points beyond last byte of number (i.e. TO 0-byte terminator)
;	es = ds
;
;***************************************************************************
cProc	ListNum,<PUBLIC,FAR>,<si>
cBegin
	push	ds
	pop	es			;es = DGROUP
	push	ax			;save ah=explicit type char
					; pass B$IFOUT ptr to value in es:bx
					; pass B$IFOUT valTyp in al
	call	B$IFOUT			;bx = adr of ascii string
					;ax = byte count
	pop	dx			;restore dh = explicit type char
	cmp	BYTE PTR [bx],' '
	jne	NoSpc			;brif no leading space
	inc	bx			;skip leading space
	dec	ax
NoSpc:
	xchg	cx,ax			;cx = # bytes in ASCII string
	mov	si,bx			;si points to start of ASCII string

	;copy ascii string from BIFOUT's static buffer to result buffer
NumLoop:
	lodsb				;al = next byte to transfer
	stosb				;list it
	cmp	al,'E'
	je	Not0to9
	cmp	al,'D'
	je	Not0to9
	cmp	al,'.'
	jne	Its0to9
	cmp	dh,'#'
	je	Its0to9			;. isn't strong enough to not list #
					;else 10.5# would list as 10.5 (R4)
	cmp	dh,'@'
	je	Its0to9			;same goes for @
Not0to9:
	sub	dh,dh			;no explicit type needed, we got
					; a period, E or D
Its0to9:
	loop	NumLoop
	or	dh,dh
	je	LnExit			;brif not explicit type char needed
	mov	al,dh			;al = explicit type char
	stosb				;list it
LnExit:
	mov	BYTE PTR [di],0		;0 terminate result
cEnd

;***************************************************************************
; SetLsCursor				; - function added in this rev.
; Entry:
;	ax = number of bytes in line
;	bx = pbdDst
;	[colLsCursor] = column of interest (equivalent to otxLsCursor)
; Exit:
;	dx = column of interest (equivalent to otxLsCursor)
;
;***************************************************************************
cProc	SetLsCursor,<NEAR>,<si>
cBegin
	mov	cx,UNDEFINED		;for cheaper comparisons below
	mov	dx,[colLsCursor]
	cmp	dx,cx
	jne	NotStmtEnd		;brif colLsCursor already set
	cmp	[ndLsCursor],cx
	je	NoColCursor		;brif otxLsCursor wasn't in line
	xchg	dx,ax			;else, this is it, dx=column

;Make sure that column of interest isn't pointing to a blank,
;If it is, make first token after blank column of interest
NotStmtEnd:
	cmp	dx,cx
	je	NoColCursor		;brif otxLsCursor not in this line
	mov	si,[bx.BD_pb]		;si points to 1st byte of result
	add	si,dx			;si points to column of interest
SkipBlanks:
	lodsb				;al = byte at column of interest
	cmp	al,' '
	je	SkipBlanks
	cmp	al,0
	je	NoColCursor		;brif blanks are at end-of-line
	dec	si			;si points to 1st non blank
	mov	dx,si
	sub	dx,[bx.BD_pb]		;dx = offset to 1st non blank
NoColCursor:
cEnd


;***************************************************************************
; B$FConvBase
; Purpose:
;	Convert an I4 to ASCII Hex/Octal/Binary without causing any
;	Heap Movement.  This is needed by QBI.
; Entry:
;	BX points beyond last byte of 11 byte buffer (32 bytes for _BFBIN)
;	CH = Mask, CL = Shift count, i.e.
;	   0703 for Octal, 0F04 for Hex
;	DX:AX = number to convert
; Exit:
;	DX points to 1st byte of resulting string
;	BX = number of digits in resulting string
;	ES = DS
;
;***************************************************************************
cProc	B$FCONVBASE,<NEAR>,<DI>	
cBegin
	MOV	DI,BX		;DI points beyond destination
	XCHG	AX,BX		;DX:AX = I4 to be converted
	STD			;move from high to low
	PUSH	DS		;set ES=DS
	POP	ES
	XOR	AH,AH		;init char count

; At this point the following conditions exist:
;	AH = Character count
;	CH = Mask
;	CL = Shift count
;	DX:BX = I4 to convert
;	DI = pointer to digit buffer
; Perform the conversion by shifting DX:BX by CL bits and masm out
; unused bits with CH.	Take this number and convert to ascii char
; representing digit. Stuff the char in the buffer, bump the char
; count and continue until no non-zero digits remain.

CONVERT_LOOP:
	MOV	AL,BL		;Bring number to accumulator
	AND	AL,CH		;Mask down to the bits that count
;Trick 6-byte hex conversion
	ADD	AL,90H
	DAA
	ADC	AL,40H
	DAA			;Number in hex now
	STOSB			;Save in string
	INC	AH		;Count the digits
	PUSH	CX		;Save mask/shift count
	XOR	CH,CH		;zero out mask, leaving shift count

SHIFT_LOOP:
	SHR	DX,1		;shift low bit into carry, zero high bit
	RCR	BX,1		;rotate carry into low word
	LOOP	SHIFT_LOOP	;repeat shift count times

	POP	CX		;recover mask/shift count
	PUSH	BX
	OR	BX,DX		;is rest of I4 = 0?
	POP	BX
	JNZ	CONVERT_LOOP	;brif not, convert next digit

	CLD			;Restore direction UP
	INC	DI		;Point to most significant digit
	MOV	DX,DI		;Put string pointer in DX
	MOV	BL,AH		;Digit count in BX (BH already zero)
cEnd
sEnd	LIST

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\lsid.asm ===
TITLE	LSID - Contains functions for listing id related opcodes

;======================================================================
; Module: lsid.asm
;
; Purpose:
;	Contains functions for listing id related opcodes
;
;
;=======================================================================*/

	include		version.inc
	LSID_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce lister
	includeOnce lsint
	includeOnce names
	includeOnce opmin
	includeOnce pcode
	includeOnce prsorw
	includeOnce prstab
	includeOnce qblist
	includeOnce scanner
	includeOnce txtmgr
	includeOnce types
	includeOnce variable

	PERIOD_ID EQU ON		;record.element, not record->element

	assumes	DS,DGROUP
	assumes	SS,DGROUP
	assumes	ES,NOTHING

FV_ARYELEM EQU 1

sBegin	DATA

orwDecl DW	0			;temporary location used to
					;store the reserved word for the
					;the declaration stmt currently
					;being listed: AUTO,PUBLIC,STATIC,DIM



ET_MAX_NOFIELDS = ET_MaxStr
sEnd	DATA

sBegin	LIST
assumes	CS,LIST

; Code Segment Tables

;Table for mapping ET_xxx to DEFxxx reserved word
tRwDefType LABEL WORD
	DW	ORW_DEFINT		;res word for ET_I2
	DW	ORW_DEFLNG		;res word for ET_I4
	DW	ORW_DEFSNG		;res word for ET_R4
	DW	ORW_DEFDBL		;res word for ET_R8
	DW	ORW_DEFSTR		;res word for ET_SD



subttl	Beginning/End of line/statement opcodes

;------------------------------------------------------------------
;	Beginning/End of line/statement opcodes
;------------------------------------------------------------------

;===========================================================================
;			 List Rules
;
;	Each of these functions takes 0 or more nodes off oNodeRoot's list
;	and adds 0 or more nodes as indicated in its header comment.
;
;	On Entry, each of these routines can expect:
;		SI points to opcode's operand (if any)
;		DI points to node to be created (if any)
;		AX = opcode being listed
;		BX = 2 * opcode being listed
;
;===========================================================================

;	+-------------------------------------------+
;	| Beginning-of-line / End-of-text List Rules|
;	+-------------------------------------------+

;	[...] ==> [linenum ...] or [: label ...]
;
EatLabelDef PROC NEAR
	inc	si			;skip link field
	inc	si
	lods	WORD PTR es:[si]	;ax = label's oNam operand
	call	NewLabelONam		;Create either LNT_ONAM for label
					; or LNT_NUM for line number,
					; ax = offset to newly created node
	or	dl,dl
	jne	GotLineNum		;brif not an alphanumeric label
	call	PushRoot		;push label's oNam node
	mov	al,':'
	call	NewChar			;ax = offset to ":" node
GotLineNum:
	jmp	PushRoot		;push line number node or ':' 
EatLabelDef ENDP

; Emit n spaces. CX = emitted space count on return
Spc	PROC NEAR
	lods	WORD PTR es:[si]	;ax = space count
Spc	ENDP
	;fall into SpcAX
SpcAX	PROC NEAR
	push	ax			;save cSpaces
	call	NewSpaces		;ax = offset to spaces node
	pop	cx			;cx = space count
	jmp	PushRoot		;return to caller
SpcAX	ENDP

LrEotInclude:
	cmp	[fViewInclude],0
	jne	LrEot1			;brif INCLUDEd lines are visible
	dec	si
	dec	si			;si points to the BolInclude[Sp] opcode
	mov	[otxListNextInc],si	;save it for caller of ListLine
	push	es			;preserve seg addr of text table
	push	si
	call	OtxNoInclude		;ax = otx to opBol/opEot for next line
					; which has no $INCLUDE
	pop	es			;restore seg addr of text table
	xchg	si,ax			;si = otx to opBol/opEot for next line
					; which has no $INCLUDE
	jmp	Stage2Inc


ListRule LrEot
 	cmp	[fGotBol],0		
 	jne	LrEot1			;brif we've seen an opBol
 	mov	[ndLsCursor],UNDEFINED	;if called to list beyond eot, don't
 					; highlight it as current stmt
LrEot1:
	dec	si
	dec	si			;si = text offset to terminating opcode
J1_Stage2:
	jmp	Stage2

ListRule LrBolLab
	cmp	[fGotBol],0
	jne	LrEot1			;brif this is 2nd Bol opcode
	;fall into LrLab
ListRule LrLab
	call	EatLabelDef
	call	PushRootSpc		;terminate with a space
	jmp	SHORT LrBol2

ListRule LrBolLabSp
	cmp	[fGotBol],0
	jne	LrEot1			;brif this is 2nd Bol opcode
	;fall into LrLabSp
ListRule LrLabSp
	call	EatLabelDef
	call	Spc			;consume and handle space-count operand
	jmp	SHORT LrBol2

ListRule LrBolInclude
	cmp	[fGotBol],0
	jne	LrEotInclude		;brif this is 2nd Bol opcode
					; seen so far in this line
	lods	WORD PTR es:[si]	;ax = $INCLUDE nesting depth
	mov	[fLsIncluded],al	;tell ListLine's caller this is
	jmp	SHORT LrBol1		; an INCLUDEd line

ListRule LrBolIncludeSp
	cmp	[fGotBol],0
	jne	LrEotInclude		;brif this is 2nd Bol opcode
					; seen so far in this line
	lods	WORD PTR es:[si]	;ax = $INCLUDE nesting depth
	mov	[fLsIncluded],al	;tell ListLine's caller this is
					; an INCLUDEd line
	;fall into LrBolSp
ListRule LrBolSp
	cmp	[fGotBol],0
	jne	LrEot1			;brif this is 2nd Bol opcode
	call	Spc			;consume and handle space-count operand
	jmp	SHORT LrBol3		;cx = space count

ListRule LrBol
	cmp	[fGotBol],0
	jne	LrEot1			;brif this is 2nd Bol opcode
	mov	ax,[opList]		;ax = opcode (as saved by DispLs1)
;ax = opcode and high-bit operands
	.errnz	OPCODE_MASK - 3FFh
	shr	ah,1
	shr	ah,1			;ah = high-bit operand
	je	LrBol1			;brif no leading spaces
	.errnz	opBol
	xchg	ah,al			;ax = high-bit operand
	call	SpcAX
	jmp	SHORT LrBol3

ListRule LrEndProg

ListRule LrWatchExp
ListRule LrWatchStop
	cmp	[fGotBol],0
	jne	LrEot1			;brif this is 2nd Bol opcode
					; seen so far in this line
LrBol1:
	sub	al,al
	call	PushRootChar		;list null node, so Stg2Loop will
					; have something after ndLsCursor
					; in case this is the opcode identified
					; by otxLsCursorTmp
	;fall into LrBol2
LrBol2:
	mov	cl,LOW UNDEFINED	;no leading spaces on line
LrBol3:

;NOTE: the leading space count is used when entabbing leading spaces during
;	 ASCII save.  This won't work if cbLeading > 254, but who cares?

	mov	[fGotBol],cl		;remember we've seen the first BOL
					;also specifies number of leading spaces
	mov	[lsBolFlags],0		;reset beginning of line flags
LrBos1:
	mov	[lsBosFlagsWord],0	;reset beginning of stmt flags
					;sets lsBosFlags & lsBosFlags2
J1_Stg1Loop:
	jmp	Stg1Loop		;return to outer loop

ListRule LrBos
	mov	ax,' :'
	call	PushRootChars		;list ": "
	jmp	SHORT LrBos1

ListRule LrBosSp
	mov	al,':'
	call	PushRootChar
	lods	WORD PTR es:[si]	;ax = column operand
	call	NewCol1			;ax = "advance to column(ax)" node
	call	PushRoot		;list it
	jmp	SHORT LrBos1

subttl Expression related list rules

;------------------------------------------------------------------
;		Expression related list rules
;------------------------------------------------------------------

;***************************************************************************
; LrBinaryOp
; Purpose:
;	List a binary operator opcode like opAdd
;	[expRight expLeft] ==> [[expRight operator expLeft]]
;
;***************************************************************************
ListRule LrBinaryOp
	call	PopRootPushTemp		;move expRightNode from root to temp stk
	call	PushTempSpc		;surround operator with blanks
	call	PushTempOpChars		;list opcode's char(s)
	call	PushTempSpc		;surround operator with blanks
BinaryOp1:
	call	PopRootPushTemp		;move expLeftNode from root to temp stk
PUBLIC	PushRevListStg1
PushRevListStg1:
	call	PushRevList		;move temp stk to root in reverse order
	jmp	Stg1Loop		;return to outer loop

;***************************************************************************
; LrBinaryRw
; Purpose:
;	List a binary reserved-word operator opcode like opXor
;	[expRight expLeft] ==> [[expRight operator expLeft]]
;
; Algorithm:
;	opNode = NewRw(opcode)
;	expRightNode = PopRoot()
;	expLeftNode = PopRoot()
;	PushTemp(expLeftNode)
;	PushTemp(opNode)
;	PushTemp(expRightNode)
;	PushList()
;
;***************************************************************************
ListRule LrBinaryRw
	call	PopRootPushTemp		;move expRightNode from root to temp stk
	call	PushTempSpc		;surround operator with blanks
	call	PushTempOpRwSpc		;push res word node to temp stack
	jmp	SHORT BinaryOp1

;***************************************************************************
; LrLParen
; Purpose:
;	List the opcode (exp)opLParen
;	[exp] ==> [[")" exp "("]]
;
;***************************************************************************
ListRule LrLParen
	call	PushTempLParen		;push '(' onto temp stack
	call	PopRootPushTemp		;move expNode from root to temp stk
	call	PushTempRParen		;push ')' onto temp stack
	jmp	PushListStg1		;push temp list to root as 1 node

subttl Id related opcodes

;------------------------------------------------------------------
;			Id related opcodes
;------------------------------------------------------------------

PUBLIC PushTempONam
PushTempONam PROC NEAR
	call	NewONam 		;ax = offset to new ONam node
	jmp	PushTemp		;push node to temp stack
					; and return to caller
PushTempONam ENDP

;***************************************************************************
; PushTempId
; Purpose:
;	Consume an id opcode and push the following nodes to the temp stack:
;	(typeChar oNam)
;
; Entry:
;	si points to id's operand
;	di = offset to next free byte in bdNodes
;	FBOS_DoIdCommas is set if ", " is to be pushed to the root stack
;	   before this id is pushed to the temp stack
; Exit:
;	si points beyond id's operand
;	di is updated
;	typeChar oNam are pushed to the temp stack
;
;***************************************************************************
PushTempId PROC NEAR
	call	PushTempIdComma		;list ", " if we're in COMMON/SHARED
	call	NewId			;consume id's operand, ax = node
	call	PushTemp
PushTempId ENDP
	;fall into PushEt		;push explicit type (if any)
PushEt	PROC NEAR
.errnz	OPCODE_MASK - 3FFh
	mov	bl,BYTE PTR[opList+1]	;bl = high byte of original opcode
	shr	bl,1			
	shr	bl,1			;shift off low two bits
	jz	J1_Ret			;brif not an explicit type
	xor	bh,bh			;bx = ET_<type>
	mov	al,CS:tcEt[bx - 1]	;al = explicit type char
	call	PushTempChar		;push a char node (al) onto temp stack
	jmp	CharToCharTok		;convert it to a LNT_CHARS_TOK node
					;and return to caller
PushEt	ENDP

;***************************************************************************
; PushTempElem
;	Added as part of revision [14]
; Purpose:
;	Load the next word representing a record element
;	(which is an oNam if we're in rude or an oElem if we're not).
;	Push a "." and then a node containing the oNam of the element
;	onto the Temp stack.
;		[] ==> [ElementName "."]
; Entry:
;	[pIdLdOperand] is a pointer to the operand of the IdLd opcode
;	whose element is referenced.
;
;***************************************************************************
PushTempElem PROC NEAR
	mov	al,'.'
	call	PushTempChar		;push "." onto temp stack
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	lods	WORD PTR es:[si]	;ax = oNam or oElem
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	PTEExit 		;brif table is in rude-edit state
	;ax is oElem parm to ONamOElem
	push	es			;preserve seg addr of text table
	cCall	ONamOElem,<ax>		; ax = oNam for element oElem
GotONam:
	pop	es			;restore seg addr of text table
PTEExit:
	call	PushTempONam		;push oNam
	jmp	SHORT PushEt		;push explicit type (if any)
					; and return to caller
PushTempElem ENDP

;***************************************************************************
; PushOffId
; Purpose:
;	Consume an id offset opcode's operand, and an id from the root
;	stack, and push the following nodes to the temp stack:
;	  [id ...]  ==>  [[typeChar oNam '.' id] ...]
; Entry:
;	mpOpLsArg[bx] = explicit type char (0 if none)
;	si points to opOffxxx's operand
;	di = offset to next free byte in bdNodes
; Exit:
;	si points beyond opcode's operand
;	di is updated
;
;***************************************************************************
PUBLIC	PushOffId
PushOffId PROC NEAR
	call	PopRootPushTemp		;move id node from Root to temp stack
	jmp	SHORT PushTempElem	;push "." and "elem_name"
PushOffId ENDP

;***************************************************************************
; PushTempAId
; Purpose:
;	push array id & indicies onto temp stack
;	  [[")" indexN "," ... index1 "(" typeChar oNam]]
; Entry:
;	root stack: [indexN ... index1 ...] ==>
;	temp stack: [...]
; Exit:
;	root stack: [...]
;	temp stack: [")" indexN "," ... index1 "(" typeChar oNam ...]
;
;***************************************************************************
NO_ARY_ARGS EQU 8000H

PushTempAId PROC NEAR
	call	PopAsClause		;ax = offset to [AS <type>] node
					; (0 if no AS <type> clause)
	push	ax			;list AS <type> later
	lods	WORD PTR es:[si]	;ax = count of indicies
	mov	[cLsArgs],al		;save count of indicies
	push	ax
	call	PushTempId		;consume oNam operand, push nam node
	pop	ax
.errnz	NO_ARY_ARGS - 8000H
	or	ax,ax
	js	NoAryArgs		;got an array like ERASE A
					; with no indecies
	call	PushTempLParen		;push '(' onto temp stack
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	call	PushTempRParen		;push ')' onto temp stack
NoAryArgs:
	pop	ax			;ax = offset to [AS <type>] (if any)
	or	ax,ax
	je	J1_Ret			;brif no AS <type> clause  (return)
	call	PushTemp		;list after id(...)
J1_Ret:
	ret
PushTempAId ENDP

;
; push a comma onto temp stack if FBOS_DIM flag is set
; Added as part of revision [36]
PushTempIdCommaDim PROC NEAR
	test	lsBosFlags2,FBOS2_Dim
	je	NoIdComma		;brif not in DIM/AUTO etc.
	test	lsBosFlags,FBOS_NextIdComma
	je	FirstId			;brif first id in list, no leading comma
	call	PushTempCommaSpc	;output a ', '
FirstId:
	or	lsBosFlags,FBOS_NextIdComma
NoIdComma:
	ret
PushTempIdCommaDim ENDP

;***************************************************************************
; LrIdLdxxx
; Purpose:
;	List the id opcodes as follows:
;	opIdLdxxx:  [...] ==> [typeChar oNam ...]
;	opIdRfxxx:  [...] ==> [typeChar oNam ...]
; Entry:
;	mpOpLsArg[bx] = explicit type char (0 if none)
;            
;***************************************************************************
ListRule LrVtRf
	call	PushTempIdCommaDim	;list ',' if in DIM type statement
SkipCommaDim:
ListRule LrIdLd				
ListRule LrIdRf
ListRule LrIdRfTyp
	call	PushTempId		;PushTemp(<typeChar> <oNam>)
	call	PopAsClause		;ax = offset to [AS <type>] node
					; (0 if no AS <type> clause)
	or	ax,ax
	je	NoIdAsClause
	call	PushTemp		;list after id
NoIdAsClause:
PUBLIC	PushListStg1
;push temp list to root as 1 node and return to outer loop
PushListStg1:
	call	PushList		;move temp stk to root as 1 node
	jmp	Stg1Loop		;return to outer loop

ListRule LrIdSt
ListRule LrIdStTyp
	test	[lsBosFlags2],FBOS2_CONST
	je	NotInConst		;brif not listing CONST stmt
	test	[lsBosFlags2],FBOS2_CONST_COMMA
	je	Not1stConst		;brif not listing CONST stmt
	call	PushTempCommaSpc	;list ", "
Not1stConst:
	or	[lsBosFlags2],FBOS2_CONST_COMMA
NotInConst:
	call	PushTempId		;PushTemp(<typeChar> <oNam>)
ListAStType1:
	call	PushTempSpc		;surround '=' with spaces
	mov	ax,' ='
	call	PushTempChars		;push a char node (ax) onto temp stack
	call	PopRootPushTemp		;move expNode from root to temp stk
	jmp	SHORT PushListStg1	;push temp list to root as 1 node
					; and return to outer loop

ListRule LrOffALd
	call	PushTempOffAId
	jmp	SHORT PushListStg1
ListRule LrOffASt
	call	PushTempOffAId
	jmp	SHORT ListAStType1

;***************************************************************************
; PushTempOffAId
; Purpose:
;	List the array type element opcode
;	[indexN ... index1 id] ==>
;	  [[")" indexN "," ... index1 "(" typeChar oNam "." id]]
;
;***************************************************************************
PushTempOffAId PROC NEAR
	lods	WORD PTR es:[si]	;ax = cArgs
	mov	[cLsArgs],al
	call	PushTempElem		;next word is the oNam/oElem of field
					;  push "." and fieldname to temp stk
	call	PushTempLParen		;push '(' onto temp stack
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	call	PushTempRParen		;push ')' onto temp stack
	call	PopRoot			;ax = node for record of which
					;  the array is an element
	push	ax			;save ptr to node
	call	PushList		;create single node for array ref
					;  of form ".id(1,2)"
	pop	ax			;recover node for record
	call	PushTemp		;push it onto Temp stack		
	call	PopRootPushTemp		;mov ".id(1,2)" to Temp stack
	ret
PushTempOffAId ENDP

;***************************************************************************
; LrAIdLd [48]
; Purpose:
;	[indexN ... index1] ==>
;	  [[")" indexN "," ... index1 "(" typeChar oNam]]
;
;***************************************************************************
ListRule LrAIdLd
	call	PushTempAId		;push array id & indicies onto temp stk
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;***************************************************************************
; LrAVtRf [48]
; Purpose:
;	[exp ", " exp ", ..., " exp ] ==>
;	  [[")" exp "," ... exp "(" typeChar oNam]]
;	StripOptBase called to convert every other "," to TO
;
;***************************************************************************
ListRule LrAVtRf			
	call	PushTempIdCommaDim	;list ',' if in DIM type statement
	call	PushTempAId		;push array id & indicies onto temp stk
	call	PushList		
	test	[lsBosFlags2],FBOS2_DIM	
	je	AVtRfNotDim		;brif not listing DIM/AUTO etc.			
	call	PopRoot			;ax = offset to node to be DIMed
	call	StripOptBase		;walk through list ax, eliminating
					; nodes created by opDimOptionBase
					; and converting ',' to TO.
					; ax still = offset to node to DIM
	call	PushRoot		;push array node to temp stack
AVtRfNotDim:				
	jmp	Stg1Loop		;					; and return to outer loop

;***************************************************************************
; LrAIdSt, LrAIdStTyp
; Purpose:
;	List the array id assignment opcodes
;	[indexN ... index1 exp ...] ==>
;	  [[exp = [")" indexN "," ... index1 "(" typeChar oNam]] ...]
;
;***************************************************************************
ListRule LrAIdSt
ListRule LrAIdStTyp
	call	PushTempAId		;push array id & indicies onto temp stk
	jmp	ListAStType1

;***************************************************************************
; LrOffLd, LrOffRf, LrOffLdTyp, LrOffRfTyp
; Purpose:
;	List the id opcodes as follows:
;	opIdOffLdxxx:  [id ...] ==> [[typeChar oNam '.' id] ...]
;	opIdOffRfxxx:  [id ...] ==> [[typeChar oNam '.' id] ...]
; Entry:
;	mpOpLsArg[bx] = explicit type char (0 if none)
;            
;***************************************************************************
ListRule LrOffLd
ListRule LrOffRf
ListRule LrOffLdTyp
ListRule LrOffRfTyp
	call	PushOffId
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop
	
;***************************************************************************
; LrOffSt, LrOffStTyp
; Purpose:
;	List the id opcodes as follows:
;	opOffStxxx:  [id exp ...] ==> [exp = [typeChar oNam '.' id] ...]
; Entry:
;	mpOpLsArg[bx] = explicit type char (0 if none)
;            
;***************************************************************************
ListRule LrOffSt
ListRule LrOffStTyp
	call	PushOffId
	jmp	SHORT ListAStType1

;Table for mapping ET_xxx to INTEGER, LONG, ..., STRING
tRwET LABEL WORD
	DW	ORW_ANY			;res word for ET_I2
	DW	ORW_INTEGER		;res word for ET_I2
	DW	ORW_LONG		;res word for ET_I4
	DW	ORW_SINGLE		;res word for ET_R4
	DW	ORW_DOUBLE		;res word for ET_R8
	DW	ORW_STRING		;res word for ET_SD
	DW	ORW_STRING		;res word for ET_TX

;***************************************************************************
; PushTempAsClause
;	rewritten for revision [11]
; Purpose:
;	Called for opAsType, opAsTypeExp, opAsType2 and for proc. parameters
;	to push a spaces node, "AS " and <type> to temp stack.
; Entry:
;	ax = column to advance to (0 if 1 space)
;	bx = if <= ET_MAX then
;		it is a predefined "ET_" type 
;	     or if high bit not set 
;		it is the oNam of a user defined type
;	     otw if high bit is set it is a command equivalent [EB]
;		
;***************************************************************************
PushTempAsClause PROC NEAR
	push	bx			;save Type
	or	ax,ax
	je	OneSpace
	call	NewCol1			;ax = "advance to column(ax)" node
	call	PushTemp		;list it
	jmp	SHORT OneSpace1

OneSpace:
	call	PushTempSpc		;list " "
OneSpace1:

	mov	ax,ORW_As
	call	PushTempRwSpc		;list "AS "
	pop	ax			;ax = Type
	cmp	ax,ET_MAX
	jbe	AsExplicitType		;brif AS INTEGER...STRING
	call	NewONam			;ax = offset to oNam's node
	jmp	SHORT FinishAsClause


AsExplicitType:
	xchg	bx,ax
	shl	bx,1			;bx = type * 2
	mov	ax,tRwET[bx]		;ax = ORW_ANY,ORW_INTEGER .. ORW_DOUBLE
	call	NewRw			;ax = offset to reserved word node
FinishAsClause:
	call	PushTemp
	ret
PushTempAsClause ENDP

;***************************************************************************
; PopAsClause
; Purpose:
;	See if PushTempAsClause has been called since the last PopAsClause,
;	If so, return with ax = offset to [ AS <type>] node.
;	Else, ax = 0
;
;***************************************************************************
PopAsClause PROC NEAR
	sub	ax,ax			;0 = default return value
	test	[lsBolFlags],FBOL_AsClause
	je	NoAryType		;brif not A(...) AS <type>
	and	[lsBolFlags],0FFH - FBOL_AsClause
	call	PopRoot			;ax = offset to [AS <type>] node
NoAryType:
	ret
PopAsClause ENDP


;	[id] ==> [[type AS id]]
;
ListRule LrAsTypeFixed
	lods	WORD PTR es:[si]	;ax = oTyp operand
	xchg	bx,ax			;bx = oTyp operand
	lods	WORD PTR es:[si]	;ax = cb or oNam
	push	ax			;preserve cb or oNam
	sal	bx,1			;carry = 1 means its an oNam
	pushf				;save carry to test later
	shr	bx,1			;restore bx = oTyp
	lods	WORD PTR es:[si]	;ax = column for AS
	call	PushTempAsClause	;push "AS " and <type>
	mov	al,' '
	call	PushTempChar		;push " " to temp stack
	mov	ax,' *'
	call	PushTempChars		;push "* " to temp stack
	popf				;restore flags word
	pop	ax			;restore ax = cb or oNam
	jc	ItsAnONam		;brif its an oNam
	push	si			;preserve text pointer
	xchg	si,ax			;si = string length constant
	mov	ax,LIT_LINENUM * 256 + 2;al = length, ah = constant type
	call	NewNum			;ax = offset to numeric constant node
	pop	si			;restore text pointer
	jmp	SHORT AT2PushTemp	
ItsAnONam:
	call	NewONam			;ax = new ONam node
AT2PushTemp:
	call	PushTemp		;push the new node
	jmp	SHORT EndAsClause

;	[id] ==> [[type AS id]]
;
ListRule LrAsTypeExp
ListRule LrAsType
	lods	WORD PTR es:[si]	;ax = oTyp operand
	xchg	bx,ax			;bx = oTyp operand
	lods	WORD PTR es:[si]	;ax = column for AS
	call	PushTempAsClause	;Push [ AS <type>] to temp stack
EndAsClause:
	or	[lsBolFlags],FBOL_AsClause;remember to call PopAsClause
	jmp	PushListStg1		;return to outer loop

;	[...]  =>  [id]
;
ListRule LrElemRef
	lods	WORD PTR es:[si]	;ax = id's oNam
	call	PushRootONam		;list id
	jmp	Stg1Loop		;return to outer loop

;	[...]  =>  [id()]
;
ListRule LrAElemRef
	inc	si			;until static arrays are allowed
	inc	si			; the index count is ignored
	lods	WORD PTR es:[si]	;ax = id's oNam
	call	NewONam 		;ax = offset to new ONam node
	call	PushTemp		;push oNam note onto temp stack
	mov	ax,')('	
	call	PushTempChars		;push "()" onto temp stack
	jmp	PushListStg1		;push temp list to root as 1 node

;	[...]  ==>  [<id> TYPE]
;
ListRule LrStType
	call	PushRootOpRwSpc		;list "TYPE "
	inc	si			;skip opStType's link operand
	inc	si
	lods	WORD PTR es:[si]	;ax = opStType's oNam operand
	call	PushRootONam		;list type's id
	jmp	Stg1Loop		;return to outer loop


subttl Declarative opcodes

;---------------------------------------------------------------------------
;			Declarative opcodes
;---------------------------------------------------------------------------

;---------------------------------------------------------------------------
; DIM related opcodes
;	Original ASCII Text:
;	  DIM x,a(x),b(y TO z)
;	pcode:
;	  opVtRfImp(x),opStDimScalar,
;	  opDimOptionBase,opIdLdImp(x),opAVtRfImp(2,a),opStDimTo,
;	  opIdLdImp(y),opIdLdImp(z),opAVtRfImp(2,b),opStDimTo
;
;---------------------------------------------------------------------------
ListRule LrDimOptionBase
	mov	al,'?'
	call	PushRootChar		;for now, just list a "?"
	jmp	Stg1Loop		;return to outer loop

; The stmt "DIM SHARED a,b" produces the pcode
; opShared, opIdRef(a), opStDimScalar, opIdRef(b), opStDimScalar
; When opShared is seen, it sets a flag telling opStDimScalar (or
; similar opcode) to list SHARED after DIM.
;
ListRule LrShared
	or	[lsBolFlags],FBOL_Shared
	jmp	Stg1Loop		;return to outer loop

; If opShared has been seen, push SHARED to temp stack
PushTempShared PROC NEAR		
	mov	bx,LISTOFFSET PushTempRwSpc 
	jmp	SHORT PushSharedCommon
PushTempShared ENDP

; If opShared has been seen, push SHARED to root stack
PushRootShared PROC NEAR		
	mov	bx,LISTOFFSET PushRootRwSpc 
PushSharedCommon:
	test	[lsBolFlags],FBOL_Shared
	je	NoShared
	and	[lsBolFlags],0FFH - FBOL_Shared
	mov	ax,ORW_SHARED
	jmp	bx			;push reserved word ax
NoShared:
	ret
PushRootShared ENDP


;***************************************************************************
; LrStReDimTo
; Purpose:
;	if 1st DIM opcode in this statement, list DIM, else list ','
;
;	[[")" expZ "," expY "," expX ... exp1 "(" typeChar oNam]] ==>
;	  [[")" expZ TO expY "," expX ... exp1 "(" typeChar oNam]]
;	opDimOptionBase gets listed as "?" internally, so this function
;	eliminates those nodes when found.
;
;***************************************************************************
ListRule LrStReDimTo
	mov	ax,ORW_REDIM		;ax = reserved word of stmt 
	call	PushTempRwOrComma	;push "," or RW of stmt
	call	PushTempShared		;list SHARED if opShared was seen
	call	PopRoot			;ax = offset to node to be DIMed
; handle the special case where an StReDimTo is being used in place
; of what used to be a StReDimScalar in QB4.0
	test	BYTE PTR[opList+1],HIGH(OPCODE_MASK+1) 
	jnz	GotRedimScalar		;brif if normal ReDimTo
	call	StripOptBase		;walk through list ax, eliminating
					; nodes created by opDimOptionBase
					; and converting ',' to TO.
					; ax still = offset to node to DIM
GotRedimScalar:
	call	PushTemp		;push array node to temp stack
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

;***************************************************************************
; StripOptBase
; Purpose:
;	ax = offset to [[")" exp ", " exp ", " exp "(" typeChar oNam]]
;	walk through this list, eliminating "?" "," nodes (which
;	were created by opDimOptionBase), and converting every other
;	comma to " TO "
; Preserves: ax
;
;***************************************************************************
StripOptBase PROC NEAR
	push	ax
	push	si
	call	ListOffToPtr		;bx = ptr to node ax
	mov	ax,WORD PTR [bx.LN_val_list]
					;bx = offset to 1st node in list
					; This could be ")" or [AS <type>]
	call	ListOffToPtr		;bx = ptr to node ax
	cmp	BYTE PTR [bx.LN_type],LNT_CHAR
	je	StripLoop		;brif it is ")"
	call	ListSibPtr		;bx = sibbling(bx) ")"
StripLoop:
	call	ListSibPtr		;bx = sibbling(bx) (dim's UPPER index)
	call	ListSibPtr		;bx = sibbling(bx) (comma)
	mov	si,bx			;save ptr to it
	mov	WORD PTR [si.LN_val_char],'OT'	;convert comma to TO
	call	ListSibPtr		;bx = sibbling(bx) (dim's LOWER index
					; or "?" put there by opDimOptionBase)
	cmp	BYTE PTR [bx.LN_type],LNT_CHAR
	jne	NotDefault		;brif couldn't be "?"
	cmp	BYTE PTR [bx.LN_val_char],'?'
	jne	NotDefault		;brif not "?"
	sub	ax,ax			;ax = 0
	mov	WORD PTR [si.LN_val_char],ax	;convert comma node to NULL
	mov	WORD PTR [bx.LN_val_char],ax	; and LOWER index node to NULL
NotDefault:
	call	ListSibPtr		;bx = sibbling(bx) (comma or '(')
	cmp	BYTE PTR [bx.LN_val_char],','
	je	StripLoop		;brif ","
StripExit:				
	pop	si
	pop	ax			;ax = offset to node to be DIMed
	ret
StripOptBase ENDP

ListRule LrStErase
	call	PushTempOpRwSpc		;emit opcode's resword (ERASE)
	lods	WORD PTR es:[si]	;ax = opStErase's cnt operand
	mov	[cLsArgs],al
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

; The statement "COMMON SHARED /foo/ a,b" produces the pcode:
; opShared, opCommon(oNam(foo)), opIdVTRef(a), opIdVTRef(b)
;
ListRule LrStCommon
	call	PushRootOpRwSpc		;emit opcode's resword (COMMON)
	call	PushRootShared		;list SHARED if opShared seen
	inc	si			;skip cntEos operand
	inc	si
	lods	WORD PTR es:[si]	;ax = common block's oNam (FFFF if none)
	cmp	ax,UNDEFINED
	je	NotBlockCommon
	push	ax
	mov	al,'/'			;list "/"
	call	PushRootChar
	pop	ax
	call	PushRootONam		;list block's name
	mov	ax,' /'
	call	PushRootChars		;list "/ "
NotBlockCommon:
	or	[lsBosFlags],FBOS_DoIdCommas
					;every opIdVTRef in this statement
					; is to be preceeded by "," except
					; the first.
	jmp	Stg1Loop		;return to outer loop

; The statement "SHARED a,b" produces the pcode:
; opStShared opIdVTRef(a), opIdVTRef(b)
;
ListRule LrStStatic
ListRule LrStShared
	inc	si			;skip oText operand
	inc	si
	call	PushRootOpRwSpc		;emit opcode's resword (SHARED/STATIC)
	or	[lsBosFlags],FBOS_DoIdCommas
					;every opIdVTRef in this statement
					; is to be preceeded by "," except
					; the first.
	jmp	Stg1Loop		;return to outer loop

;	DIM, AUTO, PUBLIC, and EB STATIC
ListRule LrStoClassDecl
	inc	si			; skip oText operand
	inc	si			
	or	[lsBosFlags2],FBOS2_DIM 
	call	PushRootOpRwSpc		
	call	PushRootShared		;list SHARED if opShared seen
	jmp	Stg1Loop		;return to outer loop


;***************************************************************************
; LrStDefType
; Purpose:
;	List opStDefType opcode.  Opcode's operand is link field followed
;	by 32 bit mask/type as follows:
;	   high 26 bits, 1 bit for each letter A..Z
;	   low 6 bits = ET_xx
; Algorithm:
;	letterCur = 'A'-1
;	cLetters = 0
;	fNotFirst = FALSE
;	while mask != 0
;	   letterCur = letterCur + 1
;	   shift mask left 1 bit
;	   if carry is set
;	      if cLetters == 0
;	         if fNotFirst
;	            list ", "
;	         list letterCur
;	         fNotFirst = TRUE
;	      cLetters++
;	   else
;	      if cLetters > 0
;	         if cLetters > 1
;	            list "-"
;	            list letterCur-1
;		 cLetters = 0
;
; Register allocation:
;	letterCur = si
;	cLetters = cl
;	mask = dx:ax
;	fNotFirst = ch
;
;***************************************************************************
ListRule LrStDefType
	inc	si			;skip link field
	inc	si
	lods	WORD PTR es:[si]	;ax = low 16 bits of operand
	xchg	ax,dx			;dx = low 16 bits of operand
	lods	WORD PTR es:[si]	;ax = high 16 bits of operand
	xchg	ax,dx			;[dx:ax] = 32 bit operand
	mov	bl,al			;bl = type
	and	ax,0FFC0H		;ax = bit mask for last 10 letters
	push	si			;save si for duration of routine

	push	ax			;save low 16 bits of operand
	push	dx			;save high 16 bits of operand
	and	bx,03FH			;bx = type
	shl	bx,1			;bx = type * 2
	mov	ax,tRwDefType - 2[bx]	;ax = ORW_DEFINT .. ORW_DEFSTR
	call	PushRootRwSpc		;list DEFINT..DEFSTR

	mov	si,'A'-1		;si = letterCur = 'A'-1
	sub	cx,cx			;cLetters = 0, fNotFirst = 0
DefTypeLoop:
	pop	dx			;dx = bit mask for first 16 letters
	pop	ax			;ax = bit mask for last 10 letters
	mov	bx,ax			;test mask
	or	bl,cl			;don't exit if we're within a range
					; (like A-Z), so we can terminate it
	or	bx,dx			;test high word of mask as well
	je	EndDefType		;brif mask is 0
	inc	si			;letterCur = letterCur + 1
	shl	ax,1			;shift mask left 1 bit
	rcl	dx,1
	push	ax			;save mask on stack
	push	dx			; (gets popped by DefTypeLoop)
	push	cx			;save cLetters, fNotFirst
	jnc	NotThisLetter		;brif this letter is not set
	or	cl,cl
	jne	BumpCLetters		;brif we're already in a range
					; (ie we're at B in an A-Z range)
	or	ch,ch
	je	Not1stLetter		;brif this is the 1st letter output
	call	PushRootCommaSpc	;list ", "
Not1stLetter:
	mov	ax,si			;al = letterCur
	call	PushRootChar		;list letterCur
BumpCLetters:
	pop	cx			;restore cLetters, fNotFirst
	inc	cx			;cLetters++ (inc cl is bigger opcode)
	mov	ch,1			;fNotFirst = FALSE
	jmp	SHORT DefTypeLoop

NotThisLetter:
	or	cl,cl
	je	NotWithinRange		;brif cLetters = 0
	dec	cl
	je	NotWithinRange		;brif cLetters was 1
	mov	al,'-'
	call	PushRootChar		;list "-"
	mov	ax,si			;al = letterCur
	dec	al			;al = letterCur - 1
	call	PushRootChar
NotWithinRange:
	pop	cx
	sub	cl,cl			;cLetters = 0
	jmp	SHORT DefTypeLoop	;set fNotFirst = TRUE

EndDefType:
	pop	si			;restore si=text pointer
	jmp	Stg1Loop		;return to outer loop

subttl	Procedure related opcodes

;------------------------------------------------------------------
;		Procedure related opcodes
;------------------------------------------------------------------

tcEt LABEL BYTE
	.erre	ET_I2 EQ 1		
	DB	'%'			;ET_I2
	.erre	ET_I4 EQ 2		
	DB	'&'			;ET_I4
	.erre	ET_R4 EQ 3		
	DB	'!'			;ET_R4
	DB	'#'			;ET_R8
	db	'$'			;ET_SD

;***************************************************************************
; ListProc
; Purpose:
;	List a [DECLARE] SUB/FUNCTION/DEF [QB4] statement
; Entry:
;	ax = cnt operand
;	es:si points to oPrs operand
;	lsBosFlags2 & FBOS2_DECLARE is non-zero for DECLARE
;
;***************************************************************************
DbPub	ListProc
cProc	ListProc,<NEAR>
	localW	parmFlags
	localW	cbAlias
	localB	procType
	localW	procAtr				
	procAtr_LO EQU BYTE PTR (procAtr)
	procAtr_HI EQU BYTE PTR (procAtr+1)
cBegin
	add	ax,si			;ax -> beyond end of opcode's operands
	push	ax			;save till function exit
	lods	WORD PTR es:[si]	;ax = oPrs operand (oNam if opStDefFn
					; and we're in SS_RUDE scan state)

	;--------------------------------------------------------\
	;NOTE: Temp data is on stack until end of this block
	;      Don't branch into or out of this block
	push	es			;save es (restored after FieldsOfPrsFar)
	push	ax			;pass oPrs to FieldsOfPrsFar

	lods	WORD PTR es:[si]	;ax = procAtr operand
	mov	[procAtr],ax		;save procAtr
	.errnz	DCLA_procType - 0300h
	and	ah,3			;ah = procType
	mov	[procType],ah		;save for later
	xchg	dx,ax			;dh = procType

	mov	ax,ORW_SUB
	cmp	dh,PT_SUB
	je	LpGotOPrs		;brif we're in a SUB
	mov	ax,ORW_FUNCTION
	cmp	dh,PT_FUNCTION
	je	LpGotOPrs		;brif we're in a FUNCTION
	DbAssertRelB dh,e,PT_DEFFN,LIST,<LrStDeclare has invalid proc type>
	mov	ax,ORW_DEF
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jb	LpGotOPrs		;brif not in SS_RUDE
	;opStDefFn has oNam as operand, not oPrs in RUDE state
	call	PushRootRwSpc		;push DEF to root stack
	pop	ax			;ax = oNam
	jmp	SHORT LpDefFn

LpGotOPrs:
	call	PushRootRwSpc		;push SUB/FUNCTION/DEF to root stack

					;parm to FieldsOfPrsFar pushed shortly
					; after entry to ListProc
	call	FieldsOfPrsFar		;ax = oNam of prs
;ax = oNam for procedure
LpDefFn:
	pop	es			;restore es = seg adr of txt table
	;NOTE: Temp data is now off stack
	;--------------------------------------------------------/

	call	PushRootONam		;list sub/func/def's name
					;high byte contains proc type
	mov	al,[procAtr_LO]
	.errnz	DCLA_Explicit - 0080h
	or	al,al
	jns	ImplicitTyp
	and	al,DCLA_oTyp		;al = explicit type
	DbAssertRelB al,ne,0,LIST,<ListProc: invalid explicit oTyp1>
	DbAssertRelB al,be,ET_MAX,LIST,<ListProc: invalid explicit oTyp2>
	mov	bx,LISTOFFSET tcEt - 1	;bx points to tcEt mapping table
	xlat	cs:[bx]			;al = explicit type char (%,&,etc.)
	call	PushRootChar		;list it
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
ImplicitTyp:
	call	PushRootSpc
	test	[procAtr_HI],DCLA_cdecl / 100h
	.errnz	DCLA_cdecl - 8000h
	je	NotCDECL		;brif not declared as CDECL
	mov	ax,ORW_CDECL
	call	PushRootRwSpc		;list "CDECL "
NotCDECL:
	lods	WORD PTR es:[si]	;ax = parm cnt operand
	mov	[cLsArgs],al		;save parm count

	;List ALIAS "string" or LIB "string"
	mov	cl,[procAtr_HI]
	.errnz	DCLA_cbAlias - 7C00h
	and	cx,DCLA_cbAlias / 100h	;cx = cbAlias * 4
	shr	cl,1
	shr	cl,1			;cx = cbAlias
	jcxz	NoAliasOrLib		;brif alias clause not specified
	push	si			;save si points to 1st arg
	push	cx			;save byte count of ALIAS/LIB id

	; set si to point to ALIAS/LIB name
	mov	al,[cLsArgs]
	inc	al			;map 0 and UNDEFINED to 0
	je	NoParms			; brif cLsArgs was UNDEFINED
	dec	al			; restore dx = cLsArgs
NoParms:
	sub	ah,ah			;ax = cLsArgs
	mov	dx,ax			;dx = cLsArgs
	shl	ax,1			;ax = cLsArgs * 2
	add	ax,dx			;ax = cLsArgs * 3
	shl	ax,1			;ax = cLsArgs * 6
	add	si,ax			;si points to ALIAS or LIB name

	mov	ax,ORW_ALIAS
	call	PushRootRwSpc		;list ALIAS
	pop	ax			;restore ax = cbAlias
PushQStr:				
	call	PushRootQstr		
	call	PushRootSpc		;list " "
NoAlias:
	pop	si			;restore si points to 1st arg

NoAliasOrLib:
	cmp	[cLsArgs],0
	jg	GotProcParms		;brif cParms != UNDEFINED and != 0
					; (for DECLARE, UNDEFINED means 0
					;  parms, and no type checking - see
					;  pcode document)
	jl	NoTypeChk		;brif cParms == UNDEFINED
	test	[lsBosFlags2],FBOS2_DECLARE
	je	NoTypeChk		;brif not listing DECLARE
EnforceNoParms:
	mov	ax,')('
	call	PushRootChars		;list "() "
	call	PushRootSpc
NoTypeChk:
	jmp	NoProcParms

GotProcParms:
	call	PushRootLParen		;push '('
ProcParmLoop:
	cmp	si,[otxLsCursorTmp]
	jb	NotNdLsCursor		;brif not token of interest
	mov	[ndLsCursor],di
	mov	[otxLsCursorTmp],UNDEFINED ;make sure we don't set it again
NotNdLsCursor:
	test	[lsBosFlags2],FBOS2_DECLARE
	je	NotDeclParm		;brif not listing DECLARE
	lods	WORD PTR es:[si]	;ax = parm's oNam
	call	NewONam			;ax = offset to oNam node
					;bx = oNam
	jmp	SHORT ChkPrmFlgs
NotDeclParm:
	call	NewId			;consume id's operand, ax = node
					;bx = oNam
ChkPrmFlgs:
	push	bx			;saveNam
	push	ax			;save id's node
	lods	WORD PTR es:[si]	;ax = flags operand (PATR_xxx)
	mov	[parmFlags],ax

	TestX	ax,PATR_SEG		;Is Seg attribute present?
	mov	ax,ORW_SEG		;Assume yes
	jne	@F			;Brif yes
	TestM	[parmFlags],PATR_BYVAL	;Is ByVal attribute present?
	jz	NotSegParm		;Brif not
	mov	ax,ORW_BYVAL
@@:
	call	PushRootRwSpc		;list ByVal or Seg
NotSegParm:
	pop	ax			;ax = offset to id node
	call	PushRoot		;list it
	pop	bx			;bx = parm's oNam
					;NOTE: we need to preserve this in
					; bx until OTypOfONamDefault is called
	lods	WORD PTR es:[si]	;ax = formal parm's oTyp operand
	test	[parmFlags],PATR_asClause
	jne	AsParm			;brif parm was AS <type>
	DbAssertRel ax,be,ET_MAX,LIST,<LrStDeclare has invalid oTyp>
	dec	ax			;map ET_I2 to 0
	test	[parmFlags],PATR_explicit
	jne	NotImpl			;brif explicit type char (%&!#$)
	jmp	SHORT NoExpType

NotImpl:
	mov	bx,LISTOFFSET tcEt	;map (0,1,2,...) to (%,&,!,...)
	xlat	cs:[bx]			;al = explicit type char (%,&,etc.)
	call	PushRootChar		;list it
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	jmp	SHORT NoExpType

AsParm:
	test	[parmFlags],PATR_array
	je	NotAryParm
	push	ax			;save oTyp
	mov	ax,')('
	call	PushRootChars		;list "()"
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
	pop	ax			;restore ax=oTyp
;ax = oTyp for AS <type> clause
NotAryParm:
	cmp	ax,ET_MAX
	jbe	NotUserType
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	NotUserType		;brif ax=oNam of user type
	push	es			;preserve seg addr of text table
	cCall	ONamOTyp,<ax>		; ax = oNam for oTyp ax
	pop	es			;restore seg addr of text table
NotUserType:
	xchg	bx,ax			;bx = oNam
	sub	ax,ax
DoAsClause:
	call	PushTempAsClause	;Push [<type> AS] to temp stack
CallPushList:
	call	PushList		;Push AsClause to root as 1 node
	jmp	SHORT DecArgs

NoExpType:
	test	[parmFlags],PATR_array
	je	DecArgs
	mov	ax,')('
	call	PushRootChars		;list "()"
	call	CharToCharTok		;convert it to a LNT_CHARS_TOK node
DecArgs:
	dec	[cLsArgs]
	je	EndProcParms
	call	PushRootCommaSpc	;separate parms with ", "
	call	GrowBdNodes		;grow list buffer if necessary
	je	ListProcExit		;brif out-of-memory - We'll abort
					; ListLine next time through Stg1Loop
	jmp	ProcParmLoop

EndProcParms:
	call	PushRootRParen		;push ')'
	call	PushRootSpc		;list " "
NoProcParms:

NoAsClause:
	;list STATIC if not declare and prsCur.fStatic is TRUE
	test	[lsBosFlags2],FBOS2_DECLARE
	jne	ListProcExit		;brif listing DECLARE
	cmp	[procType],PT_DEFFN
	je	ListProcExit		;brif listing DEF FN
	test	[prsCur.PRS_flags],FP_STATIC
	je	ListProcExit		;brif not a STATIC proc
	mov	ax,ORW_STATIC
ListAuto:
	call	PushRootRw		
ListProcExit:
	pop	si			;si points beyond end of opcode
cEnd	;ListProc

; pcode = opStSub/opStFunction(cntEos, oPrs, cnt, cnt*(id,flags,oTyp))
;	[...] ==> [) id , id ... ( id SUB/FUNCTION]
;
ListRule LrStDefFn
	lods	WORD PTR es:[si]	;ax = cnt operand
	inc	si			;skip link field
	inc	si
	dec	ax			;don't include link field in count
	dec	ax
	jmp	SHORT DoListProc

ListRule LrStDeclare
	or	[lsBosFlags2],FBOS2_DECLARE
					;tell ListProc its doing a DECLARE
	jmp	SHORT ListDeclare

ListDeclare:
	mov	ax,ORW_DECLARE
	call	PushRootRwSpc		;push DECLARE to temp stack
ListRule LrStSub
ListRule LrStFunction
	lods	WORD PTR es:[si]	;ax = cnt operand
DoListProc:
	call	ListProc
	jmp	Stg1Loop		;return to outer loop

ListRule LrStCallLess
	or	[lsBosFlags],FBOS_CallLess
	jmp	SHORT CallId

ListRule LrStCallS
ListRule LrStCall
	call	PushTempOpRwSpc		;list "CALL[S] "
CallId:
	lods	WORD PTR es:[si]	;ax = count of args
	mov	[cLsArgs],al		;save count of args
	lods	WORD PTR es:[si]	;ax = oPrs to call
	push	es			;save es = seg adr of txt table
	push	ax			;pass oPrs
	call	FieldsOfPrsFar		;ax = proc's oNam
	pop	es			;restore es = seg adr of txt table
	call	PushTempONam		;list proc's name
	cmp	[cLsArgs],0
	je	NoCallArgs
ListArgsNoParen:
	mov	al,' '
	test	[lsBosFlags],FBOS_CallLess
	jne	CallLess1		;brif no CALL keyword
					;don't list ( for CallLess
ListArgsParen:
	mov	al,'('
CallLess1:
	call	PushTempChar		;push char al onto temp stack
	call	PushCommaArgs		;copy cLsArgs from root to temp
					; and separate them by commas
	test	[lsBosFlags],FBOS_CallLess
	jnz	CallLess2		;brif no CALL keyword
					;don't list ( for CallLess
					;don't list ) for CallLess
	call	PushTempRParen		;push ')' onto temp stack
CallLess2:
NoCallArgs:
	call	PushList		;push temp list to root as 1 node
	jmp	Stg1Loop		;return to outer loop


;	[exp defargs]  ==>  [exp = defargs]
;
ListRule LrEndSingleDef
	add	si,4			;skip filler field operand
					; and link field operand
	mov	ax,' ='			;list "= "
	call	PushTempChars
	call	PopRootPushTemp		;move exp from root to temp stack
	jmp	PushListStg1		;push temp list to root as 1 node
					; and return to outer loop

ListRule LrStExitProc
	inc	si			;consume opcode's operand
	inc	si
ListRule LrStEndProc
	call	PushRootOpRwSpc		;emit opcode's resword (EXIT/END)
	mov	ax,ORW_DEF

	cmp	grs.GRS_oPrsCur,UNDEFINED
	je	GotEndSub		;brif we're in a DEF FN
	mov	ax,ORW_SUB
	cmp	[prsCur.PRS_procType],PT_SUB
	je	GotEndSub		;brif we're in a SUB
	mov	ax,ORW_FUNCTION		;else it has to be a FUNCTION
GotEndSub:
	call	PushRootRw		;list SUB, FUNCTION or DEF
	jmp	Stg1Loop		;return to outer loop

ListRule LrStConst
	or	[lsBosFlags2],FBOS2_CONST	;so LrIdSt outputs commas
	jmp	LrRwSpc




sEnd	LIST

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsdebug.c ===
/*==========================================================================
*
*  Module:  prsdebug.c
*  Subsystem:  Parser
*  System:  Quick BASIC Interpreter
*
*=========================================================================*/
#include "version.h"

#if !PRSTAB_H
# include "prstab.h"
#endif

#if !QBIMSGS_H
# include "qbimsgs.h"
#endif

#if !PARSER_H
# include "parser.h"
#endif

#if !PSINT_H
# include "psint.h"
#endif

#if !OPCODES_H
# include "opcodes.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\nammgr.asm ===
TITLE	NamMgr.asm - Name Table manager
;****************************************************************************
;	Copyright <C> 1985, Microsoft Corporation
;Purpose:
;	This module contains the routines necessary to create and manage the
;	symbol name table.  These routines are:
;
;  CopyONamPb
;		  Copies the ASCII chars of a symbol from mrsCur.tNam.oNam.name
;		  to [pb].  The length of the string is returned.
;
;  CopyONamBd
;		  Allocates a heap entry for the uninitialized Bd and then
;		  does a CopyONamPb to Bd.pb.
;
;  GetVarNamChar
;		  Returns a first logical char of name and a flag which
;                 indicates whether the name starts with 'FN'.
;
;  FlagOfONam
;		  Returns the raw symbol mask of mrsCur.tNam.oNam.  This value
;		  can then be used to determine the various flag settings.
;
;  LnOfONam
;		  If oNam is a line number offset
;		    THEN AX=mrsCur.tNam.oNam.LnW
;		    ELSE AX=UNDEFINED
;
;  ONamOfPbCb
;		  Returns the offset of a symbol in mrsCur.tNam.  If the symbol
;		  doesn't exist, then it is added.  If a symbol match is found,
;		  but the case is different, then the new case is used to
;		  replace the old symbol.
;
;  ONamOfPsd
;		  Returns the offset of a symbol in mrsCur.tNam.  If the symbol
;		  doesn't exist, then it is added.  If a symbol match is found,
;		  but the case is different, then the new case is used to
;		  replace the old symbol.
;
;  ONamOfLn
;		  Returns the offset of a line number in mrsCur.tNam.  If the
;		  line number doesn't exist, then it is added.
;
;  ResetTNamMask
;		  Resets the all but the selected flag bits in all symbols of
;		  mrsCur.tNam (the symbol's flags are ANDed with the given
;		  byte mask).
;
;  ResetONamMask
;		  Resets the maskW selected flag bits of mrsCur.tNam.oNam
;		  (The symbol's flags are ANDed with the NOT of maskW).
;
;  SetONamMask
;		  Sets the maskW selected flag bits of mrsCur.tNam.oNam
;		  (The symbol's flags are ORed with maskW).
;
;  SetONamSpace
;                 Sets the 2 "name space" bits of the flags byte to some
;                 NMSP_ value. Returns 0 if no error, or ER_DD if either of
;		  those bits were already set.
;
;  CheckONamSpace
;		  Same error checking as SetONamSpace, but doesn't actually
;		  modify any namespace bits.
;                 
;  TNamInit
;		  Initializes the symbol table (mrsCur.tNam).
;
;  OgNamOfPsd
;                 Same as ONamOfPsd, but returns an ogNam.
;  OgNamOfPbCb
;                 Same as OgNamOfPbCb, but returns an ogNam.
;  CopyOgNamPb
;                 Same as CopyONamPb, but takes an ogNam instead of an oNam.
;  CopyOgNamPbNear
;                 Same as CopyOgNamPb, but near rather than far interface.
;  FpNamOfOgNam
;                 Given an ogNam, returns a far pointer to the name (in the
;                 actual table) and the length of the name.
;  OgNamOfONam
;                 Given an oNam for the current module, returns the ogNam
;                 for this name.
;  ONamOfOgNam
;                 Given an ogNam, returns the oNam for the current module
;                 for this name.
;  CharOfOgNam
;                 Given an ogNam, returns the first char in the name.
;  CbOfOgNam
;                 Given an ogNam, returns the length of the name.
;  BdAppendOgNam
;                 Given an ogNam and a pBd, appends the name to the end of
;                 of the bd.
;  CmpOgNamIns
;                 Given two ogNam's, performs a case-insensitive comparison
;                 of the two names.
;  ogNamOfHst
;                 Same as OgNamOfPbCb, but accepts a hst as input instead of
;                 a pb and cb.
;  hstNamOfOgNam
;                 Given an ogNam, returns a far pointer to a hst for the name.
;
;  IsOgNamOfPbCb
;		  Given an string, return OgNam of string if it exists, but
;		  don't add the string if not found in the name table.
;  IsONamOfPbCb
;		  Given an string, return ONam of string if it exists, but
;		  don't add the string if not found in the name table.
;
;    The symbol table is refered to as tNam.  It is a large far heap entry (and
;    therefore restricted to 64K).  The first part of tNam is a table of chain
;    pointers that are used to select the chain to be searched. This is actually
;    two such tables: the first (and larger one) is for all names except for
;    line numbers, while the second is just for line numbers. A hashing function
;    is applied to inputs to hash them into a given chain.  Unknown symbols are
;    added to the end of the appropriate chain.
;
;  tNam structure:
;
;	|-----------------------|
;	|  Chain Header Tables	|
;	|-----------------------|
;	|   Local variables	|
;	|-----------------------|
;	|     symbol chains	|
;	|-----------------------|
;	|	 unused 	|
;	|-----------------------|
;
;    Chain Header Tables: (pointers are NULL if no entries in chain)
;	pNameChain0 - first name chain
;	pNameChain1
;	pNameChain2
;	     .
;	     .
;	pNameChain31 - last name chain
;	pNameChain32 - first line number chain
;	     .
;	     .
;	pNameChain39 - last line number chain
;
;    Local Variables:
;	CurONamHdr - current tNam 1st char index - used by GetNextONam
;	cbUsed - # of bytes allocated to tables & entries
;
;    Each element of a symbol chain has the following format:
;
;	NextW - ptr to next symbol on chain (NULL if end of chain)
;	FlagsB - symbol flag byte
;	cbB    - # of bytes in the 'name' field
;	name   - ASCII chars of symbol name (or binary value for line numbers)
;
;	Each chain is terminated by a NULL Next.  New symbols are added to the
;	end of the appropriate chain.  A symbol can never be deleted or moved.
;	A symbol can't have more than CB_MAX_NAMENTRY chars.  Each char in the
;	name part of the symbol can be any valid ASCII (0-127) except the
;	following:
;	    <Control Char> < ' > < { > < | > < } > < ~ > <DEL>
;
;    Each module name table is limited to 32k. This limitation was imposed
;	based on the pcode generated for opAsTypeExp; as of June '87 that's
;	the only known reason for the limitation. In the (unlikely) event
;	that the 32k limit is ever a problem, this pcode restriction could
;	doubtless be removed.
;
;
;****************************************************************************

	.xlist


	NAMMGR_ASM = 1
	include 	version.inc
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	names
	includeOnce	qbimsgs
	includeOnce	ui
	includeOnce	util		
	.list

assumes DS,DATA
assumes SS,DATA
assumes ES,NOTHING

sBegin	DATA				
	globalW oRsNam,0		;[10] used to access appropriate tNam
sEnd	DATA				

sBegin	CP
assumes CS,CP

;***
;Use_GMrs
;Purpose:
;	Added as part of revision [10].
;
;	Set oRsNam to point to the global module so generic routines can be
;	used to support the global name table.
;
;	NOTE: Not all of the nammgr routines check for a non-zero offset in
;	NOTE: oRsNam - - - only those that are currently used in conjunction
;	NOTE: with a call to this routine. If you want to use this indirection
;	NOTE: mechanism for some nammgr support routine, ensure that it will
;	NOTE: access the name table via oRsNam.
;Entry:
;	None.
;Exit:
;	static oRsNam is an offset to the global name table in the Rs table.
;Preserves:
;	AX, BX, DX
;Exceptions:
;	none
;***************************************************************************
cProc	Use_GMrs,<NEAR,NODATA>
cBegin	Use_GMrs
	DbAssertRel  grs.GRS_oMrsCur,nz,OMRS_GLOBAL,CP,<Use_GMrs: global mrs is active>
	sub	cx,cx			; assume global mrs is active
	cmp	[grs.GRS_oMrsCur],OMRS_GLOBAL ;[23] is global mrs active?
	jz	Activate_Exit		;  brif so

	mov	cx,MRS_bdlNam + OMRS_GLOBAL ;[23] offset in the global mrs
					    ;[23] to the name table.
Activate_Exit:
	mov	[oRsNam],cx
cEnd	Use_GMrs

;***
;FetchPNam
;	Fetch a pointer to desired name table.
;	If the static oRsNam is non-zero, it is assumed to contain an
;	offset in the Rs table to the desired name table; otherwise, the
;	desired name table is assumed to reside in mrsCur.
;
;	Added as part of revision [10] to share/consolidate code, and
;	to limit access to the mrs to a specific point.
;Purpose:
;Entry:
;	none
;Exit:
;	es:bx is a pointer to the appropriate bdlNam
;Uses:
;	none
;***************************************************************************
cProc	FetchPNam,<NEAR,NODATA>
cBegin
	GETRS_SEG es,bx,<SIZE,LOAD>	;[25] NOTE: can trash bx?
	mov	bx,[oRsNam]
	or	bx,bx			
	jz	Get_PMrs		

	RS_BASE add,bx			
	jmp	short Got_PMrs		
Get_PMrs:				
	SETSEG_EQ_SS es 		
	mov	bx,dataOFFSET mrsCur.MRS_bdlNam 
Got_PMrs:
cEnd

;***
;LnOfONam		LnW = LnOfONam
;Purpose:
;		  If given oNam is a line number offset
;		    THEN return AX=mrsCur.tNam.oNam.LnW
;		    ELSE return AX=UNDEFINED
;Register conventions:
;	DS - Line# segment
;	ES - tNam segment
;Entry:
;     oNam on stack
;     The following globals are referenced:
;	mrsCur.bdlNam => current module's name table
;
;Exit:
;	if oNam represents a binary line number,
;	   AX = line number
;	else (oNam represents an alpha name)
;	   AX = UNDEFINED, DL = 1st letter of name
;	
;Uses:
;	none
;***************************************************************************
cProc	LnOfONam,<PUBLIC,FAR,NODATA>
	parmW	oNam			
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	DbChk	oNam,oNam		; sanity check on input oNam
	GETSEG	ES,[mrsCur.MRS_bdlNam_seg],,<LOAD,SIZE> ;[25]
	mov	bx,[oNam]		
	mov	ax,ES:NM_NAME[bx]	;return the 16 bit line number
	mov	dx,ax			;dl = 1st letter of alpha name
	test	ES:NM_FLAGS[bx],byte ptr NM_fLineNum ;is it a line #
	jne	LnExit			;brif a line# - AX=line number
	mov	ax,UNDEFINED		;return UNDEFINED for alpha name
LnExit:
cEnd

;***
;ONamOfLn		oNamW = ONamOfLn
;Purpose:
;	To return the Name Table offset of a line number.  If the line number
;	isn't already in the Name Table, then it is added.  Line numbers are
;	kept in their own seperate chains in tNam.  A '0' is returned in AX to
;	indicate an error condition (out of memory, etc).
;
;	NOTE: Shares a common exit with ONamOfPbCb, so these must have identical
;		entries.
;Entry:
;       AX = 16 bit line number
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;
;Exit:
;	AX - Name table offset of LnW
;	     0 is returned for error conditions (out of memory)
;	DL = tNam.oNam.flags if AX != 0
;	PSW flags set via an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ONamOfLn,<PUBLIC,NEAR,NODATA>,<DI>
	LocalW	pbName			; These locals match those in
	LocalW	cbName			;	ONamOfPbCb because we share a
	LocalW	pNamCur 		;	common exit
	LocalB	fGrowTNam		
	LocalB	fDontReplaceNam 	
	LocalW	lineNum 		
	LocalV	bdlTmp,<SIZE BDL>	
cBegin	
	mov	[lineNum],ax
	lea	ax,[lineNum]		;parm to ONamOfPbCb (ptr to 'name')
	mov	cx,2			;parm to ONamOfPbCb (size of 'name')
	mov	di,LineNumHdr1st	;ptr to first line number hash chain
	mov	dl,7			;only 8 chains for line numbers
	mov	bx,0FFFFH		;ensure we match only the correct number
	jmp	short ONamOf_Common
cEnd	<nogen>

;***
;ONamOfPsd		oNamW = ONamOfPsd(psdW)
;Purpose:
;	To return the Name Table offset of a symbol.  If the symbol isn't
;	already in the Name Table, then it is added.  The symbol's case is
;	preserved in tNam , but it is ignored while searching for a match
;	(FoO is the same as fOo). If the cases don't match exactly, then the
;	new symbol will replace the old one in tNam.  A 0 is returned in AX
;	to indicate an error condition (out of memory, etc).
;
;	NOTE: shares code with and exits via ONamOfPbCb.
;Assumptions:
;	)symbols can never be removed from tNam
;	)Each char in the name part of the symbol can be any valid
;	 ASCII (0-127) except the following:
;	 <Control Char>  < ' >  < { >  < | >  < } >  < ~ >  <DEL>
;	)0 < cb < CB_MAX_NAMENTRY
;Entry:
;     The stack contains the following parameters (PLM calling convention)
;	ParmW - ptr to a string descriptor
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;
;Exit:
;	AX - Name table offset of name in psd
;	     0 is returned for error conditions (out of memory)
;	DL = tNam.oNam.flags if AX != 0
;	PSW flags set via an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ONamOfPsd,<PUBLIC,NEAR,NODATA>
cBegin	<nogen>
	pop	dx			;return address to caller
	pop	bx			;psd parm passed by caller
	mov	ax,[bx.BD_pb]		;ptr to string contents
	mov	cx,[bx.BD_cbLogical]	;byte count
	DbAssertRel  cx,be,CB_MAX_NAMENTRY,CP,<ONamOfPsd: psd.cb too large>
	push	dx			;put retval back on stack
cEnd	<nogen>				;fall into ONamOfPbCb

;***
;ONamOfPbCb		oNamW = ONamOfPbCb
;Purpose:
;	To return the Name Table offset of a symbol.  If the symbol isn't
;	already in the Name Table, then it is added.  The symbol's case is
;	preserved in tNam , but it is ignored while searching for a match
;	(FoO is the same as fOo). If the cases don't match exactly, then the
;	new symbol will replace the old one in tNam by default; this replacement
;	is suppressed if the Cb input word has it's high bit set. A 0 is 
;	returned in AX to indicate an error condition (out of memory, etc).
;Assumptions:
;	)symbols can never be removed from tNam
;	)Each char in the name part of the symbol can be any valid
;	 ASCII (0-127) except the following:
;	 <Control Char>  < ' >  < { >  < | >  < } >  < ~ >  <DEL>
;	)0 < cb < CB_MAX_NAMENTRY
;Register conventions:
;	DS - pbName segment
;	ES - tNam segment
;	SI - pbName pointer
;	DI - tNam pointer
;Entry:
;	AX = ptr to ASCII string
;	CX = length of ASCII string
;		If the high bit is set and the name is found, the existing
;		name is NOT to be replaced in the table.
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;
;Exit:
;	AX - Name table offset of PbCb input string
;	     0 is returned for error conditions (out of memory).
;	     Special: when fDontCreateName != 0, ax = 0 indicates that the
;	     name wasn't found (and was NOT added to the table).
;	DL = tNam.oNam.flags if AX != 0
;	PSW flags set via an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ONamOfPbCb,<PUBLIC,NEAR,NODATA>,<DI> ;NOTE: matches entry to ONamOfLn
	LocalW	pbName			;ptr to string containing symbol
	LocalW	cbName			;# of bytes in *pbName
	LocalW	pNamCur
	LocalB	fGrowTNam		;set if tNam needs to be grown
					;before exiting
	LocalB	fDontReplaceNam		;FALSE if we should replace name in tbl
	LocalW	lineNum			;line number here, if entry via ONamOfLn
	LocalV	bdlTmp,<SIZE BDL>	
cBegin
	mov	di,tNam 		; not using line # hash table
	mov	bx,0DFDFH-1		;upper case mask for NextChar loop
	mov	dl,31d			;32 hash chains for names (not line #'s)
ONamOf_Common:				;entry from ONamOfLn
	DbChk	tNam
	push	si
	xor	dh,dh
	mov	[fGrowTNam],dh		;assume that tNam doesn't need to grow
	or	ch,ch
	jns	SetReplaceNam		;brif assumption correct

	and	ch,07FH			;reset high bit
	inc	dh			;Don't replace the name in the name
					;  table if entry found, i.e., leave
					;  case of existing name as-is.
SetReplaceNam:
	mov	[fDontReplaceNam],dh
	DbChk	ConStatStructs
	mov	[pbName],ax		;save input
	mov	[cbName],cx		;save input
	xchg	ax,si			;ptr to Name string in SI
	push	bx			; preserve mask
	call	FetchPNam		; bx points to desired mrs
	GETSEG	ES,PTRRS[bx.BDL_seg],,<SIZE,LOAD> ;[10][6][25]
	pop	bx			; restore mask

	DbAssertRel  cx,be,CB_MAX_NAMENTRY,CP,<ONamOfPbCb: cbName too large>
	DbAssertRel  cx,nz,0,CP,<ONamOfPbCb: cbName is 0>
	lodsb				;al = 1st byte of symbol to search for
	dec	cx
	jcxz	Mask_Hash

	dec	cx
	jcxz	Grab_Last		;brif just 2 chars
	
	xor	al,[si]			;hash in second char of name
Grab_Last:				;grab last char for use in hash
	add	si,cx			;point to last char in name
	xor	al,[si]			;use last char in name for hash too
Mask_Hash:
	inc	bx
	jnz	Mask_Hash2		;brif not a numeric - - (must not shift)
					;NOTE: as long as we just use the low
					;	5 bits of this for the hash
					;	index, we don't need to worry
					;	about upper vs. lower case
					;	letters.
	shr	al,1			;Line numbers tend to end in 0; don't
					;  use least significant bit to provide
					;  a more even hash distribution
	dec	bx			
Mask_Hash2:
	;at this point, BX = 0FFFF for Line Number, 0DFDF otherwise
	xor	dh,dh
	and	ax,dx	 		;get the 1st char hash value by doing
					;doing a MOD 32 (or MOD 8 for line #'s).
					;This value is the byte index into
					;tNam which is used to obtain the
					;ptr to the appropriate symbol chain
	shl	ax,1			;convert to word index
	add	di,ax			;DI = offset to 1st char chain ptr,
					;NOTE - this works because tNam
					;is a far heap ( ES:0 => tNam )
	mov	[pNamCur],di		;pass to AddName (if a null chain)
	mov	dx,ES:[di]		;offset of first symbol in chain
					;or 0 if no symbols on chain
NextName:
	mov	cx,[cbName]		;CX=# of bytes in pbName

NextNameCX:				;this label allows the above 'mov cx'
					;to be removed from the inner loop of
					;NextName
	mov	di,dx
	or	di,di			;test ptr to next symbol
	je	AddName 		;brif end of chain encountered

	mov	dx,ES:[di]		;dx=ptr to next symbol in the chain
	mov	[pNamCur],di		;pass to AddName or MapExit
	cmp	ES:NM_SIZE[di],cl	;are both strings the same size?
	jne	NextNameCX		;brif different sizes

	mov	si,[pbName]		;pb of callers name
	add	di,NM_NAME		;DI = ptr to 1st ASCII char of symbol
NextChar:
	lodsb				;AL=next char from pbName
	mov	ah,ES:[di]		;AH=next char from tNam
	inc	di			;bump tNam index
	and	ax,bx			;BX contains 0DFDFH, so this converts
					;AH & AL to upper case by resetting
					;their respective bit 5's. This
					;mapping works because there are
					;no control or special chars in the
					;symbol names.
	cmp	ah,al			;is pbName[SI]=tNam[DI]
	jne	NextName		;brif chars not the same
	loop	NextChar		;loop till mismatch or all chars tested
;
;We found a case insensitive match - if the names are exactly the same, then
;just quit (typical case?), otherwise, tell the UI that it needs to redraw
;the debug screen, and replace the name in the table

	cmp	[fDontReplaceNam],FALSE	;want to replace the name in the table?
	jz	DoReplaceName		;  brif so
MapExit1:				
	jmp	MapExit 		;  nope - just exit

DoReplaceName:
	mov	di,[pNamCur]		;addr of symbol record that matched
	mov	si,[pbName]		;pb of symbol to add
	mov	cx,[cbName]		;# of bytes in pbName
	add	di,NM_NAME		;offset to 1st byte of new entry name
	repz	cmpsb			;are names exactly the same?
	jz	MapExit1		;  brif so - exit

	push	es			;preserve across call
	call	DrawDebugScrFar		;inform UI
	pop	es
	mov	di,[pNamCur]		;addr of symbol record that matched
	jmp	short CopyString	;copy DS:[pbName] to ES:[DI+NM_NAME]
;
; Add pbName to the end of the current chain

AddName:
	xor	ax,ax			;0 for initializing new fields
	mov	[fGrowTNam],TRUE	;tNam needs to grow
;
; make the last entry point to the next empty symbol
;
	mov	di,ES:[cbUsed]		;# of allocated bytes in tNam
					;this is also the addr of the next
					;available byte since cbLogical is
					;greater than cbUsed
	mov	ES:NM_NEXT[di],ax	;NULL ptr for new record
	inc	bx			;is this name for a Line Number?
	jnz	Not_Ln			;  brif not

	mov	al,NM_fLineNum		;set flag to recall that this is a Line#
Not_Ln:
	mov	ES:[di+NM_FLAGS],al	;initialize flags to OFF state
;
; copy the pb string to [ES:DI.name]

CopyString:
	mov	si,[pbName]		;pb of symbol to add
	mov	cx,[cbName]		;# of bytes in pbName
	mov	ES:NM_SIZE[di],cl	;update length field of symbol
					;NOTE - this may be redundant
	add	di,NM_NAME		;offset to 1st byte of new entry name
	rep	movsb			;copy from DS:pbName[SI] to ES:tNam[DI]
	cmp	[fGrowTNam],FALSE	;do we need to grow tNam
	je	MapExit 		;brif symbol wasn't added - don't need
					;to grow tNam
;
; Make sure there will be enough room to add another symbol the next time thru.
; TNam can now be safely grown since the string has been copied and heap
; movement is no longer a problem.
;

	mov	cx,[oRsNam]		;[10]
	jcxz	MrsCur_Okay		; brif want to grow bdl in mrsCur

	; We want to grow the bdlNam for the global mrs, but it's not
	; active. It must be active because (1) cannot safely grow a bdl
	; when it's in a local heap table, and (2) we need to know where
	; the owner of the bdl is in case of heap movement, to refresh es.
	; Therefore, we active and then deactivate the global mrs.
	; NOTE: This assumes that the only reason pMrsNam is non-zero is
	; for global mrs support.
	; Note: we save both oPrsCur AND oMrsCur here instead of oRsCur
	;	    to protect against the special case where a declared/ref'd
	;	    but not defined prs is active here ... in this special case,
	;	    RsActivate of oRsCur would leave the global mrs active ...
	push	[grs.GRS_oPrsCur]	; save for later restore
	push	[grs.GRS_oMrsCur]	; save for later restore
	PUSHI	ax,OMRS_GLOBAL		;[23] oMrs of global mrs
	call	MrsActivateCP		; activate the global mrs

MrsCur_Okay:				
	mov	bx,dataOFFSET mrsCur.MRS_bdlNam	; pointer to tNam bdl
	mov	ax,CB_MAX_NAMENTRY+NM_NAME+NM_NAME 
					; max # of bytes needed to add
					;the next symbol plus the
				 	;overhead needed by the
					;current symbol.
	add	ax,[cbName]		;plus the _NAME field bytes used by
					;the current symbol
	mov	di,[pNamCur]		;addr of last searched name entry

	push	bx			; pass pbdlNam to BdlCheckFree
	push	ax			;pass byte count to BdlCheckFree
	call	BdlCheckFree		;make sure there is enough room in tNam
					;to add another symbol
	xchg	ax,si			; save return code across poss. call
	mov	cx,[oRsNam]		;[10]
	jcxz	MrsCur_Okay1		; brif mrsCur is to be left alone

	; The oRs of the context that was active on input is on the top
	; of the stack. Activate this again, and then refresh pMrsNam in
	; case the mrs table moved and pMrsNam will be used again.
	mov	[oRsNam],0		; reset so global mrs access in
					; MrsActivateCP will be correct
	call	MrsActivateCP		; reactivate input oMrsCur
	call	PrsActivateCP		; reactivate input oMrsCur
	call	Use_GMrs		

MrsCur_Okay1:				
	sub	ax,ax			; in case of error
	or	si,si			; BdlCheckFree return code
	je	ONamOfPbCb_Exit		;brif not enough memory - the current
					;name isn't added to tNam - even
					;though the _NAME field has been
					;updated.
	mov	si,[cbName]		;# of bytes in new symbol
	add	si,NM_NAME		;compensate for header bytes
					;SI = # of bytes in new entry
	call	FetchPNam		; bx points to desired mrs
	mov	dx,PTRRS[bx.BDL_cbLogical] ;[10] # of bytes in Name Table
	add	dx,si			   ; + padding for next symbol
	js	ONamOfPbCb_Exit		;brif table has grown > 32k
					;  see module header for reason(s) for
					;  this restriction
	mov	PTRRS[bx.BDL_cbLogical],dx  ;[10]
	
	GETSEG	ES,PTRRS[bx.BDL_seg],,<SIZE,LOAD> ;[14][10][6]
					 ;	  may have been changed by the
					 ;	  call to BdlCheckFree

					;make the last entry point to the 
					; next empty symbol
	mov	ax,ES:cbUsed		;# of tNam bytes already used
					;this is also the addr of the next
					;available byte since cbLogical is
					;greater than cbUsed
	mov	ES:[di],ax		;make the last entry point to new entry
	mov	di,ax			;return new oNam to caller
	add	ax,si			;cbUsed + size of new entry
	mov	ES:cbUsed,ax		;# of bytes used by the Name Table
	mov	[pNamCur],di		;return new oNam to caller
MapExit:
	mov	bx,[pNamCur]		;return name offset to caller in AX
	mov	dl,ES:NM_FLAGS[bx] 	;get the flag byte
	xchg	ax,bx
ONamOfPbCb_Exit:
	pop	si
	or	ax,ax			;set flags for callers
cEnd



;***
;TNamInit		TNamInit()
;Purpose:
;	To initialize the Name Table structure and any other data used by
;	the Name Table Manager.  A zero is returned in AX if there was not
;	enough memory.
;Entry:
;	sbToUse - 0 means use any sb for this table. If non-zero, then this
;			sb value is to be used.
;	mrsCur.bdlNam = current module's name table
;Exit:
;	AX = 0 if not enough memory was available
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	TNamInit,<PUBLIC,NEAR,NODATA>,<DI>
	parmW	sbToUse 		
cBegin
	mov	ax,dataOFFSET mrsCur.MRS_bdlNam  ; ptr to tNam bdl
	push	ax			; parm to BdlAlloc
	cCall	BdlFree,<ax>		; in case name table is an owner
	mov	ax,NM_INIT_TABLE_SZ	;# of bytes to allocate
	push	ax			;pass low word of cb to BdlAlloc
	PUSHBDL_TYPE  pgtypEBNameTable,ax ; pass sb type for EB version
	mov	cx,[sbToUse]		
	jcxz	Use_Any_Sb

	push	cx			
	call	BdlAllocSb		
	jmp	short TNamInit_Cont	
Use_Any_Sb:				
	call	BdlAlloc		;allocate a large far heap for NamTab
TNamInit_Cont:
	or	ax,ax			;check return code
	je	TNIExit 		;brif heap wasn't allocated
;
;we now own a far heap entry - initialize it
;
	GETSEG	ES,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]

	mov	cx,mrsCur.MRS_bdlNam_cPhysical ;# of paragraphs in Name Table
	shl	cx,1			;convert cPara to cBytes
	shl	cx,1			;  (under DOS 5 this already is cBytes)
	shl	cx,1
	shl	cx,1
	mov	di,tNam 		;di=base addr of tNam
					;NOTE - tNam is a far heap
	sub	cx,di			; zero-fill all but initial bytes
	sub	ax,ax			;AX=0
	REP	STOSB			;Initialize the Name table
	mov	ax,oNamFirst		;offset to 1st usable entry
	mov	ES:cbUsed,ax		;# of bytes currently being used
					;by tNam
	add	ax,NM_NAME+CB_MAX_NAMENTRY 
					; # of bytes currently being used
					;by tNam + enough padding to add
					;another symbol
	mov	mrsCur.MRS_bdlNam_cbLogical,ax ;total size of tNam
TNIExit:
cEnd

;***
;CopyONamPb		cbW = CopyONamPb
;Purpose:
;	To copy the ASCII chars in a name table entry to the callers buffer.
;	The # of ASCII characters copied is returned.
;Assumptions:
;	pbW contains room for at least CB_MAX_NAMENTRY chars
;Register conventions:
;	DS - tNam segment
;	ES - pb segment
;	SI - tNam pointer
;	DI - pb pointer
;Entry:
;	pbBuf - ptr to a buffer
;	oNam  - symbol's name table offset into mrsCur.tNam
;     The following data is referenced:
;	if oRsNam is <> 0, then we use that to fetch name table segment,
;	else mrsCur.bdlNam contains current module's name table segment.
;Exit:
;	AX - # of ASCII chars in mrsCur.tNam.oNam.name
;		These chars are copied into the given buffer.
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CopyONamPb,<PUBLIC,FAR,NODATA>,<SI,DI,DS>
	parmW	pbBuf			
	parmW	oNam			
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	DbChk	oNam,oNam		; sanity check on input oNam
	mov	si,[oNam] 		; SI = tNam.oNam
					;NOTE - this works because tNam
					;is a far heap ( ES:0 => tNam )
	call	FetchPNam		; bx points to desired mrs
	GETSEG	DS,PTRRS[bx.BDL_seg],,<SIZE,LOAD> ;[14][10][6]
	push	SS			;callers pb segment
	pop	ES			;ES = callers pb segment
	mov	di,[pbBuf]		
	sub	cx,cx			;CX=0
	mov	cl,NM_SIZE[si]		;# of ASCII bytes in oNam
	mov	ax,cx			;return cbW to caller
	add	si,NM_NAME		;SI = tNam.oNam.name
	rep	movsb			;copy tNam.oNam.nam to pb
cEnd

;***
;CopyONamBd		cbW = CopyONamBd(oNamW,pBdW)
;Purpose:
;	Use oNam to determine the symbol's size and then use that size to
;	allocate a heap entry for pBd.	The ASCII chars in the symbol name
;	are then copied to the heap entry.  pBd must point to an un-initialized
;	Bd (ie - Bd doesn't currently own a heap entry)!
;Entry:
;     The stack contains the following parameters (PLM calling convention)
;	ParmW - symbol's name table offset
;	ParmW - ptr to uninitialized Bd
;Exit:
;	AX =  0 if Bd allocation was unsucessful
;	   =  mrsCur.tNam.oNam.cb if Bd allocation was sucessful
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CopyONamBd,<PUBLIC,NEAR,NODATA>,<SI,DI>
	parmW	oNam		;symbol's offset into tNam
	parmW	pBd		;ptr to uninitialized Bd
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	DbChk	oNam,[oNam]		;sanity check on input oNam
	mov	si,[oNam] 		;SI = tNam.oNam
					;NOTE - this works because tNam
					;is a far heap ( ES:0 => tNam )
	sub	cx,cx			;CX=0
	GETSEG	ES,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	mov	cl,ES:NM_SIZE[si]	;# of ASCII bytes in oNam
	push	cx			;save & pass to BdAlloc

	mov	ax,IT_NO_OWNERS 	;pass bdType to BdAlloc
	cCall	BdAlloc,<pBd,cx,ax>	;allocate a Bd to copy oNam to
	pop	cx
	or	ax,ax			;was the allocation sucessful
	je	CopyONamBdExit		;brif unsucessful
	push	DS			;ES = DGROUP (for the 'rep movsb')
	pop	ES
	GETSEG	DS,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
					;refresh - BdAlloc could have moved it
assumes DS,NOTHING
	mov	ax,cx			;return mrsCur.tNam.oNam.cbW to caller
	add	si,NM_NAME		;SI = tNam.oNam.name (source ptr)
	mov	di,[pBd]		;ptr to Bd to copy to
	mov	di,ES:[di.BD_pb]	;ptr to buf to copy oNam to (dest ptr)
	rep	movsb			;copy tNam.oNam.nam to pb
	push	ES			;DS = DGROUP (for the 'rep movsb')
	pop	DS
assumes DS,DATA
CopyONamBdExit:
cEnd

;***
;GetVarNamChar		ushort = GetVarNamChar(oNamW)
;Purpose:
;	Given an oNam, the logical first char of the name for use in 
;	determining the default type of a variable by that name (i.e.,
;	bypass a leading 'FN' in the name).
;	For versions supporting DEF FN's, also return a flag indicating 
;	whether the name starts with 'FN' or not.
;Entry:
;	oNamW - symbol's name table offset into mrsCur.tNam
;Exit:
;	AL - logical first char of variable name, forced to upper case
;	ife FV_QB4LANG
;		AH - 0 if name doesn't start with 'FN', non-zero if it does
;	endif
;Uses:
;	none.
;Preserves:
;	DX, ES
;Exceptions:
;	none.
;****************************************************************************
cProc	GetVarNamChar,<PUBLIC,NEAR,NODATA>,<ES>
	parmW	oNam
cBegin
	DbChk	oNam,[oNam]		;sanity check on input oNam
	DbChk	tNam
	DbChk	ConStatStructs
	GETSEG	es,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	mov	bx,[oNam]
	add	bx,NM_NAME		;add table start ptr to offset
	mov	al,es:[bx]		;fetch first char of name
	and	al,0DFh			;force to upper case
	xor	ah,ah
	cmp	al,'F'
	jnz	GetVarChar_Exit		;brif doesn't start with 'FN'

	mov	cl,es:[bx-(NM_NAME - NM_SIZE)] ; fetch length of name
	cmp	cl,2			; long enough to be a DEF FN name?
	jbe	GetVarChar_Exit 	; brif not

	mov	cl,es:[bx+1]		;fetch second char of name
	and	cl,0DFh			;force to upper case
	cmp	cl,'N'
	jnz	GetVarChar_Exit		;brif doesn't start with 'FN'

	mov	al,es:[bx+2]		;fetch third char of name
	and	al,0DFh			;force to upper case
	inc	ah			;set "found 'FN'" flag
GetVarChar_Exit:
cEnd


;***
;FlagOfONam		FlagW = FlagOfONam(oNamW)
;Purpose:
;	To get a symbols flag byte from the symbol table.
;Entry:
;     The stack contains the following parameters (PLM calling convention)
;	ParmW - symbol's name table offset
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;Exit:
;	AX = tNam.oNam.flags
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	FlagOfONam,<PUBLIC,NEAR,NODATA>,<DS>
	parmW	oNam		;symbol's offset into tNam
cBegin
	DbChk	oNam,[oNam]		;sanity check on input oNam
	DbChk	tNam
	DbChk	ConStatStructs
	GETSEG	ds,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	mov	bx,oNam 		;bx = tNam.oNam
					;NOTE - this works because tNam
					;is a far heap ( DS:0 => tNam )
	sub	ax,ax			;AH=0 - for returning a ushort
	mov	al,NM_FLAGS[bx] 	;get the flag byte
cEnd

;***
;SetONamMask, SetONamSpace, CheckONamSpace
;Purpose:
;	To selectively set individual bits in a symbols FLAG byte.
;	For SetONamSpace, 
;		sets the 2 "name space" bits of the flags byte to some
;      		NMSP_ value. Returns 0 if no error, or ER_DD if either of
;		those bits were already set.
;	For CheckONamSpace,
;		catches the error where a given bit is already set, but
;		doesn't actually set the namespace.
;Entry:
;     The stack contains the following parameters (PLM calling convention)
;	ParmW - symbol's name table offset
;	ParmB - mask to be ORed with symbols FLAG byte
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;Exit:
;	tNam.oNam.flags = tNam.oNam.flags OR maskW
;	For SetONamSpace, AX = 0 if no error, else AX = ER_DD.
;			  PSW.Z set if no error 
;	dl = old value of oNams flags before the new bit was set.
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
PUBLIC	CheckONamSpace		
CheckONamSpace: 		
	mov	ch,0FFH 	; don't set namespace bits
	SKIP2_PSW		
PUBLIC	SetONamSpace
SetONamSpace:
	mov	ch,0		; do set namespace bits
	mov	cl,0FFH 	; do check for errors
	SKIP2_PSW
PUBLIC	SetONamMask
SetONamMask:
	xor	cx,cx
cProc	SetONamMaskGen,<NEAR,NODATA>,<DS>
	parmW	oNam		;symbol's offset into tNam
	parmB	orMask		;bit mask - value to be ORed with NM_FLAGS
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	GETSEG	ds,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	mov	bx,[oNam] 		;bx = tNam.oNam
					;NOTE - this works because tNam
					;is a far heap ( ES:0 => tNam )
	DbChk	oNam,bx			;sanity check on input oNam
	mov	dh,[orMask]
	jcxz	NMSP_Okay

	xor	ax,ax			;assume no error for SetONamSpace retval
	mov	dl,NM_FLAGS[bx]		;fetch flags as they were on entry
	and	dl,NMSP_MASK		;had one of the NMSP_ bits been set?
	jz	NMSP_Okay		;  brif not

	cmp	dl,dh			;were those bits same as input?
	jz	NMSP_Okay		;  brif so

	mov	al,ER_DD
	xor	dh,dh			;don't alter table if error
NMSP_Okay:
	or	ch,ch			; want to actually modify flag bits?
	jnz	@F			; brif not - - - exit

	mov	dl,NM_FLAGS[bx] 	;return old value in dl
	or	NM_FLAGS[bx],dh 	;set all MASKed bits
@@:					
	or	ax,ax			;set PSW flags
cEnd

;***
;ResetONamMask		ResetONamMask
;Purpose:
;	To selectively reset individual bits in a symbols FLAG byte.
;Entry:
;	AL = mask to be NANDed with symbols FLAG byte
;	BX = symbol's name table offset
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;Exit:
;	tNam.oNam.flags = tNam.oNam.flags OR maskW
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ResetONamMask,<PUBLIC,NEAR,NODATA>,<DS>
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	DbChk	oNam,bx			;sanity check on input oNam
	GETSEG	ds,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	not	al			;invert the mask
	or	al,NM_fLineNum		;don't let anyone reset this flag
	and	NM_FLAGS[bx],al 	;reset all MASKed bits
cEnd

;***
;ResetONamMaskTmp
;Purpose:
;	C code access to ResetONamMask
;Entry:
;     The stack contains the following parameters (PLM calling convention)
;	mask to be NANDed with symbols FLAG byte
;	symbol's name table offset
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;Exit:
;	tNam.oNam.flags = tNam.oNam.flags OR maskW
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ResetONamMaskTmp,<PUBLIC,NEAR,NODATA>
	parmW	oNam
	parmB	nandMask
cBegin
	mov	al,[nandMask]
	mov	bx,[oNam]
	call	ResetONamMask
cEnd

;***
;ResetTNamMask		ResetTNamMask(maskW)
;Purpose:
;	Resets the all but the selected flag bits in all symbols of 
;	mrsCur.tNam (the symbol's flags are ANDed with the given byte mask).
;
;	Note that we handle the NMSP_ enumerated bits specially to ensure
;	that the NMSP_SUB constant is never changed.
;Entry:
;	AL - mask to be ANDed with all symbol FLAG bytes
;     The following globals are referenced
;	mrsCur.bdlNam => current module's name table
;Exit:
;	none.
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ResetTNamMask,<PUBLIC,NEAR,NODATA>,<SI,DS>
cBegin
	DbChk	ConStatStructs
	DbChk	tNam
	GETSEG	ds,[mrsCur.MRS_bdlNam_seg],,<SIZE,LOAD> ;[6]
	xor	si,si			;SI=0 - make GetNextONam return
					;	FirstONam
	or	al,NM_fLineNum+NM_fLineNumLabel ;don't let anyone reset these

	;if NMSP_SUB is set for a name, leave it alone, otherwise, allow
	;caller to reset either both NMSP_ bits or neither
	mov	ah,al
	mov	cl,NMSP_SUB
NextTNamMask:
	call	GetNextONam		;SI = pNextONam
	je	ResetTNamMaskExit	;brif no more oNams
	test	BYTE PTR NM_FLAGS[si],080H
	jnz	NextTNam_Cont		;brif NMSP_Variable or _Constant set
					;  (need this because NMSP_'s are
					;   enumerated - - see .errnz's above)
	or	al,cl			;don't mask off NMSP_SUB flag
NextTNam_Cont:
	and	NM_FLAGS[si],al 	;reset all MASKed bits
	mov	al,ah
	jmp	NextTNamMask		;loop till all oNam's visited
ResetTNamMaskExit:
cEnd

;***
;GetNextoNam
;Purpose:
;	To get the next oNam in tNam
;Entry:
;	DS - tNam segment
;	SI - current oNam - if 0 then return 1st oNam
;	DS:CurONamHdr - current tNam 1st char index
;
;Exit:
;	PSW - IF zero flag set then no more valid oNam's exist
;	SI - next oNam
;	NextONamHdr  - next tNam 1st char index
;Uses:
;	dx
;***************************************************************************
	PUBLIC	GetNextONam
GetNextONam:
	or	si,si			;should we initialize
	jne	NextoNam		;brif initialization not desired
	mov	word ptr DS:CurONamHdr,tNam - 2  
					;offset of 1st valid chain header-2
NextChain:
	mov	dx,DS:CurONamHdr	;offset of current tNam chain header
	inc	dx			;word ptr to next chain header
	inc	dx
	cmp	dx,LineNumHdrLast	;check for the end of tNam header tbl
	mov	DS:CurONamHdr,dx	;update
	ja	GotNextoNam		;brif all chain headers visited

	mov	si,dx			;start with 1st symbol in cur chain
NextoNam:
	mov	si,[si] 		;ptr to next symbol in cur hdr chain
	or	si,si			;test for end of cur chain
	je	NextChain		;brif no more symbols in cur hdr chain
GotNextoNam:
	or	si,si			;set cond codes for caller
	ret

;=============================================================================
;
;	   Global Name Table Support (ogNam support routines)
;
;=============================================================================

;***
;OgNamOfPsd
;Purpose:
;	Same as ONamOfPsd, but returns an ogNam, not an oNam
;
;	Added as part of revision [4]
;Entry:
;	a psd on the stack
;Exit:
;	ax = ogNam or 0
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	OgNamOfPsd,<PUBLIC,FAR,NODATA>
	parmW	psdName
cBegin
	call	Use_GMrs		; point oRsNam to global name table
	cCall	ONamOfPsd,<psdName>	;returns ax = ogNam or 0 for error
	mov	[oRsNam],0		;[10] reset pointer to default
cEnd

;***
;OgNamOfPbCb
;Purpose:
;	Same as ONamOfPbCb, but returns an ogNam, not an oNam
;
;	Added as part of revision [4]
;Entry:
;	pbName and cbName on stack
;Exit:
;	ax = ogNam or 0
;	PSW flags set based on an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	OgNamOfPbCb,<PUBLIC,NEAR,NODATA>
	parmW	pbName
	parmW	cbName
cBegin
	call	Use_GMrs		; point oRsNam to global name table
	mov	ax,[pbName]
	mov	cx,[cbName]
	cCall	ONamOfPbCb		;returns ax = ogNam or 0 for error
	mov	[oRsNam],0		;[10] reset pointer to default
cEnd

;***
;CopyOgNamPb, CopyOgNamPbNear
;Purpose:
;	Given an ogNam and a short pointer to a buffer, copy the name to the
;	buffer and return the length of the name
;
;	Added as part of revision [4]
;Entry:
;	CopyOgNamPbNear:
;		ax = pDest
;		bx = ogNam
;	CopyOgNamPb: parameters are on the stack
;		pDest
;		ogNam
;Exit:
;	ax - # of chars in the name, that were copied into the given buffer.
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CopyOgNamPbNear,<PUBLIC,NEAR,NODATA>
cBegin
	DbChk	ogNam,bx		
	call	Use_GMrs		; point oRsNam to global name table
	cCall	CopyONamPb,<ax,bx>	; perform copy, return ax = cbName
	mov	[oRsNam],0		;[10] reset pointer to default
cEnd

cProc	CopyOgNamPb,<PUBLIC,FAR,NODATA>
	parmW	pDest
	parmW	ogNam
cBegin
	mov	ax,[pDest]
	mov	bx,[ogNam]
	cCall	CopyOgNamPbNear		;perform copy, return ax = cbName
cEnd

;***
;FpNamOfOgNam
;Purpose:
;	Given an ogNam, return a far pointer to, and the length of, the name.
;
;	Added as part of revision [4]
;Entry:
;	ogNam on stack
;Exit:
;	es:bx points to name
;	es:dx also points to name (i.e., dx = bx)
;	cx = cbName
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	FpNamOfOgNam,<PUBLIC,NEAR,NODATA>
	parmW	ogNam
cBegin
	DbChk	ogNam,ogNam		
	lea	bx,[mrsCur.MRS_bdlNam]	 ; assume global mrs active
	cmp	[grs.GRS_oMrsCur],OMRS_GLOBAL ; is global mrs active?
	jz	@F			;  brif so

	GETRS_SEG es,bx,<SIZE,LOAD>	
	mov	bx,MRS_bdlNam_seg + OMRS_GLOBAL ; offset in the global mrs
					    ; to the name table.
	RS_BASE add,bx			
@@:					
	GETSEG es,PTRRS[bx],,<SIZE,LOAD>  
	mov	bx,[ogNam]
	sub	cx,cx
	mov	cl,es:[bx.NM_SIZE]
	add	bx,NM_NAME		;es:bx points to name
	mov	dx,bx			;es:dx also points to name
cEnd

;***
;OgNamOfONam
;Purpose:
;	Given an oNam, return the ogNam for this name. 
;
;	Added as part of revision [4]
;Entry:
;	an oNam for the current module on the stack
;Exit:
;	ax = ogNam or 0
;	PSW flags set based on an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	OgNamOfONam,<PUBLIC,NEAR,NODATA>
	parmW	oNam
	localV	namTmp,CB_MAX_NAMENTRY	; alloc space for max. name on stack
cBegin
	lea	ax,namTmp
	push	ax			;parm1 to OgNamOfPbCb
	push	ax			; parm1 to CopyONamPb
	push	[oNam]			; parm2 to CopyONamPb
	DbChk	oNam,oNam		;[11]
	call	CopyONamPb		;necessary, as OgNamOfPbCb expects
					;as DGROUP-relative pointer
	push	ax			;parm2 to OgNamOfPbCb
	call	OgNamOfPbCb
cEnd

;***
;ONamOfOgNam
;Purpose:
;	Given an ogNam, return the oNam for this name. 
;
;	Added as part of revision [4]
;Entry:
;	an ogNam
;Exit:
;	ax = ogNam or 0
;	PSW flags set based on an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	ONamOfOgNam,<PUBLIC,NEAR,NODATA>
	parmW	ogNam
	localV	namTmp,CB_MAX_NAMENTRY	; alloc space for max. name on stack
cBegin
	lea	ax,namTmp
	push	ax			;save across call
	mov	bx,[ogNam]
	DbChk	ogNam,bx		
	call	CopyOgNamPbNear		;necessary, as ONamOfPbCb expects
					;a DGROUP-relative pointer
	xchg	ax,cx			;cx = cbName
	pop	ax			;ax = pbName
	call	ONamOfPbCb
cEnd

cProc	ONamOfOgNamFar,<PUBLIC,FAR,NODATA>  
	parmW	ogNam			
cBegin					
	cCall	ONamOfOgNam,<ogNam>	
cEnd					

;***
;CharOfOgNam
;Purpose:
;	Given an ogNam, return the first char in the name in al
;
;	Added as part of revision [4]
;Entry:
;	an ogNam
;	It is assumed that the global mrs is NOT active on entry
;Exit:
;	ax = first char in name
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CharOfOgNam,<PUBLIC,FAR,NODATA>
	parmW	ogNam
cBegin
	cCall	FpNamOfOgNam,<ogNam>		;returns es:dx pointing to name
						;  and cx = cbName
	mov	bx,dx
	mov	al,es:[bx]
cEnd

;***
;CbOfOgNam
;Purpose:
;	Given an ogNam, return the length of the name in ax
;
;	Added as part of revision [4]
;Entry:
;	an ogNam
;	It is assumed that the global mrs is NOT active on entry
;Exit:
;	ax = length of the name
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CbOfOgNam,<PUBLIC,FAR,NODATA>
	parmW	ogNam
cBegin
	cCall	FpNamOfOgNam,<ogNam>		;returns es:dx pointing to name
						;  and cx = cbName
	xchg	ax,cx
cEnd

;***
;BdAppendOgNam
;Purpose:
;	Given a pbd and an ogNam, allocate the bd if necessary, and append the 
;	name to the end of the bd.
;
;	Added as part of revision [4]
;Entry:
;	pBd
;	ogNam
;Exit:
;	If not enough memory can be obtained, AX = FALSE
;	else pbd->cbLogical is updated, AX = TRUE (non-zero)
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	BdAppendOgNam,<PUBLIC,FAR,NODATA>,<SI>
	parmW	pBd
	parmW	ogNam
cBegin
	cCall	CbOfOgNam,<ogNam>	;ax = cbName
	mov	si,[pBd]
	push	si			;parm1 to BdCheckFree
	push	ax			;parm2 to BdCheckFree
	cmp	[si.BD_pb],NULL		;is the bd currently an owner?
	jnz	GrowTheBd		; brif not - grow, don't allocate

	PUSHI	ax,IT_NO_OWNERS
	call	BdAlloc			;allocate buffer of sufficient size
	mov	[si.BD_cbLogical],0	;to match algorithm in shared code
	jmp	short BdCheck_OM
GrowTheBd:
	call	BdCheckFree
BdCheck_OM:
	or	ax,ax
	jz	BdAppendOgNam_Exit	;brif error exit

	mov	ax,[si.BD_pb]
	add	ax,[si.BD_cbLogical]	;pointer to where name is to be copied
	mov	bx,[ogNam]
	cCall	CopyOgNamPbNear		;returns ax = cbName
	add	[si.BD_cbLogical],ax	;update logical length of buffer
	;The below assertion is to ensure we return a non-zero result
	DbAssertRel  ax,ne,0,CP,<BdAppendOgNam: 0-length name appended?!>
BdAppendOgNam_Exit:
cEnd

;***
;CmpOgNamIns
;Purpose:
;	Given two ogNam's, perform a case-insensitive comparison on the names.
;	NOTE: This routine could easily be generalized to work with any oNam's.
;
;	Added as part of revision [4]
;Entry:
;	ogNam1
;	ogNam2
;	It is assumed that the global mrs is NOT the current mrs on entry
;Exit:
;	if the two ogNam's are the same then	ax = 0
;	else if name1 < name2 then 		ax = FFFF
;	else name1 > name2 and 			ax = 1
;
;	if name1 longer than name2 then		dx > 0
;	else if name1 shorter than name2 then	dx < 0
;	else name1 same length as name2 and	dx = 0
;
;	PSW set based on an OR AX,AX on exit
;Uses:
;	none
;Exceptions:
;	none
;***************************************************************************
cProc	CmpOgNamIns,<PUBLIC,NEAR,NODATA>
	parmW	ogNam1
	parmW	ogNam2
cBegin
	DbChk	ogNam,ogNam1		
	DbChk	ogNam,ogNam2		
	push	si
	lea	bx,[mrsCur.MRS_bdlNam]	 ; assume global mrs active
	cmp	[grs.GRS_oMrsCur],OMRS_GLOBAL ; is global mrs active?
	jz	@F			;  brif so

	GETRS_SEG es,bx,<SIZE,LOAD>	
	mov	bx,MRS_bdlNam_seg + OMRS_GLOBAL ; offset in the global mrs
					    ; to the name table.
	RS_BASE add,bx			
@@:					
	GETSEG ds,PTRRS[bx],,<SIZE,LOAD>  
assumes DS,NOTHING
	mov	bx,[ogNam1]		;ds:bx = pNam1
	mov	si,[ogNam2]		;ds:si = pNam2

	sub	ax,ax
	mov	al,NM_SIZE[bx]		;ax = length of string1
	mov	cx,ax			; assume string1 is the shorter one
	sub	dx,dx
	mov	dl,NM_SIZE[si]		; dx = length of string2
	sub	ax,dx			;ax > 0 if string1 longer than string2
	jle	DoCmp			;brif string1 is not longer than string2
	mov	cx,dx			;cx = length of shorter string (string2)
DoCmp:
	add	bx,NM_NAME		;ds:bx points to 1st byte of string1
	add	si,NM_NAME		;ds:si points to 1st byte of string2
	push	ax			;preserve across call
	call	CmpStrIns		;call shared code to do the work
	pop	dx			;dx > 0 if string1 longer than string2
	pop	si
	push	ss			
	pop	ds
assumes DS,DATA
cEnd



sEnd	CP

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsctl.asm ===
TITLE	prsctl.asm - Parser Control-Flow NonTerminal Functions

;==========================================================================
;
;  Module:  prsctl.asm - Parser Control-Flow NonTerminal Functions
;  Subsystem:  Parser
;  System:  Quick BASIC Interpreter
;  Copyright <C> 1985, Microsoft Corporation
;
;  NOTE:
;	See prsnt.asm for general comments
;
;=========================================================================

	include version.inc
	PRSCTL_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce names
	includeOnce opcontrl
	includeOnce parser
	includeOnce prsirw
	includeOnce prstab
	includeOnce psint
	includeOnce qbimsgs

	assumes	DS,DGROUP
	assumes	ES,DGROUP
	assumes	SS,DGROUP

sBegin	DATA

fLastWasLabel DB 0	;flag which gets set by IfClause 
			;non-zero if last call emitted a label,
			;zero if last call emitted a statement list
sEnd	DATA

sBegin	CP
assumes	CS,CP

;===========================================================================
;                  C O N T R O L    F L O W
;    P A R S E R    R E C O G N I Z I N G    F U N C T I O N S
;
;=======================================================================

;**********************************************************************
; ushort NEAR TestLn()
;
; Purpose:
;	See if the current token could be considered a line number
;	or numeric label.  A line number is any integer from 0 to 65529.
;	A numeric label is any number other than an integer from 0 to 65529
;	that does not use E or D notation.
; Entry:
;	pTokScan points to current token
; Exit:
;	If an error (like OVERFLOW or Out-Of-Memory) occurs
;	   error is logged, al = PR_BadSyntax, carry is set
;	Else
;	   carry is clear
;	   if lineNumber was found (i.e. 0 to 65529)
;	      ax its oNam, cx=0
;	   else if numeric label was found (i.e. any num other than 0 to 65529)
;	      ax its oNam, cx=non-zero
;	   else, return 0 (with condition codes set).
;	The token is not consumed in any case.
;
;******************************************************************
cProc	TestLn <PUBLIC,NODATA,NEAR>
cBegin	TestLn
	mov	bx,[pTokScan]		;di points to current token
	cmp	[bx.TOK_class],CL_lit
	jne	NotLn			;branch if token is not a literal
	mov	ax,[bx.TOK_lit_value_I2];ax = potential line number
	mov	cl,[bx.TOK_lit_litType]	;cl = literal type
	cmp	cl,LIT_I2
	jne	NotI2			;branch if we got an integer
	or	ax,ax
	js	NotLn			;branch if literal was -1 .. -32768
;ax = integer line number (0..65529)
TlExit2:
	call	ONamOfLn		;ax = offset in name table for linenum
	je	TlOmErr			;brif out-of-memory
	sub	cx,cx			;return lineNumber indication
;ax = oNam for line number or numeric label
TlExit1:
	or	ax,ax			;set condition codes for caller
;ax = error code if carry set, oNam if carry clear
TlExit:
cEnd	TestLn

NotLn:
	sub	ax,ax
	jmp	SHORT TlExit1

;bx = pointer to token descriptor
;ax = integer constant value, cl = literal type
NotI2:
	cmp	cl,LIT_I4
	jne	NotI4			;branch if not a long integer
	cmp	[bx.TOK_lit_value_I2+2],0
	jnz	GotNum			;branch if high word was not 0
					; it is still a numeric label
	cmp	ax,MAX_LN
	jbe	TlExit2			;branch if 0..65529
	jmp	SHORT GotNum		;I4's are valid numeric labels

;bx = pointer to token descriptor
;cl = literal type.  See if its an R4 or R8 numeric label
NotI4:
	cmp	cl,LIT_R4
	je	GotNum
	cmp	cl,LIT_R8
	jne	NotLn			;brif it is not I2,I4,R4 or R8
;bx = pointer to token descriptor, scan numeric label
GotNum:
	sub	ax,ax
	or	al,[bx.TOK_lit_errCode]	;ax = lexical analyzer's error code
	jne	TlErr			;brif lexical analyzer found an error
					; in literal's format
	test	[bx.TOK_lit_flags],FLIT_exp
	jne	NotLn			;brif E+nnn or D+nnn exponent seen
	mov	ax,[ps.PS_bdpSrc.BDP_pb] ;ax points to start of parser buffer
	add	ax,[bx.TOK_oSrc]	;ax points to 1st byte of id
					;  (parm to ONamOfPbCb)
	mov	cx,[ps.PS_bdpSrc.BDP_pbCur] ;cx = pointer beyond end of number
	sub	cx,ax			;cx = byte count of number (parm)
	cmp	cx,CB_IDNAM_MAX		
	ja	NotLn			;brif more than 40 chars long
	call	ONamOfPbCb		;nammgr returns ax = oNam, dl = flags
	mov	cl,1
	jne	TlExit1			;brif not out-of-memory
TlOmErr:
	call	ParseErrOm		;Error "Out of memory"
	jmp	SHORT TlErr1
TlErr:
	call	PErrMsg_AX		; al = PR_BadSyntax
TlErr1:
	mov	al,PR_BadSyntax
	stc				;return error code
	jmp	SHORT TlExit

;**********************************************************************
; PARSE_RESULT NEAR NtLn()
;
; Purpose:
;	Parse a Line Number.
; Exit:
;	If line number is found,
;	   consume the token, emit the 16 bit name table offset
;	   for the label/line number, and return al=PR_GoodSyntax.
;	Otherwise,
;	   return al=PR_NotFound.
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtLn <PUBLIC,NODATA,NEAR>
cBegin	NtLn
	call	TestLn			;ax = value of pTokScan's line number
	jc	NtLnExit		;brif error (Overflow, out-of-memory)
	je	NoLineNum		;branch if token isn't a line number
	call	Emit16_AX		;emit oNam
	call	ScanTok			;consume the line number
	or	[ps.PS_flags],PSF_fRef+PSF_fLabelRef ;so text mgr knows
					; to scan program if in direct mode 
	mov	al,PR_GoodSyntax
	SKIP2_PSW
NoLineNum:
	sub	ax,ax			;return PR_NotFound
NtLnExit:
	or	al,al			;set condition codes for caller
cEnd	NtLn

;**********************************************************************
; PARSE_RESULT NEAR NtLabLn()
;
; Purpose:
;	Parse a Label or Line Number.
;
; Exit:
;	If it is found, consume the token, emit the 16 bit name table offset
;	   for the label/line number, and return PR_GoodSyntax.
;	Otherwise,
;	   return PR_NotFound.
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtLabLn <PUBLIC,NODATA,NEAR>
cBegin	NtLabLn
	call	NtLn			;see if current token is line num
	jne	GotLn			;branch if parsed a line number

	;we're not looking at a line number, maybe its a label 
	call	IdTokPeriodImp		;next token can have "." in it
					; but must have no explicit type char
	je	NtLabExit		;branch if PR_NotFound
	mov	ax,[bx.TOK_id_oNam]	;emit its oNam
	call	Emit16_AX
	call	ScanTok			;consume the label
	or	[ps.PS_flags],PSF_fRef+PSF_fLabelRef ;so text mgr knows
					; to scan program if in direct mode 
GotLn:
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
	SKIP2_PSW
NtLabExit:
	or	al,al			;set condition codes for caller
cEnd	NtLabLn

;**********************************************************************
; PARSE_RESULT NEAR NtIfStmt()
;
; Purpose:
;	Parse a block or single line IF statement
;
; Entry:
;	IF <exp> has just been parsed.
;	'pTokScan' points to the current token, which may be THEN/GOTO
;
; Exit:
;	If a Block THEN is recognized, the next token is scanned,
;	   and the return value is PR_GoodSyntax.
;	else
;	   the return value is PR_NotFound.
;
;   Runtime behavior of IF-THEN-ELSE opcodes:
;   ----------------------------------------
;      <exp> opStIf(oText) - branch to oText if exp is zero (false)
;      <exp> opStIfLab(label) - branch to label if exp is non-zero (true)
;      <exp> opStIfLabDirect(label) - branch to label if exp is non-zero (true)
;      opStElse(oText) - unconditionally branch to oText
;      opStElseLab(label) - unconditionally branch to label
;      opStElseLabDirect(label) - unconditionally branch to label
;      opStElseNop - nop
;      <exp> opStIfBlock(oText) - branch to oText if exp is zero (false)
;      <exp> opStElseIf(oText) - branch to oText if exp is zero (false)
;      opStEndIfBlock - nop
;
;   NOTE: When in direct mode, Parser emits opStIfLabDirect instead of
;         opStIfLab, and opStElseLabDirect instead of opStElseLab.
;
;   BASICA allows IF <exp> ,THEN ... ,ELSE ...
;   Since BASCOM does not allow the comma, neither does QBI
;   
;   Single line IF statement syntax to pcode mappings:
;   -------------------------------------------------
;
;      Syntax:  IF <exp> GOTO <label>
;   
;      Pcode:   <exp> opStIfLabDirect(label)  (if direct mode)
;               <exp> opStIfGotoLab(label)    (if not direct mode - for listing)
;
;      ============================================================
;      Syntax:  IF <exp> THEN <label>
;   
;      Pcode:   <exp> opStIfLab(label)
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list>
;   
;                            +--------------+
;      Pcode:   <exp> opStIf(|) <stmt list> |
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <label> ELSE <label>
;   
;      Pcode:   <exp> opStIfLab(label) opStElseNop opStElseLab(label)
;
;      NOTE:    Lister emits no 'ELSE' for opStElseLab, just the ASCII label
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <label> ELSE <stmt list>
;   
;      Pcode:   <exp> opStIfLab(label) opStElseNop <stmt list>
;
;      NOTE:    <stmt list> can contain more single line IF stmts
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list> ELSE <label>
;   
;                            +--------------------------+
;      Pcode:   <exp> opStIf(|) <stmt list> opStElse(|) | opStElseLab(label) |
;                                                    +-----------------------+
;
;      NOTE:    Lister emits no 'ELSE' for opStElseLab, just the ASCII label
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list> ELSE <stmt list>
;   
;                            +--------------------------+
;      Pcode:   <exp> opStIf(|) <stmt list> opStElse(|) | <stmt list> |
;                                                    +----------------+
;   
;   Block IF statement syntax to pcode mappings:
;   -------------------------------------------
;      Syntax:  IF <exp> THEN
;   
;      Pcode:   <exp> opStIfBlock(oText to beyond ELSEIF/ELSE/END IF opcode)
;   
;      ============================================================
;      Syntax:  ELSEIF <exp> THEN
;   
;      Pcode:   <exp> opStElseIf(oText to beyond next ELSEIF/ELSE/END IF opcode)
;
;      NOTE:    Scanner inserts exBranch(oText to beyond END IF opcode)
;               after the opBol and before <exp>, so code falling into the
;               ELSEIF will branch beyond END IF without evaluating <exp>.
;   
;      ============================================================
;      Syntax:  ELSE 
;   
;      Pcode:   opStElse(oText to beyond END IF opcode)
;   
;      ============================================================
;      Syntax:  END IF
;   
;      Pcode:   opStEndIfBlock
;   
; RESTRICTIONS:
;	Block IF must be 1st stmt on line
;	Block ELSEIF must be 1st stmt on line
;	Block ELSE must be 1st stmt on line
;	Block END IF must be 1st stmt on line
;	Block IF must be last stmt on line (or else its a single line IF)
;	Block ELSEIF need not be last stmt on line
;	Block ELSE need not be last stmt on line
;	Block END IF need not be last stmt on line
;
;******************************************************************
cProc	NtIfStmt <PUBLIC,NODATA,NEAR>,<si,di>
cBegin	NtIfStmt
	mov	ax,IRW_GOTO
	call	TestScan_AX
	jne	NotIfGoto1		;branch if current token is not 'GOTO'
	call	ScanTok			;consume 'GOTO' token 
	mov	ax,UNDEFINED		;parse label or stmtlist 
	call	IfClause		;parse label, generate code
	jg	TryElseClause		;branch if result == PR_GoodSyntax
					; IfClause never returns PR_NotFound
	jmp	SHORT NtIfExit		;return error result

NotIfGoto1:
	mov	ax,IRW_THEN		;Consume THEN
	call	ConsumeRw_AX
	jc	NtIfExit		;brif not THEN - return PR_BadSyntax
	call	NtEndLine
	je	TryThenClause		;brif something follows THEN

	;Got a BLOCK IF statement 
	call	NtErrIfNot1st
	jl	NtIfExit		;brif not 1st stmt on line
	mov	ax,opStIfBlock
	call	Emit16_AX
	call	Emit16_0		;leave room for the operand
NtIfGoodSyntax:
	mov	al,PR_GoodSyntax
	jmp	SHORT NtIfExit

;Consume the label/linenum/statement-list following the THEN token
TryThenClause:
	mov	ax,opStIf
	call	IfClause		;parse label or stmtlist 
	jle	NtIfExit		;branch if result = PR_BadSyntax
					; IfClause never returns PR_NotFound

;we've just parsed THEN clause of a single line if
; Check for an ELSE clause 
;
TryElseClause:
	mov	ax,IRW_Colon		;Allow stmts IF e THEN 10 : ELSE ...
	call	TestScan_AX		; since both BASICA and BASCOM do
	jne	NotColonElse		;branch if no ':'
	call	Peek1Tok		;peek (don't consume) token after ':'
	mov	ax,IRW_ELSE
	call	TestPeek_AX
	jne	NtIfGoodSyntax		;branch if not ': ELSE'
	call	ScanTok			;Skip colon
NotColonElse:
	mov	ax,IRW_ELSE
	call	TestScan_AX
	jne	NtIfGoodSyntax		;branch if current token isn't ELSE
	call	ScanTok			;consume 'ELSE' token
	mov	ax,opStElse
	call	IfClause		;parse label | stmtlist 
					;al = result
NtIfExit:
cEnd	NtIfStmt

;-----------------------------------------------------------------
; NOTE: IfClause() assumes the following contiguous relative order
;	of opcodes:
;	opStIf, opStIfLab, opStIfLabDirect
;	opStElse, opStElseLab, opStElseLabDirect
;
;-----------------------------------------------------------------
if opStIfLab - opStIf - 1
	Error: code assumes opStIfLab == opStIf+1
endif
if opStIfLabDirect - opStIfLab - 1
	Error: code assumes opStIfLabDirect == opStIfLab+1
endif
if opStElseLab - opStElse - 1
	Error: code assumes opStElseLab == opStElse+1
endif
if opStElseLabDirect - opStElseLab - 1
	Error: code assumes opStElseLabDirect == opStElseLab+1
endif

;**********************************************************************
; PARSE_RESULT NEAR IfClause(ax=opcode)
;
; Purpose:
;	Parse the clause [<label> | <line number> | <statementlist>]
;	which can follow THEN or ELSE in a single line IF statement.
;
; Entry:
;	ax = opStIf if we are parsing a THEN clause,
;            opStElse we are parsing an ELSE clause,
;	     UNDEFINED if we are parsing an IF <exp> GOTO clause.
;	fLastWasLabel is NonZero if the last time IfClause() was called,
;	it parsed a statement-list and not a label.  This is used
;	to decide what type of opcodes to generate for ELSE ...
;	<label> ELSE <label> ==> opStElseNop opStElseLab(<label>)
;	<label> ELSE <stmtlist> ==> opStElseNop <stmtlist> 
;	<stmtlist> ELSE <label> ==> opStElse(oText) opStElseLab(<label>)
;	<stmtlist> ELSE <stmtlist> ==> opStElse(oText) <stmtlist> 
;
; Exit:
;	Returns PR_GoodSyntax or PR_BadSyntax with condition codes
;	set accordingly (NEVER returns PR_NotFound)
;
;******************************************************************
IfClause PROC NEAR
	push	si
	push	di
	xchg	di,ax			;di isn't changed for rest of IfClause
					; it is the opcode to emit
	mov	si,dataOFFSET fLastWasLabel
					;si isn't changed for rest of IfClause
	call	TestLn			;see if pTokScan points to a line num
	jc	J1_IfClExit		;brif error (Overflow, out-of-memory)
	je	NotLabel1		;branch if it wasn't a line number
					; or a numeric label
	jcxz	GotLabel		;brif linenum, not numeric label
	mov	ax,MSG_ExpLn		;Error: expected line number
IfPErrMsg:				
	call	PErrExpMsg_AX		;al = PR_BadSyntax
	jmp	SHORT J1_IfClExit

NotLabel1:
	cmp	di,UNDEFINED		;test opcode for UNDEFINED
	je	TestForAlphaLab		;brif IF <exp> GOTO
	cmp	di,opStElse		;check 'opcode'
	jne	EmitTheOpcode
	cmp	BYTE PTR [si],0		;see if fLastWasLabel == FALSE
	je	EmitTheOpcode		;branch if last clause wasn't a label
	mov	ax,opStElseNop		;EmitOpcode(opStElseNop)
	jmp	SHORT DoEmit16

EmitTheOpcode:
	mov	ax,di			;ax = opStIf or opStElse
	call	Emit16_AX		;emit opStIf or opStElse 
	sub	ax,ax			;leave room for oText operand 
DoEmit16:
	call	Emit16_AX

	call	NtStatementList		;parse statement list, may recurse
					; back to this function 
	mov	BYTE PTR [si],0		;fLastWasLabel = FALSE
	jne	IfClExit		;return PR_GoodSyntax/PR_BadSyntax
	;optional stmt-list omitted. i.e. IF 1 THEN ELSE  is a valid stmt
IfClGood:
	mov	al,PR_GoodSyntax	;stmt list is optional
J1_IfClExit:
	jmp	SHORT IfClExit

TestForAlphaLab:			
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_ID	;test to see if it's an identifier
	je	GotLabel		;it's a valid label
	mov	ax,MSG_ExpLabLn		;ax = "Label or Line Number"
	jmp	SHORT IfPErrMsg		;generate "Expected ..." err msg

;At this point, we know we're looking at a label/linenum and not stmt list
;di = opcode to emit (or UNDEFINED if IF <exp> GOTO ...)
GotLabel:
	cmp	di,opStElse		;check 'opcode'
	jne	NotElse
	cmp	BYTE PTR [si],0		;see if fLastWasLabel == FALSE
	je	LastWasntLabel		;branch if last time we were called, we
					; emitted a statement list and not
					; a label, in which case, there is
					; no need to emit an opStElseNop
	mov	ax,opStElseNop
	jmp	SHORT EmitTheElse

LastWasntLabel:
	mov	ax,opStElse
	call	Emit16_AX
	sub	ax,ax			;leave room for oText operand 
EmitTheElse:
	call	Emit16_AX
NotElse:
	mov	BYTE PTR [si],1		;fLastWasLabel = NonZero (true)
	xchg	ax,di			;ax = the opcode
					;NOTE: di is no longer opcode
	inc	ax			;map opStIf to opStIfLab,
					;    opStElse to opStElseLab,
					;    UNDEFINED (goto) to 0
	jne	NotGotoLabel		;branch if not GOTO <label>
	mov	ax,opStIfGotoLab
	cmp	[grs.GRS_fDirect],FALSE
	je	NotGotoLabel

	;In direct mode, convert IF <exp> GOTO => IF <exp> THEN label,
	;so we don't need special opStIfGotoLabDirect opcode.  The
	;only reason we don't map opStIfGotoLab to opStIfLab is for listing
	
	mov	ax,opStIfLab
NotGotoLabel:
	call	Emit16_AX
	call	NtLabLn			;emit 16 bit oNam operand for label 
					;NtLabLn is guarenteed to return
					; PR_GoodSyntax since we've already
					; peeked at the following token
IfClExit:				;al = result
	pop	di
	pop	si
	or	al,al			;setup condition codes for caller
	ret
IfClause ENDP

;-----------------------------------------------------------------------
; NOTE: NtCaseRelation() assumes the following contiguous relative order
;	of opcodes:
;	  opStCaseEq,opStCaseLt,opStCaseGt,opStCaseLe,opStCaseGe,opStCaseNe
;
if opStCaseLt - opStCaseEq - 1
	Error: code assumes opStCaseLt == opStCaseEq+1
endif
if opStCaseGt - opStCaseLt - 1
	Error: code assumes opStCaseGt == opStCaseLt+1
endif
if opStCaseLe - opStCaseGt - 1
	Error: code assumes opStCaseLe == opStCaseGt+1
endif
if opStCaseGe - opStCaseLe - 1
	Error: code assumes opStCaseGe == opStCaseLe+1
endif
if opStCaseNe - opStCaseGe - 1
	Error: code assumes opStCaseNe == opStCaseGe+1
endif

;**********************************************************************
; PARSE_RESULT NEAR NtCaseRelation()
;
; Purpose:
;	Parse '<relational operator> <constant>'
;	and emit <constant> opStCaseXX(oTextT,oTextF)
;	where XX = {Lt,Le,Eq,Ne,Ge,Gt}
;
; Entry:
;	CASE IS has just been parsed.
;	'pTokScan' points to the current token (relational operator)
;
; Exit:
;	Returns either PR_GoodSyntax, PR_NotFound or PR_BadSyntax
;
;******************************************************************
cProc	NtCaseRelation <PUBLIC,NODATA,NEAR>
cBegin	NtCaseRelation
	;First, map {=, <, >, <=, >=, <>} to {1..6}  
	call	RelOp			;parse relational operator, ax = result
	or	ax,ax
	je	NtCaseExit		;branch if we didn't get one, with ax=0
					; (PR_NotFound)
	push	ax			;save relop
	call	ScanTok			;skip relational operator
	call	NtConsumeExp		;parse an expression
	pop	dx			;restore relop
	jle	NtCaseExit		;branch if no or bad expression
					; al = PR_BadSyntax
	xchg	ax,dx			;ax = relop
	add	ax,opStCaseEq - 1	;EmitOpcode(opStCaseEq - 1 + relop)
	call	Emit16_AX
	mov	al,PR_GoodSyntax
NtCaseExit:
cEnd	NtCaseRelation

;**********************************************************************
; PARSE_RESULT NEAR NtErrIfNot1st()
; Purpose:
;	Checks to see if current statement is 1st stmt on line.
; Entry:
;	PSIF_fNot1stStmt is set in psFlags if no statements have been
;	completed yet
; Exit:
;	if this is the 1st stmt on this line
;	   returns al=PR_GoodSyntax
;	else
;	   generates error (Must be 1st stmt on line)
;	   returns al=PR_BadSyntax
;	Condition codes set based on value in al
;
;**********************************************************************
PUBLIC	NtErrIfNot1st
NtErrIfNot1st PROC NEAR
	test	[psFlags],PSIF_fNot1stStmt
	mov	al,PR_GoodSyntax
	je	NtErrExit		;brif we're in 1st stmt on line
	mov	ax,MSG_1stStmt		;Error: "Must be 1st statement on line"
	call	PErrMsg_AX		; al = PR_BadSyntax
NtErrExit:
	or	al,al			;set condition codes for caller
	ret
NtErrIfNot1st ENDP


sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prscg.asm ===
TITLE	prscg.asm - Parser Code Generation Functions

;==========================================================================
;
;  Module:  prscg.asm - Parser Code Generation Functions
;  Subsystem:  Parser
;  System:  Quick BASIC Interpreter
;
;==========================================================================

	include		version.inc
	PRSCG_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	opmin
	includeOnce	opcontrl
	includeOnce	opstmt
	includeOnce	opintrsc
	includeOnce	parser
	includeOnce	pcode
	includeOnce	prstab
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	rtps
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	util
	includeOnce	variable


;--------------------------------------------------------------------------
;			Code Generation Overview
;
; During the course of interpreting the parse state tables, NtParse()
; encounters MARK(nnn) directives.  These cause NtParse to push
; the current pcode offset and the constant nnn onto a stack as follows:
;
; Given BNF of
;     exp MARK(1) exp MARK(2) exp
;
; Before parsing the statement, the marker stack looks like:
;    high memory:
;	maxStkMark-->        <--pCurStkMark
;           :
;	minStkMark-->
;    low memory:
;
; After parsing the statement, but before calling the code generation
; function for the statement, the marker stack looks like:
;    high memory:
;	maxStkMark-->[oDstPcode]
;
;                    [oDstPcode]
; <--pCurStkMark
;           :
;	minStkMark-->
;    low memory:
;
; Code generation functions use the information on the marker stack to
; decide how to alter pcode already emitted to the pcode buffer during
; parsing.
; An Argument may be passed to a code generation function in ax.
;
;--------------------------------------------------------------------------

assumes	ds,DATA
assumes	ss,DATA
assumes	es,NOTHING

sBegin	DATA
sEnd	DATA

sBegin	CP
assumes	cs,CP

;*********************************************************************
; VOID InsertOp(ax:opcode, bx:oDst)
;
; Purpose:
;	Insert an opcode at a given offset into the pcode buffer
;	If out-of-memory, ps.errCode = ER_OM on exit
;
; Entry:
;	bx = offset into ps.bdpDst where word is to be inserted
;	ax = word to be inserted
; Exit:
;	Caller's can depend on bx being preserved
;	If an out-of-memory error occurs, ps.errCode = ER_OM
;
;*********************************************************************
InsertOp PROC NEAR
	;make room for 2 bytes in pcode buffer before oDst
	; BdShiftRight((bd *)&ps.bdpDst, oDst, (ushort)2))
	
	push	bx			;save caller's bx
	push	ax			;save opcode
	push	bx			;save oDst

	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	bx			;pass oDst
	PUSHI	ax,2
	call	BdShiftRight		;grow buf, can cause heap movement
	or	ax,ax
	je	InsOpOmErr		;brif out-of-memory
	call	SetDstPbCur		;update ps.bdpDst.pbCur,

	pop	bx			;restore bx = oDst
	add	bx,[ps.PS_bdpDst.BDP_pb]
	pop	[bx]			;pop and store opcode
InsOpExit:
	pop	bx			;restore caller's bx
	ret

InsOpOmErr:
	call	ParseErrOm		;Error "Out of memory"
	pop	bx
	pop	ax
	jmp	SHORT InsOpExit
InsertOp ENDP

;*********************************************************************
; VOID NEAR CgOn(ax:opcode)
;
; Purpose:
;	Called after the RESTORE/RETURN statement has been parsed.
;	It generates code for the statement.
;
; Entry:
;	The top of the MARK stack (*pCurStkMark) is 1 or 2 for
;	   1 for RESTORE
;	   2 for RESTORE <label>
;	opcode = the opcode to emit if top of MARK stack = 1
;	   This can be opStRestore0 or opStReturn0
;
;	The bnf which causes this to occur is:
;	  tkON (event (tkGOSUB ((Lit0 EMIT(opEvGosub) EMIT(UNDEFINED)) |
;			(EMIT(opEvGosub) LabLn)))) |
;	    (tkERROR tkGOTO ((Lit0 EMIT(opStOnError) EMIT(UNDEFINED)) |
;			(EMIT(opStOnError) LabLn))) |
;	    (Exp (tkGOTO MARK(1) | tkGOSUB MARK(2)) LabLn {tkComma LabLn})
;	<CgOn()>
;
;*********************************************************************
PUBLIC	CgOn
CgOn	PROC NEAR
	mov	bx,[pCurStkMark]
	cmp	bx,MAX_STK_MARK
	je	OnExit			;brif no MARK directives from BNF
	push	[bx]			;save markId

	mov	bx,[bx+2]		;bx = offset into pcode which preceeded
					; markId
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	sub	ax,bx			;ax = byte count of operands
	call	InsertOp		;insert word AX at offset BX
					; (bx is preserved)
	pop	ax			;restore ax = markId
	cmp	al,1			;markId
	mov	ax,opStOnGoto
	je	GotGoto			;brif if MARK(1) directive (GOTO)
	mov	ax,opStOnGosub		;else it must be MARK(2) (GOSUB)
GotGoto:
	call	InsertOp		;insert word AX at offset BX
OnExit:
	ret
CgOn	ENDP

;*********************************************************************
; VOID NEAR CgInsert0or1(opcode)
;
; Purpose:
;	Called after the RESTORE/RETURN statement has been parsed.
;	It generates code for the statement.
;	If out-of-memory, ps.errCode = ER_OM on exit
;
; Entry:
;	The top of the MARK stack (*pCurStkMark) is 1 or 2 for
;	   1 for RESTORE/RETURN/RESUME
;	(generated pcode = opStRestore0/opStReturn0/opStResume0)
;	   2 for RESTORE/RETURN/RESUME <label>
;	(generated pcode = opStRestore1/opStReturn1/opStResume <label>)
;	   3 for RESUME 0
;	(generated pcode = opStResume <UNDEFINED>)
;	   4 for RESUME NEXT
;	(generated pcode = opStResumeNext)
;
;	opcode = the opcode to emit if top of MARK stack = 1
;	   This can be opStRestore0, opStReturn0, or opStResume0
;
;	The bnf which causes this to occur is:
;	   tkRESTORE MARK(1) [LabLn MARK(2)]
;	 <CgInsert0or1(opStRestore0)>
;	   tkRETURN MARK(1) [LabLn MARK(2)]
;	 <CgInsert0or1(opStReturn0)>
;	   tkRESUME MARK(1) [(LabLn MARK(2)) | (Lit0 MARK(3)) |
;	                     (tkNEXT MARK(4))]
;	<CgResume(opStResume0)>
;
;*********************************************************************
PUBLIC	CgInsert0or1
CgInsert0or1 PROC NEAR
	xchg	dx,ax			;save opcode in dx
	mov	bx,[pCurStkMark]
	mov	al,[bx]			;al = markId
	cmp	al,1
	je	InsMark1		;brif got RESUME or RETURN or RESTORE
					; with no parameter
	cmp	al,2
	je	InsMark2
	cmp	al,3
	je	InsMark3		;brif got RESUME 0

;else it must be MARK(4) RESUME NEXT
	mov	ax,opStResumeNext
	jmp	SHORT InsEmit

;got RESUME or RETURN or RESTORE with no parameter
InsMark1:
	xchg	ax,dx			;ax = opcode
InsEmit:
	call	Emit16_AX
	jmp	SHORT InsExit

InsMark2:
	push	dx			;save opcode

	;make room for 2 more bytes at end of pcode buffer
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	PUSHI	ax,2
	call	BdGrow			;grow buf, can cause heap movement
	or	ax,ax
	je	InsOmErr
	;move label's oNam forward in buffer by 2 bytes
	mov	bx,[ps.PS_bdpDst.BDP_pbCur]
	mov	ax,[bx-2]
	mov	[bx],ax

	;Insert opcode before label's oNam
	pop	ax			;ax = opcode
	inc	ax			;map to opcode variant with no parm
					; opStResumeLab opStRestoreLab or
					; opStReturnLab
	mov	[bx-2],ax		;store opcode
	call	SetDstPbCur		;update ps.bdpDst.pbCur
	jmp	SHORT InsExit

;map RESUME 0 to opStResume(UNDEFINED)
InsMark3:
	mov	ax,opStResume
	call	Emit16_AX
	mov	ax,UNDEFINED
	call	Emit16_AX
InsExit:
	ret

InsOmErr:
	jmp	ParseErrOm		;Error "Out of memory"
					; and return to caller
CgInsert0or1 ENDP

;*********************************************************************
; ErrIfPrsHasTxtTbl()
; Purpose:
;	If the current prs (prsCur) has a text table, generate an error.
;	This is called by functions which are about to do something which
;	can only be done to a "compiled" (external) procedure, not a
;	pcoded procedure.
;
; Exit:
;	returns FALSE if prsCur has a text table (condition codes set)
;
;*********************************************************************
ErrIfPrsHasTxtTbl PROC NEAR
	sub	ax,ax			;prepare to return FALSE
	test	[txdCur.TXD_flags],FTX_mrs
	jne	ErrNoText		;brif prs has no text table
	mov	ax,MSG_InvDecl OR PSERR_fAlert
	call	ParseErr0
	mov	ax,sp			;return TRUE (non-zero)
ErrNoText:
	or	ax,ax			;set condition codes for caller
	ret	
ErrIfPrsHasTxtTbl ENDP

;*********************************************************************
; VOID NEAR CgDeclare(opcode)
;
; Purpose:
;	Called after the DECLARE, SUB, FUNCTION or DEF FN statement has
;	been parsed.  It generates code for the statement.
;	The prs has already been created (by MakeProc in prsid.asm),
;	and is active for all statements except DECLARE.
;
; Entry:
;	Structure pdcl is filled in by parser terminal recognizers like
;	   NtIdSubDecl, NtIdFn [QB4], etc. to describe to prs being declared/defined
;	The MARK stack (*pCurStkMark) contains entries built by the bnf:
;	   MARK 1    indicates CDECL was present
;	   MARK 2 -> ALIAS's string literal
;	   MARK 3 -> start of formal parm list
;	   MARK 4    indicates STATIC was found
;	   MARK 5 -> single line DEF FN's definition expression
;	   MARK 6    indicates ([parmlist]) was seen
;	   MARK 7 -> LIB's string literal	[EB specific] [07]
;	   MARK 8    indicates AUTO was found	[EB specific] [07]
;
;	BNF which builds entry pcode:
;	   tkDECLARE
;	      (tkFUNCTION IdFuncDecl [tkCDECL MARK(1)]
;	         [tkALIAS MARK(2) LitString] MARK(3) parms) |
;	      (tkSUB IdSubDecl [tkCDECL MARK(1)] 
;	         [tkALIAS MARK(2) LitString] MARK(3) parms)
;	     <CgDeclare(opStDeclare)>
;	   tkDEF IdFn MARK(3) parms [tkEQ MARK(5) Exp]
;	     <CgDeclare(opStDefFn)>
;	   tkFUNCTION IdFuncDef MARK(3) parms [tkSTATIC MARK(4)]
;	     <CgDeclare(opStFunction)>
;	   tkSUB IdSubDef MARK(3) parms [tkSTATIC MARK(4)]
;	     <CgDeclare(opStSub)>
;
;	For the statement DECLARE SUB X CDECL ALIAS "abc" (BYVAL A(), B, ...)
;	The pcode buffer contains:
;	              <"abc"> <idA> <idB> ...
;	MARK(1)MARK(2)^MARK(3)^
;
;	For the statement SUB X (BYVAL A(), B, ...) STATIC
;	The pcode buffer contains:
;	       <idA> <idB> ...
;	MARK(3)^MARK(8)
;
;	Where <idX> is 3 16 bit words:  oPrs, oNamProc, oTypProc
;
;*********************************************************************
cProc	CgDeclare,<PUBLIC,NEAR,NODATA>,<si,di>
	localW	opcode
	localW	oDstParms
	localW	oDstAlias
	localW	oDstEndDef
	localW	cbLibInfo
	localW	procAtr
	procAtr_LO EQU  BYTE PTR (procAtr)
	procAtr_HI EQU  BYTE PTR (procAtr+1)
cBegin
	mov	[opcode],ax
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	mov	[oDstEndDef],ax		;save current size of output

	sub	ax,ax
	mov	[procAtr],ax
	mov	[oDstAlias],ax
	mov	[cbLibInfo],ax
	mov	al,[pdcl.PDCL_procType]
	.errnz	DCLA_procType - 0300h
	or	[procAtr_HI],al		;save procType in pcode field
	mov	al,[pdcl.PDCL_oTyp]	;al = value for low byte of ProcAtr
					;  word which DCLA_Explicit,
					;  DCLA_AsClause, and DCLA_oTyp
	mov	[procAtr_LO],al		;save oTyp in pcode field
	sub	ax,ax
	cmp	[pdcl.PDCL_fDeclare],al
	je	NotDeclare		;brif not DECLARE stmt
	cmp	[pdcl.PDCL_cParms],ax
	jne	MarkDisp		;brif got a parm list
	dec	[pdcl.PDCL_cParms]	;set to UNDEFINED so scanner knows
					; to not use this for parm
					; type/count checking
	jmp	SHORT MarkDisp

NotDeclare:
	;If we don't get MARK(4), this SUB/FUNCTION has no STATIC keyword
	and	[prsCur.PRS_flags],NOT FP_STATIC

;-------------------------------------------------
;walk through MARK(xxx) entries from left to right
;-------------------------------------------------
MarkDisp:
	mov	si,MAX_STK_MARK
DeclMarkLoop:
	cmp	[pCurStkMark],si
	jne	DeclNextMark
	jmp	SHORT DeclEndOfMarks

DeclNextMark:
	dec	si
	dec	si
	mov	di,[si]			;di = oDstOpcode
	dec	si
	dec	si
	mov	ax,[si]			;ax = al = markId
	dec	ax
	DbAssertRel ax,be,9,CP,<Unexpected MARK in CgDeclare()>
	shl	ax,1
	xchg	ax,bx			;bx = 2 * (markId - 1)
	jmp	WORD PTR cs:DeclDispTbl[bx]	;dispatch based on markId

DeclDispTbl:
	DW	DeclMark1		;CDECL
	DW	DeclMark2		;ALIAS
	DW	DeclMark3		;parms (before left paren)
	DW	DeclMark4		;STATIC
	DW	DeclMark5		;single line DEF
	DW	DeclMark6		;1st parm (after left paren)

;MARK(1):  Got CDECL directive
DeclMark1:
	call	ErrIfPrsHasTxtTbl
	jne	DeclMarkLoop		;brif prs has a text table
	.errnz	DCLA_cdecl - 8000h
	or	[procAtr_HI],80h	;remember we got CDECL
	jmp	SHORT DeclMarkLoop

;MARK(2):  Got ALIAS directive
DeclMark2:
	call	ErrIfPrsHasTxtTbl
	mov	[oDstAlias],di		;save offset to opLitSD("<alias>")
	jmp	SHORT DeclMarkLoop

;MARK(3):  got offset to formal parm list
DeclMark3:
	mov	[oDstParms],di
	jmp	SHORT DeclMarkLoop

;MARK(4):  got STATIC keyword at end of proc definition
DeclMark4:
	or	[prsCur.PRS_flags],FP_STATIC
	jmp	SHORT DeclMarkLoop

;MARK(5):  got single line DEF FN
DeclMark5:
	mov	[oDstEndDef],di
	mov	ax,opEndSingleDef
	call	Emit16_AX
	mov	ax,2
	call	Emit16_AX		;emit cntEos word
	call	Emit16_0		;emit space for link field
	jmp	SHORT DeclMarkLoop

;MARK(6):  got ( [parmlist] )
DeclMark6:
	cmp	[pdcl.PDCL_cParms],UNDEFINED ;so scanner knows to not use this
					; for parm type/count checking
	jne	DeclMarkLoop		;brif got a parm list
	inc	[pdcl.PDCL_cParms]	;so scanner knows to use this declare
					; for parm type/count checking
	jmp	SHORT DeclMarkLoop


DeclEndOfMarks:
	;Copy Alias text after formal parms
	mov	ax,[oDstAlias]
	or	ax,ax
	je	NoAliasArg
	call	CopyLit			;ax = cbAlias
	mov	[cbLibInfo],ax
	shl	al,1
	shl	al,1
	.errnz	DCLA_cbAlias - 7C00h
	or	[procAtr_HI],al		;save cbAlias in pcode field


	;squeeze source of ALIAS lit out of pcode buffer
	;BdShiftLeft((bd *)&ps.bdpDst, oDstAlias, oDstParms - oDstAlias)
	
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	[oDstAlias]
	mov	ax,[oDstParms]
	sub	ax,[oDstAlias]		;ax = number of bytes to delete
	push	ax
	sub	[oDstParms],ax		;update for the left shift
	sub	[oDstEndDef],ax		;update for the left shift
	call	BdShiftLeft		;grow buf, can cause heap movement

NoAliasArg:
	;Now make room for things to insert before parm list:
	; opcode, byte-count-till-end-of-stmt, link field for DEF FNs, oPrs
	mov	si,10			;assume we need to insert 10 bytes
	cmp	[pdcl.PDCL_procType],PT_DEFFN
	jne	NotDefFn1		;brif not DEF FN stmt
	inc	si			;need 2 extra bytes for link field
	inc	si
NotDefFn1:
	;BdShiftRight((bd *)&ps.bdpDst, oDstParms, cbInsert)
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	[oDstParms]
	push	si			;pass cbInsert parm
	call	BdShiftRight
	or	ax,ax
	jne	ShiftOk			;brif no out-of-memory error
	call	ParseErrOm		;Error "Out of memory"
	jmp	SHORT DeclExit

ShiftOk:
	call	SetDstPbCur		;update ps.bdpDst.pbCur after BdShift...
	push	ds
	pop	es			;es = ds for stosw below
	mov	di,[oDstParms]
	add	di,[ps.PS_bdpDst.BDP_pb]
	mov	ax,[opcode]
	stosw				;store opcode in pcode buffer

	;emit cntEos operand
	mov	ax,[oDstEndDef]
	sub	ax,[oDstParms]
	add	ax,si			;include cbInsert
	add	ax,[cbLibInfo]		;add #bytes in LIB and ALIAS clause
	sub	ax,4
	inc	ax			;round up to even byte count
	and	al,0FEH
	stosw				;store cntEos operand

	cmp	[pdcl.PDCL_procType],PT_DEFFN
	jne	NotDefFn2		;brif not DEF FN stmt
	stosw				;leave room for DEF FN link field
NotDefFn2:
	mov	ax,[pdcl.PDCL_oPrs]
	or	ax,ax
	jns	NotUnboundDefFn
	mov	ax,[pdcl.PDCL_oNam]	;for [DECLARE] DEF FNs, in SS_RUDE
					;state, emit the oNam
NotUnboundDefFn:

	stosw				;store oPrs/oNam operand
	mov	ax,[procAtr]
	stosw				;store proc's oTyp
	mov	ax,[pdcl.PDCL_cParms]
	stosw				;store cParms operand
DeclExit:
cEnd

;*********************************************************************
; CopyLit(ax:oDstLit)
; Purpose:
;	Move the ASCII text of an opLitSD to the end of the pcode buffer.
;	If string is longer than 255 bytes, it is truncated.
; Entry:
;	ax = offset into pcode buffer to opLitSD opcode
;	[EB] bx = TRUE iff length of string is to output as byte preceeding
;		  text of string. 
; Exit:
;	string is moved to end of pcode buffer and the opLitSd is removed
;	ax = length of string
;
;*********************************************************************
CopyLit	PROC NEAR
	push	si
	mov	si,ax
	add	si,[ps.PS_bdpDst.BDP_pb]
	lodsw				;skip opLitSD opcode
	DbAssertRel ax,e,opLitSD,CP,<CopyLit: expected opLitSD> 
	lodsw				;ax = cb operand from opLitSD
	or	ah,ah
	je	LenOk
	mov	ax,255			;truncate string
LenOk:
	push	ax			;save for return value
	inc	ax			;round up to word count
	shr	ax,1
	mov	cx,ax
	jcxz	CLitExit		;brif entire string has been copied
CLitLoop:
	push	cx			;save word count
	lodsw				;ax = next 2 bytes of string

	sub	si,[ps.PS_bdpDst.BDP_pb] ;Emit16 can cause heap movement
	call	Emit16_AX
	add	si,[ps.PS_bdpDst.BDP_pb] ;reconvert offset to pointer

	pop	cx			;restore word count
	loop	CLitLoop
CLitExit:
	pop	ax			;ax = string length
	pop	si
	ret
CopyLit	ENDP

;*********************************************************************
; CgCall(opcode)
; Purpose:
;	Called to generate pcode for the following bnf:
;	 tkCALL (MARK(1) IdImplicit
;	   [tkLParen IdCallArg {tkComma IdCallArg} tkRParen])
;	 tkCALLS MARK(1) IdImplicit
;	   [tkLParen IdCallArg {tkComma IdCallArg} tkRParen]
;
;*********************************************************************
PUBLIC	CgCall
CgCall	PROC NEAR
	push	si			;save caller's si
	mov	bx,MAX_STK_MARK
	mov	si,[bx-2]		;si=offset in pcode for item after MARK
	push	ax			;save opcode for Emit16 below
	mov	bx,[ps.PS_bdpDst.BDP_pb]
	mov	ax,[bx][si]		;ax = oNamIdSub
	call	SubRef			;ax = oPrs for sub being called
					;We can ignore error results, because
					;if error occurs, no code will ever
					;try to activate this oPrs, because
					;line will be stored as opReParse

	;delete the information emitted by NtIdImplicit()
	;BdShiftLeft((bd *)&ps.bdpDst, oDstCur, 2)
	
	PUSHI	dx,<dataOFFSET ps.PS_bdpDst>
	push	si
	PUSHI	dx,2
	mov	si,ax			;si = oPrs
	call	BdShiftLeft		;grow buf, can cause heap movement
	call	SetDstPbCur		;set ps.bdpDst.pbCur after BdShiftLeft
	call	Emit16			;emit opcode pushed ~15 lines above
	push	[cIdArgs]
	call	Emit16			;emit arg count
	push	si			;push oPrs
	call	Emit16
	pop	si			;restore caller's si
	ret
CgCall	ENDP

;*********************************************************************
; VOID NEAR CgRun(opcode)
; Purpose:
;	Invoked to generate code for the following bnf:
;	 tkRUN [(Ln MARK(1)) | (Exp MARK(2))]; <CgRun()>
;
;*********************************************************************
PUBLIC	CgRun
CgRun	PROC NEAR
	mov	bx,[pCurStkMark]
	cmp	bx,MAX_STK_MARK
	mov	ax,opStRunMain		;ax = opcode to emit for RUN
	je	RunEmitExit		;brif simple RUN (no MARKs)
	DbAssertRelB [bx],be,2,CP,<Invalid MARK id in CgRun()>
	cmp	BYTE PTR [bx],1
	jne	RunFile			;brif markId != 1  (RUN <filename>)

	;Got RUN <line number>, insert opStRunLabel before Ln
	mov	bx,[bx+2]		;bx = pcode offset
	dec	bx
	dec	bx			;bx = pcode offset where opcode is to go
	mov	ax,opStRunLabel
	call	InsertOp		;insert word AX at offset BX
	jmp	SHORT RunExit

RunFile:
	mov	ax,opStRunFile
RunEmitExit:
	call	Emit16_AX
RunExit:
	ret
CgRun	ENDP

;*********************************************************************
; VOID NEAR CgInput(opcode)
; Purpose:
;	Invoked to generate code for the following bnf:
;
;	tkINPUT 
;	 [(lbsInpExpComma MARK(16)) |
;	  (tkSColon MARK(2) [LitString MARK(4) (tkSColon | (tkComma MARK(1)))])|
;	  (LitString MARK(4) (tkSColon | (tkComma MARK(1))))]
;	 MARK(8) IdAryElemRef EMIT(opStInput) {tkComma IdAryElemRef
;                                              EMIT(opStInput)}
;	 EMIT(opInputEos)
;	   <CgInput(opInputPrompt)>
;
;	tkLINE tkINPUT
;	 [(lbsInpExpComma MARK(16)) |
;	  (tkSColon MARK(2) [LitString MARK(4) (tkSColon | (tkComma MARK(1)))]) |
;	  (LitString MARK(4) (tkSColon | (tkComma MARK(1))))]
;	 IdAryElemRef
;	   <CgInput(opStLineInput)>
;
;	It maps syntax to pcode as follows:
;	   INPUT [;] [prompt (,|;) <list> =>
;	    [sdExp] opInputPrompt(cnt,mask,<typelist>)
;	If prompt is followed by a semicolon, FINP_QSupress is not ORed into
;          'mask' which causes a question mark to be appended to the prompt
;          string.
;	The optional semicolon after INPUT causes FINP_CrLf not to be ORed into
;	   'mask' which causes the user's terminating carriage return not to be
;	   echoed.
;
;*********************************************************************
PUBLIC	CgInput
CgInput	PROC NEAR
.errnz	FINP_QSupress - 1
.errnz	FINP_CrLf - 2
.errnz	FINP_Prompt - 4
	push	si			;save caller's si
	push	di			;save caller's di
	sub	di,di			;init bit mask
	mov	bx,MAX_STK_MARK

;OR bit mask with to 1 for comma after prompt (MARK(1)),
;		     2 for semicolon after INPUT (MARK(2)),
;		     4 for prompt (MARK(4))
InpMarkLoop:
	cmp	[pCurStkMark],bx
	je	InpMarkLoopDone
	dec	bx
	dec	bx
	mov	si,[bx]			;si = oDstOpcode from mark stack
	dec	bx
	dec	bx
	cmp	WORD PTR [bx],16
	jne	NotMark16		;brif markId != 16
	cmp	ax,opStLineInput
	je	InpMarkLoop		;brif not INPUT #n
	jmp	SHORT InpExit		;If INPUT #n, pcode is already complete

NotMark16:
	or	di,[bx]
	DbAssertRel di,b,16,CP,<Invalid markId in CgInput>
	jmp	SHORT InpMarkLoop

;di = bit mask (built by ORing markIds)
;ax = opcode
;
InpMarkLoopDone:
	cmp	ax,opStLineInput
	jne	NotLineInput
	call	Emit16_AX		;emit opcode
	push	di			;emit bit mask
	call	Emit16
	jmp	SHORT InpExit

;It was INPUT, not LINE INPUT
;insert opStInputPrompt[cbOperands:16,mask:8,types:8]
;don't count string literal in cInputItems (its in cIdArgs)
;count mask in cInputItems (cancels string literal)
;di = bit mask (built by ORing markIds)
;ax = opcode
;
NotLineInput:
	push	ax			;save opcode on stack
	mov	ax,[cIdArgs]
	shr	ax,1			;round down to word count
	mov	cx,ax			;cx = word count
	mov	bx,si			;bx = oDstOpcode (place to insert ops)
	jcxz	InpLoopDone

;emit garbage typelist (scanner will fill in)
InpLoop:
	push	cx			;save word count
	call	InsertOp		;insert word AX at offset BX
					;any value in ax would do, scanner fills
					; (bx is preserved)
	pop	cx			;restore word count
	loop	InpLoop

;now emit mask and space for 1st entry in type list
InpLoopDone:
	mov	ax,di
	and	al,7			;mask off bits > 7
	call	InsertOp		;insert word AX at offset BX
					; (bx is preserved)
	mov	ax,[cIdArgs]
	inc	ax
	call	InsertOp		;insert word AX at offset BX
					; (bx is preserved)
	pop	ax			;ax = opcode (pushed ~25 lines above)
	call	InsertOp		;insert word AX at offset BX
InpExit:
	pop	di			;save caller's di
	pop	si			;save caller's si
	ret
CgInput	ENDP

;*********************************************************************
; CgStmtCnt(opcode)
; Purpose:
;	Called for statements like CLEAR, CLOSE, COLOR, ERASE, FIELD, LOCATE
;	and SCREEN, which take as an operand the number of arguments
;	preceding them.
;
;*********************************************************************
PUBLIC	CgStmtCnt
CgStmtCnt PROC NEAR
	call	Emit16_AX		;emit the opcode
	mov	ax,[cIdArgs]
	jmp	Emit16_AX		;emit the arg count
					;and return to caller
CgStmtCnt	ENDP

;*********************************************************************
; CgCntHigh(opcode)
;
; Purpose:
;
;   Called for the Format$ function.
;
;*********************************************************************

	;Added with [11]


	;End of [11]

;*********************************************************************
; CgLineStmt(opcode)
;
; Purpose:
;	Invoked to generate code for the following bnf:
;	   tkLINE [coordStep] tkMinus coord2Step
;	[tkComma [Exp MARK(1)]
;	  [tkComma [(RwBF MARK(3)) | (RwB (RwF MARK(3)) | MARK(2))]
;	    [tkComma Exp MARK(4)]]]
;	<CgLineStmt(opStLine)>
;
;*********************************************************************
PUBLIC	CgLineStmt
CgLineStmt PROC NEAR
	push	si			;save caller's si
	sub	dx,dx			;operand = 0
	mov	cx,ax			;cx = opcode
	mov	si,[pCurStkMark]
LineLoop:
	cmp	si,MAX_STK_MARK
	je	LineLoopDone
	lodsw				;ax = markId
	inc	si			;skip oDstPcode
	inc	si
	dec	ax
	je	LineMark1		;brif MARK(1)
	dec	ax
	je	LineMark2		;brif MARK(2)
	dec	ax
	je	LineMark3		;brif MARK(3)

;MARK(4) means line style parm was specified
	inc	cx			;convert opStLine, opStLineColor->
					; opStLineStyle, opStLineColorStyle
	;fall into case 1
;MARK(1) means color parm was specified
LineMark1:
	inc	cx			;convert opStLine to opStLineColor
	jmp	SHORT LineLoop

;MARK(2) means B parm was specified
LineMark2:
	mov	dl,1			;operand = 1
	jmp	SHORT LineLoop

LineMark3:
;MARK(3) means BF parm was specified
	mov	dl,2			;operand = 2
	jmp	SHORT LineLoop

LineLoopDone:
	push	dx			;pass operand to Emit16 below
	xchg	ax,cx			;ax=opcode for Emit16_AX
	call	Emit16_AX		;emit the opcode
	call	Emit16			;emit the operand
	pop	si			;restore caller's si
	ret
CgLineStmt ENDP

;*********************************************************************
; CgOpen(opcode)
;
; Purpose:
;	Invoked to generate code for the following bnf:
;  tkOPEN Exp
;   ([(tkFOR ((tkAPPEND  MARK(1)) |
;             (tkINPUT   MARK(2)) | 
;             (tkOUTPUT  MARK(3)) |
;             (tkRANDOM  MARK(4)) |
;             (tkBINARY  MARK(5))))]
;    [tkACCESS ((tkREAD  MARK(6) [tkWRITE MARK(8)]) | (tkWRITE MARK(7)))]
;    [(tkLOCK ((tkREAD ((tkWRITE MARK(11)) | MARK(9))) |
;              (tkWRITE MARK(10)))) |
;     (tkSHARED MARK(12))]
;    tkAS optFilenum [tkLEN tkEQ Exp MARK(13)])  |
;   (tkComma optFilenum exp12 MARK(14))
;     <CgOpen(opStOpen2)>
;
;*********************************************************************
tModeMask LABEL WORD
	DW MD_APP		; MARK(1) means APPEND was specified
	DW MD_SQI		; MARK(2) means INPUT was specified
	DW MD_SQO		; MARK(3) means OUTPUT was specified
	DW MD_RND		; MARK(4) means RANDOM (or default) was speced
	DW MD_BIN		; MARK(5) means BINARY was specified
	DW ACCESS_READ * 256	; MARK(6) means READ was specified
	DW ACCESS_WRITE * 256	; MARK(7) means WRITE was specified
	DW ACCESS_BOTH * 256	; MARK(8) means READ WRITE was specified
	DW LOCK_READ * 256	; MARK(9) means LOCK READ was specified
	DW LOCK_WRITE * 256	; MARK(10) means LOCK WRITE was specified
	DW LOCK_BOTH * 256	; MARK(11) means LOCK READ WRITE was specified
	DW LOCK_SHARED * 256	; MARK(12) means SHARED was specified

PUBLIC	CgOpen
CgOpen	PROC NEAR
	push	si			;save caller's si
	mov	cx,ax			;cx = opcode
	sub	dx,dx			;mode = 0
	mov	si,[pCurStkMark]
OpenLoop:
	cmp	si,MAX_STK_MARK
	je	OpenLoopDone
	lodsw				;ax = markId
	inc	si			;skip pcode offset
	inc	si
	cmp	al,14
	je	OpenMark14
	cmp	al,13
	je	OpenMark13
	;mode |= tModeMask[markId - 1]
	xchg	bx,ax			;bx = markId
	shl	bx,1			;convert to word index
	mov	ax,tModeMask - 2[bx]	;ax = mask
	or	dx,ax			;or mask into mode
	jmp	SHORT OpenLoop

;MARK(13) means LEN=nnn was specified
OpenMark13:
	inc	cx			;convert opStOpen2 to opStOpen3
	jmp	SHORT OpenLoop

OpenLoopDone:
	push	dx			;save mode
	xchg	ax,cx			;emit opcode
	call	Emit16_AX
	pop	ax			;ax = open mode
	test	al,MD_APP OR MD_SQI OR MD_SQO OR MD_RND OR MD_BIN
	jne	OpenEmitExit		;brif open mode was specified
	or	al,MD_DEFAULT		;default open mode
OpenEmitExit:
	call	Emit16_AX		;emit open mode
	pop	si			;restore caller's si
	ret

;MARK(14) means old open syntax
OpenMark14:
	mov	ax,[cIdArgs]
	add	ax,opStOpenOld3 - 3	;ax = old open opcode
	jmp	SHORT OpenEmitExit

CgOpen	ENDP

;*********************************************************************
; CgLock(opcode)
;
; Purpose:
;	Invoked to generate code for the following bnf:
;	tkLOCK optFileNum
;	 (tkComma (Exp MARK(1) [tkTO MARK(2) Exp]) | (tkTO MARK(3) Exp]))
;	   <CgLock(opStLock)>
;	tkUNLOCK optFileNum
;	 (tkComma (Exp MARK(1) [tkTO MARK(2) Exp]) | (tkTO MARK(3) Exp]))
;	   <CgLock(opStLock)>
;
;*********************************************************************
PUBLIC	CgLock
CgLock	PROC NEAR
	push	si			;save caller's si
	push	di			;save caller's di
	mov	di,ax			;di = opcode
	sub	dx,dx			;mode = markId = 0
	cmp	ax,opStUnLock
	jne	NotUnlock
	mov	dl,LOCK_UNLOCK		;mode = LOCK_UNLOCK
NotUnlock:
	mov	si,[pCurStkMark]
LockLoop:
	cmp	si,MAX_STK_MARK
	je	LockLoopDone		;brif done with MARK directives
	lodsw				;al = markId
	xchg	cx,ax			;cl = markId
	lodsw				;ax = oDstOpcode
	cmp	cl,1
	jne	NotMark1		;brif not MARK(1)
	test	dl,LOCK_1stToLast
	jne	NotMark1		;brif MARK(2) was seen
	or	dh,LOCK_DefLastArg/256	;tell executor to default last record
NotMark1:
	cmp	cl,3
	jne	NotMark3		;brif not MARK(3)
	xchg	bx,ax			;bx = oDstOpcode
	;Emit default 1st record before the 2nd Exp
	push	dx			;save dx
	.erre	opLitI2Max GE 1 	; Assure 1 is allowed
	mov	ax,opLitI2+OPCODE_MASK+1; pass opLitI2 with value of 1
	call	InsertOp		;insert word AX at offset BX
					; (bx is preserved)
	pop	dx			;restore dx = mode & markId
	or	dh,LOCK_Def1stArg/256	;tell lister to default 1st record
NotMark3:
	or	dl,LOCK_1stToLast
	jmp	SHORT LockLoop

LockLoopDone:
	push	dx			;pass mode to 2nd call of Emit16
	xchg	ax,di			;pass opcode to Emit16_AX
	call	Emit16_AX		;emit the opcode
	call	Emit16			;emit the mode operand
	pop	di			;restore caller's di
	pop	si			;restore caller's si
	ret
CgLock	ENDP

PUBLIC	Cg0or1Args, Cg1or2Args, Cg2or3Args, Cg3or4Args
Cg3or4Args PROC NEAR
	dec	ax
Cg3or4Args ENDP				;fall into Cg2or3Args
Cg2or3Args PROC NEAR
	dec	ax
Cg2or3Args ENDP				;fall into Cg1or2Args
Cg1or2Args PROC NEAR
	dec	ax
Cg1or2Args ENDP				;fall into Cg0or1Args
Cg0or1Args PROC NEAR
	mov	dx,ax			;save base opcode in dx
	add	ax,[cIdArgs]		;ax = opcode + cIdArgs
	cmp	dx,opStMid_2 - 3
	je	CgMoveOpsToEnd		;brif MID$ statement
J1_Emit16_AX:
	jmp	Emit16_AX		;emit ax and return to caller
Cg0or1Args ENDP


;*********************************************************************
; CgMoveOpsToEnd(opcode)
;
; Purpose:
;	Invoked to generate code for the following bnf:
;	  tkLSET MARK(1) idAryElemRef MARK(2) tkEQ Exp
;	    CgMoveOpsToEnd(opStLset)
;	  tkRSET MARK(1) idAryElemRef MARK(2) tkEQ Exp
;	    CgMoveOpsToEnd(opStRset)
;	  tkMID_ tkLParen MARK(1) idAryElemRef MARK(2) exp12 tkRParen tkEQ Exp
;	    Cg3or4Args(opStMid_2)
;	Moves the pcode for idAryElemRef to the end of the buffer
;
;*********************************************************************
cProc	CgMoveOpsToEnd,<PUBLIC,NEAR,NODATA>,<si,di>
cBegin
	push	ax			;pass opcode to Emit16 (at end of proc)
	mov	si,[pCurStkMark]
	lodsw				;al = markId (2)
	lodsw				;ax = text offset for MARK(2)
	xchg	di,ax			;bx = text offset for MARK(2)
	lodsw				;al = markId (1)
	lodsw				;ax = text offset for MARK(1)
	xchg	si,ax			;si = text offset for MARK(1)

	;setup for BdShiftLeft((bd *)&ps.bdpDst, oDstCur, cbMoved)
	
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	si
	mov	ax,di
	sub	ax,si
	push	ax			;pass cbMoved
					;call to BdShiftLeft is after loop
MoveLoop:
	cmp	si,di
	je	MoveDone
	add	si,[ps.PS_bdpDst.BDP_pb] ;si = ptr to next word to be moved
	lodsw				;ax = next word to be moved
	sub	si,[ps.PS_bdpDst.BDP_pb] ;si = offset to next word to be moved
	call	Emit16_AX		;copy word to end of buffer
	jmp	SHORT MoveLoop

MoveDone:
	;delete the source of copied words - parms pushed several lines above
	call	BdShiftLeft		;grow buf, can cause heap movement
	call	SetDstPbCur		;update ps.bdpDst.pbCur for BdShiftLeft
	;emit opcode - parm pushed several lines above
	call	Emit16
cEnd

PUBLIC	CgCircle
CgCircle PROC NEAR
	mov	dx,MAX_STK_MARK
	cmp	[pCurStkMark],dx
	je	NoCircleMark
	inc	ax			;got a MARK(1), color parm included
					;map opStCircle to opStCircleColor
NoCircleMark:
	jmp	Emit16_AX		;emit ax and return to caller
CgCircle ENDP


sEnd	CP
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsid.asm ===
TITLE	prsid.asm - Parser ID Related NonTerminal Functions

;==========================================================================
;
;	Module:  prsid.asm - Parser ID Related NonTerminal Functions
;	Subsystem:  Parser
;	System:  Quick BASIC Interpreter
;
;	See Comments at top of prsnt.asm for rules for writing non-terminal
;	functions
;
;
;==========================================================================

	include		version.inc
	PRSID_ASM = ON

	includeOnce	architec
	includeOnce	context
	includeOnce	names
	includeOnce	opcodes
	includeOnce	parser
	includeOnce	pcode
	includeOnce	prstab
	includeOnce	prsirw
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	util
	includeOnce	variable

	MAXARG EQU 60d	;BASCOM shared constant - max args to SUB/FUNC/DEF
	MAXDIM EQU 60d	;BASCOM shared constant - max args to DIM

ET_MAX_NOFIELDS = ET_MaxStr

FV_ARYELEM EQU 0


sBegin	DATA
assumes	ds,DATA
assumes ss,DATA

fLastIdIndexed	DW 1 DUP (?)

PUBLIC		oNamConstPs
oNamConstPs	DW 0	;non-zero if we're parsing a CONST expression

;pdcl is used to pass info from parser terminal recognizers like
;NtIdSubDecl, NtIdFn [QB4], etc. to the code generator CgDeclare():
;
PUBLIC		pdcl
pdcl		DB size PDCL_st DUP(?)


NTEL_ARGS EQU 0010h			;used as input flag to NtExprOrArg

	extrn	fMergeInSub:byte	;non-zero if MERGING into SUB/FUNC
					;only valid when FLoadActive is TRUE
sEnd	DATA

sBegin	CP
assumes	cs,CP

;====================================================================
; ID Syntactic Elements
;
;       Common identifier non-terminals referenced from bnf.prs
;
;	IdNamCom := idNoType
;	      occurs in COMMON /id/ statements	[QB4]
;	IdAry := id [()]
;	      occurs in SHARED statement. [QB4]
;	IdAryI := id [([integer])]
;	      occurs in STATIC, COMMON [QB4], and array in formal arg list for
;	IdAryElem := id [(arg, ... )]
;	      occurs in expressions, which can be array references or function
;	         invocations. [QB4]
;	IdAryElemRef := id [(arg, ... )]
;	      occurs in GET, LINE INPUT, INPUT, MID$, PUT, READ, RSET,
;	      SADD, SWAP, VARPTR, VARPTR$, VARSEG.
;	      Causes a Rf type Id opcode to be emitted.
;	IdArray() := id
;	      occurs in ERASE, LBOUND, UBOUND
;	IdAryGetPut() := id [(exp, ...)]
;	      occurs in GET, PUT, PALETTE USING statements [QB4]
;	IdAryDim := id [(exp [TO exp], ... )]
;	      occurs in DIM statement.
;	IdAryRedim := id (exp [TO exp], ... )
;	      occurs in REDIM statement.
;	IdFor := id
;	      occurs in FOR and NEXT statements
;	IdSubDef := id <no type char>
;	      occurs in SUB statement
;	IdSubDecl := id <no type char>
;	      occurs in DECLARE SUB statement
;	IdFuncDef := id
;	      occurs in FUNCTION statement
;	IdFuncDecl := id
;	      occurs in DECLARE FUNCTION statement
;	IdType := id
;	      occurs in TYPE statement and AS <type> clause
;	IdFn := FNid
;	      occurs in DEF FN statement
;	IdParm := [BYVAL | SEG] variable
;	      occurs in DECLARE, SUB, FUNCTION, DEF FN parm lists
;	NArgsMax3 := [arg [, [arg] [, arg]]]
;	      occurs in CLEAR and COLOR statements
;	NArgsMax4 := [arg [, [arg] [, [arg] [, arg]]]]
;	      occurs in SCREEN statement
;	NArgsMax5 := [arg [, [arg] [, [arg] [, [arg] [, arg]]]]]
;	      occurs in LOCATE statement
;
; ACTIONidCommon [QB4] - sets varmgr COMMON flag for all ids until end-of-stmt
; ACTIONidShared [QB4] - sets varmgr SHARED flag for all ids until end-of-stmt
; ACTIONidAuto [EB] - sets varmgr AUTO flag for all ids until end-of-stmt
; ACTIONidPublic [EB] - sets varmgr PUBLIC flag for all ids until end-of-stmt
; ACTIONidStatic - sets varmgr STATIC flag for all ids until end-of-stmt
;
;	NOTE [QB4] That it is ok for types, elements, labels, subs, and
;	   common block names to begin
;	   with FN.  It is not ok for scalars, FUNCTIONS or arrays to begin
;	   with FN.
;
;=======================================================================

opId_Ld		EQU opIdLd - opIdLd	;value to add to opIdLd
					; to get opIdLd
opId_Rf		EQU opIdLd - opIdLd	;value to add to opIdLd to get 
					; ref type opcode (same as Ld type)
opId_St		EQU opIdSt - opIdLd	;value to add to opIdLd
					; to get opIdSt
opId_VtRf	EQU opVtRf - opIdLd	;value to add to opIdLd
					; to get opIdVtRf
opId_Scalar	EQU opIdLd - opIdLd	;value to add to opIdxx opcode
					; to get scalar type opcode
opId_Array	EQU opAIdLd - opIdLd	;value to add to opIdxx opcode 
					; to get array type opcode

;*********************************************************************
; STATICF(boolean) FElements()
; Purpose:
;	Look ahead and see if we're looking at record seperator
; Entry:
;	pTokScan points to current token
; Exit
;	Returns zero condition codes iff record separator is seen
;	Alters bx, preserves all other registers (callers assume this)
;
;*********************************************************************
PUBLIC	FElements			
FElements PROC NEAR
	mov	bx,[pTokScan]
	cmp	[bx.TOK_class],CL_UNKNOWNCHAR
	jne	FeExit			;brif not "."
	cmp	[bx.TOK_unknownChar_unknownChar],"."
FeExit:
	ret
FElements ENDP

;*********************************************************************
; ushort NEAR BindVar(ax:pTok)
; Purpose:
;	If we're parsing to SS_PARSE, bind the variable identified by
;	the token 'pTok'.
; Entry:
;	ax = pTok.  points to a token descriptor for the id
;	mkVar is setup for a call to MakeVariable
; Exit:
;	ax = oVar
;
;*********************************************************************
PUBLIC	BindVar
BindVar	PROC NEAR
	push	ax			;save pointer to id's token
	xchg	bx,ax			;bx points to token

	or	[ps.PS_flags],PSF_fRef	;so text mgr knows to scan program
					; if in direct mode 
	TESTM	mkVar.MKVAR_flags,FVI_FNNAME	
	jne	GotFn			;brif id begins with FN
GotFnRet:
	mov	ax,[mkVar.MKVAR_oNam]	;potential return value
	test	[psFlags],PSIF_fBindVars
	je	BindExit		;brif parser not binding variables
					;return oNam (in ax) instead of oVar

	;let varmgr bind variable.
	;If parsing direct mode stmt, scan-state is same current text
	;table's, since if module is SS_RUDE, everything in module is
	
	mov	al,[bx.TOK_id_lexFlags]
	and	al,FLX_asSymConst	;0 if not 'x AS STRING * <sym const>
	or	al,al
	jz	BindVar_Cont

	or	[mkVar.MKVAR_flags2],MV_fONamInOTyp
BindVar_Cont:
	call	MakeVariable
	or	ax,ax			;high bit is set for errors
	js	BindErr			;brif error
BindExit:				;return oVar/oNam in ax
	pop	dx			;discard pTok parm
BindExit1:
	ret

;Make sure its not COMMON FNx or SHARED FNx etc.
GotFn:
	TESTM	mkVar.MKVAR_flags,<FVI_COMMON or FVI_STATIC or FVI_SHARED or FVI_ARRAY or FVI_DIM or FVI_ASCLAUSE or FVI_FORMAL>	
	je	GotFnRet		;brif not a declarative reference
	mov	ax,MSG_FNStart		
	;fall into BindErr

;MakeVariable detected some error, pass it to ParseLine
;in ps.errCode so it can return RudeEdit or ReParse.
;low byte has QBI Std Error Code 
;
BindErr:
	pop	bx			;bx points to token of interest (or 0)
	call	PErrVarMgr		;handle variable mgr error
	jmp	SHORT BindExit1
BindVar	ENDP

;*********************************************************************
; STATICF(boolean) EmitVar(pTok, opBase, cArgs, flags)
;
; Emit one of the following opcodes:
;	opAId<Ld|St|Rf>(<cArgs>,<oNam|oVar>)
;	opAVtRf(<cArgs>,<oNam|oVar>)
; The high bits of the opcode are set to give the explicit type if any. [25]
;
; Entry:
;	   pTok->dsc.id.oNam is the name table offset for the var being defined
;	   pTok->dsc.id.oTyp is the explicit type for the variable being defined
;	      (ET_IMP if id has no explicit type)
;	      (RefTyp(oNam) if it was in an AS clause)
;	   pTok->dsc.id.flags has one or more of the following bits set:
;	      FVI_LVAL      if on left side, or in INPUT, READ stmt
;	      FVI_INDEXED   if var followed by "(" - could be an array or Function
;	      FVI_ASCLAUSE  if var type declared via an AS clause
;	      FVI_DIM       if scalar was seen in a DIM stmt, so var mgr can
;		     detect a scalar being DIMed twice (BASCOM compatibility)
;	   opBase = opId_Ld or opId_St or opId_Rf or opId_VtRf
;	   flags.FEM_Ary means we saw an array, not a scalar
;	     cArgs = number of arguments seen within array's parenthesis
;	     cArgs must be set to 0 if called for a scalar
;	     flags.FEM_AryNoArgs means we saw an array with no (),
;	         like ERASE A.  cArgs = 0 in this case.
;	     flags.FEM_AryDim means we saw something like
;	         DIM(x to y,...)
;	         such that the number of args we pass to the scanner as
;	         an opcode argument is 2 * cArgs.  The number we pass
;	         to MakeVariable is cArgs.)
;	   flags.FEM_ElemOk is TRUE if .elem[.elem...] can be scanned
;	   pTokScan points to '.id' if any elements are to be parsed
;	   mkVar.flags has one or more of the following bits set:
;	      FVI_COMMON    if input is from a COMMON statement [QB4]
;	      FVI_STATIC    if input is from a STATIC statement
;	      FVI_SHARED    if SHARED keyword associated with var [QB4]
;	      The setting of any other flags in mkVar.flags are unimportant.
;	         (and any other bits for that matter)
;
;	      FVI_ARRAY will be set by if its a reference array id
;	      as opposed to load/store.  This tells MakeVariable that
;	      it is definately not a function.
;
; Exit:
;	If syntax error
;	   returns Carry Set and al=PR_BadSyntax after emitting error msg
;	else returns Carry Clear
;	If FV_SQL then if there is no error bx = oVar of variable emitted [34]
;
;*********************************************************************
FEM_Ary		EQU 1
FEM_AryNoArgs	EQU 2
FEM_AryDim	EQU 4
FEM_ElemOk	EQU 8
MKVAR_STATIC_FLAGS EQU FVI_COMMON + FVI_STATIC + FVI_SHARED
DbPub	EmitVar

cProc EmitVar,<NEAR>,<si,di>
	parmW pTok			
	parmW opBase
	parmB cArgs
	parmB flags
cBegin
	mov	si,[pTok]
	mov	ax,[si.TOK_id_oNam]
	mov	[mkVar.MKVAR_oNam],ax
	mov	ax,[mkVar.MKVAR_flags]	;ax = default flags
	and	ax,MKVAR_STATIC_FLAGS	;preserve these flags in mkVar.flags
	or	ax,[si.TOK_id_vmFlags]	;set token specific flags
					; this may set one or more of FVI_LVAL,
					; FVI_ASCLAUSE
					;ax = default flags for scalars
	test	[flags],FEM_Ary
	je	NotAry1			;brif we're emitting a scalar

	;FVI_INDEXED can be set for array or function references.
	;If this is a VTREF (declarative/GET/PUT/ERASE) opcode,
	;or an lvalue (assign,INPUT,READ) opcode,
	;tell MakeVariable this is an array and not a function by
	;setting FVI_ARRAY
	
if	FVI_INDEXED AND 0FFH		
	or	al,FVI_INDEXED		;[34] set FVI_INDEXED for arrays
else					
	or	ah,FVI_INDEXED / 100H	;set FVI_INDEXED for arrays
endif					
	TESTM	si.TOK_id_vmFlags,FVI_FNNAME	
	jne	NotAry1			;brif reference to DEF FN
	cmp	[opBase],opId_VtRf
	je	ItsAnArray		;brif we sure its an array
	cmp	[cArgs],0
	je	ItsAnArray		;ref like X() can't be function
	TESTM	mkVar.MKVAR_flags,FVI_LVAL	
	je	NotAry1			;brif it may be a function ref
ItsAnArray:
.errnz	FVI_ARRAY AND 0FFH
	or	ah,FVI_ARRAY / 100H
NotAry1:
	mov	[mkVar.MKVAR_flags],ax	;pass flags to MakeVariable
	mov	al,[cArgs]
	mov	[mkVar.MKVAR_cDimensions],al

	mov	ax,[si.TOK_id_oTyp]
	test	[flags],FEM_ElemOk
	je	EvNoElem		;brif ref cannot have elements
.errnz	ET_IMP
	or	ax,ax			;test for ET_IMP
	jne	EvNoElem		;brif ref is explicitly typed
	call	FElements		;try to parse .elem.elem...
					;ax is preserved as ET_IMP
	jne	EvNoElem		;brif variable not followed by "."
	mov	[mkVar.MKVAR_oTyp],UNDEFINED
					;tell MakeVariable to look for
					; record variable
	jmp	SHORT EvBind

;ax = si.TOK_id_oTyp
EvNoElem:
	mov	[mkVar.MKVAR_oTyp],ax
	and	[flags],NOT FEM_ElemOk	;remember id has no .elem after it
EvBind:
	mov	ax,si			;pass pTok in ax
	call	BindVar
	xchg	di,ax			;di = oVar
	test	[flags],FEM_ElemOk
	je	EvNoElem1		;brif didn't get .element
	mov	ax,opIdLd		
	test	[flags],FEM_Ary
	je	EvEmit			;brif scalar
	mov	ax,opAIdLd		
	jmp	SHORT EvEmit

EvNoElem1:
	TESTM	si.TOK_id_vmFlags,FVI_ASCLAUSE	
	je	EvNoAs
	mov	[si.TOK_id_oTyp],ET_IMP	;so DIM A(5) AS INTEGER won't list
					; like DIM A(5)% AS INTEGER

;if mkVar.oTyp is a USER DEFINED TYPE, we need
;to emit a opAIdLd or opAIdSt with no explicit type.
;EmitOpcode( (pTok->dsc.id.oTyp <= ET_MAX) ?
;               opIdLd + opBase + opId_Array | pTok->dsc.id.oTyp << 10 :
;            (opBase == opId_St) ? opAIdSt :
;            (opBase == opId_VtRf) ? opAVtRf : opAIdLd)
;
EvNoAs:
	mov	bx,CPOFFSET twOpIdMap
	mov	cx,opIdLd		
	test	[flags],FEM_Ary
	je	NotAry3			;brif we're emitting a scalar
	mov	bx,CPOFFSET twOpAIdMap
	mov	cx,opId_Array + opIdLd	
NotAry3:
	mov	ax,[opBase]
	mov	dx,[si.TOK_id_oTyp]
	cmp	dx,ET_MAX
	ja	EvUserTyp		;brif user defined type
	add	ax,cx			;ax = opcode to emit 
.errnz OPCODE_MASK - 3FFh		
	shl	dx,1			
	shl	dx,1			
	or	ah,dl			;ax = opcode with high bits set
					;     to the explicit type if any
	jmp	SHORT EvEmit

EvUserTyp:
	call	MapBaseOp		;ax = opcode for opBase in ax
EvEmit:
	call	Emit16_AX		;Emit16(opcode)
	test	[flags],FEM_Ary
	je	NotAry2			;brif we're emitting a scalar
	mov	ax,8000H		;cArgs for ERASE A and friends
					;high-bit tells lister not to list ()
	test	[flags],FEM_AryNoArgs
	jne	EvNotDim		;brif no args, like ERASE A
	mov	al,[cArgs]
	sub	ah,ah			;ax = al = cArgs



	test	[flags],FEM_AryDim
	je	EvNotDim		;brif not DIM array
	;for DIM x(1 TO 2, 2 TO 3), tell scanner that cArgs = 4
	shl	ax,1			;ax = cArgs * 2



EvNotDim:				;brif not DIM array
	call	Emit16_AX		;emit cArgs
NotAry2:
	push	di			;Emit16(oVar)
	call	Emit16
	test	[flags],FEM_ElemOk
	je	EvNoElem2		;brif didn't get .element
	push	[opBase]		;pass EeElements opBase
	call	EmitElements		;parse and emit .elem...
	jmp	SHORT EvExit		;return ax as result

EvNoElem2:
	clc				;return success
EvExit:
cEnd

;*********************************************************************
; STATICF(boolean) EmitElements(ax:opBase)
;	Many modifications during revision [15]
; Purpose:
;	Scan .id[.id...] and emit pcode for construct
;
; Entry:
;	parm1 = opBase = opId_Ld or opId_St or opId_Rf
;	pTokScan points to token for '.'
;	mkVar.oTyp contains the type of the variable
;
; Exit:
;	If syntax error
;	   returns Carry Set and al=PR_BadSyntax after emitting error msg
;	else
;	   returns Carry Clear
;	   pTokScan points beyond end of construct
;
;***********************************************************************
DbPub	EmitElements
cProc	EmitElements,<NEAR>,<si,di>	
	parmW	opBase
cBegin	EmitElements			
EeLoop:
	or	[psFlags],PSIF_fNoPeriod
					;so ScanTok stops at "."
					;get's reset by IdTokNoPeriod
	call	ScanTok			;skip past "." token
	call	IdTokNoPeriod		;check for id token with no period in it
	stc				;prepare to return error
DJMP	jl	EeExit			;brif PR_BadSyntax, carry set

	mov	si,[bx.TOK_id_oNam]	;si = oNam
	mov	di,[bx.TOK_id_oTyp]	;save oTyp in di
	call	ScanTok			;skip id token
	test	[psFlags],PSIF_fBindVars
	je	EeSavTyp		;brif parser not binding variables


	;ask typmgr to convert oNam to oElem
	
	push	si			
	push	di			;pass oTyp so RefElem can test the
					; explicit type if any
	cCall	RefElem 		;ax = oElem (high bit set if error)
;Fix bug where a random error message gets generated for an undefined
;element reference or element type mismatch. Fix this only in QBJ to
;be sure it has no affect on frozen QB4.5.
;Note however that this is thought to be a very safe bug fix.
	mov	si,ax			;save si = oElem
	or	si,si			
	jns	EeSavTyp		;brif no error

	;Either the variable manager hasn't seen this oNam in the variable's
	;TYPE definition or the explicit type conflicted with the actual
	;type.  Tell ParseLine() to return ReParse.
	;We call this instead of PErrMsg_AX so we can continue
	;checking for bad syntax.
	
	and	ah,7Fh			;mask off sign bit. ax = error code
	call	ParseErrTokScan
EeSavTyp:
.errnz	ET_IMP
	or	di,di			;compare di with ET_IMP
	jne	EeNoElem		;brif id is explicitly typed (i.e. id#)
	call	FElements		;check for more record elements
	jne	EeNoElem		;brif didn't get record separator
	mov	ax,opOffLd		
EeEmit:
	call	Emit16_AX		;emit opcode opOffLd
	push	si			;emit oNam/oElem
	call	Emit16
	test	[psFlags],PSIF_fBindVars
	je	EeLoop			;brif parser not binding variables
	mov	ax,[mkvar.MKVAR_oTyp]	;ax = oTyp of last element
					;     (returned by RefElem)
	cmp	ax,ET_MAX_NOFIELDS	;compare it to largest non-fielded
					; 	type
	jbe	EeIdNoPeriod		;brif if not a user defined type
	or	ax,ax			;test the top bit of the oTyp
	jns	EeLoop1 		;if not set we have a user type
EeIdNoPeriod:
	mov	ax,MSG_BadElemRef	;pass error code to ParseErrTokScan
	call	ParseErrTokScan		;As we do for bad element names
					;  we generate a ReParse and 
					;  continue parsing
EeLoop1:				
	jmp	EeLoop	
	
;done with .a.b.c loop
;if mkVar.oTyp is a USER DEFINED TYPE, we need
;to emit a opOffLd, opOffLd or opIdSt with no explicit type.
;EmitOpcode( (oTyp <= ET_MAX) ? opOffLd + opBase + oTyp :
;            (opBase == opId_St) ? opOffSt : opOffLd)
;
;di = ET_IMP or token's explicit type
EeNoElem:
	mov	ax,[opBase]
DbAssertRel	ax,ne,opId_VtRf,CP,<EmitElements: opbase = opId_VtRf>   
DbAssertRel	di,be,ET_MAX,CP,<EmitElements: oTyp is user type>
	add	ax,opOffLd		;ax = opBase + opOffLd
.errnz OPCODE_MASK - 3FFh		
	xchg	ax,di			;di = oTyp, ax = opcode to Emit
	xchg	ah,al			;ah = oTyp
	shl	ax,1			
	shl	ax,1			
	or	ax,di			;ax = opcode with oTyp in high bits
EeEmit2:
	call	Emit16_AX		;emit opOff<Ld|St><Typ>
	xchg	ax,si			;ax = oNam/oElem
	call	Emit16_AX
	clc				;return success
EeExit:
cEnd	EmitElements			

;Tables used to map from opBase to opcodes
twOpBase LABEL WORD			;opBase search table
	dw	opId_St
	dw	opId_Ld
twOpBaseEnd LABEL WORD
CB_OPBASE = twOpBaseEnd - twOpBase

twOpIdMap LABEL WORD
	dw	opIdSt			;opId_St maps to this for scalars
	dw	opVtRf			;opId_Ld maps to this for scalars
	dw	opIdLd			;opId_Rf and opId_VtRf maps to this

twOpAIdMap LABEL WORD
	dw	opAIdSt			;opId_St maps to this for arrays
	dw	opAVtRf			;opId_Ld maps to this for arrays
	dw	opAIdLd			;opId_Rf and opId_VtRf maps to this

;*********************************************************************
; MapBaseOp
; Purpose:
;	Map an opBase (opId_St etc.) to an opcode.
; Entry:
;	ax = value to search for (opId_St etc.)
;	bx = ptr to table of opcodes which cooresponds to twOpBase
; Exit:
;	ax = opcode
;
; Alters ES
;
;*********************************************************************
MapBaseOp PROC NEAR
	mov	dx,CPOFFSET twOpBase
	mov	cx,CB_OPBASE
	jmp	MapCpW			;ax = bx[find[ax,dx,cx]]
MapBaseOp ENDP

	
;*********************************************************************
; ushort NEAR SubRef(oNam)
; Purpose:
;	Map the oNam for a SUB to its oPrs.
; Entry:
;	ax = oNam of subprogram
; Exit:
;	if successful, ax = oPrs, carry clear on exit
;	else ps.errCode is set with error code, carry set on exit
;
;*********************************************************************
cProc	SubRef,<PUBLIC,NEAR>
cBegin
	push	ax			;pass oNam of sub
	PUSHI	ax,PT_SUB
	sub	ax,ax
	push	ax
	call	PrsRef			;ax = error or oPrs
	or	ax,ax
	jns	SubRefGood		;brif no error

	;Don't set PSERR_fAlert flag, wait until ScanTime to report the error
	; since user may have just deleted =B from A=B, which would make
	; A now look like both a variable and an implied call.
	mov	ah,PSERR_fRude / 100h	;set rude edit flag in result
	call	ParseErr0		;report it to ParseLine's caller
	stc				;return error result
	jmp	SHORT SubRefExit

SubRefGood:
	call	UndoLogPrs		;remember to free prs entry if
					; we turn this line into a reparse
					; ax is preserved as oPrs
	clc				;return success
SubRefExit:
cEnd

;*********************************************************************
; STATICF(PARSE_RESULT) NtConsumeExp()
;
; Purpose:
;	Parse an expression.
;	If successfully parsed, return PR_GoodSyntax.
;	If one is not found, report error and return PR_BadSyntax.
;	If expression had bad syntax, return PR_BadSyntax.
;	In other words, identical to NtExp(), but it won't take
;	   PR_NotFound for an answer.
; Exit:
;	al = PR_GoodSyntax or PR_BadSyntax, condition codes set accordingly
;
;*********************************************************************
PUBLIC	NtConsumeExp
NtConsumeExp PROC NEAR
	call	NtExp
	je	PErrExpExpr		;brif result == PR_NotFound
					; error "Expected expression"
					; al = PR_BadSyntax
	ret
NtConsumeExp ENDP

;*********************************************************************
; PARSE_RESULT NEAR PErrExpExpr()
;
; Purpose:
;	generate error "Expected expression" and return PR_BadSyntax
; Exit:
;	al = PR_BadSyntax
;
;*********************************************************************
PUBLIC	PErrExpExpr
PErrExpExpr PROC NEAR
	mov	ax,MSG_ExpExp
	jmp	PErrExpMsg_AX		;Error "Expected expression"
					; al = PR_BadSyntax
PErrExpExpr ENDP

;*********************************************************************
; NtExprOrArg()
; 
; Purpose:
;	Parse an expression or an arg based on the value in ax
; Entry:
;	ax is tested for the flag
;	    NTEL_ARGS: if set allow SEG, BYVAL and A() args
;			        otherwise only allow a normal expression
; Exit:
;	same as NtArg
;	
;*********************************************************************
NtExprOrArg PROC
	test	ax,NTEL_ARGS
	jnz	NtArg
	call	NtExp
	mov	dx,0
	ret
NtExprOrArg ENDP

;*********************************************************************
; ExpRParenLastToken
; Purpose:
;	generate the error "expected ')'" referring to the last token
;	consumed
; Exit:
;	al = PR_BadSyntax
;*********************************************************************
ExpRParenLastToken PROC NEAR
	mov	ax,[pTokLastConsumed]	
	mov	[pTokScan],ax		;reset pTokScan to point to ","
					; so it will be highlighted
	mov	ax,IRW_RPAREN		
	jmp	PErrExpRw_Ax		;generated "expected ')'"
ExpRParenLastToken ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdCallArg()
;
; Purpose:
;	Try to parse an identifier of the form:
;	   "[BYVAL | SEG] id[([exp[,exp...]])]"
;	This can occur in the following statements:
;	   tkCALL IdSub [tkLParen IdCallArg {tkComma IdCallArg} tkRParen]
;	Tests to ensure that we haven't yet reached the maximum number
;	of args before branching into 
;
;*********************************************************************
PUBLIC	NtIdCallArg
NtIdCallArg PROC NEAR
	cmp	[cIdArgs],MAXARG
	jae	ExpRParenLastToken	;BASCOM can't handle more than 60
					; args, so we shouldn't either
; fall into NtArg
NtIdCallArg ENDP

;*********************************************************************
; STATICF(PARSE_RESULT) NtArg()
;
; Purpose:
;	Parse and generate code for:
;	   [BYVAL | SEG] expression or
;	   array reference of the form x()
;	Emit the following pcode:
;	   [opByval | opSeg] <expression's pcode>
;	   opAIdRfxx(oVar,0)
;	NOTE: BYVAL x() is illegal because it makes no sense
;	      SEG x() is illegal because we don't want to document
;	              the format of array descriptors to outside world.
; Exit:
;	Returns al = PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;	If result is PR_GoodSyntax, bumps cIdArgs by 1, no matter what
;	   recursion takes place and returns
;	   dx = NTEL_ARGS if SEG, BYVAL, or array ref of form x() seen
;		0 otherwise
;
;*********************************************************************
cProc	NtArg,<NEAR,PUBLIC>,<di>
cBegin
	push	[cIdArgs]
	mov	ax,IRW_Byval
	call	TestScan_AX		;see if current token is BYVAL
					;bx points to current token
	.erre	opByval
	mov	di,opByval
	je	GotByvalSeg		;brif got BYVAL keyword
	sub	di,di			;assume no SEG
	mov	ax,IRW_Seg
	call	TestScan_AX		;see if current token is SEG
					;bx points to current token
	jne	NoByvalSeg		;brif didn't get SEG keyword
	mov	di,opSeg
	.erre	opSeg

GotByvalSeg:
	call	ScanTok			;skip BYVAL or SEG token
					;bx points to current token

;di = 0 for no SEG or BYVAL, opByval for BYVAL, opSeg for SEG
;bx points to current token
NoByvalSeg:
	or	di,di
	jne	NotAryArg		;can't have arg of form 'BYVAL A()'
					; or 'SEG A()'
	cmp	[bx.TOK_class],CL_ID
	jne	NotAryArg		;brif token isn't an id
	call	Peek1Tok		;see if its an array ref of the form x()
	mov	ax,IRW_LParen
	call	TestPeek_AX
	jne	NotAryArg		;brif not '('
	call	PeekNextTok
	mov	ax,IRW_RParen
	call	TestPeek_AX
	jne	NotAryArg		;brif not ')'

	;we did get an array reference of the form x()
	;if (!EmitVar(pTokScan, opId_VtRf, 0, FALSE)) return PR_BadSyntax
	
	push	[pTokScan]		;pass pointer to id's token
	PUSHI	ax,opId_Ld		;make opcode a Ld variant
	PUSHI	ax,0			;pass cArgs == 0
	PUSHI	ax,FEM_Ary		;let EmitVar know its an array ref
	call	EmitVar
	jc	NtArgExit		;brif unsuccessful (al = PR_BadSyntax)
	call	ScanTok			;skip id
	call	ScanTok			;skip '('
	call	ScanTok			;skip ')'
	jmp	SHORT ItsAnArg		

NotAryArg:
	or	di,di
	je	MaybeExp		;brif no tokens consumed yet
	call	NtConsumeExp		;error if can't consume an expression
	jle	NtArgExit		;brif result != PR_GoodSyntax
EmitByvalSeg:
	or	di,di
	je	NtArgGood		;brif no BYVAL or SEG parm
	push	di
	call	Emit16			;emit opByval or opSeg
ItsAnArg:
NtArgGood:
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
	jmp	SHORT NtArgExit

MaybeExp:
	call	NtExp			;consume expression, al = result
NtArgExit:
	pop	dx			;dx = caller's cIdArgs
	inc	dx
	or	al,al			;set condition codes for caller
	jle	NtArgExit1		;brif result != PR_GoodSyntax
	mov	[cIdArgs],dx		;bump cIdArgs
NtArgExit1:
cEnd

;*********************************************************************
; NtExprList
;	Completely rewritten during revision [15]
; Purpose:
;	Parse and generate code for 
;		(expr1, expr2, ..., exprN)
;	Each of these expressions can be:
;	-  An expression
;	-  A scalar or array element
;
;	Called by NtImpliedLetOrCall and EmitElements.
;
;
; Exit:
;	Returns ax = PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;	condition codes set based on value in [al]
;	cx = number of args scanned. 0 if no "(" found.
;if NOT FV_QB4LANG
;	NtELFlags contains output flags
;		NTEL_ARGS is set if an arg of the form x(), or
;				SEG x, or BYVAL x is seen
;if     FV_ARYELEM
;		NTEL_STOPONTO is set if TO was encountered
;endif ;FV_ARYELEM
;endif ;NOT FV_QB4LANG
;
;*********************************************************************
DbPub	NtExprList
cProc	NtExprList,<NEAR>,<di>
cBegin
	xor	di,di			;initialize arg count to 0
	mov	ax,IRW_LPAREN
	call	TryScan_AX		;consume "(" if present
	mov	ax,PR_NotFound		;assume "(" not found
	jne	NoArrayArg		;brif "(" not found

NtELLoop:
	call	NtExp			
	jg	NtELGotArg		;brif result is PR_GoodSyntax
	jl	NtELBadSyn		;brif result is PR_BadSyntax
	call	PErrExpExpr		;error "Expected expression"
	jmp	SHORT NtELBadSyn
NtELGotArg:
	inc	di			;bump arg count
.erre	MAXARG EQ MAXDIM		;since NtExprList used for parsing
					; both arg list Call-Less call w/
					; parens and array on lhs of assgn
	cmp	di,MAXARG		
	jae	ConsumeRParen		
	mov	ax,IRW_Comma
	call	TryScan_AX		;try to consume a ","
	je	NtELLoop		;if "," found then repeat loop


ConsumeRParen:
	mov	ax,IRW_RPAREN
	call	ConsumeRw_AX		;consume ")" if present
	jc	NtELBadSyn		;brif not found al = PR_BadSyntax
	mov	al,PR_GoodSyntax	;found it --- return PR_GoodSyntax
	
NoArrayArg:
	mov	cx,di			;return cx = arg count
NtELBadSyn:
	or	al,al			;set condition codes for caller
cEnd

;*********************************************************************
; EnsRude
; Purpose:
;	This is called by parser non-terminals that require current
;	text table to be in SS_RUDE state.  If current table isn't
;	an error is generated that will force ParseLine's caller
;	to descan to SS_RUDE.
;	The reason we need to retry the call to ParseLine after
;	calling AskRudeEdit is because the pcode already emitted for this
;	line could have been emitted in SS_PARSE, and the pcode for
;	the rest of the line would be emitted in SS_RUDE.
; Exit:
;	if already in SS_RUDE
;	   Condition codes = Z
;	else
;	   Condition codes = NZ
;	   Either PSF_UndoEdit or PSF_fRetry bits are set in ps.flags
;	
;*********************************************************************
EnsRude PROC NEAR
	cmp	[txdCur.TXD_scanState],SS_RUDE
	je	AlreadyRude		;brif scan-state = SS_RUDE

	call	ParseUndo		;We must call this before ModuleRudeEdit
					; or else we will try to free some
					; DEF FN prs's which no-longer exist
	call	AskRudeEdit		;see if user wants to back out of edit
	mov	al,PSF_UndoEdit
	je	ErBackOut		;brif user wants to back out
	mov	al,PSF_fRetry		;tell caller to call ParseLine again
ErBackOut:
	or	[ps.PS_flags],al
	mov	ax,ER_IER
	call	ParseErr0		;stop's subsequent calls to MakeVariable
	or	al,al			;set nz condition codes
AlreadyRude:
	ret
EnsRude	ENDP


;*=========================================================================
;*    I D    R E L A T E D    N O N - T E R M I N A L    F U N C T I O N S
;*
;*    NOTE:  These functions are arranged alphabetically
;*
;*=========================================================================

;*********************************************************************
; PARSE_RESULT NEAR NtACTIONidCommon()
; Purpose:
;	Remember that subsequent ids in this statement have this attribute.
;	This occurs in the following statement:
;	   COMMON [/id/] ACTIONidCommon ...
;
;*********************************************************************
PUBLIC NtACTIONidCommon
NtACTIONidCommon PROC NEAR
	call	EnsRude
	mov	ax,FVI_COMMON
	jmp	SHORT SetIdMask
NTACTIONidCommon ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtACTIONidShared()
; Purpose:
;	Remember that subsequent ids in this statement have this attribute.
;	This occurs in the following statement:
;	   SHARED ACTIONidShared IdAry {tkComma IdAry}
;
;*********************************************************************
PUBLIC NtACTIONidShared
NtACTIONidShared PROC NEAR
	mov	ax,FVI_SHARED
	jmp	SHORT SetIdMask
NTACTIONidShared ENDP



;*********************************************************************
; PARSE_RESULT NEAR NtACTIONidStatic()
; Purpose:
;	Remember that subsequent ids in this statement have this attribute.
;	This occurs in the following statement:
;	   STATIC ACTIONidStatic IdAryI {tkComma IdAryI}
;
;*********************************************************************

;*********************************************************************
; STATICF(PARSE_RESULT) SetIdMask(mask)
;
; Purpose:
;	Set one or more of the following flags into mkVar.flags:
;	   FVI_COMMON    if input is from a COMMON statement [QB4]
;	   FVI_STATIC    if input is from a STATIC statement
;	   FVI_SHARED    if SHARED keyword associated with var [QB4]
;
; NOTE:  NtExp() preserves the value of mkVar.flags and
;	      sets it to 0 for all id's encountered within the expression
;
;*********************************************************************
PUBLIC NtACTIONidStatic
NtACTIONidStatic PROC NEAR
	mov	ax,FVI_STATIC
NTACTIONidStatic ENDP
	;fall into SetIdMask
SetIdMask PROC NEAR
	or	[mkVar.MKVAR_flags],ax
RetGoodSyntax:
	mov	al,PR_GoodSyntax
	ret
SetIdMask ENDP


;*********************************************************************
; PARSE_RESULT NEAR NtAsClause(al=flags, bx=pTokId)
; Purpose:
;	Parse AS (ANY | INTEGER | LONG | SINGLE | DOUBLE | STRING * n | id)
;
; Entry:
;	al = flags, set as follows:
;	     FAS_fNoVarLenStr if no var length STRING syntax is allowed
;		(this flag is ignored if FV_FARSTR is true)
;	     FAS_fNoFixLenStr if no fixed length STRING/TEXT syntax is allowed
;	     FAS_fAllowAny if AS ANY or AS FIELD (EB) is allowed
;	     FAS_fDontBind if we're not to call RefType(x) for
;	       id as x  (set if AS clause is seen inside TYPE/END TYPE block)
;	     FAS_fDontSetONam if we're not to set FOO's NM_fAs [QB4]
;	       bit if we see FOO AS BAR.  Setting this bit prevents any
;	       variables/constants/procedures named FOO.xxx
;	     FAS_fNoUserType if AS <userType> is not allowed and
;				FORMs not allowed (EB).
;	     FAS_fField if As Field allowed (EB)
;	bx = pTokId points to token for variable (i.e. to FOO for case
;	     FOO AS BAR)
;	pTokScan points to AS token
;	If RefTyp is not to be called for this variable, pTokId = NULL
;
; Exit:
;	If good syntax, emits the following pcode and returns PR_GoodSyntax:
;	  AS ANY ==> opAsTypeExp(ET_IMP,column)
;	  AS INTEGER ==> opAsTypeExp(ET_I2,column)
;	  AS LONG ==> opAsTypeExp(ET_I4,column)
;	  AS SINGLE ==> opAsTypeExp(ET_R4,column)
;	  AS DOUBLE ==> opAsTypeExp(ET_R8,column)
;	  AS STRING ==> opAsTypeExp(ET_SD,column)
;	  AS STRING * nn ==> opAsTypeFixed(0x8000 + ET_SD, nn, column)
;	     (only valid if fInType is TRUE)
;	  AS STRING * <symbolic const> ==> 
;			opAsTypeExp(0x8000 + ET_SD,oNam,column)
;	     (only valid if fInType is TRUE)
;	  AS CURRENCY (if FV_CURRENCY)  ==> opAsTypeExp(ET_Cy,column)
;	  AS TEXT (if EB) ==> opAsTypeExp(ET_Tx,column)
;	  AS FORM <command equivalent> (if EB) ==> opCmdAsType(iCe , column)
;	  AS <id> ==> opAsType(<oNam for id>,column)
;	  if pTokId is not NULL, pTokId->id.oTyp = oTyp from AS clause
;
;	Else returns PR_NotFound or PR_BadSyntax
;	Condition codes set based on result in al
;
;*********************************************************************
FAS_fNoVarLenStr	EQU 01h
FAS_fAllowAny		EQU 02h
FAS_fDontBind		EQU 04h
FAS_fDontSetONam	EQU 08h
FAS_fNoFixLenStr	EQU 10h
FAS_fNoUserType		EQU 20h

PUBLIC	NtAsClause	;for debugging
cProc	NtAsClause,<NEAR>,<si,di>
	localB	flags
	localW	columnAs		;source column where AS occurred
	;register si = pTokId
	;register di = oTyp
cBegin
	mov	[flags],al
	mov	si,bx			;si = pTokId
	mov	ax,IRW_AS
	call	TestScan_AX
	mov	al,PR_NotFound		;prepare to return NotFound
	jne	J1_NtAsExit		;brif current token isn't 'AS'
	mov	ax,[bx.TOK_oSrc]	;ax = column for AS
	mov	[columnAs],ax
	call	ScanTok			;consume 'AS' token


	mov	ax,STI_AsClausePrim + OFFSET CP:tState
	test	[flags],FAS_fNoUserType
	jne	CallParse		;brif AS <userType> not allowed
	mov	ax,STI_AsClauseAny + OFFSET CP:tState ;parse AS <type>
	test	[flags],FAS_fAllowAny
	jne	CallParse		;brif AS ANY not allowed
	mov	ax,STI_AsClause + OFFSET CP:tState ;parse AS <type | userType>
CallParse:
	mov	[pStateLastScan],ax	;setup for call to PErrState below
	call	NtParse			;al = parse result for AS <clause>
	jg	GoodAs			;brif good syntax
	jl	J1_NtAsExit		;brif bad syntax -- only occurs if 
					; user defined types are allowed and
					; an invalid identifier was encountered
	call	PErrState		;output 'expected INTEGER, SINGLE, ...
					; based on pStateLastScan above
					;al = PR_BadSyntax
J1_NtAsExit:
	jmp	NtAsExit		;brif NtParse=PR_BadSyntax/PR_NotFound

;Pcode emitted by NtParse(AsClause) is:
; opAsType(oTyp)
; opAsTypeExp(ET_I2)
;   :
; opAsTypeExp(ET_SD)
;
GoodAs:
	call	RudeIfErr		;if this line gets any kind of error,
					; we will descan to ss-rude.  First,
					; ask user if he wants to back out of
					; edit for Edit & Continue.
	cmp	[si.TOK_id_oTyp],ET_IMP
	je	NotAsExplicitId		;brif not implicit id
; Got As Explicit Id
	mov	bx,[pTokScan]
	mov	ax,[si.TOK_oSrc]	;ax = column id began in
	mov	[bx.TOK_oSrc],ax	;set field used by PErrMsg
	mov	ax,MSG_IdImp		;error: id can't end with $!#&%
	jmp	NtAsErrMsg

NotAsExplicitId:
	mov	bx,[ps.PS_bdpDst.BDP_pbCur]
	mov	di,[bx-2]		;di = oTyp or oNam from AS clause
	cmp	WORD PTR [bx-4],opAsType 
	jne	NtAsNotUser		;brif didn't get id AS <user type>
					; may have been id AS INTEGER
					; or id AS ANY

;Got user type like FOO AS BAR
;di = oNam for BAR, not oTyp
;Set namtbl bit NM_fAS for x, so lexer knows all future references to A.B
; are 3 tokens.
;
	test	[flags],FAS_fDontSetONam
	jne	DontSetAsBit
	mov	al,MSG_BadElemRef	;identifier cannot have "."
	test	[si.TOK_id_lexFlags],FLX_hasPeriod
	jne	NtAsErrSiAl		;brif id.anything AS <usertype>

	mov	al,PUNDO_oNamAs		;pass entry type in al
	mov	dx,[si.TOK_id_oNam]	;pass oNam in dx
	call	ParseUndoLog		;remember to undo SetONamMask if
					; we turn this line into a reparse

	push	[si.TOK_id_oNam]	;pass oNam
	PUSHI	ax,NM_fAS		;pass mask for bit to be set
	call	SetONamMask		;set flag, dl=old value of flag
	test	dl,NM_fAS
	jne	DontSetAsBit		;brif bit was already set, no change
	or	[mrsCur.MRS_flags],FM_asChg
					;causes PreScanAsChg before scanning
					;to convert any A.B id references
					;into record elements
DontSetAsBit:
	test	[flags],FAS_fDontBind
	jne	J1_NtAsEnd		;brif no need to call RefTyp
	test	[psFlags],PSIF_fBindVars
	je	J1_NtAsEnd		;brif parser not binding variables

	mov	ax,[ps.PS_otxLine]	;pass source offset of reference
	mov	dx,UNDEFINED
	;can't test [txdCur.TXD_flags],FTX_mrs because prs's text table
	; isn't created until after parsing "SUB id(x AS foo)" line
	
	cmp	[grs.GRS_oPrsCur],dx
	je	NotInSubOrFunc		;brif ref isn't in SUB/FUNCTION
	cmp	[prsCur.PRS_procType],PT_DEFFN
	je	NotInSubOrFunc		;brif ref is in DEF FN
	xchg	ax,dx			;ax = UNDEFINED, because all
					; TYPEs are defined at module level,
					; so are available to any SUB/FUNCTION
NotInSubOrFunc:
	push	di			;pass oNam to RefType
	push	ax			;pass otx to RefType
	call	RefTyp			;ask type mgr for oTyp of AS id
	mov	di,ax			;di = ax = oTyp
	or	ax,ax
	jns	J1_NtAsEnd		;brif no error
;si = id token ptr, al = error code
NtAsErrSiAl:
	sub	ah,ah			;low byte has QBI Std Error Code
	mov	bx,si
	call	ParseErr		;ParseErr(ax,bx)

J1_NtAsEnd:
	jmp	SHORT NtAsEnd	

;Got explicit type like AS INTEGER or AS ANY
NtAsNotUser:
	cmp	di,ET_SD
	jne	NtAsEnd			;brif not STRING in TYPE stmt
NtAsTestFlags:
	test	[flags],FAS_fNoFixLenStr
	jne	NtAsEnd			;brif can't accept fixed len string
	test	[flags],FAS_fNoVarLenStr
	jne	GetFixed		;brif can't accept var len string

	;We can accept either fixed length, or variable length string syntax
	mov	ax,IRW_Mult		;Consume "* const" clause
	call	TestScan_AX
	jne	NtAsEnd			;brif didn't get * (fixed len string)
GetFixed:
	mov	ax,IRW_Mult		;Consume "*"
	call	ConsumeRw_AX
	jc	NtAsExit		;brif syntax error (al = PR_BadSyntax)
	add	di,ET_FS-ET_SD		;Convert oTyp to fixed variant
	call	IdTok			;bx points to current token
	jne	NotSymConst		;brif its not an id token
	push	[bx.TOK_id_oNam]	;preserve oNam
	call	ScanTok			;consume symbolic constant's token
	pop	ax			;ax = oNam of symbolic constant
	mov	bx,[ps.PS_bdpDst.BDP_pbCur]
	mov	dx,di			;dx = oTyp
	or	dh,80h			;set high bit of oTyp to store
					;  in pcode
	;set flag so we can tell MakeVariable that fsLength is oNam
	; of symbolic constant.
	
	or	[si.TOK_id_lexFlags],FLX_asSymConst

	jmp	SHORT UpdatePcode
NotSymConst:
	call	NtLitI2NoCode		;consume integer (if any)
					;bx points to I2 value in pcode buf
	jl	NtAsExit		;brif PR_BadSyntax
	je	NtAsSnErr		;brif PR_NotFound
	mov	ax,[bx]			;ax = string length
	or	ax,ax			
	jnz	GotGoodLen		;brif string length is > zero
	mov	ax,MSG_IllegalNumber	
	call	PErrPrevTok_Ax		
	jmp	SHORT NtAsExit
GotGoodLen:
	mov	dx,di			;dx = oTyp
UpdatePcode:
	mov	[bx-2],dx		;replace the old oTyp operand in pcode
	mov	dx,opAsTypeFixed	;change opcode from opAsTypeExp to
	mov	[bx-4],dx		;  opAsType2

.errnz MKVAR_fsLength - MKVAR_oNamForm	
NtAsEmitExtraOperand:
	mov	[mkvar.MKVAR_fsLength],ax ;oNam/cb passed to makevariable
	call	Emit16_Ax		;emit number of bytes or oNam
					; of constant which gives # of bytes
NtAsEnd:
	mov	ax,[columnAs]		
	call	Emit16_AX		;emit column operand
	mov	[si.TOK_id_oTyp],di	;set the variable's oTyp
	or	[si.TOK_id_vmFlags],FVI_ASCLAUSE
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
NtAsExit:
	or	al,al			;set condition codes for caller
cEnd

NtAsSnErr:
	mov	ax,ER_SN		;Syntax Error
NtAsErrMsg:
	call	PErrMsg_AX		;al = PR_BadSyntax
	jmp	SHORT NtAsExit		;return PR_BadSyntax


;*********************************************************************
; NtLitI2NoCode
; Purpose:
;	Parse a signed integer
; Exit:
;	If successfully parsed,
;	   no pcode is emitted, but value is stored beyond end
;	      of pcode buffer,
;	   bx points to value,
;	   al = PR_GoodSyntax
;	else
;	   al = PR_NotFound or PR_BadSyntax
;	Condition codes are set based on value in al
;
;*********************************************************************
NtLitI2NoCode PROC NEAR
	call	NtLitI2			;consume integer, emit 2 byte value
	jle	NoI2			;brif no integer found, or snerr
	sub	[ps.PS_bdpDst.BDP_cbLogical],2 ;eliminate pcode emitted by NtLitI2
	mov	bx,[ps.PS_bdpDst.BDP_pbCur] ;bx points beyond emitted value
	dec	bx			;pbCur -= 2
	dec	bx
	mov	[ps.PS_bdpDst.BDP_pbCur],bx
	or	al,al			;set condition codes for caller
NoI2:
	ret
NtLitI2NoCode ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAry()
;
; Purpose:
;	Try to parse a scalar or array id of the form: id [()] [AS <type>]
;	This can occur in the following statements:
;	   SHARED IdAry {tkComma IdAry}
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAry
NtIdAry	PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_VTREF OR IDM_AS
	jmp	SHORT NtId
NtIdAry	ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryElem()
;
; Purpose:
;	Try to parse a scalar or array element of the form:
;	   id[<type>] [(exp, ... )] [.id[.id...]]
;	This can occur in the following statements:
;	   FIELD #n, 15 AS IdAryElem, 20 as IdAryElem [QB4]
;	   MID$ (IdAryElem, 5, 3) = exp
;	   LSET IdAryElem = exp
;	   RSET IdAryElem = exp
;	   NtExp() calls this for any id's encountered within expressions
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryElem
NtIdAryElem PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_EXP OR IDM_ARGS OR IDM_ELEM
	jmp	SHORT NtId
NtIdAryElem ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryElemRef()
;
; Purpose:
;	Try to parse a scalar or array element of the form:
;	   id[<type>] [(exp, ... )]
;	and emit a Rf Id opcode.
;	This can occur in the following statements:
;	   INPUT IdAryElem
;	   LINE INPUT IdAryElem
;	   READ IdAryElem
;	   y = VARPTR(IdAryElem)
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryElemRef
NtIdAryElemRef PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_EXP OR IDM_REF OR IDM_ELEM
	jmp	SHORT NtId
NtIdAryElemRef ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryGetPut()
;
; Purpose:
;	Try to parse a scalar or array element of the form:
;	   id[<type>] [(exp, ... )]
;	This can occur in the following statements:
;	   GET (10,10)-(20,20),IdAryGetPut
;	   PUT (10,10),IdAryGetPut
;	   PALETTE USING IdAryGetPut
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryGetPut
NtIdAryGetPut PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_EXP OR IDM_ARRAY	
	jmp	SHORT NtId
NtIdAryGetPut ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryI()
;
; Purpose:
;	Try to parse a scalar or array id of the form:
;	   id [([<integer>])] [AS <type>]
;	This can occur in the following statement:
;	   STATIC IdAryI {tkComma IdAryI}
;	   COMMON [SHARED] [/id/] IdAryI {tkComma IdAryI} [QB4]
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryDim2
NtIdAryDim2	LABEL	NEAR



PUBLIC	NtIdAryI
NtIdAryI PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_CONST OR IDM_VTREF OR IDM_AS
	jmp	SHORT NtId
NtIdAryI ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdArray()
;	Parse an identifier of the form:   "id"
;	This can occur in the following statements:
;	   ERASE IdArray {tkComma IdArray}
;	   PALETTE [USING IdArray]...
;
;*********************************************************************
PUBLIC	NtIdArray
NtIdArray PROC NEAR
	mov	ax,IDM_ARRAY		
	jmp	SHORT NtId
NtIdArray ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdFor()
;
; Purpose:
;	Try to parse an identifier of the form:  id [<type>]
;	This can occur in the following statements:
;	   FOR IdFor ...
;	   NEXT IdFor ...
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdFor
NtIdFor PROC NEAR
	mov	ax,IDM_REF
	jmp	SHORT NtId
NtIdFor ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtId(ax:mask)
;
; Purpose:
;	Try to parse an id.  The legal format of the ID depends on the bits
;	set in the input parameter 'mask'.
;
; Entry:
;	If the static variable [oNamConstPs] is non-zero, variables which
;	   are not CONSTANT are not allowed
;	ax:mask's bits have the following meanings:
;	   If no bits in mask are set, the only syntax allowed is ID
;	   IDM_INDEXED: ID can be (but need not be) followed by ()
;	      IDM_CONST: (<integer constant>) can (but need not) follow ID
;	      IDM_EXP: exp [,...] must follow ID( if ( is seen
;	      IDM_OEXP: exp [,...] can (but need not) follow ID( if ( is seen
;	         IDM_DIM: each exp can be followed by [TO exp]
;	         IDM_ARGS: each exp can be preceded by BYVAL or SEG
;	            and each exp can be of the form id() or a normal expression
;	   IDM_ARRAY: an array id opcode is emitted even if no
;	      indecies are seen
;	   IDM_AS: id can be followed by [AS id]
;	   IDM_ELEM: id can be followed by [.id[.id...]]
;	   By default, either opIdLd... or opAIdSt... is emitted
;	   IDM_REF : causes opIdRf... or opAIdRf... to be emitted
;	   IDM_VTREF : causes opIdVtRf... or opAIdVtRf... to be emitted
;
;	For example:
;	   SHARED IdAry : IDM_INDEXED | IDM_AS [QB4]
;	   STATIC IdAryI : IDM_INDEXED | IDM_CONST | IDM_AS
;	   ERASE IdArray : IDM_ARRAY
;	   DIM IdAryDim : IDM_INDEXED | IDM_EXP | IDM_DIM | IDM_VTREF | IDM_AS
;	   PUT (10,20),IdAryGetPut : IDM_INDEXED | IDM_EXP | IDM_ARRAY
;	   FOR IdFor : IDM_REF
;	   INPUT IdAryElemRef : IDM_INDEXED | IDM_EXP | IDM_REF | IDM_ELEM
;	   NtExp() calls NtIdAryElem, which calls NtId with :
;	      IDM_INDEXED | IDM_EXP | IDM_ARGS
;
; Exit:
;	If id was indexed, fLastIdIndexed is TRUE, else it is FALSE
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax in al.
;	Condition codes set based on value in al
;	If result is PR_GoodSyntax, bumps cIdArgs by 1, no matter what
;	   recursion takes place
;	For FV_SQL bx = oVar of emitted variable if variable ref was emitted.
;
;*********************************************************************

;word masks for 'flags'
IDM_INDEXED  EQU 0001H
IDM_CONST    EQU 0002H
IDM_EXP      EQU 0004H
IDM_OEXP     EQU 0008H
IDM_ARGS     EQU 0010H
IDM_DIM      EQU 0020H
IDM_ARRAY    EQU 0040H
IDM_REF      EQU 0080H
IDM_VTREF    EQU 0100H
IDM_ELEM     EQU 0200H
IDM_AS       EQU 0400H
IDM_NOSCALAR EQU 0800H	

;low-byte masks
IDM1_INDEXED  EQU 01H
IDM1_CONST    EQU 02H
IDM1_EXP      EQU 04H
IDM1_OEXP     EQU 08H
IDM1_ARGS     EQU 10H
IDM1_DIM      EQU 20H
IDM1_ARRAY    EQU 40H
IDM1_REF      EQU 80H

;high-byte masks
IDM2_VTREF    EQU 01H
IDM2_ELEM     EQU 02H
IDM2_AS       EQU 04H
IDM2_NOSCALAR EQU 08H	

cProc	NtId,<PUBLIC,NEAR>,<si,di>
	localW	maskW
	maskLO  EQU BYTE PTR (maskW)
	maskHI  EQU BYTE PTR (maskW+1)
	localV	tokId,%(size TOK)
	localW	opBase
	localW	flags
	flagsLO  EQU BYTE PTR (flags)
;Register usage:  di = oDstExp, si = cArgs
cBegin
	push	[cIdArgs]		;save caller's cIdArgs
	mov	[maskW],ax
	sub	al,al			;prepare to return PR_NotFound
	call	IdTok			;bx points to current token
	je	GotId			;brif its an id token
	jmp	NtIdExit		;brif not an id
GotId:
.erre opId_Ld EQ 0
	xor	ax,ax			;ax = opId_Ld
	test	[maskLO],IDM1_REF
	je	NotRefId		;brif not a REFERENCE id
	mov	ax,opId_Rf
	jmp	SHORT SetOpBase
NotRefId:
	test	[maskHI],IDM2_VTREF
	je	SetOpBase		;brif not a VarTab REFERENCE id
	mov	ax,opId_VtRf

;ax = opId_xxx (which class of opId to emit)
SetOpBase:
	mov	[opBase],ax
	;save important information about this token id.
	lea	bx,tokId
	call	CopyTokScanBx		;copy token [pTokScan] to [bx], ScanTok
					; using NtACTIONidDim
	test	[maskLO],IDM1_DIM
	je	NotDim			;brif id is not in DIM stmt
	;var mgr reports duplicate defn for DIM A: DIM A or DIM FNA
	or	[tokId.TOK_id_vmFlags],FVI_DIM
NotDim:
	sub	dx,dx			;default value for flags
	mov	al,[maskHI]
	and	al,IDM2_ELEM		;al = non-zero if .elem can follow id
	je	NoElem
	or	dl,FEM_ElemOk		;tell EmitVar that .elem is ok
NoElem:
	mov	[flags],dx
	test	[maskLO],IDM1_INDEXED
	je	NotIndexed		;brif (...) cannot follow id
	mov	ax,IRW_LParen
	call	TestScan_AX
	jne	TestNoScalar		
DJMP	jmp	SHORT IndexedId		; brif got an indexed id
TestNoScalar:				
	test	[maskHI],IDM2_NOSCALAR	
	jz	NotIndexed		
	mov	ax,IRW_LParen		
	call	PErrExpRw_Ax		
	jmp	SHORT J1_NtIdSnErr	
NotIndexed:
	test	[maskLO],IDM1_ARRAY
	je	NotUnindexedArray

	;got unindexed array reference like ERASE A
	lea	ax,[tokId]
	push	ax			;pass pointer to id's token
	push	[opBase]		;load/store/ref/vtref indicator
	PUSHI	ax,0			;arg count
	or	[flagsLO],FEM_Ary OR FEM_AryNoArgs
	push	[flags]
	call	EmitVar			;emit array id opcode
	jmp	SHORT ChkResult

;got scalar id reference
NotUnindexedArray:
	test	[maskHI],IDM2_AS
	je	NotAsScalar		;brif AS <type> is not allowed here
	sub	ax,ax
	lea	bx,[tokId]
	call	NtAsClause		;parse "AS <type>" clause
	jl	J1_NtIdSnErr		;brif result == PR_BadSyntax
NotAsScalar:
	mov	ax,[tokId.TOK_id_oNam]
	cmp	ax,[oNamConstPs]
	je	BadConst		;brif self-referencial CONST x=x
					; this is needed in case we're in
					; a procedure, and there is a global
					; level CONST x=n stmt.
	lea	ax,[tokId]
	push	ax			;pass ptr to token's id
	push	[opBase]		;load/store/ref indicator
	PUSHI	ax,0			;cArgs = 0
	push	[flags]
	call	EmitVar			;emit a scalar id opcode

;condition codes = result of calling EmitVar
ChkResult:
	jc	J1_NtIdSnErr		;brif bad syntax
	mov	[fLastIdIndexed],FALSE	;tell caller last id was not indexed
	cmp	[oNamConstPs],0
	je	J1_NtIdEnd		;brif not in CONST a=<expression> stmt
	test	[psFlags],PSIF_fBindVars
	je	J1_NtIdEnd		;brif parser not binding variables
					;rude scanner will check for this error
	TESTM	mkVar.MKVAR_flags2,MV_fConstFound	
	jne	J1_NtIdEnd		;brif CONST id = constant
					;else got CONST id = variable
BadConst:
	mov	ax,MSG_InvConst		;Error: Invalid Constant
	call	PErrMsg_AX		; al = PR_BadSyntax
J1_NtIdSnErr:
	jmp	SHORT J2_NtIdSnErr

J1_NtIdEnd:
	jmp	NtIdEnd

;got an indexed id
IndexedId:
	cmp	[oNamConstPs],0
	jne	BadConst		;brif in CONST a=<expression> stmt
					;can't have CONST a=z(i)
	or	[flagsLO],FEM_Ary	;tell EmitVar this is an array/func
	sub	si,si			;cArgs = 0
	call	ScanTok			;skip past left paren

	;Now that we've consumed at least 1 token, we can only return
	;PR_GoodSyntax or PR_BadSyntax
	
	test	[maskLO],IDM1_CONST
	je	NoOptConst		;brif not looking for X(literal) syntax
					; like COMMON x(3) [QB5] or STATIC x(2)
	call	NtLitI2NoCode		;scan optional integer (ignore value)
	jl	J2_NtIdSnErr		;brif result == PR_BadSyntax
NtIdNoArg:
DJMP	jmp	SHORT NtIdGetRParen	

NoOptConst:
	TESTM	maskW,<IDM_EXP OR IDM_OEXP>	
	je	NtIdNoArg
;scan arguments/indicies, can have a number of arguments inside ()
NtIdArgLoop:
	mov	di,[ps.PS_bdpDst.BDP_cbLogical] ;di = oDstExp
.erre NTEL_ARGS EQ IDM_ARGS
	mov	ax,[maskW]		
	call	NtExprOrArg		
	jl	J2_NtIdSnErr		;brif result == PR_BadSyntax
	je	NtIdEndArgs		;brif result == PR_NotFound
BumpCArgs:
	inc	si			;bump cArgs
	test	[maskLO],IDM1_DIM
	je	GetComma

	;each index to DIM represents 2 scanner arguments, but 1
	;arg to MakeVariable.  We communicate this to
	;EmitVar() by passing FEM_AryDim in [flags]
	
	or	[flagsLO],FEM_AryDim
	mov	ax,IRW_TO
	call	TestScan_AX
	jne	NoToClause		;brif didn't get TO
	call	ScanTok			;skip TO
	call	NtConsumeExp		;consume high index
	jge	GetComma		;brif result != PR_BadSyntax
J2_NtIdSnErr:
	jmp	short NtIdSnErr		;brif syntax error

;default lower bound
NoToClause:
	PUSHI	ax,<DATAOFFSET ps.PS_bdpDst>
	push	di			;pass oDstExp
	PUSHI	ax,2
	call	BdShiftRight
	or	ax,ax
	jne	StoreOpBase
	call	ParseErrOm		;Error "Out of memory"
	jmp	SHORT GetComma

;store opDimOptionBase opcode in pcode buffer
StoreOpBase:
	add	[ps.PS_bdpDst.BDP_pbCur],2
	mov	bx,[ps.PS_bdpDst.BDP_pb]
	add	bx,di			;add in oDstExp
	mov	WORD PTR [bx],opDimOptionBase
GetComma:
	mov	ax,IRW_Comma
	call	TestScan_AX
	jne	NtIdEndArgs		;brif current token is not comma
	cmp	si,MAXDIM
	jae	NtIdEndArgs		;BASCOM can't handle more than 60
					; args, so we shouldn't either
	call	ScanTok			;skip comma
	jmp	NtIdArgLoop		;get next arg

NtIdEndArgs:
	or	si,si			;test cArgs
	jne	NtIdGetRParen		;brif got more than 1 index
	test	[maskLO],IDM1_EXP
	je	NtIdGetRParen		;brif we don't need any expressions
	call	PErrExpExpr		;error "Expected expression"
	jmp	SHORT NtIdExit		;return PR_BadSyntax

NtIdGetRParen:
	mov	ax,IRW_RParen
	call	ConsumeRw_AX		;consume ')'
	jc	NtIdSnErr		;brif syntax error
	test	WORD PTR [maskHI],IDM2_AS
	je	NotAryAs		;brif not expecting AS clause

	;check for AS clause
	sub	ax,ax
	lea	bx,[tokId]
	call	NtAsClause		;parse AS <type>
	jge	NotAryAs		;brif result != PR_BadSyntax
NtIdSnErr:
	mov	al,PR_BadSyntax
	jmp	SHORT NtIdExit

NotAryAs:
	lea	ax,[tokId]
	push	ax
	push	[opBase]
	push	si			;pass cArgs
	push	[flags]
	call	EmitVar			;emit pcode for array ref
	jc	NtIdSnErr		;brif syntax error
	mov	[fLastIdIndexed],TRUE
NtIdEnd:
	;this is (and must remain) the only exit point for PR_GoodSyntax
	mov	al,PR_GoodSyntax
NtIdExit:
	;Can't just bump cIdArgs, recursive calls to NtExp could have
	;bumped it, making it useless.
	
	pop	dx			;dx = caller's cIdArgs
	inc	dx
	or	al,al			;set condition codes for caller
	jle	NtIdExit1		;brif result != PR_GoodSyntax
	mov	[cIdArgs],dx		;bump cIdArgs
NtIdExit1:
cEnd


;*********************************************************************
; CopyTokScanBx
; Purpose:
;	Copy important fields from one token descriptor to another.
;	Then call ScanTok to advance to next token.
; Entry:
;	[pTokScan] points to source token
;	bx points to destination token
;
;*********************************************************************
PUBLIC	CopyTokScanBx
CopyTokScanBx PROC NEAR
	push	[pTokScan]		;pass pbSrc
	push	bx			;pass pbDst
	PUSHI	ax,<size TOK>		;pass byte count
	call	CopyBlk			;copy the token descriptor
	jmp	ScanTok			;get next token, then return to caller
CopyTokScanBx ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryDim()
;
; Purpose:
;	Try to parse a scalar or array element of the form:
;	   id[<type>] [(exp [TO exp], ... )] [AS <type>]
;	This can occur in the statement  DIM IdAryDim ...
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryDim
NtIdAryDim PROC NEAR
	mov	ax,IDM_INDEXED OR IDM_EXP OR IDM_DIM OR IDM_VTREF OR IDM_AS
	jmp	NtId			

NtIdAryDim ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdAryRedim()
;
; Purpose:
;	Try to parse a scalar or array element of the form:
;	   id[<type>] [(exp [TO exp], ... )] [AS <type>]
;	This can occur in the statement  REDIM IdAryDim ...
;
; Exit:
;	Returns PR_NotFound, PR_GoodSyntax or PR_BadSyntax
;
;*********************************************************************
PUBLIC	NtIdAryRedim
NtIdAryRedim PROC NEAR
	mov ax,IDM_INDEXED OR IDM_EXP OR IDM_DIM OR IDM_AS OR IDM_NOSCALAR
	call	NtId
	jle	AryDimExit		;brif result != PR_GoodSyntax
	cmp	[fLastIdIndexed],FALSE
	je	AryDimExit		; Brif NtId emitted a scalar
	mov	ax,opStRedimTo
	call	Emit16_AX
	mov	al,PR_GoodSyntax
AryDimExit:
	or	al,al			; Set flags for caller
	ret	
NtIdAryRedim ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtImpliedLetOrCall(fCantBeCall)
;
; Purpose:
;	Parse implied LET or CALL or TYPE/AS statement
;	   id = exp
;	   id [argList]
;	   id AS (INTEGER | LONG | SINGLE | DOUBLE | STRING * const | id)
;	A complicated example is:
;	   a(x).b=c(y).d which produces:
;	opIdLd(y) opAIdRf(1,c) opOffLd(d) opIdLd(x) opAIdRf(1,a) opOffSt(b)
;
; Entry:
;	It is assumed that pTokScan points to an id token
;	fCantBeCall is TRUE if it MUST be a LET statement
;
; Exit:
;	Never returns PR_NotFound, only PR_GoodSyntax or PR_BadSyntax
;	Condition codes set based on value in al
;
;*********************************************************************
cProc	NtImpliedLetOrCall,<PUBLIC,NEAR>,<si,di>
	parmW	fCantBeCall		;can't be parmB because some caller's
					; do a push sp to pass TRUE
	localB	fGotScalar
	localW	cArgs
	;reg si = oDstLvalStart
	localW	oDstLvalEnd
	localV	tokId,%(size TOK)
	localW	cbShift
cBegin
	call	Peek1Tok		;look at token past id
	mov	ax,IRW_AS
	call	TestPeek_AX
	jne	NotAsType1		;brif id not followed by AS

	;got  id AS type  statement, presumably within TYPE/END TYPE block
	call	IdTokNoPeriodImp	;parse id token with no period in it
					;error if not implicit
	jl	J1_LetExit		;brif PR_BadSyntax
	lea	bx,tokId
	call	CopyTokScanBx		;copy [pTokScan] to [bx], ScanTok
	mov	ax,opElemRef
PrsAsClause:
	call	Emit16_AX
	mov	ax,[tokId.TOK_id_oNam]	;ax = oNam of variable in as clause
	call	Emit16_AX

	;now parse 'AS <type>' and emit opAsType(oNam)
; if FV_FARSTR is TRUE but that would be nearly unreadable
	mov	al,FAS_fNoVarLenStr + FAS_fDontBind + FAS_fDontSetONam
					;AS STRING is not allowed within
					; a TYPE stmt.  AS STRING * N is
					;Don't call RefType(x) for id as x
	lea	bx,tokId
	call	NtAsClause		;parse "AS <type>" clause
J1_LetExit:
	jmp	LetExit			

NotAsType1:
	lea	bx,tokId
	call	CopyTokScanBx		;copy [pTokScan] to [bx], ScanTok
	mov	si,[ps.PS_bdpDst.BDP_cbLogical]
					;si = oDstLvalStart]
	mov	[fGotScalar],TRUE
	call	NtExprList		;try to parse "(exp, exp, ..., exp)"
	mov	[cArgs],cx		;record number of args found
	je	LetNotAry		;brif not found
	jl	J1_LetExit		;brif syntax error
LetGotAry:
	mov	[fGotScalar],FALSE
	
LetNotAry:
	call	FElements		;see if cur token is record separator
	je	ItsALet			;brif we got .elem (it can't be CALL)
	cmp	cx,1			
	ja	ItsALet			;brif got x(y,...)... (can't be CALL)
	mov	ax,IRW_EQ
	call	TestScan_AX
	je	ItsALet			;brif got '=' (can't be CALL)
	jmp	ImpliedCall		;brif didn't get an implied LET stmt

;we're looking at an implied LET statement, not an implied CALLstatement
ItsALet:
	or	[tokId.TOK_id_vmFlags],FVI_LVAL
	cmp	[fGotScalar],FALSE
	je	LetAry
	lea	ax,[tokId]
	push	ax			;pass ptr to id's token
	PUSHI	ax,opId_St		;emit a Store id variant
	PUSHI	ax,0			;cArgs = 0
	PUSHI	ax,FEM_ElemOk		;.elem may follow variable
	jmp	SHORT LetEmitVar

;lvalue is an array element
LetAry:
LetAryGood:
	lea	ax,[tokId]
	push	ax
	PUSHI	ax,opId_St		;emit a Store id variant
	push	[cArgs]			;arg count
	PUSHI	ax,<FEM_Ary OR FEM_ElemOk> ;.elem may follow variable
LetEmitVar:
	call	EmitVar			;emit an array store opcode
	jc	LetSnErr		;brif EmitVar got error
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	mov	[oDstLvalEnd],ax	;save offset to end of lval's pcode
	mov	ax,IRW_EQ
	call	ConsumeRw_AX		;parse '='
	jc	LetSnErr		;brif error
	call	NtConsumeExp		;parse an expression
	jl	LetSnErr		;brif result == PR_BadSyntax
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	sub	ax,[oDstLvalEnd]
	mov	[cbShift],ax

	;for assignments like A(X,Y)=Z, the pcode buffer contains:
	;           <id(X)> <id(Y)> <id(A)> <id(Z)>
	;         1^                      2^      3^
	; where 1^=oDstLvalStart, 2^=oDstLvalEnd, 3^=cbLogical
	; The next few lines swap argument and expression pcode to be:
	;             <id(Z)> <id(X)> <id(Y)> <id(A)>
	
	PUSHI	ax,<DATAOFFSET ps.PS_bdpDst>
	push	si
	push	[cbShift]
	call	BdShiftRight
	or	ax,ax
	jne	RightOk
	call	ParseErrOm		;Error "Out of memory"
	jmp	SHORT J1_LetGoodSyntax

RightOk:
	mov	ax,[oDstLvalEnd]
	add	ax,[cbShift]
	add	ax,[ps.PS_bdpDst.BDP_pb] ;ax points to source
	push	ax
	xchg	ax,si			;ax = oDstLvalStart
	add	ax,[ps.PS_bdpDst.BDP_pb] ;ax points to destination
	push	ax
	push	[cbShift]		;pass byte count
	call	CopyBlk
	mov	ax,[cbShift]
	sub	[ps.PS_bdpDst.BDP_cbLogical],ax
J1_LetGoodSyntax:
	jmp	SHORT LetGoodSyntax


InvalidCall:
	mov	ax,MSG_ExpAssignment	;Error "Expected var=expression"

LetExpErr:
	call	PErrExpMsg_AX
	;tell user-interface what column error really occured in
	mov	ax,[tokId.TOK_oSrc]
	mov	[ps.PS_oSrcErr],ax
LetSnErr:
	mov	al,PR_BadSyntax
	jmp	SHORT LetExit		


;we're looking at an implied CALL statement, not an implied LET statement
;If [cArgs] == 1, we've already consumed the 1st argument, because we
;   weren't sure if it was an array lval.
;   idProc ( expression ) [, arg2 [, arg3 ...]]
;          current token ^
;If [cArgs] == 0, we've just consumed the idProc
;            idProc [arg1 [, arg2 ...]]
;    current token ^
;
ImpliedCall:
	cmp	[fCantBeCall],FALSE
	jne	InvalidCall		;brif implied CALL is invalid here
	cmp	[tokId.TOK_id_oTyp],ET_IMP
	jne	InvalidCall		;brif sub id is explicitly typed
	cmp	[cArgs],0
	je	CallArg1		;brif no args consumed yet

; We've got IdProc (arg) [, ...] --- 
GotPassByVal:
	mov	ax,opLParen		;already consumed 1st arg,
	call	Emit16_AX		;it was a parend expression
	jmp	SHORT CallArg2		;get 2nd CALL arg (if any)

CallArgLoop:
	call	ScanTok			;skip ','
	call	NtIdCallArg		;consume 1st arg (if any)
	jg	CallArgNext		;brif result is PR_GoodSyntax
	jl	J4_LetSnErr		;brif result == PR_BadSyntax
	call	PErrExpExpr		;error "Expected expression"
J4_LetSnErr:
	jmp	LetSnErr		;return al = PR_BadSyntax

;so far, we've just seen idProc.  Try to parse 1st arg.
;
CallArg1:
	call	NtIdCallArg		;consume 1st arg (if any)
	je	CallArgEnd		;brif no args
CallArgNext:
	inc	[cArgs]			;bump arg count
	cmp	[cArgs],MAXARG		
	jae	CallArgEnd		;don't parse more args if got max
					; this will generate "expected EOL"
CallArg2:
	mov	ax,IRW_Comma
	call	TestScan_AX
	je	CallArgLoop		;brif got a comma
CallArgEnd:
	mov	ax,opStCallLess
CallEmitOp:
	call	Emit16_AX		;emit opcode
	mov	ax,[cArgs]
	call	Emit16_AX		;emit arg count
	mov	ax,[tokId.TOK_id_oNam]	;ax = oNam for sub
	call	SubRef			;ax = oPrs for sub
	jc	LetGoodSyntax		;brif couldn't define prs
					;ps.errCode set, so pcode won't be
					;emitted - line will be opReParse

	call	Emit16_AX		;emit oPrs for sub (parm pushed above)
LetGoodSyntax:
	mov	al,PR_GoodSyntax
LetExit:
	or	al,al			;set condition codes for caller
cEnd

;*********************************************************************
; PARSE_RESULT NEAR NtIdNamCom()
;
; Purpose:
;	Try to parse an identifier of the form:  id <with no explicit type>
;	The id can have a period, regardless of 'x AS' elsewhere in module.
;	This can occur in the following statements:
;	   COMMON [/IdNamCom/] ...
;
; Exit:
;	If good syntax, Emits id's 16-bit oNam and returns PR_GoodSyntax
;	Otherwise, an error is generated and PR_BadSyntax is returned.
;	Never returns PR_NotFound because no callers have other options
;
;*********************************************************************
PUBLIC	NtIdNamCom
NtIdNamCom PROC NEAR
	call	IdTokPeriodImp1
	jmp	SHORT NtIdImp1
NtIdNamCom ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdType()
;
; Purpose:
;	Try to parse an identifier of the form:  id <with no explicit type>
;	The id can have no periods.
;	This can occur in the following statements:
;	   DIM a AS IdType
;	   TYPE IdType
;	     Id AS IdType  'element definition in TYPE block
;
; Exit:
;	If good syntax, Emits id's 16-bit oNam and returns PR_GoodSyntax
;	If token is not an id, returns PR_NotFound
;	Else PR_BadSyntax after generating error
;
;*********************************************************************
PUBLIC	NtIdType
NtIdType PROC NEAR
	call	IdTok
	mov	al,PR_NotFound
	jne	NtIdImpExit		;brif not an id token
	call	IdTokNoPeriodImp	;parse id token with no period in it
					;error if not implicit
NtIdImp1:
	jl	NtIdImpExit		;brif PR_BadSyntax
;Jumped to from other procedures
NtIdImp2:
	mov	ax,[bx.TOK_id_oNam]
	call	Emit16_AX		;emit id's oNam
	call	ScanTok			;skip id
	mov	al,PR_GoodSyntax
NtIdImpExit:
	or	al,al			;set condition codes for caller
	ret	
NtIdType ENDP



;*========================================================================
;	               Procedure related ID nonterminals
;=========================================================================

;*********************************************************************
;UndoLogPrs
;Purpose:
;	Remember to free prs entry if we turn this line into a reparse
;	We only log it if the prs in question has no other references.
;	If we called UndefPrs for a prs that had a reference, then
;	a DECLARE that followed a SUB could end up looking like a stronger
;	reference than the SUB, which would cause problems.
;Entry:
;	ax = oPrs in question
;Exit:
;	ax is preserved as oPrs
;
;*********************************************************************
UndoLogPrs PROC NEAR
	push	ax			;save caller's ax
	call	PPrsOPrs		;bx = ptr to prs, ax still=oPrs
	xchg	dx,ax			;dx = oPrs (for ParseUndoLog)
	mov	ax,PTRRS[bx.PRS_otxDef] 
	inc	ax			;test for UNDEFINED
	jne	AlreadyRefed		;brif this prs already has a ref
	mov	al,PUNDO_oPrsRef	;pass entry type in al
	call	ParseUndoLog		;remember to free prs entry if
					; we turn this line into a reparse
AlreadyRefed:
	pop	ax			;restore caller's ax
	ret
UndoLogPrs ENDP


;*********************************************************************
; PARSE_RESULT NEAR NtIdSubRef
;
; Purpose:
;	Try to parse an identifier of the form:  id <with no explicit type>
;	This can occur in the following statements:
;	   CALL IdSubRef ...,  CALLS IdSubRef ...,
;
; Exit:
;	If good syntax, Emits id's 16-bit oNam and returns PR_GoodSyntax
;	Otherwise, an error is generated and PR_BadSyntax is returned.
;	Never returns PR_NotFound because no callers have other options
;
;*********************************************************************
PUBLIC	NtIdSubRef
NtIdSubRef PROC NEAR
	call	IdSub
	jge	NtIdImp2		;brif not PR_BadSyntax, emit pcode
NtRet1:
	ret
NtIdSubRef ENDP

;*********************************************************************
; NtIdFuncDef, NtIdFuncDecl, NtIdFn [QB4]
;
; Purpose:
;	Try to parse a procedure id of the form:
;	   [FN]id[type]
;	This can occur in the following statements:
;	   DECLARE FUNCTION IdFuncDecl ...
;	   FUNCTION IdFuncDef ...
;	   DEF IdFn ... [QB4]
;
; Exit:
;	If this is found, the token is consumed, the parm's oNam and
;	   16 bit procedure-attribute-mask are emitted, and the return
;	   value is PR_GoodSyntax.
;	Otherwise, an error is generated and PR_BadSyntax is returned.
;	Never returns PR_NotFound because no callers have other options
;
;********************************************************************
PUBLIC	NtIdFuncDecl
NtIdFuncDecl PROC NEAR
	sub	ax,ax			;id can't begin with FN
	call	IdTokFn
	jl	NtRet1			;brif bad syntax
	mov	ax,0FF00h + PT_FUNCTION
	jmp	SHORT MakeProcFunc
NtIdFuncDecl ENDP

PUBLIC	NtIdFuncDef
NtIdFuncDef PROC NEAR
	sub	ax,ax			;id can't begin with FN
	call	IdTokFn
	jl	NtRet1			;brif bad syntax
	mov	ax,PT_FUNCTION
MakeProcFunc:
	mov	dx,FVI_FUNCTION
	jmp	SHORT MakeProc
NtIdFuncDef ENDP

; Invoked for DEF FNx statement
PUBLIC	NtIdFn
NtIdFn PROC NEAR
	mov	ax,FVI_FNNAME		;id needs to begin with FN
	call	IdTokFn			;bx=token, dl=oTyp
	jl	NtRet1			;brif bad syntax
	mov	ax,PT_DEFFN
	sub	dx,dx
	jmp	SHORT MakeProc
NtIdFn ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtIdSubDef, NtIdSubDecl
;
; Purpose:
;	Try to parse an identifier of the form:  id <with no explicit type>
;	This can occur in the following statements:
;	   SUB IdSubDef ...
;	   Implied CALL gets fixed up in NtImpliedLetOrCall
;	   DECLARE SUB IdSubDecl ...
;
; Exit:
;	If good syntax, Emits id's 16-bit oNam and returns PR_GoodSyntax
;	Otherwise, an error is generated and PR_BadSyntax is returned.
;	Never returns PR_NotFound because no callers have other options
;
;*********************************************************************
PUBLIC	NtIdSubDef
NtIdSubDef PROC NEAR
	call	IdSub
	jl	NtRet1			;return if bad syntax
	mov	ax,PT_SUB
	jmp	SHORT MakeProcSub
NtIdSubDef ENDP

PUBLIC	NtIdSubDecl
NtIdSubDecl PROC NEAR
	call	IdSub
	jl	NtRet1			;return if bad syntax
	mov	ax,0FF00h + PT_SUB
MakeProcSub:
	sub	dx,dx
NtIdSubDecl ENDP
	;fall into MakeProc
;*********************************************************************
; MakeProc
; Purpose:
;	Calls PrsDefine which will create a Prs for the procedure if one does
;	not yet exist.
;	If it is called for a function then it sets up a variable in the
;	module's variable table for the function.
;	Ensures table is in RUDE state.
; Entry:
;	al = procType
;	ah = non-zero if DECLARE
;	dx = mkVar.flags value for procedure (FVI_FUNCTION/0)
;	pTokScan points to id token for [DECLARE] SUB/FUNCTION/DEF id
; Exit:
;	token is consumed
;	al = PR_GoodSyntax or PR_BadSyntax if DECLARE or DEF FN stmt 
;		is being added into a procedure or out of memory, etc.
;	[pdcl.PDCL_cParms] = 0
;	[pdcl.PDCL_oPrs] = oPrs of procedure
;	If called for other than a DECLARE stmt then PrsCur and MrsCur
;	hold the Prs/Mrs of the procedure.
;
;*********************************************************************
cProc	MakeProc,<NEAR>
	localW	oMrsSave
	localW	oPrsSave
cBegin
	mov	WORD PTR ([pdcl.PDCL_procType]),ax
					;save procType, fDeclare flags
	mov	[mkVar.MKVAR_flags],dx	;setup for call to BindVar
	push	ax
	call	EnsRude			;make sure table is in SS_RUDE state
	pop	ax
	jnz	J1_MpExit		;exit if backout or retry
	test	[mrsCur.MRS_flags2],FM2_Include
	jne	ItsAnIncl		;brif we're looking at an INCLUDE file
	cmp	[cInclNest],0
	je	NotInInclude		;brif not loading an $INCLUDE file
	.errnz	PT_SUB - 1
	.errnz	PT_FUNCTION - 2
	.errnz	PT_DEFFN - 3
ItsAnIncl:
	cmp	ax,PT_FUNCTION
	ja	NotInInclude		;brif DECLARE or DEF FN
	mov	ax,MSG_InvIncl		;Error Stmt illegal within $INCLUDE file
	jmp	SHORT AlertErr

NotInInclude:
	mov	[pdcl.PDCL_cParms],0	;init parm count

	;Check for illegal SUB/FUNCTION/DEF FN/DECLARE Scoping:
	;if (opcode is opStDefFn or opStDeclare)
	;   If (we're within a SUB or FUNCTION)
	;      Issue  Illegal in SUB/FUNCTION error
	;else /* opcode is opStSub or opStFunction */
	;   if ( we're within a SUB or FUNCTION and SUB/FUNCTION is not defined)
	;      PrsDeactivate	      /* so new prs will be created */
	
	cmp	ax,PT_SUB
	je	GotSubFunc		;brif SUB stmt (not DECLARE SUB)
	cmp	ax,PT_FUNCTION
	je	GotSubFunc		;brif FUNCTION stmt

; user is entering a DECLARE, or DEF FN statement
NotSubFunc:
	test	[txdCur.TXD_flags],FTX_mrs
	jne	NoScopeErr		;brif not currently in a SUB/FUNCTION

;  user is attempting to enter a  DEF FN or DECLARE stmt in SUB/FUNC
;
InvProcErr:
	mov	ax,MSG_InvProc		;Error: stmt illegal in SUB/FUNCTION

;ax = standard qbi error code
;pTokScan points to id token
;
AlertErr:
	or	ah,PSERR_fAlert / 100h	;set parser's Alert flag
	call	ParseErrTokScan
J1_MpExit:
	jmp	MpExit

;user is attempting to define a SUB or FUNCTION
GotSubFunc:
	; We are in a SUB or function, and there is no current
	; definition for the SUB, then call PrsDeactivate so that a
	; new SUB/FUNCTION will be created.  Otherwise, this will be
	; treated as a rename of a SUB/FUNCTION.
	
	test	[txdCur.TXD_flags],FTX_mrs
	jne	NoScopeErr		;brif not currently in a SUB/FUNCTION
					; i.e. user is attempting to enter a
					; SUB or FUNCTION stmt in main prog
;Check to see if we are currently merging into a sub. If we
;are then generate an error. 
	fLoadActive			
	jz	NotLoading		;brif not loading
	cmp	[fMergeInSub],0		
	jnz	InvProcErr		;brif merging into a Sub
NotLoading:				
	test	[prsCur.PRS_flags],FP_DEFINED
	je	NoScopeErr		;brif SUB/FUNCTION is not already
					; defined. Rename the SUB/FUNCTION

	; We are in a SUB/FUNCTION with a definition.  Call PrsDeactivate
	; to force the creation of a NEW SUB/FUNCTION by PrsDefine

	call	PrsDeactivate		;get back to main program's text table

;PrsDefine(oNam, procType, oTyp, fDeclare)
NoScopeErr:
	mov	bx,[pTokScan]
	mov	ax,[bx.TOK_id_oNam]
	mov	[pdcl.PDCL_oNam],ax
	mov	[mkVar.MKVAR_oNam],ax	;setup for call BindVar
	mov	ax,[bx.TOK_id_oTyp]	;ax = explicit oTyp
	mov	dx,ax			;dx = ax = oTyp
	or	dl,DCLA_Explicit
	mov	cx,WORD PTR([pdcl.PDCL_procType]) ;cl = procType, ch=fDeclare
	cmp	cl,PT_SUB
	je	ImplicitType		;brif [DECLARE] SUB
	or	ax,ax			;test for ET_IMP
	.errnz	ET_IMP
	jne	ExplicitType
	mov	al,[bx.TOK_id_charFirst]
	sub	ah,ah			;ax = 0..25 for A..Z
	push	bx
	mov	bx,ax			;can't use xchg, need ah=0
	mov	al,[ps.PS_tEtCur+bx]	;ax = default oTyp
	pop	bx			;bx points to id token
ImplicitType:
	sub	dx,dx			;dl = ET_IMP
	.errnz	ET_IMP
ExplicitType:
	mov	[mkVar.MKVAR_oTyp],ax	;oTyp to pass to BindVar (never ET_IMP)
	mov	[pdcl.PDCL_oTyp],dl	;oTyp to emit in pcode

	cmp	cl,PT_DEFFN
	jne	NotDefFn		;brif not DEF FN stmt
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jne	NotDefFn
	mov	[pdcl.PDCL_oPrs],UNDEFINED
	DJMP	jmp SHORT MpExit	;bind DEF FNs to oNam in SS_RUDE
					; to oPrs in other scan states
NotDefFn:

;bx = ptr to token, cl = procType, al = oTypFn
	push	[bx.TOK_id_oNam]	;pass oNam
	push	cx			;pass procType (byte parm)
	push	ax			;pass oTyp (byte parm)
	push	WORD PTR([pdcl.PDCL_fDeclare])	;pass fDeclare (byte parm)
	mov	ax,[grs.GRS_oMrsCur]	;save current mrs & prs
	mov	[oMrsSave],ax		; so we can restore context on exit
	mov	ax,[grs.GRS_oPrsCur]	; for DECLARE
	mov	[oPrsSave],ax
	call	PrsDefine
	or	ax,ax			
	je	PrsDefined		;brif no error
	jmp	AlertErr

PrsDefined:
	;procedure has been defined or declared and made active
	
	mov	ax,[grs.GRS_oPrsCur]	;dx = oPrs for proc
	mov	[pdcl.PDCL_oPrs],ax
	call	UndoLogPrs		;remember to free prs entry if
					; we turn this line into a reparse
					; ax is preserved as oPrs

	;Even if oPrsSave == oPrsNew, we call WnReAssign in case user changed
	;from a SUB to a FUNCTION, so if DrawDebugScr will be called to
	;change all EXIT/END SUB statements to EXIT/END FUNCTION.
	;Otherwise, what is in pcode is inconsistent with what is on the screen.
	;(calling DrawDebugScr is cheap enough to do it sometimes when we
	; don't really need to)
	;;cmp	[oPrsSave],ax
	;;je	NoRename

	cmp	[oPrsSave],UNDEFINED
	je	NoRename
	mov	ax,WORD PTR([pdcl.PDCL_procType]) ;al=procType, ah=fDeclare
	cmp	ax,PT_SUB
	je	RenameProc		;brif SUB stmt
	cmp	ax,PT_FUNCTION
	jne	NoRename
RenameProc:
	;--------------------------------------------------------
	;user is editing SUB/FUNCTION Foo, and has changed its
	;name to Bar.  PrsDefine created a new prs for this case,
	;and moved the text table over to the new prs.
	;We must now find a new definition for prs Foo (i.e.
	;set its prsCur.otx field to another DECLARE,
	;or PrsFree Foo's prs entry if no references exist for it.
	;--------------------------------------------------------
	;tell user interface to change title and oPrs of procedure's window
	mov	ax,[oPrsSave]
	or	ah,80H			;tells WnReAssign this is oPrs, not oMrs
	push	ax			;pass oRsSave
	push	[grs.GRS_oRsCur]	;pass oRs for new prs
	push	sp			;just renaming an oRs-don't move cursor
	call	WnReAssign

	mov	ax,[oPrsSave]
	call	UndefPrs		;tell txtmgr we deleted "defining" ref
;call ChkAllUndefPrs here because if we wait until we return to TxtChange,
;the Prs for "sub2" in the stmt "Sub sub1 : call sub2" will get discarded
;after parsing since its only reference is in the parser buffer.
	call	ChkAllUndefPrsSaveRs	;find new ref to the old Prs or
					; discard it if there aren't any
NoRename:
	cmp	[pdcl.PDCL_procType],PT_SUB
	je	DeclSub			;brif [DECLARE] SUB stmt

DbAssertRel mkVar.MKVAR_oTyp,be,ET_MAX,CP,<invalid mkVar.oTyp in CgDeclare>
; Let variable manager know about this DEF/FUNCTION
; Note that BindVar (and MakeVariable) don't care about the settings of
; FVI_INDEXED or mkVar.cDimensions if FVI_FUNCTION is set or the id begins with FN.
;
NoParms:
DeclSub:
	cmp	[pdcl.PDCL_fDeclare],FALSE
	je	MpExit			;brif not DECLARE stmt
	push	[oMrsSave]		;restore old mrs/prs
	call	MrsActivateCP
	push	[oPrsSave]
	call	PrsActivateCP
MpExit:
	call	ScanTok			;consume id token
	mov	al,PR_GoodSyntax
cEnd

;*********************************************************************
; NtIdParm()
;
; Purpose:
;	Try to parse a formal parameter of the form:
;	   [BYVAL | SEG] id [([constant]) [AS <typeId>]]
;	This can occur in the DECLARE, DEF FN, FUNCTION, and SUB
;	   statement's formal parameter lists.
; Entry:
;	[pdcl.PDCL_procType], [pdcl.PDCL_fDeclare] and [pdcl.PDCL_cParms]
;	  have been setup by NtIdFuncDecl, NtIdSubDecl, NtIdFn [QB4],
;	  NtIdFuncDef or NtIdSubDef.
; Exit:
;	If this is found, the tokens are consumed, the parm's oNam,
;	   16 bit formal-parm-attribute-mask, and oTyp are emitted,
;	   and the return value is PR_GoodSyntax.
;	Otherwise, the return value is PR_NotFound or PR_BadSyntax.
;
;********************************************************************
cProc	NtIdParm,<PUBLIC,NEAR>,<si,di>
	localW	pTokId
	localW	oNamParm
	;reg si oTypOrONam
	;reg di parmAtrMask
cBegin
	;following constants from different header files must be same
	DbAssertRel FVI_ARRAY,e,PATR_array,CP,<FVI_ARRAY != PATR_array>
	DbAssertRel FVI_ASCLAUSE,e,PATR_asClause,CP,<FVI_ASCLAUSE != PATR_asClause>

	cmp	[pdcl.PDCL_cParms],MAXARG 
	jb	NtIdOK			
	call	ExpRParenLastToken	;"expected ')'" on prev token
	jmp	SHORT J1_NtParmExit	
NtIdOK:
	sub	di,di			;parmAtrMask = 0
	cmp	[pdcl.PDCL_fDeclare],0
	je	NotSegParm		;brif SEG/BYVAL not allowed -not DECLARE
	mov	ax,IRW_ByVal
	call	TestScan_AX
	jne	@F			;brif token isn't BYVAL
	mov	di,PATR_BYVAL		;remember that BYVAL was seen

	jmp	SHORT GotSegByVal
@@:
	mov	ax,IRW_SEG
	call	TestScan_AX
	jne	@F			;brif token isn't SEG
	mov	di,PATR_SEG		;remember that SEG was seen
GotSegByVal:
	call	ScanTok			;consume SEG/BYVAL token
@@:
NotSegParm:
	call	IdTok			;bx points to current token
	je	GotIdParm		;brif its an id token
NIPError:
	sub	ax,ax			;prepare to return PR_NotFound
	or	di,di			;test parmAtrMask
	je	J1_NtParmExit		;brif no tokens have been consumed
	;we've already consumed BYVAL or SEG, it is a syntax error
	call	PErrExpId		;Expected id, al = PR_BadSyntax
J1_NtParmExit:
	jmp	NtParmExit

GotIdParm:
	test	[bx.TOK_id_vmFlags],FVI_FNNAME 
	jnz	NIPError		;brif parameter is FNxxx

	mov	[pTokId],bx		;pTokId = pTokScan
	mov	ax,[bx.TOK_id_oNam]	;ax = parm's oNam
	mov	[oNamParm],ax
	mov	si,[bx.TOK_id_oTyp]	;si = parm's oTyp
.errnz	ET_IMP
	or	si,si
	je	ImplicitParm		;brif no explicit type
	or	di,PATR_explicit	;remember parm has explicit type
	jmp	SHORT EatId

ImplicitParm:
	cCall	OTypOfONamDefault,<ax>	; ax = default oTyp for oNam in ax
	xchg	si,ax			;si = oTyp
EatId:
	call	ScanTok			;skip past parm's id token
	mov	al,FAS_fNoUserType + FAS_fNoFixLenStr
	cmp	[pdcl.PDCL_procType],PT_DEFFN
	je	TryAsClause1		;DEF FNs can't have array parms
	test	di,PATR_BYVAL OR PATR_SEG
	jne	TryAsClause		;arrays can't be passed by value or seg
	mov	ax,IRW_LParen
	call	TestScan_AX
	jne	TryAsClause		;brif no '('
	call	ScanTok			;skip past '('
	call	NtLitI2NoCode		;scan optional integer (ignore value)
	jl	JL1_NtParmExit		;brif PR_BadSyntax
	mov	ax,IRW_RParen
	call	ConsumeRw_AX		;consume ')' token
	jc	J1_NtParmExit		;return PR_BadSyntax if not found
	or	di,PATR_array		;remember parm is an array
TryAsClause:
	mov	al,FAS_fNoFixLenStr
TryAsClause1:
	cmp	[pdcl.PDCL_fDeclare],0
	je	NotDeclare		;brif not DECLARE parm
	or	al,FAS_fAllowAny	;parm AS ANY is ok in DECLARE stmt
NotDeclare:
	mov	bx,[pTokId]
	call	NtAsClause		;parse "AS <type>" clause
JL1_NtParmExit:
	jl	NtParmExit		;brif result == PR_BadSyntax
	je	NotAsParm		;brif result == PR_NotFound

	;NtAsClause set pTokId's oTyp to type indicated by AS clause
	mov	bx,[pTokId]
	mov	si,[bx.TOK_id_oTyp]	;si = oTyp (set by NtAsClause)
	or	di,PATR_asClause

	; discard pcode emitted by NtAsClause
	sub	[ps.PS_bdpDst.BDP_cbLogical],6
	sub	[ps.PS_bdpDst.BDP_pbCur],6

;Now bind the parameter to an oVar if we're not in a DECLARE stmt
NotAsParm:
	mov	ax,[oNamParm]
	cmp	[pdcl.PDCL_fDeclare],0
	jne	EmitONam		;brif DECLARE parm
	mov	[mkVar.MKVAR_oNam],ax

	mov	ax,FVI_FORMAL
	test	di,PATR_array
	je	NotArray
	or	ax,FVI_INDEXED OR FVI_ARRAY
NotArray:
	test	di,PATR_asClause
	je	NotAsType2
	or	ax,FVI_ASCLAUSE
NotAsType2:
	mov	[mkVar.MKVAR_flags],ax
	mov	[mkVar.MKVAR_cDimensions],0
	mov	[mkVar.MKVAR_oTyp],si
	mov	ax,[pTokId]		;if error, report at this column
	call	BindVar			;call var mgr to bind variable
					;ax = oVar to emit
EmitONam:
	call	Emit16_AX		;Emit oNam or oVar
	xchg	ax,di			;Emit parmAtrMask
	call	Emit16_AX
	xchg	ax,si			;Emit16 oTypOrONam
	call	Emit16_AX
	inc	[pdcl.PDCL_cParms]	;bump parm count
	mov	al,PR_GoodSyntax
NtParmExit:
cEnd

;*********************************************************************
; PARSE_RESULT NEAR NtNArgs()
;
; Purpose:
;	Invoked to parse the arguments to statements like CLEAR, COLOR,
;	LOCATE, SCREEN where each positional parameter can is optional.   
;	Each expression is followed by opLit1 (to indicate to the executor that
;	this parameter was specified).  Each omitted expression results in
;	an opNull (to tell the executor that this parm was omitted).
;	Syntax error if last item is a comma and not expression.
;	0 or more arguments are allowed.
;	Expected syntax:  [[exp], [[exp] , ... ]]
;	The Finite State Machine for this syntax is:
;	State0:  comma -> state1
;	         expression -> state2
;	         end-of-stmt -> accept
;	State1:  comma -> state1
;	         expression -> state2
;	State2:  comma -> state1
;	         end-of-stmt -> accept
;
; Entry:
;	pTokScan points to 1st expression or comma
;	cIdArgs is assumed to be 0 (it gets set by NtStatement())
;
; Exit:
;	The return value is PR_GoodSyntax or PR_BadSyntax
;
;********************************************************************
PUBLIC	NtNArgsMax3, NtNArgsMax4, NtNArgsMax5
NtNArgsMax3 PROC NEAR
	mov	al,3
	SKIP2_PSW
NtNArgsMax3 ENDP
NtNArgsMax4 PROC NEAR
	mov	al,4
	SKIP2_PSW
NtNArgsMax4 ENDP
NtNArgsMax5 PROC NEAR
	mov	al,5
NtNArgsMax5 ENDP
NtNArgs PROC NEAR
;At this point, we can accept and end-of-stmt, expression, or comma
	push	si
	cbw
	xchg	si,ax			;si = max args allowed
	call	NtEndStatement
	mov	al,PR_GoodSyntax	;prepare to return PR_GoodSyntax
	jne	ArgExit			;brif end-of-stmt
ArgLoop:
	inc	[cIdArgs]		;bump cnt for opNull or opUndef
	mov	ax,IRW_Comma
	call	TestScan_AX
	jne	ArgExp			;brif current token is not a comma
	mov	ax,opNull		;let executor know arg was defaulted
	call	Emit16_AX
	jmp	SHORT ArgComma

;We need an expression at this point
ArgExp:
	mov	ax,opUndef		;let executor know arg wasn't  defaulted
	call	Emit16_AX
	call	NtConsumeExp		;try to parse an expression
					;NtExp bumps cIdArgs
					;returns PR_GoodSyntax or PR_BadSyntax
	jl	ArgExit			;brif result == PR_BadSyntax
	call	NtEndStatement
	mov	al,PR_GoodSyntax	;prepare to return PR_GoodSyntax
	jne	ArgExit			;brif end-of-stmt

;We need a comma at this point
ArgComma:
	dec	si
	je	ArgExpEos		;brif beyond last legal arg
	mov	ax,IRW_Comma		;Consume ","
	call	ConsumeRw_AX
	jnc	ArgLoop			;brif no syntax error
					; else al = PR_BadSyntax
ArgExit:
	pop	si
	ret	

ArgExpEos:
	mov	ax,MSG_eos		;Expected End of statement
	call	PErrExpMsg_AX		;generate error, al=PR_BadSyntax
	jmp	SHORT ArgExit
NtNArgs	ENDP

;********************************************************************
; NtConstAssign
; Purpose:
;	Recognize the nonterminal 'id = <expression>'
;	Where <expression> can contain no intrinsic functions
;
;********************************************************************
PUBLIC	NtConstAssign
cProc	NtConstAssign,<PUBLIC,NEAR>,<si,di>
	localW	oSrcTok
cBegin
	call	EnsRude			;make sure table is in SS_RUDE state
	call	IdTok			;bx points to current token
	je	GotConstId		;brif its an id token
ConstBadName:
	call	PErrExpId		;Expected id, al = PR_BadSyntax
	jmp	SHORT ConstExit

GotConstId:
	TESTM	bx.TOK_id_vmFlags,FVI_FNNAME	
	jne	ConstBadName		;brif id begins with FN
	mov	si,[bx.TOK_id_oNam]
	mov	di,[bx.TOK_id_oTyp]
	mov	ax,[bx.TOK_oSrc]
	mov	[oSrcTok],ax		;remember token's column for error
					; reporting
	call	ScanTok			;skip id
	mov	ax,IRW_EQ
	call	ConsumeRw_AX		;parse '='
	jc	ConstExit		;brif syntax error (return PR_BadSyntax)

	push	[ps.PS_bdpDst.BDP_cbLogical];save cur #bytes pcode generated
	DbAssertRel si,ne,0,CP,<NtConstAssign err1>
	mov	[oNamConstPs],si	;set static flag so NtExp does not
					; allow intrinsic functions or variables
	call	NtConsumeExp		;parse an expression
	mov	[oNamConstPs],0
	pop	dx			;dx = offset to 'id=expr' pcode
	jl	ConstExit		;brif result == PR_BadSyntax

.errnz OPCODE_MASK - 3FFh		
	xchg	ax,di			;ax = oTyp
	xchg	ah,al			
	shl	ax,1			
	shl	ax,1			
	add	ax,opIdSt		;ax = opIdSt with oTyp in top 6 bits
	call	Emit16_AX		;emit opcode
	xchg	ax,si			;pass oNam in ax
	call	Emit16_AX		;emit oNam
ConstGoodExit:
	mov	al,PR_GoodSyntax
ConstExit:
cEnd



			;-----------------------------
			; Primitive ID token scanners 
			;-----------------------------

;*********************************************************************
; IdTokPeriodImp1
; Purpose:
;	Same as IdTokPeriodImp, but this generates errors if desired
;	token is not found, instead of returning PR_NotFound
;
;*********************************************************************
IdTokPeriodImp1	PROC NEAR
	call	IdTok			;bx points to current token
	jne	J1_PErrExpId		;brif not an id token
					; error: Expected id, al = PR_BadSyntax
	call	IdTokPeriodImp
	je	J1_PErrExpIdImp		;brif not implicit id
					; id can't have %&!#$, al=PR_BadSyntax
	ret
IdTokPeriodImp1	ENDP

;*********************************************************************
; IdTokPeriodImp
; Purpose:
;	See if current token is an id token
;	Allow current token to have "." within id
;	Id cannot have explicit type char
; Entry:
;	[pTokScan] points to current token
; Exit:
;	bx points to current token
;	if token is an id token with no explicit type char:
;	   al = PR_GoodSyntax, non-zero condition codes
;	else
;	   al = PR_NotFound, zero condition codes
;
;*********************************************************************
PUBLIC	IdTokPeriodImp
IdTokPeriodImp PROC NEAR
	call	IdTok			;bx points to current token
	jne	IdTpNotFound		;brif not an id token
	;see if token needs to be rescanned
	cmp	[bx.TOK_id_termChar],'.'
	jne	NoRescan		;brif id not terminated by "."
	or	[psFlags],PSIF_fPeriodOk	;this time, don't stop at "."
	call	LexReset		;rescan pTokScan, don't stop at "."
	and	[psFlags],NOT PSIF_fPeriodOk
NoRescan:
	cmp	[bx.TOK_id_oTyp],ET_IMP
	je	IdGoodExit		;brif id has no explicit type char
IdTpNotFound:
	mov	al,PR_NotFound
IdTpExit:
	or	al,al			;set condition codes for caller
	ret
IdTokPeriodImp ENDP

;*********************************************************************
; IdTokNoPeriodImp
; Purpose:
;	Parse an id token, where the id cannot have a period in it.
;	Id must have no explicit type char.
;	Since callers of this function demand an id token, i.e.
;	no other token is possible, this function never returns
;	PR_NotFound, but generates the error instead.
; Entry:
;	[pTokScan] points to current token
; Exit:
;	If token is not an id token:
;	   "Expected id" error message is generated
;	   al = PR_BadSyntax
;	else if token has period:
;	   "id can't have '.'" error message is generated
;	   al = PR_BadSyntax
;	else if token has explicit type char:
;	   "id can't have %&!#$" error message is generated
;	   al = PR_BadSyntax
;	else
;	   al = PR_GoodSyntax
;	   bx points to current token
;	Never returns PR_NotFound because no callers have other options
;	condition codes set based on al
;
;*********************************************************************
PUBLIC	IdTokNoPeriodImp
IdTokNoPeriodImp PROC NEAR
	call	IdTokNoPeriod		;parse id token with no period in it
	jl	IdTokExit		;brif PR_BadSyntax
	cmp	[bx.TOK_id_termChar],'.'
	je	J1_PErrExpIdNoPer	;brif token terminated by '.'
	cmp	[bx.TOK_id_oTyp],ET_IMP
	jne	J1_PErrExpIdImp		;brif token has explicit type char
IdGoodExit:
	mov	al,PR_GoodSyntax	;prepare for successful return
IdTokExit:
	or	al,al			;set condition codes for caller
	ret
IdTokNoPeriodImp ENDP

J1_PErrExpIdNoPer:
	mov	ax,MSG_BadElemRef	;identifier can not have "."
J1_PErrMsg_AX:
	jmp	PErrMsg_AX

;*********************************************************************
; IdTokNoPeriod
; Purpose:
;	Parse an id token, where the id cannot have a period in it.
;	Since callers of this function demand an id token, i.e.
;	no other token is possible, this function never returns
;	PR_NotFound, but generates the error instead.
; Entry:
;	[pTokScan] points to current token
; Exit:
;	If token is not an id token:
;	   "Expected id" error message is generated
;	   al = PR_BadSyntax
;	else
;	   al = PR_GoodSyntax
;	   bx points to current token
;	Never returns PR_NotFound because no callers have other options
;	condition codes set based on al
;
;*********************************************************************


PUBLIC	IdTokNoPeriod
IdTokNoPeriod PROC NEAR
	or	[psFlags],PSIF_fNoPeriod
	call	LexReset		;rescan pTokScan if necessary
					; "." terminates id token
	and	[psFlags],NOT PSIF_fNoPeriod
	call	IdTok			;bx points to current token
	je	IdGoodExit		;brif its an id token
J1_PErrExpId:
	jmp	PErrExpId		;error: "Expected id", al=PR_BadSyntax
					; return to caller
IdTokNoPeriod ENDP

;*********************************************************************
;IdSub
;Purpose:
;	Scan an id token and give an error if:
;	  - it begins with FN [QB5]
;	  - it has an explicit type char
;Exit:
;	If not valid id token
;	   generates "Expected id" message and returns PR_BadSyntax
;	Else if id begins with FN and ax was 0 on entry
;	   generates "Can't begin with 'FN'" message and
;	   returns PR_BadSyntax
;	Else if id ends with explicit type char,
;	   generates "Can't end with '%&!#$'" message and
;	   returns PR_BadSyntax
;	Else returns PR_GoodSyntax with bx pointing to token descriptor
;	Never returns PR_NotFound because no callers have other options
;	condition codes set based on value in al
;
;*********************************************************************
IdSub	PROC NEAR
	sub	ax,ax
	sub	ax,ax			;id can't begin with FN
	call	IdTokFn
	jl	IdTokExit		;brif PR_BadSyntax
	cmp	[bx.TOK_id_oTyp],ET_IMP
	je	IdGoodExit		;brif no explicit type char
J1_PErrExpIdImp:
	jmp	PErrExpIdImp		;id can't have %&!#$
					;al = PR_BadSyntax, return to caller
IdSub	ENDP

;*********************************************************************
;IdTokFn
;Purpose:
;	Scan an id token and give an error if:
;	  - it begins with FN, and FN was not expected - or
;	  - it doesn't begins with FN, and FN was expected
;Entry:
;	ax = 0 if FN is not expected, FVI_FNNAME if it is expected
;Exit:
;	If not an id token
;	   generates "Expected id" message and returns PR_BadSyntax
;	Else if id begins with FN and ax was 0 on entry
;	   generates "Can't begin with 'FN'" message and
;	   returns PR_BadSyntax
;	Else if id does not begin with FN and ax was FVI_FNNAME on entry
;	   returns PR_NotFound
;	Else returns PR_GoodSyntax with bx pointing to token descriptor
;	Never returns PR_NotFound because no callers have other options
;	condition codes set based on value in al
;
;*********************************************************************
PUBLIC	IdTokFn
IdTokFn PROC NEAR
	push	ax			;save fExpectingFn
	call	IdTok			;bx points to current token
	pop	cx			;cx = 0 if id can't begin with FN
	je	IdFnGotId		;brif got id token
	jmp	J1_PErrExpId		;error "Expected Id", al = PR_BadSyntax
					;return to caller
IdFnGotId:
	mov	dx,[bx.TOK_id_vmFlags]
	and	dx,FVI_FNNAME		;ax = non-zero if id begins with FN
	cmp	dx,cx
	je	IdGoodExit		;brif FN state is as expected
	mov	ax,MSG_FNstart		;error "Can't start with 'FN'"
	jcxz	J1_PErrMsg_AX		;brif FN not expected
	mov	ax,MSG_ExpFNid
	jmp	PErrExpMsg_AX		;generate error, return al=PR_BadSyntax
IdTokFn	ENDP

;*********************************************************************
; IdTok
; Purpose:
;	See if current token is an id token
; Entry:
;	[pTokScan] points to current token
; Exit:
;	bx points to current token
;	Zero flag is set if token is an id token
;	NOTE: CALLERS ASSUME AL IS PRESERVED
;
;*********************************************************************
PUBLIC	IdTok
IdTok	PROC NEAR
	mov	bx,[pTokScan]
	cmp	[bx.TOK_class],CL_ID
	ret
IdTok	ENDP

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsexp.asm ===
TITLE	prsexp.asm - Parser Expression Recognizer

;==========================================================================
; Module:  prsexp.asm - Parser Expression Recognizer
; Subsystem:  Parser
; System:  Quick BASIC Interpreter
;
;  NOTE:
;	See prsnt.asm for general comments
;
;===========================================================================

	include version.inc
	PRSEXP_ASM = ON 
	includeOnce opaftqb4
	includeOnce prstab
	includeOnce opintrsc
	includeOnce qbimsgs
	includeOnce parser
	includeOnce pcode
	includeOnce psint
	includeOnce variable

	assumes DS,DATA
	assumes SS,DATA
	assumes ES,NOTHING

sBegin	DATA

PREC_lPar EQU	1	;operator precedence for '('
PREC_rPar EQU	1	;operator precedence for ')'
PREC_mark EQU	0	;minimum operator precedence


FOP_unary EQU	1	;flag indicating resword can be a unary operator

;NOTE: order of this table assumes values of IOP_mark through IOP_LParen
; as defined in psint.inc
;
.errnz	IOP_mark	- 0
.errnz	IOP_RParen	- 1
.errnz	IOP_Imp		- 2
.errnz	IOP_Eqv		- 3
.errnz	IOP_Xor		- 4
.errnz	IOP_Or		- 5
.errnz	IOP_And		- 6
.errnz	IOP_Not		- 7
.errnz	IOP_EQ		- 8
.errnz	IOP_LT		- 9
.errnz	IOP_GT		- 10
.errnz	IOP_LE		- 11
.errnz	IOP_GE		- 12
.errnz	IOP_NE		- 13
.errnz	IOP_Add		- 14
.errnz	IOP_Minus	- 15
.errnz	IOP_Mod		- 16
.errnz	IOP_Idiv	- 17
.errnz	IOP_Mult	- 18
.errnz	IOP_Div		- 19
.errnz	IOP_Plus	- 20
.errnz	IOP_UMinus	- 21
.errnz	IOP_Pwr		- 22
.errnz	IOP_LParen	- 23

mpIopOpcode LABEL	WORD
	DW	0			;stack marker
	DW	0			;)			
	DW	opImp			;IMP		
	DW	opEqv			;EQV		
	DW	opXor			;XOR		
	DW	opOr			;OR			
	DW	opAnd			;AND		
	DW	opNot			;NOT		
	DW	opEQ			;=			
	DW	opLT			;<			
	DW	opGT			;>			
	DW	opLE			;<=			
	DW	opGE			;>=			
	DW	opNE			;<>			
	DW	opAdd			;binary+	
	DW	opSub			;binary-	
	DW	opMod			;MOD		
	DW	opIDv			; \			
	DW	opMul			;*			
	DW	opDiv			;/			
	DW	0			;unary+	 (never emitted)
	DW	opUMi			;unary-	
	DW	opPwr			;^			
	DW	opLParen		;(

mpIopPrecedence	LABEL	BYTE
	DB	2*PREC_mark		;stack marker
	DB	2*PREC_rPar		;)			
	DB	2*2			;IMP		
	DB	2*3			;EQV		
	DB	2*4			;XOR		
	DB	2*5			;OR			
	DB	2*6			;AND		
	DB	2*7 + FOP_unary		;NOT		
	DB	2*8			;=			
	DB	2*8			;<			
	DB	2*8			;>			
	DB	2*8			;<=			
	DB	2*8			;>=			
	DB	2*8			;<>			
	DB	2*9			;binary+	
	DB	2*9			;binary-	
	DB	2*10			;MOD		
	DB	2*11			; \			
	DB	2*12			;*			
	DB	2*12			;/			
	DB	2*13 + FOP_unary	;unary+	
	DB	2*13 + FOP_unary	;unary-	
	DB	2*14			;^			
	DB	2*PREC_lPar + FOP_unary;(

	PUBLIC	pExpTos, stkExpInit
;Expression stack constants (see prsexp.asm)
CB_EXP_STK	EQU 64			;number of bytes in expression stack
					; 4 bytes per entry, 16 entries
stkExp		DB CB_EXP_STK DUP (?)	;parse-time expression stack
stkExpMin	EQU stkExp+4		;minimum legal offset for pExpTos
stkExpInit	LABEL BYTE		;value of pExpTos when initialized
pExpTos		DW 0			;points to cur top of expression stack

sEnd	DATA


sBegin	CP
assumes CS,CP

;*********************************************************************/
; ushort NEAR RelOp()
;
; Purpose:
;	Called by NtExp() and NtCaseArg() to parse a relational operator.
;	If a 2-token relational operator is parsed, ScanTok() is called
;	once to consume 1st token.  Caller must always call once ScanTok()
;	to skip past token(s).  It is done this way so NtExp() can be faster
;	& smaller.
;
; Entry:
;	pTokScan points to potential relational operator token
;
; Exit:
;	returns:
;		0 if token is not a relational operator
;		1 for = 
;		2 for < 
;		3 for > 
;		4 for <= 
;		5 for >= 
;		6 for <> 
; 	Condition codes set based on value in ax
;
;*********************************************************************/
;Register usage:
;	di = iOperator
;	si = points to current token
;
cProc	RelOp	<PUBLIC,NEAR,NODATA>,<di>
cBegin	RelOp
	sub	di,di			;default return value to 0
	mov	bx,[pTokScan]		;bx points to current token
RelOpLoop:
	cmp	[bx.TOK_class],CL_resword
	jne	RelOpExit		;brif token isn't a reserved word
	mov	ax,[bx.TOK_rw_iOperator];ax = operator's index (IOP_xxx)
	inc	ax			;test for UNDEFINED
	je	RelOpExit		;brif token isn't an operator

	;Got an operator, see if its a relational operator
	;IOP_xxx is always way less than 255, we can deal with low byte of ax
	sub	al,9			;map =,<,> to 0,1,2
	cmp	al,2
	ja	RelOpExit		;brif token isn't a relational operator
	inc	ax			;map =,<,> to 1,2,3
	or	di,di
	jne	Got2ndChar		;brif we're dealing with 2nd char
					; or relational operator
	xchg	di,ax			;save partial return value in di

	;got a relational operator, see if it is a 2-token
	;relational operator like <>, <=, or >=
	
	call	Peek1Tok		;examine beyond current token
					; bx points to that token
	jmp	SHORT RelOpLoop		;examine 2nd char

;di = 1..3 for 1st char in {=,<,>}
;ax = 1..3 for 2nd char in {=,<,>}
Got2ndChar:
	cmp	ax,di
	je	RelOpExit		;brif same char as 1st (<<, >> or ==)
	inc	ax			;map 2nd char {=,<,>} to 2,3,4
	add	di,ax			;map <=, >=, <> to 4,5,6
	call	ScanTok			;skip 1st relational operator
RelOpExit:
	xchg	ax,di			;ax = return value
	or	ax,ax			;set condition codes for caller
cEnd	RelOp

;*********************************************************************
; STATICF(boolean) PopTillLParen()
;
; Purpose:
;	This is called when we have encountered a right paren while
;	parsing an expression.  It causes all operators which have been
;	stacked to be emitted, up to the matching stacked left paren.
;	If no matching left paren is found on the stack, it means we
;	parsed a sub-expression like x+y), so NtExp() should exit
;	and let its caller parse the right paren.  Maybe it marks the
;	end of a function, sub, or array arg list.
;
; Exit:
;	If 1 left paren was popped of the stack, returns psw.EQ,
;  else if no left parens were found on stack, returns psw.NE
;
;*********************************************************************/
cProc	PopTillLParen	<NEAR,NODATA>,<si,di>
cBegin	PopTillLParen
	mov	si,[pExpTos]		;si points to top of expression stack

PopLoop:				;while (PREC_lPar < *pExpTosReg) {
	cmp	WORD PTR [si],PREC_lPar
	jbe	PopDone
	inc	si			;pop stacked operator's precedence
	inc	si
	lodsw				;pop and emit stacked operator's opcode
	call	Emit16_AX
	jmp	SHORT PopLoop

PopDone:
	mov	[pExpTos],si		;save pointer to top-of-stack

	;if top-of-stack is left paren, return psw.EQ
	cmp	WORD PTR [si],PREC_lPar
cEnd	PopTillLParen

;*********************************************************************
; PARSE_RESULT NEAR NtExp()
;
; Purpose:
;	Parse an expression and emit code for it.
;	Guarenteed to give Expression To Complex error before
;	more than 16 (CB_EXP_STK/4) entries get pushed onto the expression
;	stack.  This controls unrestricted stack (SS) usage.
;
; Entry:
;	pTokScan points to 1st token of expression to be parsed
;	If the static variable [oNamConstPs] is non-zero, intrinsic
;	   functions are not allowed
;
; Exit:
;	pTokScan points to 1st token after expression
;	cIdArgs is bumped by 1 (no matter how much recursion takes place).
;	The return value is PR_GoodSyntax, PR_NotFound or PR_BadSyntax.
;	If the result is not PR_BadSyntax, mkVar.flags is preserved across
;	the call
;	Condition codes set based on value in al
;
;*******************************************************************
cProc	NtExp	<PUBLIC,NEAR,NODATA>,<si,di>
	localB	fConsumed
cBegin	NtExp
	push	[mkVar.MKVAR_flags]	;preserve this for caller

	;Push a low-precedence stopper onto the stack which prevents any
	;operators already on the stack from being emitted as a result of
	;this recursive invocation of NtExp.
	
	sub	[pExpTos],2		;make room for marker on exp stack
	mov	bx,[pExpTos]
	mov	WORD PTR [bx],PREC_mark	;push minimum precedence
	mov	[fConsumed],0		;we haven't consumed anything yet


;-------------------------------------------------------------------
;State which expects a term (function, constant, or variable).
; If we don't get one, we either return PR_BadSyntax if we've consumed
; 1 or more tokens, or PR_NotFound if we've consumed no tokens
;
State1:
	mov	bx,[pTokScan]		;bx points to current token
	mov	ax,[bx.TOK_class]	;ax = token's class
	cmp	al,CL_id
	je	GotId			;brif token is an id
	cmp	al,CL_resword
	je	GotResWord		;brif token is a reserved word
	cmp	al,CL_lit
	jne	NotTerm			;brif token is not a constant
	call	NtLit			;try to parse a constant
					; It is guarenteed that NtLit cannot
					; return PR_NotFound if the token's
					; class is CL_lit
	jmp	SHORT CheckResult

GotId:	call	NtIdAryElem		;Try to parse an id (may recurse)
					; It is guarenteed that NtIdAryElem
					; cannot return PR_NotFound
					; if the token's class is CL_id
	dec	[cIdArgs]		;NtIdAryElem() bumped cIdArgs,
					; NtExp() bumps it on exit, and we are
					; only supposed to bump it once per
					; invocation of NtExp().
CheckResult:
	or	al,al			;test return code
	jg	State2			;brif PR_GoodSyntax
	jmp	NtExpExit		;return PR_BadSyntax result

;bx points to current token's descriptor
GotResWord:
	mov	ax,[bx.TOK_rw_iOperator]
	inc	ax			;test for UNDEFINED
	je	NotOperator		;brif didn't get an operator
	dec	ax			;ax = IOP_xxx for operator
	cmp	al,IOP_Add
	je	Scan_State1		;brif unary plus
					; no need to emit a unary +
	cmp	al,IOP_Minus
	jne	NotMinus		;brif not if unary minus
	mov	al,IOP_UMinus		;convert to unary form of -

;ax = operator index (IOP_xxx) for current token
NotMinus:
	mov	di,ax			;di = operator index
	test	mpIopPrecedence[di],FOP_unary
	je	NotTerm			;brif not a unary operator
	cmp	al,IOP_LParen
	jne	ConsumeOp		;brif token is not '('
					; -- consume & stack/emit operator

	sub	[pExpTos],2
	mov	bx,[pExpTos]
	mov	WORD PTR [bx],PREC_lPar	;push precedence for '('
					; this precedence can only be popped
					; by right paren
	cmp	bx,dataOFFSET stkExpMin
	jb	ExpTooComplex		;brif stack overflow
Scan_State1:
	call	ScanTok			;skip current token
	mov	[fConsumed],1		;Now we can't return PR_NotFound
	jmp	State1			; because we've consumed something

NotOperator:
	call	NtIntrinsic		;try to parse intrinsic function
	jg	SHORT State2		;brif PR_GoodSyntax (change state)
	jl	J1_NtExpExit		;brif PR_BadSyntax
NotTerm:
	cmp	[fConsumed],1
	je	ExpectedExp		;error if we needed to see a term
					; i.e. we've consumed anything
	;else we never even consumed 1 token, return NotFound
	sub	al,al			;return(PR_NotFound)
	jmp	SHORT J1_NtExpExit

;-------------------------------------------------------------------
;Error handler's (placed here so they can be reached by SHORT jumps)
;
ExpTooComplex:
	mov	ax,MSG_ExpTooComplex	;Error: expression too complex
	call	PErrMsg_AX		;produce parser error msg
					; al = PR_BadSyntax
	jmp	SHORT J1_NtExpExit

;we've encountered something like <term><operator><garbage>
;
ExpectedExp:
	mov	ax,MSG_ExpExp		;Error: Expected expression
ExpErrMsg:
	call	PErrExpMsg_AX		;Error: Expected <ax>
					; al = PR_BadSyntax
J1_NtExpExit:
	jmp	NtExpExit

;-------------------------------------------------------------------
;This code is for the state where we are expecting a binary operator
; or end-of-expression
;
State2:
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_resword
	jne	EndOfExp		;brif not reserved word
	mov	ax,[bx.TOK_rw_iOperator];ax = IOP_xxx for token
	inc	ax			;test for UNDEFINED
	je	EndOfExp		;brif its not an operator
	dec	ax			;ax = operator's IOP_xxx
	mov	di,ax			;di = operator's IOP_xxx
	test	mpIopPrecedence[di],FOP_unary
	jne	EndOfExp		;brif not binary operator (exit)
	cmp	al,IOP_RParen		;check for right paren
	jne	NotRightParen		;brif not

	;Now we call PopTillLParen to cause all operators stacked
	; since the last scanned left paren to be emitted.
	; It also detects if the parenthesis for this expression
	; don't balance, i.e.  the expression (a)), in which
	; case we return, because the right paren we're looking
	; at may be for an array reference.  If it is an error,
	; it will be caught by a higher level.
	
	call	PopTillLParen
	jne	EndOfExp		;brif we got a right paren, but it
					; was beyond the expression we were
					; called to parse.  Exit without
					; consuming this right paren.
	add	[pExpTos],2		;pop left paren's precedence
	mov	ax,opLParen		;emit opLParen pcode
	call	Emit16_AX
	call	ScanTok			;skip right paren
	jmp	SHORT State2		;state remains ExpBinaryOp

;Check for relational operator
; di = IOP_xxx for operator
;
NotRightParen:
	call	RelOp			;see if its a relational operator
	je	ConsumeOp		;branch if not
	
	;iop = RelOp() + IOP_EQ - 1
	
	add	al,IOP_EQ - 1		;ax = operator index - IOP_EQ - 1
	xchg	di,ax			;di = IOP for relational operator

;This is executed when we have scanned an operator while parsing
; an expression.  All stacked operators with precedence greator or
; equal to the scanned operator are emitted, then the scanned operator
; is stacked.  This is how we convert infix to postfix (or reverse polish).
; di = IOP_xxx for operator
;
ConsumeOp:
	mov	si,[pExpTos]		;si points to top of exp stack
	mov	al,mpIopPrecedence[di]	;al = operator's precedence
	sub	ah,ah			;ax = operator's precedence
	shl	di,1			;di = IOP_xxx * 2
	push	mpIopOpcode[di]		;save current operator's opcode
	mov	di,ax			;di = operator's precedence
	test	al,FOP_unary
	jne	EmitDone		;brif unary operator (must be stacked
					; until we emit the term it applies to)
EmitLoop:
	cmp	[si],di
	jb	EmitDone		;brif stacked operand's precedence
					; is less than precedence of
					; current operator
					; (i.e. leave relatively high precedence
					;  operators on the stack)
	inc	si			;pop stacked operator's precedence
	inc	si
	lodsw				;pop and emit stacked operator's opcode
	call	Emit16_AX		;emit the stacked opcode
	jmp	SHORT EmitLoop	

EmitDone:
	sub	si,4			;make room for new entry
	mov	[si],di			;push current operator's precedence
	pop	[si+2]			;push current operator's opcode
	mov	[pExpTos],si		;save exp stack ptr
	cmp	si,dataOFFSET stkExpMin
	jbe	J_ExpTooComplex		;brif exp stack overflow
	jmp	Scan_State1		;scan token, advance state

J_ExpTooComplex:
	jmp	ExpTooComplex		;Error: Expression too complex

;Now we call PopTillLParen to cause all operators stacked by this
; recursive invocation of NtExp to be emitted.  It also detects
; if the parenthesis for this expression don't balance, i.e.
; the expression ((a+5)
;
EndOfExp:
	call	PopTillLParen
	jne	ParensBalance		;brif paranthesis are balanced
	mov	ax,MSG_RightParen	;Error: Expected ')'
	jmp	ExpErrMsg

;Now we pop the minimum precedence operator stack marker which was
;stacked when we entered this recursive invocation of NtExp
;
ParensBalance:
	inc	[cIdArgs]
	mov	al,PR_GoodSyntax	;This is (and must remain) the only
					; exit which returns PR_GoodSyntax
NtExpExit:
	add	[pExpTos],2		;pop off initial stopper
	pop	[mkVar.MKVAR_flags]	;restore caller's mkVar.flags
	or	al,al			;set condition codes for caller
cEnd	NtExp

subttl	Intrinsic Function Nonterminal

;**********************************************************************
; PARSE_RESULT NEAR NtIntrinsic()
;
; Purpose:
;	Parse an intrinsic function.
;
; Entry:
;	If the static variable [oNamConstPs] is non-zero, intrinsic
;	   functions are not allowed
;
; Exit:
;	The value of cIdArgs is preserved
;	If no intrinsic is found, no tokens are consumed, no opcodes
;	   are emitted, and the return value is PR_NotFound.
;	If it is found, a corresponding opcode is emitted and
;	   Parse() is called to check the syntax and generate code
;	   for it.  If the syntax for the intrinsic is good, the
;	   return code is PR_GoodSyntax.  If not the return code
;	   is PR_BadSyntax.
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtIntrinsic <PUBLIC,NODATA,NEAR>,<si,di>
cBegin	NtIntrinsic
	sub	al,al			;prepare to return PR_NotFound 
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_resWord
	jne	NtIntrExit		;brif not a reserved word
	mov	dx,[bx.TOK_rw_rwf]	;dx = reserved word flags
	test	dx,RWF_FUNC
	je	NtIntrExit		;brif token isn't for intrinsic func
	cmp	[oNamConstPs],0
	je	NotInCONST		;brif not in CONST a=<expression> stmt
	mov	ax,MSG_InvConst		;Error: Invalid Constant
	call	PErrMsg_AX		; al = PR_BadSyntax
	jmp	SHORT NtIntrExit

NotInCONST:
	push	[pCurStkMark]		;preserve caller's pCurStkMarker
	push	[cIdArgs]		;preserve caller's cIdArgs
	mov	[cIdArgs],0		;reset cIdArgs to 0 for this
					; intrinsic function's code generator
	;Fetch info for a particular intrinsic function out of the
	;parser's reserved word table 'tRw'.
	
	mov	si,[bx+TOK_rw_pArgs]	;si -> pRwArgs in tRw
	lods	WORD PTR cs:[si]	;ax=state table offset for func's syntax
	mov	cx,ax			;cx=state table offset
	sub	di,di			;default to no code generator
	test	dx,RWF_FUNC_CG
	je	NoFuncCg		;branch if no code generator for func
	lods	WORD PTR cs:[si]	;ax=adr of code generation func
	mov	di,ax			;di=adr of code generation func
	lods	WORD PTR cs:[si]	;ax=arg to pass to code generation func
	mov	si,ax			;si=code generation arg
NoFuncCg:
	push	cx			;pass oState to Parse
	call	ScanTok			;skip keyword token 
	pop	ax			;ax = oState
	add	ax,OFFSET CP:tState	;ax = pState = &(tState[oState])
	mov	[pStateLastScan],ax
	call	NtParse			;try to parse intrinsic function
	jle	NtIntrNotGood		;branch if result isn't PR_GoodSyntax
	or	di,di
	je	NtIntrGoodSyntax	;branch if no function code generator
	mov	ax,si			;pass arg to code generation routine
					; (usually, this is an opcode)
	call	di			;invoke code generation routine 
NtIntrGoodSyntax:
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
	jmp	SHORT NtIntrRestore

NtIntrNotGood:
	jl	NtIntrRestore		;branch if result == PR_BadSyntax
	call	PErrState		;Generate error message "Expected
					; <a> or <b> or ..." 
					;al = PR_BadSyntax
NtIntrRestore:
	pop	[cIdArgs]		;restore caller's cIdArgs
	pop	[pCurStkMark]		;restore caller's pCurStkMarker
NtIntrExit:
	or	al,al			;set condition codes for caller
cEnd	NtIntrinsic

subttl	Literal Nonterminals

UNARY_LIT EQU 0
	;	Used when CASE could only be followed by literal instead of Exp.
	;	May easily be useful for some future construct.
	;	Handles up to 1 unary minus.  Could easily be changed
	;	to handle unary +, we would just need to add the opcode.

;**********************************************************************
; PARSE_RESULT NEAR NtLit()
;
; Purpose:
;	Parse any form of literal and, if found, generate a corresponding
;	literal opcode.
;
; Exit:
;	Returns either PR_GoodSyntax, PR_NotFound or PR_BadSyntax
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtLit <PUBLIC,NODATA,NEAR>,<si,di>
cBegin	NtLit
	mov	di,[pTokScan]		;di points to current token
	cmp	[di.TOK_class],CL_lit
	jne	LitNotFound		;brif already got a unary op
	sub	ax,ax
	or	al,[di.TOK_lit_errCode]	;ax = lexical analyzer's error code
	jne	LitSnErr		;brif lexical analyzer found an error
					; in literal's format
	lea	si,[di.TOK_lit_value_I2];si points to literal's value
	mov	bl,[di.TOK_lit_litType]	;bl = LIT_xxx for literal
	cmp	bl,LIT_STR
	je	GotLitSD
	cmp	bl,LIT_I2
	jne	@F			;branch if not a decimal integer
	mov	ax,[si] 		;ax = value
	cmp	ax,opLitI2Max		; Is value within pcode limit
	ja	@F			;branch if value isn't 0..10
	.erre	OPCODE_MASK EQ 03ffh	; Assure following code is ok
	mov	ah,al			
	mov	al,0			; AX = literal * 0100h
	shl	ax,1			; AX = literal * 0200h
	shl	ax,1			; AX = literal * 0400h
	add	ax,opLitI2		;opcode = opLitI2 w/value in upper bits
	call	Emit16_AX
	jmp	SHORT NtLitGoodSyntax

@@:
	sub	bh,bh			;bx = LIT_xxx for literal
	mov	al,[tLitCwValue + bx]	;al = # words in literal's value
	sub	ah,ah			;ax = # words in literal's value
	mov	di,ax			;di = # words in literal's value
	shl	bx,1			;bx = 2 * LIT_xxx for literal
	mov	ax,[tLitOpcodes + bx]	;ax = opcode
	call	Emit16_AX		;emit the opcode
EmitLitLoop:
	lodsw				;ax = next word of literal's value
	call	Emit16_AX
	dec	di
	jne	EmitLitLoop		;branch if more words to emit
	jmp	SHORT NtLitGoodSyntax

;Got a string constant like "xxxxxxx"
;Emit all source characters between the double quotes.
;If <cbText> is odd, <cbText> is emitted as an odd value,
;and an extra pad byte is appended to keep pcode even-byte alligned.  
;
GotLitSD:
	mov	ax,opLitSD
	call	Emit16_AX
	mov	ax,[di.TOK_oSrc]	;ax = column token started in
	inc	ax			;ax = oSrc + 1 (skip ")
	push	ax			;pass it to EmitSrc
	mov	ax,[si]			;ax = length of string literal in bytes
					;TOK_lit_value_cbStr
	push	ax			;pass size of string to EmitSrc
	call	Emit16_AX		;emit size of the string
	call	EmitSrc			;emit the string itself
NtLitGoodSyntax:
	call	ScanTok			;skip literal token
	mov	al,PR_GoodSyntax
NtLitExit:
	or	al,al			;set condition codes for caller
cEnd	NtLit

LitNotFound:
	sub	ax,ax			;prepare to return PR_NotFound
	jmp	SHORT NtLitExit		;brif we didn't consume unary opcode

;ax = error encountered by lexical analyzer when scanning number
LitSnErr:
	call	PErrMsg_AX		; al = PR_BadSyntax
	jmp	SHORT NtLitExit

sEnd CP
sBegin DATA

;Tables used by NtLit

;Following tables assume following constants:
OrdConstStart 0
OrdConst LIT_I2		; % suffix
OrdConst LIT_O2		; &O prefix
OrdConst LIT_H2		; &H prefix
OrdConst LIT_I4		; & suffix
OrdConst LIT_O4		; &&O prefix
OrdConst LIT_H4		; &&H prefix
OrdConst LIT_R4		; ! suffix
OrdConst LIT_R8		; # suffix
OrdConst LIT_STR	; "xxx"
tLitOpcodes LABEL WORD
	DW	opLitDI2		;LIT_I2	 (% suffix)
	DW	opLitOI2		;LIT_O2	 (&O prefix)
	DW	opLitHI2		;LIT_H2	 (&H prefix)
	DW	opLitDI4		;LIT_I4	 (& suffix)
	DW	opLitOI4		;LIT_O4	 (&&O prefix)
	DW	opLitHI4		;LIT_H4	 (&&H prefix)
	DW	opLitR4			;LIT_R4	 (! suffix)
	DW	opLitR8			;LIT_R8	 (# suffix)

tLitCwValue LABEL BYTE
	DB	1			;LIT_I2	 (% suffix)
	DB	1			;LIT_O2	 (&O prefix)
	DB	1			;LIT_H2	 (&H prefix)
	DB	2			;LIT_I4	 (& suffix)
	DB	2			;LIT_O4	 (&&O prefix)
	DB	2			;LIT_H4	 (&&H prefix)
	DB	2			;LIT_R4	 (! suffix)
	DB	4			;LIT_R8	 (# suffix)

sEnd DATA
sBegin CP

;**********************************************************************
; PARSE_RESULT NEAR NtLitI2() - Parse & emit 16-bit integer
; Purpose:
;	Parse and emit a 16-bit signed integer.  Note this is very
;	different from NtLit() in that it emits no opcode, just
;	a 16 bit value.  It is the responsibility of the caller
;	to emit the opcode before calling this function.
;	If a numeric literal is found, but it is > 32k,
;	an Overflow error message is generated.
; Exit:
;	Returns PR_GoodSyntax, PR_BadSyntax or PR_NotFound
;	Condition codes set based on value in al
;
;******************************************************************
PUBLIC	NtLitI2
NtLitI2	PROC NEAR
	sub	al,al			;prepare to return PR_NotFound
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_lit
	jne	NtLitI2Exit		;branch if token isn't a literal
	cmp	[bx.TOK_lit_type],ET_I2
	jne	NtLitI2Ov		;brif token isn't a signed 16 bit int
	mov	ax,[bx.TOK_lit_value_I2];ax = value
	call	Emit16_AX		;emit it
	call	ScanTok			;consume token
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
NtLitI2Exit:
	or	al,al			;set condition codes for caller
	ret

NtLitI2Ov:
	mov	ax,ER_OV		;Overflow
	jmp	PErrMsg_AX		;al = PR_BadSyntax
					; return to caller
NtLitI2	ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtLit0() - Parse the literal 0, emit nothing
;******************************************************************
PUBLIC	NtLit0
NtLit0	PROC NEAR
	sub	cx,cx			;expect constant 0
NtLit1Shared:
	sub	al,al			;prepare to return PR_NotFound
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_lit
	jne	NtLit0Exit		;branch if token isn't a literal
	cmp	[bx.TOK_lit_type],ET_I2
	jne	NtLit0Exit		;brif token isn't a signed 16 bit int
	cmp	[bx.TOK_lit_value_I2],cx
	jne	NtLit0Exit		;branch if token isn't 0
	call	ScanTok			;consume token
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax
NtLit0Exit:
	ret
NtLit0	ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtLit1() - Parse the literal 1, emit nothing
;******************************************************************
PUBLIC	NtLit1
NtLit1	PROC NEAR
	mov	cx,1			;expect constant 1
	jmp	SHORT NtLit1Shared
NtLit1	ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtLitString() - Parse a string literal
;******************************************************************
cProc	NtLitString <PUBLIC,NODATA,NEAR>
cBegin	NtLitString
	sub	al,al			;prepare to return PR_NotFound
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_lit_type],ET_SD
	jne	NtLitStringExit		;branch if token isn't string constant
	call	NtLit			;ax = result of parsing the string
NtLitStringExit:
cEnd	NtLitString

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prslex.asm ===
TITLE	prslex.asm - Parser's Lexical Analyzer (token fetcher)

;=============================================================================
; prslex.asm - Parser's Utility Functions
;
; Copyright <C> 1985, Microsoft Corporation
;
; Purpose:
;	Contains QBI Lexical Analyzer Functions
;
;
;=============================================================================

	include version.inc
	PRSLEX_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	exint		;needed for CoR4R8
	includeOnce	heap
	includeOnce	names
	includeOnce	parser
	includeOnce	prstab
	includeOnce	prsirw
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	txtmgr
	includeOnce	variable	;for FVI_FNNAME [3]

	assumes DS,DGROUP
	assumes SS,DGROUP
	assumes ES,NOTHING


sBegin	DATA

	extrn	$i8_inpbas:byte		; inpbas now supported in AltMath


;List of bytes which, when they follow digits, mean its not an I2
tbFloat	label byte
	db	'.' - '0'
	db	'e' - '0'
	db	'E' - '0'
	db	'd' - '0'
	db	'D' - '0'
	db	'&' - '0'
	db	'!' - '0'
	db	'#' - '0'
	db	'%' - '0'  ;even though % means integer, its not fast-path
			   ;through the code (would slow down typical cases
			   ;to check for % in TryI2)
CB_tbFloat EQU $-tbFloat

sEnd	DATA

sBegin	CP
assumes CS,CP

QUOTE	=	022H			;quote char (")

; It is assumed that all classes of characters < TC_PERIOD are valid
; in identifiers.

OrdConstStart	0
OrdConst	TC_UCASE	;* Upper Case Alpha
OrdConst	TC_LCASE	;* Lower Case Alpha
OrdConst	TC_NUM		;* numeric (or .)
OrdConst	TC_PERIOD	;* "." (record separator / number / part of id)
OrdConst	TC_NEWLINE	;* end-of-line
OrdConst	TC_WHITE	;* white space (tab or space)
OrdConst	TC_SPECIAL	;* special character
OrdConst	TC_PRINT	;* '?' (short hand for PRINT)
OrdConst	TC_RW	;* special character reserved word

typChar LABEL	BYTE
	DB	TC_NEWLINE ; NUL
	DB	TC_SPECIAL ; SOH
	DB	TC_SPECIAL ; STX
	DB	TC_SPECIAL ; ETX
	DB	TC_SPECIAL ; EOT
	DB	TC_SPECIAL ; ENQ
	DB	TC_SPECIAL ; ACK
	DB	TC_SPECIAL ; BEL
	DB	TC_SPECIAL ; BS
	DB	TC_WHITE   ; HT
		;Tabs are expanded to spaces in GetLineBd.
		;Don't be tempted to do it at lex time because
		;if ReParse, source buffer is copied to pcode.
	DB	TC_NEWLINE ; LF
	DB	TC_SPECIAL ; VT
	DB	TC_SPECIAL ; FF
	DB	TC_NEWLINE ; CR
	DB	TC_SPECIAL ; SO
	DB	TC_SPECIAL ; SI
	DB	TC_SPECIAL ; DLE
	DB	TC_SPECIAL ; DC1
	DB	TC_SPECIAL ; DC2
	DB	TC_SPECIAL ; DC3
	DB	TC_SPECIAL ; DC4
	DB	TC_SPECIAL ; NAK
	DB	TC_SPECIAL ; SYN
	DB	TC_SPECIAL ; ETB
	DB	TC_SPECIAL ; CAN
	DB	TC_SPECIAL ; EM
	DB	TC_SPECIAL ; SUB
	DB	TC_SPECIAL ; ESC
	DB	TC_SPECIAL ; FS
	DB	TC_SPECIAL ; GS
	DB	TC_SPECIAL ; RS
	DB	TC_SPECIAL ; US

	DB	TC_WHITE ; spc
	DB	TC_RW + IRW_EtSingle ; !
	DB	TC_RW + IRW_DQuote ; "
	DB	TC_RW + IRW_Lbs ; #
	DB	TC_RW + IRW_EtString ; $
	DB	TC_RW + IRW_EtInteger ; %
	DB	TC_RW + IRW_EtLong ; &
	DB	TC_RW + IRW_SQuote ; '
	DB	TC_RW + IRW_LParen ; (
	DB	TC_RW + IRW_RParen ; )
	DB	TC_RW + IRW_Mult ; *
	DB	TC_RW + IRW_Add ; +
	DB	TC_RW + IRW_Comma ; ,
	DB	TC_RW + IRW_Minus ; -
	DB	TC_PERIOD ; .
	DB	TC_RW + IRW_Div ; /
	DB	TC_NUM ; 0
	DB	TC_NUM ; 1
	DB	TC_NUM ; 2
	DB	TC_NUM ; 3
	DB	TC_NUM ; 4
	DB	TC_NUM ; 5
	DB	TC_NUM ; 6
	DB	TC_NUM ; 7
	DB	TC_NUM ; 8
	DB	TC_NUM ; 9
	DB	TC_RW + IRW_Colon ; :
	DB	TC_RW + IRW_SColon ; 
	DB	TC_RW + IRW_LT ; <
	DB	TC_RW + IRW_EQ ; =
	DB	TC_RW + IRW_GT ; >
	DB	TC_PRINT ; ?

	DB	TC_SPECIAL ; @
	DB	TC_UCASE ; A
	DB	TC_UCASE ; B
	DB	TC_UCASE ; C
	DB	TC_UCASE ; D
	DB	TC_UCASE ; E
	DB	TC_UCASE ; F
	DB	TC_UCASE ; G
	DB	TC_UCASE ; H
	DB	TC_UCASE ; I
	DB	TC_UCASE ; J
	DB	TC_UCASE ; K
	DB	TC_UCASE ; L
	DB	TC_UCASE ; M
	DB	TC_UCASE ; N
	DB	TC_UCASE ; O
	DB	TC_UCASE ; P
	DB	TC_UCASE ; Q
	DB	TC_UCASE ; R
	DB	TC_UCASE ; S
	DB	TC_UCASE ; T
	DB	TC_UCASE ; U
	DB	TC_UCASE ; V
	DB	TC_UCASE ; W
	DB	TC_UCASE ; X
	DB	TC_UCASE ; Y
	DB	TC_UCASE ; Z
	DB	TC_RW + IRW_LParen ; map '[' to '(' for BASICA compatibility
	DB	TC_RW + IRW_Idiv ; \
	DB	TC_RW + IRW_RParen ; map ']' to ')' for BASICA compatibility
	DB	TC_RW + IRW_Pwr ; ^
	DB	TC_SPECIAL; _ (underscore)

	DB	TC_SPECIAL ; `
	DB	TC_LCASE ; a
	DB	TC_LCASE ; b
	DB	TC_LCASE ; c
	DB	TC_LCASE ; d
	DB	TC_LCASE ; e
	DB	TC_LCASE ; f
	DB	TC_LCASE ; g
	DB	TC_LCASE ; h
	DB	TC_LCASE ; i
	DB	TC_LCASE ; j
	DB	TC_LCASE ; k
	DB	TC_LCASE ; l
	DB	TC_LCASE ; m
	DB	TC_LCASE ; n
	DB	TC_LCASE ; o
	DB	TC_LCASE ; p
	DB	TC_LCASE ; q
	DB	TC_LCASE ; r
	DB	TC_LCASE ; s
	DB	TC_LCASE 
	DB	TC_LCASE ; u
	DB	TC_LCASE ; v
	DB	TC_LCASE ; w
	DB	TC_LCASE ; x
	DB	TC_LCASE ; y
	DB	TC_LCASE ; z
	DB	TC_SPECIAL ; {
	DB	TC_SPECIAL ; |
	DB	TC_SPECIAL ; }
	DB	TC_SPECIAL ; ~
	DB	TC_SPECIAL ; DEL




subttl	FindRw

;================ External Procedures Referenced by this module ========


;***************************************************************************
; NEAR BOOL FindRw(pToken, pSym, cbSym, fStr)
; Purpose:
;	Search the reserved word table for a specified symbol.
;
; Entry:
;	'pToken' points to descriptor for current token being fetched
;	'pSym' points to the 1st byte of the symbol to search for.
;	'cbSym' = number of bytes in symbol (always assumed to be > 1)
;	'fStr' is true if the symbol was terminated by "$".
;	[ES] = [DS]
;	NOTE: This assumes reserved word table is ordered ALPHABETICALLY
;
; Exit:
;	If the reserved word was not found,
;	   returns with carry clear
;	else
;	   returns with carry set
;	The fields of the token structure are filled in with the description
;	of the reserved word.
;	[11]In EB FindRw may also determine that the string passed to it is a
;	command equivalent name in which case the token structure is filled
;	in describing it.
;
;*******************************************************************************
; Register allocation within procedure:
;	si is always pointing to next byte in reserved word table
;	di = temporary copy of pbSym
;	cx = temporary copy of cbSym

cProc	FindRw	<PUBLIC,NEAR>, <si,di>
	ParmW	pToken			;ptr to token being built
	ParmW	pSym			;ptr to 1st byte of name to search for
	ParmW	cbSym			;byte count of name to search for
	ParmB	fStr			;TRUE if name ends with '$'

	localW	nStmts			;num statements that begin with
					; this reserved word

cBegin	FindRw
	mov	si,[pSym]		;si points to 1st letter of id
	lodsb				;al = 1st letter of id
	dec	[cbSym] 		;decrement byte count for same reason
	sub	al,'A'			;al = (0..25) for (A..Z) 
	cbw	
	cmp	al,'Z'-'A'		
	ja	WordNotFound1		;brif first letter can not start RW
	shl	ax,1			;ax = word index into tRw
	xchg	si,ax			;si = index into tRw
	mov	si,WORD PTR cs:tRw[si]	;si->res word table for 1st letter of id

	;======================================================
	; NOTE: Beginning of block which has DS->CP (not DGROUP)
	;	If any static variables need be accessed in this
	;	block, access them with an ES override.
	;======================================================
	push	cs
	pop	ds			;ds = Code Segment (CP)
	assumes DS,CP

	lodsw				;[ax] = res word index for 1st entry
	mov	bx,ax			;iRw = res word index for 1st entry
	mov	cx,[cbSym]		;initialize
	jmp	SHORT NextEntry

;Register usage:
; dx points to next entry in reserved word table
; bx contains the res word index for current symbol
; si points into current reserved word table entry
; 
CbsInWord:				
	lodsw				;al = #bytes of attributes
					;ah = #bytes in reserved word
	jmp	SHORT GotCbs		

TryNextWord:
	mov	cx,[cbSym]		;cx = byte count for that name
TryNextWordCX:
	inc	bx
	mov	si,dx			;si points to start of next entry
NextEntry:
	lodsb				;al = size of next entry
					; high 4 bits = #bytes in name
					; low 4 bits = #bytes of attributes
	or	al,al
	jz	WordNotFound		;brif end of this res word table
	inc	al			
	jz	CbsInWord		;brif counts are in following word
	dec	al			

	mov	ah,al			;ah = #bytes in name * 16
	and	al,0FH			;al = #bytes of attributes
	shr	ah,1			;ah = #bytes in name * 8
	shr	ah,1			;ah = #bytes in name * 4
	shr	ah,1			;ah = #bytes in name * 2
	shr	ah,1			;ah = #bytes in name
GotCbs:
	mov	dl,ah			;dl = #bytes in name
	add	dl,al			;dl = #bytes in name & attributes
	sub	dh,dh			;dx = #bytes in name & attributes
	add	dx,si			;dx->next entry
	cmp	ah,cl
	jne	TryNextWordCX		;brif name lengths not equal
	mov	di,[pSym]
	inc	di			;di->2nd byte of name to search for
	rep cmpsb			;compare pSym with res word entry
	jc	TryNextWord		;brif pSym is alphabetically > this
					;entry in res word tbl.
	jne	WordNotFound		;brif names are not identical
					;and pSym is alphabetically < this
					;entry in res word tbl.
	lodsb				;al = flags byte
	sub	ah,ah			;ah = STRING:FALSE
	test	al,RWF_STR
	je	NotStr
	mov	ah,1			;ah = STRING:TRUE
NotStr:
	cmp	ah,[fStr]
	jne	TryNextWord		;brif one name ends with $ and
					; the other doesn't (no match)

;At this point, we have found a match in the reserved word table.
;
	push	ss
	pop	ds			;restore DS = DGROUP
	assumes DS,DGROUP
	;======================================================
	; NOTE: End of block which has DS->CP
	;======================================================
	mov	di,[pToken]		;di -> token descriptor being built
	mov	[di.TOK_class],CL_RESWORD
	mov	[di.TOK_rw_rwf],ax	;pToken->dsc.rwf = res word flags
	test	al,RWF_OPERATOR
	mov	ax,UNDEFINED
	je	NotOper 		;brif res word is not an operator
	lods	BYTE PTR cs:[si]	;al = IOP_xxx index for res word
	sub	ah,ah			;ax = IOP_xxx index for res word
NotOper:
	mov	[di.TOK_rw_iOperator],ax;save it in pToken
	mov	[di.TOK_rw_iRw],bx	;save res word's unique index
	mov	[di.TOK_rw_pArgs],si	;save ptr to func/stmt args
	stc				;tell caller reserved word was found
	jmp	SHORT FindRwExit	;exit function

WordNotFound:
	push	ss
	pop	ds			;restore DS = DGROUP
WordNotFound1:
	clc				;tell caller reserved word not found
FindRwExit:
cEnd	FindRw


subttl	FetchToken

;*********************************************************************
; VOID PLM NEAR FetchToken(di:pToken)
;
; Purpose:
;  This is the lexical analyzer for BASIC.  It scans
;  ASCII text and sets fields in the structure pToken
;  which identify the scanned token.
;  It filters out white space such as tabs, newlines, and spaces.
;
; Entry:
;  di (pToken) points to the receiving token descriptor structure.
;	ps.bdpSrc is a buffer descriptor which holds current line being parsed
;
; Exit:
;  The structure pointed to by pToken is filled in
;     id:
;	 pToken->class = CL_ID
;	 pToken->dsc.id.oNam = ONamOfPbCb offset for the identifier.
;	 pToken->dsc.id.oTyp = explicit type which followed
;	    identifier (ET_IMP for implicit, ET_I2 for % ET_R8 for # etc.)
;	 pToken->dsc.id.charFirst = [0..25] if 1st letter is [A..Z]
;	    used to determine default type for implicit variable references
;	 pToken->dsc.id.vmFlags has one or more of the following bits set:
;		FVI_FNNAME if id began with FN
;		(Even though MakeVariable ignores value of FVI_FNNAME in
;		 mkVar.flags, we set it for parser's own internal use).
;	 pToken->dsc.id.lexFlags has one or more of the following bits set:
;		FLX_hasPeriod if id has '.' in it
;     lit:
;	 pToken->class = CL_LIT
;	 pToken->dsc.lit.type = type of value (ET_I2, ET_SD etc.)
;	 pToken->dsc.lit.litType = type of literal (LIT_I2, LIT_H2, LIT_J2 etc.)
;	 pToken->dsc.lit.value.I2 = value of 2 byte integer.
;	 pToken->dsc.lit.value.I4 = value of 4 byte integer.
;	 pToken->dsc.lit.value.R4 = value of 4 byte real.
;	 pToken->dsc.lit.value.R8 = value of 8 byte real.
;	 pToken->dsc.lit.value.cbStr = number of bytes in string literal.
;
; Algorithm:
;	From first character, determine what class the token is,
;	and then take class specific action to consume it.
;
;*********************************************************************

cProc	FetchToken <PUBLIC,NEAR>, <si>
	localV	namBuf,CB_IDNAM_MAX+2	
	localW	cbId
	localW	endOfGO
	localW	tokFlags
	localB	firstChar
	localB	lastChar
	localB	charType

cBegin	FetchToken
	DbChkPsStk			;see if this is a new high-water stack
	and	[psFlags],NOT PSIF_fLexPeriodOk
	push	ds			;set up es register for string copy
	pop	es
	mov	si,[ps.PS_bdpSrc.BDP_pbCur]
SkipWhiteSpace_0:
	mov	ax,si			;ax -> next source byte to be fetched
	sub	ax,[ps.PS_bdpSrc.BDP_pb]
	mov	[di.TOK_oSrc],ax	;pToken->oSrc = ps.bdpSrc.pbCur -
					; ps.bdpSrc.pb	tells parser where
					; token began in source buffer
	sub	ah,ah			;ax = al (code below assumes ah=0)
	jmp	short SkipWhiteSpace_1
SkipWhiteSpace:
	inc	[di.TOK_oSrc]		;Just do this if we know we just read
					;  a single char
SkipWhiteSpace_1:
	lodsb				;al = next source byte
	mov	dl,al			;save current char in dl
	or	al,al
	js	NotASCII2		;branch if al is not a 7-bit ASCII char

	mov	bx,CPOFFSET typChar	;bx->table to map char to char-class
	xlat	BYTE PTR cs:[bx]	;al = ax = character type
NotASCII1:
	cmp	al,TC_RW
	jnb	ResWord			;brif this is a 'res word' char
					; like +,* etc.
; At this point we have either an alpha, a numeric, white space,
; end-of-line character, or a special character which BASIC doesn't consider
; part of its character set.  Dispatch based on the character-class.
; This can result in a numeric literal, id, reserved word, or special char.
; ax = character type, dl = char
;
NotResWord:
	mov	bx,ax
	shl	bx,1			;bx = index into dispatch table
	jmp	[bx + CaseJmpTbl]	;dispatch to case

ResWord:
	;We have a non-alpha-numeric char.  Try to map it
	; to a reserved word/operator
	
	sub	al,TC_RW		;al = ax = IRW (res word index)
	mov	[di.TOK_rw_iRw],ax	;save it in token descriptor
	mov	[di.TOK_class],CL_RESWORD
	mov	[di.TOK_rw_rwf],0	;res word is not a stmt/func
	mov	bx,OFFSET CP:mpIRWtoIOP ;bx -> table for mapping RW to IOP
	xlat	BYTE PTR cs:[bx]	;al = IOP (operator) index for res word
					;ax = IOP since ah is still 0
	or	al,al
	js	NotOperator		;brif this res word char isn't an
					; operator
	mov	[di.TOK_rw_iOperator],ax
	jmp	UpdateSrcPtr		;save si in ps.PS_bdpSrc.BDP_pbCur and exit

NotASCII2:
	mov	al,TC_SPECIAL		;all chars >127 are special chars
	jmp	SHORT NotASCII1

;The special character we parsed is not an operator,
; Try '&<number>' or "<quoted string literal>"
; dl = current source char, its not an operator
NotOperator:
	mov	[di.TOK_rw_iOperator],UNDEFINED
	cmp	dl,'&'
	je	GotLit			;brif numeric literal like &Hffff
	cmp	dl,QUOTE
	jne	J_UpdateSrcPtr		;branch if current char is not "
	mov	dx,si			;dx points to 1st char in literal
LoopInString:
	lodsb				;al = next byte of source
	cmp	al,QUOTE
	je	EndOfString
	or	al,al
	jne	LoopInString		;brif we're not at end-of-line
	dec	si			;so next call to FetchToken will
					; re-fetch end-of-line
	dec	dx			;adjust dx so length comes out right
EndOfString:
	mov	ax,si			;ax points beyond last char of literal
	sub	ax,dx			;ax = # chars since start of token
	dec	ax			;don't count the last double quote
	mov	WORD PTR [di.TOK_lit_value_cbStr],ax
	mov	[di.TOK_class],CL_LIT
	mov	[di.TOK_lit_type],ET_SD
	mov	[di.TOK_lit_litType],LIT_STR
	mov	WORD PTR ([di.TOK_lit_errCode]),0 ;set errCode and flags field
	.errnz	TOK_lit_flags - TOK_lit_errCode - 1
J_UpdateSrcPtr:
	jmp	UpdateSrcPtr		;save si in ps.PS_bdpSrc.BDP_pbCur and exit

	
sEnd CP
sBegin DATA
CaseJmpTbl	LABEL	WORD
	dw	Got_TC_ALPHA		;Upper Case
	dw	Got_TC_ALPHA		;Lower Case Alpha
	dw	GotLit			;0-9
	dw	Got_TC_PERIOD		;.
	dw	Got_TC_NEWLINE		;End-of-line Character
	dw	SkipWhiteSpace		;White Space Character
	dw	Got_TC_SPECIAL		;Special Character
	dw	Got_TC_PRINT		;? = shorthand for "PRINT"
sEnd DATA
sBegin CP
assumes CS,CP

;got a "." at start of token.  It may be a number, or a record separator
Got_TC_PERIOD:
	mov	al,[si]
	cmp	al,'0'
	jb	Got_TC_SPECIAL		;brif char after "." isn't 0-9
	cmp	al,'9'
	ja	Got_TC_SPECIAL		;brif char after "." isn't 0-9
;0-9 or .
GotLit:
	;Call ScanLit, trapping runtime overflow errors
	mov	WORD PTR [di.TOK_lit_errCode],0 ;zero errCode and flags
	.errnz	TOK_lit_flags - TOK_lit_errCode - 1
	PUSHI	ax,<CODEOFFSET ScanLit>
	call	CallRtTrap_CODE 	; al = 0 if no error, else ER_OV
					; in QBJ version ax may be error
					; for bad KANJI constant
	mov	[di.TOK_lit_errCode],al ;return error code
	jmp	UpdateSrcPtr		;save si in ps.PS_bdpSrc.BDP_pbCur and exit

;End-of-line Character
Got_TC_NEWLINE:
	mov	[di.TOK_class],CL_RESWORD
	mov	[di.TOK_rw_iRw],IRW_NewLine
	mov	[di.TOK_rw_rwf],0	;res word is not an operator/stmt/func
	mov	[di.TOK_rw_iOperator],UNDEFINED
	jmp	ExitFetchToken		;don't save new si in
					;ps.PS_bdpSrc.BDP_pbCur so next call to
					;FetchToken will get the same token
					;until a new line is read into ps

;Special Character
Got_TC_SPECIAL:
	mov	[di.TOK_class],CL_UNKNOWNCHAR
	mov	[di.TOK_unknownChar_unknownChar],dl
	cmp	dl,'_'
	jne	NotLineCont		;brif not underscore
	FLoadActive
	je	NotLineCont		;brif not loading a file
	dec	si			;don't include _ in logical line
	mov	bx,dataOFFSET ps.PS_bdpSrc ;pass pbd in bx
	sub	si,[bx.BD_pb]		;si = #bytes in buffer before _
	mov	cx,si			;pass cbAppend in cx
	call	GetLineBd		;append next physical line to current
					; buffer
SkipWhiteSpace_2:
	mov	[di.TOK_oSrc],si	;update current offset
	add	si,[ps.PS_bdpSrc.BDP_pb] ;si = ptr to next byte after _
	sub	ah,ah			;ax = al (SkipWhiteSpace_1 assumes ah=0)
	jmp	SkipWhiteSpace_1

NotLineCont:
	jmp	UpdateSrcPtr		;save si in ps.PS_bdpSrc.BDP_pbCur and exit

;While scanning a token, we found a FN followed by a space.
;In all versions of BASIC, FN xxx is treated the same as FNxxx.
;Squeeze source of ' 'out of pcode buffer
;because we need to call ONamOfPbCb with case sensitive FNxxx
;BdShiftLeft((bd *)&ps.bdpSrc, oSpace, 1)
;
FNspace:
	pop	di			;restore di points to token descriptor
	PUSHI	ax,<dataOFFSET ps.PS_bdpSrc>
	mov	ax,si
	dec	ax			;ax points to space
	sub	ax,[ps.PS_bdpSrc.BDP_pb] ;ax = offset to space
	push	ax			;pass oSpace
	PUSHI	ax,1			;shift 1 byte left
	call	BdShiftLeft		;causes no heap movement
	mov	si,[di.TOK_oSrc]	;si points to start of FNxxx
	jmp	SkipWhiteSpace_2	;re-scan token

;Convert '?' into "PRINT"
Got_TC_PRINT:
	push	di			;save ptr to result token descriptor
	lea	di,[namBuf]		;di -> temporary name buffer
	mov	ax,'RP' 		;namBuf = "PRINT"
	stosw
	mov	ax,'NI'
	stosw
	mov	al,'T'
	stosb
	mov	[lastChar],al		;anything but '$'
	inc	si			;compensate for dec si below
	mov	ax,5			;[ax] = #chars in "PRINT"
	pop	di			;di points to result token descriptor
	jmp	GotId	

;Upper and Lower Case Alpha
Got_TC_ALPHA:				
	mov	cx,CB_IDNAM_MAX+1	
	sub	ax,ax
	mov	[di.TOK_id_lexFlags],al
	mov	[endOfGO],ax		;assume we're not looking at 'GO'
	mov	[tokFlags],ax		;default flags = 0
	push	di			;save ptr to result token descriptor
	lea	di,[namBuf]		;di -> temporary name buffer
	mov	[di],ax			;init first two bytes of namBuf
					; to 0 so the "cmp [namBuf],'NF'"
					; below will always work.
	mov	al,dl			;al = source char
IdLoop0:
	mov	bx,CPOFFSET typChar	;bx->table to map char to char-class
GotInternational:			

;Loop to convert id to upper case and copy to temp buffer
; In the case of GO TO	or  GO SUB, we copy the entire reserved word
; into namBuf, squeezing out any white space after 'GO'.  The goal
; is to make people who use GO TO pay more than people who use GOTO.
; At this point,
;	al = UCASE(current source char)
;	si points to next source char
;	di points to destination of next char of id
;	bx points to typChar table
;	cx = max number of chars left in identifier
;	es = ds = DGROUP
;
IdLoop:
	and	al,0DFh 		;force to upper case
					;Note that it is OK to do this even
					;if char is numeric, since no res words
					;contain numerics, if it is numeric,
					;it will never match.
	stosb				;store UCASE(source char) in temp buf
	lodsb				;al = next source char
	dec	cx
	jcxz	IdTooLong 		;branch if name length exceeded
IdLoop1:
	or	al,al			;test for non-ascii char ( > 127)
	js	GotNonASCII		;branch if we got a non ASCII char

	mov	dl,al			;save current char in dl
	xlat	BYTE PTR cs:[bx]	;al = ax = character type
	cmp	al,TC_PERIOD
	xchg	ax,dx			;dl = char type, al=char
	jb	IdLoop			;brif got an alpha or numeric
	jne	EndOfId 		;brif didn't get a "."
	test	[psFlags],PSIF_fPeriodOk OR PSIF_fLexPeriodOk
	jne	IdLoop			;brif "." can be part of id token
	cmp	[nambuf],'NF'
	je	IdLoop			;brif FNxxx.xxx (def fn ids can have
					; periods in them)

GotNonASCII:
	mov	dl,TC_SPECIAL

;al = char which terminated id (may be '$','#' etc.)
;dl = type of last char (TC_xxx)
;si points beyond char which terminated string
;
EndOfId:
	mov	[lastChar],al		;save last char
	mov	[charType],dl		;save type of terminator
	mov	ax,CB_IDNAM_MAX+1	
	sub	ax,cx			;ax = # chars in id
	mov	dx,[nambuf]
	cmp	al,2
	jne	NotGO			;branch if id can't be 'GO'
	cmp	dx,'OG'			;in namBuf, least sig byte comes last,
					; so GO == 'OG'
	jne	NotGO			;branch if id isn't 'GO'
	cmp	[lastChar],' '
	jne	NotGO			;branch if not 'GO' followed by space
	mov	[endOfGO],si		;save ptr to end of 'GO'
;Skip white space, then try to find GO TO or GO SUB
SkipSpc:
	lodsb
	cmp	al,' '
	jne	IdLoop1
	jmp	SHORT SkipSpc

;Got an id which was too long - generate tricky error message.
;If we didn't call ParseErr before PErrMsg_AX, PErrMsg_AX would call NtEndStmt
;which would recursively call FetchToken, which would be bad news.
;
IdTooLong:
	pop	bx			;bx points to result token descriptor
					; for error column reporting
	push	bx			;re-save it on stack
	mov	ax,PSERR_fAlert + MSG_IdTooLong
	call	IdErr
	mov	cx,1			;only pass 40 byte name to ONamOfPbCb
	mov	al,[si]
	jmp	SHORT EndOfId		; it can't handle anything longer

;Got 'FN' as start of name
;di points beyond of name in nambuf, ax=length of name, dx = [nambuf]
FNid:
	cmp	al,2
	jne	NotFN2			;brif we got more than just FN
	cmp	[lastChar],' '		
	jne	IllegalFNid		;brif FN not followed by ' '
					; will get error like "Expected FNid"
	jmp	FNspace			;treat FN x  like  FNx

IllegalFNid:
	pop	di			;di points to result token descriptor
	mov	bx,di
	mov	ax,PSERR_fAlert + MSG_BadId
	call	IdErr
	jmp	SkipWhiteSpace_0	;re-scan token

;Got FNxxx, not just FN
NotFN2:
	or	[tokFlags],FVI_FNNAME	;set FVI_FNNAME bit in tok.id.flags
	mov	dl,[namBuf+2]		;dl = UCASE(1st char beyond FN)
	cmp	dl,'A'			
	jae	NotGO_Cont		;brif got FN<letter>xxx
	cmp	dl,('.'	AND 0DFh)	;test if char was a '.' before 
					; anding with '.'
	jne	IllegalFNid 		;brif got FN<digit>xxx
	mov	dl,26+'A'		;'.' maps to 26 (Z+1)
					; FN.xxx is always single precision
	jmp	short NotGO_Cont

;di points beyond of name in nambuf, ax=length of name, dx = [nambuf]
NotGO:
	cmp	dx,'NF'			;test for 'FN' (FN == 'NF' because
					; in namBuf, least sig byte comes last)
	je	FNid			;brif got 'FN'

;dl=1st letter of name (or 3rd letter of FNname)
;ax=length of name, [lastChar]=terminator
NotGO_Cont:
	pop	di			;di points to result token descriptor
	mov	[firstChar],dl

;di points to token descriptor, ax=length of name, [lastChar]=terminator
GotId:
	mov	[cbId],ax		;save byte count of id
	cmp	al,1
	je	NotResWordId		;1 letter id can't be res word
	cmp	[lastChar],'.'
	je	NotResWordId		;res word can't be followed by period

	push	di			;pass ptr to token descriptor to FindRw
	lea	bx,namBuf
	push	bx			;pass ptr to UCASE(1st char)
	push	ax			;pass char count
	sub	ax,ax			;fStr = FALSE
	cmp	[lastChar],'$'
	jne	CallFindRw		;brif id terminator <> '$'
	inc	ax			;fStr = TRUE
CallFindRw:
	push	ax			;pass fStr
	call	FindRw
	jnc	NotResWordId

	;Got a valid reserved word
	cmp	[lastChar],'$'
	je	J1_UpdateSrcPtr		;brif res word not terminated by '$'
	dec	si			;next FetchChar will refetch terminator
J1_UpdateSrcPtr:
	jmp	short UpdateSrcPtr	;save si in ps.PS_bdpSrc.BDP_pbCur and exit

;[tokFlags] = tok.id.flags
NotResWordId:
	mov	al,[firstChar]
	sub	al,'A'			;map A..Z to 0..25, period to 26
	mov	[di.TOK_id_charFirst],al;so parser can set default type
					; Also used for DEFxxx A-X
	mov	ax,[tokFlags]
	mov	[di.TOK_id_vmFlags],ax
	mov	cx,[endOfGO]
	jcxz	NotGoId 		;brif we didn't parse 'go id'
	mov	si,cx			;si -> 1st byte after 'go '
	mov	[cbId],2
	jmp	SHORT GotImplicitId

NotGoId:
	;following code assumes IRW_EtInteger...IRW_<last expl. type char>
	; are contiguous
	mov	al,[charType]
	sub	al,TC_RW + IRW_EtInteger
	cmp	al,CBASETYPEMAX - 1	;cmp al to number of explicit types
	jb	GotExplicitType
GotImplicitId:
	dec	si			;next FetchChar will refetch terminator
	mov	al,ET_IMP		;can't be $,%,&,!, or #
	jmp	SHORT SaveType

GotExplicitType:
	add	al,ET_I2
SaveType:
	sub	ah,ah
	mov	[di.TOK_id_oTyp],ax
	mov	ax,[ps.PS_bdpSrc.BDP_pb]
	mov	[ps.PS_bdpSrc.BDP_pbCur],si ;NOTE: ONamOfPbCb can cause heap to move
					; so save current text pointer
	add	ax,[di.TOK_oSrc]	;ax points to 1st byte of id
					;  (parm to ONamOfPbCb)
	mov	cx,[cbId]		;#bytes in id - also parm to ONamOfPbCb
	test	[ps.PS_flags],PSF_fParseExp
	jne	DontSaveCase		;brif called to parse a Watch Expression
	test	[psFlags],PSIF_NoCaseChg
	jne	DontSaveCase
	cmp	[grs.GRS_fDirect],FALSE
	je	SaveCase		;brif not parsing direct mode stmt
DontSaveCase:
	or	ch,80h			;highbit says don't change case
					; of existing namtbl id, so user
					; can type alpha in the command window
					; and it doesn't change Alpha to
					; alpha in his list window.
SaveCase:
	call	ONamOfPbCb		;nammgr returns ax = oNam, dl = flags
	je	ONamErr			;brif ONamOfPbCb failed
	mov	[di.TOK_id_oNam],ax	;save nammgr's handle for the name
	cmp	[lastChar],'.'
	je	IdPeriod
NotIdPeriod:
	mov	[di.TOK_class],CL_ID
	mov	al,[lastChar]
	mov	[di.TOK_id_termChar],al
	jmp	SHORT ExitFetchToken

;save si in ps.PS_bdpSrc.BDP_pbCur and exit
UpdateSrcPtr:
	mov	[ps.PS_bdpSrc.BDP_pbCur],si
ExitFetchToken:
cEnd	FetchToken

ONamErr:	       			
	call	ParseErrOm		;tell ParseLine to return out-of-mem err
J1_Got_TC_NEWLINE:
	jmp	Got_TC_NEWLINE		;return new-line - ends parsing of line

;ax = oNam of id which was terminated with "."
IdPeriod:
	test	[psFlags],PSIF_fNoPeriod ;don't stop for periods
	jne	NotIdPeriod		;brif scanning id which cannot have .
	test	dl,NM_fAS		;dl still set from ONamOfPbCb call
	jne	NotIdPeriod		;brif id has been seen in "x AS" clause
					; in which case x.y is 3 tokens

	;set PSIF_fLexPeriodOk so IdLoop won't stop for periods
	;set PSIF_fLineHasPeriodId so ParseLine knows line has 'a.b' id in line
	; so it will emit an opNoType at end of line - helps txtmgr
	
	or	[psFlags],PSIF_fLineHasPeriodId + PSIF_fLexPeriodOk
	or	[di.TOK_id_lexFlags],FLX_hasPeriod
	mov	si,[ps.PS_bdpSrc.BDP_pbCur] ;si points to '.' after id
	mov	cx,CB_IDNAM_MAX+2	
	mov	ax,[cbId]
	sub	cx,ax			;cx = num bytes left
	push	di			;save token ptr back on stack
					; so we can jump back into IdLoop
	lea	di,nambuf
	add	di,ax			;di points to destination for next byte
	mov	al,'.'
	push	ds
	pop	es			;es = DGROUP
	jmp	IdLoop0



;=====================================================================
;	   T O K E N   S C A N N I N G	 F U N C T I O N S
;
;	The idea is to maintain a circular queue of tokens for "Look Ahead".
;	There are 4 offsets into this circular queue of particular interest:
;	   pTokLast points to the most recent token scanned by 'FetchToken'.
;	   pTokPeek points to the last token returned by 'Peek1Tok' or
;	      'PeekNextTok'.
;	   pTokScan points to the last token returned by 'ScanTok'.
;		It is the chronologically oldest token we care
;	        about, or the opposite end of the queue from pTokLast.
;	   pTokLastConsumed points to the last token consumed by 'ScanTok'.
;		This token was the previous value of pTokScan. It is useful
;		in some special cases for checking for syntax errors and
;		generating the correct column offset.
;
;======================================================================

;*********************************************************************
; VOID NEAR ScanTok()
;
; Purpose:
;	Advance 'pTokScan' to point to the next non white-space token in
;	the circular token queue.  Note that if PeekNextTok has already
;	fetched the token we're interested in, this function does
;	very little work (i.e. doesn't need to call FetchToken).
; Exit:
;	bx points to current token (same as pTokScan)
;
;*********************************************************************
PUBLIC	ScanTok
ScanTok PROC NEAR
	inc	[cTokScan]		;bump token count so NtParse
					; knows to return PR_GoodSyntax
					; instead of PR_NotFound
	mov	ax,[pStateCur]
	mov	[pStateLastScan],ax	;used for error reporting
	mov	ax,[pTokScan]		;ax points to current 'scan' token
	mov	[pTokLastConsumed],ax	;update pointer to last consumed tok
	mov	bx,ax	 		;bx points to current 'scan' token
	add	ax,CB_TOK		;advance to next token
	cmp	ax,dataOFFSET tLookAhead + (LOOK_AHEAD * CB_TOK)
	jb	ScanNoWrap		;brif if not wrapped around
	mov	ax,dataOFFSET tLookAhead;ax points to 1st token descriptor
ScanNoWrap:
	mov	[pTokScan],ax		;save ptr to new 'scan' token

;bx points to previous token of interest
;ax points to next token of interest
ScanFetch:
	cmp	[pTokLast],bx
	jne	ScanGotOne		;brif token we want has already been
					; fetched by PeekNextToken
					;else circular queue is empty,
					; fetch a new entry
	mov	[pTokLast],ax		;advance pTokLast as well
	push	di
	mov	di,ax			;di points to new token
	call	FetchToken		;fill in token structure di
	mov	bx,di			;return token ptr in bx
	pop	di
ScanGotOne:
	ret
ScanTok ENDP

;Entry:
;	ax = error code
;	bx = token descriptor
;
IdErr	PROC NEAR
	cmp	[ps.PS_errCode],0
	jne	Not1stErr		;brif not 1st error for this line
	call	ParseErr
Not1stErr:
	ret
IdErr	ENDP

;*********************************************************************
; VOID NEAR Peek1Tok()
;
; Purpose:
;	Set 'pTokPeek' pointing to the 1st non white-space token after
;	'pTokScan' for look-ahead.
; Exit:
;	bx points to current token (same as pTokPeek)
;
;*********************************************************************
;*********************************************************************
; VOID NEAR PeekNextTok()
;
; Purpose:
;	Advance 'pTokPeek' to point to the next non white-space token in
;	the circular token queue for look-ahead.
; Exit:
;	bx points to current token (same as pTokPeek)
;
;*********************************************************************
PUBLIC	Peek1Tok
Peek1Tok PROC NEAR
	mov	ax,[pTokScan]		;pTokPeek = pTokScan
	mov	[pTokPeek],ax
	;fall into PeekNextTok
Peek1Tok ENDP
PUBLIC	PeekNextTok
PeekNextTok PROC NEAR
	mov	ax,[pTokPeek]		;ax points to current 'peek' token
	mov	bx,ax			;bx points to current 'peek' token
	add	ax,CB_TOK		;advance to next token
	cmp	ax,dataOFFSET tLookAhead + (LOOK_AHEAD * CB_TOK)
	jb	PeekNoWrap		;brif if not wrapped around
	mov	ax,dataOFFSET tLookAhead;ax points to 1st token descriptor
PeekNoWrap:
	mov	[pTokPeek],ax		;save ptr to new 'peek' token
	jmp	SHORT ScanFetch 	;share code with ScanToken
PeekNextTok	ENDP

;**********************************************************************
; boolean NEAR TestScan_AX
; Purpose:
;	See if current token is a particular reserved word
; Entry:
;	pTokScan points to current token
;	ax = IRW_xxx for reserved word to be tested
; Exit:
;	bx = [pTokScan]
;	psw.z set if current token is desired reserved word
;
;*******************************************************************
PUBLIC	TestScan_AX
TestScan_AX PROC NEAR
	mov	bx,[pTokScan]		;bx points to current token
TestPeek_AX1:
	cmp	[bx.TOK_class],CL_resWord
	jne	TestScan_AXExit 	;if not res word, return NE
	cmp	ax,[bx.TOK_rw_iRw]	;if not expected one, return NE
TestScan_AXExit:
	ret
TestScan_AX ENDP

;**********************************************************************
; boolean NEAR TryScan_AX
; Purpose:
;	See if current token is a particular reserved word and if it
;	is then consume it.
; Entry:
;	pTokScan points to current token
;	ax = IRW_xxx for reserved word to be tested
; Exit:
;	if not matched then psw.z is cleared and bx = [pTokScan]  
;	otherwise psw.z is set
;
;*******************************************************************
PUBLIC	TryScan_AX
TryScan_AX PROC NEAR
	call	TestScan_Ax		;test for the reserved word
	jne	TrySExit		;brif not matched
	call	ScanTok			;consume it
	xor	ax,ax			;set psw.z
TrySExit:
	ret
TryScan_AX ENDP

;**********************************************************************
; boolean NEAR TestPeek_AX
; Purpose:
;	See if current PEEK token is a particular reserved word
; Entry:
;	pTokPeek points to next token
;	ax = IRW_xxx for reserved word to be tested
; Exit:
;	bx = [pTokPeek]
;	psw.z set if token is desired reserved word
;
;******************************************************************
PUBLIC	TestPeek_AX
TestPeek_AX PROC NEAR
	mov	bx,[pTokPeek]		;bx points to next token
	jmp	SHORT TestPeek_AX1
TestPeek_AX ENDP

;**********************************************************************
; boolean NEAR ConsumeRw_AX(ax:iRw)
; Purpose:
;	Make sure that the current token is the reserved word 'iRw'.
; Entry:
;	ax is offset into reserved word table for res word to be consumed
; Exit:
;	If reserved word was not found
;	   a complete error message is generated
;	   al = PR_BadSyntax
;	   carry is set
;	Else
;	   token is consumed
;	   bx = [pTokScan]
;	   carry is clear
;
;*******************************************************************
PUBLIC	ConsumeRw_AX
ConsumeRw_AX PROC NEAR
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_resWord
	jne	ConRwErr		;branch if token isn't reserved word
	cmp	[bx.TOK_rw_iRw],ax	;compare with expected res word
	jne	ConRwErr		;branch if didn't get expected one
	call	ScanTok 		;consume token
	clc				;return SUCCESS
	ret

ConRwErr:
	call	PErrExpRw_AX		;Error "Expected <reserved word>"
					; al = PR_BadSyntax
	stc				;return error flag
	ret
ConsumeRw_AX ENDP

;*********************************************************************
; LexReset
; Purpose:
;	Reset the lexical analyzer's source pointer to the 1st char
;	of pTokScan's token.  This flushes the token peek-ahead queue.
;
;*********************************************************************
PUBLIC	LexReset
LexReset PROC NEAR
	mov	bx,[pTokScan]
	mov	[pTokLast],bx
	mov	ax,[bx.TOK_oSrc]
	add	ax,[ps.PS_bdpSrc.BDP_pb]
	mov	[ps.PS_bdpSrc.BDP_pbCur],ax ;setup to rescan same token
	jmp	ScanTok 		;bx points to current token
					;return to caller
LexReset ENDP

sEnd	CP


sBegin	CODE
assumes CS,CODE

;*********************************************************************
; void ScanLit
;	This function is based on code lifted from BASCOM
; Purpose:
;	Scan a number
; Entry:
;	si points beyond 1st source char in number
;	di points to token descriptor to be filled in on exit
; Exit:
;	si points to char which terminates number
;	token pointed to by di is filled in
;	If an error occurred, a runtime error is generated with
;	   a standard error msg (ER_xxx or MSG_xxx)
;
;*********************************************************************
l_s16inv=	80h		; 16 bit signed value is invalid
l_ind=		80h		; indefinite
l_inv=		40h		; invalid (no digits or syntax error)
l_s32inv=	20h		; 32 bit signed value is invalid
l_u32inv=	10h		; 32 bit unsigned value is invalid
l_long= 	08h		; l_Dexp or more than 7 digits
l_Dexp= 	04h		; explicit 'D' or 'd' seen
l_Rexp= 	02h		; explicit 'E' or 'e' seen
l_inf=		01h		; DP overflow

dbPub	ScanLit
cProc	ScanLit,<FAR>			
cBegin	ScanLit				
	dec	si			;si points to 1st letter of number
	mov	[di.TOK_CLASS],CL_LIT	;token class = Literal
	push	di			;save pointer to token descriptor
	add	di,TOK_lit_value_R8	;di points to number's result field
	cmp	byte ptr [si],'&'	; check for special radix constant
	jne	DNSgetnum		;   no - normal number

;	read special radix numbers as unsigned 16 or 32 bit integers

	inc	si			; skip past 1st &
	lodsb				; get next character (H or O)
	or	al,20h			; map letter to lower case
	mov	bx,(LIT_H4 * 100h) + 10h; assume hex
	cmp	al,'h'
	je	DNSerad 		;   yes

	mov	bx,(LIT_O4 * 100h) + 8	; assume octal
	cmp	al,'o'
	je	DNSerad 		;   yes


	dec	si			; must be octal - move back pointer
DNSerad:
	push	bx			; save bh = LIT_xxx
	xor	bh,bh			; bx = bl = base
	call	DoInput			; [bx:ax] = result if integer/long
	pop	dx			; [dh] = LIT_xxx
	pop	di			; di points to token descriptor

	test	cl,l_u32inv		; check if overflow error
	jnz	DNSovr
	test	cl,l_inv		; check syntax err
	jnz	DNSsyn
	cmp	byte ptr [si],'&'	; long?
	je	EatExpLng		; brif explicitly LONG
	or	bx,bx			; if BX<>0, can't be 16-bit integer
	je	ItsShort		
	cmp	byte ptr [si],'%'	; short?
	jne	DNSradlng		; brif not explicitly SHORT
;Overflow error
DNSovr:
	mov	ax,ER_OV		; input number overflow
	jmp	SHORT DNSerr

EatExpLng:
	inc	si			; consume '&'
	jmp	SHORT DNSradlng

ItsShort:
	sub	dh,3			; map LIT_x4 to LIT_x2
.errnz	LIT_H4 - LIT_H2 - 3		; in case values of constants change
.errnz	LIT_O4 - LIT_O2 - 3		; in case values of constants change
	cmp	byte ptr [si],'%'	; short?
	jne	DNSradint		; brif not explicit SHORT
	inc	si			; consume '&'
;dh = literal type (LIT_xxx)
DNSradint:
	mov	dl,ET_I2		; integer
DNSradintlng:
	mov	[di.TOK_lit_value_I2],ax	; save low part of integer
	xchg	ax,dx			; al = value type, ah = literal type
	jmp	DNSchkdbl		; save type and exit

;dh = literal type (LIT_xxx)
DNSradlng:
	mov	dl,ET_I4		; long integer
	mov	[di.TOK_lit_value_I2+2],bx	; save high part of long integer
	jmp	SHORT DNSradintlng

DNStyp:
	inc	si			; eat invalid type character
DNSsyn:
	mov	ax,MSG_IllegalNumber	; input number syntax error
DNSerr:
	call	RtErrorCODE		; error (ax)

DNSgetnum:
	call	TryI2		;if its an I2, don't call $i8_input (pig slow)
	jc	NotAnI2		;brif not a valid I2
	pop	di		;restore token pointer
	mov	dh,LIT_I2
	jmp	SHORT DNSradint	;brif AX = valid I2

NotAnI2:
	xor	bx,bx		; (BX) = 0 (default radix)
	call	DoInput		; [bx:ax] = result if integer/long
				; [di] = R8 result
	pop	di		; di points to token descriptor

	test	cl,l_inv+l_ind	; check if syntax error
	jnz	DNSsyn
	test	cl,l_inf	; check if d.p. overflow
	jnz	DNSovr

;	check if number could be 16-bit integer

	test	cl,l_s32inv	; check if valid 32-bit integer
	jnz	DNSinv16	;   no - not valid 16-bit either
	cwd
	cmp	bx,dx
	je	DNSchkexp

DNSinv16:
	or	cl,l_s16inv	; mark as invalid 16-bit integer

;	check for explicit E or D

DNSchkexp:
	test	cl,l_Rexp+l_Dexp ; check if explicit E or D
	jz	DNSchktyp	;  no - test for explicit type char
	or	[di.TOK_lit_flags],FLIT_exp
	jmp	SHORT DNSsav	;  explicit types not allowed

;	check if trailing type character

DNSchktyp:
	cmp	byte ptr [si],'#' ; double precision?
	je	DNSdbl		  ;   yes
	cmp	byte ptr [si],'!' ; single precision?
	je	DNSsng		  ;   yes
	cmp	byte ptr [si],'%' ; integer?
	je	DNSint		  ;   yes
	cmp	byte ptr [si],'&' ; long?
	jne	DNSsav		  ;   no

DNSlng:
	test	cl,l_s32inv	; check if valid 32-bit integer
	jnz	DNStyp		;   no - type character error
	or	cl,l_s16inv	; force it long
	jmp	SHORT DNSsavi

DNSint:
	test	cl,l_s16inv	; check if valid 16-bit integer
	jnz	DNStyp		;   no - type character error
	jmp	SHORT DNSsavi

DNSdbl:
	or	cl,l_long+l_s32inv+l_s16inv ; force it double
	jmp	SHORT DNSsavi


DNSsng:
	and	cl,not l_long	; force it single
	or	cl,l_s32inv+l_s16inv

DNSsavi:
	inc	si		; skip over explicit type character

;	have number - now save it

DNSsav:
	mov	dh,LIT_I2
	test	cl,l_s16inv	; check if 16-bit integer
	jz	jDNSradint	;   yes

DNSchklng:
	mov	dh,LIT_I4
	test	cl,l_s32inv	; check if 32-bit integer
	jz	jDNSradlng	;   yes

DNSchksng:
	mov	ax,(LIT_R8 * 100h) + ET_R8	;assume double precision
	test	cl,l_long	; check if double
	jnz	DNSchkdbl	;   yes

	push	di		;save ptr to token descriptor

	add	di,TOK_lit_value_R8	;di -> number's result field
	fld	qword ptr [di]	;pass R8 value
	fstp	dword ptr [di]	;pop R4 value
	pop	di		;di points to token descriptor
	mov	ax,(LIT_R4 * 100h) + ET_R4	;single precision
	fwait			

; al = value type, ah = literal type
DNSchkdbl:
	mov	[di.TOK_lit_type],al	; value type (ET_xxx)
	mov	[di.TOK_lit_litType],ah ; constant type (LIT_xxx)
DNSxit:
cEnd	ScanLit				


jDNSradint:
	jmp	DNSradint

jDNSradlng:
	jmp	DNSradlng

DoInput PROC NEAR
	mov	cx,[ps.PS_bdpSrc.BDP_pb] ;cx = start of bdpSrc buffer
	add	cx,[ps.PS_bdpSrc.BDP_cbLogical] ;cx = end of bdpSrc buffer+1
	sub	cx,si			;cx = remaining number of bytes in
					;     buffer past si
	xor	ax,ax			; no scale factor
	cwd				; (DX) = 0 (FORTRAN garbage)
	mov	[$i8_inpbas],1		; use BASIC sematics for E and D
	push	bp
	extrn	$i8_input:near
	call	$i8_input		; [bx:ax] = long integer
	pop	bp
	mov	[$i8_inpbas],0		; clear BASIC input flag
	ret
DoInput ENDP


;*********************************************************************
;TryI2
;Purpose:
;	Try to parse an I2 so we don't have to call $i8_input (its slow)
;Entry:
;	si points to 1st digit of number
;Exit:
;	if valid I2 was consumed,
;	   carry is clear
;	   si points beyond last digit of number
;	else
;	   carry is set
;	   si points to 1st digit of number
;
;*********************************************************************
dbpub	TryI2
cProc	TryI2,<NEAR>
cBegin
	push	si
	sub	dx,dx			;acc=0
NextDigit:
	lodsb				;al = next digit
	sub	al,'0'			;map '0'..'9' to 0..9
	jc	EndOfDigits		;brif < '0'
	cmp	al,9
	ja	EndOfDigits
	cmp	dx,3275d
	ja	NotI2			;brif result could be > 32759
	add	dx,dx			;acc = acc*2
	mov	cx,dx			;cx  = acc*2
	add	dx,dx			;acc = acc*4
	add	dx,dx			;acc = acc*8
	add	dx,cx			;acc = acc*10
	cbw
	add	dx,ax			;acc = acc*10 + new digit
	jmp	SHORT NextDigit

;al = terminating digit - '0'
EndOfDigits:
	mov	bx,ax			;bl = terminating digit - '.'
	push	di
	push	ds
	pop	es			;es = DGROUP
	lea	di,tbFloat		;si points to table of letters that
					; would mean the number is not an I2
	mov	cx,CB_tbFloat
	repne	scasb			;search for found opcode in table
	pop	di
	je	NotI2			;brif terminated with '.'
	pop	ax			;discard entry si
	dec	si			;si points to terminating digit
	xchg	ax,dx			;return result in dx
	clc
	jmp	SHORT TryI2Exit

NotI2:
	pop	si			;restore ptr to start of digits
	stc
TryI2Exit:
cEnd

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsmain.asm ===
TITLE	prsmain.asm - Parser Main Module

;==========================================================================
;
;  Module:  prsmain.asm - Parser Main Module
;  Subsystem:  Parser
;  System:  Quick BASIC Interpreter
;
;==========================================================================

	include		version.inc
	PRSMAIN_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	names
	includeOnce	opcontrl
	includeOnce	opid
	includeOnce	opmin
	includeOnce	parser
	includeOnce	pcode
	includeOnce	prsirw
	includeOnce	prstab
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	util
	includeOnce	stack2			

;--------------------------------------------------------------------------
;
;  The BIC Parser is a table driven recursive descent parser.
;  Because it is used by the Interpreter, it can make no assumptions
;  about the order in which it sees statements.  This means it has
;  to consider each statement as an atomic unit.  Checking syntax
;  which spans multiple statements, like matching FOR NEXT statements,
;  is left to the static scanner, a separate BIC component.
;
;  The parser receives tokens from FetchToken().  For the interpreter,
;  it produces an infix pcode stream.  For the compiler, it returns
;  the top node of a syntax tree.
;
;  The fundamental Control hierarchy of the parser component is as follows:
;
;                      (ParseLine)
;                            |
;             +-----------------------------+
;             |                             |
;       (ParseLabelOrLineNum)            (Parse)
;             |       |                     |
;             +----+  | +--------+----------|
;                  |  | |        |          |
;                (ScanTok)  (Peek1Tok)      |
;                     |          |          |
;                     +-------+--+          |
;                             |         (NtXXXX)
;                         (FetTok)
;                             |
;                        (FetchToken)
;                         | |  |
;                         | |  |
;             +-----------+ |  |
;             |             |  |
;      [ONamOfPbCb] ($i8input) |
;                              |
;                          (FindRw)
;
;=========================================================================*
;
;  The tables which this module uses to perform its parsing are produced
;  by the utility program 'buildprs' (a recursive descent parser generator).
;  See 'parser.doc' for a definition of how these parse tables are built.
;  The following is an example of how they are used.
;  The lexical analyzer recognizes all reserved words.  When it encounters
;  one, it returns a pointer to a structure which shows all the opcodes
;  which map to this reserved word, as well as whether or not it is
;  a legal keyword to start a statement or intrinsic function.
;  If it can start a statement or intrinsic function, this list also contains
;  an offset into the parser state table which describes the syntax for
;  the statement/function.  The following is an example of how CALL would
;  be parsed.
;
;    Reserved-Word-Table    Syntax-State-Table
;      CALL---------+
;                   |
;                   +-----> s24: [id->s27]  [error]
;                           s27: ["("->s31]  [empty->accept]
;                           s31: [svar->s36]  [exp->s43]  [error]
;                           s36: ["("->s40]  [empty->s43]
;                           s40: [")"->s43]  [error]
;                           s43: [","->s31]  [")"->accept]  [error]
;
;    This state table represents the following state transition graph:
;
;               ID        (        svar       (         )         )
;    CALL (s24)---->[s27]---->(s31)---->(s36)---->(s40)---->(s43)---->[]
;                         +-->   |         +------------+-->   |
;                         |      |  exp                 |      |
;                         |      +----------------------+      |
;                         |                          ,         |
;                         +------------------------------------+
;
;
;
;    Where [sn] is a "final" or "accepting" state, and (sn) is not.
;
;--------------------------------------------------------------------

assumes	ds,DATA
assumes	ss,DATA
assumes	es,NOTHING


sBegin	DATA
PUBLIC	stkChkParse, psFlags
stkChkParse	DW 0
psFlags		DB 0			;general purpose parser internal flags

bdParseUndo	DB SIZE bd DUP(0)	;buffer used by ParseUndo()


sEnd	DATA


sBegin	CP
assumes	cs,CP

;--------------------------------------------------------------------
;           P A R S E - A - L I N E    F U N C T I O N S
;--------------------------------------------------------------------

;*********************************************************************
;EmitLabel
;	Emit a label definition (i.e. opBol, opBolSp, opBolLabSp etc.)
; Entry:
;	di = 0 for line number, 1 for alpha label:
;	si = name table offset for label/line number
;Exit:
;	appropriate label opcode is emitted
;	carry set if duplicate label error
;Uses:	di
;
;*********************************************************************
EmitLabel PROC NEAR
	push	si			;pass label to FlagOfONam
	call	FlagOfONam		;ax = name's flags
	test	al,NM_fLineNumLabel
	jne	DupLabel		;brif linenum already declared
	mov	ax,[ps.PS_bdpSrc.BDP_pbCur]
	sub	ax,[ps.PS_bdpSrc.BDP_pb] ;ax = number of leading blanks
	push	ax
	call	ScanTok			;skip label
	dec	di
	jnz	LineNum			;brif not alpha label
	call	ScanTok			;skip ':'
LineNum:
	pop	ax			;ax = number of leading blanks
	mov	bx,[pTokScan]
	mov	di,[bx.TOK_oSrc]
	sub	di,ax			;di = updated # of leading blanks
	cmp	di,1
	jbe	NoLeadingBlanks		;brif not 2 or more leading blanks
	cmp	[ps.PS_bdpDst.BDP_cbLogical],0
	mov	ax,opBolLabSp
	je	Bol1			;brif we're at beginning of line
					; i.e. no pcode has been emitted yet
	mov	ax,opLabSp
Bol1:
	call	Emit16_AX		;emit the opcode
	call	Emit16_0		;leave room for link field
	push	si
	call	Emit16			;emit oNam field
	push	di			;emit count of leading blanks
	jmp	SHORT ElEmit

NoLeadingBlanks:
	cmp	[ps.PS_bdpDst.BDP_cbLogical],0
	mov	ax,opBolLab
	je	Bol2			;brif we're at beginning of line
	mov	ax,opLab
Bol2:
	call	Emit16_AX		;emit the opcode
	call	Emit16_0		;leave room for link field
	push	si
ElEmit:
	call	Emit16			;emit oNam field
	clc
ElExit:
	ret

DupLabel:
	mov	ax,ER_DL OR PSERR_fAlert ;report duplicate label
	call	ParseErrTokScan		;ParseErr(ax)
	stc				;set carry to indicate error
	jmp	SHORT ElExit
EmitLabel ENDP

;*********************************************************************
;EmitBol
;Purpose:
;	Emit an opBol, opBolSp, opBolInclude, or opBolIncludeSp
;Entry:
;	ax = opBolInclude or opBol
;
;*********************************************************************
EmitBol	PROC NEAR
	mov	bx,[pTokScan]
	mov	cx,[bx.TOK_oSrc]	;ax = #bytes leading spaces
	jcxz	NoSpc			;brif no leading blanks
	.errnz	opBol
	or	ax,ax
	jne	NotOpBol		;brif not opBol
	cmp	cx,24d
	ja	NotOpBol		;brif too many spaces
	.errnz	OPCODE_MASK - 3FFh
	mov	ah,cl			;ax = 256 * cSpaces
	shl	ax,1			;ax = 512 * cSpaces
	shl	ax,1			;ax = 1024 * cSpaces
	jmp	SHORT NoSpc

NotOpBol:
	push	cx			;pass cb to Emit16 (below)
	inc	ax			;map opBol->opBolSp
					;    opBolInclude->opBolIncludeSp
	call	Emit16_AX
	mov	al,[cInclNest]		;al = $INCLUDE nesting depth (0 if none)
	and	ax,0FFh			;ax=al, can't use cbw--doesn't set flags
	je	NotIncl1		;brif not an included line
	call	Emit16_AX		;emit $INCLUDE nesting depth
NotIncl1:
	pop	ax			;ax = #leading blanks
	jmp	Emit16_AX		;emit the #leading blanks pushed above
					; and return to caller

NoSpc:
	call	Emit16_AX		;emit opcode
	mov	al,[cInclNest]		;al = $INCLUDE nesting depth (0 if none)
	and	ax,0FFh			;ax=al, can't use cbw--doesn't set flags
	je	NotIncl2		;brif not an included line
	call	Emit16_AX		;emit $INCLUDE nesting depth
NotIncl2:
	ret
EmitBol	ENDP

;*********************************************************************
; STATICF(VOID) ParseLineNumAndLabel()
;
; Purpose:
;	Parse an optional line number and/or label definition and emit
;	pcode for them.  If no label, emit an opBol.
;
; Exit:
;	appropriate opBolXXX opcode(s) are emitted
;	if error occurred, ps.errCode = error code, carry set
;	else carry is clear on exit
;
;*********************************************************************
ParseLineNumAndLabel PROC NEAR
	push	si
	push	di
	cmp	[cInclNest],0
	je	NoInclude		;brif source line isnt from include file
	mov	ax,opBolInclude
	call	EmitBol
NoInclude:
	call	TestLn			;ax = oNam for line number or 0
	jc	PlabExit		;brif error (Overflow, out-of-memory)
	je	NoLineNum		;brif no line number
	xchg	si,ax			;save oNam in si
	sub	di,di			;tell EmitLabel its a line number label
	call	EmitLabel		;emit label
	jc	PlabExit		;brif duplicate label
NoLineNum:
	call	IdTokPeriodImp		;next token can have "." in it
					; but must have no explicit type char
	je	NoLabel1		;branch if PR_NotFound
	call	Peek1Tok		;pTokPeek -> token after pTokScan
	mov	ax,IRW_Colon
	call	TestPeek_AX
	jne	NoLabel1		;brif not ':'

	mov	bx,[pTokScan]
	mov	si,[bx.TOK_id_oNam]
	mov	di,1			;tell EmitLabel its an alpha label
	call	EmitLabel		;emit the label definition
NoLabel:
	cmp	[ps.PS_bdpDst.BDP_cbLogical],0
	jne	PlabExit		;brif a label or linenum was emitted
	.errnz	opBol
	sub	ax,ax			;mov	ax,opBol
	call	EmitBol			;emit an opBol or opBolSp
	jmp	SHORT PlabGood

NoLabel1:
	call	LexReset		;rescan pTokScan ("." is terminator)
	jmp	SHORT NoLabel

PlabNoSpc:
	.errnz	opBol
	call	Emit16_0		;emit an opBol
PlabGood:
	clc				;indicate no error
PlabExit:
	pop	di
	pop	si
	ret	
ParseLineNumAndLabel ENDP

;*********************************************************************
; boolean NEAR ParseLine()
; Purpose:
;	Parse a line of BASIC source, producing pcode and or
;	error message text.
; Entry:
;	ps.bdpSrc contains the zero-byte terminated ASCII source line to
;	   be parsed.
;	grs.fDirect is true if we're parsing a direct mode statement.
;	if grs.fDirect is FALSE, grs.oMrsCur and grs.oPrsCur identify
;	   the module/procedure being edited.
;	ps.bdpDst describes destination buffer to receive generated pcode.
;	ps.bdErr describes destination buffer for error message text.
;	ps.PS_flags & PSF_fParseExp is non-zero if parser is to parse just
;	   an expression, zero if it is to parse a source line
;	other ps.PS_flags must be 0
; Exit:
;	condition codes set based on value in ax
;	If no errors were encountered,
;	   PSW.C is not set,
;	   ps.errCode=0
;	   ps.bdpDst contains generated pcode.
;	   If any labels or variables were referenced, on output,
;	      ps.flags & PWF_fRef is set true, so the text manager knows
;	      to scan the whole program if the parsed statement was in
;	      direct mode.
;	   grs.oPrs is updated if a SUB/FUNCTION/DEF statement for an
;	      as yet undefined procedure is parsed (during ASCII Load), in which
;	      case, the text manager inserts the text at the beginning of the
;	      new module.
; 
;	If any error was encountered,
;	   PSW.C is set,
;	   ps.flags PSF_UndoEdit is set if caller should back out of
;	      current edit.
;	   ps.flags PSF_fRetry is set if caller should call ParseLine
;	      again for the current edit.
;	   ps.flags PSF_fRudeIfErr is non-zero if ModuleRudeEdit is to be called
;	      if for any reason, this line's pcode is stored as opReParse,
;	      or not inserted at all.
;	   ps.oSrcErr contains the offset into ps.bdpSrc to the offending text.
;	   ps.bdpDst contains garbage.
;	   If a syntax error was encountered,
;	      ps.errCode & PSERR_fAsciiMsg is set non-zero and ps.bdErr contains
;	      a parser-built ASCII error message
;	   Else
;	      ps.errCode & PSERR_errCode contains an offset into the
;	      QBI Message Table (MSG_xxx or ER_xxx)
;	   If the variable manager returns an error code which
;	      means a RudeEdit is being performed, ps.errCode & PSERR_fRude
;	      is non-zero.  If the user wants to go through with the edit,
;	      TxtChange() will cause the module's value table to be destroyed
;	      and the module to be de-scanned to SS_RUDE
;	   If the error was a serious error, i.e. the kind of error which
;	      we want to flag as soon as the user enters it,
;	      ps.errCode & PSERR_fAlert is set non-zero.  An example of
;	      when this wouldn't be set is if the user referenced an as-yet
;	      undefined TYPE, causing the variable manager to return a
;	      'ReParse' error code.  This allows the text mgr to remember
;	      the pcode in an opReParse, but not report the error to the user.
;	      The reason this is not reported as an error is because
;	      the user may define the TYPE before a RUN is attempted.  If
;	      it is still an error when TxtDirect() is going through
;	      its ReParse list before a RUN, the error is reported to the
;	      user at that time.
;
;********************************************************************/

ParseExp:
	or	[psFlags],PSIF_fNot1stStmt
					;so we give "expected end-of-statement
					; error" instead of "expected statement"
					; if expression isn't terminated
					; by end-of-line
	call	NtConsumeExp		;parse expression (error if not found)
	jmp	short CheckResult	;check result in al

PUBLIC	ParseLine
ParseLine PROC NEAR
;Static variable stkChkParse assumes b$pend never moves.
;If this ever becomes invalid, just move code from ParseInit to ParseLine.
DbAssertRel [b$pend],e,[initBpEnd],CP,<ParseLine: b$pend moved>
	sub	ax,ax			;ax = 0
	mov	[ps.PS_errCode],ax
	mov	[psFlags],al
	mov	[pStateCur],ax
	mov	[pStateLastScan],ax
	mov	[pStateLastGood],ax
	cmp	[grs.GRS_fDirect],al
	jne	PlNoBind		;brif we're in direct mode
	cmp	[txdCur.TXD_scanState],SS_RUDE
	je	PlNoBind
	or	[psFlags],PSIF_fBindVars ;bind var refs
PlNoBind:

	;reset all parser buffers to their start
	mov	ax,[ps.PS_bdpSrc.BDP_pb]
	mov	[ps.PS_bdpSrc.BDP_pbCur],ax
	call	ResetDstPbCur		;discard anything in this buffer

	call	ScanTok			;pick up 1st token on line
	test	[ps.PS_flags],PSF_fParseExp
	jne	ParseExp		;brif called to parse a Watch Expression
	call	ParseLineNumAndLabel	;consume and emit line number and
					; label definition
	jc	PlErr			;brif some error in label

	call	NtStatementList0	;parse a list of statements
					; [:] stmt [: stmt [: ...]]
CheckResult:
	jl	PlErr			;brif bad syntax, ps.bdErr already
					; contains ASCII error message,
					;PR_NotFound is ok (empty stmt list)
	mov	ax,IRW_NewLine
	call	TestScan_AX		;test for end-of-line
	jne	NoEndOfLine		;brif didn't get expected end-of-line
	test	[psFlags],PSIF_fLineHasPeriodId
	je	NoAdotB			;brif line contains no A.B identifiers
	mov	ax,opNoType		;emit an opEot to terminate pcode
	call	Emit16_AX
NoAdotB:
	mov	ax,opEot		;emit an opEot to terminate pcode
	call	Emit16_AX
	cmp	[ps.PS_errCode],0
	jne	PlErr			;brif got some error like out-of-memory
					; or variable creation error
	clc				;return carry clear (no error)
PlExit:
	ret	

NoEndOfLine:
	mov	ax,MSG_ExpStatement	;Error "Expected statement"
	test	[psFlags],PSIF_fNot1stStmt
	je	PlReportErr		;brif never got 1st statement on line
					;else didn't get expected end-of-line
	mov	ax,IRW_ELSE
	call	TestScan_AX
	je	BadElse			;brif got ELSE
	mov	ax,IRW_ELSEIF
	call	TestScan_AX
	jne	PlExpEos
;Tried to put ELSE or ELSEIF after 1st statement on line,
BadElse:
	mov	ax,MSG_1stStmt		;Error: "Must be 1st statement on line"
	call	PErrMsg_AX
	jmp	SHORT PlErr

PlExpEos:
	call	PErrState		;generate "Expected A or B or C based
					; on parse table state where last
					; token was scanned.
	mov	ax,MSG_eos		;Error "Expected End-of-Statement"
;ax = text for what we expected
PlReportErr:
	call	PErrExpMsg_AX

;This point is only reached if the line entered had bad syntax,
;or we ran out of memory during some stage,
;or the variable manager detected an error.
PlErr:
	;Halt if non-release version, and user entered -TglParseErrs
	call	far ptr ParseErrInit
	DbAssertRel [ps.PS_errCode],ne,0,CP,<prsmain.asm: errcode != 0>
	stc				;return with carry set (error)
	jmp	SHORT PlExit
ParseLine ENDP



;*********************************************************************
; boolean FAR SetPsBufSz(szStmt)
; Purpose:
;	Set the content of the parser's source buffer.
; Entry:
;	szStmt points to a 0-byte terminated string.
; Exit:
;	If out-of-memory,
;	   returns FALSE
;	else
;	   The line is copied to the global buffer ps.bdpSrc
;	   returns TRUE (non-zero)
;
;********************************************************************/
cProc	SetPsBufSz,<PUBLIC,FAR>
	parmW	szStmt
cBegin
	push	[szStmt]
	call	CbSz			;ax = length of string
	xchg	dx,ax			;dx = length of string
	inc	dx			;include room for 0-byte terminator
	sub	ax,ax			;prepare to return FALSE
	cmp	dx,[ps.PS_bdpSrc.BDP_cbLogical]
	ja	SetSzExit		;brif no room for command

	;Now copy the block from szStmt to the parser's buffer
	push	[szStmt]
	push	[ps.PS_bdpSrc.BDP_pb]
	push	dx
	call	CopyBlk
	mov	ax,sp			;return non-zero (success)
SetSzExit:
cEnd

;*********************************************************************
; SetDstPbCur()
; Purpose:
;	Set parser's output pcode buffer's current pointer field
;	(ps.bdpDst.pbCur) pointing to the end of the buffer.
;	This is called after ps.bdpDst.cbLogical has been altered.
;
; Preserves:
;	All registers except ax, flags
;
;*********************************************************************
PUBLIC	ResetDstPbCur
ResetDstPbCur PROC NEAR
	mov	[ps.PS_bdpDst.BDP_cbLogical],0
	mov	[bdParseUndo.BD_cbLogical],0
ResetDstPbCur ENDP
	;fall into SetDstPbCur
PUBLIC	SetDstPbCur
SetDstPbCur PROC NEAR
	mov	ax,[ps.PS_bdpDst.BDP_pb]
	add	ax,[ps.PS_bdpDst.BDP_cbLogical]
	mov	[ps.PS_bdpDst.BDP_pbCur],ax
	ret	
SetDstPbCur ENDP

;*********************************************************************
; void FAR ParseInit()
; Purpose:
;	Called once during initialization to initialize the parser
;
;*********************************************************************

AllocBd PROC NEAR
	mov	dl,IT_NO_OWNERS
	sub	cx,cx			;byte count = 0
AllocBd ENDP
	;fall into AllocBd1
AllocBd1 PROC NEAR
	push	ax			;pass ptr to buffer
	push	cx			;pass byte count
	push	dx			;pass flags
	call	BdAlloc
	or	ax,ax
	je	J1_RtErrorOM_INI	;fatal out-of-memory error
	ret
AllocBd1 ENDP
	

J1_RtErrorOM_INI:
	jmp	RtErrorOM_INI		;fatal error, never returns

STKCHK_NtParse EQU 400d	;actually 242, add 158 bytes for maintenance/uncertainty
;
;STKCHK_ToNtParse is the number of bytes of stack space needed to get from
; UserInterface (where caller ensures STACK_CHECK bytes exist between sp
; and b$pend) and NtParse().
;
STKCHK_ToNtParse EQU 350d ;actually 228d, add 122 for maintenance/uncertainty

cProc	ParseInit,<FAR,PUBLIC>
cBegin	ParseInit
	;Runtime ensures we never enter the user interface with less
	;than STACK_CHECK bytes free.  Make sure that STACK_CHECK is big enough
	;to satisfy parser's requirements.
	
DbAssertRel <STKCHK_ToNtParse+STKCHK_NtParse>,b,STACK_CHECK,CP,<ParseInit stk>

	;Set static variable which prevents the recursive parser from
	;over-running the memory allocated for stack space (b$pend)
	
	mov	ax,[b$pend]
	add	ax,STKCHK_NtParse
	mov	[stkChkParse],ax

	; BdAlloc(&ps.bdpSrc, 0, (char)IT_NO_OWNERS_BDP)
	mov	ax,dataOFFSET ps.PS_bdpSrc
	mov	dl,IT_NO_OWNERS_BDP
	sub	cx,cx			;byte count = 0
	call	AllocBd1

	; BdAlloc(&ps.bdpDst, 0, (char)IT_NO_OWNERS_BDP)
	mov	ax,dataOFFSET ps.PS_bdpDst
	mov	dl,IT_NO_OWNERS_BDP
	mov	cx,CB_PCODE_MIN		;never let bdpDst get smaller than
	call	AllocBd1		; CB_PCODE_MIN, so we can always
					; execute a SYSTEM, SETMEM, CLEAR stmt
					; in direct mode.

	; BdAlloc(&bdEMScratch, 0, (char)IT_NO_OWNERS)
	mov	ax,dataOFFSET bdEMScratch
	call	AllocBd

	; BdAlloc(&ps.bdErr, 0, (char)IT_NO_OWNERS)
	mov	ax,dataOFFSET ps.PS_bdErr
	call	AllocBd

	; BdAlloc(&bdParseUndo, 0, (char)IT_NO_OWNERS)
	mov	ax,dataOFFSET bdParseUndo
	call	AllocBd
	jmp	SHORT ParseErrInitStart	
ParseInit ENDP

;Called during initialization and after errors
cProc	ParseErrInit,<FAR>		
cBegin	ParseErrInit			
ParseErrInitStart:
	;set all token pointers start of circular token queue
	mov	ax,dataOFFSET tLookAhead
	mov	[pTokLast],ax
	mov	[pTokScan],ax
	mov	[pTokPeek],ax
	mov	[pExpTos],dataOFFSET stkExpInit
					;reset NtExp's stack
					; (for expression parsing)
cEnd	ParseErrInit			

;*********************************************************************
; void FAR ParseNewInit()
; Purpose:
;	Called once during initialization and for NEW statement
;	to change size of parser's source buffer to 256.
;	ASCII Load can increase the size of the parser's source
;	buffer to the length of the longest line loaded.
; Exit:
;	ax = zero if out-of-memory
;
;*********************************************************************
cProc	ParseNewInit,<PUBLIC,FAR>
cBegin
	PUSHI	ax,<dataOFFSET ps.PS_bdpSrc>
	PUSHI	ax,MIN_EDITLINE
	call	BdRealloc
	or	ax,ax
	jz	ParseNew_Exit

	PUSHI	ax,<dataOFFSET bdEMScratch>
	PUSHI	ax,MIN_EDITLINE
	call	BdRealloc
ParseNew_Exit:
cEnd

;*********************************************************************
; RudeIfErr
; Purpose:
;	If current line gets any kind of error, we will descan to ss-rude.
;	First, ask user if he wants to back out of edit for Edit & Continue.
;	This is called before calling MakeVariable for CONST ID=1
;	because if the line is never inserted, the variable table
;	still contains the now bogus entry for ID.
; Exit:
;	If user wants to back out of edit,
;	   ps.errCode = ER_IER (any error code would do other than ER_CN
;	                as long as PSERR_fAlert bit is not set, user will
;			never see the error.  Any non-zero value prevents
;			us  from calling MakeVariable for rest of this line.
;	   ps.flags PSF_UndoEdit bit is set, telling caller to back out of edit.
;	else
;	   ps.flags PSF_RudeIfErr is set, telling caller of ParseLine
;	   to call ModuleRudeEdit if any error occurs before this
;	   line's pcode gets inserted into the text table.
;
;*********************************************************************
PUBLIC	RudeIfErr
RudeIfErr PROC NEAR
	call	AskCantCont_CP		;see if user wants to back out of edit
	jne	RiNoBackOut		;brif not
	mov	ax,ER_IER
	call	ParseErr0		;stop's subsequent calls to MakeVariable
	or	[ps.PS_flags],PSF_UndoEdit
	ret
RiNoBackOut:
	or	[ps.PS_flags],PSF_fRudeIfErr
	ret
RudeIfErr ENDP

;*********************************************************************
; void ParseUndoLog()
; Purpose:
;	Called to remember something ParseUndo must handle if
;	for any reason, this statement's pcode doesn't make it
;	into a text table without errors.
; Entry:
;	al = entry type (PUNDO_xxx)
;	dx = type specific argument (oNam, oPrs, etc.)
; Exit:
;	if out-of-memory, ps.errCode = ER_OM, [QB4]
;	   or MSG_LineTooLong [EB]
;	   ax = zero if out-of-memory, PSW set accordingly
;
;*********************************************************************
cProc	ParseUndoLog,<PUBLIC,NEAR>
cBegin
	push	ax			;save entry type
	push	dx			;save entry argument
	PUSHI	ax,<dataOFFSET bdParseUndo>
	PUSHI	ax,3			;size of 1 entry
	call	BdGrow			;allocate space for entry
	pop	dx			;pop entry argument
	or	ax,ax			;test return value from BdGrow()
	pop	ax			;al = entry type
	je	PulOm			;brif BdGrow returned out-of-memory
	mov	bx,[bdParseUndo.BD_pb]
	add	bx,[bdParseUndo.BD_cbLogical]
	mov	[bx-2],dx		;store entry argument
	mov	[bx-3],al		;store entry type
	DbAssertRel ax,ne,0,CP,<ParseUndoLog: ax=0>
;ax = return value, condition codes already set
PulExit:
cEnd

PulOm:
	call	ParseErrOm		;set ps.errCode to ER_OM
	sub	ax,ax			;return 0 (out-of-memory)
	jmp	SHORT PulExit

;*********************************************************************
; void ParseUndo()
; Purpose:
;	Called when line which was partially parsed by ParseLine is
;	found to have an error.  It undoes any static actions (like
;	setting of name table bits) caused by ParseLine. It scans
;	the entries created by ParseUndoLog and takes following actions:
;	  PUNDO_oNamAs - Call ChkLastAs to see if no other refs to
;	    oNam AS in pcode.  If so, oNam's NM_fAs name table bit is reset.
;	  PUNDO_oPrsRef - call ChkDelPrs to see if PrsFree should
;	    be called for this prs, since no other refs to this prs exist.
;
;*********************************************************************
cProc	ParseUndo,<PUBLIC,NEAR>,<si>
cBegin
	mov	si,[bdParseUndo.BD_pb]
PudLoop:
	mov	ax,[bdParseUndo.BD_pb]
	add	ax,[bdParseUndo.BD_cbLogical]
	cmp	si,ax
	jae	PudDone
	lodsb				;al = entry type
	dec	al
	lodsw				;ax = oNam/oPrs (flags unaffected)
	jne	NotAsType
	.errnz	PUNDO_oNamAs - 1
	call	ChkLastAs		;reset NM_fAs bit if appropriate
	jmp	SHORT PudLoop
NotAsType:

;ax = oPrs if SUB/FUNCTION/DECLARE
	.errnz	PUNDO_oPrsRef - 2
	call	UndefPrs		;tell txtmgr we deleted "defining" ref
	jmp	SHORT PudLoop

PudDone:
	mov	[bdParseUndo.BD_cbLogical],0
					;so if we're called twice for
					; the same line, the 2nd call will
					; be a nop
cEnd

;*********************************************************************
; VOID NEAR MakeOpReParse()
; Purpose:
;	This is called when some parse-time error is encountered.
;	Discard current contents of ps.bdpDst and replace it with an
;	opReParse token for the current source line.
; Entry:
;	ps.bdpSrc contains the current 0-byte terminated source line
; Exit:
;	If an out-of-memory error occured,
;	   ps.errCode = ER_OM
;	   ps.bdpDst contains garbage
;	else
;	   ps.bdpDst contains opBol, opReParse(cTxt, link, text), opEot
;	   (the 0-byte terminator is not included in the opReParse)
;
;********************************************************************/
PUBLIC	MakeOpReParse
MakeOpReParse PROC NEAR
	call	ResetDstPbCur		;discard any output produced thus far
	.errnz	opBol
	mov	al,[cInclNest]		;al = $INCLUDE nesting depth (0 if none)
	and	ax,0FFh			;ax=al, can't use cbw--doesn't set flags
	je	NotIncl			;brif source line isnt from include file
	push	ax
	mov	ax,opBolInclude
	call	Emit16_AX		;emit opBolInclude
	pop	ax			;ax = $INCLUDE nesting depth (0 if none)
NotIncl:
	call	Emit16_AX		;emit an opBol (or opBolIncl operand)
	mov	ax,opReParse
	call	Emit16_AX		;emit an opReParse

	;Copy all of source buffer ps.bdpSrc to pcode buffer ps.bdpDst
	PUSHI	ax,0			;EmitSrc(0, cbText)

	push	[ps.PS_bdpSrc.BDP_pb]	;pass ptr to 1st byte of source line
	call	CbSz			;ax = length of stmt
	push	ax			;pass to EmitSrc (below)

	inc	ax			;include room for link field
	inc	ax
	call	Emit16_AX		;emit count
	call	Emit16_0		;leave room for link field
	call	EmitSrc			;parms were pushed several lines above
	mov	ax,opEot
	jmp	Emit16_AX		;emit ax and return to caller
MakeOpReParse ENDP

sEnd	CP
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsnt1.asm ===
;=============================================================================
; prsnt1.asm - Parser's Non-Terminal Functions (continued)
;
; Copyright <C> 1985, Microsoft Corporation
;
; Purpose: 
;	In an ideal world, these functions would reside in prsnt.asm.
;	They live here to reduce the number of include files needed
;	by prsnt.asm, so MASM won't run out of memory when assembling it.
;	See general comments at top of prsnt.asm for non-terminal function
;	conventions.
;
;
;=============================================================================

	include	version.inc
	PRSNT1_ASM = ON
	includeOnce	architec	
	includeOnce	names
	includeOnce	opstmt
	includeOnce	opid 
	includeOnce	parser
	includeOnce	prstab
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	types
	includeOnce	util

	assumes	CS,CP
	assumes	DS,DGROUP
	assumes	SS,DGROUP
	assumes	ES,DGROUP


sBegin	DATA
szB		DB "B",0
szBF		DB "BF",0
szF		DB "F",0
sEnd	DATA

sBegin	CP

subttl	misc parser nonterminal recognizers

;**********************************************************************
; PARSE_RESULT NEAR NtRwB()
;
; Purpose:
;	Parse the identifier B
; Exit:
;	Returns PR_GoodSyntax (and consumes token) or PR_NotFound
;
;******************************************************************
PUBLIC	NtRwB
NtRwB	PROC NEAR
	mov	ax,dataOFFSET szB
	jmp	SHORT CheckRw1
NtRwB	ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtRwBF()
;
; Purpose:
;	Parse the identifier BF
; Exit:
;	Returns PR_GoodSyntax (and consumes token) or PR_NotFound
;
;******************************************************************
PUBLIC	NtRwBF
NtRwBF	PROC NEAR
	mov	ax,dataOFFSET szBF
	mov	cx,8002h		;highbit says don't change case
					; of existing namtbl id, incase
					; user has variable 'bF'
	jmp	SHORT CheckRw
NtRwBF	ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtRwF()
;
; Purpose:
;	Parse the identifier F (as found in the statement LINE ...,B F
; Exit:
;	Returns PR_GoodSyntax (and consumes token) or PR_NotFound
;
;******************************************************************

PUBLIC	NtRwF
NtRwF	PROC NEAR
	mov	ax,dataOFFSET szF
CheckRw1:
	mov	cx,8001h		;highbit says don't change case
					; of existing namtbl id, incase
					; user has variable 'f'
NtRwF	ENDP
; Fall into CheckRw

;*******************************************************************************
; PARSE_RESULT NEAR CheckRw(ax=pbRw,cx=cbRw)
;
; Purpose:
;	Checks for the reserved word and eats it if found.
;
; Entry:
;	ax=pbRw	- Pointer to string containing the reserved word to check for.
;	cx=cbRw	- Length of the reserved word string.
;	
; Exit:
;	PR_GoodSyntax or PR_NotFound based on finding the pseudo reserved word.
;
;***************************************************************************
CheckRw PROC NEAR
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_id
	jne	CheckNotFound		;branch if token isn't an identifier
	push	bx			;save pointer to token
	;ax = pbRw, cx = cbRw
	call	ONamOfPbCb		;ax = oNam (or 0 if out-of-memory)
					; no-need to check for out-of-memory
					; since comparison will fail, and we'll
					; get another out-of-memory when we
					; try to insert the text in a txttbl.
	pop	bx			;restore pointer to token
	cmp	[bx.TOK_id_oNam],ax
	jne	CheckNotFound
	call	ScanTok			;skip identifier 
	mov	al,PR_GoodSyntax
	ret
CheckNotFound:
	sub	al,al			;return(PR_NotFound)
	ret
CheckRw	ENDP

sEnd	CP

sBegin	DATA

str255Include	DB 7,'INCLUDE'
str255Static	DB 6,'STATIC'
str255Dynamic	DB 7,'DYNAMIC'

IMETA_INCLUDE	EQU 0
IMETA_STATIC	EQU 1
IMETA_DYNAMIC	EQU 2
NMETA EQU 3

	EVEN
tstr255Meta DW	OFFSET DGROUP:str255Include
	DW	OFFSET DGROUP:str255Static
	DW	OFFSET DGROUP:str255Dynamic
	EVEN

topMeta	DW	op_Include
	DW	op_Static
	DW	op_Dynamic

sEnd	DATA

sBegin	CP

;**********************************************************************
; STATICF(PARSE_RESULT) NtEmitRem(opcode)
;
; Purpose:
;	Emit opcode which encapsulates text argument for REM, DATA, _, or '.
;	Meta command syntax is:
;	  $DYNAMIC
;	  $STATIC
;	  $INCLUDE <spaces>:<spaces>'<filename>'
;
; Entry:
;	opcode is: opStRem for REM, opQuoteRem for ', opStData for DATA
;
; Exit:
;	opcode = opcode to be generated
;	An end-of-line terminates all of the above.
;	Sequential runs of a single char > 6 will be specified by opRemRepeat.
;	An additional terminator for a DATA statement is : outside of quotes.
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtEmitRem <PUBLIC,NODATA,NEAR>,<si,di>
	parmW	opcode
	localW	oSrcRemArg
	localW	fCompress
	localW	oDstCbRem
	localW	oDstTerm
	localW	cbMeta
	localW	iMeta
	localB	fMetaOk
	;fMetaOk is intended to allow meta commands only if the 1st
	; non-white-space char on the line is '$'
cBegin	NtEmitRem
	mov	[fCompress],sp		;we start by assuming that we want
					; to compress text
	mov	[fMetaOk],1		;$meta commands are valid
	mov	bx,[pTokScan]		;bx points to current token
	mov	si,[bx.TOK_oSrc]	;si = offset in source line to token
	mov	ax,[opcode]		;ax = opcode to be emitted

	;skip past reserved word in source buffer based on opcode 
	inc	si			;assume its a single-quote rem
	cmp	ax,opQuoteRem
	je	KeywordSkipped		;branch if we're doing '
	inc	si			;'REM' is 3 bytes long
	inc	si
	cmp	ax,opStRem
	je	KeywordSkipped		;branch if we're doing REM
	inc	si			;else it must be 'DATA' (4 bytes long)
	mov	[fCompress],0		;don't compress DATA text
KeywordSkipped:

;si = offset in current source line to 1st byte of remark's data
;     i.e. to 1st byte beyond "REM", "DATA", "'", "$STATIC" etc.
;
RemLoop:
	mov	[oSrcRemArg],si		;save offset to start of REM/DATA text
	add	si,[ps.PS_bdpSrc.BDP_pb] ;convert offset to ptr
					; si points to start of source buffer
	mov	[iMeta],UNDEFINED	;assume we'll see no $<meta>
	sub	dl,dl			;remember we're not inside a quote

;search for end of remark/DATA 
; si points to next byte of remark's data
; dl = non-zero if we're in a DATA statement and within double quotes
;      (so we know to not treat : as end-of-stmt)
;
LoopTillEos:
	lodsb				;al = next byte of source
	or	al,al
	je	J1_EmitRem		;branch if end-of-line
	cmp	[opcode],opStData
	je	GotData			;branch if we're scanning a DATA stmt
	cmp	[fMetaOk],0
	je	LoopTillEos		;brif $meta commands not legal
	cmp	al,"$"			;else we're in some form of REM stmt
	je	CheckMeta		;branch if '$' inside a REM
	cmp	al," "
	je	LoopTillEos		;brif haven't seen anything but space
	and	[fMetaOk],NOT 1		;$meta commands are no longer valid
					; unless we've already parsed one
	jmp	SHORT LoopTillEos	;test for end-of-line (end-of-REM)

GotData:
	cmp	al,34			;compare with '"' (double quote)
	jne	NotDoubleQuote
	not	dl			;toggle in-quote state 
	jmp	SHORT LoopTillEos

NotDoubleQuote:
	cmp	al,":"
	jne	LoopTillEos		;branch if not ':'
	or	dl,dl
	jne	LoopTillEos		;branch if we're inside a "xxx"
J1_EmitRem:
	jmp	SHORT EmitRem		;else, the DATA stmt is terminated

BadMeta:
	mov	ax,ER_ADF		; Map all $INCLUDE errors to AFE
	call	PErrMsg_AX		;al = PR_BadSyntax
	jmp	NtRemExit

;At this point, we've seen a dollar sign in a REMARK which could
;be the start of a $META directive.
;
CheckMeta:
	or	[fMetaOk],2		;$meta commands are now valid until
					; the end of this remark
	mov	di,NMETA		;number of meta commands to search for
MetaLoop:
	dec	di
	js	LoopTillEos		;branch if didn't find a $<meta>
	mov	bx,di			;bx = iMeta
	shl	bx,1			;bx = 2*iMeta
	mov	bx,WORD PTR tstr255Meta[bx]
					;bx points to str255 struct for string
	mov	al,[bx]			;al = length of meta command
	inc	bx			;bx points to 1st letter of meta
	cbw				;ax = cbMeta
	mov	[cbMeta],ax		;save it for later
	xchg 	cx,ax			;pass byte count in cx
	call	CmpStrIns		;do a case insensitive string compare 
					; of strings *bx and *si
	jne	MetaLoop		;branch if they don't match

	;We found a $META command in the REM
	;si points past '$' byte of $META directive
	mov	[iMeta],di		;save meta command's id
	or	di,di			;test for IMETA_INCLUDE
	jne	EmitRem			;branch if not $INCLUDE

	; got $INCLUDE <spaces>:<spaces>'<filename>'
	mov	di,si			;di points beyond "$"
	add	di,[cbMeta]		;di points beyond "$<meta>" 
	push	ds
	pop	es			;es = DGROUP for repne scasb

	jmp	short BadMeta		; Always give AFE error

;Copy bytes from source buffer ps.bdpSrc to pcode buffer ps.bdpDst 
; oSrcRemArg = offset to first byte to emit
; si points beyond text's terminator
;
EmitRem:
	mov	di,[opcode]		;di = REM/DATA/<meta> opcode
	cmp	di,opStData
	je	ItsData			;brif DATA (leave room for 0-terminator)
	dec	si			;si points to text's terminator
ItsData:
	sub	si,[ps.PS_bdpSrc.BDP_pb] ;si = offset beyond last byte to emit
	push	di			;pass opcode
	call	Emit16			;emit opcode
	mov	cx,[oSrcRemArg]		;cx = offset to first byte to emit
	mov	ax,si			;ax = offset beyond last byte to emit
	sub	ax,cx			;ax = size of opcode's argument
	push	cx			;pass offset to EmitSrc (below)
	push	ax			;pass cb to EmitSrc (below)
	mov	cx,[ps.PS_bdpDst.BDP_cbLogical] ;get offset to where cb will be
	mov	[oDstCbRem],cx		;emitted
	cmp	di,opStData
	je	LinkedOpcode		;branch if this opcode has link field
	cmp	di,opQuoteRem
	jne	UnlinkedOpcode		;branch if opcode has no column field
LinkedOpcode:
	inc	ax			;add size of link field to size
	inc	ax
	mov	dx,[ps.PS_bdpDst.BDP_pbCur]
	sub	dx,[ps.PS_bdpDst.BDP_pb] ;dx = #bytes in output buffer
	inc	dx			;add 2 bytes for cb field
					;subtract 1 for 0-terminator
	add	dx,ax			;dx = offset to 0-terminate DATA stmt
	mov	[oDstTerm],dx		;save offset to 0-terminate DATA stmt
	call	Emit16_AX		;emit the size field
	mov	bx,[pTokScan]		;bx points to current token
	mov	ax,[bx.TOK_oSrc]	;ax = source column token started in
					;for opSQuote, we are emitting the
					; column so we can accurately list it.
					; For all other opcodes, we are making
					; room for a link field 
UnLinkedOpcode:
	call	Emit16_AX		;emit the size field/link field
	cmp	[fCompress],0		;should we compress chars in string?
	jne	CompressText		;brif so
	call	EmitSrc			;parms were pushed (above)
	jmp	short ChkOpData
CompressText:
	push	[oDstCbRem]		;pass offset of cbRem in case
					; we compress the text
	call	EmitSrcCompress 	;other parms were pushed (above)
ChkOpData:
	cmp	di,opStData
	jne	NotData
	mov	bx,[ps.PS_bdpDst.BDP_pb]
	add	bx,[oDstTerm]		;bx points 1 byte beyond dst DATA
	mov	BYTE PTR [bx],0		;0-terminate DATA stmt
	dec	si			;rescan terminator
NotData:
	mov	bx,[iMeta]
	shl	bx,1			;bx = 2 * iMeta
	jc	GotLastRem		;branch if no more $<meta> commands on
					; this line
	;generate another opcode for the $META directive 
	mov	ax,topMeta[bx]		;ax = meta directive's opcode
	mov	[opcode],ax
	add	si,[cbMeta]
	inc	si
	mov	[fCompress],0		;don't compress $<meta> command text
	jmp	RemLoop

;si points beyond REM/DATA stmt
GotLastRem:
	add	si,[ps.PS_bdpSrc.BDP_pb]
	mov	[ps.PS_bdpSrc.BDP_pbCur],si
	call	ScanTok			;pTokScan points to end-of-stmt or
					; end-of-line token 
	mov	al,PR_GoodSyntax
NtRemExit:
	or	al,al			;set condition codes for caller
cEnd	NtEmitRem



sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsnt.asm ===
TITLE	PRSNT - Parser NonTerminal Functions

;==========================================================================
;
;  Module:  prsnt.asm - Parser NonTerminal Functions
;  Subsystem:  Parser
;  System:  Quick BASIC Interpreter
;  Copyright <C> 1985, Microsoft Corporation
;
;	RULES FOR WRITING NON-TERMINAL FUNCTIONS:
;	----- --- ------- --- -------- ---------
;
;	A 'TERMINAL' is a syntactic item which can be described by
;	   1 token.  Examples include reserved words, constants, variables.
;	A 'NON-TERMINAL' is a complicated syntactic item which is
;	   described by a sequence of TERMINALS and other NON-TERMINALS.
;	   Examples include statement (NtStatement), expressions (NtExp) etc.
;
;	Whenever possible, we try to parse non-terminals with the function
;	Parse(), which uses state-table information in prsstate.asm.
;	Non-Terminal parsing functions are used instead of state-table
;	driven non-terminal entries (in bnf.prs) for the following reasons:
;	-	When we need to look ahead (i.e. PeekNextTok()) to decide
;		which of several similar non-terminals the token stream is.
;	-	When we need to generate complicated pcode.
;	-	When we want to setup state for the code generator which
;		will eventually be called for this statement/intrinsic
;		(See NtACTIONxxx() for an example of this).
;
;	The functions in this module (and in module PrsExp.asm) are responsible
;	for parsing NON-TERMINALs which could not be parsed by Parse().
;	These non-terminal parsing functions must return 1 of 3 values:
;
;	-	PR_NotFound, meaning the non-terminal was not recognized, but
;		no tokens were consumed and no pcode was emitted.  This
;		allows the caller (which is almost always Parse()) to
;		try alternate non-terminals before generating a syntax error.
;
;	-	PR_GoodSyntax, meaning the non-terminal was successfully
;		recognized, tokens were consumed, and pcode was emitted.
;
;	-	PR_BadSyntax, meaning the non-terminal was not recognized, and
;		tokens were consumed and/or pcode was emitted.  An error
;		message must also be generated, like ("Expected <non-terminal>")
;		by calling PErrExpMsg() or similar routines.  This will
;		cause the caller to return all the way up to ParseLine()
;		with the generated syntax error.
;
;=========================================================================

	include version.inc
	PRSNT_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce opstmt
	includeOnce opid
	includeOnce parser
	includeOnce prsirw
	includeOnce prstab
	includeOnce psint
	includeOnce qbimsgs
	includeOnce rtinterp
	includeOnce rtps

	assumes	CS,CP
	assumes	DS,DGROUP
	assumes	ES,DGROUP
	assumes	SS,DGROUP

sBegin	DATA

	EXTRN	b$ErrInfo:byte		;extended error code

	PUBLIC	pStateCur, pStateLastScan, pStateLastGood
pStateCur	DW 0		;see comments below in NtParse
pStateLastScan	DW 0		;see comments below in NtParse
pStateLastGood	DW 0		;see comments below in NtParse

	PUBLIC	pCurStkMark, minStkMark, maxStkMark
	MARK_STACK_SIZE EQU 10
	;The size of this constant must exceed the maximum number
	;of MARK meta-commands that can occur for any statement
	;in the bnf (see bnf.prs).  Since MARK never appears within
	;a repeating construct (i.e. {id MARK(n)}), we can easily
	;compute the worst case number of MARKs in 1 statement.
	;It is currently 6 for OPEN, so 10 gives plenty of breathing
	;room.  It would be nice at some point to change buildprs
	;(the program that reads bnf.prs) to produce this constant.
	
pCurStkMark LABEL WORD
	DW	0
minStkMark LABEL WORD
	DW	MARK_STACK_SIZE DUP(?)
maxStkMark LABEL WORD


fNeedPrintEos DB 1			;used by NtEndPrint

sEnd	DATA


;*====================================================================
;*    P A R S E   S T A T E   T A B L E   I N T E R P R E T E R
;*
;*    This function make up the interpreter which emulates the
;*    push-down-automata for the recursive descent parser.
;*
;*====================================================================

sBegin	CP
assumes	CS,CP

PUBLIC	RtErrOmStack
RtErrOmStack PROC NEAR
	mov	[b$ErrInfo],OMErr_STK	;so user interface can distinguish
					; this from other types of Out-of-memory
					; when reporting the error
	mov	al,ER_OM		;"Out of memory"
	jmp	RtErrorNoSi
RtErrOmStack ENDP

;*********************************************************************
; PARSE_RESULT NEAR NtParse(ax:pState)
;
; Purpose:
;	Try to match (parse) the token stream which begins with 'pTokScan'
;	to the regular expression identified by pState.
;
; Entry:
;	ax=pState: pointer into tState[] for the syntax to be recognized
;
; Exit:
;	If no errors are encountered, on exit 'pTokScan' should be a valid
;	   syntax terminator.
;	   Return value is PR_GoodSyntax.
;	If the 1st token was not even consumed, the return value is
;	   PR_NotFound.
;	Otherwise, the error(s) are reported and 'pTokScan' is the next
;	   statement terminator.
;	   Return value is PR_BadSyntax.
;	Condition codes set based on value in al
;
; Example:
;	If the state tree pointed to by 'pState' looked like:
;
;           A
;          / \
;         B   C
;        / \   \
;       D   E   F
;
; Then the input token stream had better look like one of the following:
;  ACF or BE or D
;
; Tricky statements to report errors for (i.e. test these if you
; ever alter the error reporting logic):
;  KEY(1)="this"
;  CIRCLE (1,2)),3
;  DO STOP --> make sure error is expected WHILE or end-of-stmt
;  NEXT STOP --> make sure error is expected id or end-of-stmt
;
;********************************************************************
;Register usage:
;	si = pState

;in response to EMIT(opcode) directive, emit the opcode
GotEmitNode:
	lods	WORD PTR cs:[si]	;ax = EMIT's operand
	call	Emit16_AX
	jmp	SHORT ParseLoop

cProc	NtParse,<PUBLIC,NEAR>,<si,di>
	localW	nodeId
	localB	cTokFirst
cBegin	NtParse
	DbChkPsStk			;see if this is a new high-water stack
	cmp	sp,[stkChkParse]
	jbe	RtErrOmStack		;brif almost out of stack space
	xchg	si,ax			;si = pState
	mov	al,[cTokScan]
	mov	[cTokFirst],al		;cTokFirst = cTokScan
ParseLoop:
	;fetch state transition arc from encoded state tree 'tState'
	lods	BYTE PTR cs:[si]	;al = nodeId
	cmp	al,ND_EMIT
	ja	NotDirective		;brif not ACCEPT/REJECT/MARK/EMIT
	je	GotEmitNode		;branch if EMIT node
.errnz	ND_ACCEPT
	or	al,al
	je	J1_GotAcceptNode	;branch if ACCEPT node
	cmp	al,ND_MARK
	je	GotMarkNode		;branch if MARK node
	jmp	GotRejectNode		;else it has to be a REJECT node

J1_GotAcceptNode:
	jmp	GotAcceptNode

;In response to MARK(const) directive, push current
;pcode offset and const onto stack.  This information
;will be used by stmt or func code generator
;
GotMarkNode:
	mov	bx,[pCurStkMark]
	DbAssertRel bx,a,MIN_STK_MARK,CP,<NtParse: marker stack overflow>
	mov	ax,WORD PTR ps.PS_bdpDst.BDP_pbCur
	sub	ax,WORD PTR ps.PS_bdpDst.BDP_pb ;ax = cur offset into out buffer
	dec	bx			;push pcode offset onto MARK stack
	dec	bx			; for use by Code Generator function
	mov	[bx],ax
	dec	bx			;push MARK's operand as well
	dec	bx
	lods	BYTE PTR cs:[si]	;al = MARK's operand
	sub	ah,ah
	mov	[bx],ax
	mov	[pCurStkMark],bx
	jmp	SHORT ParseLoop

Got_STT_Accept:
	sub	ax,ax			;indicates unconditional acceptance
	jmp	SHORT PsHandleNode

;got a branch, token, or nonterminal - fetch its id
;al = 1st byte of nodeId
;
NotDirective:
	sub	ah,ah
	cmp	al,ENCODE1BYTE
	jb	PsOneByteNodeId
	;nodeId = ((nodeId-ENCODE1BYTE) << 8) + (*pState++) + ENCODE1BYTE
	mov	ah,al
	lods	BYTE PTR cs:[si]	;ax = nodeId * 256 + next byte
	sub	ax,255 * ENCODE1BYTE
;ax = nodeId
;node is followed by 1 or 2 byte branch operand, fetch it
;
PsOneByteNodeId:
	mov	[nodeId],ax
	lods	BYTE PTR cs:[si]	;al = 1st byte of operand
	cmp	al,ENCODE1BYTE
	jb	PsOneByteOperand
	cmp	al,255
	je	Got_STT_Accept
	;operand is 2 byte offset into tState, pick up 2nd byte
	;pStateTrue = &tState[((operand-ENCODE1BYTE)<<8) + *pState++]
	
	mov	ah,al
	lods	BYTE PTR cs:[si]	;al=2nd byte of operand
	add	ax,OFFSET CP:tState-256*ENCODE1BYTE
	jmp	SHORT PsHandleNode

;operand is 1 byte relative branch in state table
;al = 1st byte of node's operand
;
PsOneByteOperand:
	sub	ah,ah			;ax = operand
	mov	bl,al			;bl = operand
	add	ax,si
	cmp	bl,ENCODE1BYTE/2
	jbe	PsHandleNode		;brif positive relative branch
	sub	ax,ENCODE1BYTE		;negative relative branch

;ax = state to branch to if we recognize(consume) what we're expecting
PsHandleNode:
	mov	di,ax			;di = pStateTrue
	mov	[pStateCur],ax		;set static var for error reporting
	mov	ax,[nodeId]
	cmp	ax,ND_BRANCH
	je	GotBranch		;brif got unconditional branch
	;got a token or nonterminal node
	sub	ax,ND_BRANCH + 1
	cmp	ax,NUMNTINT
	jae	PsNotIntNt
	;we expect a non-terminal described by a state tree
	mov	bx,ax
	shl	bx,1
	mov	ax,WORD PTR cs:tIntNtDisp[bx]
	add	ax,OFFSET CP:tState	;ax = pState = &(tState[oState])
	call	NtParse			;result = Parse(tIntNtDisp[nodeId])
	jmp	SHORT CheckResult

;ax = node id - (ND_BRANCH + 1)
PsNotIntNt:
	sub	ax,NUMNTINT
	cmp	ax,NUMNTEXT
	jae	GotResWord		;brif expecting a reserved word token
	;we expect a non-terminal defined by a C function
	mov	bx,ax
	shl	bx,1
	call	cs:tExtNtDisp[bx]	;result = (*tExtNtDisp[nodeId])()

;al = PR_NotFound, PR_BadSyntax, or PR_GoodSyntax
CheckResult:
	or	al,al
	jg	RecognizedToken		;brif result was PR_GoodSyntax
	jl	ParseExit		;brif result was PR_BadSyntax
					; non-terminal already generated
					; complete error message
	jmp	ParseLoop		;else result == PR_NotFound, continue
					; scanning by taking FALSE branch from
					; current node

;Unconditional branch to a new parse-state
GotBranch:
	mov	si,di			;si = pStateTrue
					;unconditional branch to another state,
J1_ParseLoop:
	jmp	ParseLoop		;continue scanning

;Expect a reserved word
;ax = node id - (ND_BRANCH + 1) - NUMNTINT
GotResWord:
	sub	ax,NUMNTEXT		;ax=expected res word's IRW_xxx
	mov	bx,[pTokScan]		;bx -> current token
	cmp	WORD PTR [bx],CL_RESWORD
	jne	J1_ParseLoop		;brif token isn't a reserved word
	cmp	[bx.TOK_rw_iRw],ax	;ax = current token's IRW_xxx
	jne	J1_ParseLoop		;brif expected token was not found,
					; continue scanning by taking FALSE
					; branch from current node
	call	ScanTok			;skip recognized token
RecognizedToken:
	or	di,di			;test for pStateTrue for NULL
	je	GotAcceptNode		;brif got acceptance state transition
					;else take TRUE transition out of this
	mov	si,di			; state to another node
	mov	[pStateLastGood],di	;save for error reporting
J2_ParseLoop:
	jmp	ParseLoop

;Got to a leaf node of the parse tree which is not an accepting node,
; ie. we were unable to recognize what Parse() was called to recognize.
; If we didn't get what was expected, but didn't emit code (see note below)
; or consume any
; tokens, its not necessarily a syntax error yet.  If Parse() was called to
; consume some non-terminal, let the caller continue trying other options
; (if any), and when they are all exausted, the caller will generate an
; error msg.
;NOTE: NtParse does not actually test whether any pcode was emitted and so
;NOTE: will still return PR_NotFound even if some pcode has been emitted
;NOTE: as long as no tokens have been consumed. This is used to advantage
;NOTE: in the NonTerminal "AsClause" which will return PR_NotFound for
;NOTE: 		"AS REAL" even though it will emit an opcode.
;
GotRejectNode:
	mov	al,[cTokScan]
	cmp	[cTokFirst],al
	mov	al,PR_NotFound
	je	ParseExit
	call	PErrState		;Produce error message "Expected <a>
					; or <b> or ..."
					;al = PR_BadSyntax
	jmp	SHORT ParseExit

;We recognized parse tree described by initial pState
GotAcceptNode:
	mov	al,PR_GoodSyntax
ParseExit:
	or	al,al			;set condition codes for caller
cEnd	NtParse

;===========================================================================
;    M I S C    P A R S E R    R E C O G N I Z I N G    F U N C T I O N S
;
;    NOTE:  These functions are arranged alphabetically
;
;=======================================================================

;**********************************************************************
; PARSE_RESULT NEAR NtAssignment()
;
; Purpose:
;	Called for the 'LET "var=exp"' statement
;
;******************************************************************
PUBLIC	NtAssignment
NtAssignment PROC NEAR
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_id
	jne	NtAssBadSyntax
	push	bx			;Tell NtImpliedLetOrCall that
					; it must be LET, not CALL
	call	NtImpliedLetOrCall	;al = result
NtAssExit:
	ret
NtAssignment ENDP

NtAssBadSyntax:
	sub	al,al			;al = PR_NotFound
	jmp	SHORT NtAssExit

;*******************************************************************************
; PARSE_RESULT NEAR NtCommaNoEos()
;
; Purpose:
;	Special nonterminal for a comma which is followed by optional arguments.
;	Rather than generate oodles of state table, this nonterminal is used to
;	make sure that the comma, if present, is NOT followed by end of line or
;	end of statement. Generates an opComma if comma found and all is okay.
;
; Returns:
;	PR_NotFound	- no comma found
;	PR_GoodSyntax	- comma found, followed by something.
;	PR_BadSyntax	- comma found, followed by end of statement.
;
;***************************************************************************
cProc	NtCommaNoEos <PUBLIC,NEAR>
cBegin
	mov	ax,IRW_Comma
	call	TestScan_AX
	jne	NoComma			;branch if current token isn't comma
	call	ScanTok			;consume the comma
	call	NtEndStatement
	mov	al,PR_GoodSyntax
	je	NtComExit		;branch if not end-of-statement
	jmp	PErrExpExpr		;Error: expected expression
					; return al = PR_BadSyntax
NoComma:
	sub	al,al			;return PR_NotFound
NtComExit:
cEnd

;**********************************************************************
; PARSE_RESULT NEAR NtEndPrint()
;
; Purpose:
;	Called during a PRINT expression list.
;
; Exit:
;	Always returns PR_NotFound.
;
;******************************************************************
cProc	NtEndPrint <PUBLIC,NEAR>
cBegin	NtEndPrint
	mov	ax,IRW_ELSE
	call	TestScan_AX
	je	GotPrintEos		;branch if current token is ELSE
	call	NtEndStatement		;check for end-of-statement
	je	NotPrintEos		;branch if not end-of-statement
GotPrintEos:
	cmp	[fNeedPrintEos],FALSE
	je	NotPrintEos		;branch if we don't need to emit
	mov	ax,opPrintEos		; opPrintEos to terminate the PRINT
	call	Emit16_AX
NotPrintEos:
	mov	[fNeedPrintEos],0FFh	;set flag to TRUE (non-zero)
	sub	al,al			;return(PR_NotFound)
cEnd	NtEndPrint

;**********************************************************************
; PARSE_RESULT NEAR NtEndPrintExp()
;
; Purpose:
;	Called during a PRINT expression list after an expression has been
;	parsed.
;
; Exit:
;  Always returns PR_GoodSyntax.
;
;******************************************************************
cProc	NtEndPrintExp <PUBLIC,NEAR>
cBegin	NtEndPrintExp
	mov	ax,IRW_ELSE
	call	TestScan_AX		;see if current token is ELSE
	je	GotPrExpEos		;branch if it is
	call	NtEndStatement		;see if current token is end-of-stmt
	je	NotPrExpEos		;branch if not
GotPrExpEos:
	mov	ax,opPrintItemEos
	call	Emit16_AX		;emit end-of-stmt print terminator
	mov	[fNeedPrintEos],FALSE	;so NtEndPrint() won't terminate
	jmp	SHORT NtEndPrGoodSyntax	; print item list with opPrintEos

NotPrExpEos:
	mov	ax,opPrintItemSemi
	call	Emit16_AX
NtEndPrGoodSyntax:
	mov	al,PR_GoodSyntax
cEnd	NtEndPrintExp

;**********************************************************************
; STATICF(uchar) TestLet()
;
; Purpose:
;	Test to see if 'pTokScan' is a 1 letter identifier from 'A' - 'Z'
;
; Exit:
;	al = 0..25 for A-Z and a-z.
;	     26 if its not an ID from A-Z.
;
;******************************************************************
cProc	TestLet <PUBLIC,NEAR>
cBegin	TestLet
	mov	bx,[pTokScan]		;bx points to current token
	mov	ax,26D			;prepare for FALSE return
	cmp	[bx.TOK_class],CL_id
	jne	TestLetExit		;branch if not an id token
	mov	al,[bx.TOK_id_charFirst]
					;al = id's 1st char
TestLetExit:
cEnd	TestLet

;**********************************************************************
; PARSE_RESULT NEAR NtDeflistXX()
;
; Purpose:
;	Parse a letter range like "A-F,X" for statements like DEFINT.
;	If it is not recognized at all, return value is PR_NotFound.
;	If it is only partially found, like "A-", return value is PR_BadSyntax.
;	If it is found, a 32 bit mask is emitted, the tokens are consumed
;	   and the return value is PR_GoodSyntax.
;
; Exit:
;	Emits <opStDefType><link field><low-word><high-word>
;	where
;	   <high-word> has 1 bit set for each letter from A..P
;	   <low-word> has 1 bit set for each letter from Q..Z in the
;		high bits, and type (ET_I2..ET_SD) in the low 3 bits.
;	Updates ps.tEtCur[]
;	It never returns PR_NotFound because the bnf guarentees that
;	nothing else can follow DEFINT.
;
;******************************************************************
SKIP2_BX MACRO
	db	0BBH		;mov bx,<immediate word>
	ENDM

PUBLIC	NtDefListR4
NtDefListR4 PROC NEAR
	mov	al,ET_R4
	SKIP2_BX			;load next 2 bytes to bx (fall through)
NtDefListR4 ENDP
	;fall through



PUBLIC	NtDefListI2
NtDefListI2 PROC NEAR
	mov	al,ET_I2
	SKIP2_BX			;load next 2 bytes to bx (fall through)
NtDefListI2 ENDP
	;fall through

PUBLIC	NtDefListI4
NtDefListI4 PROC NEAR
	mov	al,ET_I4
	SKIP2_BX			;load next 2 bytes to bx (fall through)
NtDefListI4 ENDP
	;fall through

PUBLIC	NtDefListR8
NtDefListR8 PROC NEAR
	mov	al,ET_R8
	SKIP2_BX			;load next 2 bytes to bx (fall through)
NtDefListR8 ENDP
	;fall through

PUBLIC	NtDefListSD
NtDefListSD PROC NEAR
	mov	al,ET_SD
NtDefListSD ENDP
	;fall through
;register conventions:
; bl = 1st char of A-Z pair
; bh = 2nd char of A-Z pair
; si points to maskCur
;
cProc	NtDeflist <PUBLIC,NEAR>,<si,di>
	localW	maskSumLOW
	localW	maskSumHIGH
	localB	oTyp
cBegin	NtDeflist
	mov	[oTyp],al		;save input parm
	sub	ax,ax
	lea	si,[maskSumHIGH]	;si doesn't change for rest of NtDeflist
	mov	[si],ax			;maskSumHIGH = 0
	mov	[si+2],ax		;maskSumLOW = 0
DefListLoop:
	call	TestLet			;al = 1st letter of current token
	cmp	al,26D
	jne	GotValidLetter		;branch if got a valid letter
DefExpLetter:
	;Got something like DEFINT <end-of-stmt> or DEFINT A-B,
	mov	ax,MSG_Letter		;Error: expected letter
	call	PErrExpMsg_AX		; al = PR_BadSyntax
	jmp	short DefListExit

GotValidLetter:
	mov	bl,al			;bl = 1st char
	mov	bh,al			;default bh 2nd char to 1st char
	mov	di,bx			;save letters in di
	call	ScanTok			;skip 1st letter
	mov	ax,IRW_Minus		;check for '-'
	call	TestScan_AX
	jne	NoDefDash		;branch if no '-'
	call	ScanTok			;skip '-'
	call	TestLet			;al = 1st letter of current token
	cmp	al,26D
	je	DefExpLetter
	mov	bx,di			;restore bl = 1st char
	mov	bh,al			;bh = 2nd char of A-Z pair
	mov	di,bx
	call	ScanTok			;skip 2nd letter
NoDefDash:
	mov	bx,di			;restore bl,bh = 1st,2nd chars
	cmp	bl,bh
	jbe	SetTheBits		;branch if 1st char <= 2nd char
	xchg	bl,bh			;Treat DEFINT S-A same as DEFINT A-S

;bl = 1st char to set, bh = last char to set (0..25)
;cl = current letter (0..25)
;ax:dx = maskCur
;
SetTheBits:
	mov	ax,08000H
	sub	dx,dx			;maskCur = 0x80000000
	mov	cl,dl			;current letter = 0
BitSetLoop:
	cmp	cl,bh			;compare current with final
	ja	BitSetEnd		;branch if end of loop
	cmp	cl,bl
	jb	DontSetThisOne
	or	[si],ax			;or ax:dx bits into maskSum
	or	[si+2],dx
DontSetThisOne:
	shr	ax,1			;shift ax:dx right by 1
	rcr	dx,1
	inc	cl			;bump current char
	jmp	SHORT BitSetLoop

BitSetEnd:
	mov	ax,IRW_Comma
	call	TestScan_AX
	jne	DefEndOfList		;branch if no comma
	call	ScanTok			;skip comma
	jmp	DefListLoop

DefEndOfList:
	mov	ax,opStDefType
	call	Emit16_AX
	call	Emit16_0		;leave room for link field
	mov	ax,[si+2]		;ax = low word
	or	al,[oTyp]		;or oTyp into low 6 bits
	call	Emit16_AX		;emit low word first
	mov	ax,[si]			;emit high word second
	call	Emit16_AX

	;update ps.tEtCur[] for source lines like DEFINT A-Z:b=1
	
	lodsw				;ax = maskSumHIGH
	push	ax			
	push	[si]			; maskSumLOW
	mov	bl,[oTyp]		;bl = ET_xxx to set
	push	bx			
	call	far ptr SetDefBits	; update ps.tEtCur table
	mov	al,PR_GoodSyntax
DefListExit:
cEnd	NtDeflist

;**********************************************************************
; SetDefBits
; Purpose:
;	Update the current default-type array as a result of scanning
;	a DEFINT..DEFSTR statement
;	This is used by both the Parser and Static Scanner
; Entry:
;	maskSumHIGH:maskSumLOW = DEFTYPE bit mask, as would appear in
;				 opStDefType's operand
;	defET = ET_xxx to store in si for each bit set in ax:dx
;	ps.tEtCur filled with current default types (one ET_xxx for each letter)
; Exit:
;	ps.tEtCur is updated according to mask
;
;**********************************************************************
cProc	SetDefBits,<PUBLIC,FAR>,<SI>	
	parmW	maskSumLOW
	parmW	maskSumHIGH
	parmB	defET
cBegin
	mov	si,dataOFFSET ps.PS_tEtCur
					;si points to table to be updated
	mov	cx,26D			;cx = repeat count (1 for each letter)
	mov	dx,[maskSumHIGH]	
	mov	ax,[maskSumLOW] 	
	mov	bl,[defET]		
BitTestLoop:
	shl	dx,1			;shift ax:dx left 1
	rcl	ax,1
	jnc	BitNotSet		;branch if this bit is not set
	mov	[si],bl			;store new type in type table
BitNotSet:
	inc	si			;advance to next byte
	loop	BitTestLoop
cEnd



;======================================================================
;	  Ambiguous Statement resolving functions.
;
;	  These functions are needed where the BNF specifies 2 or more
;		statements which begin with the same keyword.  These functions
;		look ahead in the pcode to decide which of the statements we're
;		really looking at.
;
;==================================================================

OSTMT1 EQU 0	; offset from current position in reserved word table
		; for the first (as ordered in bnf.prs) 
		; of the possible statements.
OSTMT2 EQU 6	; offset for the second possible statement

;*******************************************************************************
; ushort NEAR AmDEF()
;
; Purpose:
;	Determine if statement is a DEF FN or a DEF SEG statement.
; Exit:
;	ax = offset into reserved word entry for correct statement
;
;***************************************************************************
PUBLIC	AmDef
AmDef	PROC NEAR
	mov	ax,IRW_SEG
	jmp	SHORT AmCommon
AmDef	ENDP

;*******************************************************************************
; ushort NEAR AmGET(), AmPut()
;
; Purpose:
;	Determine if statement is a graphics or I/O GET/PUT.
;
; Method:
;	If GET/PUT is followed by a left paren or STEP, this must be
;	a graphics GET/PUT.
;
;***************************************************************************
PUBLIC	AmGet
AmGet	PROC NEAR
AmGet	ENDP
	;fall into AmPut
PUBLIC	AmPut
AmPut	PROC NEAR
	call	Peek1Tok
	mov	ax,IRW_STEP
	call	TestPeek_AX
	je	AmGotExpected		;brif followed by STEP
	mov	ax,IRW_LParen
	jmp	SHORT AmTestPeek	;see if followed by '('
AmPut	ENDP

;*******************************************************************************
; ushort NEAR AmLINE()
;
; Purpose:
;	Determine whether statement is a LINE INPUT or a graphics
;	LINE statement.
;
; Method:
;	We just look at the next token in the input stream. If it is INPUT, then
;	we know it's a LINE INPUT, else it's a graphics line command.
;
;***************************************************************************
PUBLIC	AmLine
AmLine	PROC NEAR
	mov	ax,IRW_INPUT
AmLine	ENDP
	;fall into AmCommon

; Entry:
;	ax = reserved word id (IRW_xxx) for token for 2nd stmt in list
; Exit:
;	ax = OSTMT2 if reserved word found, OSTMT1 (0) if not
;
AmCommon PROC NEAR
	push	ax
	call	Peek1Tok		;peek at next token
	pop	ax			;ax = token we're looking for
AmTestPeek:
	call	TestPeek_AX
AmGotExpected:
	mov	ax,OSTMT2		;assume next token is [ax]
	je	AmExit			;branch if next token is [ax]
	sub	ax,ax			;ax = 0
AmExit:
	ret
AmCommon ENDP

;*******************************************************************************
; ushort NEAR AmPLAY()
;
; Purpose:
;	Determine if we're starting a PLAY event switch statement,
;	or the standard PLAY statement.
;
;***************************************************************************
PLAY_STMT EQU 0
PLAY_EVENT EQU 6
PUBLIC	AmPlay
AmPlay	PROC NEAR
	call	Peek1Tok		;peek at next token
	mov	ax,IRW_ON
	call	TestPeek_AX
	je	AmPlayEvent		;branch if next token is ON
	mov	ax,IRW_OFF
	call	TestPeek_AX
	je	AmPlayEvent		;branch if next token is OFF
	mov	ax,IRW_STOP
	call	TestPeek_AX
	je	AmPlayEvent		;branch if next token is STOP
	sub	ax,ax			;ax = PLAY_STMT
	jmp	SHORT AmPlayExit

AmPlayEvent:
	mov	ax,PLAY_EVENT
AmPlayExit:
	ret
AmPlay	ENDP

CP	ENDS
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsstmt.asm ===
TITLE	prsstmt.asm - Parser Statement Parsing

;==========================================================================
;
;  Module:  prsstmt.asm - Parser Statement Parsing
;  Subsystem:  Parser
;  System:  Quick BASIC Interpreter
;  Copyright <C> 1985, Microsoft Corporation
;
;  Note:
;	See general comments at top of prsnt.asm
;
;=========================================================================

	include version.inc
	PRSSTMT_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce msgshort
	includeOnce opmin
	includeOnce opstmt
	includeOnce parser
	includeOnce prsirw
	includeOnce prstab
	includeOnce psint
	includeOnce util
	includeOnce variable			;needed for mkVar

sBegin	DATA





sEnd	DATA

sBegin	CP
assumes	CS,CP
assumes	DS,DATA
assumes	SS,DATA
assumes ES,NOTHING

;**********************************************************************
; PARSE_RESULT NEAR NtStatement()
;
; Purpose:
;	Parse the start of a sequence of statements.
;
; Entry:
;	pTokScan = 1st token of statement list.
;
; Exit:
;	If no statement is recognized, no tokens are consumed and the
;	   return value is PR_NotFound.
;	If the statement head is recognized, the token is consumend,
;	   code is emitted and the entire statement is parsed.
;	   If it was good syntax, return value is PR_GoodSyntax.
;	   If it was bad syntax, return value is PR_BadSyntax.
;	Condition codes set based on value in al
;
;******************************************************************
cProc	NtStatement <PUBLIC,NODATA,NEAR>,<si,di>
	localW	pState
	localW	pCgFunc			
	localW	cgArg
cBegin	NtStatement
	sub	ax,ax			;ax = 0
	mov	[mkVar.MKVAR_flags],ax
	mov	[cIdArgs],ax		;cIdArgs = 0 (used by NtId())
	mov	[pCgFunc],ax		;assume no post-stmt code generator 
	mov	bx,[pTokScan]		;bx points to current token
	cmp	[bx.TOK_class],CL_id
	jne	NotImplied		;branch if token wasn't an id
	sub	ax,ax			;allow LET or CALL
	push	ax
	call	NtImpliedLetOrCall	;parse implied LET or CALL 
	jg	J_CheckForEos		;brif PR_GoodSyntax, parse end-of-stmt
	jmp	NtStmtExit		;branch if PR_NotFound or PR_BadSyntax

J_CheckForEos:
	jmp	CheckForEos

;bx points to 1st token in statement
NotImplied:
	mov	[pCurStkMark],MAX_STK_MARK
					;reset stack used by MARK bnf directive
	cmp	[bx.TOK_class],CL_resWord
	jne	NtStmtNotFound
	mov	di,[bx.TOK_rw_rwf]	;di = reserved word flags
	mov	cx,[bx.TOK_rw_iRw]	;cx = reserved word's id
	test	di,RWF_NSTMTS
	jne	GotStmt

	;Reserved word table says this res word can't begin a statement.
	;Check for special cases. 
	
	mov	ax,opStData
	cmp	cx,IRW_DATA
	je	EmitTheRem		;branch if stmt is DATA
	mov	ax,opStRem
	cmp	cx,IRW_REM		;branch if stmt is REM
	je	EmitTheRem
	cmp	cx,IRW_SQuote
	jne	NtStmtNotFound		;branch if stmt isn't '<rem>
GotSQuote:
	mov	ax,opQuoteRem
EmitTheRem:
	push	ax			;pass opcode to be emitted
	call	NtEmitRem		;emit REM/DATA, al = PR_GoodSyntax
	jle	J1_NtStmtExit		;brif bad syntax (return AL as result)
	jmp	CheckForEos		;brif good syntax

NtStmtNotFound:
	sub	al,al			;ax = PR_NotFound
J1_NtStmtExit:
	jmp	NtStmtExit

;got a statement reserved word 
; bx points to 1st token in statement (current token)
; di = reserved word flags
; cx = reserved word's id
;
GotStmt:
	;Fetch info for a particular intrinsic function out of the
	;parser's reserved word table 'tRw'.
	
	.errnz	IRW_DEFINT - IRW_DEFDBL - 1
	.errnz	IRW_DEFLNG - IRW_DEFDBL - 2
	.errnz	IRW_DEFSNG - IRW_DEFDBL - 3
	.errnz	IRW_DEFSTR - IRW_DEFDBL - 4
	xchg	ax,cx			;ax = iRw
	cmp	ax,IRW_DEFDBL
	jb	NotDefType
	cmp	ax,IRW_DEFSTR
	ja	NotDefType
	or	[psFlags],PSIF_NoCaseChg
	;no identifiers in rest of this statement will affect nammgr's
	;upper/lower case of identifiers.  Otherwise, DEFINT A-Z would
	;change statements like a=z to A=Z
NotDefType:
	test	[psFlags],PSIF_fNot1stStmt
	je	FirstStmt		;brif this is 1st stmt on line
	cmp	ax,IRW_ELSE
	je	NtStmtNotFound		;brif got ELSE
	cmp	ax,IRW_ELSEIF
	je	NtStmtNotFound		;brif not ELSEIF
FirstStmt:
	mov	si,[bx.TOK_rw_pArgs]	;si -> pRwArgs in tRw
	test	di,RWF_FUNC
	je	NoFunc			;brif this res word is not an Intrinsic
	lodsw				;skip intrinsic's oState (lodsw is a
					; small-code way to bump si by 2.
					; Speed doesn't matter in this case)
	test	di,RWF_FUNC_CG
	je	NoFunc			;branch if no code generator for func
	lodsw				;skip intrinsic's code gen info
	lodsw
NoFunc:
	;There are 2 or more different statements which can begin
	; with this reserved word.  We now call a function which
	; looks ahead in the pcode to resolve the ambiguity.
	
	mov	ax,di			;ax = reserved word flags
	and	ax,RWF_NSTMTS		;ax = num stmts beginning with res word
	dec	ax
	je	NoAmbiguity		;branch if only 1
	lods	WORD PTR cs:[si]	;ax=adr of look-ahead function
	call	ax			;invoke it to resolve ambiguity
					;ax = 0,6,12,... for correct stmt
	add	si,ax			;advance to proper stmt's info
NoAmbiguity:
	lods	WORD PTR cs:[si]	;ax=state table offset for stmt's syntax
	add	ax,OFFSET CP:tState	;pState = &(tState[oState])
	mov	[pState],ax
	test	di,RWF_STMT_CG
	je	NoStmtCg		;branch if no code generator for stmt
	lods	WORD PTR cs:[si]	;ax=adr of code generation func
	mov	[pCgFunc],ax
	lods	WORD PTR cs:[si]	;ax=arg to pass to code generation func
	mov	[cgArg],ax
NoStmtCg:
	cmp	[grs.GRS_fDirect],0
	je	NotProtDirect		;brif we're not parsing a direct mode
					; statement 
	test	di,RWF_NO_DIRECT
	jne	ErrorId			;branch if stmt illegal in direct mode
NoScanner:

;Beyond this point, we can only return PR_GoodSyntax or PR_BadSyntax 
;because we've consumed something.
;
NotProtDirect:
	call	ScanTok			;skip keyword token 
	mov	ax,[pState]
	mov	[pStateLastScan],ax
	call	NtParse			;parse the statement @ ax
	jle	StmtNotGood		;branch if result wasn't PR_GoodSyntax
	cmp	[ps.PS_errCode],0
	jne	CheckForEos		;brif got some error like out-of-memory
	mov	dx,[pCgFunc]
	or	dx,dx
	je	CheckForEos		;brif no code generator to be called
	mov	ax,[cgArg]		;pass cgArg (opcode) in ax
	call	dx			;invoke code generation routine 
CheckForEos:
	or	[psFlags],PSIF_fNot1stStmt ;no longer 1st stmt on line
	jmp	SHORT NtStmtGoodSyntax

StmtNotGood:
	jl	NtStmtExit		;branch if Parse() returned PR_BadSyntax
	call	PErrState		; or <b> or ..." 
					;al = PR_BadSyntax
	SKIP2_PSW			;skip  mov al,PR_GoodSyntax  instr
NtStmtGoodSyntax:
	mov	al,PR_GoodSyntax
NtStmtExit:
	and	[psFlags],NOT PSIF_NoCaseChg
	or	al,al			;set condition codes for caller
cEnd	NtStatement

ErrorId:
	mov	ax,ER_ID		;Error: Stmt is illegal in Direct Mode 
	call	PErrMsg_AX		; al = PR_BadSyntax
	jmp	SHORT NtStmtExit

;**********************************************************************
; PARSE_RESULT NEAR NtStatementList()
;
; Purpose:
;	Parse 0 or more statements of the form: Statement {: [Statement]}
;
; Entry:
;	pTokScan = 1st token of statement list.
;
; Exit:
;	If no statement is recognized, no tokens are consumed and the
;	   return value is PR_NotFound.
;	If the statement head is recognized, the token is consumend,
;	   code is emitted and the entire statement is parsed.
;	   If it was good syntax, return value is PR_GoodSyntax.
;	   If it was bad syntax, return value is PR_BadSyntax.
;	Condition codes set based on al (return value)
;
;******************************************************************
; NOTE: Control flow may appear strange, but is optimized for "Typical case"
;
;NtStatementList0 is called by ParseLine() for the source line.
;NtStatementList is called for blocks within a 1 line THEN or ELSE clause
;
PUBLIC	NtStatementList, NtStatementList0
NtStatementList PROC NEAR
	or	[psFlags],PSIF_fNot1stStmt ;no longer 1st stmt on line
NtStatementList ENDP
;fall into NtStatementList0
NtStatementList0 PROC NEAR
	push	si			;preserve caller's si
	sub	si,si			;prepare to return PR_NotFound
StmtLoop:
	call	NtStatement		;parse 1 statement
	jle	NtStmtNotGood		;branch if result != PR_GoodSyntax
	inc	si			;remember we've consumed something
					; assumes no more than 32767 statements
					; per line (very safe)
TryColon:
	mov	ax,IRW_Colon
	call	TestScan_AX		;bx points to current token
	jne	NotColon		;branch if didn't get a ':'
	push	[bx.TOK_oSrc]		;save column of :
	inc	si			;remember we've consumed something
	call	ScanTok			;skip ':', bx points to next token
	pop	ax			;ax = column of :
	sub	ax,[bx.TOK_oSrc]	;ax = -#spaces between : and next token
	cmp	al,-2
	jl	BosSp			;brif more than 1 space
	mov	ax,opBos		;emit statement separator 
	call	Emit16_AX
	jmp	SHORT StmtLoop		;test return value

BosSp:
	push	[bx.TOK_oSrc]		;pass column of token after : to Emit16
	mov	ax,opBosSp		;emit statement separator 
	call	Emit16_AX
	call	Emit16			;emit column
	jmp	SHORT StmtLoop		;test return value

NotColon:
	mov	ax,IRW_SQuote
	call	TestScan_AX
	je	StmtLoop		;branch if got a 'comment
	mov	al,PR_GoodSyntax	;if we've consumed anything, return
	or	si,si			; PR_GoodSyntax
	jne	NtStmtListExit
	sub	al,al			;return PR_NotFound
	jmp	SHORT NtStmtListExit	;return PR_BadSyntax (cond codes set)

;al = PR_NotFound or PR_BadSyntax after calling NtStatement
NtStmtNotGood:
	je	TryColon		;brif NtStatement returned PR_NotFound
NtStmtListExit:
	pop	si			;restore caller's si
	ret
NtStatementList0 ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtEndStatement()
;
; Purpose:
;	Parse End-of-Statement or End-of-Line, but don't consume any
;	tokens or emit any opcodes.
;
; Exit:
;	Returns PR_GoodSyntax if pTokScan is either End-Statement or End-Line.
;	Otherwise returns PR_NotFound.
;	condition codes are set via or al,al.
;
;******************************************************************
PUBLIC NtEndStatement
NtEndStatement PROC NEAR
	call	NtEndLine
	jg	NtEndExit		;brif got end-of-line
	cmp	cx,IRW_Colon		;NtEndLine set cx=token's IRW_xxx
	je	NtEndGood		;branch if token is ':'
	cmp	cx,IRW_ELSE
	jne	NtEndExit		;branch if token isn't 'ELSE' (returning
					; PR_NotFound as set by NtEndLine)
NtEndGood:
	mov	al,PR_GoodSyntax	;return PR_GoodSyntax for ':'
NtEndExit:
	or	al,al			;set condition codes for caller
	ret
NtEndStatement ENDP

;**********************************************************************
; PARSE_RESULT NEAR NtEndLine()
;
; Purpose:
;	Parse End-of-Line, but don't consume any tokens or emit any opcodes.
;
; Exit:
;	Returns PR_GoodSyntax if pTokScan is End-of-Line.
;	Otherwise returns PR_NotFound.
;	If token is res word, its IRW_xxx is returned in cx
;	condition codes are set via or al,al.
;
;******************************************************************
PUBLIC	NtEndLine
NtEndLine PROC NEAR
	mov	bx,[pTokScan]		;bx points to current token
	sub	cx,cx			;cx = impossible IRW_xxx
	cmp	[bx.TOK_class],CL_resWord
	jne	NotEol			;branch if not a reserved word token
	mov	al,PR_GoodSyntax	;prepare to return Good Syntax
	mov	cx,[bx.TOK_rw_iRw]	;cx = reserved word's id
	cmp	cx,IRW_NewLine
	je	GotEol			;branch if token is newline
	cmp	cx,IRW_SQuote
	je	GotEol			;branch if token is single quote rem
NotEol:
	sub	al,al			;return PR_NotFound
GotEol:
	or	al,al			;set condition codes for caller
	ret
NtEndLine ENDP


CP	ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\rttemp.asm ===
page	,132
	TITLE	RtTemp - Temporary Runtime Routines


COMMENT \

--------- --- ---- -- ---------
COPYRIGHT (C) 1982 BY MICROSOFT
--------- --- ---- -- ---------

RtTemp is a file of routines that will be replaced with the common
runtime.

------------------
Revision History:
------------------


	\

	page

	.xlist
	RTTEMP_ASM = 1
	include 	version.inc
	IncludeOnce	executor
	IncludeOnce	msdos
	IncludeOnce	rttemp
	.list

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

sBegin	DATA
sEnd	DATA


sBegin	CODE
assumes CS,CODE

subttl	Internal Debug Function Timer
page

sEnd	CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\qbidata.c ===
/*** 
*qbidata.c - allocate global variable storage for EXTERNAL variables
*
*	Copyright <C> 1986, Microsoft Corporation
*
*Purpose:
*	Variables declared with the EXTERNAL declaration are included as
*	'EXTERNAL' in every other module, but not in this module - - - this
*	module is linked in for the express purpose of allocating storage for
*	these variables (mrsCur, etc.) in just one place. DEFINE_VARIABLES
*	should be OFF in every module but this one (see interp.h & switch.h).
*
*******************************************************************************/
#define DEFINE_VARIABLES ON  /* note: must do this BEFORE version.h included! */

#include "version.h"

#if !CONTEXT_H
#include "context.h"
#endif

#if !EXECUTOR_H
#include "executor.h"
#endif

#if !HEAP_H
#include "heap.h"
#endif

#if !PARSER_H
#include "parser.h"
#endif

#if !PSINT_H
#include "psint.h"
#endif

#if !RTINTERP_H
#include "rtinterp.h"
#endif

#if !SCANNER_H
#include "scanner.h"
#endif

#if !TXTINT_H
#include "txtint.h"
#endif

#if !TXTMGR_H
#include "txtmgr.h"
#endif

#if !UI_H
#include "ui.h"
#endif

#if !VARIABLE_H
#include "variable.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\rsalpha.asm ===
TITLE	RsAlpha.asm - Alphabetical Register Set Functions

;==========================================================================
;
;Module:  RsAlpha.asm - Alphabetical Register Set Functions
;System:  Quick BASIC Interpreter
;SubSystem:  Register Set Manager
;
;=========================================================================*/

	include		version.inc
	RSALPHA_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	names			
	includeOnce	util

	assumes ds,DATA
	assumes ss,DATA
	assumes es,NOTHING

sBegin	DATA	
	globalB bdAlphaRs,NULL,<SIZE BD>
sEnd	DATA

sBegin	CP
assumes cs,CP

;**************************************************************************
; void InsertAlpha
; Purpose:
;	Inserts grs.oRsCur into rgRs in the appropriate spot
;	(based on alphabetical order) between iFirst and iLast.
;
; Entry:
;	grs.oRsCur is oRs to be inserted into table
;	si = 1st index to compare with
;	si + di = last index to compare with + 1
;
; Exit:
;	di is bumped by 1
;
;**************************************************************************
cProc	InsertAlpha,<NEAR>
cBegin
	push	si			;save caller's si,di
	push	di

	add	di,si			;di = stopping index
	dec	si
IaLoop1:
	inc	si
	cmp	si,di
	jae	IaDone1			;brif end of range of oRs's to compare
	push	si			;save current index

	xchg	ax,si			;ax = index of oRs to compare with
	call	ORsOfAlphaCP		;ax = oRs to compare with oRsCur
	GETRS_SEG es,bx,<SIZE,LOAD>	;[3]
	mov	bx,DATAOFFSET mrsCur.MRS_ogNam 
	sub	si,si			
	RS_BASE mov,si			; es:si points to base of Rs table
	or	ax,ax
	jns	GotAnMrs
	and	ah,7Fh			;ax = oPrs
	mov	bx,DATAOFFSET prsCur.PRS_ogNam 

;bx points to ogNam for oRsCur 		
;es:si points to base of Rs table
;ax = oMrs or oPrs of oRs to compare with oRsCur
;
GotAnMrs:
	.errnz	MRS_ogNam - PRS_ogNam	
	add	si,ax			;si = pMrs or pPrs for oRs in table
;***** Begin revision [08]
	mov	cx, [bx]		;get ogNam1
	mov	dx,PTRRS[si.MRS_ogNam]	;get ogNam2
	pop	si			;restore si = index of oRs in table

	.errnz	OGNAM_UNNAMED		
	jcxz	IaDone1			;if ogNam1 == OGNAM_UNNAMED then
					;   ogNam1 < OGNAM_UNNAMED

	xchg	dx,cx			;dx = ogNam1, cx = ogNam2
	jcxz	IaLoop1			;if ogNam2 == OGNAM_UNNAMED then
					;   ogNam1 > ogNam2

	push	dx			; ogNam1
	push	cx			;[1] ogNam2
;***** End revision [08]
	call	CmpOgNamIns		; returns:
	;				;     ax = 0 if substrings match,
					;     ax = FFFF if str1 < str2
					;	 ax = 1 if str1 > str2
					;	 dx > 0 if str1 longer than str2
					;	 dx < 0 if str1 shrter than str2
					;	 dx = 0 if they're same length
					;     PSW set via an OR AX,AX

	jne	CmpDiff			; brif strings differ in their subset
	xchg	ax,dx			;ax identifies which string is longer
CmpDiff:
	or	ax,ax
	jg	IaLoop1			;brif have not found insertion point
					; i.e. oRsCur is alphabetically
					; greater than the oRs in the table @ si

;si = index of slot to use for new oRs.
; copy all existing entries from si to the end of the table up 2 bytes
;
IaDone1:
	mov	di,[bdAlphaRs.BD_cbLogical]
	dec	di
	mov	cx,di
	shl	si,1			;convert index count to byte count
	sub	cx,si			;cx = # bytes to be moved
	add	di,[bdAlphaRs.BD_pb]	;di points to last byte to transfer
	mov	si,di
	dec	si
	dec	si			;si points to 1st byte to transfer
	push	ss			
	pop	es
	std
	rep movsb
	cld
	mov	ax,[grs.GRS_oRsCur]
	stosw				;insert new oRs in table
	pop	di
	pop	si
	inc	di			;bump caller's di
cEnd

;**************************************************************************
; ushort AlphaBuildORs()
; Purpose:
;	Build an alphabetically sorted list of register sets if one
;	does not already exist.  This is called by any functions that
;	need to reference ORsOfAlpha or AlphaOrORs.
;	Name changed from AlphaORsBuild as revision [9].
; Exit:
;	returns number of entries in the table.
;	returns 0 if out-of-memory
;
;**************************************************************************
cProc	AlphaBuildORs,<PUBLIC,FAR>,<si,di>
	localW	cMrs
cBegin
	cmp	[bdAlphaRs.BD_pb],NULL
	je	BldAlloc
	jmp	BldExists		;brif table already created
BldAlloc:
	mov	ax,[grs.GRS_bdRs.BD_cbLogical]	
	sub	dx,dx			;dx:ax = size of Rs table
	mov	cx,SIZE PRS		;cx = min. size of 1 entry in Rs table
	.erre	(SIZE MRS) GT (SIZE PRS); use size of smaller struct to be
					;  conservative (i.e., to allow for
					;  max. possible Rs table entries)
	div	cx			;ax = dx:ax / cx
					;   = max number of Rs entries
	shl	ax,1			;ax = max size of table (in bytes)

	PUSHI	dx,<DATAOFFSET bdAlphaRs>
	push	ax
	PUSHI	ax,IT_NO_OWNERS
	call	BdAlloc
	or	ax,ax
	jne	GotBuf
	jmp	BldExit			;brif out-of-memory

;First, put grs.oMrsMain (if any) in bdAlphaRs
;Next, fill bdAlphaRs with oRs for all pcoded mrs's
;Next, append to bdAlphaRs all oRs's for non-pcoded mrs's (documents/includes)
;
GotBuf:
	push	[grs.GRS_oPrsCur]	;preserve caller's register sets
	push	[grs.GRS_oMrsCur]	; Note it isn't enough to save oRsCur
					; since it may be for a DECLARE,
					; in which case the current module
					; wouldn't be restored.

	sub	si,si			;insertion point = 0

	mov	ax,[grs.GRS_oMrsMain]
	inc	ax
	je	BldNoMain		;brif no main module
	dec	ax
	cCall	MrsActivateCP,<ax>
	sub	di,di			;cMrsTemp = 0
	call	InsertAlpha		;insert oRsCur between si and si+di
	inc	si			;new insertion point = 1
BldNoMain:
	mov	cx,1			;1st, save pcoded mrs's
BldLoop0:
	sub	di,di			;cMrsTemp = 0
	push	cx			;remember if we're saving pcode/no-pcode
	call	MrsDeactivate
BldLoop1:
	call	NextMrsFile_All
	inc	ax
	je	BldDone1		;brif done with mrs's
	dec	ax			;ax = grs.oMrsCur
	cmp	ax,[grs.GRS_oMrsMain]
	je	BldLoop1		;main has already been inserted
	pop	cx
	push	cx
	mov	al,[mrsCur.MRS_flags2]
	and	al,FM2_Include OR FM2_NoPcode
	jcxz	BldNotPcoded		;brif saving non-pcoded mrs's
	je	BldInsert		;brif this is pcoded mrs
	jmp	SHORT BldLoop1
BldNotPcoded:
	je	BldLoop1		;brif this is a pcoded mrs
BldInsert:
	call	InsertAlpha		;insert oRsCur between si and si+di
					; and bump di
	jmp	SHORT BldLoop1

BldDone1:
	add	si,di			;si = number of mrs's inserted so far
					; insert all non-pcoded mrs's after
					; the pcoded mrs's
	pop	cx
	dec	cx
	jcxz	BldLoop0		;brif its time to save non-pcoded mrs's

;si = number of mrs's inserted in table bdAlphaRs
	mov	cx,si			;cx = cMrs
	sub	si,si			;iMrs = 0
BldLoop2:
	push	cx			;save cMrs
	mov	ax,si			;ax = index of oRs
	call	ORsOfAlphaCP		;ax = oMrs = oRs
	cCall	MrsActivateCP,<ax>
	inc	si			;iMrs++

;Now, insert all procedures within current module into bdAlphaRs
; between current module and the next module
;
	sub	di,di			;cPrs = 0
BldLoop3:
	call	NextTextPrsInMrs
	inc	ax
	je	BldDone3
	call	InsertAlpha		;insert oRsCur between si and si+di
					; and bump di
	jmp	SHORT BldLoop3

BldDone3:
	add	si,di			;si = number of oRs's in table so far
	pop	cx			;cx = cMrs
	loop	BldLoop2
	shl	si,1			;si = real # bytes of oRs's in table
	DbAssertRel si,be,[bdAlphaRs.BD_cbLogical],CP,<AlphaBuildORs err1>
	mov	[bdAlphaRs.BD_cbLogical],si

	call	MrsActivateCP		;parm pushed on entry
	call	PrsActivateCP		;parm pushed on entry

BldExists:
	mov	ax,[bdAlphaRs.BD_cbLogical] ;ax = size of table
	shr	ax,1			;convert byte count to word count
BldExit:
cEnd

;**************************************************************************
; ushort AlphaORsFree()
; Purpose:
;	Releases the table built by AlphaBuildORs.  It is called whenever
;	a new register set is inserted, or an existing one is deleted.
;
;**************************************************************************
cProc	AlphaORsFree,<PUBLIC,FAR>
cBegin
	PUSHI	ax,<DATAOFFSET bdAlphaRs>
	call	BdFree
cEnd

;**************************************************************************
; ushort ORsOfAlpha(index)
; Purpose:
;	Given an alphabetical index, map it to an oRs
; Entry:
;	parm1 = index
; Exit:
;	If index is beyond end of table, it returns 7FFFh
;	   (high bit is off so callers that are looking for
;	    the end of a module's prs's need take no special action).
;	else ax = equivalent oRs
;
;**************************************************************************
cProc	ORsOfAlpha,<PUBLIC,FAR>
	parmW	index
cBegin
	mov	ax,[index]
	call	ORsOfAlphaCP
cEnd

;**************************************************************************
; ushort ORsOfAlphaCP(ax=index)
; Purpose:
;	Given an alphabetical index, map it to an oRs
; Entry:
;	ax = index
; Exit:
;	If index is beyond end of table, it returns 7FFFh
;	   (high bit is off so callers that are looking for
;	    the end of a module's prs's need take no special action).
;	else ax = equivalent oRs
;
;**************************************************************************
cProc	ORsOfAlphaCP,<PUBLIC,NEAR>
cBegin
	DbAssertRel [bdAlphaRs.BD_pb],ne,NULL,CP,<ORsOfAlphaCP err1>
	mov	dx,7FFFh		;prepare to return End-Of-Table result
	shl	ax,1			;convert word offset to byte offset
	cmp	ax,[bdAlphaRs.BD_cbLogical]
	jae	ORsExit			;brif beyond end of table
	mov	bx,[bdAlphaRs.BD_pb]	;bx -> base of table
	add	bx,ax
	mov	dx,[bx]			;ax = oRs
	DbChk	oRs,dx			;make sure it is a valid oRs
ORsExit:
	xchg	ax,dx			;return result in dx
cEnd

;**************************************************************************
; ushort AlphaOfORs(oRs)
; Purpose:
;	Given an oRs, map it to an alphabetical index
;
;**************************************************************************
	PUBLIC	AlphaOfORs		
AlphaOfORs:				
cProc	AlphaOfORsFar,<PUBLIC,FAR>
	parmW	oRs
cBegin
	cCall	AlphaOfORsNear,<[oRs]>	
cEnd

cProc	AlphaOfORsNear,<NEAR>,<di>	
	parmW	oRs
cBegin
	DbAssertRel [bdAlphaRs.BD_pb],ne,NULL,CP,<AlphaOfORs err1>
	mov	ax,[oRs]		;ax = word to search for
	DbChk	oRs,ax			
	mov	di,[bdAlphaRs.BD_pb]	;di -> 1st word in table to search
	mov	cx,0FFFFh
	push	cx
	push	ds
	pop	es
	repne scasw			;search for opcode in table pointed
					; to by di (uses es)
	pop	ax
	sub	ax,cx			;ax = index (1..n+1)
	dec	ax			;ax = index (0..n)
cEnd

;**************************************************************************
; NextAlphaPrs
; Purpose:
;	Return the alphabetically next prs within current mrs.
;	Assumes AlphaBuildORs() has been called.
; Entry:
;	grs.oRsCur identifies current register set (can be module's)
; Exit:
;	If not at end of module's procedure list,
;	   next prs is activated, ax and PSW are non-zero
;	else
;	   module's text table is activated (no prs), ax and PSW are zero
;
;**************************************************************************
cProc	NextAlphaPrs,<PUBLIC,FAR>
cBegin
	push	[grs.GRS_oRsCur]
	call	AlphaOfORsNear		; ax = index into list of oRs for module
	inc	ax			;ax = index for next oRs
	cCall	ORsOfAlphaCP		;ax = oRs for this oRs (or 7FFF if
					; end of table)
	push	ax
	call	PrsDeactivate
	pop	ax
	or	ax,ax
	jns	NextDone		;brif done with all prs's in this module
	cCall	RsActivateCP,<ax>
NextDone:
	mov	ax,[grs.GRS_oPrsCur]
	inc	ax			;return 0 if done with list
cEnd

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\prsutil.asm ===
;=============================================================================
; prsutil.asm - Parser's ASM Utility Functions
;
; Copyright <C> 1985, Microsoft Corporation
;
; Purpose:
;	Contains Parser Utility Functions
;
;
;=============================================================================

	include	version.inc
	PRSUTIL_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	parser
	includeOnce	prstab
	includeOnce	prsirw
	includeOnce	psint
	includeOnce	qbimsgs
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	variable
	includeOnce	ui
	includeOnce	util

	assumes	DS,DGROUP
	assumes	SS,DGROUP
	assumes	ES,NOTHING

sBegin	CP
assumes	CS,CP

subttl	pcode emitting functions

;=====================================================================
;    B d   S T A T I C   B U F F E R   R O U T I N E S
;=====================================================================



;=====================================================================
;    P C O D E    G E N E R A T I O N    F U N C T I O N S
;=====================================================================

;*********************************************************************
; BOOL NEAR CheckFreeDstBuf(cbExtra)
; Purpose:
;	Checks to see if free space exists for the parser's
;	pcode buffer ps.bdpDst. If the extra space couldn't be
;	obtained, then a parser OM error is issued.
; Entry:
;	cx = cbExtra
; Exit:
;	ax = 0 if out-of-memory error
;	Flags set on value in ax
;
;*********************************************************************
PUBLIC	CheckFreeDstBuf 		
CheckFreeDstBuf PROC NEAR
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	cx			;cbExtra
	call	BdCheckFree
	or	ax,ax
	je	CheckFreeOMError	;brif out-of-memory
CheckFreeExit:
	ret
CheckFreeDstBuf ENDP

CheckFreeOMError:
	call	ParseErrOm		;Error "Out of memory"
	sub	ax,ax
	jmp	SHORT CheckFreeExit

		
;*********************************************************************
; VOID NEAR Emit16(code16)
; Purpose:
;	Emit 16 bits of pcode to parser's pcode buffer ps.bdpDst
;
;*********************************************************************
cProc	Emit16,<PUBLIC,NEAR,NODATA>
	parmW	code16
cBegin	Emit16
	mov	ax,code16
	call	Emit16_AX
cEnd	Emit16

;**********************************************************************
; VOID NEAR Emit16_0
; Purpose:
;	Emit 16 bits of 0 to parser's pcode buffer ps.bdpDst
;
;**********************************************************************
;**********************************************************************
; VOID NEAR Emit16_AX
; Purpose:
;	Emit 16 bits (in AX) to parser's pcode buffer ps.bdpDst
;
;**********************************************************************
PUBLIC	Emit16_0
PUBLIC	Emit16_AX
Emit16_0 PROC NEAR
	sub	ax,ax			;ax = 0
Emit16_0 ENDP				;fall into Emit16_AX
Emit16_AX PROC NEAR
	DbChkPsStk			;see if this is a new high-water stack
	mov	bx,[ps.PS_bdpDst.BDP_cbLogical]
	inc	bx
	inc	bx
	cmp	bx,[ps.PS_bdpDst.BDP_cbPhysical]
	ja	Emit16Grow		;brif dest buffer needs to grow
Emit16GotRoom:
	mov	[ps.PS_bdpDst.BDP_cbLogical],bx
	mov	bx,[ps.PS_bdpDst.BDP_pbCur]
	mov	[bx],ax			;store pcode in buffer
	inc	bx
	inc	bx
	mov	[ps.PS_bdpDst.BDP_pbCur],bx
Emit16Exit:
	ret
Emit16_AX ENDP
Emit16Grow:
	push	ax			;save pcode to be emitted
	push	bx			;save new value of cbLogical
	mov	cx,2			;need 2 more bytes
	call	CheckFreeDstBuf 	;see if enough free space
	pop	bx			;restore new value of cbLogical
	pop	ax			;restore pcode to be emitted
	jne	Emit16GotRoom		;brif buffer grown successfully
	jmp	SHORT Emit16Exit

PUBLIC	Emit32
cProc	Emit32,<PUBLIC,NEAR,NODATA>
	parmW	code32HIGH
	parmW	code32LOW
cBegin	Emit32
	mov	ax,code32LOW
	call	Emit16_AX		;Emit least significant word first
	mov	ax,code32HIGH
	call	Emit16_AX		;Emit most significant word second
cEnd	Emit32

;*********************************************************************
; VOID NEAR EmitSrc(oSrcText, cbText)
;
; Purpose:
;	Copy bytes from source buffer ps.bdpSrc to pcode buffer ps.bdpDst.
;
; Entry:
;	oSrcText is an offset into the source buffer for 1st byte to copy
;	cbText = number of bytes to be copied
;
; Exit:
;	<text> is copied from the source buffer to the destination pcode buffer.
;	If cbText is odd, an extra filler byte is appended to <text> to keep
;	pcode buffer even-byte aligned.
;	If out-of-memory error, ps.errCode = ER_OM
;
;*********************************************************************
cProc	EmitSrc,<PUBLIC,NEAR,NODATA>,<si,di>
	parmW	oSrcText
	parmW	cbText
cBegin	EmitSrc
	mov	di,cbText		;round cbText (si) up to even value
	inc	di
	and	di,0FFFEH
	mov	cx,di
	call	CheckFreeDstBuf 	;make sure enough free space exits
					;in pcode buffer
	je	EmitSrcExit		;brif out-of-memory

;	set si -> where to copy chars from in bdpSrc
	mov	si,[ps.PS_bdpSrc.BDP_pb]
	add	si,[oSrcText]		


;	push arguments for call
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	si
	push	di
	;BdAppend((bd *)(&ps.bdpDst), ps.bdpSrc.pb + oSrcText, cbText)
	call	BdAppend
	DbAssertRel  ax,nz,0,CP,<EmitSrc: BdAppend returned Out of Memory>

	add	[ps.PS_bdpDst.BDP_pbCur],di  
EmitSrcExit:				
cEnd	EmitSrc

;*********************************************************************
; VOID NEAR EmitSrcCompress(oSrcText, cbText, oDstCbRem)
;
; Purpose:
;	Copy bytes from source buffer ps.bdpSrc to pcode buffer ps.bdpDst.
;	Runs of characters longer than 3 bytes will be compressed and
;	encoded as follows:
;	   Byte 1 - PS_EncodedText
;	   Byte 2 - repeat count for char
;	   Byte 3 - char
;	Chars with ASCII values equal to PS_EncodedText are represented
;	as an encoded char with byte count >= 1.
;
; Entry:
;	oSrcText is an offset into the source buffer for 1st byte to copy
;	cbText = number of bytes to be copied
;	oDstCbRem = offset to emitted cb for this REM
;
; Exit:
;	Encoded <text> is copied from the source buffer to the
;	  destination pcode buffer.
;	If cbText is odd, an extra filler byte is appended to <text> to keep
;	  pcode buffer even-byte aligned.
;	If out-of-memory error, ps.errCode = ER_OM
;
;*********************************************************************
cProc	EmitSrcCompress,<PUBLIC,NEAR>,<si,di>
	parmW	oSrcText
	parmW	cbText
	parmW	oDstCbRem
	localW	cbLeft
	localW	cbCompressed
	localW	cbRep
	localB	chPrev
cBegin	EmitSrcCompress
	push	[ps.PS_bdpDst.BDP_cbLogical] ;save current size of dest

	sub	ax,ax
	mov	[cbCompressed],ax
	mov	[chPrev],al
	inc	ax
	mov	[cbRep],ax
	mov	cx,[cbText]		;round cbText (si) up to even value
	mov	[cbLeft],cx
	inc	cx
	and	cl,0FEH
	jcxz	J1_CompressSkip 	;brif no text
	call	CheckFreeDstBuf 	;make sure pcode buffer has enough room
	jne	CompressTxt		;brif enough room
J1_CompressSkip:
DJMP	jmp	SHORT CompressSkip	;space, brif out-of-memory

CompressTxt:
	push	ds
	pop	es			;es=ds
	mov	si,[oSrcText]
	add	si,[ps.PS_bdpSrc.BDP_pb]
	mov	di,[ps.PS_bdpDst.BDP_pbCur]

;	si = pSrcBuffer 	di = pDstBuffer
;	[cbLeft] = count of bytes remaining to process in src buffer
;	[cbCompressed] = count of bytes compressed from src buffer
;	[chPrev] = last character processed
;	[cbRep] = count of repeated [chPrev] chars processed so far

CompressLoop:
	lodsb				;al = next char
	cmp	al,[chPrev]		;same as last char?
	je	SameChar		;brif so

StartNewRun:				
; Current char does not match last char.  If repeat count for last
; char is > 3 then compress repeated chars out of emitted text.
	call	CompressText		;try to compress txt of last char string
	stosb				;emit current char
	cmp	al,STR_EncodedText	;does this happen to match the
					;special Encode char?
	je	GotSpecialChar		;brif so, do special processing

NoCompress:
	mov	[cbRep],1
	jmp	short CompressNext

; We have a run of identical chars.  If char is "special char" then
; just increment emitted count of special chars.  Else increment
; count of chars seen, and emit the char

SameChar:
	cmp	al,STR_EncodedText	;is this the "special char"?
djmp	je	RunOfSpecialChars	;brif so, bump count in emit buf
	cmp	[cbRep],0FFh		; enough room for this one?
	je	StartNewRun		; brif not -- start a new run
	stosb				;emit char
	inc	[cbRep]
DbAssertRel [cbRep],be,0FFH,CP,<EmitSrcCompress: err1>

CompressNext:
	mov	[chPrev],al		;save new "Last char seen"
	dec	[cbLeft]		;dec remaining char count
	jne	CompressLoop		;brif more to process

CompressDone:
	call	CompressText		;try to compress txt of last char string
	mov	di,[oDstCbRem]		;get offset to emitted cbRem
	add	di,[ps.PS_bdpDst.BDP_pb] ;convert to ptr
	mov	ax,[cbCompressed]
	sub	[di],ax 		;adjust emitted cb for compression
	neg	ax
	add	ax,[cbText]		;adjust and pad size of original
	inc	ax			; for compression
	and	al,0FEH
	add	[ps.PS_bdpDst.BDP_pbCur],ax ;adjust for added text
	pop	[ps.PS_bdpDst.BDP_cbLogical] ;recover entry size
	add	[ps.PS_bdpDst.BDP_cbLogical],ax ;adjust by inserted size
CompressExit:
cEnd	EmitSrcCompress

CompressSkip:
	pop	ax			;clean stack
	jmp	SHORT CompressExit	;and exit quick

;=====================================================================
; We have encountered a char which matches our special flag byte.
; We will emit it as a compressed char record. Note: we have already
; emitted the char by this point.
;=====================================================================

GotSpecialChar:
	add	[cbCompressed],2	;compression record costs us 2 bytes
	js	GotSpecGrow		;brif we need to grow dest buffer

GotSpecCont:
	mov	ah,al			;mov char into high byte
	mov	al,1			;set initial count of chars
	stosw				;emit count and char
	mov	al,ah			;recover char
	jmp	SHORT CompressNext	;process next char

GotSpecGrow:
; We actually need to grow the destination buffer because we have inserted
; enough "special chars" to override the compression savings.
	sub	si,[ps.PS_bdpSrc.BDP_pb] ;conv ptr to offset in case of movement
	sub	di,[ps.PS_bdpDst.BDP_pb] ;conv ptr to offset in case of movement
	mov	cx,2			;size of compression record is 2 bytes
	call	CheckFreeDstBuf 	;ensure enough room in pcode buffer
	je	CompressSkip		;brif out-of-memory
	add	si,[ps.PS_bdpSrc.BDP_pb] ;conv offset back to ptr
	add	di,[ps.PS_bdpDst.BDP_pb] ;conv offset back to ptr
	mov	al,STR_EncodedText	;get back char
	jmp	short GotSpecCont

;=====================================================================
; We are processing a run of special chars. The first one caused us
; to emit an encoded record for the char, so just bump the count
; of these chars.
;=====================================================================

RunOfSpecialChars:
DbAssertRelB [di-3],e,STR_EncodedText,CP,<EmitSrcCompress: err2>
DbAssertRelB [di-1],e,STR_EncodedText,CP,<EmitSrcCompress: err3>

	inc	byte ptr [di-2] 	;bump count of special chars
	jz	OverFlow		; brif too many
	inc	[cbCompressed]		;compressed 1 more char
	jmp	CompressNext

OverFlow:				
	dec	byte ptr [di-2] 	; restore count of special chars
	jmp	StartNewRun		; start another run


;*********************************************************************
; CompressText
;
; Purpose:
;	Compress text in buffer DI if possible.
;	Note: this routine should only be called from EmitSrcCompress,
;	as it utilizes frame variables defined by EmitSrcCompress.
;
; Entry:
;	[cbRep] = repeat count for last char in buffer.
;	[cbCompressed] = current count of compressed chars in buffer.
;
; Exit:
;	[cbCompressed] updated if text was compressed
;	DI updated for compression
; Preserves:
;	AX
;*********************************************************************
CompressText:
	push	ax			;save chCur
	mov	ax,[cbRep]		;get repetition factor for chLast

	cmp	al,3			;Don't compress if repeat count < 3
	jbe	CompressTextExit
	sub	di,ax			;back up pDst to first repeated char
	add	[cbCompressed],ax	;bump count of compressed bytes
	sub	[cbCompressed],3	; - compression overhead (2)
					; - 1 (make cbRep 0 relative)
	mov	ah,al			;high byte has count
	mov	al,STR_EncodedText	;low byte has encoded flag
	stosw				;emit encoded flag/cb encoded
	inc	di			;skip char
	mov	byte ptr[di],0		;zero potential extra byte

CompressTextExit:
	pop	ax			;recover chCur
	ret


;*********************************************************************
; boolean ListStdMsgToBd(iMsg, pbdDst)
;
; Purpose:
;	List a standard ASCII message to the end of a buffer.
;
; Entry:
;	iMsg is standard error index from qbimsgs.h
;	pbdDst points to buffer descriptor where message is to be listed
;
; Exit:
;	If out-of-memory error, returns FALSE
;	else returns TRUE
;
;*********************************************************************
cProc	ListStdMsgToBd,<PUBLIC,FAR,NODATA>
	parmW	iMsg
	parmW	pbdDst			
cBegin	ListStdMsgToBd
	push	[iMsg]
	call	ListStdMsgFar		;copy text of msg to bufStdMsg
					; ax = # bytes in message
	;return(BdAppend(pbdDst, pMsgText, cbText))
	push	[pbdDst]			;pass ptr to destination buffer
	PUSHI	bx,<dataOFFSET bufStdMsg>
					;pass ptr to 1st byte of text
	push	ax			;push byte count
	call	BdAppend		;ax = FALSE if out-of-memory
ListMsgExit:
cEnd	ListStdMsgToBd


;*************************************************************************
; ListIRW 
; Purpose:
;	Map a reserved word from index (0..n) to ASCII.
;	Used by user-interface's context sensitive help.
; Entry:
;	parm1: reserved word index (0,1,2,...n)
; Exit:
;	returns byte count (0 if index is too large).
;	zero terminated string for reserved word is copied to bufStdMsg
;
;*************************************************************************
cProc	ListIRW,<PUBLIC,FAR>,<si,di>
	parmW	iRw
	localW	pbDst			
	localW	iRwCur
	localB	letterCur
cBegin
	mov	ax,IRW_ALPHA_FIRST
	mov	[iRwCur],ax		;initialize cur res word counter/index
	mov	bx,[iRw]		;bx=reserved word of interest
	cmp	bx,ax
	jae	NotSpecChar		;brif iRw represents a word from
					; res word table, and not a special
					; char like +, *,$ etc.
	mov	al,BYTE PTR cs:mpIRWtoChar[bx]
	mov	[letterCur],al
	sub	cx,cx			;cbNam = 0
	jmp	SHORT SrchEnd

NotSpecChar:
	mov	[letterCur],'A'
	mov	ax,cs:[tRw]		;ax points to A's res word tbl
	inc	ax			;skip IRW for 1st entry in table
	inc	ax
	xchg	si,ax			;si points into A's res word tbl
	push	cs
	pop	es			;es = CP segment (for GetRwFromTab)

;Register usage:
;	si->current res word, cx = cbNam, dx=cbAtr
;	es = segment adr of reserved word table (CP)
;
SrchLoop:
	cmp	BYTE PTR cs:[si],0
	jne	NotEndOfTbl		;brif not at end of current table

	;we just moved into next letter's reserved word table
	inc	[letterCur]
	sub	dx,dx			;prepare to return 0
	cmp	[letterCur],'Z'
	ja	ListEnd 		;brif IRW not found (return 0)
	add	si,3			;skip 0-byte terminator and
	jmp	SHORT SrchLoop		; iRw for 1st entry in next table

NotEndOfTbl:
EXTRN	GetRwFromTabCP:near
	call	GetRwFromTabCP		;cx = size of res word's name
					;dx = size of res word's atr block
					;si points to 1st byte of res word name
	mov	ax,[iRwCur]		;ax = current reserved word's index
	inc	[iRwCur]
	cmp	ax,[iRw]
	je	SrchEnd			;brif current res word is one
					; we've been looking for
	add	si,cx			;skip cbNam bytes
	add	si,dx			;skip cbAtr bytes
	jmp	SHORT SrchLoop

;[letterCur] = 1st letter of reserved word
;cx = # bytes in reserved word, excluding first char
;
SrchEnd:
	mov	dx,cx
	inc	dx			;dx = real number of bytes in res word
	push	ds
	pop	es			;es=ds for block transfer
	mov	di,DATAOFFSET bufStdMsg
	mov	al,[letterCur]
	stosb				;store 1st char in buffer
	jcxz	ListExit		;branch if 1 letter res word (like +)
OutLoop:
	lods	BYTE PTR cs:[si]	;al = next letter of res word
	stosb				;store it in buffer
	loop	OutLoop			;until cx=0
	lods	BYTE PTR cs:[si]	;al = flags byte
	test	al,RWF_STR
	je	ListExit		;brif doesn't end with '$'
	mov	al,'$'
	stosb				;store it in buffer
	inc	dx			;dx = real number of bytes in res word
ListExit:
	xchg	ax,cx			;ax = 0
	stosb				;store 0-terminator
ListEnd:
	xchg	ax,dx			;return result in ax
cEnd


subttl	Error reporting functions

;=======================================================================
;	  E R R O R    R E P O R T I N G    F U N C T I O N S
;
; Example:
;	Assume the statement we are parsing is defined by the parse tree:
;
;	            A
;	           / \
;	          B   C
;	           \   \
;	            +---+
;	                 \
;	                 <accept>
;
; and assume A is a non-terminal which is described by the parse tree:
;
;	            X
;	           / \
;	          /   Z
;	          \    \
;	           +----+
;	                 \
;	                 <accept>
;
; If Parse(A) fails to match A or B, we want to produce the error message
; "Expected X or B" (since A is really known to the user as X).
;	The way this is accomplished is as follows:
;	- Every NonTerminal parsing function (like Parse() and Ntxxx())
;	  returns 1 of 3 values:
;	  PR_GoodSyntax if tokens were recognized & pcode emitted
;	  PR_NotFound if tokens were not recognized, and no tokens were consumed
;	  PR_BadSyntax if some tokens got consumed before we detect a syntax
;	   error.  In this case, the NonTerminal parsing function is responsible
;	   for generating a complete error message by calling one or more of
;	   the functions: PErrState(), PErrExpectedOr(), PErrMsg(),
;	     PErrExpMsg(), PErrExpRw().
;
;  Control Flow:
;
;	      PErrState
;                 |
;           +-----+----+
;           |          |
;       PErrExpMsg PErrExpRw
;           |
;       PErrMsg_AX ParseErrOm ParseErr0 PErrVarMgr ParseErrTokScan
;           |           |        |          |           |
;           +-----------+--------+----------+-----------+
;                       |
;	           ParseErr
;
;=====================================================================

;*********************************************************************
; void NEAR ParseErr(ax:errCode, bx:pTokErr)
; Purpose:
;	Record the fact that a parser error has occurred.
; Entry:
;	ax = errCode is a standard error code from qbimsgs.h or
;	     PSERR_fAsciiMsg with 0 or more of: PSERR_fAlert, PSERR_fRude
;	bx = pointer to token where error occurred (used for column
;	     error reporting).
;	     bx = 0 if caller doesn't know what token caused the error.
; Exit:
;	psFlags bit PSIF_fBindVars is reset so we don't continue binding
;	   variables in a statement which is already known to be bad
;
;********************************************************************/

PUBLIC	ParseErrOm
ParseErrOm PROC NEAR
	mov	ax,ER_OM OR PSERR_fAlert
ParseErrOm ENDP
	;fall into ParseErr0
PUBLIC	ParseErr0
ParseErr0 PROC NEAR
	sub	bx,bx			;token/source-column = unknown
ParseErr0 ENDP
	;fall into ParseErr
PUBLIC	ParseErr
ParseErr PROC NEAR
	mov	dx,ax
	and	dx,PSERR_errcode
	cmp	dx,ER_CN
	jne	NotCantCont

	;variable mgr and context mgr return ER_CN if asked to grow a
	;variable table when CONT is possible.  Since variable tables
	;can't move during program execution, either AskCantCont will
	;disable CONT, or the edit must be backed out of.
	
	DbAssertRelB [txdCur.TXD_scanState],ne,SS_RUDE,CP,<ParseErr: err1>
	;If this assertion failed, we could be in an infinite loop of retries.

	call	AskCantCont_CP		;ask user "Want to back out?"
	mov	al,PSF_UndoEdit
	je	BackOut			;brif user wants to back out
	mov	al,PSF_fRetry		;tell caller to call ParseLine again
BackOut:
	or	[ps.PS_flags],al
	mov	al,ER_IER		;this error should never get to user
;ax = errCode
NotCantCont:
	mov	[ps.PS_errCode],ax
	or	bx,bx
	je	PerrNoOSrc		;brif we don't know column of error
	mov	bx,[bx.TOK_oSrc]	;bx = token's source line offset
PerrNoOSrc:
	mov	[ps.PS_oSrcErr],bx
	and	[psFlags],NOT PSIF_fBindVars
	ret
ParseErr ENDP

;*********************************************************************
; void NEAR ParseErrTokScan(ax:errCode)
; Purpose:
;	Same as ParseErr.  This should be called if the caller wants
;	to flag an error, but continue checking for bad syntax.
;	If a syntax error is found later in the line, it will
;	over-write this error message.  Call PErrMsg_AX if
;	syntax analysis of the line is to stop.
; Entry:
;	ax = errCode is a standard error code from qbimsgs.h or
;	     PSERR_fAsciiMsg with 0 or more of: PSERR_fAlert, PSERR_fRude
;	[pTokScan] = pointer to token where error occurred (used for column
;	     error reporting).
; Exit:
;	Same as ParseErr
;
;********************************************************************/
PUBLIC	ParseErrTokScan
ParseErrTokScan PROC NEAR
	mov	bx,[pTokScan]
	jmp	SHORT ParseErr
ParseErrTokScan ENDP

;*********************************************************************
; void NEAR PErrVarMgr(ax:errCode, bx:pTokErr)
; Purpose:
;	Handle error code returned by MakeVariable
;	Note that this can be an error returned by ScanAndExec as well.
;	If PRS_ER_RE bit is set (Rude edit error)
;	   set PSERR_fRude bit in ParseLine's return value
;	Else If PRS_ER_RP bit is NOT set (passive reparse error)
;	   set PSERR_fAlert bit in ParseLine's return value
;	Else
;	   caller of ParseLine may defer reporting the error until
;	   the user tries to run the program.
; Entry:
;	ax = errCode is an error code as returned by MakeVariable
;	bx = (used for column
;	     error reporting).
;	     bx = 0 if caller doesn't know what token caused the error.
; Exit:
;	psFlags bit PSIF_fBindVars is reset so we don't continue
;	   binding variables in a statement which is bad
;	We will continue to check rest of statement for syntax errors,
;	   since these are stronger (more useful to user) than
;	   variable manager errors.  If any syntax errors are found,
;	   any information recorded in ps.err... by this function
;	   will be overwritten.
;
;********************************************************************/
PUBLIC	PErrVarMgr
PErrVarMgr PROC NEAR
	test	ah,(PRS_ER_RP / 100h) AND 7Fh
	jne	ReparseErr		;brif Reparse Error
	test	ah,(PRS_ER_RE / 100h) AND 7Fh
	.errnz	PSERR_fRude AND 0FFH
	mov	ah,PSERR_fRude / 100h	;set rude edit flag in result
	jne	BindRude		;brif a rude edit
	.errnz	PSERR_fAlert AND 0FFH
	mov	ah,PSERR_fAlert / 100h	;set ALERT flag in result
					;this error is reported at entry
					;time, rather than waiting until
					;the pre-run reparse loop
	SKIP2_PSW			;skip following mov ah,0 instruction
ReparseErr:
	mov	ah,0			;DON'T alter condition codes
BindRude:
	jmp	SHORT ParseErr		;ParseErr(ax,bx)
					; result doesn't matter because of error
PErrVarMgr ENDP

;error "id can't end with % & ! # or $", al=PR_BadSyntax on exit
;
PUBLIC	PErrExpIdImp
PErrExpIdImp PROC NEAR
	mov	ax,MSG_IdImp		;"id can't end with % & ! # or $"
PErrExpIdImp ENDP
;fall into PErrMsg_AX
;*********************************************************************
; VOID NEAR PErrMsg_AX, PErrPrevTok_AX, PErrMsg_AX_BX
;
; Purpose:
;	Append the standard message identified by iMsgErr to current error line.
;
; Entry:
;	ax = error code (from qbimsgs.inc)
;	pTokScan->oSrc is used for column offset by PErrMsg_AX
;	OR
;	bx->oSrc is used for column offset by PErrMsg_AX_BX [09]
;
; Exit:
;	al = PR_BadSyntax, condition codes set based on al
;
;*********************************************************************
;PErrPrevTok_Ax uses the column offset of the last token consumed 
;for reporting the error
PUBLIC	PErrPrevTok_AX			
PErrPrevTok_AX PROC NEAR		
	mov	bx,[pTokLastConsumed]	;bx -> last consumed token
	; fall into PErrMsg_AX_BX	
	jmp	SHORT PErrMsg_Ax_Bx	
PErrPrevTok_AX ENDP			

PUBLIC	PErrMsg_AX
PErrMsg_AX PROC NEAR
	mov	bx,[pTokScan]
	; fall into PErrMsg_AX_BX	
PErrMsg_AX ENDP				

cProc	PErrMsg_AX_BX,<PUBLIC,NEAR>	
cBegin	PErrMsg_AX_BX			
	test	BYTE PTR([ps.PS_errCode+1]),PSERR_fAsciiMsg / 100h
	jne	GotEos1			;brif not 1st msg for this line
	test	BYTE PTR([ps.PS_errCode+1]),PSERR_fAlert / 100h
	jne	NoOmErr			;brif already got an error not
					; consisting of pasting together
					; messages into ps.bdErr (like
					; Id too long, or Out of memory)
					;This still overrides errors like ER_DD
					; so syntax errors get reported before
					; variable mgr re-parse type errors
					; (because a syntax error is more
					;  valuable to the user).

	push	ax			;save msg id
	mov	[ps.PS_bdErr.BD_cbLogical],0 ;reset bdErr buffer

	mov	ax,PSERR_fAsciiMsg + PSERR_fAlert
					;tells ParseLine's caller that err msg
					; is in ps.bdErr
	call	ParseErr		;set ps.errCode, ps.oSrcErr
GetEos:
	call	NtEndStatement
	jne	GotEos			;brif current token is end-of-stmt
	call	ScanTok
	jmp	SHORT GetEos

GotEos:
	pop	ax			;restore ax = msg id
GotEos1:
	push	ax			;pass msgId to ListStdMsgToBd
	PUSHI	ax,<dataOFFSET ps.PS_bdErr>
	call	ListStdMsgToBd		;append std msg to error buffer
	or	ax,ax
	jne	NoOmErr			;brif not out-of-memory
	call	ParseErrOm		;Error "Out of memory"
NoOmErr:
	mov	al,PR_BadSyntax
	or	al,al			;set condition codes for caller
cEnd	PErrMsg_AX_BX

;*********************************************************************
; VOID NEAR PErrExpectedOr()
;
; Purpose:
;	If this is the 1st clause of this err msg, output 'Expected: '
;	Otherwise output ' or '.
;
; Exit:
;	al = PR_BadSyntax, condition codes set based on al
;
;*********************************************************************
PErrExpectedOr PROC NEAR
	mov	ax,MSG_or
	test	BYTE PTR([ps.PS_errCode+1]),PSERR_fAsciiMsg / 100h
	jne	OrNot1stMsg		;brif not 1st msg for this line
	mov	ax,MSG_expected
OrNot1stMsg:
	jmp	SHORT PErrMsg_AX	;emit msg, al = PR_BadSyntax
					; return to caller
PErrExpectedOr	ENDP

;*********************************************************************
; VOID NEAR PErrExpRw_AX
;
; Purpose:
;	Produce the error message:  "Expected <reserved word>"
;
; Entry:
;	ax = IRW for expected reserved word (from prsirw.inc)
; Exit:
;	al = PR_BadSyntax
; 
;*********************************************************************
cProc	PErrExpRw_AX,<PUBLIC,NEAR,NODATA>,<si>
cBegin
	xchg	si,ax			;si = IRW for expected reserved word
	DbAssertRel si,be,NTOKENS,CP,<Illegal token in PErrExpRw>
	;list ASCII this opcode maps to
	call	PErrExpectedOr		;output "Expected" or "or"
	cmp	si,IRW_NewLine
	jne	NotNewLine
	mov	ax,MSG_eos
	call	PErrMsg_AX		;output "end of statement"
	jmp	SHORT PErrExpRwExit

NotNewLine:
	push	si
	call	ListIRW			;output reserved word's name to
					; bufStdMsg, ax = byte count
	DbAssertRel ax,ne,0,CP,<ListIRW called with bad IRW>

	PUSHI	bx,<dataOFFSET ps.PS_bdErr>	;pass ptr to destination buffer
	PUSHI	bx,<dataOFFSET bufStdMsg>
					;pass ptr to 1st byte of text
	push	ax			;push byte count
	call	BdAppend		
PErrExpRwExit:
	mov	al,PR_BadSyntax		;return PR_BadSyntax
cEnd

;error "Expected id", al=PR_BadSyntax on exit
;
PUBLIC	PErrExpId
PErrExpId PROC NEAR
	mov	ax,MSG_ExpId
;;	jmp	SHORT PErrExpMsg_AX
PErrExpId ENDP
;fall into PErrExpMsg_AX
;*********************************************************************
; VOID NEAR PErrExpMsg_AX
;
; Purpose:
;	Produce the error message:  "Expected <Standard BASIC Message>"
;
; Entry:
;	ax = error code (from qbimsgs.inc)
;
; Exit:
;	al = PR_BadSyntax, condition codes set based on al
;
;*********************************************************************
PUBLIC	PErrExpMsg_AX
PErrExpMsg_AX PROC NEAR
	push	ax			;save msgId
	call	PErrExpectedOr
	pop	ax			;restore ax = msgId
	jmp	PErrMsg_AX		;al = PR_BadSyntax
					;return to caller
PErrExpMsg_AX ENDP

if ND_ACCEPT - 0
	Error: PErrState assumes ND_ACCEPT = 0
endif
if ND_REJECT - 1
	Error: PErrState assumes ND_REJECT = 1
endif
if ND_MARK - 2
	Error: PErrState assumes ND_MARK = 2
endif
if ND_EMIT - 3
	Error: PErrState assumes ND_EMIT = 3
endif
if ND_BRANCH - 4
	Error: PErrState assumes ND_BRANCH = 4
endif

;*************************************************************************
; VOID NEAR PErrState
;
; Purpose:
;	Append an error message to the error buffer indicating
;	'A or B or C ...  or Z'  was expected.
;
; Entry:
;	ushort pStateLastScan - pointer into tState for expected syntax
;	  when last token was scanned.
;	ushort pStateLastGood - pointer into tState for expected syntax
;	  when last non-terminal was accepted.
;
; Exit:
;	al = PR_BadSyntax
;	  
;*************************************************************************
cProc	PErrState,<PUBLIC,NODATA,NEAR>,<si>
cBegin	PErrState
	test	BYTE PTR([ps.PS_errCode+1]),PSERR_fAlert / 100h
	jne	GotBadSyntax		;brif already got an error not
					; consisting of pasting together
					; messages into ps.bdErr (like
					; Id too long, or Out of memory)
					;This still overrides errors like ER_DD
					; so syntax errors get reported before
					; variable mgr re-parse type errors
					; (because a syntax error is more
					;  valuable to the user).
	mov	ax,[pStateLastScan]
	call	PErrState1		;PErrState(pStateLastScan - tState)
	test	BYTE PTR([ps.PS_errCode+1]),PSERR_fAsciiMsg / 100h
	jne	GotBadSyntax	      ;brif PErrState1 didn't generate anything
	mov	ax,[pStateLastGood]
	call	PErrState1
GotBadSyntax:
	mov	al,PR_BadSyntax
cEnd	PErrState

;Register usage:
;	dx = pStateTrue
;	cx = nodeId
;	si = pState
;
cProc	PErrState1,<NODATA,NEAR>,<si>
cBegin	PErrState1
	xchg	si,ax			;si = pState
	or	si,si
	jne	ErrLoop			;brif not NULL pState
J1_ErrLoopExit:
	jmp	ErrLoopExit		;brif ACCEPT or REJECT node (done)

ErrLoop:
	lods	BYTE PTR cs:[si]	;al = node id
	cmp	al,ND_REJECT
	jbe	J1_ErrLoopExit		;brif ACCEPT or REJECT node

	cmp	al,ND_EMIT
	ja	NotEmitOrMark		;brif not EMIT or MARK node
	lodsb				;bump si without changing status flags
	jne	ErrLoop			;brif MARK node (1 byte operand)
	inc	si			;EMIT has 2 byte operand
	jmp	SHORT ErrLoop

;got a branch, token, or nonterminal - fetch its id
NotEmitOrMark:
	sub	ah,ah			;ax = nodeId
	cmp	al,ENCODE1BYTE
	jb	OneByteNodeId		;brif 1 byte nodeId

	;nodeId = ((nodeId-ENCODE1BYTE) << 8) + (*pState++) + ENCODE1BYTE
	mov	ah,al
	lods	BYTE PTR cs:[si]	;ax = nodeId * 256 + next byte
	sub	ax,255 * ENCODE1BYTE
OneByteNodeId:	
	xchg	cx,ax			;save nodeId in cx
;node is followed by 1 or 2 byte branch operand, fetch it
	lods	BYTE PTR cs:[si]
	sub	ah,ah			;ax = operand
	cmp	al,ENCODE1BYTE
	jb	OneByteOperand		;brif 1 byte operand (< ENCODE1BYTE)
	cmp	al,255
	je	HandleNode		;brif special id->accept node
					; never generated for a BRANCH node,
					; which is the only reason we care
					; about the operand in this function
	;operand is 2 byte offset into tState
	;operand = ((operand-ENCODE1BYTE) << 8) + *pState++
	mov	ah,al
	lods	BYTE PTR cs:[si]	;ax = operand * 256 + next byte
	sub	ax,256 * ENCODE1BYTE
	add	ax,OFFSET CP:tState
	xchg	dx,ax			;pStateTrue = &tState[operand]
	jmp	SHORT HandleNode

OneByteOperand:
	;operand is 1 byte relative branch in state table
	mov	dx,ax			;dx = offset to new state
	add	dx,si			;pStateTrue = pState + operand
	cmp	al,ENCODE1BYTE/2
	jbe	HandleNode		;brif positive relative branch
	sub	dx,ENCODE1BYTE		;negative relative branch
HandleNode:
	xchg	ax,cx			;ax = nodeId
	cmp	ax,ND_BRANCH
	jne	NotBranchNode
	mov	si,dx			;unconditional branch to another state,
					; pState = pStateTrue
	jmp	SHORT ErrLoop		; continue scanning

NotBranchNode:
	sub	ax,ND_BRANCH + 1
	cmp	ax,NUMNTINT
	jae	NotIntNt

	;we expected a non-terminal described by a state tree
	xchg	bx,ax
	shl	bx,1
	mov	ax,cs:tIntNtDisp[bx]
	add	ax,CPOFFSET tState	;ax = pState
	call	PErrState1		;recurse
J1_ErrLoop:
	jmp	SHORT ErrLoop

NotIntNt:
	sub	ax,NUMNTINT
	cmp	ax,NUMNTEXT
	jae	NotExtNt

	;we expected a non-terminal defined by a C function
	xchg	bx,ax
	shl	bx,1
	mov	ax,cs:tExtNtHelp[bx]
					;iMsg = tExtNtHelp[nodeId]
	or	ax,ax
	je	J1_ErrLoop		;brif no error msg for this nonterminal
	call	PErrExpMsg_AX		;emit the message
	jmp	SHORT J1_ErrLoop

NotExtNt:
	;we expected a reserved word:  Error "Expected <reserved word>"
	sub	ax,NUMNTEXT		;ax = nodeId
	call	PErrExpRw_AX		;PErrExpRw(ax:nodeId)
	jmp	SHORT J1_ErrLoop

ErrLoopExit:
cEnd	PErrState1
sEnd	CP




end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssbos.asm ===
page	49,132
	TITLE	ssbos - scan support for begin of statement opcodes
;***
;ssbos - scan support for begin of statement opcodes
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains scan dispatches for label definitions and
;   label reference opcodes.
;
;   Labels refer to line numbers or alpha-numeric labels.  There is
;   no difference notable in the scanner.
;
;   The scanner is responsible for the following tasks:
;
;	1. Reference scope.  For each label reference opcode thereis only one
;	   scope in which the label may be legally defined.  Scope checking is
;	   simply a matter of searching the reference chain in the appropriate
;	   link list.
;	   NOTE: The main level code must be scanned first.  This allows
;	   immediate binding without fixups whenever a procedure references
;	   a label at the main level.  The main level may never reference a
;	   procedure label.
;
;	2. Binding.  Label references are bound to the text table
;	   in SS_EXECUTE state only.  In other states, they are bound to the
;	   name table.
;	   Binding involves replacing the oName in the label reference with
;	   the oTx for the label.  References to the main level from within
;	   a procedure are never ambiguous, so no oPrs or other flag is needed.
;
;	   Backward references are bound simply by searching
;	   the label chain.
;
;	   Forward references are handled by linking the
;	   reference into the label chain at the definition point.  The
;	   backward pointer is identifiable when scanning the label definition
;	   opcodes, and the reference is bound when the definition is bound.
;
;	3. Debinding.  Debinding label references is done in a separate pass
;	   on the text at descan time.
;
;	4. Duplicate label detection. Duplicate labels are detected by the
;	   text manager.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSBOS_ASM = ON
	IncludeOnce	context
	IncludeOnce	optables
	IncludeOnce	opcontrl
	IncludeOnce	opstmt
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	scanner
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	ui
	IncludeOnce	variable
	.list

assumes es,nothing
assumes ds,DATA
assumes ss,DATA
assumes cs, SCAN

sBegin	DATA
	externW	pSsCOMcur		;defined in SsDeclar.asm
	oRsExpected DW	?		;expected oRs when binding labels
	fRestoreLab DB	0		;non-zero if binding RESTORE
sEnd	DATA

extrn	exNoList1:near
extrn	exStRestore1:near

extrn	exStDefFn:near


sBegin	SCAN

DWBOL	MACRO	cSpace
	DWEXT	exBol&cSpace
	endm

CBOL_EXECS EQU 25  ;number of opBol executors (for indentation 0..24)
mpBol	label	word
cSpace	=	0
	REPT	CBOL_EXECS
	DWBOL	%cSpace
cSpace	=	cSpace+1
	endm


;***
;Ss_BolLabDef,Ss_LabDef - scan Bos opcode varients
;Purpose:
;	Scan general begin of statement opcodes.
;	This task is simply opcodes to executors and copying any operands.
;
;	Update the begin of statement pointer, and reset scanner flags.
;
;	Update the pointer to the pcode following begin of statement.
;	This pointer is used to isolate DIMs for $STATIC arrays.  See the
;	comments in exarray.asm.
;
;	Scan label definition varients.
;
;	Label definition tasks include:
;	1. If link points to code on emit side then the link is to a label
;	   reference that has not yet been bound (forward reference problem).
;		bind ref at link side
;		pick up ref in link side item
;		goto 1 (there may be more than one forward ref to this label)
;	2. maintain the link list.
;
;	A link points to an opcode that has an operand which is a scanned
;	reference if the low bit is set.
;
;	Label links point to the opcode that has a link field of the next
;	label, or are UNDEFINED.  Label offsets to the unscanned source are
;	not relocated when text expands.
;
;	The label list control structure is in struc TXLNK at [SsLinkCtl].
;	It contains fields as follows:
;	TXLNK_LabDefNext - offset of next label definition
;			   (unrelocated for expansion)
;	TXLNK_LabDefLast - offset of last bound label definition
;
;Input:
;	ax	= opcode
;	bx	= opcode * 2
;	es:si	= source code address of operands (if any)
;	es:di	= destination code address.
;Output:
;	si/di	updated
;Modifies:
;	ax,bx,cx,dx modifies
;***********************************************************************
SsProc	LabDef
	mov	dx,di			;Preserve the emit address
	call	EmitExCopyOps		;Emit executor and operand(s)
	jmp	short LabDef		;Now handle the label definition

SsProc	BolLabDef,rude
	mov	dx,di			;Preserve the emit address
	call	Bos0_0Com		;Process standard BOS issues
LabDef:
	xchg	dx,di			;Preserve next emit address
					; and move to link field on emit side
	mov	cx,di			;Save oTx for forward reference linking
	inc	di			;Move to link field on emit side
	inc	di
	mov	bx,di
	mov	ax,PTRTX[bx]		;Load link operand of current label

;Reenter here if we fixed up some previous forward ref.
BosForwardRefChk:
	cmp	ax,UNDEFINED		;Test for end of link list
	jz	NotForwardRefFixup	;End of list - can't be a fixup
	test	ax,1			;Is a link to a forward reference?
	jz	NotForwardRefFixup	;This is not a previous forward ref.

;Fix up the previous forward ref
	dec	ax			;Remove link flag
	mov	bx,ax
	mov	ax,PTRTX[bx]		;Load link from referenced location
	mov	PTRTX[bx],cx		;Bind to beginning of BOL varient
	jmp	short BosForwardRefChk	;Check if this is another old forward

NotForwardRefFixup:
	mov	bx,[SsLinkCtl]		;Address of TXLNK control struc
	mov	[bx].TXLNK_LabDefNext,ax;oTx for next label before any
					; expansion is accounted for.
	mov	cx,di
	xchg	cx,[bx].TXLNK_LabDefLast;Address of last label link
	mov	bx,cx
	jcxz	BolFirst		;This is the first defined label.
					; as oTxLastLabDef starts at 0
	mov	PTRTX[bx],di		;Link last label to this one
BolFirstLabDefCont:			;Continue here after handling first
					; label definition
	or	al,1			;set low bit on emitted side to
					;specify end of Bound label chain
	mov	PTRTX[di],ax		;Emit link to next label def
	dec	di			;Back to BOL executor address
	dec	di
	jmp	short BolCom		;Handle general BOL considerations


;Here if this is the first label definition encountered.
BolFirst:
	mov	txdCur.TXD_otxLabLink,di;Update text descriptor to point to
					; the first label in the link chain
	jmp	short BolFirstLabDefCont;Continue label definition handling


;***
;Ss_Bos,Ss_Bol,SsEot,Ss_0_0 - Scan opcodes with no args, emit nothing, executor in mpOpExe
;Purpose:
;	Scan opcodes which:
;	1. have no arguments (consume nothing)
;	2. emit no value
;	3. have no special operand processing.
;	   (operand count is in mpOpAtr)
;	4. executor is in mpOpExe
;
;	For example, this includes:
;	opBos, opBol, opBolSp, opBolCont, opWatch, opInclude
;
;Input:
;	ax	= opcode
;	bx	= opcode * 2
;	es:si	= source code address of operands (if any)
;	es:di	= destination code address.
;Output:
;	si/di	updated
;Modifies:
;	ax,bx,cx,dx modified
;***********************************************************************
SsProc	Bos,rude
	push	[ScanRet]		;Set return address
	DJMP	jmp SHORT Bos0_0Com	;Continue through shared BOS code

SsProc	Eot,rude
	test	[SsFlags],SSF_ScanAndExec
	jnz	ScanExExitJ
	mov	[ScanRet],scanOFFSET ScanExit	;Terminate scan dispatching
	jmp	short SsBol			; after performing BOL work

ScanExExitJ:
	jmp	SsScanExExit

SsProc	BolEmit,rude
	jmp	short SsBol

SsProc	Bol,rude
	mov	al,es:[si-1]		;Get high byte of opcode
	and	ax,HIGH (not OPCODE_MASK) ;Get count of spaces * 2
	xchg	ax,bx			;Preserve opcode*2 in bx
.errnz	OPCODE_MASK - 3FFH
	shr	bx,1			;cSpace is shifted left one bit
DbAssertRel	bx,be,2*CBOL_EXECS,SCAN,<Ss_Bol: cSpace too large>
	mov	bx,[bx].mpBol		;Get appropriate executor
	xchg	ax,bx
SsBol:
	mov	dx,di			;Preserve BOL executor address
	call	Bos0_0Com		;Handle end of statement
	xchg	dx,di			;Back to BOL executor, preserving next emit addr
BolCom:
	mov	ax,[SsLineCount]
	inc	ax
	mov	[SsLineCount],ax
	test	al,LineUpdate-1	;Time to update line count on screen?
	jnz	NoLineUpdate
	push	dx
	cCall	UpdStatusLn,<ax>
	GETSEGTXTCUR		
	pop	dx
NoLineUpdate:
	test	SsFlags,SSF_If	;Is there special per line work?
	jnz	BolControlBind	
BolComX:
	mov	di,dx		;Back to next emit address
	jmp	[ScanRet]

;BolControlBind
;Purpose:
;	Bind control structure frames found on the stack.
;
;	This routine binds all non-block, non-label IF and ELSE entries
;	to this BOL.
;
;	Label varients of IF are discarded.  They were on the stack in order
;	to allow the scanner to correctly check IF/ELSE scoping.
;
;	The label and nop varients of ELSE cause no stack entry.
;
;	Block varients of ELSE and IF are popped by the matching block type
;	opcodes only.

BolDoBind:
	pop	bx		;Get IF operand address from frame
	mov	[SsBosStack],sp ; SP at BOS
	pop	cx		;throw away block if Brach chain

	test	ax,STYP_Lab	;Label IFs and ElseNops are popped, but don't require binding
	jnz	BolControlBind	;Label IF frame - go check next stack entry

	mov	PTRTX[bx],di	;Store address of this BOL

BolControlBind:
	pop	ax			;Get frame type
	testx	ax,STYP_If+STYP_Else	;Bind If and Else
	jz	BolControlBindX
	testx	ax,STYP_Block		;Don't bother with block If/Else
	jz	BolDoBind		;Not Block IF or ELSE - perform the binding
BolControlBindX:
	push	ax			;Replace frame type
	and	SsFlags,not SSF_If	;Clear IF flag
	jmp	short BolComX		;exit through BolCom


;Bos0_0Com
;Purpose:
;	Handle standard BOS issues
;
;	SsCbFrameTemp is the number of bytes needed for the statement
;	just scanned.  It is used to keep a high water mark for the
;	number of temps needed by any statement.  This count is zeroed
;	in preparation for the next statement.
;
;	If we CAN continue, then there may be oTx's in the stack, in
;	MrsCur, etc., that need to be updated to account for text
;	expansion during scan.  References to these oTexts have been
;	marked with opNoList1, whose operand points to the reference.
;	The scan routine for opNoList1 updates the reference to point to
;	the current emit address.  However, a subsequent insertion (for
;	coercion, for example) could cause the point being referenced to
;	move again.  For this reason, the opNoList1 is left in the pcode
;	(as exNoList1) and two flags are maintained in SsBosFlags.
;	If both SSBOSF_Inserted and SSBOSF_PcUpdate are true, then an
;	insertion might have moved an opNoList1.  This routine will search
;	for exNoList1 and re-patch the references.
;
;	If a COMMON statement was being scanned, then there is a frame
;	on the stack with the owners of the Type and Value tables.  These
;	owners are moved back to the COM structure in the COMMON block
;	table.
;
;NOTE: This routine is fallen into by Ss_BOS and is also called.
;Input:
;	Standard Scan entry convention.
;Preserves:
;	dx
Bos0_0Com:
	push	di			;Save current emit oTx
	call	EmitExCopyOps		;Handle 0 consume 0 emit issues

;Report delayed Argument Count Mismatch errors
	mov	ax,UNDEFINED
	xchg	ax,[SsDelayCnt]		;Get count, reset to -1
	inc	ax			;Any errors?
	jz	UpdateTemp
	push	si
	mov	si,[SsDelayLoc]		;Source oTx of error
	mov	ax,[SsDelayErr]
	call	SsError
	pop	si

UpdateTemp:
;Update count of temporaries
	xor	ax,ax
	xchg	ax,[SsCbFrameTemp]	;Get count of temps needed
	mov	bx,dataOFFSET prsCur.PRS_cbFrameTemp
	test	byte ptr [grs.GRS_oRsCur+1],80H	;MRS?
	jnz	CheckTemps
	mov	bx,dataOFFSET mrsCur.MRS_cbFrameTemp
CheckTemps:
	cmp	ax,[bx]			;Using more temps?
	jb	FewerTemps
	mov	[bx],ax 		;Set new max temp count
FewerTemps:

;Now check for PC update
	test	[SsBosFlags],SSBOSF_Inserted + SSBOSF_PcUpdate
	jz	NoPcUpdate
	jpo	NoPcUpdate		;If only 1 set, no work
;Have inserted pcode on line with PC Update pcode
	push	dx
	mov	bx,[SsOTxBos]		;Start of previous line
UpdateLoop:
	mov	ax,codeOFFSET exNoList1 ;pc update executor
	call	SsFindOpNoList1
	jc	ExitPcUpdate
	mov	ax,PTRTX[bx-2]		;Get offset of reference
	xchg	ax,bx
	mov	[bx],ax			;Adjust to new location
	xchg	ax,bx
	jmp	UpdateLoop

ExitPcUpdate:
	pop	dx
NoPcUpdate:
	pop	ax			; AX = oTx of BOS in emitted code
	mov	[SsOTxBos],ax		; Save oTx of BOS
	mov	[SsOTxStart],di 	;New first location for DIM
	mov	bx,UNDEFINED		; No patch indicator
	xchg	bx,[SsOTxPatchBos]	; BX = Address to be patched ?
	.erre	UNDEFINED EQ 0ffffh	; Assure INC/JZ is sufficient
	inc	bx			; Any?
	jz	@F			; No
	mov	PTRTX[bx+1],ax		; Patch Bos address
@@:					
	test	[SsBosFlags],SSBOSF_StCommon	;Finishing up COMMON?
	jz	CheckCase
;Have COMMON entry on stack to clean up
	push	dx
	push	es
	mov	ax,[bp-SsCom].COM_oCom
	add	ax,[grs.GRS_bdtComBlk.BD_pb] ;oCommon --> pCommon
	xchg	bx,ax			;pCommon to bx
	mov	ax,[bp-SsCom].COM_oValCur
	mov	[bx].COM_oValCur,ax
	mov	ax,[bp-SsCom].COM_oTypCur
	mov	[bx].COM_oTypCur,ax
.errnz	SsCom - COM_bdType
	add	bx,COM_bdType
	push	bp			;Current owner
	push	bx			;New owner
	add	bx,COM_bdValue - COM_bdType
	cmp	[bp-SsCom].COM_bdValue.BD_cbPhysical,UNDEFINED ;User Library?
	jz	CopyTypOwner
	lea	ax,[bp-SsCom].COM_bdValue
	push	ax			;Current owner
	push	bx			;New owner
	call	BdChgOwner		;Copy BD back to COMMON table
CopyTypOwner:
	call	BdChgOwner
	mov	[pSsCOMcur],0		;reset to default
	pop	es
	pop	dx
	pop	cx			;Return address
	add	sp,SsComSize+4		; Eat oCommon and cbFixed
	pop	bp
	push	cx			;Return address back
CheckCase:

;
;	Binds CASE true branches to BOS.  The line may only consist of
;	constant expressions and case executors, thus the CASE frame
;	must be on the top of the scan stack.  If this is not the case,
;	it was the result of a CASE without SELECT error which is detected
;	by Ss_Case.

	test	[SsBosFlags],SSBOSF_StCase ;Need to bind TRUE Case branch?
	jz	ResetFlags

	pop	cx			;pop return address
	pop	ax			;get frame type
	test	ax,STYP_Case		;is this a CASE frame?
	push	ax
	push	cx
	jz	ResetFlags		;brif not, must have been an error (CASE w/o SELECT)

	mov	bx,sp			;get ptr to CASE frame
	inc	bx
	inc	bx			;skip return address
	mov	ax,UNDEFINED		;reset start of TRUE branch chain
	xchg	ax,[bx].FCASE_oTxTrue	;get ptr to start of TRUE branch chain
	xchg	ax,bx			;bx = start of TRUE branch chain
	mov	cx,[SsoTxBos]		;bind to start of BOS
	call	BindExit		;bind the chain

ResetFlags:
	mov	SsBosFlags,0		;Reset statement flags
	mov	[SsBosStack],sp 	; SP at BOS
	ret

SsProc	OptionBase1
	or	[mrsCur].MRS_flags,FM_OptionBase1
	jmp	short CheckOption

SsProc	OptionBase0			;Already set by default
CheckOption:
	test	[SsFlags],SSF_HaveDimmed;DIM already occured?
	jz	SetDimmed		;If not, it's OK
	xchg	cx,ax			;Save executor in cx
	mov	ax,MSG_OBA		;Array already dimensioned
	jmp	short NestError

SetDimmed:
	or	[SsFlags],SSF_HaveDimmed;Don't allow another OPTION BASE
	jmp	short NotInProc


SsProc	Shared,rude
	jmp	short NotInProc

SsProc	StShared,rude
	or	SsBosFlags,SSBOSF_StShared
	jmp	short Ss_StDim		

SsProc	StStatic,rude
	or	SsBosFlags,SSBOSF_StStatic
	jmp	short Ss_StDim		


SsProc	StDim,rude

	mov	[SsOTxPatchBos],di	; Patch this with next Bos address
	add	di,4			; Address after this opcode
	mov	[SsOTxStart],di 	; New first location for DIM
	sub	di,4			; Restore current emit address
	jmp	short Ss_0_0


SsProc	NotInProc
NotInProc:
	test	byte ptr [grs.GRS_oRsCur+1],80H	;In a procedure?
	jz	Ss_0_0			;If not, it's OK
	xchg	cx,ax			;Save executor in cx
	mov	ax,MSG_InvProc		;Illegal in procedure
NestError:
	call	SsError
NestCont:
	xchg	ax,cx			;Restore executor to ax
	jmp	short Ss_0_0

SsProc	ElemRef
	test	[SsFlags],SSF_InType	;In a TYPE declaration?
	jnz	Ss_0_0			;If so, it' OK
	xchg	cx,ax			;Save executor in cx
	mov	ax,MSG_InType
	jmp	short NestError


SsProc	StConst,rude

	mov	cl,[SsExecFlag]
	mov	[SsExecTmp],cl		    ;Save current state of OPA_fExecute
	or	[SsBosFlags],SSBOSF_Const   ;Flag that we're in a CONST statement
	jmp	short Ss_0_0

SsProc	AsType,rude
	jmp	short Ss_0_0


SsProc	Static
	mov	f_Static,TRUE
	jmp	short Ss_0_0

SsProc	Dynamic
	mov	f_Static,FALSE
	jmp	short Ss_0_0

SsProc	0_0
	push	[ScanRet]	;Push address of main scan loop
				;And fall into EmitExCopyOps to handle standard
				; 0 consume 0 emit issues
;EmitExCopyOps - Emit executor and copy operands
;Purpose:
;	Emit the executor for the current opcode.
;	Copy all operands from source to destination.
;
;NOTE:	SsProc 0_0 falls into this code.
;
;Input:
;	ax	 = executor
;	bx	 = opcode * 2
;	es:si/di = scan source and destination
;Output:
;	bx    = opcode
;	si/di	updated
;
;Preserves:
;	dx
Public	EmitExCopyOps
EmitExCopyOps:
	STOSWTX 			;Emit the executor
;	jmp	short CopyOperands	;Fall into CopyOperands

;***
;CopyOperands
;Purpose:
;	Copy the operands for opcode in bx from si to di.
;
;	This routine handles the following special cases:
;	- no operands for this opcode
;	- operand count is the first operand
;
;NOTE:	EmitExCopyOps falls into this code.
;
;Input:
;	bx = opcode * 2
;	si = source of copy
;	di = destination
;	es = segment of copy
;
;Output:
;	bx = opcode
;	si/di updated
;
;Preserves:
;	dx
;*****************************************************************
Public	CopyOperands
CopyOperands:
	shr	bx,1			;Back to opcode
	mov	cl,mpOpAtr.[bx] 	;Load atribute byte
	and	cx,OPA_CntMask		;Get the operand count from atribute
.errnz	OPA_CntMask AND 0FF00H		;must use cx in next line if non-zero
	cmp	cl,OPA_CntMask		;Check for cnt field in operand
	jne	CopyOp	 		;No cnt field
	LODSWTX 			;Load the cnt field
	STOSWTX 			;Emit the byte cnt field
	mov	cx,ax
	inc	cx			;Round to even byte count
CopyOp:
	shr	cx,1			;Move to word count
	cli				;Double prefix! No interrupts!
rep	movs	PTRTX[si],PTRTX[di]	;Copy the operands
	sti
	ret


subttl	Label Reference Scanning
page
;***
;Ss_MrsMrsLabRef - scan dispatch for RESUME/RETURN <line/label>
;Purpose:
;	Scope and bind RESUME/RETURN <line/label> reference to definition.
;	Check to ensure that the RESUME/RETURN statement was at the module
;	level.	If not, issue an Illegal in PROC or DEF FN error.
;	bind the RESUME/RETURN to a module level label.  If the label
;	definition is in a DEF FN, SUB, or FUNCTION, issue a
;	scoping error.
;Entry:
;	standard scan entry
;Exit:
;	standard scan exit
;Exceptions:
;	Illegal in proc or DEF FN.
;	Label not defined.
;****************************************************************************


SsProc	MrsMrsLabRef
	STOSWTX 			;emit executor
	test	grs.GRS_oRsCur,8000H	;are we in DEF FN, SUB, or FUNCTION?
	jz	LabelBindMrs		;brif not, at main level
	mov	ax,MSG_InvProc		;Illegal in PROC or DEF FN
	call	SsError 		;remember error
	jmp	short LabelBindMrs	;bind to module level label


;***
;Ss_MrsLabelRef - scan dispatch for binding labels to module level
;Purpose:
;	Scanner entry point to scope and bind labels which must always
;	be bound to the module level.  The statements that get bound
;	here include ON event GOSUB <lab/line>, ON ERROR GOTO <lab/line>,
;	RESTORE <lab/line>, and RUN <lab/line>.
;
;	NOTE: RESTORE <lab/line> may bind within a DEF FN, or to the
;	Module level.
;
;	If the label definition is in a DEF FN, SUB, or FUNCTION, issue a
;	scoping error.
;Entry:
;	standard scan entry
;Exit:
;	standard scan exit
;Exceptions:
;	Label not defined.
;****************************************************************************
SsProc	MrsLabelRef
	STOSWTX 				;Emit executor
	    cmp     ax,CODEOffset exStRestore1	;Is this a RESTORE <lab/line>
	    jnz     LabelBindMrs		;Brif not
	mov	fRestoreLab,TRUE		;Set special RESTORE flag
;fall into LabelBindMrs

page
;LabelBindMrs, LabelBindMrsCx - bind label refs to module level
;Purpose:
;	Binds one(LabelBindMrs), or more (LabelBindMrsCx) label
;	references to module level label defs.	Scoping errors
;	and undefined label refs are checked.
;Entry:
;	cx - count of labels to bind
;	es:si - start of label oNam list to bind.
;	es:di - emit address for bound label oTx.
;Exit:
;	source and emit addresses advances appropriately.
;Exceptions:
;	Label not defined.


;public  LabelBindMrs			 ;Entry point to bind to a module level
LabelBindMrs:				;label
	mov	cx,1			;will bind 1 label

;public  LabelBindMrsCx 		 ;Entry point to bind a list of label
LabelBindMrsCx: 			;refs to module level label defs
	mov	ax,grs.GRS_oMrsCur	;scope it to MODULE level
	GETSEG	dx,[mrsCur.MRS_txd.TXD_bdlText_seg],,<SIZE,LOAD> ;[3] get module text table
	mov	bx,mrsCur.MRS_txd.TXD_otxLabLink  ;get module label chain

	test	txdCur.TXD_flags,FTX_mrs ;are we in a module level text table?
	jz	LabelBind		;brif not, use module text table
	jmp	short LabelBindCom	;bind to current text table

page
;***
;Ss_nLabelRef - scan dispatch for binding a list of labels to same scope
;Purpose:
;	Scanner entry point to scope and bind labels which must always
;	be bound to the same scoping level. This scanner dispatch
;	handles a list of labels.  Statemtents that are bound by this
;	routine include ON <exp> GOSUB <lab/line, ...>, and
;	ON <exp> GOTO <lab/line, ...>.
;
;	If the label definition is not at the same scoping level, (e.g.
;	into or out of DEF FN) then a scoping error is generated.
;Entry:
;	standard scan entry
;Exit:
;	standard scan exit
;Exceptions:
;	Label not defined.
;****************************************************************************
SsProc	nLabelRef
	STOSWTX 			;emit executor
	mov	ax,ET_I2		;enumerated GOTO, GOSUB must have I2 arg
	call	EnsureArgType		;coerce to I2 if necessary
	LODSWTX 			;get operand byte count
	STOSWTX 			;and emit it
	shr	ax,1			;byte => word count
	xchg	ax,cx			;set up label count
	jmp	short LabelBindCur

;***
;Ss_LabelRef - scan dispatch for binding a labels to the same scope
;Purpose:
;	Scanner entry point to scope and bind labels which must always
;	be bound to the same scoping level. This scanner dispatch
;	handles a list of labels.  Statemtents that are bound by this
;	routine include GOSUB <lab/line, ...>, GOTO <lab/line>, and
;	RETURN <lab/line>
;
;	If the label definition is not at the same scoping level, (e.g.
;	into or out of DEF FN) then a scoping error is generated.
;Entry:
;	standard scan entry
;Exit:
;	standard scan exit
;Exceptions:
;	Label not defined.
;****************************************************************************
SsProc	LabelRef
	STOSWTX 			;emit executor
	mov	cx,1			;will bind one label
;fall into LabelBindCur

page
;LabelBindCur, LabelBindCom, LabelBind - label binders
;Purpose:
;	Label binder routines for the various styles of label
;	binding.
;
;	LabelBindCur - binds the label ref and def to the same
;	    scope, using the current text table.
;	LabelBindCom - binds the label ref to a label def in
;	    the current text table.  The scoping rule for the
;	    the target label has already been determined.
;	LabelBind - binds the label ref to the specified text
;	    table, with the specified target scoping rule.
;
;	The label ref scope is defined by grs.GRS_oRsCur, which defines
;	the oRs for the Module, DEF FN, SUB, or FUNCTION of the label
;	ref.  If we are scanning the direct mode buffer, then the
;	current CONTINUE context is used to define the label ref scope.
;
;	The label def scope is the expected oRs of the actual
;	definition.  This may, or may not be within the current text
;	table.	The label def scope is kept in the variable oRsExpected.
;	If bit 0 of oRsExpected is set then the label def (if found)
;	was in a SUB or FUNCTION.  If the label was found and was
;	in a module level text table, oRsExpected is compared against
;	the oRs of the label def to ensure that illegal binding
;	across DEF FN boundaries has not occurred.
;
;	The actual binding occurs as follows:
;
;	- If the oRsExpected text table is the same as the current emit
;	  text table, then the label links are searched from the scanner
;	  source address to the end of the pcode.
;
;	  If found in this range, link the emit address into the label list.
;	  This label reference will be bound at label definition time.
;	  The low bit of the label definition link is set to indicate a link
;	  in the label definition list is pointing to an unbound reference.
;
;	- If not found in the step above, or if the text table we are
;	  searching is not the emit text table, then search from the
;	  root of the label chain in the appropriate text table for a
;	  definition of the referenced label.
;
;	  If the search text table is the same as the emit text table,
;	  the search terminates at the scanner emit address.
;
;	  If the label is found in this search, bind the label.  Not finding
;	  the label is declared as an error.
;
;	RESUME 0 , ON ERROR GOTO 0, and ON <event> GOSUB 0 have the special
;	label oNam UNDEFINED.  This label is emitted as UNDEFINED.
;
;
;Entry:
;	ax - oRs of expected scope (LabelBindCom, LabelBind)
;	bx - oTx of label chain start (LabelBind)
;	cx - count of labels to bind
;	dx - test seg containing label chain (LabelBind)
;	es:si - start of label oNam list to bind.
;	es:di - emit address for bound label oTx.
;Exit:
;	source and emit addresses advances appropriately.
;Exceptions:
;	Label not defined.

; CX = count of labels to bind

public	LabelBindCur			;Entry point to bind a label to
LabelBindCur:				;current context
	mov	ax,grs.GRS_oRsCur	;expected same scope

	    test    txdCur.TXD_flags,FTX_mrs	;are we in a module text table?
	    jnz     LabelBindCom		;brif so

	or	al,1			;set low bit to indicate that we are
					;binding to SUB or FUNCTION


;	AX = oRs of expected scope (low bit set if binding TO a SUB/FUNCTION)
;	CX = count of labels to bind

;	Common entry for LabelBindMrs

LabelBindCom:
	GETSEG	dx,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;[3] set text table to current
					; text tbl in case we are already 
					; at module level
	mov	bx,txdCur.TXD_otxLabLink ;get cur label link chain


;At this point, DX = text table to bind to, BX = start of label def chain
;		AX = oRs of expected scope, CX = count of labels to bind
;		ES:SI = pcode addr of oNam/ref label ref list to be bound

;	Common entry for LabelBindMrs

LabelBind:
	mov	oRsExpected,ax		;remember expected scope
LabelBindLoop:
	push	cx			;save label count
	LODSWTX 			;get label oNam
	cmp	[SsErr],0		;Any errors so far?
	jne	@F			;If so,don't bind labels
	cmp	ax,0fffeh		; Is this RESUME 0/NEXT or ON ERROR/EVENT
	jae	@F			;GOTO/GOSUB 0? skip bind if so.
	push	bx			;remember start of label chain
	call	LabelSearch		;Search for label in specified text table
	pop	bx
@@:
	STOSWTX 			;bind label/or emit oNam
	pop	cx			;restore label count
	loop	LabelBindLoop
	mov	fRestoreLab,cl		;reset Binding RESTORE flag
	jmp	[ScanRet]		;return to main scan loop

page

;LabelSearch - search for label definition
;
;Purpose:
;	This routine searches for labels in the specified context.
;	The label definition will either be at the same scope as
;	the label reference, or at the module level.  If this is not
;	the case, either an Undefined Label, or Subprogram error
;	will be generated.  If the direct mode buffer is being bound,
;	then the current Continue context will be used to determine
;	scoping errors.
;Entry:
;	 oRsExpected = oRs of expected scope.
;	 ax  = oNam of label to be found
;	 bx  = start of label def chain
;	 dx  = Text table seg to search.
;	 es:si	= text table addr of label ref
;	 es:di	= text table emit addr
;Exit:
;	 ax  = oTx of found label, or oNam if not found.
;Preserves:
;	 dx

LabelSearch:
	push	ds
	mov	cx,es
	cmp	cx,dx			;are we searching in current table?
	jnz	LabelNotCurTxt		;brif not, table already bound

;Searching for a label definition in same txt table as label reference.

	mov	cx,[SscbTxExpand] 	;get table expansion factor
	mov	bx,[SsLinkCtl]		;address of label control structure
	mov	bx,[bx].TXLNK_LabDefNext ;Next unbound label reference
	mov	ds,dx			;set ds to txt table of search
	jmp	short LabSearchSrc	;Search forward through unbound source

SkipRef:
	dec	bx			;Reset LSB of reference
NextLink:
	mov	bx,[bx]			;Get link to next
LabSearchSrc:
	cmp	bx,-1			;End of chain?
	jz	LabelNotForwardRef	;Label not found - go look in already
					; bound section of current text table
	test	bl,1			;Just a forward reference?
	jnz	SkipRef
	add	bx,cx			;Adjust by SsCbTxExpand
	cmp	ax,[bx+2]		;oNames match?
	jnz	NextLink

	mov	ax,bx
;Forward Reference Case
	pop	ds			;recover dgroup
	push	bx			;preserve ptr to def
	call	CheckLabelScope 	;check for scoping errors before
					;linking into forward ref chain
	pop	bx			;recover ptr to def
	jnz	LabelSearchX		;brif invalid scope

	push	ds
	mov	ds,dx			;set ds to label def txt table
	mov	cx,[bx] 		;Load link field from definition
	mov	ax,di
	inc	ax			;Mark as forward reference link
	mov	[bx],ax 		;Emit forward reference link to current
					; label reference
	xchg	ax,cx			;AX = pcode address of next
					; unbound label definition offset
	pop	ds			;recover DGroup

LabelSearchX:				;finished was a forward ref
	ret

LabelNotForwardRef:
;Search the section of the current text table that is already bound.
assumes	ds,nothing
	mov	bx,txdCur.TXD_otxLabLink;Start at first label
LabelNotCurTxt:
	mov	ds,dx			;search in specified table
	jmp	short LabSearchBound	;Search from start through bound source

BoundLoop:
	cmp	ax,[bx+2]		;oNames match?
	jz	LabFound
	mov	bx,[bx]			;Link to next
LabSearchBound:
	test	bl,1			;End of chain (either unbound or -1)
	jz	BoundLoop
	pop	ds			;Label not found

LabelScopeError:
	mov	ax,ER_UL		;"Undefined Label" or incorrect scoping
	dec	si
	dec	si			;Back up to oName (sets error location)
	call	SsError
	LODSWTX 			;recover oName
	or	sp,sp			;reset psw.z
	ret


LabFound:
	mov	ax,bx
;   ax = address of definition
;es:di = address of reference
	dec	ax			;Move back to oTx of BOL pcode
	dec	ax
	pop	ds			;recover ds = dgroup
assumes	ds,data

; fall into CheckLabelScope.

page
;CheckLabelScope - find and check oRs for passed oTx, verify expected scope
;
;Purpose:
;	This routine verifies that the found label is in the expected
;	scope.	If not, an Undefined label error is issued.
;Entry:
;	 oRsExpected = oRs of expected scope.
;	 ax  = oTx
;	 dx  = Text table seg of of label def.
;	 es:si	= text table addr of label ref
;Exit:
;	 psw.z - indicates valid scope.
;	 psw.nz - indicates scoping error detected, and Undefined label error
;		  has been recorded.
;	 ax  = oTx of label if valid scope, or oNam if invalid scope.
;Preserves:
;	dx
;
;NOTE: CheckLabelScope is called from forward ref case, and fallen into.
;      from the already backwards ref/not current table case.

CheckLabelScope:

; Find oRs of found oTx and check against expected oRs.  If mismatch,
; then we have a scoping error.

	mov	bx,oRsExpected		;get expected oRs
	shr	bx,1			;see if in sub or function
	jc	LabelScopeX		;brif so, scope is ok

; oRs could be in a DEF FN or at module level.	Verify it is at expected
; scope.
	shl	bx,1			;restore expected oRs
	call	ScanORsOfOtx		;cx = oRs of label def.
	cmp	bx,cx			;is oRs expected oRs?
	jz	LabelScopeX		;brif so, no error

; Check for the special case of RESTORE <lab/line> which can bind
; to either the current DEF FN, or to the Module level.
	cmp	fRestoreLab,0		;is this special case of RESTORE?
	jz	LabelScopeError 	;brif not, issue error

; We only can get here if the RESTORE statement was in a DEF FN and
; the label definition was also in a DEF FN.  Make sure that the label
; def and the RESTORE statement are in the same DEF FN.
	cmp	cx,grs.GRS_oRsCur	;is this the same DEF FN?
	jnz	LabelScopeError 	;brif not - Label Scoping error

LabelScopeX:
	xor	bx,bx			;return with psw.z set - scope ok
	ret

page
;ScanORsOfOtx - find oRs of passed oTx.
;
;Purpose:
;	Given an  offset within the text table table defined by
;	DX, return the oRs of the DEF FN, or module which it falls
;	within.  This routine understands how defs are bound in execute
;	and non execute states, and can bridge the Scan gap if
;	this is the current text table.
;
;	The DEF FN chain is preserved in SS_EXECUTE state.  If a table
;	has been fully bound, then the DEF FN chain for the module is
;	directly walkable.  If the text table is partially bound, then
;	if SsLinkCtl.TXLNK_DefFn is 0 then no DEF FNs have been bound
;	yet.  The DEF FN chain is walkable by adjusting all entries
;	by the size of the scan gap.  If the SsLinkCtl.TXLNK_DefFn
;	is non-zero, then the scan bound/unbound gap is defined by
;	a single entry in the DEF FN chain with the low order bit set.
;	This entry indicates that the NEXT entry starts the unbound
;	DEF FN chain.  The unbound entries are walkable by applying
;	the size of the scan gap as an adjustment value.
;	The DEF FN chain is terminated by an UNDEFINED ptr.
;
;Entry:
;	ax = otx
;	dx = text table seg
;Exit:
;	cx = oRs of module or DEF FN containing the oTx.
;Preserves:
;	ax, bx, dx.
;

ScanORsOfOtx:
DbAssertRel ax,nz,UNDEFINED,SCAN,<Invalid oTx passed to ScanORsOfOtx>
	push	es
	push	di
	push	si
	push	bx
	push	dx			;save text seg of bind
	mov	cx,[grs.GRS_oMrsCur]	;default return value = oMrsCur
	mov	di,CODEOffset exStDefFn ;search is for DEF FN executors
	mov	si,es
	mov	es,dx			;es = seg adr of search txt tbl
	mov	bx,[mrsCur.MRS_otxDefFnLink] ;start at head of DEF FN list

	cmp	dx,si			;are we searching txdCur?
	mov	dx,0			;default adjustment for scan gap.
					;we start out assuming that we are
					;searching bound pcode.
	jnz	DefFnLoop		;brif not, table has already been bound
	push	bx			;save start of DefFn chain
	mov	bx,SsLinkCtl
	cmp	[bx].TXLNK_DefFn,0	;have any DEF FN entries been bound?
	pop	bx			;recover start of DEF FN list
	jnz	DefFnLoop		;brif so, search bound pcode first


	or	bl,1			;flag that we are crossing scan gap
					;search unbound pcode
DefFnLoop:
	cmp	bx,UNDEFINED		;are we at the end of DEF FN list?
	jz	DefFnExit		;brif so
	shr	bx,1			;clear lsb - Are we crossing scan gap?
	jnc	NotCrossingGap		;brif not


	mov	di,opStDefFn		;search for DEF FN opcodes in
					;unbound pcode
	mov	dx,SscbTxExpand 	;get table expansion factor for unbound
					;def fn links
NotCrossingGap:
	shl	bx,1			;recover oTx of next DEF FN link
	add	bx,dx			;adjust for text expansion
	cmp	bx,ax
	ja	DefFnExit		;brif beyond otx of interest
	mov	cx,[grs.GRS_oMrsCur]	;default return value = oMrsCur

	cmp	WORD PTR es:[bx-4],opNoList0 ;is this the CONT statement?
	je	GotContContext		;brif so - exceptional case
	cmp	WORD PTR es:[bx-4],di	;is this a DEF FN executor/opcode?
	jne	NotInDef		;brif its an END DEF
ContInDef:
	mov	cx,es:[bx+2]		;ax = oPrs of this DEF FN
	or	ch,80H			;make it into an oRs
NotInDef:
	DbChk	DefFnLink		;perform sanity check on this link.
	mov	bx,es:[bx]		;bx points to next in linked list
	jmp	SHORT DefFnLoop 	;applies standard BOUND adjustment

; Handle very special case where we are in Edit and Continue, AND the
; current statment is a DEF FN or END DEF that has yet to be scanned.
; In this case opNoList0 was inserted into the pcode for the opStDefFn
; or opStEndDef.  The real opcode is in SsErrOpcode.

GotContContext:
       cmp	[SsErrOpcode],di	;is this a DEF FN?
       je	ContInDef		;brif so
       jmp	short NotInDef		;must be END DEF

DefFnExit:
	pop	dx
	pop	bx
	pop	si
	pop	di
	pop	es
	ret

page
;DebChkDefFnLink - perform sanity check on Def Fn chain link.
;
;Purpose:
;	Verifies that current link in Def Fn chain is valid.
;Entry:
;	es:bx - pcode addr of chain link
;Exit:
;	none.
;Uses:
;	none.
;Exceptions:
;	Invalid DefFn chain link.


sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssdata.asm ===
TITLE	ssdata	- Scanner specific data declarations
;***
;ssdata - Scanner specific data declarations
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains scanner specific data declarations only.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSDATA_ASM = ON
	.list


assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA

sBegin	CODE
foo	label	byte
sEnd	CODE


subttl	Static data area definitons.
sBegin	DATA

public	SegCode
SegCode		dw	seg foo

public	SsErrOTx
SsErrOTx	DW 0		;Text offset of pcode which was replaced by opEot

public	SsErr
SsErr		DW 0		;Error code to be returned by scanner.

public	SsErrOpcode
SsErrOpcode	DW 0		;Opcode which was replaced by opEot

public	SsDelayErr,SsDelayLoc,SsDelayCnt
SsDelayErr	dw 0		;Error code of delayed error
SsDelayLoc	dw 0		;oTx of delayed error
SsDelayCnt	dw 0		;Count of pending delayed errors

public	ScanRet
ScanRet 	DW 0		;Scan loop return address

	public	f_Static	
f_Static	DB 0		;TRUE if $STATIC in effect

	public	f_StaticCalc	
f_StaticCalc	DB 0		;Move to temporary for calcualtion

public	SsExec,SsExecFlag,SsExecTmp
SsExec	label	word		;Flags below referenced as one word
SsExecFlag	DB 0		;OPA_fExecute ORed in if can't allow COMMON
SsExecTmp	DB 0		;Temporary hold for SsExecFlag during CONST

public	ScannerFlags,SsBosFlags,SsFlags
ScannerFlags	label	word	;Flags below referenced as one word
SsBosFlags	DB 0		;Scanner begin of statement flags
SsFlags 	DB 0		;General scanner flags

	public	SsOTxPatchBos	
SsOTxPatchBos	DW 0		; Address of word to be patched at next Bos

	public	SsOTxStart	
SsOTxStart	DW 0		; Address of point where stack is empty

public	SsOTxBOS
SsOTxBOS	DW 0		;oTx for BOS for statement being scanned

public	SsCbTxExpand
SsCbTxExpand	DW 0		;Count of bytes by which the text table has expanded.

public	SsLinkCtl
SsLinkCtl	DW 0		;Address of Label control structure

public	SsCbFrameTemp
SsCbFrameTemp	DW 0		;Bytes of temp space for current statement

public	SsStackSave
SsStackSave	DW 0		;Save location for sp from start of scan

public	SsLineCount
SsLineCount	DW  0		;No. of lines scanned

;Descan uses these to keep track of return address on the stack
public	SsNextOTx,SsReturnBp
SsNextOTx	DW 0		;oTx of return address
SsReturnBp	DW 0		;offset in stack of return frame

;ScanAndExec needs the following
public	SsScanExStart,SsScanExSrc
SsScanExStart	DW 0		;Starting address of execution
SsScanExSrc	DW 0		;oTx of original source

	;Ss_StCall uses these to count parameter bytes for CDECL calls

	public	SsCbParmCur,SsParmCnt
SsCbParmCur	dw 0		;cb of all params so far
SsParmCnt	dw 0		;Number of parameters

public	SsOtxHeapMove
SsOtxHeapMove	dw 0		;oTx of last possible heap movement


public	SsBosStack
SsBosStack	dw 0		;SP-2 at BOS


sEnd	DATA
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssdescan.asm ===
page	49,132
	TITLE	ssdescan - Descan support routines
;***
;ssdescan - Descan dispatched routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains descan routines.  There is one descan
;   routine for one to many scan routines.
;
;   The connection between scan routines and descan routines is as
;   follows:
;   - Each scan routine is declared with macro SsProc.	This macro
;     places the address of the descan routine in the word before the
;     scan routine (much like the connection between executors and their
;     opcodes).
;   - Each descan routine is declared with macro SsDProc.  This macro
;     declares a public entrypoint for the descan routine.
;
;   Descan routines are dispatched with:
;   ax = opcode
;   si = descan source
;   di = descan destination
;
;
;*****************************************************************************

	.xlist
	include 	version.inc
SSDESCAN_ASM = ON
	IncludeOnce	context
	IncludeOnce	opcontrl
	IncludeOnce	opmin
	IncludeOnce	optables
	IncludeOnce	pcode
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list


assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA


subttl	Descan routines
sBegin	SCAN
assumes cs,SCAN

extrn	mStNextOpExe:word

page
SsDProc Eot
	mov	ScanRet,SCANOFFSET DescanTerm	  ;Cause descan termination
;***
;SsD_BOS, Others with no operands.
;
;Purpose:
;
;   Descan executors that have no operands.
;
;   NOTE: Eot causes descan termination by modifying the dispatch
;	  loop return address.
;
;Input:
;
;   standard descan dispatch
;
;Output:
;
;   standard descan dispatch
;
;******************************************************************

SsDProc LUBound1		
SsDProc LUBound2		
SsDProc ReDim
SsDProc ReDimScalar		
SsDProc 2FnSamePExe
SsDProc Shared
SsDProc 0FnEtExe
SsDProc FnString
SsDProc	UMi
SsDProc 1FnPExe
SsDProc 1FnPExeR8		
SsDProc Do
SsDProc CaseElse
SsDProc CaseTo
SsDProc Case
SsDProc EndSelect
SsDProc	StView

IdOpEmitId:
	STOSWTX 			;Emit the opcode or oNam or variable offset
	jmp	[ScanRet]		;Return to descan loop

;Added with [18]
;end of [18]

SsDProc NoList3
	inc	si
	inc	si		;Skip over operand
SsDProc NoList2
	inc	si
	inc	si		;Skip over operand
SsDProc NoList1
	inc	si
	inc	si		;Skip over operand
SsDProc NoList0
	jmp	[ScanRet]

SsProc	NoList3,,local		;No scan routines, just descan pointers
SsProc	NoList2,,local

tNextType	label	word
	db	ET_R8,0
	db	ET_R4,0
	db	ET_R4,0
	db	ET_I4,0
	db	ET_I4,0
	db	ET_I2,STYP_Step
	db	ET_I2,0

SsDproc Next
	test	byte ptr es:[si+2],1	;NEXT without IdRf?
	jnz	SsD_NextId		;Bit set means no IdRf inserted
	sub	di,4			;Eat preceding IdRf
SsDproc NextId
	mov	dx,PTRTX[si-2]		;Get executor
	STOSWTX
	MOVSWTX	   			;Copy oFrame
	xchg	ax,dx			;Executor to ax
	push	di
	push	es
	push	cs
	pop	es
	mov	di,SCANOFFSET mStNextOpExe    ;Point to NEXT executors
	mov	cx,ET_MaxNum*2*2	    ; No. of executors
	repne	scasw			    ;Find which executor
	DbAssertRel	cx,ne,0,SCAN,<ssdescan:NEXT executor not found in map>
	cmp	cx,ET_MaxNum*2		    ; Still in first map?
	jb	LookUpNext
	sub	cx,ET_MaxNum*2		    
LookUpNext:
	pop	es
	pop	di
	mov	bx,cx			    ;Index of match
	shl	bx,1
	mov	ax,[bx-2].tNextType	    ;bx >= 2
	STOSWTX
	jmp	SsD_NoList1		    ;Skip source oTx operand

page
;***
;SsD_NOps - Descan routine
;Purpose:
;	Descan opcodes with:
;	- 0 to n operands that take no special processing
;
;	This includes IF syntax and label reference syntax as the label
;	references were descanned before executing the descan loop.
;
;	This routine is used as the dispatch point for SS_RUDE scan and
;	descan for the case that the opcode requires no work for this
;	transition.
;
;**********************************************************************
SsDProc FPutGet3
SsDProc FPutGet2
SsDProc LRSetMid
SsDProc LSet
SsDProc FnLen
SsDProc StLock
SsDProc Input
SsDProc Swap
SsDProc LineInput
SsDProc InputPrompt
SsDProc PaintWidth

SsDProc StConst

SsDProc AsType
SsDProc OffLd
SsDProc OffSt
SsDProc	ElemRef

SsDProc GPutGet
SsDProc PaletteUsing
SsDProc FieldItem
SsDProc StShared
SsDProc StCommon
SsDProc	Static
SsDProc	Dynamic
SsDProc StCallS
SsDProc	Sadd
SsDProc	Varptr
SsDProc Varptr$


SsDProc StStatic
SsDProc StDim				

SsDProc BOS
SsDProc	OptionBase0
SsDProc OptionBase1

SsDProc StEndProc
SsDProc StExitProc
SsDProc StCallLess
SsDProc StCall
SsDProc ByVal_Seg
SsDProc LParen

SsDProc For
SsDProc Exit

SsDProc IfBlock
SsDProc EndIf
SsDProc IfLab
SsDProc If
SsDProc Else
SsDProc ElseNop
SsDProc ElseIf

SsDProc While
SsDProc Wend
SsDProc DoLoop
SsDProc Loop
SsDProc LoopWhile

SsDProc Select

SsDProc Erase
SsDProc 4ET_ET
SsDProc StCnt
SsDProc Lit
SsDProc LitI2				
SsDProc Coerce
SsDProc Bol
SsDProc BolEmit
SsDProc NotInProc
SsDProc LabelRef		;Label references are descanned in a separate
SsDProc MrsLabelRef		; pass on the text - they are already descanned
SsDProc MrsMrsLabRef		; by the time this dispatch is taken.
SsDProc nLabelRef





SsDProc 0_0

public	SsD_NOps
SsD_NOps:
	STOSWTX 		;Emit the opcode
	and	ax,OPCODE_MASK
CopyOp:
	mov	bx,ax		;Move opcode to bx for CopyOperands
	shl	bx,1		;CopyOperands takes opcode * 2
	call	CopyOperands
	jmp	[ScanRet]	;Return to descan loop

;***
;SsD_AId - Descan Array Variables
;
;Purpose:
;
;   Arrays may be $STATIC or $DYNAMIC.	This is calculated each time
;   the array is scanned.  The FV_STATICSET bit indicates whether the
;   array type is yet known.  If the bit is not cleared, the user will
;   get a ReDim of $STATIC array error the second time the program is
;   scanned.
;
;**********************************************************************

SsDProc AVtRf
SsDproc AIdSt
SsDproc AIdLd
	STOSWTX 			;Emit the opcode
	LODSWTX 			;Pick up the count operand

	;Fall through .....

SsDProc VtRf
SsDproc IdSt
SsDproc IdLd
	STOSWTX 			;Emit the opcode
	LODSWTX 			;Pick up the oVar operand
	STOSWTX 			;Emit the oVar operand
	    add     ax,MrsCur.MRS_bdVar.BD_pb	;oVar --> pVar
	xchg	ax,bx			;BX = oVar
	DbChk	pVar,bx 		;Verify that this is a variable

	test	byte ptr [grs.GRS_oRsCur+1],80H ;Descanning module level?
	jz	Reset			;Brif yes, always reset.
	    TestM   [bx].VAR_Flags,FVSHARED ;[3] Shared variable?
	    jnz     NoReset		;Don't reset if SHARED and in proc
Reset:
	and	[bx].VAR_Flags,NOT FV_STATICSET 
	and	byte ptr [bx].VAR_fStat,NOT FV_Static
					;Indicate to recalc $STATIC
NoReset:
	jmp	[ScanRet]

	page
;***
;SsLabelDefDebind
;
;Purpose:
;
;   Descan opcodes that define labels.	These opcodes need link field
;   maintenance, and the oName must be copied.	Some varients may have
;   other operands.
;
;   This routine uses ssLinkCtl to maintain the address of the last
;   label definition link field.
;
;   txdCur is updated when the first definition is encountered.
;
;   The last label link is set to undefined after exiting from the
;   descan loop.
;
;   No forward reference links will be encountered as label references
;   are already descanned.
;
;***************************************************************************

SsDProc BolLabDef
SsDProc LabDef

SsLabelDefDebind:
	STOSWTX 				;Emit the opcode
	push	ax				;Save the pcode
	mov	bx,SsLinkCtl			;Address of link control struc
	mov	ax,[bx].TXLNK_LabDefLast	;oTx of last label def field
	or	ax,ax				;First link?
	jz	SsLabelDefFirst 		;No pervious label
	xchg	ax,bx
	mov	PTRTX[bx],di			;Update last link to here
	xchg	bx,ax
SsLabelDefCont:
	mov	[bx].TXLNK_LabDefLast,di	;Update address of last link
	pop	ax
	jmp	short CopyOp			;Copy operands and exit

SsLabelDefFirst:
	mov	txdCur.TXD_otxLabLink,di	;Update txd head pointer
	jmp	short SsLabelDefCont


page

sEnd	SCAN
sBegin	CODE
;Table of opcodes with label reference operands that must be descanned.
tLabelRefExecs	label	word
	DW cLabelRefOpcodes		;Count of entries in table
	DW opEot			;SsLabelRefDebind assumes opEot
					; is the 1st opcode in table
	DW opEvGosub
	DW opStGosub
	DW opStGoto
	DW opStOnError
	DW opStOnGosub
	DW opStOnGoto
	DW opStRestore1
	DW opStResume
	DW opStReturn1
	DW opStRunLabel
	DW opStElseLab
	DW opStIfLab
	DW opStIfGotoLab

cLabelRefOpcodes EQU ($-tLabelRefExecs-2) SHR 1
sEnd	CODE

sBegin	SCAN
assumes cs,SCAN

;***
;SsLabelRefDebind
;
;Purpose:
;
;   Debind all label references in the current text table.
;
;   When descanning, label references are unbound in a separate pass.
;   A separate pass is used because text is compressed during descan,
;   causing problems for backward label references.
;
;   The rule byte for label reference opcodes contains a specification
;   of the number of label operands.  It is either a count, or LOWUND,
;   which indicates that the first operand is a count of bytes of label
;   reference operands.
;
;NOTE:	This routine will not handle opcodes that can have 0 label references,
;   due to the structure of the PerReference loop.
;
;   Label reference opcodes descanned by this module are found in
;   tLabelRefExecs.  Txtmgr routine TxtFindOpExec searches text for
;   executors that match an opcode in this table.
;
;   Whenever a scan-time error occurs, further label binding is stopped.
;   Thus debinding is stopped when the location of the error is reached.
;
;Input:
;
;   di = offset of first pcode to consider descanning
;   es = current text segment
;
;Output:
;
;***************************************************************************
	public SsLabelRefDebind
SsLabelRefDebind:

PerLabelOpcode:
	mov	bx,CODEOFFSET tLabelRefExecs	;Table of opcodes containing
						; label references.
	push	bx
	PUSH_ES 				
	cCall	TxtFindOpExec,<di,bx>		;index to next label reference
						;dl = tbl index of opcode found
	POP_ES					; restore es = text tbl seg
	pop	bx				;restore bx -> tLabelRefExecs
	xchg	di,ax				;di = oTx of found pcode
	xchg	ax,dx				;Index to opcode found
	or	al,al				;Found EOT?
	jz	SsLabelRefDebindX		;Eot found - no more refs

;Process label reference pcode
	cbw					;ax = index to opcode found
	xchg	si,ax				;si = index to opcode found
	inc	di
	inc	di				;Skip to first operand field
	inc	si				;Skip over count of table entrys
	shl	si,1				;To word index
	GetCodeIntoDs	SCAN		
	mov	bx,[bx+si]		; Load opcode that was found
	push	ss			
	pop     ds			
	mov	si,di				;Sync source and dest on pcode
	call	GetRuleInfo
	cmp	al,LOWUND			;Test for operand = cblabel refs
	jnz	GotRefCount			;ax = actual label ref count
	LODSWTX 				;Pick up label ref count
	shr	ax,1				;cb to cLabel refs

GotRefCount:
	mov	dx,es				;default lab def to cur txt seg
	test	al,80H				;is def for ref in mrs?
	jz	GotTextSeg			;brif not, user cur txt seg
	test	txdCur.TXD_flags,FTX_mrs	;is mrs the cur txt table?
	jnz	GotTextSeg			;brif so, use cur txt table
	GETSEG	dx,[mrsCur.MRS_txd.TXD_bdlText_seg],,<SIZE,LOAD> 
					; get mrs txt table seg
					; text tbl in case we are already 
					; at module level

GotTextSeg:
	and	ax,80h-1			;High bit indicates scope
	xchg	cx,ax				;cx = Count
	mov	di,si				;Sync source and destination

PerRefLoop:
	cmp	si,[SsErrOTx]			;Outside error range?
	jae	SsLabelRefDebindX		;If so, terminate debinding
	LODSWTX 				;Pick up bound label ref
	push	es				;save label ref txt seg
	mov	bx,ax				
	inc	bx				;Test for label UNDEFINED
	jz	LabRefDebSkip			;Skip unbinding this label
	mov	es,dx				;use label def txt seg
	mov	ax,PTRTX[bx+3]			;Load oName from def pcode
						; NOTE:[bx+3] = [bx+4] w/ inc bx
LabRefDebSkip:
	pop	es				;recover label ref txt seg
	STOSWTX 				;Emit the oName
	loop	PerRefLoop			;Loop if more references

	jmp	short PerLabelOpcode		;Go search for the next opcode

SsLabelRefDebindX:
	ret

page
;***
;
;**********************************************************************
SsDProc StDeclare
SsDProc StSub
SsDProc StFunction
	STOSWTX
	xchg	ax,bx			;Opcode to bx
	shl	bx,1			;Must pass opcode*2
	mov	ax,PTRTX[si+2]		;Get oPRS
	push	[ScanRet]
	mov	dh,-1			;Set descan direction
	jmp	SsReLinkDecl

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssdeclar.asm ===
page	49,132
	TITLE	ssdeclare - scan support for declarative statement opcodes
;***
;ssdeclare - scan support for declarative statement opcodes
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   These routines scan DIM, COMMON, VtRf, AVtRf, and provide additional
;   external support for COMMON.
;
;   COMMON utilizes a value table, where the actual values are stored,
;   and a type table, which describes what's in the value table.  (In
;   the case of arrays, the array descriptor is in the value table.)
;
;   Each entry in the value table is rounded up to the next whole word
;   in size if it needs an odd number of bytes.  This can only happen
;   when fixed-length strings are involved, either as simples or in
;   records.
;
;   The basic entry in the type table is the oType of its corresponding
;   element in the value table.  Types and values are linked only by their
;   order in the tables.  For arrays, the oType is preceded by a word
;   with bit 14 set, and the count of dimensions in its low byte.  For
;   records, the oType is followed by the oMRS that defines the type.
;
;   Arrays are always assumed to have 8 dimensions for purposes of
;   allocating space in the value table for the array descriptor.  The
;   actual number of dimensions is kept for type checking, not space
;   allocation.
;
;   When chaining, information about user types is lost.  To still
;   provide some type checking, the type table entry is modified.
;   The oMRS field for the record type is changed to contain the
;   record length.  Bit 13 of the oType is set to indicate this was
;   done.  Type checking consists of verifying the records are of
;   of the same length.  The oType itself is no longer used.
;
;
;****************************************************************************

	.xlist
	include		version.inc
SSDECLARE_ASM = ON
	IncludeOnce	context
	IncludeOnce	executor	
	IncludeOnce	optables
	IncludeOnce	pcode		
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list


extrn	B$ISdUpd:far
extrn	B$IAdUpd:far
extrn	B$STDL:far
extrn	B$IErase:far

assumes	es,nothing
assumes	ds,DATA
assumes	ss,DATA
assumes cs,SCAN


sBegin	DATA

	globalW	pSsCOMcur,0		;normally zero; when we're growing
					;  COMMON bdTyp and bdValue tables, this
					;  contains a pointer to where those
					;  tables can be found on the stack.
					;  This is necessary for bkptr updating
					;  in case the value table moves.
sEnd	DATA

sBegin	SCAN

;These flags are used in the high bits of oTyp in a COMMON block type table
cDimsFlag=	40H	;This word has cDims in low byte, not oTyp
LengthFlag=	20H	;Next word is length of record
StaticFlag=     1       ;$STATIC array in COMMON

;***
;Ss_StCommon - Scan the COMMON statement
;
;Purpose:
;
;   Creates a stack frame with COMMON information.  This frame is removed
;   by SsBos.
;
;   The frame includes the owners of the COMMON block's type and value
;   tables, as well as indexes into those tables.  The change of owners
;   is needed so they don't move as the the tables grow.
;
;***********************************************************************

SsProc	StCommon,rude
	mov	[SsOTxPatchBos],di	; Patch this with next Bos address
	STOSWTX 			;Emit executor
	test	[SsExecFlag],OPA_fExecute ;Already seen executable stmt?
	jz	@F
	mov	ax,MSG_COM		;COMMON must precede executable stmts
	call	SsError
@@:
	MOVSWTX 			;Skip over oTx operand
	LODSWTX				;Get oNam
	STOSWTX 			;Emit it
	push	ax
	call	MakeCommon
	inc	ax			;Out of memory?
	jz	OME
	dec	ax
	or	[SsBosFlags],SSBOSF_StCommon	;Set flag for VtRf

	;Make stack frame with COMMON info

	push	bp
	push	ax			; Place holder for COM_cbFixed
	push	ax			;Save oCommon
	    add     ax,[grs.GRS_bdtComBlk.BD_pb]    ;oCommon --> pCommon
	add	ax,SsCom+SsComSize	;Get to end of structure
	xchg	bx,ax			;pCommon.bdType to bx
	mov	cx,SsComSize/2		;Word size of structure
@@:
	dec	bx			
	dec	bx
	push	[bx]			;Copy word to stack
	loop	@B			;Repeat
	mov	bp,sp			;bp is low byte of COM structure
	    mov     [pSsCOMcur],sp	;see module header for explanation
;Assign owners
.errnz	SsCom - COM_bdType
	push	bx			;Current owner
	push	bp			;New owner
;If COMMON in user library, Value field is not an owner
	    add     bx,COM_bdValue - COM_bdType
	    cmp     [bx].BD_cbPhysical,UNDEFINED    ;User Library?
	    jz	    CopyTypOwner		    ;yes, skip value field
	push	bx			;Current owner
	lea	bx,[bp-COM_bdType].COM_bdValue
	push	bx			;New owner
	call	BdChgOwner		;Copy BD to stack
CopyTypOwner:
	call	BdChgOwner
	jmp	CommonX

OME:
	mov	ax,ER_OM
	call	SsError
	or	[SsBosFlags],SSBOSF_StStatic	;Set flag for no work in VtRf
	jmp	CommonX


subttl	Ss_AVtRf and Ss_VtRf
page
;***
;Ss_AVtRf - Scan AVtRf variants array Id opcodes
;
;Purpose:
;
;   Scan the id variants opAVtRf<type>.
;
;   The statements STATIC, SHARED, COMMON, and DIM all use AVtRf opcodes.
;
;   Arrays are $STATIC or $DYNAMIC based on the first reference to
;   the array.	Variables in determining the array type are:
;   - Statement.  The first reference may be in any of the following
;     statements: STATIC, SHARED, COMMON, DIM, REDIM, ERASE, PUT, GET
;     or <implicit ref> (indicating any other legal location for an array
;     reference).
;   - $STATIC and $DYNAMIC metacommand.  The default is $STATIC.  This
;     default may be changed by using the $STATIC and $DYNAMIC metacommands.
;
;   The table below shows what kind of array ($STATIC/$DYNAMIC) is created
;   or what error is reported by the BASCOM 2.0 compiler.  The <implicit>
;   case has been added for completeness - it does not use an AVtRf opcode.
;
;   Statement of First Ref  $STATIC		    $DYNAMIC
;   -----------------------------------------------------------
;   STATIC/COMMON/REDIM     $DYNAMIC		    $DYNAMIC
;   DIM (constant indices)  $STATIC		    $DYNAMIC
;   DIM (expression  index) $DYNAMIC		    $DYNAMIC
;   <implicit>		    $STATIC		    $STATIC
;   ERASE/PUT/GET/SHARED    Syntax error	    Syntax error
;
;   In the case of statements where the opcode follows the opAVtRf
;   the AVtRf scanner pushes the oVT and a flag indicating the
;   existence of an expression as an index.  The statement scanners
;   use this information to determine whether the array is $STATIC or
;   $DYNAMIC.  The declarative statement scanners are given the
;   number of AVtRf arguments by methods described in the scan routines
;   for those statements.
;
;   In the case of statements where the statement opcode preceeds the
;   opAVtRf the opAVtRf scanner sees that a flag is set, indicating
;   which executor was seen.  This flag is cleared at BOS.  The AVtRf
;   scanner completes the scan task for the statement indicated by
;   this flag.
;
;   Functions are referenced using the same opcodes as variables.
;   The VtRf variants may reference a function.  However, if they do
;   it is an error.
;
;   Tasks:
;	1. bind to executor.
;	2. complete the scan task for STATIC/COMMON/SHARED.
;	3. calculate whether any index contains an expression (as opposed
;	   to a literal).
;	4. make a scan stack entry for arrays for the case that the statement
;	   executor follows the opAVtRf.
;	5. Coerce all index expressions to integer.  This ensures that the
;	   executor for this statement can clean the stack.
;
;Algorithm:
;
;   Load and emit executor
;   Copy operand(s)
;   Ensure that the variable is not a function.
;   Coerce arguments, calculating whether any argument is not a literal.
;   If COMMON, SHARED, STATIC
;      Perform scan work for these statements.
;   ELSE (must be ERASE, PUT, GET, DIM, REDIM)
;      Push stack entry
;	  oVar
;	  flag TRUE if an index was an expression.
;	  index count
;      Scan routines for these opcodes must verify that the number of
;	  dimensions matches the number of indices.  opStDimTo must have
;	  twice the indices as opStGet, and ERASE takes no indices.
;   Return to scnner main loop
;
;Input:
;
;   ax	  = opcode
;   bx	  = 2 * opcode
;   es:di = pcode emission address
;   es:si = pcode source address
;
;Output:
;
;   si updated
;
;Modifies:
;Exceptions:
;	Ss_Error
;
;******************************************************************

.errnz	FALSE		;This algorithm depends on F_Static and F_StaticCalc
	page

AVtRfToFun:
	jmp	VtRfToFun

AVtRfRedirect:
	mov	ax,[bx].VAR_value	;Get new oVar
	mov	PTRTX[di-2],ax		;Patch into pcode
	jmp	short AVtRfRetry

StaticArray:
	;If NOT first ref, it's an error

	TestX	dx,FV_STATICSET 	;First reference?
	mov	ax,ER_DD		;Duplicate definition if not
	jnz	AVtRfError
	call	SetArrayTypeNoDim	;Set fStatic for this array
AVtRfX:
	jmp	[ScanRet]

SharedArray:
	;Make sure it's referenced at the module level

	TestX	dx,FV_STATICSET 	;First reference?
	jnz	AVtRfX			;Better not be
	mov	ax,ER_UA		;Array not defined
AVtRfError:
	call	SsError
	jmp	short AVtRfX

FRAME=	FVCOMMON+FVSTATIC+FVSHARED+FVFORMAL+FVVALUESTORED+FVREDIRECT

ComDimCnt	=	8		;No. of dims allowed in COMMON
ComArraySize	=	(size AD - 1) + ComDimCnt * (size DM)

CommonArrayJ:				
	jmp	CommonArray		


SsProc	AVtRf,Rude
	xchg	ax,bx			; BX = executor map address
	mov	al,byte ptr es:[si-1]	; High byte of opcode
	.erre	OPCODE_MASK EQ 03ffh	
	and	ax,HIGH (NOT OPCODE_MASK)
	shr	ax,1			; Convert to word offset
	add	bx,ax			; Index into map
	mov	ax,cs:[bx]		; Load executor
	STOSWTX 			;Emit the executor
	LODSWTX 			;Load argument count
	STOSWTX 			;And emit the arg count
	xchg	cx,ax			;Preserve for processing indices
	LODSWTX 			;Load oVar
	STOSWTX 			;Emit oVar
AVtRfRetry:
	    add     ax,[MrsCur.MRS_bdVar.BD_pb] ;oVar --> pVar
	xchg	ax,bx
	DbChk	pVar,bx 		;Verify that this is a variable
	mov	ax,[bx].VAR_Flags	;[5]

	;Check for AVtRf to a function error.

	TestX	ax,FVFUN		;Is this a ref to a function?
	jnz	AVtRfToFun		;Error - AVtRf to a function.

	    ;Check for AVtRf to redirected variable.

	    TestX   ax,FVREDIRECT	;Is the variable redirected?
	    jnz     AVtRfRedirect	;Redirected variable.

	DbAssertTst ax,nz,FVARRAY,SCAN,<Ss_AVtRf: Non-array>

	;Allocate oFrame.

	    TestX   ax,FRAME		;Is it a frame var?
	    jnz     @F

	call	SsAllocOFrame		;Allocate an oFrame for this var
@@:

	    xchg    dx,ax		;Keep var flags in dx
	    mov     [f_StaticCalc],FALSE;If first ref, assume dynamic array
	    mov     al,[SsBosFlags]
	    test    al,SSBOSF_StCommon	;Is it a COMMON statement?
	    jnz     CommonArrayJ
	    test    al,SSBOSF_StStatic
	    jnz     StaticArray
	    test    al,SSBOSF_StShared
	    jnz     SharedArray

	;DIM case handling - the statement opcode hasn't been seen.

	;Initialize Index Seen flag for $STATIC array calculation.
	;Flag is initialized to current default array type.
	;Needed only for DIM

	    mov     al,[f_Static]	;TRUE if $STATIC in effect
	    mov     [f_StaticCalc],al	;Move to temporary for calc

	mov	ax,ET_I2		;Target type
	call	SsCoerceN		;Coerce cx indices to type ax
					;f_StaticCalc set FALSE if any nonlits

	cmp	[f_StaticCalc],FALSE	; Were any expressions found?
	jne	@F			; Brif no expression found

	    or	    [SsExecFlag],OPA_fExecute	; This is executable

@@:					
	mov	dx,[bx].VAR_Flags	

	;Test for second DIM of array error.
	;In QB multiple Dims of $Dynamic arrays are allowed.
	;In EB multiple Dims are prevented by the variable manager.


	    TestX   dx,FV_STATICSET	;Test if array type has been set
	    jnz     @F			; Brif second Dim.
	    TestX   dx,FVCOMMON 	; Is this common array
	    jz	    NotSecondDimErr	; Brif not common.	Set type

	    ;This is first reference to a Common array.  The array must be
	    ;$Static since the Common statement would have set FV_STATICSET.

	    mov     ax,[SsOTxStart]	;Load oTx for this Dim clause.
	    mov     [bx].VAR_value.ACOM_oValue,ax   ;Save oTx of Dim statement
@@:
	    test    byte ptr [bx].VAR_fStat,FV_STATIC ;Is the array $STATIC?
	    jnz     SecondDimError	;Brif second dim of $Static array
NotSecondDimErr:

	call	SetArrayType		;Set BX=pVtArray to type in f_StaticCalc
	mov	cx,PTRTX[di-4]		;AX = cArgs
	shr	cx,1			;Two indices per dimension in DIM TO
					; Parser ensures pairs of indices.
	cmp	cl,[bx].VAR_value.ASTAT_cDims	;Is index count = dims
	jne	WrongCDimError		;Brif cDims is incorrect
@@:

	mov	ax,[SsOTxStart] 	;Load oTx for this Dim clause.
	mov	[SsScanExStart],ax	;Save in case needed below


AllocateArray:
	test	byte ptr [bx].VAR_fStat,FV_STATIC ;Is the array $Static?
	jz	DimExit 		; Brif $Dynamic array

	    TestX   dx,FVCOMMON 	; Is this common array
	    jnz     DimExit		; Brif common. Don't allocate now.

	cmp	[bx].ASTAT_ad.FHD_hData,0   ;Allocated already?
	jne	DimExit 		;Brif yes.  Bypass allocation.


	cmp	[SsErr],0		;Any errors?
	jne	DimExit2		;Brif yes.  Bypass allocation.

	mov	[DimAtScanType],SSDIM_STATIC
	push	ax			;Dummy parameter
	push	ax			;Dummy parameter
	call	ExecuteFromScan 	;Allocate array.  AX = RT error code.
	jnz	DimError		;Brif error code <> 0

DimExit:				

DimExit2:
	mov	[SsOTxStart],di 	;Update pointer for next Dim clause
	jmp	[ScanRet]		;Scan next opcode



SecondDimError: 			
	mov	ax,MSG_OBA		;Array already dimensioned
	jmp	short DimError		



WrongCDimError: 			
	mov	ax,MSG_SubCnt		;Wrong number of subscripts
DimError:
	call	SsError
	jmp	short DimExit		



NewArTypeJ:
	jmp	NewArType

StaticCommonJ:				
	jmp	StaticCommon		

CommonArray:
	call	SetArrayTypeNoDim	;Set fStatic for this array
					; to type in f_StaticCalc
					;Input:
					; bx = pVtArray

	;Set oCommon and oValue in variable table

        cmp     [SsErr],0                       ;Any errors so far?
        jnz     CommonX                         ;Don't risk it if so
	mov	ax,[bx].VAR_cbFixed		; Get length of FS
	mov	[bp-SsCom].COM_cbFixed,ax	; Save
	mov	ax,[bp-SsCom].COM_oCom		;Get oCommon
	mov	[bx].VAR_value.ACOM_oCommon,ax
	mov	cl,[bx].VAR_value.ACOM_cDims	;Get cDims
	GetOtyp dx,[bx] 			;Get oTyp of element
	test	byte ptr [bx].VAR_fStat,FV_STATIC ;$STATIC array in COMMON?
	jnz	StaticCommonJ
	mov	ch,cDimsFlag

	mov	ax,[bp-SsCom].COM_oValCur	;Get oValue
	mov	[bx].VAR_value.ACOM_oValue,ax

	;See if this stuff fits

	add	ax,ComArraySize			;Size of AD in COMMON
	call	ChkComSize			;bx = oTypCur
	jc	CommonX 			;Quit if no room

	;See if there's a type in table

	cmp	bx,[bp-SsCom].COM_bdType.BD_cbLogical	;Have entry in table?
	jae	NewArTypeJ

	;Compare with existing type

	add	bx,[bp-SsCom].COM_bdType.BD_pb	;Point into type table

	;First check no. of dimensions

	cmp	ch,[bx+1]			;Make sure both are arrays
	jnz	TypTabErrNz
	or	cl,cl				;cDims not set in Var Table?
	jz	CompArElem			;Ignore count if not known
	cmp	cl,[bx]				;cDims match with type table?
	jz	CompArElem
	cmp	byte ptr [bx],0			;cDims not set in type table?
	mov	ax,MSG_SubCnt
	jnz	ComErr				;Index count error
	mov	[bx],cl				;Set cDims in type table
CompArElem:
	;Compare element type
	inc	bx
	inc	bx				;Point to element type
CompType:
	cmp	dx,ET_MAX			;Record type?
	ja	CompRec 			; Must compare across modules
	cmp	dx,[bx]				;ET types match?
TypTabErrNz:
	jne	TypTabErr
	.erre	ET_MAX LE 100h			; ET_FS in single byte
	cmp	dl,ET_FS			
	jb	SkipOTyp			; brif not fixed string
	inc	bx				
	inc	bx				; Point to length
	mov	ax,[bp-SsCom].COM_cbFixed	; Get length to Var table
	cmp	ax,word ptr [bx]		; Compare to common length
	jne	TypTabErr			

SkipOTyp:
	inc	bx
	inc	bx
	sub	bx,[bp-SsCom].COM_bdType.BD_pb	;pTypCur --> oTypCur
	mov	[bp-SsCom].COM_oTypCur,bx	;Update position in type table
CommonX:
	GetSegTxtCur				
	jmp	[ScanRet]

CompRec:
	mov	cx,[bx]				;Get oType
	cmp	cx,ET_MAX			;Is it a record?
	jbe	TypTabErr			; brif not record
	cmp	ch,LengthFlag			;Reduced to just a length?
	jz	CompLength

	mov	ax,[bx+2]			;Get oRS of this oTyp
	push	bx
	mov	bx,[grs.GRS_oRsCur]
	cCall	CompareTyps,<ax,bx,cx,dx>	
	REFRESH_ES				
	pop	bx
	or	ax,ax				
CompRecResults:
	jnz	TypTabErr
	inc	bx
	inc	bx
	jmp	SkipOTyp

CompLength:
	xchg	ax,dx				;oTyp to ax
	call	CbTypOTypSCAN			; Get its length
	cmp	ax,[bx+2]			;Match type table?
	jmp	CompRecResults

TypTabErr:
	mov	ax,ER_TM
ComErr:
	call	SsError
	jmp	CommonX
	
StaticCommon:
	;See if there's a type in table
	;cl = cDims
	;dx = oTyp
	;ds:bx = pVar

        mov     ch,cDimsFlag+StaticFlag
	push	[bx].VAR_value.ACOM_oValue	; Push oTxDim
	mov	ax,[bp-SsCom].COM_oTypCur	;Current type table offset
	inc	ax
	inc	ax				;Skip cDims
	mov	[bx].VAR_value.ACOM_oValue,ax	;Value is offset to AD
	dec	ax
	dec	ax
	xchg	bx,ax				;oTypCur to bx
	cmp	bx,[bp-SsCom].COM_bdType.BD_cbLogical	;Have entry in table?
	jae	NewStatic

	;Compare with existing type

	add	bx,[bp-SsCom].COM_bdType.BD_pb	;Point into type table

	;First check no. of dimensions

	cmp	cx,[bx]				;Make sure both are arrays
	xchg	ax,cx				;cDims to al
	pop	cx				;Get oTxDim
	jnz	TypTabErr
	cbw					;Zero ah
.errnz  size DM - 4
        shl     ax,1
        shl     ax,1
        add     ax,size AD-1		;ax = size of AD
        sub     sp,ax
	mov	bx,sp			;bx = pAD
	call	ExecDim

	;AX = Size of array in bytes

	push	si
	push	di
	mov	si,sp
	add	si,(size AD-1)+4	;Point to start of DM fields
	mov	di,bx			;pTypCur
	mov	cl,[di]			;Get cDims again
	add	di,(size AD-1)+2	;Skip cDims and AD header
	xor	ch,ch
	shl	cx,1			;2 words/dimension
	mov	ax,cx
	push	ds
	pop	es
	rep	cmpsw			;Compare dimensions
	mov	bx,di			;Pointer to element type
	pop	di
	pop	si
	call	TMErrorNz
	shl	ax,1			;cb of dimensions
	add	ax,size AD-1
	add	sp,ax			;Remove AD from stack
	jmp	CompType

NewStatic:
	;cl = cDims, ch = $STATIC array flags
	;dx = oTyp
	;bx = oTypCur
	;[sp] = oTxDim

	mov	ax,cx
	cbw				;Zero ah
        shl     ax,1
        shl     ax,1
	add	ax,(size AD-1)+2	;cDims, size, and AD header
	push	bx			;oTypCur
	add	bx,ax			;Make room for dimensions
	call	ExtendType
	pop	ax
	jc	ShrinkType		;Didn't fit
	xchg	bx,ax			;oTypCur to bx, ax points after AD
	add	bx,[bp-SsCom].COM_bdType.BD_pb	;Point into type table
	mov	[bx],cx			;Set array type, cDims
	pop	cx			;Get oTxDim
	push	ax			;points after AD
	inc	bx
	inc	bx			;bx = pAD
	call	ExecDim
	jc	ShrinkType		;Remove this entry from type table
	mov	[bx+2].AD_fhd.FHD_hData,DGROUPSEG   ;Allocated in DGROUP
	mov	[bx+2].AD_fhd.FHD_cPara,ax ;Use size that's been rounded even
	neg	ax
	add	ax,[bp-SsCom].COM_oValCur ;Array starts at oValCur
	add	ax,[bp-SsCom].COM_bdValue.BD_pb
	mov	[bx+2].AD_fhd.FHD_oData,ax
	pop	bx			;Offset to element type
	add	bx,[bp-SsCom].COM_bdType.BD_pb
	jmp	short SetOTyp

ShrinkType:
	pop	dx			;Clean off stack
	mov	bx,[bp-SsCom].COM_oTypCur
	mov	[bp-SsCom].COM_bdType.BD_cbLogical,bx
CommonXj:
	jmp	CommonX

ComErrJ:
	jmp	ComErr

NewArType:
	inc	bx
	inc	bx				;Skip over cDims word
NewType:
	call	ExtendType
	jc	CommonXj
	add	bx,[bp-SsCom].COM_bdType.BD_pb	;Point into type table
	cmp	ch,cDimsFlag			;Have an array?
	jnz	SetOTyp
	mov	[bx-2],cx			;Set cDims
	cmp	cl,ComDimCnt			;Max allowed dimensions
	mov	ax,MSG_SubCnt			;Wrong no. of dimensions
	ja	ComErrJ
SetOTyp:
	mov	[bx],dx 			;Set oTyp
	cmp	dx,ET_FS			; Fixed? Record?
	jb	SkipOTypJ			; brif numeric, SD, or TX
	    .erre   ET_FS EQ ET_MAX		
	    je	    SetLength			
	mov	ax,[grs.GRS_oRsCur]
SetExtension:					
	inc	bx
	inc	bx
	mov	[bx],ax				;Add oRS for records
SkipOTypJ:
	jmp	SkipOTyp
SetLength:					
	mov	ax,[bp-SsCom].COM_cbFixed	; Length of FS
	jmp	SetExtension			

VtRfCommon:
        cmp     [SsErr],0                       ;Any errors so far?
	jnz	CommonXj			;Don't risk it if so

	;Set oCommon and oValue in variable table

	mov	ax,[bp-SsCom].COM_oCom		;Get oCommon
	mov	[bx].VAR_value.COMREF_oCommon,ax
	mov	cx,[bp-SsCom].COM_oValCur	;Get oValue
	mov	[bx].VAR_value.COMREF_oValue,cx
	GetOtyp ax,[bx] 			; Get oTyp of element
	mov	dx,ax				; Save
	call	CbTypOTypSCAN			; Get size of this type
	jnz	Check_Size			; Brif not fixed length
	mov	ax,[bx].VAR_cbFixed		; Get length of FS
	mov	[bp-SsCom].COM_cbFixed,ax	; Save

	;See if this stuff fits

Check_Size:					
	add	ax,cx				;New allocation
	inc	ax
	and	al,not 1			;Round up to even
	call	ChkComSize			;bx = oTypCur
	jc	CommonXj			;Quit if no room in value table

	;See if there's a type in table

	xor	cx,cx				;Ensure cDimsFlag is clear
	cmp	bx,[bp-SsCom].COM_bdType.BD_cbLogical	;Have entry in table?
	jae	NewType

	;Compare with existing type

	add	bx,[bp-SsCom].COM_bdType.BD_pb	;Point into type table
	jmp	CompType

VtRfCommonJ:
	jmp	SHORT VtRfCommon


;***
;Ss_VtRf - scan simple VtRf opcodes
;
;Purpose:
;
;   Functions are referenced using the same opcodes as variables.
;   The VtRf variants may reference a function.  However, if they do
;   it is an error.
;
;   Tasks:
;	1. bind to executor.
;	2. handle redirection.
;	3. handle references to functions (errors).
;	4. complete the scan task for COMMON.
;	5. if not COMMON, STATIC or SHARED then assume DIM of a
;	   simple variable.
;
;Algorithm:
;
;   Load and emit executor
;   Copy operand
;   Ensure that the variable is not a function.
;   If COMMON
;      Complete COMMON work
;   If not COMMON, SHARED or STATIC, assume DIM
;   Return to scnner main loop
;
;Input:
;
;   ax	  = opcode
;   bx	  = 2 * opcode
;   es:di = pcode emission address
;   es:si = pcode source address
;
;Output:
;
;   si updated
;
;Modifies:
;Exceptions:
;	Ss_Error
;
;******************************************************************
page

VtRfRedirect:
	mov	ax,[bx].VAR_value	;Get new oVar
	mov	PTRTX[di-2],ax		;Patch into pcode
	jmp	short VtRfRetry

SsProc	VtRf,Rude
	xchg	ax,bx			; BX = executor map address
	mov	al,byte ptr es:[si-1]	; High byte of opcode
	.erre	OPCODE_MASK EQ 03ffh	
	and	ax,HIGH (NOT OPCODE_MASK)
	shr	ax,1			; Convert to word offset
	add	bx,ax			; Index into map
	mov	ax,cs:[bx]		; Load executor
	STOSWTX 			;Emit the executor
	LODSWTX 			;Load operand
	STOSWTX 			;Emit the operand
VtRfRetry:
	    add     ax,[MrsCur.MRS_bdVar.BD_pb] ;oVar --> pVar
	xchg	bx,ax
	DbChk	pVar,bx 		;Verify that this is a variable
	mov	ax,[bx].VAR_Flags	;[5]
	    ;Check for VtRf to redirected variable.

	    TestX   ax,FVREDIRECT	;Is the variable redirected?
	    jnz     VtRfRedirect	;Brif Redirected variable.

	;Check for VtRf to a function error.

	TestX	ax,FVFUN		;Is this a ref to a function?
	jnz	VtRfToFun		;Error - VtRf to a function.

	mov	dx,ax			; Preserve var flags in dx
	    TestX   ax,FRAME		;Is it a frame var?
	    jnz     @F			;Brif not

	call	SsAllocOFrame		;Allocate an oFrame for this var
@@:

	    mov     al,[SsBosFlags]
	    test    al,SSBOSF_StCommon	;Is it a COMMON statement?
	    jnz     VtRfCommonJ		;Not a COMMON array - done
	    test    al,SSBOSF_StShared	;Is it SHARED?
	    jnz     VtRfX		;No work for SHARED

	;If NOT first ref, it's an error

	TestX	dx,FV_STATICSET 	; First reference?
	mov	ax,ER_DD		; Duplicate definition if not
	jnz	VtRfError		; Brif not first reference


VtRfX:
	;The oTx of the next emitted executor must be saved so that the
	;subsequent declaration can evaluate the array bounds by starting
	;execution at the saved address.

	mov	[SsOTxStart],di 	;Update pointer for next Dim clause
	jmp	[ScanRet]

VtRfToFun:
	call	TMError
	jmp	VtRfX


VtRfError:
	call	SsError 		
	jmp	VtRfX			

	public	mpAVtRfOpExe			
mpAVtRfOpExe	label	word			
	DWEXT	exAVtRfImp			
	DWEXT	exAVtRfI2			
	DWEXT	exAVtRfI4			
	DWEXT	exAVtRfR4
	DWEXT	exAVtRfR8			
	DWEXT	exAVtRfSD			


	public	mpVtRfOpExe			
mpVtRfOpExe	label	word			
	DWEXT	exVtRfImp			
	DWEXT	exVtRfI2			
	DWEXT	exVtRfI4			
	DWEXT	exVtRfR4
	DWEXT	exVtRfR8			
	DWEXT	exVtRfSD			

page
;***
;Subroutines for COMMON

ChkComSize:
;See if COMMON block is big enough, grow if needed (and possible)
;
;Input:
;       ax = New total length needed
;Output:
;       bx = oTypCur
;       CY set if unable to fit
;cx,dx preserved

	mov	[bp-SsCom].COM_oValCur,ax	;Update position
 	mov	bx,[bp-SsCom].COM_bdValue.BD_cbLogical	
 	sub	ax,bx				;Fit within present size?
	jz	BigEnough
	cmc					;Success if CY clear
	jnc	BigEnough
;COMMON block growing - unless it's in user library
	    cmp     [bp-SsCom].COM_bdValue.BD_cbPhysical,UNDEFINED ;UL COMMON?
	    jz	    NoGrowULCommon
	push	cx
	push	dx
	push	bx				
	lea	bx,[bp-SsCom].COM_bdValue
	push	ax				;Remember how much space
	push	bx				;Owner to grow
	push	ax				;additional space needed
	call	BdGrowVar			;Extend COMMON block value table
	pop	cx				;Amount of new space
	pop	bx				;Position in COMMON
	call	OMEcheck			;See if it worked
	jc	NoZero				;If alloc failed, don't init
;Zero out new COMMON block space
	push	di				;Save emit oTx
	mov	di,bx				;Position in COMMON
	push	ds
	pop	es				;es = ds
	add	di,[bp-SsCom].COM_bdValue.BD_pb	;Point to new COMMON block space
	xor	ax,ax
rep	stosb					;Zero out COMMON block
	pop	di				;Restore emit oTx
NoZero:
	pop	dx
	pop	cx
BigEnough:
	mov	bx,[bp-SsCom].COM_oTypCur	;Current type table offset
	ret

NoGrowULCommon:
	mov	ax,MSG_ULCom
	call	CyError
	jmp	BigEnough

OMECheck:
	or	ax,ax
	jnz	OkRet
OMError:
	mov	ax,ER_OM
CyError:
	call	SsError
	stc				;Unable to grow COMMON
OkRet:	ret


ExecDim:
;Execute the DIM statement for a $STATIC array in COMMON
;The array space is allocated in the COMMON value table if possible,
;or the error is reported.
;
;Inputs:
;	bx = pAD
;	cx = oTxDim
;Outputs:
;	CY set if failed (error reported)
;	ax = size of array, rounded up to whole words
;	bx = pTypCur
;Preserves:
;	dx

	mov	[SsScanExSrc],bx	;Pass pAD to DIM
	DbAssertRel cx,nz,NULL,SCAN,<No DIM for $STATIC COMMON array>
        mov     [SsScanExStart],cx
	mov	[bx].AD_fhd.FHD_hData,0	;Flag it as not allocated
	push	dx
	mov	[DimAtScanType],SSDIM_COMMON
	push	ax			; ExecuteFromScan requires
	push	ax			; two garbage parameters
        call    ExecuteFromScan
	pop	dx
        jnz	CyError			;Error reported by runtime (in ax)?
	mov	ax,[SsScanExSrc]	;Size of array returned by DIM
	inc	ax
	jz	OMError
	and	ax,not 1		;Round up to next word
;Make sure it's not too big
	mov	cx,ax
	add	ax,[bp-SsCom].COM_oValCur	;Get oValue
        jc	OMError
	call	ChkComSize
 	jc	OkRet				;Return with CY set if error
	add	bx,[bp-SsCom].COM_bdType.BD_pb	;bx = pTypCur
	xchg	ax,cx
	ret

ExtendType:
;Grow the COMMON type table
;
;Inputs:
;	bx = new length
;	dx = oTyp
;Outputs:
;	CY set if failed (error reported)
;Preserves:
;	bx,cx,dx

	push	dx
	push	cx
	push	bx
	inc	bx
	inc	bx				;Need at least one more word
	cmp	dx,ET_FS			; Record? Fixed?
	.erre	ET_FS EQ ET_MAX 		
	jb	SmallTyp			
	inc	bx				; FS have cbFixed
	inc	bx				;Records have oRS too
SmallTyp:
.errnz	COM_bdType - SsCom
	push	bp				;Owner
	push	bx				;New size
	call	BdRealloc			;Extend COMMON type table
	call	OMEcheck			;See if it worked
	pop	bx				;oTypCur
	pop	cx
	pop	dx
	ret

	page
;***
;Ss_ReDim - Scan opReDim
;
;Purpose:
;
;   Scan opReDim.
;
;   The opReDim opcode comes after a AIdLd opcode.  This scan
;   routine receives a scan stack entry describing the referenced
;   variable as follows:
;
;		oTx	    Always immediately preceeding point
;		oType	    <-- (Top of stack)
;
;   Tasks include:
;
;	1. Bind to executor
;	2. Coerce remaining arguments to integers
;	3. if argument is the first reference to an array
;	   then set whether the array is $STATIC or $DYNAMIC
;	4. Test for REDIMing a $STATIC array error.
;
;Input:
;
;   ax	  = executor
;   bx	  = 2 * opcode
;   es:si = pcode source address
;   es:di = pcode emission address
;
;Output:
;
;   si, di updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

	page

SsProc	ReDim
	STOSWTX 			;Emit the executor
	dec	si
	dec	si			;Report errors on preceding AIdLd

	pop	ax			;Discard oType of array
	DbAssertTst ax,z,ST_Array?,SCAN,<Ss_ReDim: Non-array>
	pop	bx			;BX = oTx after exAIdLd
	call	MakeArrayRef		;Convert to exAdRf

	    mov     bx,PTRTX[si-2]		;BX = oVar
	    add     bx,[mrsCur.MRS_bdVar.BD_pb] ;BX = pVar

	test	byte ptr [bx].VAR_fStat,FV_STATIC ;Is this a static array?
	jnz	ReDimStatic		;REDIM stmt. $Static arrays not allowed.
ReDimX:
	inc	si
	inc	si
	jmp	[ScanRet]		;Scan next opcode

ReDimStatic:
	mov	ax,MSG_OBA		;Array already dimensioned
	call	SsError
	jmp	ReDimX

	page
;SetArrayType
;
;Purpose:
;
;   Routine to set FV_STATIC and FV_STATICSET in an array var entry.
;
;   This routine sets FV_STATIC to the value in f_StaticCalc iff
;   FV_STATICSET is FALSE.  It then ensures that FV_STATICSET is TRUE.
;
;Input:
;
;   f_StaticCalc = TRUE if type is $STATIC, else FALSE
;   bx		 = pVariable for an array variable
;
;Outputs:
;
;   CY set if first reference
;
;Preserves:
;
;   all


	public	SetArrayType
SetArrayType:
	or	[SsFlags],SSF_HaveDimmed	;Had a DIM: no OPTION BASE now
SetArrayTypeNoDim:
	DbChk	pVar,bx 			;Verify that this is a variable
SetArrayTypePublic:
	TestM	[bx].VAR_flags,FV_STATICSET	
						;Determine if the $STATIC flag
						; is already set for this array.
	jnz	SetArrayTypeX			;Already set - nothing to do.

	;Note:	In EB, all declarations at the module
	;level are shared and all at the the procedure level
	;are not therefore there need not be two checks.

	    ;Don't set flags for shared variables while scanning proc

	    TestM   [bx].VAR_flags,FVSHARED	; Shared variable?
	    jz	    SetStatic			;If not, set bit
	    test    byte ptr [grs.GRS_oRsCur+1],80H ;Scanning module level?
	    jnz     SetArrayTypeX		;If not, don't set bit
SetStatic:

	.errnz	FALSE
	cmp	[f_StaticCalc],FALSE
	je	@F				;$DYNAMIC, leave FV_STATIC clear

	; Array is dynamic if it lives on the procedure frame

	    TestM   [bx].VAR_flags,FRAME	; In the stack?
	    jz	    @F				; Brif array is on frame
	or	byte ptr [bx].VAR_fStat,FV_STATIC	;Set $STATIC
@@:
	or	WORD PTR [bx].VAR_Flags,FV_STATICSET	; Indicate FV_STATIC is set.
	stc
SetArrayTypeX:
	ret



sEnd	SCAN


sBegin	CP

assumes cs, CP

;***
;ChainCommon - prepare blank common for chaining
;
;Purpose:
;
;   Module type tables will be destroyed by chaining, so the
;   COMMON type table must stop referring to it.  Instead, user
;   type entries are replaced with a flag and the size of the type.
;   Type checking against the chained-to program will only compare
;   record sizes.
;
;Preserves:
;
;   dx
;
;Modifies:
;
;   si
;
;***********************************************************************
;
cProc	ChainCommon,<PUBLIC,FAR,NODATA>,<SI>
cBegin
	mov	si,[grs.GRS_bdtComBlk.BD_pb]	;pBlankCommon
	DbAssertRel [si].COM_ogNam,z,NULL,CP,<ChainCommon: 1st block in bdtComBlk is not for blank COMMON> 
	mov	cx,[si].COM_bdType.BD_cbLogical	;Size of type table
	mov	si,[si].COM_bdType.BD_pb	;pTypeTable
	add	cx,si			;Ending address
LookForRecord:
	cmp	cx,si			;Reach end?
	jbe	CommonReady
	lodsw
	cmp	ah,cDimsFlag+StaticFlag	;Static array?
	jz	SkipStatic
	cmp	ah,cDimsFlag		;Array count?
	jnz	Element
GetElement:
	lodsw				;Skip count, do element
Element:
	cmp	ah,LengthFlag		;Already converted?
	jz	SkipOver
.errnz	ET_MAX - ET_FS			; ensure FS is max type
	cmp	ax,ET_MAX		;Record type or fixed length string?
	jb	LookForRecord		; If not, look at next
;Have a record or fixed length string
	xchg	bx,ax			;Save oTyp in bx
	lodsw				;Get oRS
	je	LookForRecord		; brif fixed length string
	xchg	bx,ax			;oTyp to ax, oRS to bx
	call	CbTypOTypOMrs		;Get its size
	mov	byte ptr [si-3],LengthFlag	;Flag as size-only entry
	mov	[si-2],ax
	jmp	LookForRecord

SkipStatic:
	cbw				;ah=0
	shl	ax,1
	shl	ax,1			;Size of dimensions
	add	ax,(size AD-1)		;Skip AD
	add	si,ax			;Point to element
	jmp	GetElement

SkipOver:
	lodsw				;Skip over length
	jmp	LookForRecord

CommonReady:
cEnd

;***
;SsTrimCommon
;
;Purpose:
;
;   After chaining, blank COMMON could be larger than actually used.
;   This routine trims it back, releasing any owners.  The value table
;   is not actually shortened (it could be in a UL), but the type table
;   is, and that's what counts.
;
;   THIS ROUTINE MUST NOT BE CALLED IF SCAN ERROR OCCURED
;
;Inputs:
;
;   [oTypComMax] = max size of type table
;   [oValComMax] = max size of value table
;
;***********************************************************************
	public	SsTrimCommon

SsTrimCommon:
	push	si
	push	di
	mov	si,[grs.GRS_bdtComBlk.BD_pb]	;pBlankCommon
	cmp	[si].COM_bdValue.BD_cbPhysical,UNDEFINED ; QuickLib common?
	jz	SharedQLB			; brif so -- don't delete
						; or zero-fill common
	mov	cx,[si].COM_bdType.BD_cbLogical
	mov	bx,[si].COM_bdValue.BD_pb	
	add	bx,[oValComMax]
	mov	si,[si].COM_bdType.BD_pb	;Pointer to type table
	add	cx,si				;Point last+1 of type table
	add	si,[oTypComMax]
	call	DelCommon
	mov	si,[grs.GRS_bdtComBlk.BD_pb]	;pBlankCommon
;Zero fill trimmed part of value table
	mov	di,[oValComMax]
	push	ds
	pop	es				;Make sure es=ds
	mov	cx,[si].COM_bdValue.BD_cbLogical
	sub	cx,di				;Amount to zero fill


	add	di,[si].COM_bdValue.BD_pb
	shr	cx,1
	xor	ax,ax
rep	stosw

SharedQLB:					
	mov	ax,[oTypComMax] 		
	mov	[si].COM_bdType.BD_cbLogical,ax ; Trim the type table

	pop	di
	pop	si
	ret


;***
;SsAdjustCommon
;
;Purpose:
;
;   Called whenever a QBI-specific COMMON value table is moved (by heap
;   management code).  Updates the backpointers to all SD's and string
;   array descriptors found in the value table for the given COMMON block.
;
;Inputs:
;
;   bx = pointer to COM_bdType field
;   di = adjustment factor to be passed on runtime
;	    if di=0, delete all SD's and arrays
;
;***********************************************************************

DelCommon:
;si = starting point in type table
;bx = starting point in value table
;cx = ending point in type table
	xor	di,di
	push	si
	jmp	short TestEndCommon

	public	SsAdjustCommon
SsAdjustCommon:
	push	si
	mov	cx,[bx].BD_cbLogical
	mov	si,[bx].BD_pb		;Pointer to type table
	mov	bx,[bx-COM_bdType].COM_bdValue.BD_pb
	add	cx,si			;Point last+1 of type table
TestEndCommon:
	cmp	si,cx			;End of type table?
	jae	AdjustX
	lodsw				;Get type table entry
	cmp	ah,cDimsFlag+StaticFlag	;Static array?
	jz	AdjustStatic
	cmp	ah,cDimsFlag		;Array?
	jz	AdjustArray
	cmp	ax,ET_MAX		; Record ?
	ja	AdjustRecord		; Brif yes
	.erre	ET_MAX LE 0100h 	; Assure we can use AL
	cmp	al,ET_SD		; String type?
	jb	NotRecord		; Brif not
	    .erre   ET_FS EQ ET_SD+1	; Assure JA is sufficient
	    .erre   ET_FS EQ ET_MAX	; Assure no new types added
	    ja	    RecWithLen		; Brif fixed string

	call	AdjustOneSD
	jmp	TestEndCommon

AdjustRecord:				
	test	ah,LengthFlag		;Has record been crunched to length?
	jnz	RecWithLen
	push	bx
	mov	bx,[si]			;Get oMRS
	inc	si
	inc	si
	call	CbTypOTypOMrs
	pop	bx
	jmp	short AddCbTyp

AdjustX:
	pop	si
	ret

NotRecord:
	call	CbTypOTyp		;Get length of item
AddCbTyp:
	inc	ax			
	and	al,not 1		;Round even
	add	bx,ax
	jmp	TestEndCommon

RecWithLen:
	lodsw				;Get length of record or string
	jmp	AddCbTyp

AdjustStatic:
	cmp	[si].AD_fhd.FHD_hData,0	;Any space in array?
	jz	AdjustX			;In the middle of building an entry


	add	[si].AD_fhd.FHD_oData,di;Adjust pointer to array data
	cbw				;ah=0
	shl	ax,1
	shl	ax,1			;Size of dimensions
	add	ax,(size AD-1)		;Skip header
	xchg	dx,ax			;Save in dx
	mov	ax,[si].AD_fhd.FHD_cPara;Get size of array
	add	si,dx			;Point to element
	cmp	word ptr [si],ET_SD	;String array?
	jz	AdjSdStatic
	add	bx,ax
EatOTyp:
	lodsw				;Get oTyp
	cmp	ax,ET_FS		
	    .erre   ET_FS EQ ET_MAX	
	jb	TestEndCommon		
	lodsw				;Skip over oMRS/length
	jmp	TestEndCommon

AdjustArray:
	push	cx
	push	bx
	or	di,di			;Delete the array?
	jz	DelArray
	lodsw				;Get oTyp of array
	cmp	ax,ET_SD		;Array of strings?
	jne	NoAdjArray
UpdStrings:				
	push	bx			;First arg for runtime
	push	di			;2nd arg for runtime
	call	B$IAdUpd		;Have runtime do update
AddCbArray:
	pop	bx
	pop	cx
	add	bx,ComArraySize
	jmp	TestEndCommon

DelArray:
	push	bx			;First arg for runtime
	call	B$IErase		;ERASE array (no heap movement varient)
	lodsw				;Get oTyp
NoAdjArray:				
	cmp	ax,ET_FS		
	    .erre   ET_FS EQ ET_MAX	
	jb	AddCbArray		
	lodsw				;Skip over oMRS/length
	jmp	AddCbArray

AdjSdStatic:
;ax has size of array
	shr	ax,1
	shr	ax,1			;ax = no. of 4-byte SD's
	push	cx
	xchg	cx,ax			;No. of elements to cx
AdjustEachSD:
	call	AdjustOneSD
	loop	AdjustEachSD
	pop	cx
	jmp	EatOTyp

AdjustOneSD:
	push	cx
	push	bx
	push	bx			;First arg for runtime
	or	di,di
	jz	DelSD
	push	di			;2nd arg for runtime
	call	B$ISdUpd
AddCbSD:
	pop	bx
	pop	cx
	add	bx,4			;Size of SD in value table
	ret

DelSD:
	call	B$STDL			;Delete the SD
	jmp	AddCbSD

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssaid.asm ===
page    49,132
	TITLE	ssaid	- Scan support for array id opcodes
;***
;ssaid.asm - Scan support for array id opcodes
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains the scanner dispatch routines for array id opcodes.
;   These routines perform all tasks related to moving array id opcodes from
;   SS_PARSER to SS_EXECUTE scan state.
;
;   Scan routines for IdLd opcodes make a stack entry that describes the type
;   and location of the id in the scanned pcode.  The scan stack entry is
;   created by:
;
;	push oTx  - emitted pcode address of byte following id
;		     (address at which coercion would be inserted)
;	push oTyp - type of expression or ET_RC for records
;
;   See scanner.inc for a complete definition of the id stack entry.  The
;   oTyp word contains flags that uniquely distinguish variable references,
;   literals, and intermediate expression values.
;
;   Routines named Ss_<name> are dispatched by a jmp.  These routines
;   all return to the scan loop by an indirect jmp through variable scanret.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSAID_ASM = ON
	IncludeOnce	context
	IncludeOnce	executor	
	IncludeOnce	opid
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list

assumes ds, DATA
assumes es, NOTHING
assumes ss, DATA


sBegin	SCAN
assumes cs, SCAN

	subttl	Ss_AIdLd
	page
;***
;Ss_AId Scan Ld and St variants of array Id opcodes
;
;Purpose:
;
;   Scan the id variants opAIdLd<type> and opAIdSt<type>.
;
;   Functions are referenced using opAIdLd opcodes.  The scanner must detect
;   that the reference is a function reference from flags in the variable
;   table entry.
;
;   These routines expect only fundamental BASIC data types.  User types are
;   handled by opIdRf variants followed by OpIdOff opcodes.
;
;Parsed state opcode format:
;
;   (Nexp,...) opAId<Ld|St><Imp|I2|I4|R4|R8|CY|SD|TX>(cnt,oVar)
;
;      The expressions preceeding the opcode represent the indices whose
;   count is given by the argument cnt.
;
;Algorithm:
;
;   Calculate exe map table offset for data type from type in vt.
;   Calculate exe map offset for <I|S|F|C> from oPrsCur and vt flags
;   Load and emit executor
;   Copy operand
;   Coerce index arguments to I2.
;   If this is a Ld variant then
;	    Push stack entry
;	       operand address + 2
;	       type (with variable reference bit set)
;   Else
;	    Ensure the right side variable is of the correct type.
;   Set $STATIC flag in the variable table (if this is 1st ref).
;   Return to main loop
;
;Input:
;
;   ax	  = executor map address
;   bx	  = 2 * opcode
;   es:di = pcode emission address
;   es:si = pcode source address
;
;Output:
;
;	si,di updated
;
;Modifies:
;Exceptions:
;	Ss_Error
;******************************************************************
page
StRedirect:
	mov	ax,[bx].VAR_Value	    ;Value field has new oVar
	mov	PTRTX[si+2],ax		    ;Replace old one in pcode
	jmp	short AIdStRetry

SsProc	AIdSt,Rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	AIdStRetry			    
	mov	dx,scanOFFSET mpAStImpOpExe	    
AIdStRetry:					    
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si+2]		    

	DbChk	pVar,bx 			    ;Verify this is a variable

	;Check flags to see if we're really doing a store

	    mov     ax,[bx].VAR_flags	; Fetch flags
	    TestX   ax,FVREDIRECT	;Test for redirected variable
	    jnz     StRedirect		;Go fix the redirected case
	    TestX   ax,FVFUN		;Test for function reference
	jz	@F
	mov	ax,ER_DD		;It is an error to store into a
	call	SsError 		;function with arguments.
@@:
	DbAssertTst [bx].VAR_flags,nz,FVARRAY+FVFUN,SCAN,<Ss_AIdSt: Non-Array>

	call	cDimsAndIndex		;Check cDims, index into executor map
					;CX = scan stack oTyp of variable
	jcxz	NeedOtyp		;Is it a record?
HavOtyp:				
	call	CoerceIndices		;Also restores DS if SizeD
assumes ds,DATA				
	xchg	ax,cx			;AX = oTyp of target array
	call	EnsureArgType		;Pop stack frame test for coerce
	jmp	[ScanRet]

NeedOtyp:				
	mov	cx,[bx].VAR_oTyp	;Get real oTyp for coercion
	jmp	HavOtyp			

;*****************************************************************************

LdRedirect:
	mov	ax,[bx].VAR_Value	    ;Value field has new oVar
	mov	PTRTX[si+2],ax		    ;Replace old one in pcode
	jmp	short AIdLdRetry

SsProc	AIdLd,Rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	AIdLdRetry			    
	mov	dx,scanOFFSET mpALdImpOpExe	    
AIdLdRetry:					    
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si+2]		    

	DbChk	pVar,bx 			    ;Verify this is a variable

	;Check flags to see if we're really doing a load

	    mov     ax,[bx].VAR_flags	; Fetch flags
	    TestX   ax,FVREDIRECT	;Test for redirected variable
	    jnz     LdRedirect		;Go fix the redirected case
	    TestX   ax,FVFUN		;Test for function reference
	jnz	ExecFunc		;This is a function

	DbAssertTst [bx].VAR_flags,nz,FVARRAY,SCAN,<Ss_AIdLd: Non-Array>

	call	cDimsAndIndex		;Check cDims, index into executor map
	call	CoerceIndices		;Also restores DS if SizeD
assumes ds,DATA				
	or	ch,HIGH ST_ArrVar	;Indicate this is a var reference
	push	di			;oTx for coercion insertion
	push	cx			;oTyp of array element or ET_RC
	jmp	[ScanRet]

ExecFunc:
	mov	cx,PTRTX[si]		;Get count of args
	jmp	SsCallFunc

subttl	Subroutines for <AId|Id><|Off><Ld|St>
page

;cDimsAndIndex
;
;   Used by AId<Ld|St>
;   Check count of indices, then fall into SsIndexType
;
;Inputs:
;
;   dx = base of executor map
;   ds:bx = pVar
;   es:si = pointer to first operand (cDims)
;
;Exceptions:
;
;   Generate MSG_SubCnt if incorrect number of dimensions
;   Undefined Array if first ref as whole array


FirstReference:

	;It's ok to be undefined if this is a ReDim

	cmp	PTRTX[si+4],opStReDimTo 
	je	ArIndexType		


	    ;For QB4 this is the first ref to a previously undefined array.
	    ;Lets treat this as an implicit dim.  However, it is an error if
	    ;this is a whole array ref.

	    jcxz    ArrayNotDefined	; Brif whole array reference

	    test    byte ptr [bx].VAR_fStat,FV_STATIC	; Is this $Static
	    jz	    ArrayNotDefined	


	    cmp     [bx].ASTAT_ad.FHD_hData,0	;Allocated already?
	    jne     ArrayCmpCDims	;Brif yes.  Bypass allocation.

	    cmp     [SsErr],0		; Have any errors occured?
	    jne     ArrayCmpCDims	; Brif yes.  Bypass allocation.

	    push    cx			;Save CX = cDims
	    push    dx			;Save DX = Executor map

	    mov     [SsScanExStart],1	;Indicate implicit Dim
	    push    ax			;Dummy parameter
	    push    ax			;Dummy parameter
	    call    ExecuteFromScan	;Allocate array.  AX = RT error code.

	    pop     dx			;Restore DX = Executor map
	    pop     cx			;Restore CX = cDims

		mov	bx,[MrsCur.MRS_bdVar.BD_pb]
	    add     bx,PTRTX[si+2]	;BX = pVar

	    or	    ax,ax		;Was there an error?
	    jnz     ArrayError		;Brif error code <> 0

	    jmp     short ArrayCmpCDims 


ArrayNotDefined:
	mov	ax,ER_UA		; Array not defined

ArrayError:
	call	SsError 		
	jmp	short ArIndexType	

cDimsAndIndex:
	mov	cx,PTRTX[si]		; Get actual cDims
	and	ch,7fh			; Clear MSB which indicates no ()


	    mov     [f_StaticCalc],TRUE ;$Static array if this is first ref

	;There is a problem with ReDim where the FV_STATIC bit is being set
	;when the first array reference is a ReDim with constant indices.
	;This causes the SetArrayType call in Ss_ReDim to complain about
	;ReDim of a $Static array.  The resetting of f_StaticCalc is a
	;solution.  For EB, this is done above as a default.  For QB4, implicit
	;arrays are $Static and only if this is a ReDim is $Dynamic selected.

	cmp	PTRTX[si+4],opStReDimTo 
	jne	@F			
	shr	cx,1			; AIdLd in ReDim has cDims * 2

	    mov     [f_StaticCalc],FALSE;Dynamic array if this is first ref
@@:					

	call	SetArrayType		;CY set if first ref
	jc	FirstReference		; Brif this is first reference
	jcxz	ArIndexType		; Whole array ref. Bypass cDim chk.


ArrayCmpCDims:
	DbAssertRelB	ch,e,0,SCAN,<cDimsAndIndex: cDims GT 255>
	mov	ax,MSG_SubCnt
	cmp	cl,[bx].VAR_value.ASTAT_cDims	;Cmp cDims from variable table
	jne	ArrayError		;Correct no. of indices?

ArIndexType:

	;Look for special case of integer array with 1 dimension

	dec	cx			    ; One dimension?
	jnz	SsIndexType		    ;brif no
	mov	ax,[bx].VAR_flags	    ; Fetch flags
	    TestX   ax,FVCOMMON+FVFORMAL    ;Don't optimize these
	    jnz     SsIndexType
	and	ax,FV_TYP_MASK		    ;Mask flags down to oTyp
	.erre	ET_I2 EQ 1		    
	dec	ax			    ; I2?
	jnz	SsIndexType		    ;Brif no, only optimize I2s
	add	dx,A1SOffset		    ;Point to optimized executors

	;Note:	The constant A1SOffset represents the distance between the
	;executor map for static arrays and the map for one dimension
	;static arrays.  If this is a frame array we are optimizing, the
	;map address must be adjusted again to account for the different
	;seperation.

	    TestM   [bx].VAR_flags,FVVALUESTORED    
	    jnz     SsIndexType 	;Pointing to correct executor map
	add	dx,FrameOffset+A1FrameOffset	;Correct for later ISFC calc.
; fall into SsIndexType

;SsIndexType
;
;	Used by all <AId|Id|Off><Ld|St>
;	Compute index into executor map based on type
;	Executor map is organized as follows:
;		Record
;		I2
;		I4
;		R4	    Only if R4s enabled (FV_R4)
;		R8
;		CY	    Only if currency enabled (FV_CURRENCY)
;		SD
;		TX	    Only if text enabled (FV_TEXT)
;		FS
;		FT	    Only if text enabled (FV_TEXT)
;Inputs:
;	ds:bx = pVar
;	cs:dx = base of executor map
;Outputs:
;	cx = Scan stack type
;	cs:dx = modified executor map address
;Preserves:
;	ax,bx

	public	SsIndexType,SsIndexTypeCx
SsIndexType:
	mov	cl,[bx].VAR_flags
	and	cx,FV_TYP_MASK		;CX = oTyp
SsIndexTypeCx:
	cmp	cx,ET_MAX		;Record type?
	jbe	StdType
.errnz	ET_RC
	xor	cx,cx			;Replace oType with ET_RC
StdType:
	    jb	    IndexType		
	    mov     [SsOtxHeapMove],di	;FS/FT can cause heap movement
IndexType:
;Calculate offset due to type (cx)
	add	dx,cx
	add	dx,cx			;One word per type in table
	ret



;CoerceIndices
;
;   Used by AId<Ld|St>
;   Calls SsIndexISFC, copies oVar, then coerces array indices
;
;Inputs:
;
;   dx = current executor map address
;
;Preserves:
;
;   cx

CoerceIndices:
	call	SsIndexISFC		;Locate executor, emit and copy cDims
	MOVSWTX 			;Copy oVar

	;Coerce  array indices

	pop	[SsCbParmCur]		;Get return address out of the way
	mov	bx,cx			;Preserve cx in bx
	mov	cx,PTRTX[di-4]		;count of indices
	and	ch,7fh			;clear MSB when no parens listed
	mov	ax,ET_I2		;Target type for indices
        call    SsCoerceN               ;Coerce indices to I2
	mov	cx,bx			
	jmp	[SsCbParmCur]		;Return to caller

;SsIndexISFC
;
;	Used by <AId|Id><Ld|St>
;	Call SsGetISFC to index into executor map, then fetches and emits
;	executor and one operand
;Inputs:
;	bx = pVar
;	dx = current executor map address
;Preserves
;	cx

	public	SsIndexISFC		;Restores DS if necessary


SsIndexISFC:
	push	cx
	call	SsGetISFC		;Calculate <I|S|F|C> offset from
					;   bx (MSV flags) and oPrsCur
					;Offset returned as modified dx
	pop	cx

;SsEmitExecutor
;
;   Called by Off<Ld|St>, fallen into by all others
;   Fetches executor from map, emits and copies one operand
;
;Inputs:
;
;   dx = current executor map address
;
;Preserves:
;
;   cx

	public	SsEmitExecutor
SsEmitExecutor:
	mov	bx,dx
	mov	ax,WORD PTR cs:[bx]	;Load executor
	STOSWTX 			;Emit the executor
	MOVSWTX 			;Copy the operand
	ret

subttl	Executor map for AIdLd variants
page
;Table mpALdImpOpExe is a list of AIdLdImp executors.  The list is ordered
;as follows:
;	exAId<I|E><I|S|F|C>Ld<type>
;After the Ld executors is Rf excutors for numeric types only.
;
;This table is then followed by AIdLdExp executors.
;Type "0" is used by record executors (implicits only).


	;Optimized 1-dimension load

mpA1IdISLd	equ	$ - 2			
	DWEXT	exA1IdISLdI2

	;Additional types may be added here

mpA1IdIFLd	equ	$ - 2			
	DWEXT	exA1IdIFLdI2

A1FrameOffset	=   mpA1IdIFLd - mpA1IdISLd

	;Note:	The following word fills space used by MakeRef
	;before the explicit map to find the implicit map.

	DW	0				

	public	mpALdImpOpExe
mpALdImpOpExe	label	word			


A1SOffset   =	mpA1IdISLd - $			

mpAIdISLd	label	word			
	DWEXT	exAIdISRf
	DWEXT	exAIdISLd2
	DWEXT	exAIdISLd4
	DWEXT	exAIdISLdR4
	DWEXT	exAIdISLdR8			
	DWEXT	exAIdISRfSD
	DWEXT	exAIdISLdFS

cbContext   =	$ - mpAIdISLd

mpAIdICLd	label	word			
	DWEXT	exAIdICRf
	DWEXT	exAIdICLd2
	DWEXT	exAIdICLd4
	DWEXT	exAIdICLdR4
	DWEXT	exAIdICLdR8			
	DWEXT	exAIdICRfSD
	DWEXT	exAIdICLdFS
	.erre	cbContext EQ ($-mpAIdICLd)	

mpAIdIILd	label	word			
	DWEXT	exAIdIIRf
	DWEXT	exAIdIILd2
	DWEXT	exAIdIILd4
	DWEXT	exAIdIILdR4
	DWEXT	exAIdIILdR8			
	DWEXT	exAIdIIRfSD
	DWEXT	exAIdIILdFS
	.erre	cbContext EQ ($-mpAIdIILd)	

FrameOffset =	mpAIdISLd - $			

mpAIdIFLd	label	word			
	DWEXT	exAIdIFRf
	DWEXT	exAIdIFLd2
	DWEXT	exAIdIFLd4
	DWEXT	exAIdIFLdR4
	DWEXT	exAIdIFLdR8			
	DWEXT	exAIdIFRfSD
	DWEXT	exAIdIFLdFS
	.erre	cbContext EQ ($-mpAIdIFLd)	

	;AIdRfImp executor map

mpAIdIRf	label	word			


mpAIdISRf	equ	$-2			
	DWEXT	exAIdISRf
	DWEXT	exAIdISRf
	DWEXT	exAIdISRf
	DWEXT	exAIdISRf
	DWEXT	exAIdISRfSD
	DWEXT	exAIdISRfFS
	.erre	cbContext EQ ($-mpAIdISRf)	

mpAIdICRf	equ	$-2			
	DWEXT	exAIdICRf
	DWEXT	exAIdICRf
	DWEXT	exAIdICRf
	DWEXT	exAIdICRf
	DWEXT	exAIdICRfSD
	DWEXT	exAIdICRfFS
	.erre	cbContext EQ ($-mpAIdICRf)	

mpAIdIIRf	equ	$-2			
	DWEXT	exAIdIIRf
	DWEXT	exAIdIIRf
	DWEXT	exAIdIIRf
	DWEXT	exAIdIIRf
	DWEXT	exAIdIIRfSD
	DWEXT	exAIdIIRfFS
	.erre	cbContext EQ ($-mpAIdIIRf)	

mpAIdIFRf	equ	$-2			
	DWEXT	exAIdIFRf
	DWEXT	exAIdIFRf
	DWEXT	exAIdIFRf
	DWEXT	exAIdIFRf
	DWEXT	exAIdIFRfSD
	DWEXT	exAIdIFRfFS
	.erre	cbContext EQ ($-mpAIdIFRf)	

	;Function call executors

	DWFILL					
	DWEXT	exFuncNArgImp
	DWEXT	exFuncNArgImp
	DWEXT	exFuncNArgImp
	DWEXT	exFuncNArgImp
	DWEXT	exFuncNArgImp


	;Optimized 1-dimension load

mpA1IdESLd	equ	$ - 2			
	DWEXT	exA1IdESLdI2

mpA1IdEFLd	equ	$ - 2			
	DWEXT	exA1IdEFLdI2

	.erre	A1FrameOffset EQ (mpA1IdEFLd - mpA1IdESLd)

	;Note:	The following word is used by MakeRef to
	;find the implicit map from the explicit map.

	DW	mpALdImpOpExe			

	public	mpALdExpOpExe
mpALdExpOpExe	label	word			


	.erre	A1SOffset EQ (mpA1IdESLd - $)	

mpAIdESLd	label	word			
	DWFILL					
	DWEXT	exAIdESLdI2
	DWEXT	exAIdESLdI4
	DWEXT	exAIdESLdR4
	DWEXT	exAIdESLdR8
	DWEXT	exAIdESRfSD
	DWEXT	exAIdESLdFS
	.erre	cbContext EQ ($-mpAIdESLd)	

mpAIdECLd	label	word			
	DWFILL					
	DWEXT	exAIdECLdI2
	DWEXT	exAIdECLdI4
	DWEXT	exAIdECLdR4
	DWEXT	exAIdECLdR8
	DWEXT	exAIdECRfSD
	DWEXT	exAIdECLdFS
	.erre	cbContext EQ ($-mpAIdECLd)	

mpAIdEILd	label	word			
	DWFILL					
	DWEXT	exAIdEILdI2
	DWEXT	exAIdEILdI4
	DWEXT	exAIdEILdR4
	DWEXT	exAIdEILdR8
	DWEXT	exAIdEIRfSD
	DWEXT	exAIdEILdFS
	.erre	cbContext EQ ($-mpAIdEILd)	

	.erre	FrameOffset EQ (mpAIdESLd - $)	

mpAIdEFLd	label	word			
	DWFILL					
	DWEXT	exAIdEFLdI2
	DWEXT	exAIdEFLdI4
	DWEXT	exAIdEFLdR4
	DWEXT	exAIdEFLdR8
	DWEXT	exAIdEFRfSD
	DWEXT	exAIdEFLdFS
	.erre	cbContext EQ ($-mpAIdEFLd)	

	;AIdRfExp executor map


mpAIdESRf	equ	$-2			
	DWEXT	exAIdESRfI2
	DWEXT	exAIdESRfI4
	DWEXT	exAIdESRfR4
	DWEXT	exAIdESRfR8
	DWEXT	exAIdESRfSD
	DWEXT	exAIdESRfFS
	.erre	cbContext EQ ($-mpAIdESRf)	

mpAIdECRf	equ	$-2			
	DWEXT	exAIdECRfI2
	DWEXT	exAIdECRfI4
	DWEXT	exAIdECRfR4
	DWEXT	exAIdECRfR8
	DWEXT	exAIdECRfSD
	DWEXT	exAIdECRfFS
	.erre	cbContext EQ ($-mpAIdECRf)	

mpAIdEIRf	equ	$-2			
	DWEXT	exAIdEIRfI2
	DWEXT	exAIdEIRfI4
	DWEXT	exAIdEIRfR4
	DWEXT	exAIdEIRfR8
	DWEXT	exAIdEIRfSD
	DWEXT	exAIdEIRfFS
	.erre	cbContext EQ ($-mpAIdEIRf)	

mpAIdEFRf	equ	$-2			
	DWEXT	exAIdEFRfI2
	DWEXT	exAIdEFRfI4
	DWEXT	exAIdEFRfR4
	DWEXT	exAIdEFRfR8
	DWEXT	exAIdEFRfSD
	DWEXT	exAIdEFRfFS
	.erre	cbContext EQ ($-mpAIdEFRf)	

	;Function call executors

	DWFILL					
	DWEXT	exFuncNArgI2
	DWEXT	exFuncNArgI4
	DWEXT	exFuncNArgR4
	DWEXT	exFuncNArgR8
	DWEXT	exFuncNArgSD


;Table mpAStImpOpExe is a list of AIdStImp executors.  The list is ordered
;as follows:
;	exAId<I|E><I|S|F|C>St<type>
;This table is then followed by AIdStExp executors.
;Type "0" entries are used for record executors (implicit types only).

	;Optimized 1-dimension store

mpA1IdISSt	equ	$ - 2			
	DWEXT	exA1IdISStI2

mpA1IdIFSt	equ	$ - 2			
	DWEXT	exA1IdIFStI2

	.erre	A1FrameOffset EQ (mpA1IdIFSt - mpA1IdISSt)

	;Note:	The following word fills space used by MakeRef
	;before the explicit map to find the implicit map.

	DW	0				

	public	mpAStImpOpExe
mpAStImpOpExe	label	word


	.erre	A1SOffset EQ (mpA1IdISSt - $)	

mpAIdISSt	label	word			
	DWEXT	exAIdISStTyp
	DWEXT	exAIdISSt2
	DWEXT	exAIdISSt4
	DWEXT	exAIdISStR4
	DWEXT	exAIdISStR8			
	DWEXT	exAIdISStSD
	DWEXT	exAIdISStFS
	.erre	cbContext EQ ($-mpAIdISSt)	

mpAIdICSt	label	word			
	DWEXT	exAIdICStTyp
	DWEXT	exAIdICSt2
	DWEXT	exAIdICSt4
	DWEXT	exAIdICStR4
	DWEXT	exAIdICStR8			
	DWEXT	exAIdICStSD
	DWEXT	exAIdICStFS
	.erre	cbContext EQ ($-mpAIdICSt)	

mpAIdIISt	label	word			
	DWEXT	exAIdIIStTyp
	DWEXT	exAIdIISt2
	DWEXT	exAIdIISt4
	DWEXT	exAIdIIStR4
	DWEXT	exAIdIIStR8			
	DWEXT	exAIdIIStSD
	DWEXT	exAIdIIStFS
	.erre	cbContext EQ ($-mpAIdIISt)	

	.erre	FrameOffset EQ (mpAIdISSt - $)	

mpAIdIFSt	label	word			
	DWEXT	exAIdIFStTyp
	DWEXT	exAIdIFSt2
	DWEXT	exAIdIFSt4
	DWEXT	exAIdIFStR4
	DWEXT	exAIdIFStR8			
	DWEXT	exAIdIFStSD
	DWEXT	exAIdIFStFS
	.erre	cbContext EQ ($-mpAIdIFSt)	


	;Optimized 1-dimension store

mpA1IdESSt	equ	$ - 2			
	DWEXT	exA1IdESStI2

mpA1IdEFSt	equ	$ - 2			
	DWEXT	exA1IdEFStI2

	.erre	A1FrameOffset EQ (mpA1IdEFSt - mpA1IdESSt)

	;Note:	The following word fills space used by MakeRef
	;before the explicit map to find the implicit map.

	DW	0				

	public	mpAStExpOpExe
mpAStExpOpExe	label	word


	.erre	A1SOffset EQ (mpA1IdESSt - $)	

mpAIdESSt	label	word			
	DWFILL					
	DWEXT	exAIdESStI2
	DWEXT	exAIdESStI4
	DWEXT	exAIdESStR4
	DWEXT	exAIdESStR8
	DWEXT	exAIdESStSD
	DWEXT	exAIdESStFS
	.erre	cbContext EQ ($-mpAIdESSt)	

mpAIdECSt	label	word			
	DWFILL					
	DWEXT	exAIdECStI2
	DWEXT	exAIdECStI4
	DWEXT	exAIdECStR4
	DWEXT	exAIdECStR8
	DWEXT	exAIdECStSD
	DWEXT	exAIdECStFS
	.erre	cbContext EQ ($-mpAIdECSt)	

mpAIdEISt	label	word			
	DWFILL					
	DWEXT	exAIdEIStI2
	DWEXT	exAIdEIStI4
	DWEXT	exAIdEIStR4
	DWEXT	exAIdEIStR8
	DWEXT	exAIdEIStSD
	DWEXT	exAIdEIStFS
	.erre	cbContext EQ ($-mpAIdEISt)	

	.erre	FrameOffset EQ (mpAIdESSt - $)	

mpAIdEFSt	label	word			
	DWFILL					
	DWEXT	exAIdEFStI2
	DWEXT	exAIdEFStI4
	DWEXT	exAIdEFStR4
	DWEXT	exAIdEFStR8
	DWEXT	exAIdEFStSD
	DWEXT	exAIdEFStFS
	.erre	cbContext EQ ($-mpAIdEFSt)	

	;AdRf executor map

	public	mpAdRf				
mpAdRf	label	word				
	DWEXT	exAdRfImp			
	DWEXT	exAdRfI2			
	DWEXT	exAdRfI4			
	DWEXT	exAdRfR4
	DWEXT	exAdRfR8			
	DWEXT	exAdRfSD			

	page
;***
;MakeArrayRef
;
;Purpose:
;
;   This procedure converts an exAIdLd with cArgs == 0 to an exAdRf.
;
;Input:
;
;   BX = oTx from scan stack of pointer after exAIdLd
;
;Output:
;
;   standard exit
;
;Preserves
;
;   BX, CX, DX
;
;***************************************************************************

	public	MakeArrayRef
MakeArrayRef	proc

	mov	ax,PTRTX[bx-6]		;AX = exAIdLd executor
	xchg	ax,bx			;AX = oTx, BX = executor
	GetCodeIntoDs	SCAN		
	mov     bl,byte ptr [bx-1]	;Get HIGH byte of opcode
	push	ss			
	pop     ds

	.erre	OPCODE_MASK EQ 03ffh
;	and	bx,HIGH (NOT OPCODE_MASK)
	and	bx,0FCh 		;Mask off garbage leaving oTyp * 4
	shr	bx,1			;Convert to word offset
	mov	bx,mpAdRf[bx]		;BX = AdRf executor
	xchg	ax,bx			;AX = executor, BX = oTx
	mov	PTRTX[bx-6],ax
	ret

MakeArrayRef	endp

	page
;***
;Ss_Erase
;
;Purpose:
;
;   Scan Erase statement.
;
;   AIdLd scanning has left a stack entry consisting of:
;	oType
;	oTx of point after AIdLd
;
;Parsed state opcode format:
;
;   (AIdLd,...) opStErase(cnt)
;
;      The cnt argument represents the number of preceeding AIdLd opcodes
;   each of which will have left an entry on the stack.
;
;Input:
;
;   opStErase operand has count of AIdLd arguments.
;
;Output:
;
;   standard exit
;
;***************************************************************************

SsProc	Erase
	STOSWTX 			;Emit executor
	LODSWTX 			;Load operand count
	STOSWTX 			;And emit it
	xchg	cx,ax			;CX = operand count
EraseLoop:
	pop	bx			;Discard oType
	pop	bx			;BX = oTx after exAIdLd
	call	MakeArrayRef		;Convert to exAdRf
	loop	EraseLoop		;Go process next array
	jmp	[ScanRet]		; and back to the main loop

	page
;***
;Ss_LUbound - scan LBOUND and UBOUND
;
;Purpose:
;
;   Scan opFn<L|U>bound<1|2>
;
;   Scan stack contains:
;	I2 (for op<L|U>Bound2 case)
;	AIdLd entry:
;	    oType
;	    oTx of point after AIdLd (location of exFn<L|U>Bound<1|2>)
;
;Parsed state opcode format:
;
;   (AIdLd)	 opFn<L|U>bound1
;   (AIdLd,Nexp) opFn<L|U>bound2
;
;Input:
;
;   standard entry
;
;Output:
;
;   standard exit
;
;***************************************************************************

SsProc	LUBound2
	mov	ax,ET_I2		;Index must be I2
	call	EnsureArgType		;Perform the coercion as required
	xchg	ax,dx			
	SKIP2_PSW			; Skip over descan routine address
SsProc	LUBound1			
	STOSWTX
	pop	bx			;Discard oType
	pop	bx			;BX = oTx after exAIdLd
	push	di			;Push oTx of result for coercion
	PushI	ax,ET_I2		;Push oTyp of result. Always I2
FixNoDimArray:
	call	MakeArrayRef		;Convert to exAdRf
	jmp	[ScanRet]		; and back to the main loop

	page
;***
;Ss_GPutGet,PaletteUsing
;
;Purpose:
;
;   Scan graphics PUT, GET and PALETTE USING
;
;Parsed state opcode format:
;
;   (I2exp,...,AIdLd)	opStPalletteUsing
;   (I2exp,...,AIdLd)	opStGraphicsGet
;   (I2exp,...,AIdLd)	opStGraphicsPut(function)
;
;Input:
;
;   standard entry
;
;Output:
;
;   standard exit
;
;***************************************************************************


SsProc	PaletteUsing
	mov	dl,ET_I4		;Max type for PALETTE USING
	jmp	short PutGetUsing

SsProc	GPutGet
	mov	dl,ET_MaxNum		; Max type for PUT/GET
PutGetUsing:
	call	EmitExCopyOps		;Emit executor, copy operands for PUT
	pop	cx			; Get oTyp
	or	cl,cl
	jz	TMErr			;If not simple type, always wrong
	cmp	cl,dl			;Test for valid array type (numeric)
	jbe	PutGetX
TMErr:
	mov	ax,ER_TM		;Type mismatch error
	call	SsError
PutGetX:
	pop	bx			;BX = oTx of insertion point
	cmp	byte ptr es:[bx-4],0	;Is cDims == 0
	je	FixNoDimArray		;Brif yes, convert to AdRf
	xchg	ax,cx			;AX = oTyp w/Flags
	call	MakeRef 		;AX = AIdRf executor
	mov	PTRTX[bx-6],ax		;Update emitted code
	jmp	[ScanRet]		; and back to the main loop


sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssfor.asm ===
page	49,132
TITLE	ssfor	- scan support for For/Next
;***
;ssfor.asm
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Scan For/Next.
;
;	For executors utilize a For block that is allocated by the scanner.
;	The allocation is from the frame.
;
;	For opcode variants are:
;	  (IdLd,exp,exp[,exp]) opStFor<Step|> (UNDEFINED,UNDEFINED)
;
;	For executor variants are:
;	  (IdRf,exp,exp[,exp]) exStFor<Step|><I2|I4|R4|R8|CY> (oFrame,oTxNext)
;
;	where:
;
;	oFrame	   is the offset to the For block, which contains step and limit
;	oTxNext    is the oTx of the oTx operand of the Next associated with
;		   this For.  The For executor uses this oTx to branch to the
;		   Next executor to do the limit test for the first iteration.
;
;	Next opcode variants are:
;	   ([IdLd|]) opStNext<Id|> (UNDEFINED,UNDEFINED)
;
;	where:
;	<Id|>	indicates whether the user labeled the Next.
;
;	The statement:
;	Next i,j,k
;	maps to several opStNextId opcodes.
;
;	The Next executor variants are:
;	   (IdRf) exStNext<Id|><Step|><I2|I4|R4|R8|CY>
;
;	The IdLd's of both For and Next are converted to IdRf.
;	The scanner supplies the IdRf in the case that the Next is a
;	opStNext.  However, this Id is not listed and is removed at descan.
;
;	Not all executor variants are unique.  For example, the R8 variant
;	of For supplies a Step of 1 if the user does not so specify.  There
;	need be no Step versions of R8 Next.
;
;Exceptions:
;	Errors detected during For/Next scanning are:
;	- Nesting errors (For without Next and Next without For).
;	- Variable type errors (SD or user data types, arrays, or
;	  array elements
;
;For to Next binding:
;			+------------------------+
;			|			 V
;	exStFor (oFrame,oTx) ... exStNext (oFrame,oTx)
;			    ^			   |
;			    +----------------------+
;
;
;****************************************************************************

	.xlist
	include 	version.inc
	IncludeOnce	context
	IncludeOnce	qbimsgs
	IncludeOnce	scanner
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list

assumes ds, DATA
assumes es, NOTHING
assumes ss, DATA
assumes cs, SCAN

sBegin	SCAN
subttl	For
page
;***
;Ss_For - Scan For statement
;Purpose:
;
;   Scan For statement.  The following tasks are performed:
;	1. Make a For scan stack entry - each item is a word:
;	    For identifier flags
;		STYP_For
;		STYP_Step
;	    oTx of For statement
;	    oTx for start of EXIT For chain (initially UNDEFINED)
;	    oTx of exIdRf opcode
;	    oTyp of For index
;
;	2. Convert IdLd to IdRf.  Coerce step, limit, and initial value
;	   to the type of the index variable.
;
;	3. Map and emit the executor
;	   Executor calculation involves these factors:
;	    1. opcode to exe map For this opcode
;	       From mpOpExe
;	    2. Direct mode or main level code
;	       From grsCur
;	    3. Data type of index variable
;	       From Ld stack entry
;	    4. Whether Step is present.
;	       From RULE table index
;
;***************************************************************************
.erre	low STYP_Step	;The following code and PEROPCOD.TXT assume that the
			;STYP_Step bit is one of the bits in the low byte.
			;This flag is obtained from mpOpRule where it is set
			;as <low STYP_Step> and the mpOpRule byte is loaded into
			;the low byte below.
SsProc	For,Rude
;Calculate STYP_Step for this For
	push	bp			; Set up local frame pointer to ease
	mov	bp,sp			;	access to index variable oTyp
	shr	bx,1
	test	mpOpRule[bx],STYP_Step	; Step clause present?
	jz	NoStep			; Brif no step clause
	mov	ax,[bp+14]		; Get oTyp of index (Record = ET_RC)
	mov	cx,3			; Coerce three values
	jmp	short CoerceFor		

NoStep:					
	mov	ax,[bp+10]		; Get oTyp of index (Record = ET_RC)
	mov	cx,2			; Coerce two values
CoerceFor:				
	pop	bp			; Restore BP.  Discard frame pointer.
	.erre	ST_Typ_Mask EQ 0ffh	; Assure CBW is sufficient
	.erre	ET_MAX LT 80h		; Assure CBW is sufficient
	cbw				; Clear flags in scan stack
	call	SsCoerceN		

	xor	ch,ch
	mov	cl,mpOpRule[bx] 	;cx now has correct value for STYP_Step
	shl	bx,1			;Back to opcode * 2
	mov	dx,bx			; Save in dx
;Obtain the IdLd executor address, check type of For index.
	pop	ax			; oTyp of For index (Record=ET_RC)
	pop	bx			; oTx of For index
	push	ax
	call	MakeRef 		;Convert IdLd to IdRf
	pop	ax			;Get type back
	and	ax,ST_Typ_Mask		; Map to ET_type
	.erre	ET_RC EQ 0		; Assure JZ is sufficient
	jz	ForTypeBad		; For index is a record
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_MaxNum		; Numeric type?
	jbe	ForTypeOK		
ForTypeBad:				
	mov	al,ET_I2		; Leave a valid type
ForTypeOK:
	push	ax			;FRAME gets type
	push	bx			; FRAME gets IdRf executor oTx

;Begin mapping to executor
	dec	ax
	shl	ax,1			;AX = zero relative word offset
	mov	bx,dx			; opcode*2 back to bx
	mov	bx,mpOpExe[bx]		;Address of executor map
	add	bx,ax			;Address of executor for this For
	mov	ax,word ptr cs:[bx]	;Load ...
	STOSWTX 			;... and emit the executor
	MOVSWTX 			;Copy current For block offset

.errnz	UNDEFINED - 0FFFFH
	mov	dx,UNDEFINED		;Get an UNDEFINED to push as the
					; EXIT For link head
	push	dx			;FRAME gets initial EXIT For link
	push	di			;FRAME gets address of oTx for this For
	or	cx,STYP_For		;cx = scan frame identifier
	push	cx			;FRAME gets frame identifier
	MOVSWTX				;Skip over oTx operand
	jmp	[ScanRet]		; and back to the scan loop


subttl	ForBlockAlloc - allocate the For block
page

;***
;ForBlockAlloc - allocate the For block
;Purpose:
;	For/Next executors require a For block to store limit and Step.
;	This block is allocated when scanning For.
;
;	The block is allocated from the current frame (the same as
;	frame space for dynamic variables).
;
;	A For may be scanned several times during the course of user program
;	development.  For blocks may be active during user edition.  For
;	block allocation supports CONT by utilizing the currently allocated
;	block for the For if one exists.
;
;Input:
;	cx = STYP_Step
;	dx = data type of For
;
;Output:
;	ax = new For block offset
;Preserves:
;	bx,cx,dx
;***************************************************************************
ForBlockAlloc:
;Calculate bytes required for this For block
	mov	ax,dx
	call	CbTypOTypSCAN		; bytes for data type
	cmp	dx,ET_I2		;Only I2 can have no Step
	jnz	ForStepCom		;  as For supplies Step for other types
	test	cl,STYP_Step		;Is Step present?
	jz	ForNoStepCom		;No Step, so ax = For block size
ForStepCom:
	shl	ax,1			;Times 2 for Step
ForNoStepCom:
;ax = bytes for For block
	test	byte ptr [grs.GRS_oRsCur+1],80H	;Module or procedure level?
	jnz	ProcLevel
	add	ax,mrsCur.MRS_cbFrameVars	;Get current top of frame
	mov	mrsCur.MRS_cbFrameVars,ax	;Put back new top of frame
	jmp	short MakeOBP

ProcLevel:
;Allocate the For block from the frame of the current procedure.
	add	ax,prsCur.PRS_cbFrameVars	;Get current top of frame
	mov	prsCur.PRS_cbFrameVars,ax	;Put back new top of frame
MakeOBP:
	neg	ax				;oBP
	ret

subttl	For Opcode to Executor maps
page
public	mStForOpExe
mStForOpExe:
	DWEXT exStForI2
	DWEXT exStForI4
	DWEXT exStForR4
	DWEXT exStForR8

public	mStForStepOpExe
mStForStepOpExe:
	DWEXT exStForStepI2
	DWEXT exStForStepI4
	DWEXT exStForStepR4
	DWEXT exStForStepR8

subttl	Next
page
;***
;Ss_Next, Ss_NextId
;Purpose:
;	Scan For/Next.
;
;	Next opcode variants are:
;	   ([IdLd|]) opStNext<Id|> (UNDEFINED,UNDEFINED)
;
;	where:
;	<Id|>	indicates whether the user labeled the Next.
;
;	The statement:
;	Next i,j,k
;	maps to several opStNextId opcodes.
;
;	The Next executor variants are:
;	   (IdRf) exStNext<Id|><Step|><I2|I4|R4|R8|CY>
;
;	The scanner supplies the IdRf in the case that the Next is a
;	opStNext.  However, this Id is not listed and is removed at descan.
;	Bit 0 of the oBP field is set if the IdRf was not inserted (due
;	to out-of-memory or a previous error).
;
;	Not all executor variants are unique.  For example, the R8 variant
;	of For supplies a Step of 1 if the user does not so specify.  There
;	need be only a Step versions of R8 Next.
;
;	For blocks are allocated at Next scan time.  If the For already
;	has a valid oBP (i.e., not -1), then it is used.  Otherwise,
;	if the Next has a valid oBP, it is used.  If neither are valid,
;	then a new oBP is allocated and CantCont is set.  This method allows
;	either a For or Next (but not both) to be edited and still retain
;	their previous For block.
;
;	However, a previous For block can only be used if its type and size
;	have not changed.  This can only happen when the For is edited, not
;	the Next.  In order to tell, the oText field of the Next is set at
;	descan time to have the oTyp and the Step flag.  (Step only matters for
;	I2, where a step of 1 uses a separate executor instead of a word in
;	the For block.)
;
;For to Next binding:
;			+------------------------+
;			|			 V
;	exStFor (oFrame,oTx) ... exStNext (oFrame,oTx)
;			    ^			   |
;			    +----------------------+
;
;Scan time tasks include:
;	1. Detect nesting error (Next w/o For)
;	2. Change IdLd to IdRf, or insert IdRf if not an Id variant of Next.
;	3. Calculate and emit the executor
;	   Factors include:
;		<Id|>		separate executor map
;				(mStNextOpExe or mStNextIdOpExe)
;		type		from scan stack entry/previous IdRf
;		<Step|> 	from scan stack entry and type
;	4. Link For to Next and Next to For
;
;	([IdLd|]) opStNext<Id|> (UNDEFINED,UNDEFINED)
;	(IdRf) exStNext<Id|><Step|><I2|I4|R4|R8|CY>
;Input:
;	Standard Scanner dispatch entrypoint
;	[SP] =	For stack frame
;		For identifier flags
;			STYP_For
;			STYP_Step
;		oTx of For statement
;		oTx for EXIT For chain start
;		For block allocation
;		oTx of exIdLd executor
;		oTyp of for index
;Output:
;
;Exceptions:
;	Errors detected during Next scanning are:
;	- Nesting errors (Next without For).
;
;*******************************************************************
SsProc	NextId,Rude
;Make the preceding IdLd an IdRf
	xchg	cx,ax			;Save executor map in cx
	pop	ax			;Get oTyp of index (Record = ET_RC)
	pop	bx			;IdLd operand address + 2
	call	MakeRef 		;Convert IdLd to IdRf
	mov	ax,PTRTX[bx-2]		; Fetch operand

;Frame the stack for easy For entry referencing
	push	bp
	mov	bp,sp
	push	cx			;Save executor map
	mov	cx,6			;Bind EXIT For beyond the Next executor
	call	BindExitFor		;Find For entry on stack, binding EXITs
	jz	NextWOForErrNoFrame	;For entry not found - error

;Check for compatible IdRf between For and Next
	mov	bx,[bp+2].FFor_oTxIdRf	;oTx of IdRf executor
	sub	ax,PTRTX[bx-2]		; Same operand (variable)?
	jz	NextCom 		;Next matches For - cont through Ss_Next

NextWOForErr:
	pop	bx			;Get executor map
	call	NextErrorCommon
	jmp	Unframe

NextErrorCommon:
	mov	ax,ER_NF		;Next without For error
	call	SsError
	mov	ax,word ptr cs:[bx]	;Get any old executor
	STOSWTX				;And emit it
	mov	ax,-1
	STOSWTX				;Indicate no oBP
	STOSWTX 			;Flag Next without IdRf
	add	si,4			;Skip oBP and oTx in source
	ret

NextWOForErrNoFrame:			;No For Frame to tear down
	pop	bx			;Get executor map
	call	NextErrorCommon
	pop	bp
	jmp	[ScanRet]


SsProc	Next,Rude
;Frame stack for easy reference
	push	bp
	mov	bp,sp
	push	ax			;Save executor map

;Get For stack entry
	mov	cx,10			;bind EXIT For past IdRf executor and
					;Next executor
	call	BindExitFor		;Find For entry on stack, binding EXITs
	jz	NextWOForErrNoFrame	;For entry not found - error

;Emit IdRf
	mov	bx,[bp+2].FFor_oTxIdRf	;Get the IdRf executor address
	mov	ax,PTRTX[bx-4]		;Load the IdRf executor
	mov	cx,PTRTX[bx-2]		;Load the IdRf operand
	mov	bx,di			;Insert at emit oTx
	call	Insert1Op
	mov	al,1			;Set flag that no IdRf is present
	jc	NextCom
	dec	al			;Success, so zero al

;Calculate and emit the executor
;	bp+2 = pointer to For frame
;	al = 1 if Next with no Id and insertion of Id failed, else 0
;
;Uses:
;	type from the For frame
;	flags from For frame to distinguish between
;		<Step|> 	from scan stack entry and type
;	map on top of stack (distinguishes between exStNext and exStNextId)
NextCom:
	pop	bx			;Executor map
	push	ax
	mov	dx,[bp+2].FFor_oTyp	;For/Next type
	dec	dx			;Zero relative for indexing
	shl	dx,1			;To word offset
	test	[bp+2].FFor_Id,STYP_Step	;<Step|> variant differentiation
	jz	NextGotStepInfo 	;Not Step
	inc	dx			;Offset compensation for Step variants
NextGotStepInfo:
	shl	dx,1
	add	bx,dx			;bx = cs relative Next executor offset
	mov	ax,word ptr cs:[bx]	;ax = executor
	STOSWTX 			;Emit the executor

;Emit the frame offset for this Next
	mov	bx,[bp+2].FFor_oTx	;For oTx operand address
	mov	ax,PTRTX[bx-2]		;Get oBP from For
	cmp	ax,-1			;Valid?
	jnz	SetOBp
;See if Next has a valid oBP
	mov	cx,[bp+2].FFor_Id	;Step flag
	mov	dx,[bp+2].FFor_oTyp	;   and oTyp needed to allocate a block
	mov	ax,PTRTX[si]		;Get Next oBP
	inc	ax			;Valid?
	jz	NewForBlock
	dec	ax			;Restored oBP
	cmp	dl,es:[si+2]		;Has For type changed?
	jnz	NewForBlock
	cmp	dx,ET_I2		;I2 may or may not have step
	jnz	SetOBp
.errnz	HIGH STYP_Step			;Verify Step flag in low byte
	mov	ch,cl			;Copy Step flag
	xor	ch,es:[si+3]		;Step flag match?
	test	ch,STYP_Step
	jz	SetOBp
NewForBlock:
	call	ForBlockAlloc
;New For block means can't continue if it's in an active procedure or module
	push	ax
	push	bx
	mov	bx,dataOffset b$CurFrame
	PUSH_ES 			
	cCall	ActiveORs_Frame,<bx>	; See if frame on stack
	POP_ES
	or	ax,ax			
	jnz	Active			; brif frame is (probably) active

	mov	ax,[grs.GRS_oRsCONT]	
	cmp	ax,[grs.GRS_oRsCur]	; Is current one active?
	jnz	StillCont
Active:
	or	[SsFlags],SSF_CantCont	;Call CantCont at end of scan
StillCont:
	pop	bx
	pop	ax
SetOBp:
	STOSWTX 			;Set For block oBP in Next
	mov	PTRTX[bx-2],ax		;Set oBP in For

;Link For to Next and Next to For
	mov	PTRTX[bx],di		;Link For to Next oTx operand address
	mov	ax,bx
	inc	ax
	inc	ax			;Move to address beyond For operand
	pop	bx			;Get IdRf flag
	or	al,bl			;Set bit 0 if no IdRf was inserted
	STOSWTX 			;Link Next to executor after For
	add	si,4			;Skip source pointer over operands

Unframe:
;Now unframe the stack, pop the For frame, and exit
	pop	bp
	add	sp,SIZE FFor		;Size of For stack frame entry
	jmp	[ScanRet]		; and back to main loop

subttl	Next Opcode to Executor maps
page
public	mStNextOpExe
mStNextOpExe:
	DWEXT exStNextI2
	DWEXT exStNextStepI2
	DWEXT exStNextStepI4
	DWEXT exStNextStepI4
	DWEXT exStNextStepR4
	DWEXT exStNextStepR4
	DWEXT exStNextStepR8
	DWEXT exStNextStepR8

public	mStNextIdOpExe
mStNextIdOpExe:
	DWEXT exStNextIdI2
	DWEXT exStNextIdStepI2
	DWEXT exStNextIdStepI4
	DWEXT exStNextIdStepI4
	DWEXT exStNextIdStepR4
	DWEXT exStNextIdStepR4
	DWEXT exStNextIdStepR8
	DWEXT exStNextIdStepR8

subttl	EXIT For Support
page
;***
;Ss_Exit
;Purpose:
;	Scan EXIT For and EXIT DO.
;
;	These cases are handled by building a linked list of EXIT
;	entries in the associated For or DO stack frame.  These
;	entries will be bound at Next / DO time, when the opcode
;	that closes the block is bound.  For example, EXIT For is
;	bound at Next.
;
;	Ss_Exit ensures that there is a stack entry to match the
;	current block type that is reachable from the context of the
;	EXIT.  This requires walking frames back on the stack until
;	The appropriate control structure is found, or until the end
;	of the stack is encountered.  There is no stack entry type
;	that would cause the search to stop other than finding the
;	base of the scan stack.
;
;	The rule table index byte contains the bits for the current
;	EXIT structure type.
;
;	The mpOpExe table word carries the executor for the EXIT.
;
;	There is no other required context.
;
;Input:
;	Standard scanner dispatch.
;Output:
;	Standard scanner exit.
;***************************************************************************

;The following is an error as the bit must be in the specified byte
; as placed in PEROPCOD.TXT
.erre	low STYP_Step

SsProc	Exit
;Fetch EXIT type
	STOSWTX 			;Emit the executor
	LODSWTX 			;Skip over operand in source
	shr	bx,1			;bx = opcode (byte offset to mpOpRule)
	xor	ax,ax
	mov	ah,mpOpRule[bx] 	;Load rule byte for this For
					;ax now has correct value for STYP_For
	call	FindFrame		;Find frame type ax
	xchg	ax,cx			;cx = frame type
	jnz	ScopeOK 		;Frame type found
	mov	ax,MSG_ExitDo		;assume it's a DO frame
	cmp	cx,STYP_Do		;is it a DO?
	jz	SsExitErr		;brif so, issue error
	mov	ax,MSG_ExitScope	;EXIT not within For/Next
SsExitErr:
	call	SsError
ScopeOK:
;assert that Exit chains are at same frame offset for For and DO
.errnz	FFor_oTxExit - FDO_oTxExit

	mov	ax,[bx].FFor_oTxExit	;link this exit into the Exit chain
	mov	[bx].FFor_oTxExit,di	;new start of list is this EXIT For
	STOSWTX 			;store previous start in pcode.
	jmp	[ScanRet]		; and on to next opcode

page
;BindExitFor - bind stack entries back to For
;Purpose:
;	Look at the last scan stack frame to determine if it is a For.
;	If not a For, then a nesting error has occurred.
;
;	If a For entry is found, then bind the EXIT For list to the
;	pcode location of the opcode after the current Next.
;
;Input:
;	bp = frame of For entry (if present)
;	cx = offset from current emit address (di) for end of this Next
;
;Output:
;	PSW.Z if For block not found
;
;Preserves:
;	ax,dx

BindExitFor:
	push	ax
	test	[bp+2].FFor_Id,STYP_For ;Is it a For entry?
	jz	BindNoForErr		;No For found

;Bind EXIT For
	add	cx,di			;Address of opcode past Next
	mov	bx,[bp+2].FFor_oTxExit	;Load head pointer of EXIT list
	call	BindExit		;Jmp to common code to bind Exit chains
	or	sp,sp			;PSW.NZ
BindNoForErr:
	pop	ax
	ret

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssdo.asm ===
page	49,132
TITLE	ssdo - scan support for DO/WHILE related opcodes
;***
;ssdocase.asm
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Scan DO/LOOP, and WHILE/WEND statement opcodes.
;
;   Runtime behavior of LOOP opcodes:
;   ---------------------------------
;      <exp> opStDoWhile(oText)     - branch to oText if exp is zero (false)
;      <exp> opStWhile(oText)	    - branch to oText if exp is zero (false)
;      <exp> opStDoUntil(oText)     - branch to oText if exp is non-zero (true)
;      opStLoop(oText)		    - unconditionally branch to oText
;      opStWend(oText)		    - unconditionally branch to oText
;      opStDo			    - nop
;      <exp> opStLoopWhile(oText)   - branch to oText if exp is non-zero (true)
;      <exp> opStLoopUntil(oText)   - branch to oText if ext is zero (false)
;      <exp> opStExitDo(oText)	    - unconditionally branch to oText
;
;   DO [WHILE | UNTIL]/LOOP and WHILE/WEND statement syntax to pcode mappings:
;   --------------------------------------------------------------------------
;
;      Syntax:	DO WHILE <exp> ... LOOP
;   
;					  +-----------------+
;      Pcode:	opBol | <exp> opStDoWhile(|) ... opStLoop(|)|
;		      +-----------------------------------+
;
;      ============================================================
;      Syntax:	WHILE <exp> ... WEND
;   
;					+-----------------+
;      Pcode:	opBol | <exp> opStWhile(|) ... opStWend(|)|
;		      +---------------------------------+
;
;      Note: WHILE/WEND and DO WHILE/LOOP have different opcodes for
;	     listability, but are functionally equivilent.  They both
;	     map to the same runtime executors for size reduction.
;
;      ============================================================
;      Syntax:	DO UNTIL <exp> ... LOOP
;   
;					  +-----------------+
;      Pcode:	opBol | <exp> opStDoUntil(|) ... opStLoop(|)|
;		      +-----------------------------------+
;
;   DO/LOOP [WHILE | UNTIL] statement syntax to pcode mappings:
;   -----------------------------------------------------------
;
;      Syntax:	DO ... LOOP WHILE <exp>
;   
;
;      Pcode:	opStDo| ... <exp> opStLoopWhile(|)
;		      +-------------------------+
;
;      ============================================================
;      Syntax:	DO ... LOOP UNTIL <exp>
;   
;
;      Pcode:	opStDo| ... <exp> opStLoopUntil(|)
;		      +-------------------------+
;
;      ============================================================
;      Syntax:	EXIT DO
;   
;      Pcode:	opStExitDo(otext) to beyond opStLoop*
;
;      Note the scan routine for EXIT DO is the same as EXIT FOR and is
;      in ssfor.asm.
;
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	.list

assumes ds, DATA
assumes es, NOTHING
assumes ss, DATA
assumes cs, SCAN

sBegin	SCAN
subttl	Static data area definitons.
page
;***
;Ss_Do, Ss_DoLoop, Ss_While
;Purpose:
;	Scan entries for DO, DO WHILE, DO UNTIL, and WHILE.
;
;	Scan tasks for DO WHILE, DO UNTIL, and WHILE include:
;	- ensuring the entry type is a fundamental, non string data type.
;	- selecting the DO executor varient for the argument data type.
;	- pushing a DO/WHILE frame on the scan stack as follows:
;		push  oTx of DO operand
;		push  oTx of opcode after opBol for return branch from LOOP/WEND
;		push  DO frame label (identifying DO WHILE, DO UNTIL, WHILE)
;
;	Scan tasks for DO
;	- push a DO frame on the scan stack as follows:
;		push junk
;		push oTx of opCode after DO for return branch
;		push DO frame label
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************
SsProc	While				;WHILE entry point
	mov	dh,high STYP_While	;Specify a WHILE frame
	jmp	short DoLoopCom

SsProc	DoLoop				;DO WHILE, and DO UNTIL scan
	mov	dh,high STYP_Do 	;Specify a DO frame
DoLoopCom:
	pop	ax			;Get oTyp of last expression
	pop	cx			;Discard coercion point (None used)
	push	bx			;Save opcode * 2
	cCall	MapOpToExeNumeric	;Type explode the executor
	STOSWTX 			;Emit the executor
	pop	bx
	shr	bx,1			;bx = opcode (byte offset to mpOpRule)
	mov	dl,mpOpRule[bx] 	;dl = Do varient
	mov	bx,[SsOTxStart] 	; BX = oTx after BOS
	mov	ax,di			;di = oTx of exit branch
	jmp	short SsDoCom

SsProc	Do				;DO scan
	STOSWTX 			;Emit the executor
	mov	bx,di
	mov	ax,UNDEFINED		;No initial exit branch
	mov	dx,STYP_Do		;just a plain old DO frame
SsDoCom:
	push	ax			;Push head of exit branch chain
	push	bx			;Push return branch oTx
	push	dx			;Push frame type
	cmp	dx,STYP_Do		;is this a DO...LOOP?
	jz	SsDoSkip		;brif so, no operand to emit
	mov	ax,UNDEFINED		;UNDEFINED will terminate Exit chain
	STOSWTX 			;emit Exit chain terminator
	inc	si
	inc	si			;skip source operand
SsDoSkip:
	jmp	[ScanRet]

	page
;***
;Ss_LoopWhile, Ss_Loop
;Purpose:
;	Scan entries for LOOP WHILE, LOOP UNTIL, LOOP, and WEND.
;
;	Scan tasks for LOOP WHILE and LOOP UNTIL include:
;	- ensure the entry type is a fundamental, non string data type.
;	- emit the LOOP executor varient for the argument data type.
;	- pop DO frame, check errors
;	  + DO nesting error if top frame is not a DO
;	  + DO nesting error if frame is DO WHILE, DO UNTIL
;	- bind LOOP to DO
;	- bind EXIT DO chain to end of LOOP
;
;	Scan tasks for LOOP and WEND
;	- emit executor
;	- pop DO/WHILE frame, check errors
;	  + nesting error if top frame is not a matching DO/WHILE
;	  + DO nesting error if frame is plain DO
;	- bind LOOP to DO opBol
;	- bind EXIT DO chain and DO operand to end of LOOP
;
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************
SsProc	LoopWhile
	pop	ax			;Get oTyp of last expression
	pop	cx			;Discard coercion point (None used)
	push	bx
	cCall	MapOpToExeNumeric	;Type explode the executor
	pop	bx
	jmp	short LoopCom

SsProc	Wend
	mov	dh,high STYP_While	;need to look for a While stack entry
	jmp	short WendCom

SsProc	Loop
LoopCom:
	mov	dh,high STYP_Do 	;need to find a DO on the stack
WendCom:
	STOSWTX 			;Emit the executor
	shr	bx,1			;bx = opcode (byte offset to mpOpRule)
	mov	dl,mpOpRule[bx] 	;dx = Do varient
	pop	ax			;ax = frame type

	mov	cx,MSG_Loop		;assume a LOOP w/o DO error
	cmp	dh,ah			;is this a matching DO/WHILE frame?
	jne	LoopError		;brif not - scoping error
	cmp	dh,high STYP_While	;is this a WHILE/WEND match?
	je	LoopScopeOk		;brif so - scope ok

	mov	dh,dl
	or	dh,al
	jz	LoopScopeOk		;have a DO -> LOOP
	jpe	LoopErrMsg		;scope error - either
					;DO WHILE -> LOOP UNTIL, or
					;DO UNTIL -> LOOP WHILE
	cmp	dl,al			;is this DO WHILE -> LOOP WHILE,
					;or DO UNTIL -> LOOP UNTIL?
	je	LoopErrMsg		;brif so - scope error

LoopScopeOk:
	pop	ax			;oTx for Loop branch
	STOSWTX 			;bind LOOP to DO
	inc	si
	inc	si			;skip over operand in source
	pop	bx			;oTx of DO [WHILE|UNTIL],WHILE operand
	call	BindExitCur		;bind all loop EXIT paths

LoopExit:
	jmp	[ScanRet]

LoopError:
	cmp	dh,high STYP_Do 	;is this a LOOP without DO?
	jz	LoopErrMsg		;brif so
	mov	cx,ER_WE		;WEND without WHILE
LoopErrMsg:
	push	ax			;put back frame type on stack
	xchg	ax,cx
	call	SsError
	MOVSWTX 			;skip operand
	jmp	short LoopExit		;exit

subttl	Opcode to executor maps for Do
page
public mStWhileOpExe
mStWhileOpExe:
	DWEXT exStI2While
	DWEXT exStI4While
	DWEXT exStR8While
	DWEXT exStR8While

public mStDoWhileOpExe
mStDoWhileOpExe:
	DWEXT exStDoI2While
	DWEXT exStDoI4While
	DWEXT exStDoR8While
	DWEXT exStDoR8While

public	mStDoUntilOpExe
mStDoUntilOpExe:
	DWEXT exStDoI2Until
	DWEXT exStDoI4Until
	DWEXT exStDoR8Until
	DWEXT exStDoR8Until

public mStLoopWhileOpExe
mStLoopWhileOpExe:
	DWEXT exStLoopI2While
	DWEXT exStLoopI4While
	DWEXT exStLoopR8While
	DWEXT exStLoopR8While

public	mStLoopUntilOpExe
mStLoopUntilOpExe:
	DWEXT exStLoopI2Until
	DWEXT exStLoopI4Until
	DWEXT exStLoopR8Until
	DWEXT exStLoopR8Until

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\sscase.asm ===
page	49,132
TITLE	sscase - scan support for SELECT/CASE related opcodes
;***
;sscase.asm
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Scan SELECT CASE statement opcodes.
;
;   Runtime behavior of SELECT CASE executors:
;   ------------------------------------------
;	<exp> exStSelectCase<2|4|8> (oText)
;	      - Push an additional copy of <exp> on the stack
;		and unconditionally branch to oText.
;
;	<exp> <exp1> exStCase<Lt|Le|Eq|Ge|Gt|Ne|><I2|I4|R4|R8|CY|SD|TX>
;	      - Evaluates and consumes top two expressions on stack
;		and emits TRUE or FALSE on stack based upon result.
;		These executors share code with the MathOp executors,
;		except for the SD variants which will not cause
;		the <exp> SD to be released if it was a temp.
;
;	<exp> <exp1> <exp2> exStCaseTo<I2|I4|R4|R8|CY|SD|TX>
;	      - Evaluates <exp> and determines if it falls within
;		the range defined by <exp1> and <exp2>.  All three
;		expressions are consumed, and a TRUE or FALSE is
;		emitted to the stack based on the result of the
;		evaluation.
;
;	<exp> exCaseBranch<2|4|8|SD> (oTextF, oTextT)
;	      - Branches to oTextF or oTextT based on TRUE or FALSE
;		condition on stack.  Before taking a false branch, an
;		additional copy of the exStSelectCase expression is
;		placed on the stack. Before taking a TRUE branch, the
;		saved copy of the exStSelectCase exp is consumed and
;		deallocated if it is a string temp. This is non-listable
;		and inserted by the scanner.
;
;	exStCaseElse<2|4|8|SD>
;	      - Consume copy of exStSelectCase exp and deallocate if it
;		is a string temp.
;
;	exStEndSelect
;	      - Consume copy of exStSelectCase exp and deallocate if it
;		is a string temp.
;
;	exBranch (oText)
;	      - Unconditionally branch to oText.  This is non-listable
;		and inserted by the scanner at the beginning of each
;		line containing an exStCase* executor.
;
;
;   SELECT CASE/END SELECT statement syntax to pcode mappings:
;   ----------------------------------------------------------
;
;      Syntax:	SELECT CASE <exp>
;
;      Pcode:	<exSelexp> opStSelectCase(oTx to <exp> before first CASE)
;
;      ============================================================
;      Syntax:	CASE [IS <relop>] <const>
;
;      Pcode:	[opBol] <const> opStCase[<relop>]
;
;				 +-to beyond END SELECT
;				 |
;      Bound:	[exBol exBranch(oTx)] <const> exStCase[<relop>]<type>
;		exCaseBranch<type>(oTxF, oTxT)
;				    |	  |
;				    |	  +-To next exBol
;				    |
;				    +-To next CASE,ELSE CASE,or END SELECT
;
;      NOTE: The scanner inserts the non-listable exBranch and exStCaseBranch
;	     pcodes.
;
;      ============================================================
;      Syntax:	CASE IS <const> TO <const>
;
;      Pcode:	[opBol] <const> <const> opStCaseTo
;
;				 +-to beyond END SELECT
;				 |
;      Bound:	[exBol exBranch(oTx)] <const> <const> exStCaseTo<type>
;		exCaseBranch<type>(oTxF, oTxT)
;				    |	  |
;				    |	  +-To next exBol
;				    |
;				    +-To next CASE,ELSE CASE,or END SELECT
;
;      NOTE: The scanner inserts the non-listable exBranch and exStCaseBranch
;	     pcodes.
;
;      ============================================================
;      Syntax:	CASE ELSE
;
;      Pcode:	opBol opStCaseElse
;
;      ============================================================
;      Syntax:	END SELECT
;
;      Pcode:	opBol opStEndSelect
;
;
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	.list

assumes ds, DATA
assumes es, NOTHING
assumes ss, DATA
assumes cs, SCAN

sBegin	SCAN

	subttl	SELECT scan support.
	page
;***
;Ss_Select
;Purpose:
;	Scan entries for SELECT.
;
;	Scan tasks for SELECT include:
;	- ensuring the entry type is a fundamental data type.
;	- selecting the SELECT executor varient for the argument data type.
;	- pushing a SELECT CASE frame on the scan stack as follows:
;		push  oTx of SELECT operand for oTxFalse branch
;		push  UNDEFINED for start of oTxTrue chain
;		push  UNDEFINED for start of exBranch chain
;		push  oTyp of Select expression
;		push  CASE frame label
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************

SsProc	Select
	pop	ax		;Get oTyp of select expression (Record = ET_RC)

	if	ET_MaxStr NE ET_MAX	; Something defined beyond ET_Fx
	    .erre   ST_Typ_Mask EQ 0ffh ; Assure we can use AL
	    cmp     al,ET_MaxStr	
	    jbe     @F			
	    .erre   ET_RC EQ 0		; Assure XOR is sufficient
	    xor     ax,ax		; Treat as if a record
@@:					
	endif				; ET_MaxStr NE ET_MAX
	and	ax,ST_Typ_Mask		
	.erre	ET_RC EQ 0		; Assure JNZ is sufficient
	jnz	@F			
	call	TMError 		
	inc	ax			; Force valid type (ET_I2)
@@:					
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_FS		
	jb	@F			

	    .erre   ET_FS EQ ET_MaxStr	;[1]
	    .erre   ET_SD EQ ET_FS-1	; Assure difference is 1
	    dec     ax			; Map fixed to non-fixed types
@@:					
	push	ax			; Save for later but clear flags
	call	MapEmitExe		;Map and emit executor
	pop	ax			;oTyp of Select expression
	pop	cx			;Throw away exp address
	push	di			;FCASE_oTxFalse

	; initially bind FALSE branch to after this executor in case of
	; multiple case items on a single line.

	MOVSWTX 		;skip operand for SELECT
	mov	PTRTX[di-2],di	;bind operand to next executor
	mov	cx,UNDEFINED
	push	cx		;start of FCASE_oTxTrue chain
	push	cx		;start of FCASE_oTxBranch chain
	push	ax		;FCASE_oTyp of select expression
	PUSHI	ax,STYP_Case	;FCASE_Id - SELECT CASE frame identifier
	or	[SsFlags],SSF_StSelect ;We need to verify no executable
				;statements come before nexe CASE, CASE ELSE,
				;or END SELECT
	jmp	[ScanRet]

subttl	CASE item scan support.
page
;***
;Ss_Case, Ss_CaseTo, Ss_CaseElse
;Purpose:
;	Scan entries for CASE [IS <relop>] const, CASE IS const TO const,
;	and CASE ELSE.
;
;	Scan tasks for CASE and CASE TO include:
;	- ensuring correct CASE item nesting.
;	- coercing arguments to SELECT CASE expression oTyp.
;	- selecting the CASE item executor variant.
;	- If this is first CASE item after BOS
;	  +  Insert an exBranch after BOS
;	  +  link exBranch operand into exBranch chain.
;	  +  binding previous CASE item (SELECT CASE) false branch.
;	     This is only necessary for the BOS case, The false
;	     branch is initially bound to the immediately following executor.
;	- Insert exCaseBranch variant with two operands.
;	- link True branch operand into oTxTrue branch chain.
;	- set oTxFalse branch to False branch operand and bind operand to next
;	  executor.
;	- set CaseItem processed flag
;
;	Note:  The exBranch operand chain is bound at END SELECT.  The
;	exCaseBranch chain is bound at BOS.
;
;	Scan tasks for CASE ELSE include:
;	- ensuring correct CASE item nesting.
;	- selecting the CASE ELSE executor variant.
;	- If this is first CASE item after BOS
;	  +  Insert an exBranch after BOS
;	  +  link exBranch operand into exBranch chain.
;	  +  binding previous CASE item (SELECT CASE) false branch.
;	     This is only necessary for the BOS case, The false
;	     branch is initially bound to the immediately following executor.
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************
SsProc	CaseElse
	xor	bx,bx			;no expressions on stack
	mov	cx,bx			;this is a CASE ELSE varient
	jmp	short CaseCommon

SsProc	CaseTo
	mov	bx,2*(SIZE FEXP)	;we have 2 expressions on the stack
	mov	cl,STYP_CaseTo		;this is a CASE TO Varient
	jmp	short CaseCommon

SsProc	Case
	mov	bx,SIZE FEXP		;we have 1 expression on the stack for CASE
	mov	cl,STYP_CaseRel 	;normal CASE varient

CaseCommon:
	add	bx,sp			;point past expressions on stack to Select frame
	cmp	[bx].FCASE_Id,STYP_Case ;is this a select case frame?
	jnz	CaseScopeError		;brif not
	mov	ax,[bx].FCASE_oTyp	;get oTyp of SELECT expression
	DbAssertRel ax,be,ET_MAX,SCAN,<CaseCommon: Invalid oTyp>  
	jcxz	NoCoerce		;brif CASE ELSE, no coersion of operands

	cmp	cl,STYP_CaseRel 	;is this a standard CASE?
	je	Coerce1Op		;brif so, only one op to coerce
	call	EnsureArgType		;coerce the arg to the requested type

Coerce1Op:
	call	EnsureArgType		;coerce the arg

NoCoerce:
	push	cx			;preserve CASE type
	push	bx			;preserve frame ptr
	call	MapEmitExe		;map and emit Case executor varient
	pop	bx			;recover frame ptr
	pop	cx
	call	InsertCaseBranches	;insert exBranches/exCaseBranches
CaseX:
	jmp	[ScanRet]

CaseScopeError:
	mov	sp,bx			;eat the stack expressions
	mov	ax,MSG_Case		;Case without Select error
CaseErrorExit:				
	call	SsError
	mov	ax,ET_I2		;emit I2 varient...
	call	MapEmitExe		;...of executor...
	jmp	short CaseX		;...and return

subttl	END SELECT scan support.
page
;***
;Ss_EndSelect
;Purpose:
;	Scan entry END SELECT.
;
;	Scan tasks for END SELECT include:
;	- emitting the END SELECT executor.
;	- ensuring correct SELECT nesting.
;	- If this is item after BOS
;	  +  Insert an exBranch after BOS
;	  +  link exBranch operand into exBranch chain.
;	  +  binding previous CASE item (SELECT CASE) false branch.
;	     This is only necessary for the BOS case, The false
;	     branch is initially bound to the immediately following executor.
;	- Bind the exBranch chain.
;	- remove the SELECT CASE frame.
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************
SsProc	EndSelect
	xor	cx,cx			; Rule table byte is 0
	mov	bx,sp			;set up frame ptr
	cmp	[bx].FCASE_Id,STYP_Case ;is this a select case frame?
	mov	ax,MSG_EndSelect	
	jnz	CaseErrorExit		; Brif not a select case
	mov	ax,[bx].FCASE_oTyp	; AX = oTyp of Select expression
	call	MapEmitExe		; Emit executor
	mov	bx,sp			; Restore frame pointer
	xor	cx,cx			;looks like CASE ELSE varient
	call	InsertCaseBranches	;insert exBranch before BOS for previous
					;true branch
	mov	bx,[bx].FCASE_oTxBranch ;start of exBranch chain
	call	BindExitCur		;bind list of address to current emit address
	add	sp,SIZE FCASE		;pop off Case frame
	jmp	[ScanRet]

subttl	SELECT CASE helpers
page
;***
;InsertCaseBranches - insert exBranch and exCaseBranch varients
;
;Purpose:
;	Inserts an exBranch after BOS if this is first SELECT CASE item
;	called since last BOS was processed, and binds the preceding false
;	branch after the inserted exBranch. Also inserts exCaseBranch
;	varients for CASE and CASE TO executors.
;
;	Checks to see if a Select Case without any intervening CASE*, or
;	END SELECT statements have been scanned.  If this is true, then
;	the pcode from the preceding SELECT statement is scanned to
;	ensure that only REMs and BOS/BOL opcodes are present.	If not,
;	then an Expected Case error is generated.
;Input:
;	bx = CASE frame ptr
;	cx = CASE varient (STYP_CaseTo, STYP_CaseRel, or 0 for CASE ELSE/END
;		SELECT.
;Output:
;	none.
;Preserves:
;	bx
;****************************************************************************
InsertCaseBranches:

	test	[SsFlags],SSF_StSelect ;was a select processed last?
	jz	CheckBosBranch	;brif not, continue

	and	[SsFlags],NOT SSF_StSelect ;reset SELECT processed flag
	mov	ax,[bx].FCASE_oTxFalse ;get oTx of SELECT CASE operand
	dec	ax
	dec	ax		;backup to Select opcode and start with next.
	PUSH_ES 		
	push	bx		
	push	cx		
	cCall	TxtChkValidOpsExec,<ax,SsoTxBos> ;check for valid ops between
				;end of SELECT CASE and start of Cur statement.
	pop	cx		
	pop	bx		
	POP_ES			
	or	dx,dx		
	jz	CheckBosBranch	;brif opcodes ok

	push	bx		;save frame ptr
	xchg	ax,bx		;set error address returned by TxtChkValidOps
	mov	ax,MSG_ExpectedCase ;issue Expected CASE error
	call	SsErrorBx	;remember error
	pop	bx		;recover source address

CheckBosBranch:
	test	[SsBosFlags],SSBOSF_StCase ;has a case item been processed since BOS?
	jnz	NoInsertBranch	;brif so, exBranch has already been inserted.

	push	cx		;save Case varient
	push	bx		;preserve frame ptr
	mov	cx,[bx].FCASE_oTxBranch ;ptr to start of exBranch chain
	call	InsertBranchBos ;insert exBranch after BOS; BX = oTx after BOS
	xchg	ax,bx		;...exbranch chain for block if
	pop	bx		;recover frame ptr
	pop	cx		;recover case varient
	jc	NoBranchInserted
	dec	ax
	dec	ax		;point to operand for exBranch
	mov	[bx].FCASE_oTxBranch,ax ;update new Branch chain start
	inc	ax
	inc	ax		;point to op after exBranch operand
NoBranchInserted:
	push	bx		;save frame ptr
	mov	bx,[bx].FCASE_oTxFalse ;get ptr to preceding false operand
	inc	bx
	jz	NoFalseBranchBind ;brif no operand to fix up
	dec	bx
	mov	PTRTX[BX],ax	;bind preceding false branch to this CASE op.

NoFalseBranchBind:
	pop	bx		;recover frame ptr

NoInsertBranch:
	mov	[bx].FCASE_oTxFalse,UNDEFINED ;previous false branch has been bound
	jcxz	NoInsertCaseBranch	;don't insert CaseBranch for CASE ELSE

	mov	cx,6			;we need to insert 6 bytes
	mov	bx,[bx].FCASE_oTyp	;get type variant
	dec	bx			;make type zero relative
	shl	bx,1			;and a word index
	mov	ax,WORD PTR cs:mCaseBranch[bx]	;get case branch executor variant
	mov	bx,di			;insert at current position
	call	InsertCx		;insert the executor, bx = oTx after insertion
	jc	NoInsertCaseBranch	;brif if out of memory

	sub	bx,4			;backup to caseBranch oTxFalse operand
	mov	PTRTX[bx],di		;initially bind false branch to next executor
	xchg	ax,bx			;ax = oTx of false operand
	mov	bx,sp			;recover frame ptr
	inc	bx
	inc	bx			;adjust for return address
	mov	[bx].FCASE_oTxFalse,ax	;save ptr to False branch operand in case we
					;need to patch it later
	inc	ax
	inc	ax			;advance to True branch operand
	mov	cx,[bx].FCASE_oTxTrue	;link True branch into true branch chain
	xchg	ax,bx
	mov	PTRTX[bx],cx
	xchg	ax,bx
	mov	[bx].FCASE_oTxTrue,ax
	or	[SsBosFlags],SSBOSF_StCase ;we have binding to do at next BOS
	mov	[SsOTxStart],di 	; Mark clear stack location

NoInsertCaseBranch:
	ret

	page
;***
;MapEmitExe - type explode and emit executor, then return
;
;Purpose:
;
;   Type explode and emit the executor.
;
;Input:
;
;   ax = expression oTyp
;   dx = executor map address
;
;Output:
;
;   none.
;
;****************************************************************************

MapEmitExe:
	dec	ax			;To zero relative
	add	ax,ax			;Convert to word offset
	add	ax,dx			;Offset into executor map
	xchg	ax,bx
	mov	ax,word ptr cs:[bx]	;Executor address
	STOSWTX 			;Emit executor
	ret

	subttl	CASE opcode to executor map tables

	public	mStSelect		;SELECT CASE executors
mStSelect:
	DWEXT	exStSelectCase2 		
	DWEXT	exStSelectCase4 		
	DWEXT	exStSelectCaseR8
	DWEXT	exStSelectCaseR8 		
	DWEXT	exStSelectCase2

	public	mCaseBranch		;Case branch inserted by scanner
mCaseBranch:
	DWEXT	exCaseBranch2			
	DWEXT	exCaseBranch4			
	DWEXT	exCaseBranchR8
	DWEXT	exCaseBranchR8			
	DWEXT	exCaseBranchSD

public mStCaseElse		;CASE ELSE executors
mStCaseElse:
	DWEXT	exStCaseElse2
	DWEXT	exStCaseElse4			
	DWEXT	exStCaseElseR8
	DWEXT	exStCaseElseR8			
	DWEXT	exStCaseElseSD

public mStCaseTo		;CASE IS <const> TO <const> executors
mStCaseTo:
	DWEXT	exStCaseToI2
	DWEXT	exStCaseToI4
	DWEXT	exStCaseToR8
	DWEXT	exStCaseToR8
	DWEXT	exStCaseToSD

public mStCase			;CASE <const> executors
mStCase:
	DWEXT	exStCaseI2
	DWEXT	exStCaseI4
	DWEXT	exStCaseR8
	DWEXT	exStCaseR8
	DWEXT	exStCaseSD

public mStCaseEq		;CASE IS = <const> executors
mStCaseEq:
	DWEXT	exStCaseEqI2
	DWEXT	exStCaseEqI4
	DWEXT	exStCaseEqR8
	DWEXT	exStCaseEqR8
	DWEXT	exStCaseEqSD

public mStCaseNe		;CASE IS <> <const> executors
mStCaseNe:
	DWEXT	exStCaseNeI2
	DWEXT	exStCaseNeI4
	DWEXT	exStCaseNeR8
	DWEXT	exStCaseNeR8
	DWEXT	exStCaseNeSD

public mStCaseLt		;CASE IS < <const> executors
mStCaseLt:
	DWEXT	exStCaseLtI2
	DWEXT	exStCaseLtI4
	DWEXT	exStCaseLtR8
	DWEXT	exStCaseLtR8
	DWEXT	exStCaseLtSD

public mStCaseLe		;CASE IS <= <const> executors
mStCaseLe:
	DWEXT	exStCaseLeI2
	DWEXT	exStCaseLeI4
	DWEXT	exStCaseLeR8
	DWEXT	exStCaseLeR8
	DWEXT	exStCaseLeSD

public mStCaseGt		;CASE IS > <const> executors
mStCaseGt:
	DWEXT	exStCaseGtI2
	DWEXT	exStCaseGtI4
	DWEXT	exStCaseGtR8
	DWEXT	exStCaseGtR8
	DWEXT	exStCaseGtSD

public mStCaseGe		;CASE IS >= <const> executors
mStCaseGe:
	DWEXT	exStCaseGeI2
	DWEXT	exStCaseGeI4
	DWEXT	exStCaseGeR8
	DWEXT	exStCaseGeR8
	DWEXT	exStCaseGeSD

public mStEndSelect		;End Select executors
mStEndSelect:
	DWEXT	exStEndSelect2			
	DWEXT	exStEndSelect4			
	DWEXT	exStEndSelectR8
	DWEXT	exStEndSelectR8			
	DWEXT	exStEndSelectSD 		

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssid.asm ===
page	49,132
	TITLE	ssid	- Scan support for simple Id opcodes
;***
;ssid.asm - Scan support for simple Id opcodes
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains the scanner dispatch routines for simple id opcodes.
;   These routines perform all tasks related to moving simple id opcodes from
;   one scan state to another.
;
;   Scan routines for IdLd opcodes make a stack entry that describes the
;   type and location of the id in the scanned pcode.  The scan stack
;   entry appears as:
;
;	push oTx  - emitted pcode address of byte following id
;		     (address at which coercion would be inserted)
;	push oTyp - type of expression or ET_RC for records
;
;   See scanner.inc for a complete definition of the id stack entry.  The
;   oTyp word contains constants that uniquely distinguish variable
;   references, literals and intermediate expression values.
;
;   Routines named Ss_<name> are dispatched by a jmp.  These routines
;   all return to the scan loop by an indirect jmp through variable scanret.
;
;
;****************************************************************************

	.xlist
	include		version.inc
SSID_ASM = ON
	IncludeOnce	context
	IncludeOnce	opid
	IncludeOnce	pcode		
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list


assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA


sBegin	SCAN
assumes cs, SCAN

subttl	Ss_IdLd
page
;***
;Ss_IdLd	Scan Ld variants of simple Id opcodes
;Purpose:
;
;   Scan the id variants opIdLd<type>.
;
;Algorithm:
;
;   Load opcode data type from the variable table
;   Calculate offset for <I|S|F|C> based on oPrsCur and variable table flags
;   Load and emit executor
;   Copy operand
;   Push stack entry
;      operand address + 2
;      type (with origin bits set)
;   Return to main loop
;
;Input:
;
;   es:si = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;Exceptions:
;	Ss_Error
;
;******************************************************************
page
LdRedirect:
	    mov     ax,[bx].VAR_Value		    ;Value field has new oVar
	    mov     PTRTX[si],ax		    ;Replace old one
	    jmp     short IdLdRetry

SsProc	IdLd,Rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	IdLdRetry			    
	mov	dx,scanOFFSET mpLdImpOpExe	    
IdLdRetry:					    
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si]		    
	DbChk	pVar,bx 			    ;Verify this is a variable

	;Check flags to see if we're really doing a load

	or	WORD PTR [bx].VAR_Flags,FV_STATICSET	; Note that we've seen it
	mov	ax,[bx].VAR_Flags		; Fetch flags
	    TestX   ax,FVREDIRECT		;Test for redirected variable
	    jnz     LdRedirect			;Go fix the redirected case
	    xor     ax,FVFUN+FVVALUESTORED
	    TestX   ax,FVFUN+FVVALUESTORED	;Test for function call
	jz	ExecFunc		;This is a function call
	call	SsIndexType		;DX = Executor address based on oTyp
					;CX = oTyp of variable
	TestX	ax,FVCONST		;Loading a constant?
	jnz	ConstLoad
	or	ch,HIGH ST_SimpVar	;Indicate the stack item is a var ref.
ScanTypeSet:
	call	SsIndexISFC		;Index by ISFC. Restores DS if SizeD
assumes ds,DATA				

ScanStack:
;Make stack entry
	push	di			;oTx for coercion insertion
	push	cx			;oTyp of variable or ET_RC
	jmp	[ScanRet]

ConstLoad:
	.errnz	LOW ST_LitX		; Assure we can use CH
	or	ch,HIGH ST_LitX		;Constant same as literal w/operand
	jmp	ScanTypeSet

ExecFunc:
	xor	cx,cx			;No operands
	jmp	SsCallFunc


subttl	Executor map for IdLd variants
page
;Table mpLdImpOpExe is a list of IdLdImp executors.  The list is ordered
;as follows:
;	exIdLd<I|S|F|C><type>
;After the Ld executors is Rf excutors for numeric & FS types only.
;
;This table is then followed by IdLdExp executors.
;Type "0" is used by record executors (implicits only).

	public	mpLdImpOpExe
mpLdImpOpExe	label	word			



mpIdISLd	label	word			
	DWEXT	exIdISRfTyp
	DWEXT	exIdISLd2
	DWEXT	exIdISLd4
	DWEXT	exIdISLdR4
	DWEXT	exIdISLdR8			
	DWEXT	exIdISLdSD			
	DWEXT	exIdISLdFS

cbContext   = $ - mpIdISLd		    ;Offset to next frame of executors

mpIdICLd	label	word			
	DWEXT	exIdICRfTyp
	DWEXT	exIdICLd2
	DWEXT	exIdICLd4
	DWEXT	exIdICLdR4
	DWEXT	exIdICLdR8			
	DWEXT	exIdICLdSD			
	DWEXT	exIdICLdFS
	.erre	cbContext EQ ($-mpIdICLd)	

mpIdIILd	label	word			
	DWEXT   exIdIIRfTyp
	DWEXT	exIdIILd2
	DWEXT	exIdIILd4
	DWEXT	exIdIILdR4
	DWEXT	exIdIILdR8			
	    DWEXT   exIdIFLd2			
	DWEXT	exIdIILdFS
	.erre	cbContext EQ ($-mpIdIILd)	

mpIdIFLd	label	word			
	DWEXT	exIdIFRfTyp
	DWEXT	exIdIFLd2
	DWEXT	exIdIFLd4
	DWEXT	exIdIFLdR4
	DWEXT	exIdIFLdR8			
	DWEXT	exIdIFLdSD			
	DWEXT	exIdIFLdFS
	.erre	cbContext EQ ($-mpIdIFLd)	

	;IdRfImp executor map

	public	IdLdtoRfMap
IdLdtoRfMap=	$-mpLdImpOpExe


mpIdISRf	label	word			
	DWEXT	exIdISRf
	DWEXT	exIdISRf
	DWEXT	exIdISRf
	DWEXT	exIdISRf
	    DWEXT   exIdISRf			
	DWEXT	exIdISRfFS
	.erre	cbContext EQ ($-mpIdISRf+2)	

mpIdICRf	label	word			
	DWEXT	exIdICRf
	DWEXT	exIdICRf
	DWEXT	exIdICRf
	DWEXT	exIdICRf
	    DWEXT   exIdICRf			
	DWEXT	exIdICRfFS
	.erre	cbContext EQ ($-mpIdICRf+2)	

;  The executors for loading two byte and four byte frame variables are
;  also used for referenced to indirect variables.  For a load of a frame
;  variable, the variable table contains the value which is pushed on the
;  stack.  For a reference to an indirect variable, the variable table
;  contains the address which is then pushed on the stack.  Since addresses
;  are either two or four bytes, only these entries serve two purposes.

mpIdIIRf	label	word			
	DWEXT	exIdIIRf
	DWEXT	exIdIIRf
	DWEXT	exIdIIRf
	DWEXT	exIdIIRf
	    DWEXT   exIdIFLd2			
	DWEXT	exIdIIRfFS
	.erre	cbContext EQ ($-mpIdIIRf+2)	

mpIdIFRf	label	word			
	DWEXT	exIdIFRf
	DWEXT	exIdIFRf
	DWEXT	exIdIFRf
	DWEXT	exIdIFRf
	    DWEXT   exIdIFRf			
	DWEXT	exIdIFRfFS
	.erre	cbContext EQ ($-mpIdIFRf+2)	

	;Function call executors

	public	IdLdtoFuncMap
IdLdtoFuncMap=	$-mpLdImpOpExe

	DWFILL					
	DWEXT	exFunc0ArgImp
	DWEXT	exFunc0ArgImp
	DWEXT	exFunc0ArgImp
	DWEXT	exFunc0ArgImp
	DWEXT	exFunc0ArgImp

	;Note:	The following word is used by MakeRef to
	;find the implicit map from the explicit map.

	DW	mpLdImpOpExe			

	public	mpLdExpOpExe
mpLdExpOpExe	label	word			;No record type


mpIdESLd	label	word			
	DWFILL
	DWEXT	exIdESLdI2
	DWEXT	exIdESLdI4
	DWEXT	exIdESLdR4
	DWEXT	exIdESLdR8
	DWEXT	exIdESLdSD
	DWEXT	exIdESLdFS
	.erre	cbContext EQ ($-mpIdESLd)	

mpIdECLd	label	word			
	DWFILL					
	DWEXT	exIdECLdI2
	DWEXT	exIdECLdI4
	DWEXT	exIdECLdR4
	DWEXT	exIdECLdR8
	DWEXT	exIdECLdSD
	DWEXT	exIdECLdFS
	.erre	cbContext EQ ($-mpIdECLd)	

mpIdEILd	label	word			
	DWFILL					
	DWEXT	exIdEILdI2
	DWEXT	exIdEILdI4
	DWEXT	exIdEILdR4
	DWEXT	exIdEILdR8
	DWEXT	exIdEIRfSD
	DWEXT	exIdEILdFS
	.erre	cbContext EQ ($-mpIdEILd)	

mpIdEFLd	label	word			
	DWFILL					
	DWEXT	exIdEFLdI2
	DWEXT	exIdEFLdI4
	DWEXT	exIdEFLdR4
	DWEXT	exIdEFLdR8
	DWEXT	exIdEFRfSD
	DWEXT	exIdEFLdFS
	.erre	cbContext EQ ($-mpIdEFLd)	

	;IdRfExp executor map

	.erre	IdLdtoRfMap EQ ($-mpLdExpOpExe) 


mpIdESRf	label	word			
	DWEXT	exIdESRfI2
	DWEXT	exIdESRfI4
	DWEXT	exIdESRfR4
	DWEXT	exIdESRfR8
	DWEXT	exIdESRfSD
	DWEXT	exIdESRfFS
	.erre	cbContext EQ ($-mpIdESRf+2)	

mpIdECRf	label	word			
	DWEXT	exIdECRfI2
	DWEXT	exIdECRfI4
	DWEXT	exIdECRfR4
	DWEXT	exIdECRfR8
	DWEXT	exIdECRfSD
	DWEXT	exIdECRfFS
	.erre	cbContext EQ ($-mpIdECRf+2)	

mpIdEIRf	label	word			
	DWEXT   exIdEIRfI2
	DWEXT   exIdEIRfI4
	DWEXT   exIdEIRfR4
	DWEXT	exIdEIRfR8
	DWEXT	exIdEIRfSD
	DWEXT	exIdEIRfFS
	.erre	cbContext EQ ($-mpIdEIRf+2)	

mpIdEFRf	label	word			
	DWEXT	exIdEFRfI2
	DWEXT	exIdEFRfI4
	DWEXT	exIdEFRfR4
	DWEXT	exIdEFRfR8
	DWEXT	exIdEFRfSD
	DWEXT	exIdEFRfFS
	.erre	cbContext EQ ($-mpIdEFRf+2)	

;Function call executors
	DWFILL					
	DWEXT	exFunc0ArgI2
	DWEXT	exFunc0ArgI4
	DWEXT	exFunc0ArgR4
	DWEXT	exFunc0ArgR8
	DWEXT	exFunc0ArgSD


subttl	Ss_IdSt
page
;***
;Ss_IdStExp, Ss_IdStImp	Scan St variants of simple Id opcodes
;Purpose:
;
;   Scan the id variants opIdSt<type>.
;
;   These routines expect only fundamental BAsiC data types.  User types
;   are handled by opIdRf variants followed by OpIdOffset opcodes.
;	
;Algorithm:
;	
;   Load exe map address
;   Load opcode data type from the variable table
;   Compare with type on stack, coerce if different
;   Calculate offset for <I|S|F|C> based on oPrsCur and variable table flags
;   Load and emit executor
;   Copy operand
;   Return to main loop
;
;Input:
;	es:si = pcode emission address
;Output:
;	si updated
;Modifies:
;Exceptions:
;	Ss_Error
;******************************************************************
page

StRedirect:
	    mov     ax,[bx].VAR_Value		    ;Value field has new oVar
	    mov     PTRTX[si],ax		    ;Replace old one
	    jmp     short IdStRetry

SsProc	IdSt,Rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	@F				    
	mov	dx,scanOFFSET mpStImpOpExe	    
@@:						    
	test	[SsFlags],SSF_ScanAndExec	    ;Storing a constant?
	jnz	StoreConst
IdStRetry:
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si]		    
	DbChk	pVar,bx 			    ;Verify this is a variable

	;Check flags to see if we're really doing a store

	or	WORD PTR [bx].VAR_Flags,FV_STATICSET ; Note that we've seen it
	mov	ax,[bx].VAR_Flags		; Fetch flags
	    TestX   ax,FVREDIRECT		;Test for redirected variable
	    jnz     StRedirect			;Go fix the redirected case
	    xor     ax,FVFUN+FVVALUESTORED
	    TestX   ax,FVFUN+FVVALUESTORED	;Test for function call
	jnz	IdStore 		    ;Either not function or not static

;Trying to store into function RetVal when not within function defintion
	mov	ax,ER_DD			;Duplicate definition
	call	SsError
IdStore:
	call	SsIndexType		;DX = Executor address based on oTyp
					;CX = scan stack oTyp of variable
	jcxz	NeedOtyp		;Is it a record?
HavOtyp:				
	call	SsIndexISFC		;Index by ISFC
assumes ds,DATA				
StoreCoerce:
	xchg	ax,cx			;AX = oTyp of assignment target
	call	EnsureArgType		;Check type and possibly insert coercion
	test	[SsBosFlags],SSBOSF_Const ;In a CONST statement?
	jz	IdStX
	mov	al,[SsExecTmp]
	mov	[SsExecFlag],al		;Restore OPA_fExecute flag
IdStX:
	jmp	[ScanRet]

NeedOtyp:				
	mov	cx,[bx].VAR_oTyp	;Get real oTyp for coercion
	jmp	HavOtyp			

StoreConst:
	mov	bl,byte ptr es:[si-1]   ; Get HIGH opcode
	.erre	OPCODE_MASK EQ 3ffh	
	shr	bl,1			
	shr	bl,1			;Align explicit type
	jnz	HavConstType		;If explicit, type is in bx
	pop	bx			;If implicit, get type from stack
	push	bx			;Restore oTyp on stack
HavConstType:
	xor	bh,bh
	mov	mkVar.MKVAR_oTyp,bx
	mov	ax,PTRTX[si]		;Get oNam
	mov	mkVar.MKVAR_oNam,ax
	or	mkVar.MKVAR_flags,FVI_LVAL+FVI_CONST	
	push	dx			;Save executor map
	call	MakeVariableFar 	
	GETSEGTXTCUR			
	pop	dx
	or	ax,ax			;Error?
	js	ConstErr
	mov	PTRTX[si],ax		;Set oVar
	mov	bx,si
	sub	bx,[SsCbTxExpand]	;Compute position in unscanned code
	sub	bx,[SsScanExStart]	;Relative beginning of this scan
	add	bx,[SsScanExSrc]	;Position in original text
	mov	PTRTX[bx],ax		;Set oVar in original source
	jmp	IdStRetry

ConstErr:
	call	SsError			;Save MakeVariable error code
	MOVSWTX				;Copy oNam field
	pop	ax
	pop	bx			;Pop off stack entry
	jmp	[ScanRet]


;Table mpStImpOpExe is a list of IdStImp executors.  The list is ordered
;as follows:
;	exIdSt<I|S|F|C><type>
;This table is then followed by IdStExp executors.
;Type "0" entries are used for record executors (implicit types only).

	public	mpStImpOpExe
mpStImpOpExe	label	word			


mpIdISSt	label	word			
	DWEXT	exIdISStTyp
	DWEXT	exIdISSt2
	DWEXT	exIdISSt4
	DWEXT	exIdISStR4
	DWEXT	exIdISStR8			
	DWEXT	exIdISStSD
	DWEXT	exIdISStFS
	.erre	cbContext EQ ($-mpIdISSt)	

mpIdICSt	label	word			
	DWEXT	exIdICStTyp
	DWEXT	exIdICSt2
	DWEXT	exIdICSt4
	DWEXT	exIdICStR4
	DWEXT	exIdICStR8			
	DWEXT	exIdICStSD
	DWEXT	exIdICStFS
	.erre	cbContext EQ ($-mpIdICSt)	

mpIdIISt	label	word			
	DWEXT	exIdIIStTyp
	DWEXT	exIdIISt2
	DWEXT	exIdIISt4
	DWEXT	exIdIIStR4
	DWEXT	exIdIIStR8			
	DWEXT	exIdIIStSD
	DWEXT	exIdIIStFS
	.erre	cbContext EQ ($-mpIdIISt)	

mpIdIFSt	label	word			
	DWEXT	exIdIFStTyp
	DWEXT	exIdIFSt2
	DWEXT	exIdIFSt4
	DWEXT	exIdIFStR4
	DWEXT	exIdIFStR8			
	DWEXT	exIdIFStSD
	DWEXT	exIdIFStFS
	.erre	cbContext EQ ($-mpIdIFSt)	

	public	mpStExpOpExe
mpStExpOpExe=	$-2				;No record type

	;Note:	One word is saved by basing the executor maps at the
	;current position minus one.  This is acceptable since there
	;are no explicit references to records.  However, when publics
	;are present the static map is no longer first and must have
	;a word of filler for record references.  This word is defined
	;inside the conditional for publics.


mpIdESSt	label	word			
	DWEXT	exIdESStI2
	DWEXT	exIdESStI4
	DWEXT	exIdESStR4
	DWEXT	exIdESStR8
	DWEXT	exIdESStSD
	DWEXT	exIdESStFS
	.erre	cbContext EQ ($-mpIdESSt+2)	

mpIdECSt	label	word			
	DWFILL					
	DWEXT	exIdECStI2
	DWEXT	exIdECStI4
	DWEXT	exIdECStR4
	DWEXT	exIdECStR8
	DWEXT	exIdECStSD
	DWEXT	exIdECStFS
	.erre	cbContext EQ ($-mpIdECSt)	

mpIdEISt	label	word			
	DWFILL					
	DWEXT	exIdEIStI2
	DWEXT	exIdEIStI4
	DWEXT	exIdEIStR4
	DWEXT	exIdEIStR8
	DWEXT	exIdEIStSD
	DWEXT	exIdEIStFS
	.erre	cbContext EQ ($-mpIdEISt)	

mpIdEFSt	label	word			
	DWFILL					
	DWEXT	exIdEFStI2
	DWEXT	exIdEFStI4
	DWEXT	exIdEFStR4
	DWEXT	exIdEFStR8
	DWEXT	exIdEFStSD
	DWEXT	exIdEFStFS
	.erre	cbContext EQ ($-mpIdEFSt)	



subttl	SsGetIsfc
;SsGetISFC - return exe map offset for scope
;Input:
;	bx = pVar
;	dx = index calculated so far
;Output:
;	dx = exe map offset updated for scope
;Modifies:
;	none
;Preserves:
;	none
public	SsGetISFC,GetCxISFC


SsGetISFC:
	mov	cx,cbContext
GetCxISFC:
	    mov     ax,[bx].VAR_Flags		; Fetch flags
	    TestX   ax,FVVALUESTORED		;Test for STATIC
	    jnz     @F				;STATIC variable
		add	dx,cx			;Move to COMMON executors
		TestX	ax,FVCOMMON
		jnz	@F			;COMMON variable (oCommon
						;allocated inCOMMON statement)
	    add     dx,cx			;Move to INDIRECT executors
	    TestX   ax,FVFORMAL
	    jnz     @F				;INDIRECT variable

	add	dx,cx				;Must be a FRAME variable
	call	SsAllocOFrame			;Frame variables have an oFrame
@@:
	ret

sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\sslit.asm ===
page	,132
	TITLE	sslit	-	Scan Support for Literals
;***
;sslit - Scan Support for Literals
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   Scan literal pcodes.
;   Literal scan routines mark their stack entries for two reasons:
;	1. At procedure call time literals always coerce when the definition
;	   or declaration is available.  This means that users are not 
;	   required to use an explicit type character when calling a declared 
;	   or defined procedure.
;	2. For execution speed, I2 literals 0 through 10 are coerced to R4
;	   by replacing the executor.
;
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	scanner
	IncludeOnce	ssint
	IncludeOnce	pcode
	IncludeOnce	optables
	.list

	extrn	exLitDI2:far		

assumes cs, SCAN
assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA

sBegin	SCAN

;***
;Ss_Lit - Scan Literals 
;
;Purpose:
;
;   Scan literal opcodes opLit...
;   Stack entries for literals indicate type and the fact that they
;   are literals.  This difference allows literals to be coerced
;   rather than typechecked in procedure invocations for procedures
;   that are declared.
;   Furthermore, opLit0 through opLit10 may be coerced from I2 to R4
;   by changing the opcode.
;
;Input:
;
;Output:
;
;************************************************************************


mpLitI2OpExe	label	word
	DWEXT	exLitI20

I2Lit	=	1			;Next literal is one

	rept	opLitI2Max
	DWEXT	exLitI2%I2Lit		;;Generate table entry
I2Lit	=	I2Lit + 1		;;Bump literal value
	endm


SsProc	LitI2
	mov	al,byte ptr es:[si-1]	; Get MSB of opcode
	and	ax,HIGH (NOT OPCODE_MASK)
	.erre	OPCODE_MASK EQ 03ffh	; Assure SHR is correct
	shr	ax,1			; AX = Literal value * 2
	xchg	ax,bx			; AX = Opcode * 2, BX = Literal * 2
	mov	bx,mpLitI2OpExe[bx]	; BX = Executor address
	xchg	ax,bx			; AX = Executor, BX = Opcode * 2
	SKIP2_PSW			; Fall into scan routine below

SsProc	Lit
	;Emit the executor

	call	EmitExCopyOps		;Emit the executor and copy operands

	;Make the stack entry

	push	di			;FRAME: oTx of end of exp fragment
	mov	al,mpOpRule[bx] 	;Type is in the rule table
	mov	ah,al			;Type and flags in both bytes

	.errnz	ST_Lit AND 0FFFh	; Assure literal flags in range
	.errnz	ST_LitX AND 0FFFh	; Assure literal flags in range
	.erre	ET_MAX LT 0fh		; Assure ET type in range
	and	ax,0f00fh
	push	ax			;FRAME: Type with literal bits

	;Exit to the main loop

	jmp	[ScanRet]		;Return to the current scan loop


sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssmisc.asm ===
page	,132
	TITLE	ssmisc - Scan Miscellaneous opcodes
;***
;ssmisc - Scan Miscellaneous opcodes
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module contains miscellaneous scan utilities.
;
;
;****************************************************************************


	.xlist
	include		version.inc
SSMISC_ASM = ON
	IncludeOnce	conint		
	IncludeOnce	context
	IncludeOnce	qbimsgs 	
	IncludeOnce	ssint
	IncludeOnce	txtmgr		
	IncludeOnce	variable
	.list

;	.sall

assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA


subttl	Static data area definitons.

sBegin	SCAN
assumes cs, SCAN

subttl	Scan Table Access Routines
page
;***
;GetRuleInfo
;Purpose:
;	Fetch the rule byte and word for this opcode.
;Input:
;	bx = opcode
;Output:
;	ax = rule byte
;	bx = rule word
;	PSW.C set iff high bit in mpOpRule set
;Preserves:
;	all
;****************************************************************
public	GetRuleInfo
GetRuleInfo:
	mov	bl,mpOpRule[bx]		;Load rule table offset
	xor	bh,bh			;To byte offset
	mov	al,tRuleByte[bx]	;Load rule byte
	cbw
	shl	bl,1			;To word offset
	mov	bx,tRuleWord[bx]	;Load rule word
	ret

subttl	Scan Stack Access Routines
page

;***
;FindFrame
;Purpose:
;	Return the address of the the requested frame type, if one exists.
;
;Input:
;	ax = Frame identifier for structure entry.
;
;Output:
;	bx = address of frame (if PSW.NZ)
;	PSW.Z set if no such structure found.
;
;Modifies:
;	none
;Preserves:
;	ax
;**********************************************************************
public	FindFrame
FindFrame:
	push	ax
	mov	bx,sp
	add	bx,4			;Back over push and ret address

EnsureFrameLoop:
	mov	cx,[bx]			;Load frame identifier
	cmp	cx,STYP_StackEnd	;Test for end of stack
	jz	EnsureFrameX		;End of stack - exit
	test	cx,ax			;Test for block of requested type
	jnz	EnsureFrameX		;Frame found - exit
	call	CbFrameSTYPCx		;Map STYP in cx to cbFrame in cx
	add	bx,cx			;Move to next frame
	jmp	short EnsureFrameLoop	;Loop to check next frame

EnsureFrameX:
	pop	ax
	ret

;***
;CbFrameSTYPCx
;Purpose:
;	Map a frame id to the number of bytes in that frame type.
;
;	Frame sizes are based on the high byte of the id word.
;	The type bit is converted to an index into an array of
;	frame sizes.  The conversion is performed by shifting the
;	frame id high byte until the single bit indicating the frame
;	type is found.
;
;Input:
;	cx = frame id
;
;Output:
;	cx = count of bytes in the input frame type
;
;Preserves:
;	all
;*******************************************************************

mcbSTYP	LABEL	WORD
	dw	SIZE FIF	;IF
	dw	SIZE FIF	;ELSE
	dw	SIZE FFOR 	;FOR
	dw	SIZE FIF	;DefFn frame same as IF
	dw	SIZE FDO	;DO
	dw	SIZE FDO	;WHILE frame is identical to DO frame
	dw	SIZE FCASE	;CASE

public	CbFrameSTYPCx
CbFrameSTYPCx:
	push	bx
	mov	bx,-2
CbCountSTYPLoop:
	inc	bx
	inc	bx
	shr	ch,1
	jnb	CbCountSTYPLoop
	mov	cx,[bx].mcbSTYP
	pop	bx
	ret

	subttl	Execution Procedure Frame Allocation
	page
;***
;SsAllocOFrame - allocate an oFrame for a frame resident variable
;Purpose:
;	Allocate an oFrame for a frame resident variable.
;	If the oFrame is already allocated then that allocation is honored.
;
;	Note that this means the allocation is always successful.
;
;	prsCur contains information about the current frame
;	allocation.  
;	   PRS_cbFrameVars is the start of the last allocated frame variable.
;	
;Input:
;	ds:bx = pVar of a frame variable that may or may not have an oFrame
;Output:
;	none
;Preserves:
;	all
;**********************************************************************
.errnz	4 - SIZE DM			;Power of two multiply used below

	public	SsAllocOFrame
SsAllocOFrame:
	DbChk	PVar,bx			;Verify that this is a variable
	push	ax
	push	bx
	push	cx
	push	dx
	mov	dx,[bx].VAR_Flags	;[3] Load flags word from variable
	mov	cx,dx
	and	cx,FV_TYP_MASK		;Get oTyp from flags word
	jnz	@F
	mov	cx,[bx].VAR_oTyp	;Load data type from variable
@@:
	add	bx,VAR_value		;Move to value entry
	test	dx,FVARRAY		; Is this an array?
	jz	AllocOFrameNotArray	;Not an array
	add	bx,AFRAME_oFrame	;Move to oFrame for arrays
	mov	al,[bx-AFRAME_oFrame].AFRAME_cDims	;Dimension count
	xor	ah,ah
	shl	ax,1
	shl	ax,1			;4 bytes per dimension
	add	ax,(SIZE AD) - 1	;AD has a one byte field that
					;overlaps the first dimension info
	cmp	word ptr [bx],0		;Already allocated?
	jz	SsAllocAryOrSimple
AllocOFrameNotArray:
	cmp	word ptr [bx],0		;Already allocated?
	jnz	SsAllocOFrameX		;Already allocated
	mov	ax,cx			;Map data type..
	call	CbTypOTypSCAN		; to data byte count.
PadLength:				
	inc	ax
	and	ax,not 1		;Round up to even
	js	StackOverflow		; Variable size is > 32767 bytes
	jz	AllocFS 		; Brif fixed string or text
	TestX	dx,FVFUN		;Function return value?
	jnz     SetRetVal_OBP	        ; add var offset and set oBP

	;Bump cbFrameVars by the size of the current variable.

SsAllocAryOrSimple:
	add	ax,PrsCur.PRS_cbFrameVars ;Increment cb frame variables
					  ; and temporaries
	jo	StackOverflow		
	mov	prsCur.PRS_cbFrameVars,ax ;Save updated size
SetOBP:
	neg	ax			;To be subtracted from bp
SetHandle:
	mov	[bx],ax			;Set oFrame for current var
SsAllocOFrameX:
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

AllocFS:
	mov	ax,[bx].VAR_cbFixed	; Length of fixed variable
	DbAssertRel ax,ne,0,SCAN,<SsAllocOFrame: VAR_cbFixed is 0>
	jmp	short PadLength 	; Go back and pad


SetRetVal_OBP:				
	add	ax,-FR_FirstVar		; account for offset to first var
	jmp	short SetOBP		

StackOverflow:
	mov	ax,MSG_OutOfStack	
	call	SsError 		
	jmp	short SsAllocOFrameX	


	subttl	control structure binding helpers
	page
;BindExitCur,BindExit - bind chain of EXIT entries
;Purpose:
;	Walk a linked list of EXIT addresses and bind them to
;	the passed oTx. This is used by ENDIF, NEXT, LOOP, and
;	WEND scan routines.
;
;Input:
;	bx = oTx of start of EXIT chain (terminated by UNDEFINED)
;	cx = oTx to bind EXIT chain to.
;
;Output:
;	none.
;
;Preserves:
;	dx

public	BindExit, BindExitCur

BindExitCur:
	mov	cx,di		;bind to current emit address
BindExit:
	cmp	bx,UNDEFINED	;Test for end of list
	jz	BindX		; and exit - end of EXIT list
	mov	ax,PTRTX[bx]	;Get the next link
	mov	PTRTX[bx],cx	;Bind this ref
	xchg	ax,bx		;Next link to bx
	jmp	short BindExit	;Go check for another link in the chain.
BindX:
	ret

;***
;CbTypOTypSCAN, CbTypOTypOMrsSCAN
;Purpose:
;	This routine returns the number of bytes of data required for
;	the input type.
;
;	Copied directly from varmgr as part of revision [7].
;
;	CbTypOTyp assumes that if the oTyp is a user-defined type, it is
;			in the type table for the current mrs
;	CbTypOTypOMrs uses the MRS_bdlVar table in the mrs whose oMrs is
;			given in bx.
;Input:
;	ax = oTyp
;	for CbTypOTypOMrs, bx = oMrs of type table
;Output:
;	ax = cbTyp, or 0 if oTyp == ET_FS or ET_FT
;	PSW flags set based on an OR AX,AX
;Prserves:
;	all (even bx)
;	ES is preserved.  NOTE: for FV_SBSWAP, it is assumed that the ES to be
;				preserved is the text table.
;***************************************************************************
assumes DS, NOTHING		;can be called with DS != SS

mpCbTyp label byte
	.erre	ET_IMP EQ ($-mpCbTyp)
	DB	0		;ET_IMP hole
	.erre	ET_I2 EQ ($-mpCbTyp)
	DB	2		;ET_I2
	.erre	ET_I4 EQ ($-mpCbTyp)
	DB	4		;ET_I4

	.erre	ET_R4 EQ ($-mpCbTyp)
	DB	4		;ET_R4

	.erre	ET_R8 EQ ($-mpCbTyp)
	DB	8		;ET_R8


	.erre	ET_SD EQ ($-mpCbTyp)
	DB	SIZE SD 	;ET_SD


	.erre	ET_FS EQ ($-mpCbTyp)
	DB	0		;ET_FS - - - can't tell size from ET_ type



	.erre	ET_MAX EQ ($-mpCbTyp-1)

	public	CbTypOTypOMrsSCAN
	public	CbTypOTypSCAN
CbTypOTypOMrsSCAN   PROC    NEAR
	push	bx
	jmp	short CbTypOTyp_Cont
CbTypOTypSCAN:
	push	bx
	mov	bx,[grs.GRS_oMrsCur]
	DbChk	oTyp,ax 		;sanity check on input oTyp
CbTypOTyp_Cont:
	cmp	ax,ET_MAX		;Is it a fundamental type?
	ja	NotPredefinedType	;  brif not - user defined

	mov	bx,offset mpCbTyp	;base of lookup table in CS
	xlat	byte ptr cs:[bx]	;al == desired size
	pop	bx
	or	ax,ax			;set PSW flags
	ret

NotPredefinedType:
	PUSH_ES 			;preserve for caller
	test	[conFlags],F_CON_StaticStructs
	jz	Mrs_In_Table		;brif mrsCur not set up

	cmp	bx,[grs.GRS_oMrsCur]
	jz	Want_MrsCur		;brif passed oMrs is for mrsCur

Mrs_In_Table:
	push	si			
	RS_BASE add,bx			;bx points into Rs table
	GETRS_SEG es,si,<SPEED,LOAD>	; get seg of Rs table, trashing si
	pop	si			
	jmp	short Got_pMrs

Want_MrsCur:				;ax is an offset into type table
	lea	bx,mrsCur		;  found in the current mrs
	SETSEG_EQ_SS es
Got_pMrs:
	add	ax,PTRRS[bx.MRS_bdVar.BD_pb] ;ax = pTyp
	xchg	bx,ax			;bx = oTyp, ax = garbage
	mov	ax,[bx].TYP_cbData	;ax = cbData from type table entry
	POP_ES				
	pop	bx
	or	ax,ax			;set PSW flags
	ret
CbTypOTypOMrsSCAN   ENDP

;Added with [11]
;End of [11]
	
sEnd	SCAN				
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssoperat.asm ===
page	49,132
	TITLE	ssoperat - scan intrinsic unary functions and operators
;***
;ssoperat - scan support for intrinsic unary operantors and functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   Scan unary operators and intrinsic functions.
;   Also contains scan dispatches for functions that have no arguments.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSOPERAT_ASM = ON
	IncludeOnce	pcode		
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	variable
	.list


assumes ds, DATA
assumes es, DATA
assumes ss, DATA


	subttl Ss_FnString
	page

sBegin	CODE

	extrn	exFnString_SD:near
	extrn	exFnString_I2:near


sEnd	CODE

sBegin	SCAN


	extrn	tCo1toNotSD:byte	


assumes cs, SCAN

	;Table to map ET type to coercion table index
	;Added with [11]

Index	=	0
BadType	=	-1
Next	MACRO	Cond
IFNB	<Cond>
IFE	Cond
	exitm
ENDIF
ENDIF
	db	Index
Index	=	Index+1
	ENDM

mpScanType	label	byte
	db	BadType		;Records
I2Ind	=	Index		; Needed in MSdFs to map Forms to I2
	Next			;I2
	Next			;I4
	Next			;R4
	Next			;R8
SdInd	=	Index		;Need for FS
	Next			;SD
TxInd	=	Index		;Need for FT
	db	SdInd		;FS
	.erre	ET_MAX EQ ($-mpScanType-1)

	;Index = number of row/columns in coercion table
	;End of [11]


SsProc	FnString
	pop	ax			;AX = oTyp of argument. Record = ET_RC
	push	ax			;Restore on stack for EnsureArgType
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_MaxNum		; Is it numeric?
	jbe	FnStringI2		; Brif numeric or record
	mov	ax,ET_SD		; Result type is source type SD/TX
	call	EnsureArgType		;Eat the SD
	mov	ax,codeOFFSET exFnString_SD ;Load appropriate executor
	jmp	short FnStringEmitExe	;Go emit the exe and continue

FnStringI2:
	mov	ax,ET_I2		;Require an I2 for last argument
	call	EnsureArgType		;Ensure top argument is correct
	mov	ax,codeOFFSET exFnString_I2	;Was I2
FnStringEmitExe:
	STOSWTX 			;Emit the executor
	    mov     ax,ET_I2		;Eat the I2 count
	call	EnsureArgType
	push	di			;Frame -> oTx
	PushI	ax,ET_SD		;Frame -> oTyp
	jmp	[ScanRet]		;Go handle first arg and type explosion



SsProc	UMi
	xchg	bx,ax			;Executor map to bx
	pop	ax			;AX = oTyp of argument. Record = ET_RC
	pop	dx			;Discard oTx
	mov	cx,ax			;Save copy of type high bits
	.erre	ST_Typ_Mask EQ 0ffh	; Assure CBW is sufficient
	.erre	ET_MAX LT 80h		; Assure CBW is sufficient
	cbw				; Clear flags in scan stack
	dec	ax			; ET_RC --> 0FFFFh
	.erre	ET_RC EQ 0		; Assure JB is sufficient
	cmp	al,ET_MaxNum		;[3] Must be numeric
	jb	MapUM			;[3]
	call	TMError
	.erre	ET_I2 EQ 1		; Assure XOR is sufficient
	xor	ax,ax			; Force valid type (ET_I2)
MapUM:
	add	bx,ax
	add	bx,ax
	mov	ax,cs:[bx]		; Get executor
	STOSWTX 			;Emit executor
	push	di			;Build stack entry
	.errnz	LOW ST_Lit?		; Assure we can use CH
	xor	ch,HIGH ST_Lit? 	;High bits now zero if literal/const

	test	ch,0C0H			;Literal or constant?
	jnz	NotLit
	.errnz	LOW ST_LitX		; Assure we can use CH
	or	ch,HIGH ST_LitX		;Make it a constant
	jmp	short UMiX

NotLit:
	.erre	ST_Typ_Mask EQ 0ffh	; Assure XOR is sufficient
	xor	ch,ch			; Clear flags to make expression
UMiX:
	push	cx
	jmp	[ScanRet]	


	subttl	Ss_0FnETExe
	page
;***
;Ss_0FnETExe - Scan functions with 0 args
;
;Purpose:
;
;   Scan functions with 0 args.
;   These functions always have only one executor and one emitted type.
;   mpOpRule contains the emitted type.
;   mpOpExe contains the executor.
;
;Input:
;
;   ax = opcode
;   bx = opcode * 2
;   es:si   = source code address
;   es:di   = destination code address
;
;Output:
;
;   none
;
;**********************************************************************

SsProc	0FnETExe
	shr	bx,1			;Get rule address
	xor	cx,cx
	mov	cl,mpOpRule[bx] 	;Rule table index is the emitted type
					;cx = type emitted
	jmp	short EmitDxIdFrameX	;Exit through Ss_1FnETETExe


	subttl	Ss_2FnSamePExe
	page
;***
;Ss_2FnSamePExe - Scan routine for functions with 2 arguments and many executors
;
;Purpose:
;
;   This scan routine handles intrinsic functions and operators that:
;	- have 2 arguments
;	- mpOpExe is a pointer to a list of executors entered by type
;	- output type is either the input type or a constant (as
;	  indicated by LOW UNDEFINED in the mpOpRule entry)
;
;   This routine is dispatched by a JMP.
;
;Algorithm:
;
;   Get rule
;   Calculate coercion table address
;      Coerce table mpOpRule[(mpOpRule[opcode].irule)*sizeof(Rule)].pCoerce
;      Coercion table dimension is 2.
;   Enter coercion table based on operand entries on stack
;   Insert any needed coercion
;      If type from table does not match the input types AND
;	    required coercion is integer constant to single constant
;	    change the integer constant to the appropriate single constant
;	Else
;	    Enter the coercion executor table to find the coercion
;	    routine (or an error, if the types are not compatible).
;   Emit executor for current opcode
;   Push emit type entry on stack
;
;Input:
;
;   es:si = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;Exceptions:
;	Ss_Error
;******************************************************************
	page


SsProc	2FnSamePExe
	push	bp			
	mov	bp,sp			

	;Get left side type - records are always errors.

	mov	ax,[bp+6]		; AX = oTyp of left operand
	call	MSdFs			;Record? Map FS to SD

	; Multiply zero relative index by Index, the number of different types

	mov     cx,ax
	shl     cx,1			;*2
IF	Index AND 8
	shl     cx,1
ENDIF
IF	Index AND 2
	add     cx,ax			;*3
ENDIF
	shl     cx,1			;*4 or *6
IF	Index AND 1
	add     cx,ax			;*5 or *7
ENDIF
	.erre	(Index LE 11) AND (Index GE 4)

	;Get right side type - records are always errors.

	mov	ax,[bp+2]		; CX = oTyp of right operand
	pop	bp
	call	MSdFs			;Record? Map FS to SD

	;Get target type from coercion table

	add	ax,cx			;Coercion table index
	mov	cx,bx			;Save opcode*2
	shr	bx,1			;Back to opcode (byte index)
	mov	bl,mpOpRule[bx] 	;Get the rule table index
	xor	bh,bh
	mov	dx,bx			;Preserve tRuleByte index for exit
	shl	bx,1			;To word index
	mov	bx,tRuleWord[bx]	;Coercion table address
	xlat	byte ptr cs:[bx]	;Get result type
	cbw
	call	EnsureArgType		; Coerce right side expression
	call	EnsureArgType		; Coerce left side expression
	mov	bx,cx			; Opcode*2 back to bx
	mov	bx,mpOpExe[bx]		;Get executor address map
	xchg	dx,bx
	mov	cl,tRuleByte[bx]	;cx = rule table byte
	xor	ch,ch

EmitTypeExeIdFrameX:
	;ax = argument type (UNDEFINED if type mismatch)
	;cx = rule table byte
	;dx = executor map address

	;Emit executor for current opcode

	cmp	ax,UNDEFINED
	jnz	EmitValidTypeExe
	mov	ax,ET_I2		;This type valid for all users
EmitValidTypeExe:
	mov	bx,dx			;Exe map address to bx
	dec	ax			;To zero relative
	add	bx,ax
	add	bx,ax
	inc	ax
	mov	dx,WORD PTR cs:[bx]	;Executor address

EmitDxIdFrameX:
	;ax = argument type
	;cx = rule table byte
	;dx = executor

	xchg	dx,ax			;ax = executor, dx = input type
	STOSWTX

	xor	ch,ch			;cx = word oType or LOW UNDEFINED
	jcxz	UpdateOTxStart		; Not a function (nothing to emit)

	;Build stack entry for expression location and type

	cmp	cl,LOW UNDEFINED	;Test for output type = input type
	jne	@F			;Output type not input type (cx = type)
	mov	cx,dx			;Output type is input type (saved in dx)
@@:
	push	di			;Stack expression fragment address
	push	cx			;Stack type for expression fragment
	DbAssertRel cx,be,ET_MAX,SCAN,<EmitIdFrameX:  Unexpected return type>  
	    cmp     cl,ET_SD		; SD result?
	    jb	    @F			;Exit if not
	    mov     [SsOTxHeapMove],di	;Assume it can move the heap
@@:
X1FnPExe:
	jmp	[ScanRet]		;Return to scan loop

UpdateOTxStart: 			
	mov	[SsOTxStart],di 	; Update clear stack location
	jmp	X1FnPExe		


	subttl	Ss_1FnPExe
	page
;***
;Ss_1FnPExe - Scan routine for functions with 1 argument and many executors
;
;Purpose:
;
;   This scan routine handles intrinsic functions and operators that:
;      - have 1 argument
;      - mpOpExe is a pointer to a list of executors entered by type
;      - output type depends on the tRuleByte entry as follows:
;	    the input type (indicated by LOW UNDEFINED)
;	    a constant (as indicated by an ET_xx constant)
;	    no emitted type (as indicated by 0)
;
;Algorithm:
;
;   Get rule
;   Calculate coercion table address
;      Coercion table tRuleWord[mpOpRule[opcode].irule].pCoerce
;      Coercion table dimension is 1.
;   Pop operand from stack.
;   Enter appropriate coercion table to find input type.
;   Insert any needed coercion
;      If type from table does not match the input types AND
;	    required coercion is integer constant to single constant
;	    change the integer constant to the appropriate single constant
;	Else
;	    Enter the coercion executor table to find the coercion
;	    routine (or an error, if the types are not compatible).
;   Emit executor for current opcode
;   Push emit type entry on stack
;
;Input:
;
;   es:si = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************
;
	page


SsProc	PaintWidth
	mov	ax,ET_I2
	call	EnsureArgType		;Eat an integer from the stack
	SKIP2_PSW			;Complete through Ss_1FnPExe


SsProc	1FnPExe
	;Get EXE map address and rule address for this opcode

	;Get output type indicator and coercion table address for this rule

	shr	bx,1			;Get opcode (for StWidth2, too)
	call	GetRuleInfo		;Get rule byte and word for opcode bx
					;ax = rule byte
					;bx = rule word
	xchg	ax,cx			; CX = Rule byte

	;Determine coercion required by expression fragment in stack entry

CoerceOk:
	pop	ax			;Type of consumed expression + high bits
	push	ax			; and preserve
	call	MSdFs
	xlat	BYTE PTR cs:[bx]	;Enter coercion table on type in al
	cbw
CoerceField:
	call	EnsureArgType		;Perform the coercion as required
	jmp	EmitTypeExeIdFrameX	;ax = argument type
					;cx = rule table byte
					;dx = executor map address

SsProc	1FnPExeR8
	    pop     ax			;AX = Type of operand + high bits
	    push    ax			;Preserve for EnsureArgType
	    .erre   ET_I2 and 1
	    .errnz  ET_I4 and 1
	    .erre   ET_R4 and 1
	    .errnz  ET_R8 and 1
	    shr     ax,1		;Carry set for I2, R4, and SD
	    mov     ax,ET_R8
	    .erre   ET_R4 EQ ET_R8 - 1
	    sbb     al,0		;AX = ET_R4 if source is I2, R4, or SD
	call	EnsureArgType		;Perform the coercion as required
	xchg	ax,cx			;Result type is operand type
	jmp	EmitDxIdFrameX		;Emit executor


	subttl	Ss_Coerce
	page
;***
;Ss_Coerce - Scan routine for explicit type coercion functionsd
;
;Purpose:
;
;   This scan routine handles intrinsic coercion functions.
;
;Algorithm:
;
;   Get target type from opcode
;   Index into executor map and fetch either new map or executor address
;   Get source operand type from scan stack entry
;   If target type is numeric
;      Coerce operand and emit executor.  Force error if source not numeric.
;   Else target type is string
;      Report error if source type is not string
;      Emit executor
;
;Input:
;
;   es:si = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

SsProc	Coerce
	xchg	ax,bx			;BX = Executor map map address
	mov	cl,byte ptr es:[si-1]	;CL = MSB of opcode
	shr	cl,1
	shr	cl,1
	xor	ch,ch			;CX = ET type of target
	add	bx,cx
	add	bx,cx
	mov	dx,cs:[bx]		;DX = address of executor or map


	mov	bx,scanOFFSET tCo1toNotSD


	jmp	short CoerceOk		;Continue

	subttl	Ss_Format
	page
;***
;Ss_Format - Scan routine for the Format$ function
;
;Purpose:
;
;   This scan routine handles opFnFormat_
;
;Algorithm:
;
;
;Input:
;
;   es:si = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************



	subttl	MSdFs
	page
;***
;MSdFs	- map FS to SD
;Purpose:
;	Map type ET_FS to ET_SD
;
;Input:
;	ax = type with high bits set
;Output:
;	ax = input type - 1, but FS mapped to SD for
;	valid lookup in coercion tables
;Preserves:
;	All
;Exceptions:
;	If record type, type mismatch error is generated
;*******************************************************************************
;Rewritten with [11]

	public	MSdFs
MSdFs:
	push	bx
	xor	ah,ah
	mov	bx,scanOFFSET mpScanType
	xlat	mpScanType		;Map to coercion table index
	pop	bx
	or	al,al			;Valid type?
	js	TmErrorJ
	ret

TmErrorJ:
	xor	al,al			;Return valid index
	jmp	TmError

	;End of [11]


;===============================================================================
subttl	opcode to executor maps for math routines
page
;These tables are used by scan routines to map opcodes to executors.


	public	mptyppexFnStr_
mptyppexFnStr_	label	word
	DWEXT	exFnStr_I2
	DWEXT	exFnStr_I4
	DWEXT	exFnStr_R4
	DWEXT	exFnStr_R8

	public	mptyppexFnEnviron_
mptyppexFnEnviron_  label   word
	DWEXT	exFnEnviron_I2
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWEXT	exFnEnviron_SD



	public	mptyppexStWidth2
mptyppexStWidth2    label   word
	DWEXT	exStWidth2I2
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWEXT	exStWidth2SD

	public	mptyppexFnFre
mptyppexFnFre	label	word
	DWEXT	exFnFreI2
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWEXT	exFnFreSD


	public	mptyppexPrintItemComma
mptyppexPrintItemComma	label	word
	DWEXT	exPrintItemCommaI2
	DWEXT	exPrintItemCommaI4
	DWEXT	exPrintItemCommaR4
	DWEXT	exPrintItemCommaR8
	DWEXT	exPrintItemCommaSD

	public	mptyppexPrintItemSemi
mptyppexPrintItemSemi	label	word
	DWEXT	exPrintItemSemiI2
	DWEXT	exPrintItemSemiI4
	DWEXT	exPrintItemSemiR4
	DWEXT	exPrintItemSemiR8
	DWEXT	exPrintItemSemiSD

	public	mptyppexPrintItemEos
mptyppexPrintItemEos	label	word
	DWEXT	exPrintItemEosI2
	DWEXT	exPrintItemEosI4
	DWEXT	exPrintItemEosR4
	DWEXT	exPrintItemEosR8
	DWEXT	exPrintItemEosSD

	public	mptyppexStPaint
mptyppexStPaint label	word
	DWEXT	exStPaint2
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWFILL					; placeholder
	DWEXT	exStPaint2Tile

	public	mptyppexCoord
mptyppexCoord	label	word
	DWEXT	exCoordI2
	DWFILL					; placeholder
	DWEXT	exCoordR4

	public	mptyppexCoordStep
mptyppexCoordStep   label   word
	DWEXT	exCoordStepI2
	DWFILL					; placeholder
	DWEXT	exCoordStepR4

	public	mptyppexCoordSecond
mptyppexCoordSecond label   word
	DWEXT	exCoordSecondI2
	DWFILL					; placeholder
	DWEXT	exCoordSecondR4

	public	mptyppexCoordStepSecond
mptyppexCoordStepSecond label	word
	DWEXT	exCoordStepSecondI2
	DWFILL					; placeholder
	DWEXT	exCoordStepSecondR4

	public	mptyppexFnPoint2
mptyppexFnPoint2    label   word
	DWEXT	exFnPoint2I2
	DWFILL					; placeholder
	DWEXT	exFnPoint2R4


	public	mptyppexWatchExp
mptyppexWatchExp    label   word
	DWEXT	exWatchExpI2
	DWEXT	exWatchExpI4
	DWEXT	exWatchExpR4
	DWEXT	exWatchExpR8
	DWEXT	exWatchExpSD

	public	mptyppexFnHex_
mptyppexFnHex_	label	word
	DWEXT	exFnHex_I2
	DWEXT	exFnHex_I4

	public	mptyppexFnOct_
mptyppexFnOct_	label	word
	DWEXT	exFnOct_I2
	DWEXT	exFnOct_I4




	public	mptyppexCoerce				
mptyppexCoerce	 equ	 $-2				
	DW	scanOFFSET mptyppexFnCInt		
	DW	scanOFFSET mptyppexFnCLng		
	DW	scanOFFSET mptyppexFnCSng
	DW	scanOFFSET mptyppexFnCDbl		

mptyppexFnCInt	label	word
	DWEXT	exFnCIntI2
	DWEXT	exFnCIntI4
	DWEXT	exFnCIntR8
	DWEXT	exFnCIntR8

mptyppexFnCLng	label	word
	DWEXT	exFnCLngI2
	DWEXT	exFnCLngI4
	DWEXT	exFnCLngR8
	DWEXT	exFnCLngR8

mptyppexFnCSng	label	word
	DWEXT	exFnCSngI2
	DWEXT	exFnCSngI4
	DWEXT	exFnCSngR8
	DWEXT	exFnCSngR8

mptyppexFnCDbl	label	word
	DWEXT	exFnCDblI2
	DWEXT	exFnCDblI4
	DWEXT	exFnCDblR8
	DWEXT	exFnCDblR8

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssproc.asm ===
page	49,132
	TITLE	ssproc	- Scan support for procedures
;***
;ssproc	- Scan support for procedures
;
;	Copyright <C> 1986, Microsoft Corporation
;
;
;****************************************************************************

	.xlist
	include		version.inc
SSPROC_ASM = ON
	IncludeOnce	context
	IncludeOnce	exint		
	IncludeOnce	extort
	IncludeOnce	opid
	IncludeOnce	opmin
	IncludeOnce	opstmt
	IncludeOnce	optables
	IncludeOnce	names		
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list


assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA


	extrn	ABSOLUTE:far 		

sBegin	CODE

	extrn	exBranchRel:near	;This executor in exgoto.asm
	extrn	exBranch:near		;This executor in exgoto.asm
	extrn	exNoList1:near		; This executor in exproc.asm
	extrn	exParamCnt:near 	;This executor in exproc.asm
	extrn	exSave87:near		;This executor in exproc.asm
	extrn	exR8ToStack:near	; This executor in exproc.asm

	    extrn   exR4ToStack:near	; This executor in exproc.asm

extrn	exDelLocSD:near
extrn	exDeallocArray:near

extrn	exDelTmpSD:near

;This executor in exrefarg.asm
extrn	exPushSeg:far		;executor to coerce near reference to far ref.


sEnd	CODE


sBegin	DATA


	extrn	b$ULSymSeg:word 	;Zero iff no user library
	extrn	b$TRPTBL:word		;Start of event handler table
	extrn	b$TRPTBLEND:word	;End+1 of event handler table


pbAbsolute	db	'ABSOLUTE'	
CB_Absolute	EQU	$ - pbAbsolute	


SsLastExit	dw	0
SsProcPRS	dw	0
SsDeclSeg	dw	0	
FuncOtyp	db	0

sEnd	DATA


sBegin	SCAN
assumes cs, SCAN

NoParamsFlag=	80H	;No parentheses on declaration:  no type checking
ArrayFlag=	04H	;Current parameter is whole array
DefFnFlag=	40H	;Def Fn:  pass by value
CallSFlag=	20H	;CallS:  pass by far reference
ByValFlag=	ST_ByVal;BYVAL found on current parameter
SegFlag	=	ST_Seg	;SEG found on current parameter
ProcType=	03H	;From PRS_procType
CallFlag=	SegFlag	;Dual use flag - explicit call

TypeMatchFlag	=	FP_ENDPROC	;Set this bit if type mismatch
ResetBits	=	(ByValFlag + SegFlag + ArrayFlag)*100H + TypeMatchFlag
			;Reset for each parameter

.errnz	ByValFlag - HIGH PATR_byVal
.errnz	SegFlag - HIGH PATR_Seg
.errnz	ArrayFlag - HIGH PATR_array

;Verify the SsRefArg flags defined in SSINT.INC
.errnz	Lvalue - ProcType
.errnz	FarArg - (CallSFlag+SegFlag)
.errnz	FScb - ByValFlag

public	ByValMarker,SegMarker		;Put in rule byte

ByValMarker=	ByValFlag
SegMarker=	SegFlag


;executor map to store values in a temp.
tTmpType	label	word
	DWEXT	exStTmp2
	DWEXT	exStTmp4
	DWEXT	exStTmpR4
	DWEXT	exStTmpR8
	DWEXT	exStTmpSD


;*** Ss_LParen
;
; Make sure type of expression on stack is "expression", not
; variable or literal.

SsProc	LParen
	STOSWTX				;Emit no-op executor
	pop	ax			;Get expression type
	and	ax,((ST_ByVal OR ST_Seg) SHL 8) OR ST_Typ_Mask
	push	ax
	jmp	[ScanRet]


;*** Ss_ByVal_Seg
;
; Set flag that indicates Byval or Seg was seen
; Rule table byte has flag bit set

SsProc	ByVal_Seg
	STOSWTX				;Emit it
	shr	bx,1			;Back to byte index
	pop	ax			;Get oTyp and flags
	or	ah,mpOpRule[bx]		;Add ByVal or Seg flag
	push	ax			;Put it back
	jmp	[ScanRet]


;*** Ss_NoList0 - Current PC oText
;
; This opcode indicates location of current PC.  It was swapped in place
; of original opcode just before scanning.

SsProc	NoList0
	mov	[grs.GRS_otxCont],di	;Set new CONT otx
	dec	si
	dec	si			;Point back to opcode
	mov	ax,[SsErrOpcode]	;Get original opcode
	mov	PTRTX[si],ax		;Put it back so we can scan it now
	jmp	[ScanRet]


;*** Ss_NoList1 - Pcode reference to update
;
; This opcode identifies a spot in the pcode that is referenced by a static
; location in DS.  Its operand is the offset in DS where the oTx is stored.
; This location is updated to contain the current emit oTx if it is possible
; to continue.  Otherwise, this opcode is deleted.
;
; This opcode is used for return addresses on the stack, event table
; entries, and pcode references in the MRS.
;
; In the case of DefFn/Function return addresses, there will be a scan
; stack frame for the return value.  The oTx of this entry must be updated
; to point AFTER this return address opcode, so that any coercions, etc.,
; will be performed AFTER the DefFn/Function returns.
;
; The opNoList1 for error and event handlers is inserted after the opBol
; so that the text manager won't get confused.  A check is made for these
; handlers so they can be updated to the oTx of the saved opBos.  The opcode
; is deleted so that it won't be updated if a coercion takes place later on
; the line.

SsProc	NoList1
	    cmp     [grs.GRS_otxCONT],-1
	jz	EatNoList		;If can't continue, delete pcode
	STOSWTX
	LODSWTX				;Get operand, offset into stack
	STOSWTX
	xchg	bx,ax

	;See if we're dealing with an error or event handler

	test	byte ptr es:[si-3],HIGH (OPCODE_MASK+1)
	jnz	UpdateBOS		; Brif error/event handler

	;   The processing of a opNoList1 results in an exNoList1 being
	;emitted.  This is necessary in case text is inserted before the
	;current location.  opBos processing in ssbos.asm will scan the
	;statement for exNoList1s and update the return addresses with
	;the correct oTx.  The update is still performed here because
	;the Bos search and update will not occur unless there is an
	;insertion.

	mov	[bx],di			;Set oTx of return address to here
	or	[SsBosFlags],SSBOSF_PcUpdate	;Remember that update occured
	pop	ax
	or	ax,ax			;Scan stack entry present?
	jz	PushAx

	;Analyze stack entry to see if oTx needs updating

	pop	bx			;Get oTx
	lea	dx,[bx+4]		; Size of this opcode
	cmp	di,dx			;Did it point just in front of us?
	jnz	RestoreEntry
	mov	bx,di			;Use current emit oTx for entry
RestoreEntry:
	push	bx			;Restore oTx
PushAx:
	push	ax			;Restore oTyp
NoListRet:
	jmp	[ScanRet]

EatNoList:
	inc	si
	inc	si			;Skip over operand
	jmp	NoListRet

UpdateBOS:
	mov	ax,[SsOtxBos]
	mov	[bx],ax
	sub	di,4			;Eat opNoList1 for error/event handler
	jmp	NoListRet

subttl	StDeclare,StSub,StFunction,StDefFn - Scan procedure headers
page

;***
;Ss_StDeclare - Scan the DECLARE statement
;
;Make sure this is the same as the official declaration
;
;***********************************************************************

SsProc	StDeclare,rude
	STOSWTX
	test	[SsExecFlag],OPA_fExecute ;Already seen executable stmt?
	jz	@F
	mov	ax,MSG_COM		;DECLARE must precede executable stmts
	call	SsError
@@:
	mov	ax,PTRTX[si+2]		;Get oPRS
	push	di			;Save current position
	call	ReLinkScan		;Copy operands, adjust PRS if def.
	mov	es,cx			;Segment of PRS to es
	pop	ax
	push	si
	push	di			;Save source and emit oTx
	xchg	ax,di			;Get oTx of declare to di
	add	di,DCL_cParms		;Point to parameter count field
	xor	dh,dh			;Not a DefFn
	call	GetDecl			;Get declaration
	assumes ds,NOTHING

	;ds:si points to declaration of SUB/FUNCTION/DEF FN
	;ax = oRS of declaration

	xchg	ax,bx			;oRS to bx
	lodsw				;Get attributes
	mov	dx,ax			;Preserve length of alias
	xor	ax,es:[di-2]		;Compare attributes
	and	ax,DCLA_cdecl+DCLA_procType+DCLA_oTyp+DCLA_cbAlias
					;Make sure proc type, alias length,
					;CDECL, and fcn return type match
	jnz	DeclareDD
	lodsw				;Get count of parameters
	scasw				;Same as this declare?
	xchg	cx,ax			;Count to cx
	mov	ax,ER_AC
	jnz	DeclareX		;Argument count error?
	inc	cx
	jz	CompAlias		;No parameter list?
	dec	cx
	jz	CompAlias		;No arguments
CompareArgs:
	cmpsw				;Skip over oVar
	lodsw				;Get ParamAtr
.errnz	LOW PATR_byVal			
	mov	dl,ah			; Save ByVal flag in dl
	xor	ax,PTRTX[di]		;Compare ParamAtr
	TestX	ax,PATR_Array+PATR_Seg+PATR_ByVal+PATR_oTyp ;Only these count
	jnz	DeclareTM
	mov	ax,PTRTX[di+2]		; Get declared oType

	; Make sure ByVal is only on numeric types

	xchg	cx,ax			; Declared oType to cx, loop cnt to ax
	test	dl,HIGH PATR_ByVal	; ByVal?
	jz	CompType		; Not ByVal - go compare oTyps
	jcxz	DeclareTM		; Don't allow As Any with ByVal
	cmp	cx,ET_MaxNum		;[2] Record or SD type?
	ja	DeclareTM		; Don't allow non-numeric with ByVal
CompType:				
	push	dx
	push	ax			;Save loop count
	push	bx
	push	ds
	lodsw				;Get official oType
	xchg	ax,dx			;oType to dx

	;NOTE: Zero flag still set here if not ByVal!

	push	ss
	pop	ds
assumes	ds,DATA
	jcxz	AsAny			;Always allow ANY to pass--ZF must be set
	mov	ax,[grs.GRS_oRsCur]
	cCall	CompareTyps,<ax,bx,cx,dx>	
	REFRESH_ES				
	or	ax,ax				
AsAny:
	pop	ds
assumes	ds,NOTHING
	pop	bx
	pop	cx
NextArg:
	pop	dx
	jnz	DeclareTM
	add	di,4
	loop	CompareArgs
CompAlias:
;Make sure aliases match
.errnz	DCLA_cbAlias - 07C00H
	mov	cl,dh			;cbAlias to cx
	and	cl,HIGH DCLA_cbAlias
	shr	cl,1
	shr	cl,1
rep	cmpsb				;Compare alias strings (ZF set if none)

DeclareDD:
	mov	ax,ER_DD		;Duplicate def. if aliases don't match
DeclareX:
;Zero flag set if no error, else error code in ax
	pop	di
	pop	si
	push	ss
	pop	ds
assumes	ds,DATA
	jz	NoDeclErr
	call	SsError
NoDeclErr:
	jmp	[ScanRet]

DeclareTM:
;To accurately position error cursor, figure out exact position in pcode
;of error.  di = emit oTx of error.
	mov	dx,di			;Error location to dx
	pop	di
	pop	si
	sub	dx,di			;Distance back to error
	inc	dx			;Set LSB
	add	si,dx			;Position of error in source
	mov	ax,MSG_ParmTM		;Parameter type mismatch
	push	ss
	pop	ds			;Restore ds
	call	SsError
	sub	si,dx			;Restore source oTx
	jmp	short NoDeclErr

;***
;SsReLinkDecl - adjust PRS to point to proc declaration after scan/descan
;
;Purpose:
;	If this is the official definition of the procedure, i.e. it is
;	referred to by PRS_oRsDef and PRS_otxDef, then adjust PRS_otxDef
;	to refer to new (emit side) location.  Set flag bit if this
;	is done.
;
;	Also copies all operands.
;
;Inputs:
;	ax = oPRS
;	bx = opcode * 2
;	si & di = oTx of cbEOS (source & emit, respectively)
;	dh = 0 if scanning, dh = -1 if descanning
;Outputs:
;	cx:bx = pPRS
;	si & di = oTx of next pcode
;Preserves:
;	dl
;***********************************************************************
	public	SsReLinkDecl,SsReLinkNoCopy
ReLinkScan:
	xor	dh,dh
SsReLinkDecl:
	PUSH_ES 			
	push	di			;Save oTx of declar. (emit side)
	push	si
	push	ax			;Save oPRS
	call	CopyOperands
	pop	ax
NoCopy:
	call	PPrsOPrsSCAN		;[22] oPRS in ax --> pPRS in es:bx
	pop	ax			;oTx+2 of declaration (source side)
	pop	cx
	xor	dh,BPTRRS[bx].PRS_flags ; Get flags, adjust for scan vs. descan
	test	dh,FP_DEFSCANNED	;Already scanned/descanned definition?
	jnz	ReLinked		;No work if already in correct state
	dec	ax
	dec	ax
	sub	ax,[SsCbTxExpand]	;Compute original oTx
	cmp	ax,PTRRS[bx].PRS_otxDef ; Is that where defined?
	jnz	ReLinked
	mov	ax,PTRRS[bx].PRS_oRsDef 
	cmp	ax,grs.GRS_oRsCur	;Defined in this RS?
	jnz	ReLinked
	xor	BPTRRS[bx].PRS_flags,FP_DEFSCANNED ; Change scan state
	dec	cx
	dec	cx
	mov	PTRRS[bx].PRS_otxDef,cx ; Adjust oTx to emit location
ReLinked:
	mov	cx,es			;Save segment of PRS
	POP_ES				
	ret

SsReLinkNoCopy:
;Same as SsReLinkDecl except does not copy operands
;si & di unchanged
	PUSH_ES 			
	push	di
	push	si
	jmp	NoCopy

subttl	StData,StDefType,StType,StEndType,StDefFn,StEndDef
page
;***
;StData,StDefType,StType,StEndType,StDefFn,StEndDef
;
;	These scan routines manage linked lists across the
;	source/emit boundary.
;
;Algorithm:
;	TXLNK is a data structure with a tail pointer for each list.
;	When another item to be linked is encountered, we simply
;	find the previous one with TXLNK and point it to the new one.
;	TXLNK is updated to point to our new one, too.  TXLNK = 0
;	means there is no previous element.
;
;	These routines are generally used for both scan and descan.
;	The exception is StDefFn/StEndDef, which is descan only.  During
;	scan to execute state a stack entry is used to link Def to End.
;	End is not linked in execute state.
;
;	Reasons why these guys are linked in Parse state:
;
;	DEF FN/END DEF - Used to keep track of what is within the definition.
;
;	DATA - NOT linked by parser in Parse state.
;
;	DEFtyp - Used to figure out what type something is, given a pcode
;		location.
;
;	TYPE/END TYPE - Used to keep track of what is within the type definition
;
;
;	Reasons why these guys are linked in Execute state:
;
;	DEF FN/END DEF - Need to know what is within a definition, to 
;		prevent GOTO, etc. to/from DefFn during scan.
;
;	DATA - to find the rest of the data.
;
;	DEFtyp - Used to assign types to direct mode things, using DEFtyp
;		status of the current PC or the last statement.
;
;	TYPE/END TYPE - Used to jump over the type definition.  End is linked
;		to next Type, but not needed.


SsDProc	StDefFn
	STOSWTX
	mov	dh,-1			;Set Descan direction
LinkDefFn:
	mov	ax,PTRTX[si+4]		;Get oPRS
	call	SsReLinkNoCopy		;Adjust PRS_otxDef
	jmp	short LinkDef

SsDProc	EndSingleDef
SsDProc	StEndDef
	STOSWTX
LinkEndDef:
	mov	PTRTX[si],2		;Set filler to cbEOS
LinkDef:
	mov	bx,TXLNK_DefFn
	mov	dx,dataOFFSET mrsCur.MRS_otxDefFnLink
	cmp	PTRTX[si+2],-1		;End of list?
	jz	VarLenLink		;If so, don't change it
	inc	PTRTX[si+2]		;Set LSB of link to indicate end
	jmp	short VarLenLink

ssProc	StData,,Local
SsD_StData:
	mov	bx,TXLNK_Data		;Link field for DATA link list
	mov	dx,dataOFFSET mrsCur.MRS_data_otxFirst
	STOSWTX 			;Emit executor
	mov	PTRTX[si+2],UNDEFINED	;In case this is last, mark end
VarLenLink:
	LODSWTX 			;Load cbEos
	mov	cx,ax
	inc	cx
	shr	cx,1			;Words to EOS including link field
	jmp	short EmitAndAdjLinks	; Emit cbEos and link


SsProc	StDefType,rude,Local
SsD_StDefType:
	mov	cx,3			;Link field plus 1 Dword operand
	mov	bx,TXLNK_DefType
	mov	dx,dataOFFSET txdCur.TXD_otxDefTypeLink
	jmp	short EmitAndAdjLinks	;Emit executor and link


SsProc	StType,rude,Local
	or	[SsFlags],SSF_InType	;Remember we're in TYPE declarationt
	test	byte ptr [grs.GRS_oRsCur+1],80H	;In procedure?
	jz	SsD_StType		;Better not be
	push	ax			;Save executor
	mov	ax,MSG_InvProc		;Illegal in procedure
	call	SsError
	pop	ax
SsD_StType:
	mov	cx,2			;Link field plus 1 word operand
	jmp	short FixType

SsProc	StEndType,rude,Local
	and	[SsFlags],not SSF_InType;No longer within TYPE declaration
SsD_StEndType:
	mov	cx,1			;Link field w/no additional operands
FixType:
	mov	bx,TXLNK_Type
	mov	dx,dataOFFSET txdCur.TXD_otxTypeLink

EmitAndAdjLinks:

	;AX = Word to be emitted
	;BX = offset into LinkCtl
	;CX = remaining cw of operands to copy
	;DX = pointer to head of list

	STOSWTX
	add	bx,[ssLinkCtl]		;Get pointer to link control struc
	mov	ax,di
	xchg	ax,[bx] 		;Get last item, set new "last"
	or	ax,ax			;First item?
	jz	SetHead
	xchg	bx,ax			;Pointer to previous item in bx
	mov	PTRTX[bx],di		;Fix up pointer to current value
CopyOps:
public	CopyOps
	cli				;Double prefix! No interrupts!
rep	movs	PTRTX[si],PTRTX[di]	;Copy remaining operands
	sti
	jmp	[ScanRet]

SetHead:
	mov	bx,dx
	mov	[bx],di			;Set head pointer
	jmp	CopyOps

;***
;Ss_StSub,Ss_StFunction,SsStDefFn - Scan SUB, FUNCTION, and DEF FN statements
;
;Purpose:
;	Two functions are performed:
;
;	1.  Look up executor and copy operands unchanged
;
;	2.  Assign oBP to the parameters.
;
;	The stack looks like this at execution time:
;	<arg 1>
;	<arg 2>
;	. . .
;	<arg n>
;	<oRS of return address>
;	<oText of return address>
;	<old BP>
;
;	At this point, the MOV BP,SP is done.  <arg n> is at offset
;	FR_MinFrame from BP.  Arguments are passed by reference, with
;	the size of the pointer determined by memory model (SizeD).
;	Offsets are assigned in the variable table in a loop starting 
;	with <arg n>.  Since Def Fn arguments are passed by value, 
;	the references are always to temporaries already allocated
;	in the stack.
;	
;******************************************************************


SsProc	StDefFn,rude,local
	STOSWTX

	;Make entry on scan stack

	pop	ax
	push	ax
	or	ax,ax			;Scan frame already on stack?
	jz	DefFnFrame
	mov	ax,MSG_DefFnCtrl
	call	SsError
DefFnFrame:
	push	di
	PushI	ax,STYP_DefFn

	push	PTRTX[si+8]		;Save count of parameters
	mov	[SsBosStack],sp 	; Reset BOS SP mark for 1 Line Fn
	push	PTRTX[si+4]		;Put oPRS on stack
	mov	ax,SCANOFFSET ContDefFn
	xchg	ax,[ScanRet]
	push	ax
	xor	dh,dh
	jmp	LinkDefFn		;"call" scan routine with ret. addr.
					;  in [ScanRet]

ContDefFn:
	pop	[ScanRet]		;Restore original [ScanRet]
	mov	[SsOTxStart],di 	; Reset DOS oTx mark for 1 Line Fn
	call	PrsActivate		; oPRS pushed earlier
	REFRESH_ES			
	jmp	short FuncDef


SsProc	StFunction,rude
	STOSWTX				;Emit executor
	push	PTRTX[si+6]		;Save count of parameters
	mov	ax,PTRTX[si+2]		;Get oPRS
	call	ReLinkScan		;Re-link decl. and copy operands
FuncDef:
	cmp	prsCur.PRS_cbFrameVars,-FR_FirstVar	
					; Any frame space already allocated?
	jnz	SubFuncDef
	mov	al,prsCur.PRS_oType	;Get oTyp of return value
	and	al,M_PT_OTYPE		; mask out possible flag bits
	DbAssertRelB	al,b,ET_FS,SCAN,<Ss_StFunction: oTyp is invalid>
	cbw
	call	CbTypOTypSCAN		; Get size of this type
	add	prsCur.PRS_cbFrameVars,ax ; Allocate space for return value
	jmp	short SubFuncDef


SsProc	StSub,rude
	STOSWTX				;Emit executor
	push	PTRTX[si+6]		;Save count of parameters
	mov	ax,PTRTX[si+2]		;Get oPRS
	call	ReLinkScan		;Re-link decl. and copy operands
SubFuncDef:
	mov	[SsLastExit],0
	pop	cx			;Count of parameters
	mov	ax,cx
	jcxz	NoParams
	push	di			;Save oTx
	mov	ax,FR_MinFrame		;First oBP
AssignBP:
	sub	di,6			;Back up to next oVar
		mov	bx,[MrsCur.MRS_bdVar.BD_pb]
	    add     bx,PTRTX[di]
	.errnz	AFORMAL_oFrame
	mov	[bx].VAR_value,ax	;Assign oBP
	    inc     ax
	    inc     ax			;Offsets need two bytes
	.errnz	LOW FV_STATICSET	;Assure byte is ok
	or	byte ptr [bx].VAR_flags+1,HIGH FV_STATICSET ; Flag as dynamic array
	loop	AssignBP
	pop	di			;Recover oTx
	sub 	ax,FR_MinFrame		;cb of parameters
	shr	ax,1			;Word count of parameters
NoParams:
	mov	prsCur.PRS_cwParams,al
	jmp	[ScanRet]

SsProc	StExitProc
	STOSWTX
	inc	si
	inc	si			;Skip over operand
	mov	ax,di
	xchg	ax,[SsLastExit]
	STOSWTX				;Link this with last EXIT
	test	byte ptr [grs.GRS_oRsCur+1],80H	;In a procedure?
	jnz	ExitX
	mov	ax,MSG_InvMain		;Illegal outside procedure
	call	SsError
ExitX:
	jmp	[ScanRet]

SsProc	StEndProc
	call	LinkExit		;Point all EXIT statements to here

	;ife SizeD Insert pcode to release local strings and arrays
	;if  SizeD and FV_FORMS Insert pcode to release Forms and Menus

	push	ax			;Save executor
	call	far ptr RelLocalVars	
	GETSEGTXTCUR			
	pop	ax			;Restore END executor

	STOSWTX
	jmp	[ScanRet]


SsProc	EndSingleDef,rude,local
	STOSWTX
	mov	al,[prsCur.PRS_oType]	;Get result type
	and	ax,M_PT_OTYPE		; mask out possible flag bits
	call	EnsureArgType
;Update count of temps needed
	xor	ax,ax
	xchg	ax,[SsCbFrameTemp]	;Get count of temps needed
	mov	[prsCur.PRS_cbFrameTemp],ax	;Set temp count
	jmp	short EndDef

SsProc	StEndDef,rude,local
	call	LinkExit
	STOSWTX				;Emit executor
EndDef:
	pop	ax			;Get stack entry
	cmp	ax,STYP_DefFn		;Is it our DefFn?
	jnz	ExtraEndDef
	pop	ax			;Clean oTx off stack
EndDefX:
	call	PrsDeActivateFar	
	REFRESH_ES			
	jmp	LinkEndDef

ExtraEndDef:
	test	byte ptr [grs.GRS_oRsCur+1],80H	;In procedure?
	jnz	GetFrame		;If so, go analyze frame
	push	ax			;Restore frame
	mov	ax,MSG_EndNoDef
	call	SsError
	jmp	EndDefX

GetFrame:
	call	SsFrameType
	jmp	EndDefX


LinkExit:
;Set operand of all EXIT statements to point to current emit oTx
	mov	cx,[SsLastExit] 	; Head of list of EXITs
LinkLoop:
	jcxz	LinkX			; Brif end of list
	mov	bx,cx			;BX = Link to next
	mov	cx,di			;CX = Current oTx
	xchg	PTRTX[bx],cx		;Set oTx operand, get link to next
	jmp	LinkLoop

LinkX:
	ret


subttl	Ss_StCall
page
;***
;Ss_StCall - Scan CALL statement
;
;Purpose:
;	1.  Look up executor, copy operands unchanged.
;
;	2.  Using oPRS of target, get oRS of declaration,
;	    then actual far address of declaration.
;
;	3.  Check count of arguments, then compare types of actual
;	    arguments with declared parameters.
;
;	4.  Adapt form of each parameter as required: near reference,
;	    far reference, or value.  Interpreted SUBs and FUNCTIONs
;	    always pass by near reference, DEF FN's by value.
;
;
;******************************************************************


	public	SsCallFunc
SsCallFunc:
extrn	IdLdtoFuncMap:abs
;Enter here from IdLd and AIdLd with FVFUN set
;
;	ds:bx = pVar
;	cx = count of arguments (0 means from IdLd, non-zero means AIdLd)
;	dx = base of executor map for IdLd or AIdLd

	push	cx
	call	SsIndexType		;Index into executor map based on oTyp
	pop	cx
	add	dx,IdLdtoFuncMap
	mov	al,[bx].VAR_flags
	and	al,FV_TYP_MASK
	DbAssertFlags	nz,SCAN,<SsProc: function RetVal oTyp = 0>
	mov	[FuncOtyp],al
	mov	ax,[bx].VAR_Value	;fetch oPrs
	push	ax			;Save oPRS
	push	es			
	call	PPrsOPrsSCAN		;[22] ax = oPrs, es:bx = pPrs
	cmp	BPTRRS[bx.PRS_procType],PT_DEFFN 
	pop	es			
	mov	bx,dx
	mov	ax,cs:[bx]		;Get executor
	STOSWTX				;Emit
	MOVSWTX				;Copy one operand
	pop	ax			;Recover oPRS
	mov	dx,PT_FUNCTION*100H + PT_FUNCTION
	jnz	CallFunc		;brif not a DEF FN
	mov	dx,(DefFnFlag+PT_DEFFN)*100H+PT_DEFFN
;Make sure DefFn is not calling itself recursively
	cmp	ax,[grs.GRS_oPrsCur]	;Same as the one we're in?
	jnz	CallFunc		;If not, then not recursive
	inc	[SsDelayCnt]		;First delayed error on line?
	jnz	CallFunc		;If not, don't update its oTx
	mov	[SsDelayLoc],si		;Save source oTx of error
	mov	[SsDelayErr],ER_UF	;Undefined function
CallFunc:
	jcxz	ParamCheck		;If no arguments, only one operand
	MOVSWTX				;Copy 2nd operand of AIdLd
	jmp	short ParamCheck


ssProc	StCallS
	mov	dh,CallSFlag+PT_SUB
	jmp	short StCall


SsProc	StCall
	mov	dh,CallFlag+PT_SUB
	jmp	short StCall

ssProc	StCallLess
	mov	dh,PT_SUB
StCall:
	mov	dl,PT_SUB
	STOSWTX 			;Emit it

	LODSWTX				;Get operand count
	STOSWTX
	mov	[FuncOtyp],ah		;Set to zero - no RetVal
	xchg	cx,ax			;Save count in cx
	LODSWTX				;Get oPRS
	STOSWTX
ParamCheck:

	;Start of [39]

	;   During an Edit and Continue operation, the pcode may contain
	;opNoList1 opcodes to point to return addresses on the stack
	;that must be updated with the execute state pcode addresses of
	;the current location.	If the current "Call" opcode requires
	;executors to discard temporaries or copy array elements back
	;to far memory, the return address must point immediately after
	;the call and before the inserted executors.  Normal scanning
	;would not process the opNoList1s until the "Call" and it's
	;parameters are finished with.	This results in the stack
	;being updated with the wrong return address.  To solve this
	;problem, the scanner looks ahead to see if the following
	;opcode is opNoList1 and if so, processes it immediately.  Note,
	;there may be more than one occurance for recursive procedures.
	;After this is complete, the parameters are coerced and any
	;necessary insertions are performed.
	;   The processing of a opNoList1 results in an exNoList1 being
	;emitted.  This is necessary in case text is inserted before the
	;"Call" executor.  opBos processing in ssbos.asm will scan the
	;statement for exNoList1s and update the return addresses with
	;the correct oTx.  The update is still performed here because
	;the Bos search and update will not occur unless there is an
	;insertion.

	cmp     [grs.GRS_otxCONT],UNDEFINED	
	jz	IgnoreOpList1		; If can't continue, ignore it

	push	ax			;Save oPrs
@@:
	LODSWTX 			;Look ahead at next opcode
	cmp	ax,opNoList1		;Is this a PC update?
	jnz	@F

	mov	ax,codeOFFSET exNoList1
	STOSWTX 			;Emit executor
	LODSWTX				;Get operand, offset into stack
	STOSWTX
	xchg	bx,ax
	mov	[bx],di			;Set oTx of return address to here
	or	[SsBosFlags],SSBOSF_PcUpdate	;Remember that update occured
	jmp	@B			;Look for another PC update

@@:
	dec	si			;Backup before next opcode
	dec	si
	pop	ax			;Restore oPrs

IgnoreOpList1:				

	;End of [39]

	mov	[SsOtxHeapMove],di	;Procedures can cause heap movement
	mov	[SsParmCnt],cx
	mov	[SsProcPRS],ax		;Save oPRS
	call	PPrsOPrsSCAN		;[22] oPRS in ax --> pPRS in es:bx
					; if FV_SBSWAP, sets up sbRsScan
	cmp	dl,BPTRRS[bx].PRS_ProcType ; Use consistent with PRS?
	jz	PrsOK
	push	ax			
	mov	ax,ER_DD		;Duplicate definition
	call	SsError
	pop	ax			
PrsOK:
	mov	dl,BPTRRS[bx].PRS_flags 
	mov	cl,dl

;***** Start revision [36]
;***** End revision [36]

	push	bx			;Save pPRS
	push	es			; save seg of prs
	GETSEGTXTCUR			
	and	dl,not FP_CDECL		;Reset CDECL for now
	mov	PTRTX[di],si		;Save si in the emitted text
	xor	ax,ax			;Indicate no alias if no decl.
	mov	[SsCbParmCur],ax
	test	cl,FP_DEFINED+FP_DECLARED  ;Is there a declaration?
	mov	cx,-1			;Indicate no declared params
	pop	es			; seg of prs
	jz	NoDecl

	push	es			; save seg of prs
	call	GetDecl 		; returns with ds = seg of declare
	assumes DS,nothing		
	pop	es			; seg of prs
	pop	bx
	push	ax			;Save oRS of declaration

	;ds:si points to delcaration of SUB/FUNCTION/DEF FN
	;es:bx = pPRS of the procedure		
	;dx = flags

	lodsw				;Get oTypFn
	or	ah,ah			;CDECL bit set?
.errnz	DCLA_cdecl - 8000H
	jns	NoCDECLbit
	or	dl,FP_CDECL
NoCDECLbit:
	push	ax			;Save oTypFn
	lodsw				;Get count of parameters
	mov	[SsDeclSeg],ds		; preserve segment of declaration
	push	ss
	pop	ds			;Restore ds = ss
	assumes DS,DATA 		
	mov	cx,ax
	inc	ax			;UNDEFINED same as zero params
	jz	HavAlias
	dec	ax
	shl	ax,1			;ax = cnt*2
	add	ax,cx			;ax = cnt*3
	shl	ax,1			;ax = cnt*6
	add	si,ax			;si points to alias, if any
HavAlias:
	pop	ax			;oTypFn and attributes
NoDecl:
;oRS of decl. on stack (pPRS of procedure if no decl.)
	mov	BPTRRS[bx].PRS_flags,dl ; Update CDECL bit
	push	cx			;Declared count of params
	push	dx			;Flags

	push	bx			; parm to Ss_UL_Support: oPrs
	push	ax			; parm to Ss_UL_Support: cbAlias
	push	dx			; parm to Ss_UL_Support: flags
	call	far ptr Ss_UL_Support	; this chunk is in CP to support
					;	some calls that must be made
					;	from CP
	inc	dx			; error occurred?
	jnz	@F			;	brif not

	GETSEGTXTCUR			;Restore es
	xchg	si,PTRTX[di]		;Restore source pointer
	call	SsError 		; ax contains error code
	xchg	si,PTRTX[di]		;Resave source pointer
@@:
	dec	dx			
	mov	cx,dx			;Save segment of UL proc.
	push	ax			;Save offset
	mov	ax,[SsProcPRS]		;PRS may have moved--get pointer again
	call	PPrsOPrsSCAN		;[22] oPRS in ax --> pPRS in es:bx
	pop	ax
NoUL:
	push	es			; save seg of prs
	GETSEGTXTCUR			;Restore es
	xchg	si,PTRTX[di]		;Restore source pointer
	pop	es			; seg of prs
	pop	dx			;Get flags
	test	dl,FP_DEFINED		;Already defined in interpreter?
	    jnz     InterpProc		
	test	dl,FP_DECLARED		;Was procedure declared?
	    jnz     OKtoUse
	    test    dh,CallFlag + CallSFlag ;Explicit CALL of undeclared proc?
	    jnz     OKtoUse
	    mov     ax,ER_SN		    ;Syntax error if non-existant
	    jcxz    ULError
DeclError:
	mov	ax,ER_US		;Undefined subprogram
ULError:
	call	SsError
	jmp	short CheckParams


sEnd	SCAN
sBegin	CP
assumes cs,CP


DbPub	Ss_UL_Support			
cProc	Ss_UL_Support,<FAR>		
	parmW	oPrs			
	parmW	cbAlias 		
	parmW	flags			
cBegin					
	call	RtPushHandler		;Blasts cx
	mov	ax,cpOFFSET MakeSDFail	
	call	RtSetTrap		;Set trap, errSP at this level
	mov	cx,[cbAlias]		
	mov	cl,ch			
	and	cx,HIGH DCLA_cbAlias	;Mask to cbAlias
.errnz	DCLA_cbAlias - 7C00H
	shr	cl,1			
	shr	cl,1			
;the next four instructions don't alter the flags
	mov	dx,si			;Save pointer to alias
	pushf				;Remember if we found an alias
	GETRS_SEG es			
	mov	bx,[oPrs]		
	mov	ax,PTRRS[bx].PRS_ogNam	;[3] assume no alias

	mov	es,[SsDeclSeg]		; restore es as seg of declaration
	jnz	UseAlias		;Have alias, so copy to SD
;No alias, copy proc. name to SD
	cCall	FpNamOfOgNam,<ax>	; es:dx points to name, cx is cbName
UseAlias:
	; for LQB, all we have to do is compare against "ABSOLUTE"
	pop	ax			; discard flags on stack
	push	si			; save register
	mov	bx,offset DGROUP:pbAbsolute	; DS:BX = "ABSOLUTE"
	mov	si,dx			; ES:SI = proc name

	xor	dx,dx			; assume failure (DX:AX = 0)
	xor	ax,ax			
	cmp	cx,CB_Absolute		; length must be right
	jnz	NotAbsolute		; brif not -- exit

ChkForAbsolute:				
	lods	byte ptr es:[si]	; AL = proc name char
	cmp	al,[bx]			; does it match char of "ABSOLUTE"
	jz	NextChar		; brif so -- do next char
	and	al,0dfh			; make upper case
	cmp	al,[bx]			; match now?
	jnz	NotAbsolute		; brif not -- exit
NextChar:				
	inc	bx			; advance to next char
	loop	ChkForAbsolute		; compare next char

	mov	dx,SEG ABSOLUTE		; return the address of ABSOLUTE
	mov	ax,OFFSET ABSOLUTE	
NotAbsolute:				
	pop	si			; restore reg
NoName:
	call	RtPopHandler		;preserves ax,dx
cEnd					

MakeSdFail:
;Error handler should B$LDFS or B$ULGetProc fail
;Error code in ax
	mov	dx,UNDEFINED		
	jmp	short NoName


; emit code to release local strings and arrays - - - part of proc exit
; must be in CP for calls to FirstVar, NextVar

cProc	RelLocalVars,<FAR>		
cBegin
	call	FirstVar		;Get a variable in this proc
Deallocate:
	or	ax,ax
	jz	DoneDealloc
	mov	cx,PTRVAR[bx].VAR_flags ;[6]
FRAME=	    FVCOMMON+FVSTATIC+FVSHARED+FVFORMAL+FVFUN+FVVALUESTORED+FVREDIRECT
	    TestX   cx,FRAME		;Is it a local variable?
	jnz	GetNextVar

	    TestX   cx,FVARRAY		;Is it an array?
	    mov     ax,codeOFFSET exDeallocArray
	    jnz     @F
	    and     cx,FV_TYP_MASK	;Mask to oTyp
	    .errnz  HIGH FV_TYP_MASK	; Assure we can use CL
	    cmp     cl,ET_SD		;Is it a string?
	    jne     GetNextVar
	    mov     ax,codeOFFSET exDelLocSD
@@:
	    .errnz  AFRAME_oFrame
	mov	cx,PTRVAR[bx].VAR_value ;Get oBP of local
	jcxz	GetNextVar		;If oBP is zero, phantom variable
	call	far ptr Insert1Op_Far	; call to SCAN to call Insert1Op
GetNextVar:
	call	NextVar			;ax = oVar, bx = pVar
	jmp	Deallocate

DoneDealloc:
cEnd					

sEnd	CP
sBegin	SCAN
assumes cs,SCAN

cProc	Insert1Op_Far,<FAR>		
	;NOTE: oTx of insertion is in di
cBegin					
	GETSEGTXTCUR			
	mov	bx,di			; Insert right here
	call	Insert1Op
cEnd					


	;ES:BX = pPRS of procedure

InterpProc:
	    jcxz    CheckParams
	    mov     ax,MSG_DupLibPrs	;UL and interp proc. with same name
	    jmp     short ULError

OKtoUse:
	    jcxz    DeclError		    ;Didn't find proc in UL
	    mov     PTRRS[bx].PRS_txd.TXD_oCompiled,ax	    
	    mov     PTRRS[bx].PRS_txd.TXD_segCompiled,cx    

CheckParams:
	GETSEGTXTCUR			
	pop	ax			;Declared count of parameters
	mov	cx,[SsParmCnt]
	inc	ax			;Have parameter list?
	jz	NoParamList
	dec	ax
	cmp	ax,cx			;Same as actual count?
	jz	ParamCountOK
	inc	[SsDelayCnt]		;First ArgCntErr on line?
	jnz	NoParamList		;If not, don't update its oTx
	mov	[SsDelayLoc],si		;Save source oTx of error
	mov	[SsDelayErr],ER_AC	;It's an Arg Cnt error
NoParamList:
	or	dh,NoParamsFlag
ParamCountOK:
	pop	ax			;oRS to ax
	jcxz	SsParamsOK
NextParam:
;ax = oRS of declaration
;cx = count of remaining arguments
;dx has flags
;es:[di-2] = oTx of declaration, if any
	xchg	bx,ax			;oRS to bx
	and	dx,not ResetBits	;Reset ByVal, Seg, Array (and CallFlag)
	mov	ax,[SsCbParmCur]
	inc	ax
	inc	ax
	mov	[SsCbParmCur],ax	;Assume near reference - 2-byte param

	;Pop stack and check for BYVAL or SEG flag

	pop	ax			;Get oTyp with BYVAL/SEG flag
	test	dl,FP_DEFINED		; Interpreted function?
	jz	@F			; Brif not
	test	ah,ST_ByVal OR ST_Seg	; ByVal or Seg present
	call	TmErrorNZ		
@@:					
	xor	dh,ah			;Flip flag bits
	and	ah,not (ST_ByVal + ST_Seg) ;Mask out ByVal & Seg
	xor	dh,ah			;Restore all but ByVal & Seg
	pop	PTRTX[di+2]		;oTx of end of argument
	push	cx			;Save count of params
	call	CoerceParam		;Adjust parameter to match calling conv.

;ax = oRS of decl.
;bx adjusted to continue to point to end of argument
;dx preserved

	test	dl,FP_CDECL		;If CDECL, must re-order params
	jz	NoReorder
	cmp	[SsParmCnt],2		;If less than 2 parms, no re-order
	jl	NoReorder

;Re-order parameters for CDECL by inserting branch after each.
;Target of branch will be assigned later.

	push	ax
	call	InsertBranch
	pop	ax
NoReorder:
	pop	cx
	loop	NextParam

	DbPub	SsParamsOK
SsParamsOK:
;Done with parameter processing
;bx = oTx of end of first parameter (if any)
;dx = flags
;Start of [27]
;Find oTx before first parameter
	mov	cx,bx			;save otx of call if 1 parm
	cmp	sp,[SsBosStack]		;Any entries on stack for this stmt?
	mov	bx,[SsOTxStart] 	;Assume not - use start of stmt
;Note that SsBosStack is the SP at BOS, except it was saved with one extra
;word pushed on it.  Thus SP will actually be larger that SsBosStack when
;the stack is empty.
	ja	HaveStartOtx		;Stack empty?
;Get first oTx by looking at scanner entry on stack
	pop	ax			;oTyp
	pop	bx			;oTx
	push	bx			;Put them back
	push	ax
HaveStartOtx:
;bx = oTx of start of first parameter
;cx = oTx of call if 1 parameter
;Save 8087 registers if function call
	xchg	ax,cx			;ax = otx of call if 1 parm
	and	dh,ProcType
	cmp	dh,PT_SUB		;Was it a SUB?
	jz	No87Save
	push	ax
	mov	ax,codeOFFSET exSave87
	call	Insert
	pop	ax			;ax = otx of call if 1 parm
	inc	ax
	inc	ax			;adjust for insertion

No87Save:
;end of [27]
	cmp	[SsErr],0		;Any errors so far?
	DJMP	jnz	FuncCheck	;If so, don't try this stuff
	test	dl,FP_CDECL		;If CDECL, must re-order params
	jz	NotCDECL
	mov	cx,[SsParmCnt]
        jcxz    NotCDECL                ;No work if 0 parameters
        dec     cx
	xchg	ax,bx			;bx = otxCall if 1 parm, ax = otx first
					; param
        jz      EatParams               ;Just eat parameter on return
	xchg	ax,bx			;swap em back
	push	dx			;Save flags
	call	InsertBranch		;Jmp to last arg--don't know oTx yet
;Have inserted exBranch's to re-order parameters.  Now go find them
;and set their target operand.
	push	bx			;Remember this spot for patching later
	call	FindBranch
	pop	ax			;Restore "previous"
	push	bx			;1st param's jump to be patched later
	push	ax
PatchBranch:
;ax = oTx of previous branch
;bx = oTx of current branch
	push	ax
	push	bx
	call	FindBranch
	pop	ax			;oTx of previous branch
	pop	dx			;dx = target of branch
	call	PatchBranchRel		;compute and patch relative addr
	loop	PatchBranch
;bx = Otx after last branch == otx of call instruction
	mov	cx,bx			;save otx of call
	pop	bx			;oTx of 1st param's branch
	xchg	dx,ax			;target in dx
	call	PatchBranchRel		;patch relative addr
	pop	bx			;oTx of 2nd param's branch
	mov	dx,cx			;target is call instruction
	call	PatchBranchRel		
	mov	bx,cx			;Location of CALL
        pop     dx			;Restore flags
EatParams:
;Insert pcode to eat parameters
	mov	cx,[SsCbParmCur]
;cx = amount of stack space to release
;bx = oTx of CALL
	mov	ax,codeOFFSET exParamCnt
	call	Insert1Op
;bx = oTx of CALL
NotCDECL:
	test	dl,FP_DEFINED		;Interpreted function?
	jnz	FuncCheck
;Compiled code - add temp to save return oTx and cbParams
	mov	ax,4
	call	AllocTemp
FuncCheck:
	cmp	dh,PT_SUB			;Was it a SUB?
	je	ProcExit			;If so, we're done
;Make stack entry for function return value
	push	di				;Save oTx
	mov	al,[FuncOtyp]
	cbw
	push	ax			;Leave oType on stack
	test	dl,FP_DEFINED		;Interpreted function?
	jnz	ProcExit
	test	dl,FP_CDECL		;C function?
	jnz	ProcExit
;PL/M function - allocate temp for return value
	.erre	ET_MAX LT 100h		; Assure we can use AL
	cmp	al,ET_I4		;Returned in registers?
	jle	ProcExit
	cmp	al,ET_SD		;Returned in registers?
	jae	ProcExit		
	call	CbTypOTypSCAN		; Get size of this type
	call	AllocTemp		;Make space for return value
ProcExit:
	jmp	[ScanRet]

;*** PatchBranchRel
;
;	Added with [49].
;Inputs:
;    dx = location to jump to
;    bx = ptr to pcode AFTER exBranchRel operand
;Outputs:
;    [bx-2] is patched to contain offset of target relative to bx-2.
;Preserves:
;    all except dx.
;
PatchBranchRel:
	mov	PTRTX[bx-4],codeOFFSET exBranchRel ;backpatch exbranch
				; to exBranchRel
	sub	dx,bx		;dx = offset target relative to next pcode
	inc	dx
	inc	dx		;compute offset relative to ExBranchRel operand
	mov	PTRTX[bx-2],dx	;patch it
	ret

;*** SsFindOpNoList1,FindBranch
;
;Inputs:
;	ax = Executor whose opcode is opNoList1 (SsFindOpNoList1 only)
;	bx = start of search range
;	di = end of search range
;Outputs:
;	bx = oTx of point after opcode if found
;	Carry flag set if not found
;Preserves:
;	cx

	public	SsFindOpNoList1

FindBranch:
	mov	ax,codeOFFSET exBranch	;Look for this executor
SsFindOpNoList1:
	GetCodeIntoDs	SCAN		
assumes	ds,NOTHING
LookOpNoList1:
	mov	dx,PTRTX[bx]		;Get executor
	cmp	ax,dx			;Find it?
	jz	FoundNoList
	xchg	dx,bx
	mov	bx,[bx-2]		;Get opcode
	and	bx,OPCODE_MASK		;Just want the opcode!
	mov	bl,mpOpAtr[bx]		;Load attribute byte
	and	bx,OPA_CntMask		;Get the operand count from attribute
	cmp	bl,OPA_CntMask		;Check for cnt field in operand
	xchg	bx,dx
	jne	SkipOps 		;No cnt field
	inc	bx
	inc	bx
	mov	dx,PTRTX[bx]		;Get count of operands
	inc	dx
	and	dl,not 1		;Round up to even
SkipOps:
	add	bx,dx
	inc	bx
	inc	bx
	cmp	bx,di
	jb	LookOpNoList1
	stc				;No more found
FoundNoList:
	lea	bx,[bx+4]		;Point to next pcode w/o affecting flags
	push	ss
	pop	ds
	ret

;*** CoerceParam
;
;Purpose:
;	Perform whatever translations are necessary to make the
;	parameter match its declaration and get passed securely.
;Inputs:
;	ax = current type, high bits set
;	bx = oRS of declaration
;	dx = flags
;	es:[di+2] = oTx of end of argument
;	es:[di] = oTx of declaration
;Outputs:
;	ax = oRS of declaration
;	bx = oTx of end of argument (after any insertions)
;Preserves:
;	dx

	extrn	GetTrueType:near	; From ssrefarg.asm


	assumes ds,DATA

	DbPub	CoerceParam
CoerceParam:
	push	bx
	mov	cx,ax
	.erre	ST_Typ_Mask EQ 0FFh	;Assure XOR is sufficient
	xor	ch,ch			;Use current type if none declared
	test	dh,NoParamsFlag
	jnz	NoType
	xchg	si,PTRTX[di]		;Get oTx of declaration
	sub	si,6			;Point to next parameter
	call	GetDeclSeg		;ds:si point to parameter
	assumes ds,NOTHING		
	mov	bh,[si+DCLP_atr+1]	;Get high byte of ParamAtr
	and	bh,HIGH ResetBits
	or	dh,bh			;Combine ByVal and Seg bits
	mov	bx,[si+DCLP_oTyp]	;Get oType
	push	ss
	pop	ds			;Set ds = ss
	assumes ds,DATA 		
	xchg	si,PTRTX[di]		;Restore text source
	or	bx,bx			;Typed "as any"?
	jz	NoType	 		;If so, use attributes but not type
;Re-written with [37]
	pop	cx			;cx = oRS of declaration
	push	cx
	push	ax			;Current oTyp, high bits set
	push	bx			;Required oTyp
	push	cx
	mov	bx,PTRTX[di+2]
	call	GetTrueType
	xchg	ax,cx			;Actual oTyp to ax
	pop	bx			;Get oRs of declaration back
	pop	cx			;Get required oTyp back
	push	cx
	cmp	al,ET_FS		;Have an FS?
	jnz	LongCompare
	dec	ax			;FS-->SD, FT-->TX
	test	dh,ArrayFlag		;Passing whole array?
	jnz	NoMatch			;FS not allowed if so
LongCompare:
	push	dx
	xchg	ax,dx			;Current type to dx
	mov	ax,[grs.GRS_oRsCur]
	xchg	ax,bx			;oRS of decl. to ax, oRScur to bx
;bx:dx = oRS:oType of current type
;ax:cx = oRS:oType of target type
	cCall	CompareTyps,<ax,bx,cx,dx>	; Are types the same?
	REFRESH_ES			
	pop	dx
	or	ax,ax			; set PSW.Z flag
	jz	TypeMatch
NoMatch:
	or	dl,TypeMatchFlag
TypeMatch:
	pop	cx			;Restore target type
	pop	ax			;Restore current type with flag bits
;End of [37] re-write
NoType:
	mov	bx,PTRTX[di+2]		;Get oTx to end of argument

;ax = current type, high bits set
;bx = oTx of end of argument
;cx = target type (ET_RC ok)
;dx = flags

;Check for consistency between BYVAL, SEG, and CALLS
	test    dh,SegFlag+CallSFlag    ;Specified as segmented?
	jz	AttrOk			;If not, BYVAL would be OK
	test    dh,ByValFlag		;BYVAL and SEG/CALLS?
	jnz     BadType			;Can't have both
AttrOk:

	TestX	ax,ST_Var?		;Is it a variable or expression?
	jz	Expr
;Determine if whole array is being passed
	TestX	ax,ST_Array?		;Is this the actual array reference?
	jnz	NotWhole
	cmp	PTRTX[bx-4],0		;Any indices?
	jnz	NotWhole
;Passing whole array - see if that is what's needed
	test	dh,ArrayFlag+NoParamsFlag
	jnz	WholeArray
BadType:
	mov	ax,MSG_ParmTM
ReportErr:
	call	SsErrorBx
	jmp	short ParamXpop

NotWhole:
	test	dh,ArrayFlag		;Passing whole array?
	jnz	BadType
	test	dh,DefFnFlag+ByValFlag	;Pass by value?
	jnz	Expr
;Handle a variable
	test	dl,TypeMatchFlag	;Types match?
	jnz	BadType
	test	dh,FarArg		;SEG specified?
	jz	MakeSafeRef
;Passing by far reference.  Disable any copying of arguments,
;allowing user to screw himself with far heap movement.
	add	[SsCbParmCur],2		;Add 2 bytes to parm size
	mov	[SsOtxHeapMove],0	;Tell SsRefArg there's no heap movement
MakeSafeRef:
	call	SsRefArg
	mov	[SsOtxHeapMove],di	;Make sure we know we moved
ParamXpop:
	pop	ax			;Leave oRS of decl. in ax
	ret

CountSize:
	cmp	cx,ET_SD		;Don't allow string with ByVal
	jae	BadType 		;Error if string or form
	dec	ax
	dec	ax			;Already assumed near ref.
	add	[SsCbParmCur],ax
	mov	ax,codeOFFSET exR8ToStack
	sub	cx,ET_R8		; Is this an R8 ByVal param?
	    jz	    @F			; Brif yes, insert
	    .erre   ET_R4 EQ ET_R8-1	
	    inc     cx			; Is this an R4 ByVal param?
	    jnz     ParamXPop		; Brif not, no work to do
	    mov     ax,codeOFFSET exR4ToStack
@@:					
InsertExit2:
	call	Insert			; Insert executor to move to 8086
	jmp	short ParamXPop

WholeArray:
	test	dl,TypeMatchFlag	;Types match?
	jnz	BadType

	;Convert AIdLd to AdRf

	call	MakeArrayRef		
	jmp	short SegCheck

Expr:
	test	dh,ArrayFlag		;[J2] Is a whole array expected?
	jnz	BadType 		;[J2] Brif so
	cmp	cx,ET_MaxStr		;Is this numeric or string?
	ja	BadType			;Can't pass expr. to field/form/menu


	;If no type checking is enabled for this parameter, then fixed
	;strings will come here with an invalid target type of fixed
	;string or fixed text.	In this case, the target is converted to
	;variable string (ET_SD) to force the correct handling of temp
	;string arguments.  Using ET_SD is safe in FV_TEXT products
	;because the representation of Text and String are identical
	;as is the handling by this code.

	    .erre   ET_FS EQ ET_MaxStr	
	jb	@F			; Brif not ET_FS
	mov	cx,ET_SD		; Ok for ET_FT also
@@:

	push	dx
	push	cx			;Remember target type
	call	SsCoerceReg		;bx will be updated if coercion performed
	pop	cx
	pop	dx			;Recover flags bits
	mov	ax,cx			;oTyp to ax
	call	CbTypOTypSCAN		; AX = Size of this type
	test	dh,ByValFlag		;Passing by value?
	jnz	CountSize		;Done, but add up size of params
	    push    cx
	call	AllocTemp		;oTemp in cx, oTyp in ax
	xchg	ax,bx			;Type to bx, oTx in ax
	shl	bx,1			;Make it a word index
	mov	bx,[bx].tTmpType-2	;Get temp executor for this type
	xchg	ax,bx
	call	Insert1Op
	pop	ax			;Recover type
	cmp	al,ET_SD		;String?
	jne	SegCheck		;If not, go see if SEG specified
;Insert executor to delete string data
	mov     ax,codeOFFSET exDelTmpSD
;ax has executor, cx has oTemp
	push    bx
	mov     bx,di
	call    Insert1Op
	pop     bx
SegCheck:
	    test    dh,FarArg
	    jz	    ParamXPop
	    add     [SsCbParmCur],2	;Add 2 bytes to parm size
	    mov     ax,codeOFFSET exPushSeg ;Executor to add segment
	    jmp     short InsertExit2	; Insert opNoList0 and exit
@@:
	jmp	short ParamXPop

	;Added with [37]


	;End of [37]



DbPub	GetDecl 			
GetDecl:
;Get ds:si to point to procedure's declaration given pPRS in bx
;Returns oRS of declaration in ax
	mov	si,PTRRS[bx].PRS_oTxDef ; oText of declaration
	add	si,DCL_atr+2		;Position of attributes field
	mov	ax,PTRRS[bx].PRS_oRsDef ; Get oRs of decl.
	test	dh,DefFnFlag
	jz	GetDecSeg
	test	PTRRS[bx].PRS_flags,FP_DEFSCANNED ; Has definition been scanned?
	jnz	ValidDefFn
	xchg	ax,bx			;[J2] Save oRs across call to SsError
	mov	ax,ER_UF		;Undefined function
	xchg	si,PTRTX[di]		;[J2] Restore source pointer
	call	SsError
	xchg	si,PTRTX[di]		;[J2] Resave source pointer
	xchg	ax,bx			;[J2] restore AX = oRs
ValidDefFn:
	inc	si
	inc	si			;Skip over link field in DefFN
GetDecSeg:
	mov	bx,ax

GetDeclSeg:
;Get segment of text table into ds given oRS in bx.
;Inputs:
;	es:bx = pRS
;Outputs:
;	ds = segment of text table
;	es = text segment for scanning
;Preserves:
;	ax,cx,dx
	cmp	bx,[grs.GRS_oRsCur]	;Is it current?
	jz	CurText
	cmp	bx,[grs.GRS_oMrsCur]	;Current MRS?
	jz	IsMrsCur
	or	bx,bx
	jns	GetMRS
	and	bh,7Fh			;bx = oPrs
	lea	bx,[bx].PRS_txd.TXD_bdlText_seg		
	jmp	short SetDS		;	

IsMrsCur:
	test	[txdCur].TXD_flags,FTX_mrs ;does prs have a text table?
	jne	CurText 		;brif not, txdCur is for Mrs.
	mov	bx,dataOFFSET mrsCur.MRS_txd.TXD_bdlText_seg	
	jmp	short SetDS_2		;[5]

GetMRS:
	lea	bx,[bx].MRS_txd.TXD_bdlText_seg		
	jmp	short SetDS		;	

CurText:
	mov	bx,dataOFFSET txdCur.TXD_bdlText_seg	
SetDS_2:				;[5]
	SETSEG_EQ_SS  es		; set es = ds if Rs table is far
	jmp	short SetDS_1		;[5]
SetDS:					
	    RS_BASE add,bx		
	GETRS_SEG es,bx,<SIZE,LOAD>	;[9]
SetDS_1:				;[5]
	GETSEG	bx,PTRRS[bx],,<SIZE,LOAD> ;[9][5]
	GETSEGTXTCUR			
	mov	ds,bx			
	ret

sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssrec.asm ===
page	49,132
	TITLE	ssrec	- Scan support for records
;***
;ssrec.asm - Scan support for records
;
;	Copyright <C> 1986, Microsoft Corporation
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSREC_ASM = ON
	IncludeOnce	context
	IncludeOnce	pcode		
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr		
	IncludeOnce	variable
	.list


assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA

extrn	oVarOfRetVal:far		

sBegin	CODE				

	extrn	exSave87:near		
	extrn	exNop0:near		

sEnd	CODE				


sBegin	SCAN
assumes cs, SCAN

subttl	Ss_Off
page
;***
;Ss_Off<Ld|St> - Scan record offset ID's
;Purpose:
;	Scan the id variants opOff<Ld|St>.
;
;******************************************************************

SsProc	OffLd,rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	@F				    
	mov	dx,scanOFFSET mpOffLdImpOpExe	    
@@:						    
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si]		    ; BX = pElem

	mov	cx,[bx].ELEM_oTyp	;CX = oTyp
MapOffLd:
	call	SsIndexTypeCx		;DX = executor address based on oTyp
	call	SsEmitExecutor		;Also restores DS if SizeD
assumes ds,DATA				
	pop	ax			;Get old type
	.errnz	LOW ST_ArrayBit 	; Assure we can use AH
	and	ah,HIGH ST_ArrayBit
	or	ch,ah			;Remember if it came from array
	.errnz	LOW ST_RecVar		; Assure we can use CH
	or	ch,HIGH ST_RecVar
	pop	ax			;Clean off old insertion address
	push	di			;oTx for coercion insertion
	push	cx			;oTyp of record element or ET_RC
	jmp	[ScanRet]



SsProc	OffSt,rude
	.erre	LOW OPCODE_MASK EQ 0ffh 	    
	test	byte ptr es:[si-1],HIGH (NOT OPCODE_MASK)
	jnz	@F				    
	mov	dx,scanOFFSET mpOffStImpOpExe	    
@@:						    
		mov	bx,[MrsCur.MRS_bdVar.BD_pb] 
	    add     bx,PTRTX[si]		    ; BX = pElem

	mov	cx,[bx].ELEM_oTyp	;CX = oTyp of element
	call	SsIndexTypeCx		;DX = executor address based on oTyp
					;CX = scan stack oTyp of variable
	jcxz	NeedOtyp		;Is it a record?
HavOtyp:				

		add	sp,4			; Remove parent stack frame

	call	SsEmitExecutor		;Also restores DS if SizeD
assumes ds,DATA				

	xchg	ax,cx			; AX = oTyp of target element
	call	EnsureArgType		; Pop stack frame test for coerce
	jmp	[ScanRet]

NeedOtyp:				
	mov	cx,[bx].ELEM_oTyp	;Get real oTyp for coercion
	jmp	HavOtyp			


	public	mpOffLdImpOpExe
mpOffLdImpOpExe label	word			    
	DWEXT	exOffIRf
	DWEXT	exOffILdI2
	DWEXT	exOffILd4
	DWEXT	exOffILdR4
	DWEXT	exOffILdR8			    
	DWEXT	exOffILdSD			    
	DWEXT	exOffILdFS

	;Rf opcodes for numeric & FS types

OffLdtoRfMap=	$-mpOffLdImpOpExe

mpOffIRf    label   word			    ;[10]
	DWEXT	exOffIRf
	DWEXT	exOffIRf
	DWEXT	exOffIRf
	DWEXT	exOffIRf
	DWEXT	exOffIRfSD			    
	DWEXT	exOffIRfFS

RfCnt	=	$-mpOffIRf			    

	;Note:	The following word is used by MakeRef to
	;find the implicit map from the explicit map.

	DW	mpOffLdImpOpExe 		    

	public	mpOffLdExpOpExe
mpOffLdExpOpExe label	word			    
	DWFILL					    
	DWEXT	exOffELdI2
	DWEXT	exOffELdI4
	DWEXT	exOffELdR4
	DWEXT	exOffELdR8
	DWEXT	exOffELdSD			    
	DWEXT	exOffELdFS

	;Rf opcodes for numeric & FS types

	.erre	OffLdtoRfMap EQ ($-mpOffLdExpOpExe) 

mpOffERf    label   word			    
	DWEXT	exOffERfI2
	DWEXT	exOffERfI4
	DWEXT	exOffERfR4
	DWEXT	exOffERfR8
	DWEXT	exOffERfSD			    
	DWEXT	exOffERfFS
	.erre	RfCnt EQ ($-mpOffERf)		    

mpOffStImpOpExe label	word			    
public	mpOffStImpOpExe
	DWEXT	exOffIStTyp
	DWEXT	exOffIStI2
	DWEXT	exOffISt4
	DWEXT	exOffIStR4
	DWEXT	exOffIStR8			    
	DWEXT	exOffIStSD			    
	DWEXT	exOffIStFS


	public	mpOffStExpOpExe
mpOffStExpOpExe label	word			    
	DWFILL					    
	DWEXT	exOffEStI2
	DWEXT	exOffEStI4
	DWEXT	exOffEStR4
	DWEXT	exOffEStR8
	DWEXT	exOffEStSD			    
	DWEXT	exOffEStFS



page
;***
;MakeRef - Turn Id/Off Ld into Rf
;
;   Converts IdLd, AIdLd, and OffLd executors to Rf variants.
;   Record types are already Rf's so they're not changed.
;
;Inputs:
;	ax = Type word (from stack) of operand
;	bx = oTx of word after opcode to convert
;Outputs:
;	ax = New Id/Off Rf executor (if no error)
;Preserves:
;	bx,cx,dx,es
;Modifies:
;	none

public	MakeRef
extrn	IdLdtoRfMap:abs,GetCxISFC:near

RefArgErrPop:
	pop	ax
RefArgError:
	mov	ax,ER_VarReq
	call	SsErrorBx
	jmp	SameEx

MakeRef:
	push	bx			
	push	cx
	push	dx			;save caller's dx
	TestX	ax,ST_Var?		;Is it a variable?
	jnz	RefVariable
;Not a variable. Check to see if it's a function return value.
;Note that [bx-2] has the oVar, and [bx-4] is either the opcode (if simple
;IdLd) or the count of indices (if AIdLd).  AIdLd would imply a function
;call with arguments, and is never legal here.  The max number of arguments
;is 64, but the none of these executors are in the first 64 bytes of their
;segment.  Thus by comparing [bx-4] with 64 we can determine if it is a count
;of indices or an executor, that is, whether it is an AIdLd or IdLd.
	cmp	PTRTX[bx-4],64		;Is it a count of indices or pcode?
	jbe	RefArgError		;Error if count--must be function call
	push	ax			;Save oTyp
	mov	ax,PTRTX[bx-2]		;Get oVar of function
	DbChk	oVar,ax 		;Verify that this is a variable
	push	bx			
	PUSH_ES 			
	call	oVarOfRetVal		;Convert to oVar of return value
	POP_ES				
	pop	bx			
	or	ax,ax			
	js	RefArgErrPop		;Not function return value

	mov	PTRTX[bx-2],ax		;Update oVar
	pop	ax			;Get oTyp back
	.errnz	LOW ST_SimpVar		; Assure we can use only AH
	or	ah,HIGH ST_SimpVar	;Treat function RetVal like simple var.

	;Because this reference was originally handled as a function call,
	;an exSave87 executor was inserted prior to the call.  Not having
	;any parameters, the exSave87 will reside immediately before the
	;call executor.

	DbAssertRel PTRTX[bx-6],e,<codeOFFSET exSave87>,SCAN,<MakeRef: exSave87>
	mov	PTRTX[bx-6],codeOFFSET exNop0	

;This pcode was originally scanned to a recursive function call with no 
;arguments.  This may have generated a delayed Argument Count Mismatch 
;error if this function actually has parameters.  Check to see if it has
;parameters and clean up the error if so.

	cmp	[prsCur.PRS_cwParams],0	;Any parameters on this function?
	je	@F			;If not, no Arg Cnt Err would have occured
	dec	[SsDelayCnt]		;Peel back most recent error
@@:
	    ;A delayed error will also occur if this is a DefFn, caused
	    ;by logic that prevents recursive calls in a DefFn.

	    cmp     [prsCur.PRS_procType],PT_DEFFN  ;In DefFn?
	    jne     RefVariable 	;If not, no error was recorded
	    dec     [SsDelayCnt]	;Peel back the ER_UF error
RefVariable:
	mov	dx,PTRTX[bx-2]		;Get oVar/oElem
	sub	bx,4			;Point to opcode if not array
	TestX	ax,ST_Array?		;Is it array?
	jnz	opPoint
	dec	bx
	dec	bx			;Must back up over another operand
opPoint:
	push	bx			;Save oTx of executor address
	mov	bx,PTRTX[bx]		;Get executor
	GetCodeIntoDs	SCAN		
	mov	bx,[bx-2]		;Get opcode in front of executor
	push	ss
	pop	ds
	mov	cx,bx				    ; Save opcode
	and	bx,OPCODE_MASK			    ; Clear upper bits
	shl	bx,1				    ;Use it as word table index
	mov	bx,mpOpExe[bx]			    ;Executor address map for Ld
	TestX	cx,<NOT OPCODE_MASK>		    ; Implicit?
	jnz	@F				    ; Brif explicit
	mov	bx,word ptr cs:[bx-2]		    ; Fetch implicit map
@@:						    
	xchg	dx,bx				    ;Now dx=map, bx=oVar/oElem
	TestX	ax,ST_Record?			    ;Is it a record?
	jnz	RecVar				    ;Record - no flags
	push	ax
		add	bx,[MrsCur.MRS_bdVar.BD_pb] ; oVar --> pVar
	DbChk	pVar,bx 			    
	mov	cx,RfCnt
	call	GetCxISFC		;Calculate <I|S|F|C> offset from
					;   bx (MSV flags) and oPrsCur
					;Offset returned as modified dx
	pop	ax
	add	dx,IdLdtoRfMap-OffLdtoRfMap ;Shift to Rf map from Ld map
RecVar:
	add	dx,OffLdtoRfMap-2*ET_I2
	pop	bx			;Get oTx of executor
	and	ax,ST_Typ_Mask		; Clear flag bits
	.erre	ET_RC EQ 0		; Assure JZ is sufficient
	jz	SameEx			; Brif record. Ex is already an Rf
MapRef:
	add	dx,ax			;1 word per type in table
	add	dx,ax
	xchg	bx,dx
	mov	ax,WORD PTR cs:[bx]	;Load executor
	xchg	dx,bx
	mov	PTRTX[bx],ax		;Set new opcode
SameEx:
	pop	dx			;restore caller's dx,cx
	pop	cx
	pop	bx			
	ret

sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssrefarg.asm ===
page	49,132
	TITLE	ssrefarg - Scan pcodes for executors that require Rf Arguments
;***
;ssrefarg - Scan pcodes for executors that require Rf Arguments
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   The pcodes scanned by this module have executors that require the
;   address of a variable as an argument.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSREFARG_ASM = ON
	IncludeOnce	context
	IncludeOnce	qbimsgs
	IncludeOnce	rtps
	IncludeOnce	ssint
	IncludeOnce	variable
	.list


assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA

subttl	opcode to executor maps for opcodes with executors with Rf Args
page
;These tables are used by scan routines to map opcodes to executors.

sBegin	SCAN
assumes cs, SCAN


;INPUT Statement
PUBLIC	mStInputOpExe
mStInputOpExe:
mStInputFirst:
	DWEXT	exStInputI2
	DWEXT	exStInputI4
	DWEXT	exStInputR4
	DWEXT	exStInputR8
	DWEXT	exStInputSD
	DWEXT	exStInputFS		    ;In the table twice for easy mapping

;Table index offset for near references
omNear	= $ - mStInputFirst

	DWEXT	exStInputI2Near
	DWEXT	exStInputI4Near
	DWEXT	exStInputR4Near
	DWEXT	exStInputR8Near
	DWEXT	exStInputSD		    ;In the table twice for easy mapping
	DWEXT	exStInputFS


	;READ Statement

	public	mStReadOpExe
mStReadOpExe:
	DWEXT	exStReadI2
	DWEXT	exStReadI4
	DWEXT	exStReadR4
	DWEXT	exStReadR8
	DWEXT	exStReadSD
	DWEXT	exStReadFS

	DWEXT	exStReadI2Near
	DWEXT	exStReadI4Near
	DWEXT	exStReadR4Near
	DWEXT	exStReadR8Near
	DWEXT	exStReadSD
	DWEXT	exStReadFS




	;Maps for LSET/RSET/MID use LSB only for indexing

	;LSet

	public	mStLsetOpExe
mStLsetOpExe:
	DWEXT	exStLset,
	DWEXT	exStLsetFS

	;RSet

	public	mStRsetOpExe
mStRsetOpExe:
	DWEXT	exStRset
	DWEXT	exStRsetFS

	;Mid$

	public	mStMid_2OpExe
mStMid_2OpExe:
	DWEXT	exStMid_2
	DWEXT	exStMid_FS2

	;Mid$

	public	mStMid_3OpExe
mStMid_3OpExe:
	DWEXT	exStMid_3
	DWEXT	exStMid_FS3
					

	;Swap


	public	mStSwapOpExe
mStSwapOpExe	label	word
	DWEXT	exStSwapTyp
	DWEXT	exStSwap2
	DWEXT	exStSwap4
	DWEXT	exStSwap4
	DWEXT	exStSwap8
	DWEXT	exStSwapSD


sEnd	SCAN

sBegin	DATA

oTxInputType	DW (?)
cInputType	DW 0

sEnd	DATA

sBegin	CODE

	extrn	exPushOp:near
	extrn	exStLSetRec:near
	extrn	exFnLenTyp:near
	extrn	exStLineInputFS:near
	extrn	exAddStack:near 	;Add constant to sp


sEnd	CODE

sBegin	SCAN
assumes cs, SCAN

	subttl	Ss_FPutGet<2|3>
	page
;***
;Ss_FPutGet<2|3>
;Purpose:
;	Scan file PUT and GET varients that require an Rf
;
;	Special tasks include:
;	- make the variable an Rf
;	- Make sure the Rf will result in a far address
;	- emit the size of the variable as an operand
;Input:
;	standard scanner entry
;Output:
;	standard scanner exit
;
;*******************************************************************************
SsProc	FPutGet3
	call	FPutGetCom
	mov	ax,ET_I4
	call	EnsureArgType		;Ensure stack has an I4 variable
	jmp	short FPutGetI2

SsProc	FPutGet2
	call	FPutGetCom
FPutGetI2:
	mov	ax,ET_I2
	call	EnsureArgType		;Ensure stack has an I2 variable
	jmp	[ScanRet]		;And back to main loop

;***
;FPutGetCom
;Purpose:
;	Emit the executor
;	Make stack variable an Rf
;	Make sure the Rf will result in a far address
;	Emit the stack variable size as the operand
;Input:
;	ax = executor
;Output:
;	none
;
;*******************************************************************************

FPutGetCom:
	STOSWTX 			    ;Emit executor
	inc	si
	inc	si			    ;Skip source side SIZE operand
	pop	dx			    ;Get return address
	pop	ax			    ;Get oType
	pop	bx			    ;  and oTx
	push	dx			    ;Put return address back
	mov	dx,ax			    ; DX = oTyp w/flags
	.erre	ST_Typ_Mask EQ 0ffh	    ; Assure we can use AL
	cmp	dl,ET_SD		    ;SD/TX/FS/FT handled special
	jb	NotString		    ; Brif not a string type
	xor	ax,ax			    ;Signal SD with length of zero
	.erre	ST_Typ_Mask EQ 0ffh	    ; Assure we can use DL
	cmp	dl,ET_FS		    ; FS/FT?
	jb	GotSize 		    ; Brif not fixed
	dec	ax			    ;Signal FS with length FFFF
	jmp	short GotSize		    

NotString:				    
	call	GetTypeSize		    ;AX = size, CX = oTyp of variable
GotSize:				    
	STOSWTX 			    ;Emit size
	xchg	ax,dx			    ;AX = oTyp from scan stack
	    mov     dh,FarArg+FScb+Lvalue   ;Signal that it's far, real ptr to FS
	    jmp     SsRefArg		    ;Make a reference argument

;***
;GetTrueType
;Purpose:
;	Get the true type and size of a variable whose scan stack entry is 
;	in ax/bx.
;
;Input
;	ax - type word from scan stack
;	bx - oTx of oVar from scan stack
;Output:
;	cx = True oTyp of variable
;Preserves:
;	ax,bx,dx
;
;***************************************************************************

	;Added with [11]

	public	GetTrueType
GetTrueType:
	mov	cl,al
	mov	ch,0			;Set up type in cx
	jcxz	RecordType		;If not record, that's all there is
	ret

RecordType:
	push	bx
	    mov     bx,PTRTX[bx-2]	;Load oVar/oElem
	    add     bx,[mrsCur.MRS_bdVar.BD_pb] ;Dereference
	mov	cx,[bx].VAR_oTyp	;Assume oVar
	TestX	ax,ST_Record?		;oVar or oElem?
	jz	@F			;Not record variable
	mov	cx,[bx].ELEM_oTyp
@@:
	pop	bx
	ret

	;End of [11]

;***
;GetTypeSize
;Purpose:
;	Get the true type and size of a variable whose scan stack entry is 
;	in ax/bx.
;
;Input
;	ax - type word from scan stack
;	bx - oTx of oVar from scan stack
;Output:
;	ax = size
;	cx = true type
;Preserves:
;	bx,dx
;***************************************************************************
GetTypeSize:

	push	bx				
        mov     bx,PTRTX[bx-2]			; Load oVar/oElem
	add     bx,[mrsCur.MRS_bdVar.BD_pb] 	; Dereference

	TestX	ax,ST_Var?			; Is this a Var or Const?
	jz	@F				; brif const

	TestX	ax,ST_Record?			; oVar or oElem?
	jz	@F				; Brif not record variable
	mov	ax,[bx].ELEM_oTyp		
	mov	cx,ax				; CX = oTyp
	call	CbTypOTypSCAN			;[15]
	jnz	GotTypeSize			; Brif Fixed string
	mov	ax,[bx].ELEM_cbFixed		; Get correct size
	jmp	short GotTypeSize		;[J2] Go get the size and exit

@@:						
	DbChk	pVar,bx 			; Verify this is a variable
	GetOtyp ax,[bx] 			
	mov	cx,ax				; CX = oTyp
	call	CbTypOTypSCAN			;[15]
	jnz	GotTypeSize			; Brif Fixed string
	mov	ax,[bx].VAR_cbFixed		; Get correct size
GotTypeSize:					
	pop	bx				
	ret					


	subttl	Ss_LRSetMid
	page
;***
;Ss_LRSetMid
;Purpose:
;*******************************************************************************

SsProc	Lset
	xchg	cx,ax			;exe map address to cx
	pop	ax			;AX = oTyp of LHS
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	.erre	ET_RC EQ 0		; Assure OR/JNZ is sufficient
	or	al,al			; Is this a record?
   DJMP jnz	LRSetMid		; Brif not a record

	;LSET for records

	pop	bx			; BX = oTx of LHS
	call	GetTypeSize		; AX = Size, CX = oTyp
	DbAssertRel cx,a,ET_MAX,SCAN,<Ss_Lset: LHS should be a record>	  
	xchg	ax,dx			; DX = Size of LHS
	pop	ax			;AX = oTyp of RHS
	pop	bx			; BX = oTx of RHS
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	.erre	ET_RC EQ 0		; Assure OR/JZ is sufficient
	or	al,al			; Is this a record?
	call	TMErrorNZ		; Error if not a record

	push	ax			; Save oTyp on stack
	call	GetTypeSize		; AX = Size, CX = oTyp
	xchg	ax,cx			; CX = Size of RHS
	pop	ax			; Restore oTyp w/flags
	    push    dx			; MakeFarRef trashes dx
	    call    MakeFarRef
	    pop     dx			

	cmp	cx,dx			;Need smallest byte count
	jb	@F			
	xchg	dx,cx			;Smallest in CX
@@:					
	mov	ax,codeOFFSET exPushOp	;Executor for pushing operand
	mov	bx,di			;Insert at di
	call	Insert1Op		;Insert executor and operand
	mov	ax,codeOFFSET exStLsetRec
	STOSWTX 			;Emit executor for rec version of LSET
	jmp	[ScanRet]


SsProc	LRSetMid
	xchg	cx,ax			;exe map address to cx
	pop	ax			;AX = oTyp of LHS (Record = ET_RC)
LRSetMid:
	shr	bx,1			;bx = opcode
	mov	bl,mpOpRule[bx] 	;bx = count of integer exp's needed
	xor	bh,bh			
	xchg	bx,cx			;bx = exe map address, cx = rule byte
	mov	dx,ax			;Save copy of oTyp
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	sub	al,ET_SD		; Maps start with ET_SD
	    .erre   ET_FS EQ ET_SD+1	; Assure LSB distinguishes fixed
	    shl     ax,1		; Convert to word offset
	and	ax,2			;[13] String = 0 / Fixed = 2
	add	bx,ax

	mov	ax,cs:[bx]		;Load and emit the executor
	STOSWTX
	pop	bx
	push	bx
	push	dx
	mov	ax,ET_SD
	call	EnsureArgType
	xchg	dx,ax			    ;oTyp to ax
	    mov     dh,Lvalue+FScb+FarArg
	    call    SsRefArg		    ;Make the id an RfId
	mov	ax,ET_SD
	call	EnsureArgType
	jcxz	LRSetMidArg		;No I2 expressions to eat
NextI2:
	mov	ax,ET_I2
	call	EnsureArgType		;Eat an I2 argument
	loop	NextI2			;Go get next I2 arg

LRSetMidArg:
	jmp	[ScanRet]		;and exit to main loop

subttl	Ss_Input
page
;***
;Ss_Input
;Purpose:
;	Scan routine for INPUT and READ
;
;	Algorithm:
;
;	1. Eat an Rf
;	   produce the Rf from an Ld
;
;	3. Copy operands
;*******************************************************************************
SsProc	Input
	xchg	bx,ax		 	;Get exe map address
	pop	ax			;AX = oTyp of operand (Record = ET_RC)
	push	ax

	;Get coercion index for near/far explosion

	    mov     cx,ax		; Save oTyp with flags
	and	ax,ST_Typ_Mask		; Clear scan stack flags
	.erre	ET_RC EQ 0		; Assure JNZ is sufficient
	jnz	InputTypOk		; Brif not a record
	call	TMError
	inc	ax			; Use any valid type (ET_I2)
InputTypOK:
	    .erre   ST_Typ_Mask EQ 0ffh ; Assure we can use CH
	    or	    ch,ch		; Is this an expression?
	    jz	    NearRef		; Expr means fcn RetVal (always near)
	    cmp     ch,HIGH ST_SimpVar	;Is it a far reference?
	    jnz     FarRef		;No special FAR executor
NearRef:				
	    add     ax,omNear SHR 1	;Adjust for near/far explosion
FarRef:
	shl	ax,1			;To word offset
	add	bx,ax
        mov     ax,cs:[bx-2]            ;Load executor
	STOSWTX 			;Emit the executor

	cmp	[cInputType],0		;Is there an active type list?
	jz	NoInPrompt		;Brif not.  Must be Read or Input #n.

	pop	ax			;ax = scan stack variable type entry
	push	ax
	call	RTTypETTyp		;Map ET Type to RT Type
	mov	bx,[oTxInputType]	;oTx of next type byte
	mov	es:[bx],al		;Put current type in type list
	inc	[oTxInputType]		;Move to next type byte
	dec	[cInputType]		;Indicate 1 fewer types
NoInPrompt:
	pop	ax
	pop	bx
	call	MakeRef 		;Make id a Rf type id
	jmp	[ScanRet]


;***
;RTTypETTyp
;Purpose:
;	Map ET types to RT types.
;
;Input:
;	ax = ET type
;Output:
;	ax = RT type
;Preserves:
;	cx,dx
;****************************************************************************
Public	RTTypETTyp
RTTypETTyp:
	mov	bx,SCANOFFSET mRTTyp - 1 ;Adjust for 1 relative indexing
	xlat	cs:[bx]
	ret

	;Runtime constants for ET types

mRtTyp:
	db	VT_I2			
	db	VT_I4			
	db	VT_R4			
	db	VT_R8			
	db	VT_SD			
	db	VT_SD			; Pass SD type for FS


	subttl	Ss_Swap
	page
;***
;Ss_Swap
;
;	When swapping FS types, they are always assigned to temporary SD
;	variables in the stack.  This costs nothing if one of arguments was
;	SD, the other FS.  If both were FS, this should only be done if
;	evaluation of the second argument could cause heap movement
;	(invalidating the pointer to the first arguement).  However, the
;	existing mechanism cannot determine if this is the case--all FS 
;	operations are assumed to cause heap movement.  So SD is always used.
;
;*******************************************************************************


	.errnz	SizeD			; Won't work in SizeD

SsProc	Swap
	inc	si
	inc	si			;Ignore operand to opStSwap
	pop	ax			;AX = oTyp of 2nd arg (Record = ET_RC)
	push	ax			; Restore oTyp
	mov	dh,FarArg+Lvalue	;Assume far references are desired
	cmp	al,ET_MaxNum		;Is this a numeric or record operand?
	jbe	@F			;Brif yes, use far executor
	mov	al,ET_SD		;Use SD for FS
	mov	dh,Lvalue		;Create near references
@@:
	;Look up executor for oTyp in al

	cbw				; Clear flags
	xchg	bx,ax			;For indexing into executor table
	shl	bx,1			;Index by words
	mov	ax,mStSwapOpExe[bx]	
	STOSWTX 			;Emit executor
	pop	ax			;AX = oTyp of 2nd arg (Record = ET_RC)
	pop	bx			;BX = oTx of 2nd argument
	push	ax			; Save oTyp w/flags on stack
	call	GetTypeSize		; AX = Size, CX = oTyp of 2nd arg
	STOSWTX 			; Emit length (ET_RC) or garbage
	pop	ax			; AX = oTyp w/flags of 2nd arg
	cmp	al,ET_FS		; Is 2nd arg a fixed string?
	jb	@F			; Brif not
	.erre	ET_SD EQ ET_FS-1	
	dec	cx			; Use SD for FS
@@:
	call	SsRefArg		;Make reference to 2nd arg

	pop	ax			;AX = oTyp of 1st arg (Record = ET_RC)
	pop	bx			;BX = oTx of 1st argument
	push	ax			;Save oTyp w/flags
	push	dx			; Save SsRefArg flags
	mov	dx,cx			; DX = oTyp of 2nd argument
	call	GetTrueType		; CX = oTyp of 1st argument
	cmp	al,ET_FS		; AX is preserved across GetTrueType
	jb	@F			
	.erre	ET_SD EQ ET_FS-1	
	dec	cx			; Use SD for FS
@@:
	cmp	cx,dx			; Types match?
	call	TMErrorNZ
	pop	dx			; Restore SsRefArg flags
	pop	ax			;AX = oTyp w/flags of 1st argument
	call	SsRefArg		;Make reference to 1st arg
	jmp	[ScanRet]		; and exit to scan loop


	subttl	Ss_LineInput
	page
;***
;Ss_LineInput
;Purpose:
;**********************************************************************

SsProc	LineInput
	pop	bx			;BX = oTyp of input variable w/flags
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use BL
	cmp	bl,ET_FS		; Is this fixed ?
	jb	@F			; Brif not fixed
	mov	ax,codeOFFSET exStLineInputFS
@@:
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use BL
	cmp	bl,ET_SD		; Does type match the SD executor?
	jae	@F			; Brif input variable is a string
	call	TMError 		
@@:
	STOSWTX
	LODSWTX 			;Pick up the operand
	STOSWTX 			; and emit it
	xchg	ax,bx			;AX = oTyp of input variable w/flags
	pop	bx			;BX = oTx of input variable
	    mov     dh,Lvalue+FScb
	    call    SsRefArg		;Make the id an RfId
	test	word ptr es:[si-2],FINP_Prompt	;Test for another SD arg
	jz	@F			;Exit - all done
	pop	ax			;Discard oTyp of prompt
	pop	ax			;Discard oTx of prompt
@@:
	jmp	[ScanRet]		;Continue

subttl	Ss_InputPrompt
page
;***
;Ss_InputPrompt
;Purpose:
;**********************************************************************

SsProc	InputPrompt
	STOSWTX 			;Emit executor
	LODSWTX 			;Load count
	STOSWTX 			; and emit it
	mov	cx,ax			;Save count in CX
	LODSWTX 			;Load prompt
	STOSWTX 			; and emit it
	TestX	ax,FINP_Prompt		;Test for SD prompt argument present
	jz	@F
	pop	ax			;Discard oTyp of prompt
	pop	ax			;Discard oTx of prompt
@@:
	mov	ax,di
	dec	ax
	mov	oTxInputType,ax ;Save address of first type byte
	dec	cx		;Account for flag byte
	mov	cInputType,cx	;Save number of types
	shr	cx,1		;Round to words, 1st type was already copied

	    cli				; Double prefix! No interrupts!
	rep	movs	PTRTX[si],PTRTX[di]	; Copy remaining operands
	    sti 			
	mov	[SsOTxStart],di 	; In case of exSave87 insertion
	jmp	[ScanRet]		


subttl	VARPTR & SADD
page
;***
;Ss_Sadd
;*********************************************************************


SsProc	Sadd
	STOSWTX
	pop	ax			;Get oTyp
	pop	bx			;Get oTx
	mov	cx,ET_I2		;Function return type
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	    cmp     al,ET_FS		;[7] FS/FT ?
	    je	    CantUseFS		; Special message for that case
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_SD		
	    .erre   ET_FS EQ ET_SD+1	
	jae	MakeArg 		
SaddTM: 				
	call	TMError 		; Must be SD
MakeArg:
	    xor     dh,dh		; For SsRefArg: near, not FS, not Lvalue
	    call    SsRefArg
RetEntry:
	push	di			;oTx
	push	cx			;Function return type
	jmp	[ScanRet]

CantUseFS:
	mov	ax,MSG_InvFixStr
	call	SsErrorBx
	pop	ax			
	jmp	short RetEntry

SsProc	Varptr				    ;Varptr, Varseg
	STOSWTX
	pop	ax			    ;Get oTyp
	pop	bx			    ;Get oTx
	    mov     dh,FarArg+FScb
	    call    SsRefArg
	    test    dh,FScb		;Was it FS? (FScb reset by SsRefArg if not)
	    jz	    SetFuncI2
	mov	cx,2			;Clean 2 bytes off stack (length of FS)
	mov	ax,codeOFFSET exAddStack
	call	Insert1Op
SetFuncI2:
	mov	cx,ET_I2
	jmp	short RetEntry

SsProc	Varptr$
	STOSWTX
	pop	ax
	mov	cx,ax			;Save oTyp w/Flags
	and	ax,ST_Typ_Mask		; Clear flags
	.erre	ET_RC EQ 0		; Assure JNZ is sufficient
	jnz	MapToRT 		
	call	TMError
	inc	ax			; Leave something valid (ET_I2)
MapToRT:
	call	RTTypETTyp		;Map to runtime type
	STOSWTX				;Runtime type is operand
	inc	si
	inc	si			;Skip source operand
	pop	bx			;oTx of argument
	xchg	ax,cx			;Restore oTyp to ax
	mov	cx,ET_SD		;Result type
	TestX	ax,ST_Var?		;Is it a variable?
	jz	MakeArg			;If not, let SsRefArg sort it out
	TestX	ax,ST_Array?		;Is it array?
	jnz	MakeArg 		;No

	;Have an array.  Only SD arrays allowed.

	cmp	ax,ST_ArrVar+ET_SD	;Is it SD array?
	jz	MakeArg			;SD array is OK
	push	ax
	mov	ax,MSG_NoNumArr
	call	SsErrorBx		;Argument can't be far array
	pop	ax
	jmp	short MakeArg


	subttl	Ss_FnLen
	page
;***
;Ss_FnLen
;Purpose:
;**********************************************************************

SsProc	FnLen
	inc	si
	inc	si			    ;Eat source operand
	pop	ax			    ;AX = oTyp of operand
	pop	bx			    ;BX = oTx of operand

	.erre	ST_Typ_Mask EQ 0ffh	    ; Assure we can use AL
	    cmp     al,ET_SD		    ;Is this a string
	    je	    FnLenSd		    ;Brif operand is a string
	    cmp     al,ET_FS		    ;Is this a string
	    je	    FnLenSd		    ;Brif operand is a string


	;Note:	The test of whether the operand is an expression is bypassed
	;for strings since string expressions are valid operands.  However,
	;numeric expressions and not valid.

	TestX	ax,ST_Var?		    ; Is this a variable?
	jz	NotAVar 		    ; Brif not

	mov	dx,ax			    ;DX = oTyp of operand
	call	GetTypeSize		    ;AX = Size of operand
	xchg	cx,ax			    ;Preserve size in cx
	xchg	ax,dx			    ;oTyp w/flags to ax

	;MakeRef is called to convert the operand load to an operand reference.
	;Having a reference allows a single executor to be used for all types
	;without having to worry about the size of the expression on the stack.


	    call    MakeFarRef
	mov	dx,codeOFFSET exFnLenTyp
	    mov     ax,ET_I4		    ;Result type for non-strings is I4
	    jmp     short EmitFnLen
FnLenSD:
	    mov     ax,ET_I2		    ;Result type for strings is I2
EmitFnLen:
	xchg	ax,dx			    ;AX = Executor, DX = Result type
	STOSWTX 			    ;emit executor...
	xchg	ax,cx
	STOSWTX 			    ;...and operand
	push	di			    ;Scan stack - expression address
	    push    dx			    ;Push result type
	jmp	[ScanRet]

NotAVar:				    
	mov	ax,ER_VarReq		    ; Len() accepts a Var or ST exp
	call	SsError 		    
	jmp	FnLenSD 		    ; Return to emit executor


page
;*** SsRefArg - Pass argument by reference
;
;Purpose:
;	Parser-generated pcode can only load (IdLd/AIdLd) arguments,
;	not generate addresses for them.  In order to pass by reference,
;	those pcodes are changed to a sequence of executors that
;	produce the near or far address of the argument.
;
;	A major "gotcha" is that while calculating subsequent arguments,
;	the heap could move, invalidating the references already on the
;	stack.  This applies only to (and all) array elements.  The
;	solution to this problem is to insert additional executors that
;	copy the element to a temporary which can't move.  To
;	determine when this is necessary, the scanner keeps the oText
;	of the last place that could cause heap movement in otxHeapMove.
;	If the argument be converted to a Rf is before this, then it
;	is susceptible to the heap movement problem.
;
;	The temporaries used are normally allocated out of the stack.  The
;	exception is an SD which does not return a value (R-value).  This
;	type is copied to a string temp, which is deallocated automatically
;	by the runtime at its first use.  If the lifetime of the temp SD
;	would be too short, the caller to SsRefArg must insert a copy executor.
;
;	Some references are L-values, i.e., they need to return a value.
;	If the argument is copied to a stack temp, and must also return
;	a value, then an additional executor is inserted at the current
;	scan position (presumably after the CALL we're preparing arguments
;	for) to copy the value back to its source.
;
;	Some Rf executors naturally produce near refs, and some do far
;	refs.  Appropriate executors are inserted after the Rf to convert
;	it to the proper type if possible.  In the case of a near ref to
;	huge array element, the element must be copied (just as if the
;	heap could move) to make it near.
;
;	There are two ways to reference FS types:  1) as near ref to an SD
;	2) as a far ref to FS with length.  Which method is determined by
;	the FScb flag: non-zero means use far ref with length ("cb").
;	NO COPYING IS EVER DONE FOR FScb (because it would only be needed
;	by SWAP).  When an L-value FS is referenced as an SD, executors will
;	assign the FS to a stack SD variable.  It cannot be left as IdLdFS,
;	which produces a string temp, because the temp would be deallocated 
;	on its first usage, which is undesirable for an L-value.  For R-value 
;	FS, the reference is left as a temp SD.
;
;Inputs:
;	ax = Type of argument from scan stack
;	bx = oTx of end of argument
;	dh = Type of ref required (optimized for SsProc)
;		FarArg <> 0 means far
;		Lvalue <> 0 means L-value
;		FScb <> 0 means far ref with length for FS
;Outputs:
;	bx updated to end of argument after any insertions
;	dx almost preserved: FScb bit in dh reset if not FS
;Preserves:
;	cx

	public	SsRefArg

	extrn	exCopyTmpAr:near,exRestoreTmpAr:near
	extrn	exCopyTmpArSD:near,exRestoreTmpArSD:near
	extrn	exCopyTmpArFS:near,exRestoreTmpArFS:near
	extrn	exCopyTmpFS:near,exRestoreTmpFS:near
	extrn	exPopPopPush:near
	extrn	exStringTemp:near
	extrn	exPushSeg:near	;executor to coerce near reference to far ref.

CheckFS:
	test	dh,Lvalue+FScb		;Zero means R-value, not FScb
	jnz	Ref			;If L-value or FScb, go process FS
SegCheckJ:
	jmp	SegCheck

MakeFarRef:
	mov	dh,FarArg		;Signal that it's far
SsRefArg:
	push	cx
	mov	cx,ax			;Save flags
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_FS		; FS type?
	    .erre   ET_FS EQ ET_MAX	; Assure that JAE is sufficient
	jae	CheckFS 		
	and	dh,not FScb		;Not a full FS ref
Ref:
	call	MakeRef			;Convert Ld to Rf
	test	dh,FScb			;FS with length is to left alone
	jnz	RefArgX
	xchg	ax,cx			;Restore type w/flags to ax
	TestX	ax,ST_Var?		;Is it a variable? (else fcn retval)
	jz	SegCheckJ		;Handle retval like simple variable
	TestX	ax,ST_ArrayBit		;Is it an array reference?
	jz	RefArray		;If so, check further
;Not an array reference
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_FS		; Is it a basic type (not incl. FS)?
	    .erre   ET_FS EQ ET_MAX	; Assure that JB is sufficient
	jb	ScalRec 		
;Handle L-value FS (R-value exited through CheckFS)
	mov	ax,4+4+2		;SD, Far address, cb
	call	AllocTemp
	mov	ax,codeOFFSET exCopyTmpFS
	call	Insert1Op
	mov	ax,codeOFFSET exRestoreTmpFS
	jmp	short CopyBack

ScalRec:				
	TestX	ax,ST_Record?		;Is it a "scalar" record element?
	jnz	Rec			; Brif record element
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	or	al,al			; Record?
	.erre	ET_RC EQ 0		; Assure JNZ is sufficient
	jnz	SegCheckJ		; Brif not a record

Rec:
;Rf is far, but item is in DS
;Check whether near or far ref wanted
	test	dh,FarArg
	jnz	RefArgX			;Leave it far
	mov	ax,codeOFFSET exPopPopPush
	call	Insert
RefArgX:
	pop	cx
	ret

RefArray:
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_FS		; Always copy FS
	    .erre   ET_FS EQ ET_MAX	; Assure that JAE is sufficient
	jae	AssignFS
	cmp	bx,[SsOtxHeapMove]	;Followed by heap movement?
	jb	CopyArg 		;Yes, go copy arg

	;Might have to copy anyway if need near ref to far element

	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_SD		;Strings are already near ref
	    .erre   ET_FS EQ ET_SD+1	
	jae	SegCheck		; Go check if seg must be added
	test	dh,FarArg
	jnz	RefArgX			;Leave it far
CopyArg:
	.erre	ST_Typ_Mask EQ 0ffh	; Assure we can use AL
	cmp	al,ET_SD		;Must use assignment for strings
	jae	AssignSD
	call	GetTypeSize		;[11] AX = Size of element
	push	ax			;[11]
	mov	ax,codeOFFSET exCopyTmpAr ;Copy to temp
	mov	cx,8			;Need room for 3 operands
	call	InsertCx
	pop	ax			;Size of element
	jc	RefArgX			;If OME, don't overwrite pcode!
	mov	PTRTX[bx-4],ax		;Save as 2nd operand
	add	ax,8			;Need space for far addr, length, oVar
	call	AllocTemp
	mov	PTRTX[bx-6],cx
	mov	ax,codeOFFSET exRestoreTmpAr
;Back up through pcode to find oVar of array
;ax = executor to insert if copy back needed
;[bx-2] = location requiring oVar operand
;cx = oTemp
;dx = input flags (near/far, L-value/R-value)
	push	ax
	push	bx
	sub	bx,8			;Back up to AIdLd/OffLd
SearchBack:
	sub	bx,4			;Assume backing up over opOffLd
	cmp	PTRTX[bx],64		;Is it a count of indices or pcode?
	ja	SearchBack
        mov     ax,PTRTX[bx+2]          ;Get oVar
        pop     bx
        mov     PTRTX[bx-2],ax          ;Save oVar as operand
	pop	ax
;Will we need to copy back?
	test	dh,Lvalue		;Zero means R-value
	jz	SegCheck		;Don't copy back
CopyBack:
;Now add executor to copy back the value
;ax has executor, cx has oTemp
	push	bx
	mov	bx,di
	call	Insert1Op
	pop	bx
SegCheck:
	test	dh,FarArg
	jz	RefArgX
	mov	ax,codeOFFSET exPushSeg	;Executor to add segment
	call	Insert
RefArgXj:
	jmp	RefArgX

AssignFS:
	mov	ax,codeOFFSET exCopyTmpArFS
	mov	cx,6			;Two operands
	call	InsertCx
	jc	RefArgX
	mov	ax,4+4+2+2		;SD, array position, oVar, cb
	call	AllocTemp
	mov	PTRTX[bx-4],cx		;oTemp is 1st operand
	mov	ax,codeOFFSET exRestoreTmpArFS
FindOVar:
	push	ax
	push	bx
	sub	bx,6			;Point back to end of AIdLd/OffLd
	jmp	SearchBack

AssignSD:
	test	dh,Lvalue		;Copy back needed?
	jz	UseStringTemp
	mov	ax,codeOFFSET exCopyTmpArSD
	mov	cx,6			;Two operands
	call	InsertCx
	jc	RefArgXj
	mov	ax,4+2+2		;SD, array position, oVar
	call	AllocTemp
	mov	PTRTX[bx-4],cx		;oTemp is 1st operand
	mov	ax,codeOFFSET exRestoreTmpArSD
	jmp	FindOVar

UseStringTemp:
;No copy back, so just copy to string temp (automatic deallocation)
	mov	ax,codeOFFSET exStringTemp
	call	Insert
	jmp	SegCheck


public	AllocTemp
AllocTemp:
;Allocate ax bytes of temp space (always even).
;Return oTemp in cx, move old cx to ax
	inc	ax
	and	al,not 1		;Round up to even
	add	ax,[SsCbFrameTemp]	;Get new total of temps
	mov	[SsCbFrameTemp],ax
	neg	ax			;Turn into oBP
	xchg	cx,ax
	ret

sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssrude.asm ===
page	49,132
	TITLE	ssrude - Scan and Descan support routines for SS_RUDE mode
;***
;ssrude - Scan and descan support for SS_RUDE mode
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	Certain opcodes require work to scan from SS_RUDE to SS_PARSE and
;	back.  This module contains most of the dispatched entrypoints
;	for performing this work.
;
;	The connection between scan routines and descan routines is as
;	follows:
;	- Each scan routine is declared with macro SsVProc.  If there is
;	  work required to get to/from SS_RUDE then the optional parameter
;	  "rude" is specified on the SsVProc invocation.  Each scan dispatch
;	  so declared will have the address of the rude mode scan/descan
;	  routine stored in the scanner segment at the SsVProc entrypoint -
;	  SsVProcRude.
;	- The scan and descan main loop will vector through the above address
;	  when the mpOpAtr entry for the opcode indicates that work is required
;	  to get to or from SS_RUDE mode.
;	- The dispatched routine will determine whether the current operation
;	  is scan or descan by branching on PSW.Z.  PSW.Z set indicates
;	  descan from SS_PARSE to SS_RUDE.  PSW.Z clear indicates scan from
;	  SS_RUDE to SS_PARSE.
;
;	Rude scan/descan dispatches are entered with the following convention:
;	ax = oTyp from rule table (for opId's only)
;	cx = opcode
;	dx = pVariable table  (Descan to SS_RUDE only)
;	si = descan source
;	di = descan destination
;	es = text segment
;	PSW.Z set indicates SS_PARSE -> SS_RUDE
;
;       Special Cases:
;	-------------
;	CONSTants
;		When an opStConst statement is seen, we continue scanning
;		IdLd pcodes normally, except that we give an error if 
;		MakeVariable finds one of these that is not already created
;		as a CONSTant.  Each time we find an IdSt pcode, we call
;		ScanAndExec with the pcode expression we've just scanned
;		ScanAndExec calls MakeVariable to create the new CONSTant
;		variable, scans the expression to SS_EXECUTE, executes it
;		(thus storing the value of the expression in the CONSTant),
;		and then descans the expression back to SS_PARSE.
;
;
;*****************************************************************************

	.xlist
	include		version.inc
SSRUDE_ASM	= ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	names
	IncludeOnce	opcodes
;	IncludeOnce	opid
;	IncludeOnce	opmin
	IncludeOnce	optables
	IncludeOnce	parser
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	scanner
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	ui
	IncludeOnce	variable
	.list

;Invoked after calling any function which could cause heap movement
; and thus, movement of the current text table being scanned.
; This macro preserves all registers except ES (including flags)
;
SsRefreshES MACRO
	GETSEGTXTCUR			; ES = current pcode segment,
					; all other registers preserved,
					; including flags
	ENDM


assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA

sBegin	DATA
	globalW	oNamOfPrsCur,UNDEFINED	;Speed optimization for rude scan
					;  set up here, used by varmgr
	staticW	otxConstCur,0		;otx to start of current CONST expr
					;  if scanning a CONST stmt, else 0
	staticW	varFlags_Reset,0	;Normally 0, set to FVI_SHARED, 
					;  FVI_STATIC, FVI_COMMON, FVI_AUTO,
					;  or FVI_PUBLIC whenever one of those 
					;  bits must be temporarily reset
					;  in mkVar.flags by IdLd. 
					;  Always reset by HandleId.
	staticB fErrWithinOp,0		;set to 1 if an error occurred within
					;  the operand of a big opcode (like
					;  opStDeclare), so error can be
					;  reported at the operand.
	staticW spErrorRestore,0	;used for error recovery
sEnd	DATA

sBegin	SCAN
assumes cs,SCAN
page

;***
;SsRudeScan
;Purpose:
;	Move text between SS_PARSE and SS_RUDE.
;
;	This routine dispatches to the same entrypoint for moving
;	text in either direction.  The individual entrypoints must
;	examine PSW to determine which direction to take the current
;	opcode.
;
;	Rude mode register convention is:
;	ax	 = opcode
;	dx	 = mrsCur.MRS_bdVar_pb (if not SizeD)
;	es:si/di = source and destination pointers
;	PSW.Z	   set indicates descan from SS_PARSE to SS_RUDE
;		   reset indicates scan from SS_RUDE to SS_PARSE
;
;	Dispatching is performed for all opcodes.  Table space is
;	conserved by placing the rude dispatch as a prefix to the non-rude
;	scan dispatch entrypoint for the opcode.  Note that this restriction
;	limits the resolution of the rude scan dispatching to that of the
;	standard scan dispatching.  In other words, there are no two opcodes
;	with individual rude dispatches that have a common standard scan
;	dispatch.
;
;	A further space savings is that not all standard scan dispatches
;	have rude dispatch prefixes.  The scan entrypoint declaration macro
;	SsProc has a second parameter that determines whether the rude
;	dispatch is required.  The opcode atribute table mpOpAtr contains
;	a bit (OPA_fSsRude) that indicates to the rude scan loop whether
;	there is work to go to/from SS_RUDE for that opcode.  All opcodes
;	that do not have this bit set are dispatched to a common entrypoint
;	that skips operands to the next opcode.
;
;	The rude scans are wholly space invarient.  The rude scan is
;	a scan in place - it is not necessary for dispatch points to emit
;	text that is not modified (for instance, it is not necessary to
;	emit the opcode).
;
;	Descanning from SS_PARSE to SS_RUDE can cause no errors.
;
;	Scanning from SS_RUDE to SS_PARSE can cause errors.  When a dispatch
;	point finds an error it must:
;	- record the variable in a static variable.
;	- recover the opcode that it is processing to a consistent (RUDE or
;	  PARSE mode state (all operands must be in the same state).
;	- replace the first SS_RUDE mode opcode in the text table with an
;	  opEot.
;	- restart SsRudeScan to descan the pcode up to the opEot.
;	- replace the opEot with the saved opcode.
;	- return, reporting the error.
;
;NOTE:	This is not a recursive scheme; an alternate reentry point is
;	used to descan the pcode, and the opEot detects whether an error
;	has occurred or not. Aside from the above mechanism, this routine
;	is NOT reentrant.
;
;	Error control variables are:
;	SsErrOTx	- text offset of pcode which was replaced by opEot
;				descanner expects this to be UNDEFINED if no
;				error has occured.
;	SsErr		- error code to be returned by scanner.
;	SsErrOpcode	- opcode which was replaced by opEot
;
;Entry:
;	parmW	target scan state (must be SS_RUDE or SS_PARSE)
;Exit:
;	ax == 0  ----> Output registers are the same as for GetTXDInfo
;	ax != 0  ----> ax = error code
;                      [grs.GRS_otxCur] = text offset to error.  If low
;		       bit is set, error is within an operand (like opStSub,
;		       opStDeclare, etc.), so caller can position cursor
;		       exactly to the error token.
;
;************************************************************
cProc	SsRudeScan,<PUBLIC,FNEAR>,<si,di>	
	parmB	TargetState
cBegin

	mov	[spErrorRestore],sp	;in case an error occurs with 
					;  stack in an intermediate state
	sub	ax,ax
	mov	[fErrWithinOp],al
	dec	ax			;ax = UNDEFINED
	mov	[SsErrOTx],ax		;initialize in case we're descanning	
	cmp	[TargetState],SS_RUDE	;Indicate scan or descan
	jz	SsRudeDeScan		;brif descanning to SS_RUDE

	call	OtxDefType0Far		; set all 26 letter default
					;	types to initial default
SkipDT:
	cmp	[grs.GRS_fDirect],FALSE
	jz	Not_Direct		;brif not scanning direct mode buffer

	push	[grs.GRS_otxCONT]	; In direct mode,
	call	OtxDefTypeCurFar	; set all 26 letter defaults to
					; values at the current program counter.
					; If cant CONT (i.e. UNDEFINED), set
					; them to their value at EOT
Not_Direct:
	DbAssertRelB [TargetState],z,SS_PARSE,SCAN,<ssrude: invalid target state>
	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jz	SsRudeScanErr		;brif not scanning a procedure table

	cmp	[grs.GRS_fDirect],FALSE
	jnz	SsRudeScanErr		;ignore prsCur stuff if in Direct Mode

	push	[prsCur.PRS_ogNam]	
	call	ONamOfOgNamFar		;must succeed (as prs already exists)
	DbAssertRel  ax,nz,0,SCAN,<SsRudeScan: [6] ONamOfOgNam returned an error>
	mov	[oNamOfPrsCur],ax	;speed optimization - used by varmgr

	call	MakePrsTVar		;make var hash table for prsCur
	or	ax,ax			;error return?
	jnz	SsRudeScanErr		;  brif not
	
	PUSHI	ax,ER_OM		;insufficient memory - - exit
	jmp	ErrExit

SsRudeDeScan:				;only get here if we're descanning
	DbAssertRelB [grs.GRS_fDirect],z,FALSE,SCAN,<ssrudedescan: fDirect TRUE>
	;don't want to reset otxCONT when dealing with the Direct Mode buffer,
	;  so we're counting on the fact that we never descan the D.M. buffer
	mov	[grs.GRS_otxCONT],UNDEFINED
					;ensure this is correctly set whenever
					;  we descan any text table
SsRudeScanErr:				;reentry point in case of scan error
	SsRefreshES			;es = cur pcode seg (heap movement)
	mov	dx,[mrsCur.MRS_bdVar.BD_pb] ;Address of variable table
	SetStartOtx	si		;Start scan from the top
	mov	di,si			;Destination = source

RudeLoop:
	LODSWTX 			;Pick up opcode
	mov	bx,ax
	and	bx,OPCODE_MASK		; ax is actual opcode, bx is
					; masked opcode
	DbAssertRel	bx,be,op_max,SCAN,<Rude Scan Loop: opcode out of range.>
	DbAssertRel	spErrorRestore,e,sp,SCAN,<Rude Scan Loop: Stack Use Err.>
	DbAssertRel	si,ae,di,SCAN,<Rude Scan Loop: Emit overran source.>
	DbAssertRel	es,z,EScheckRude,SCAN,<Rude Scan Loop: ES not preserved>
	mov	cl,mpOpAtr.[bx]		;load attribute byte
	test	cl,OPA_fSsRude		;Test for scan work for rude mode
	jnz	RudeScanWork		;Work required to get to SS_RUDE

Ssv_NOps:				;Skip opcode and operands
	and	cx,OPA_CntMask		;get the operand count from attribute
	.errnz	OPA_CntMask AND 0FF00H	;must use cx in next line if non-zero
	cmp	cl,OPA_CntMask		;check for cnt field in operand
	jz	Fetch_Cnt		;  brif there is a cnt field
Bump_TxtPtr:
	add	si,cx
	jmp	RudeLoop		;start over for next operand

Fetch_Cnt:
	LODSWTX				;load the cnt field
	mov	cx,ax
	inc	cx
	and	cl,0FEH			;round up to even byte count
	jmp	short Bump_TxtPtr

RudeScanWork:
	mov	di,si			;Bring destination in line with source
	mov	al,ah			; al contains oTyp for opId's,
					; but left shifted
	SHIFT	H,R,al,2		; shift al right two bits
	.errnz	OPCODE_MASK - 03FFH	; 03FF mask implies it's shifted
					; left two bits.
	cbw				;ax = oTyp for opId's
	mov	cx,bx			; cx = masked opcode
	shl	bx,1			;To word offset
	mov	bx,[bx].mpOpScanDisp	;Scan dispatch address
	DbPub DispSSR			;a handy public for debugging
	cmp	[TargetState],SS_RUDE	;Indicate scan or descan
DispSSR:
	jmp	word ptr cs:[bx].SsProcRude	;Dispatch to RUDE scanner

;***
;SsVProc Eot
;Purpose:
;	Rude scan/descan dispatch.
;
;Input:
;	Standard rude dispatch
;Output:
;************************************************************
SsVProc Eot
	jnz	SsRudeOkX		;if scanning and got to opEot, no errors

	mov	ax,UNDEFINED
	cmp	[grs.GRS_fDirect],FALSE
	jnz	Eot_Cont1

	mov	bx,dataOFFSET mrsCur
	cmp	[grs.GRS_oPrsCur],ax
	jz	Eot_Cont		;brif not scanning a procedure table

	mov	bx,dataOFFSET prsCur
	mov	[prsCur.PRS_oVarHash],ax
					;must ensure this gets reset here, in
					;  case we were called to descan a
					;  prs with an empty text table
Eot_Cont:
	.errnz	PRS_cbFrameVars - MRS_cbFrameVars
	mov	[bx.PRS_cbFrameVars],-FR_FirstVar	
					; reset to init. value. This value
					; is 2 to account for the fact that
					; b$curframe is always pushed on the
					; stack after bp, so we treat this
					; word as a frame var for ref'ing
					; the real frame vars off of bp
Eot_Cont1:
					;reset to default
	cmp	[SsErrOTx],ax		;did we just descan due to a scan err?
	jz	SsRudeOkX		;No error - exit.

	mov	di,[SsErrOTx]
	mov	ax,[SsErrOpcode]
	STOSWTX				;restore the saved opcode in text table
	push	[SsErr]			;in case ModuleRudeEdit changes this
ErrExit:
	cmp	[grs.GRS_fDirect],FALSE
	jnz	Eot_Err_Exit		;don't call ModuleRudeEdit if error
					;  in scanning Direct mode buffer - -
					;  no need to do so.
	call	ModuleRudeEditFar	;discard vartable, reset name table bits
	mov	[spErrorRestore],sp	;refresh (ModuleRudeEdit recursively
					; calls SsRudeScan which changes this)
Eot_Err_Exit:
	pop	ax			;retval
SsRudeErr:				;ax = error code, set carry and return
	jmp	short SsRudeX

SsRudeOkX:
	mov	al,[TargetState]
	cmp	[grs.GRS_fDirect],FALSE
	jnz	SsRudeX1		;brif just scanned direct mode buffer
	mov	[txdCur.TXD_scanState],al

	;in case we had a DEF FN without an END DEF (an error the execute
	;  scanner will catch), deactivate prsCur if the current text table
	;  is for mrsCur
	test	[txdCur.TXD_flags],FTX_mrs
	jz	SsRudeX1		;brif a prs is active

	call	PrsDeActivateFar	; in case we had a DEF FN w/o an END DEF
SsRudeX1:
	DbMessTimer	SCAN,<Leave SsRudeScan - >
	sub	ax,ax			; Indicate success
SsRudeX:
	mov	[oNamOfPrsCur],UNDEFINED ;reset to default value
cEnd

;***
;HandleError
;Purpose:
;	This routine is called when an error occurs in scanning from
;	SS_RUDE to SS_PARSE. It saves away the first unscanned pcode,
;	replacing it with opEot. It saves away the error code for later
;	reporting. It sets SI & DI to zero, sets the TargetState to
;	SS_RUDE for descanning, and returns to the scan/descan loop.
;Input:
;	SI-4 points to the first unscanned pcode.
;	AL contains the qbimsgs error code; AH is likely non-zero.
;	ES is still set up for text table being scanned.
;	DI Assumed != UNDEFINED, EXCEPT for the special case where a
;		statement might be fully scanned to parse and THEN the
;		error is noticed. Example: CONST x = 1/0.
;		In this case, the otx for where the error actually occured
;		is on the stack
;Exit:
;	[SsErrOTx] = text offset to error
;
;*****************************************************************************
DbPub	HandleError
HandleError:
	SsRefreshES			; es = cur pcode seg (heap movement)
	xor	ah,ah			;convert error code to a word
	mov	[SsErr],ax
	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jz	HandleErr_Cont		;brif no prs active

	cmp	[prsCur.PRS_procType],PT_DEFFN
	jnz	HandleErr_Cont		;brif active prs is not a DEF FN

	call	PrsDeActivateFar	; deactivate the DEF FN
HandleErr_Cont:
	sub	si,4			;move back to first unscanned opcode
	mov	[SsErrOTx],si		;save oTx of opcode we're replacing
	mov	ax,si			
	inc	di			;special case?
	jnz	HandleErr_Cont1		;  brif not

	pop	ax
HandleErr_Cont1:
	mov	sp,[spErrorRestore]	;in case stack in an intermediate state
	or	al,[fErrWithinOp]	;tell caller if error was at operand
	mov	[grs.GRS_otxCur],ax	;tell SsRudeScan's caller where error is
	LODSWTX				;get original opcode
	mov	[SsErrOpcode],ax	;  and save it for later restoration
	mov	WORD PTR es:[si-2],opEot
	mov	[TargetState],SS_RUDE	;so we'll descan portion scanned so far
	jmp	SsRudeScanErr		;return to the main loop

;***
;HandleId
;Purpose:
;	Given an oTyp in ax, an oNam at es:[si], and mkVar.flags
;	set up appropriately, call MakeVariable to search for
;	(and create if necessary) the variable, replacing the
;	oNam with an oVar.
;Input:
;	ax = oTyp for var
;	es:si and es:di both point to oNam in pcode
;	mkVar.flags and mkVar.cDimensions (if appropriate)
;		are already set up per varmgr spec.s.
;Output:
;	The oVar is substituted for the oNam
;	si & di point at the following word
;Preserves:
;	ES
;*****************************************************************************
DbPub	HandleId
HandleId	PROC	NEAR
	mov	[mkVar.MKVAR_oTyp],ax
	LODSWTX				;Pick up oNam
	mov	[mkVar.MKVAR_oNam],ax
	call	MakeVariableFar 	
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ah,ah			;an error return?
	js	Id_Mkvar_Error		;  brif so

	cmp	[otxConstCur],0		;scanning a CONST statement?
	jnz	ConstCheck		;  brif so

HandleId_Exit:
	STOSWTX				;emit the oVar

	xor	ax,ax
	xchg	ax,[varFlags_Reset]	; reset flag, fetch previous
					;   settings of certain flag bits
	or	[mkVar.MKVAR_flags],ax	
					;for special case; see IdLd, below
	ret

Id_Mkvar_Error:
	TESTM	mkVar.MKVAR_exitFlags,FVI_INDEXED	
	jz	HandleError5		;brif not an array pcode

Id_Error:
	dec	si			;so si points 4-bytes past opcode
	dec	si
HandleError5:
	jmp	HandleError

ConstCheck:
	test	[mkVar.MKVAR_flags2],MV_fConstFound
	jnz	HandleId_Exit		;brif things are okay, i.e., we're in
					;  a CONST statement and the variable
					;  we just found is really a constant
	mov	al,MSG_InvConst		;"Invalid Constant"
	jmp	short Id_Mkvar_Error
	
HandleId	ENDP

	page
;***
;SsVProc Unsupported
;
;Purpose:
;
;   This routine reports an error when unsupported opcodes are encountered.
;   This will occur from a binary load of a file from another basic product
;   that supports statements not supported by this product.
;
;Input:
;
;   standard rude scan dispatch.
;
;Output:
;
;   standard rude scan dispatch.
;
;**********************************************************************

SsVProc Unsupported			
	mov	al,Msg_Unsupported	
HandleError7:				
	inc	si			; Set SI-4 to point to this opcode
	inc	si			
	jmp	short HandleError5	

;***
;SsVProc Id<Ld|St>
;Purpose:
;	Simple Id SS_RUDE scan/descan dispatch points.
;
;	The only rude mode issue is to move the single operand between
;	oVar and oNam.
;
;	Scanning:
;		For each of these, the oNam in in the pcode stream,
;		the oTyp can be fetched from the rule table (mpOpRule).
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	IdSt
	jz	DIdRude
	mov	cx,[otxConstCur]
	jcxz	IdSt			;brif not scanning a CONST statement

	inc	si			;advance txt ptr to next pcode
	inc	si
	;cx = oTx of start of CONST expression
	mov	ax,si			
	sub	ax,cx			; ax = count of bytes in CONST expr.
	cCall	ScanAndExec,<cx,ax>	; creates CONST variable, scans &
					;  executes expression, setting
					;  value field in the new CONST variable
	SsRefreshES			;es = text segment
					; (ScanAndExec can cause far heap
					;  movement)
	mov	[spErrorRestore],sp	;refresh (ScanAndExec changes this)
	or	ax,ax
	jz	IdSt_NoErr		;brif no error
	js	HandleError5		;brif pcode not modified by ScanAndExec

	sub	si,4			;so we report error on correct line
	push	si
	mov	di,UNDEFINED		;signal special case, so UI will report
					;  the error on the correct line
	add	si,8			;advance oTx to reflect that the IdSt
					;  pcode did get bound to an oVar by
					;  ScanAndExec
	jmp	short HandleError5	;brif error
IdSt_NoErr:
	mov	[otxConstCur],si	;in case there are more CONSTant
					;  expressions in this statement
	jmp	short RetToScan5	;no error

IdSt:					;start of code shared for array St's
	or	[mkVar.MKVAR_flags],FVI_LVAL	
	;We know the zero flag won't be set after the above 'or', so fall thru
SsVProc	IdLd
	jz	DIdRude

	;The following tests for ReDim scalar which can appear because QB4
	;incorrectly allowed it.  The binary translator mucks with the code
	;but must leave it so it can be listed to and editted by the user.


	cmp	PTRTX[si+2],opStReDimTo+OPCODE_MASK+1	; ReDimScalar
	je	ReDimScalar
IdLd_1: 				
	;The below code is for a case like STATIC X,Y(A),Z
	;  where 'A' will be an IdLd.   We preserve and HandleId restore's the
	;  previous state of the FVI_STATIC flag in case of variables like 'Z'
	mov	cx,[mkVar.MKVAR_flags]	
	KEYWORD_FLAGS	EQU    FVI_SHARED OR FVI_COMMON OR FVI_STATIC OR FVI_DIM
	and	cx,KEYWORD_FLAGS	
	mov	[varFlags_Reset],cx	;0 or some flag bit
	and	[mkVar.MKVAR_flags],NOT KEYWORD_FLAGS	

IdLd:					;start of code shared for array Ld ID's
	call	HandleId
RetToScan5:
	jmp	RudeLoop		;return to the main loop

ReDimScalar:				
	mov	al,Msg_SubCnt		
	jmp	short HandleError7	

DIdRude:				;Common ID rude descan code
	LODSWTX				;Pick up operand
	add	ax,dx			; ax = pVariable
	xchg	bx,ax			
	mov	ax,[bx].VAR_oNam	;ax = oNam for variable
	STOSWTX				;emit the oNam
	jmp	RudeLoop		;And return to the main loop


SsVProc	VtRf
	jz	DIdRude
IdVtRf:					;start of code shared for array VtRf's
	TestM	[mkVar.MKVAR_flags],FVI_ASCLAUSE    
	jz	IdLd			;brif no 'AS' clause found

	cmp	ax,ET_IMP
	jnz	IdLd			;brif explicitly typed VtRf opcode

	mov	ax,[mkVar.MKVAR_oTyp]	;desired oTyp is already in mkVar
	jmp	short IdLd


;***
;SsVProc AId<Ld|St>
;Purpose:
;	Array Id SS_RUDE scan/descan dispatch points.
;
;	The only rude mode issue is to move the single operand between
;	oVar and oNam.
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	AIdSt
	call	AIdPreamble		;common code to all Array ID's
	jmp	short IdSt		;shared code for all St ID's

SsVProc	AIdLd
	call	AIdPreamble		;common code to all Array ID's
	cmp	PTRTX[si+2],opStReDimTo ; Is this a ReDim statement?
	je	ArrayDeclare		; Yes, need to set FVI_ARRAY
	jmp	short IdLd_1		; shared code for all Ld ID's

SsVProc	AVtRf
	call	AIdPreamble		;common code to all Array ID's
ArrayDeclare:
	shr	[mkVar.MKVAR_cDimensions],1
					;divide cDimensions by two in case this
					;  is an array ref., since the 'cnt' for
					;  that pcode counts lower & upper
					;  bounds for each dimension
	or	[mkVar.MKVAR_flags],FVI_ARRAY	
	jmp	short IdVtRf		;shared code for all VtRf ID's

;***
;AIdPreamble
;Purpose:
;	Perform actions common to all array ID opcodes. This
;	includes checking to see if we're scanning or descanning,
;	(and handling the descan case entirely), setting up 
;	mkVar.cDimensions, and setting the FVI_INDEXED bit in mkVar.flags.
;
;Input:
;	standard rude scan dispatch.
;Output:
;	ax = type of ID
;	mkVar.MKVAR_cDimensions field set up (though it could be 2  cDim's)
;	di = si
;	mkVar.flags has FVI_INDEXED set
;*****************************************************************************
DbPub	AIdPreamble
AIdPreamble	PROC	NEAR
	jz	DAIdRude
	
	xchg	ax,bx			;save array type in bx
	LODSWTX				;Pick up (assumed) cDimensions
					;  (note that this might be 2 * cDim's)
	or	ah,ah			;special value in lieu of 0?
	jns	Save_cDims		;  brif not

	xor	al,al			;set cDims to zero
Save_cDims:
	mov	[mkVar.MKVAR_cDimensions],al
	xchg	ax,bx			;common code expects type in ax
	inc	di			;set di = si
	inc	di
	or	[mkVar.MKVAR_flags],FVI_INDEXED	
	ret
AIdPreamble	ENDP

DAIdRude:
	pop	ax			;throw away return addr from AIdPreamble
	inc	si			;skip index count
	inc	si
	mov	di,si			;Move to oVar operand
	jmp	DIdRude 		; and dereference just like an Id


;***
;SsVProc Off<Ld|St>
;Purpose:
;	Record offset Id SS_RUDE scan/descan dispatch points.
;
;	Scan work:	Convert oNam to oElem 
;	Descan work:	Convert oElem to oNam
;Input:
;	standard rude scan dispatch.
;	Count on the oTyp of parent being in mkVar.oTyp.
;Output:
;	standard rude scan dispatch.
;	Leave the oTyp of found element in mkVar.oTyp.
;*****************************************************************************
SsVProc	OffLd
SsVProc OffSt
	xchg	ax,bx			; bx == explicit type constant
	LODSWTX				;fetch oNam/oElem from pcode
	jz	D_Off			;brif descanning

	cmp	[mkVar.MKVAR_oTyp],ET_MAX
	jbe	Not_User_Defined	;[26] brif not user defined type

	cCall	RefElem,<ax,bx> 	;[36]
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ax,ax			
	js	HandleError2		;brif error return

Off_Exit:
	STOSWTX				;emit the oElem/oNam (common exit point)
RetToScan7:				
	jmp	RudeLoop		;return to the main loop

D_Off:
	mov	bx,dx			    ; get start of type table (bdVar)
	add	bx,ax			    ;bx = pElem
	mov	ax,[bx.ELEM_oNam]	    ;fetch oNam of the element
	jmp	short Off_Exit		; emit the oNam/iCE and return
					; to main loop

Not_User_Defined:			
OffError_oTyp:
	mov	al,MSG_BadElemRef	;in case this isn't of 
					;     user defined type
HandleError2:
	jmp	HandleError		;descan up to this opcode, report error
	

;***
;SsVProc AsType - handle opAsType and opAsTypeExp
;Purpose:
;	Set the mkVar flag to note that an 'AS' clause has been
;	seen, and set mkVar.oTyp to the appropriate type.
;	op[A]IdVtRfImp dispatch points must check to see if
;	the FVI_ASCLAUSE bit is set in mkVar.flags, and leave the
;	oTyp alone if so (rather than loading it from the rule
;	table index).
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;
;*****************************************************************************
SsVProc	AsType				;Includes AsTypeExp
	jz	D_AsType		;no descanning work here
	
	or	[mkVar.MKVAR_flags],FVI_ASCLAUSE	
	LODSWTX				;ax = 1st operand
	cmp	cx,opAsType		;is this for opAsType?
	jnz	AsTypeExp		;  brif not - opAsTypeExp

	cCall	RefTyp,<ax,di>
	SsRefreshES			; es = cur pcode seg (heap movement)
	or	ah,ah			;an error return?
	jns	AsType_Cont		;  brif not
HandleError6:
	jmp	short HandleError2
AsTypeExp:
	cmp	cx,opAsTypeExp
	jz	AsType_Cont		;ax contains a pre-defined oTyp

	DbAssertRel cx,z,opAsTypeFixed,SCAN,<SsVProc AsType: unexpected opcode>
	xchg	ax,dx
	LODSWTX 			;ax contains cbFS or oNam of const
					;  or oNam of FORM/MENU
	or	dh,dh			;length, or oNam?
	jns	AsTypeFixed_Cont	;  brif ax == length

	or	[mkVar.MKVAR_flags2],MV_fONamInOTyp
	and	dh,07FH 		;mask to make this a normal oTyp
AsTypeFixed_Cont:
	.errnz	MKVAR_fsLength - MKVAR_oNamForm 
	mov	[mkVar.MKVAR_fsLength],ax
	xchg	ax,dx
AsType_Cont:				;have type in ax
	mov	[mkVar.MKVAR_oTyp],ax
	inc	si
	inc	si			;Skip listing column
	jmp	short RetToScan2

D_AsType:
	add	si,4			;skip to next pcode if descanning
	cmp	cx,opAsTypeFixed
	jnz	RetToScan2		;brif only two-bytes to skip

	inc	si
	inc	si			;Skip listing column
	jmp	short RetToScan2

;***
;SsVProc StDefTyp
;Purpose:
;	Grab the 4-byte mask from the pcode; pass this to SetDefBits to
;	reset the default type for specified alphabet letters.
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	StDefType
	jz	D_DefType		;no descanning work here

	inc	si			;skip link field - - point to
	inc	si			;  I4mask in pcode
	LODSWTX				;Pick up low word
	xchg	ax,dx			;DX = Low word of mask
	LODSWTX 			;AX:DX = I4mask
	push	ax			
	push	dx			
	and	dl,FV_TYP_MASK		; mask out all but type constant
	push	dx			
	call	SetDefBits		;set new type default(s)
	SsRefreshES			; es = cur pcode seg (heap movement)
RetToScan2:
	jmp	RudeLoop		;return to the main loop


D_DefType:
	;fall through to StStatic for return to descan loop

;***
;SsVProc StCommon, StShared, StStatic, Shared
;Purpose:
;	Set flags for later variable references. Each of these
;	opcodes come before the associated Id opcodes, so these
;	flags are simply set up, and left until BOS/BOL.
;
;	To save code, don't bother to detect if we're scanning or
;	descanning; just set the flags regardless.
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	StStatic
	or	[mkVar.MKVAR_flags],FVI_STATIC	
RetToScanOps:
	jmp	Operand_Skip_Ret	;skip operands and return to main loop

SsVProc	StCommon
	or	[mkVar.MKVAR_flags],FVI_COMMON	
	jmp	short	RetToScanOps

SsVProc	StShared
SsVProc	Shared
	or	[mkVar.MKVAR_flags],FVI_SHARED	
	jmp	short	RetToScanOps	

SsVProc StDim
	or	[mkVar.MKVAR_flags],FVI_DIM	
	jmp	short	RetToScanOps	


;***
;HandleProcName
;Purpose:
;	Shared code for handling the procedure name in a
;	DECLARE, FUNCTION, or DEF FN statement. Calls MakeVariable.
;
;	NOTE: See qbipcode.txt for a description of the procAtr word in
;		the pcode in order to better understand this routine.
;Input:
;	es:[si+2] = oNam or oPrs for procedure
;	If this is for a DEF FN, bits cl = PT_DEFFN, else cx = 0
;Exit:
;	Should not be called for a SUB definition. If called for DECLARE SUB, 
;		does nothing, only return value is bl = PT_SUB.
;	Otherwise,
;		no Prs is active (i.e. module level text tbl is active)
;		mkVar.MKVAR_oTyp contains oTyp returned by MakeVariable
;		bl contains the procType of the prs
;		cx = oPrs of FUNCTION/DEF FN
;Preserves:
;	SI,DI,ES
;Exceptions:
;	This routine handles MakeVariable error return
;*****************************************************************************
DbPub	HandleProcName
HandleProcName PROC NEAR
	mov	ax,es:[si.DCL_atr]	;ax = procAtr operand
	and	ah,DCLA_procType / 100h	;ah = procType (PT_SUB etc.)
	mov	bl,PT_SUB		;put procType in bl in case of a SUB
	cmp	ah,bl			;is this a SUB?
	DJMP	jz HandleProc_Exit	;  brif so - do nothing, exit

HandleProcName_Cont:
	push	[grs.GRS_oRsCur]	;save caller's oRs
	test	al,DCLA_Explicit	;explicitly typed DEF or FUNCTION?
	jnz	HandleProc_Type		;  brif so

	mov	al,ET_IMP		;proc was implicitly typed
HandleProc_Type:
	and	ax,DCLA_oTyp		;ax = oTyp returned by function
	mov	[mkVar.MKVAR_oTyp],ax
	mov	bx,es:[si.DCL_oPrs]	;fetch oPrs (or oNam) from pcode stream
	jcxz	NotDefFn

	mov	[oNamOfPrsCur],bx	;speed optimization - used by varmgr
					;  This is safe because varmgr only uses
					;  this when grs.oPrsCur != UNDEFINED
	push	bx			;oNam of DEF FN
	push	cx			;procType
	cmp	al,ET_IMP		;implicitly typed DEF FN?
	jnz	Not_Implicit		;  brif not

	cCall	oTypOfONamDefault,<bx>	; returns ax = default oTyp
					;	for this oNam
Not_Implicit:
	push	ax			;oTyp of DEF FN (could be ET_IMP)
	xor	dx,dx
	push	dx			;fNotDefine
	call	PrsDefine
	SsRefreshES			;es = cur pcode seg (new txt tbl)
	or	ax,ax
	jnz	ProcNameError		;error in defining prs for DEF FN

	or	[prsCur.PRS_flags],FP_DEFINED
	mov	ax,si
	sub	ax,4			;ax == otx of opStDefFn
	mov	[prsCur.PRS_otxDef],ax
        mov     ax,[grs.GRS_oMrsCur]
        mov     [prsCur.PRS_oRsDef],ax  ;oRsDef is the module's oRS

	mov	bx,[grs.GRS_oPrsCur]	;oPrs for DEF FN
	mov	es:[si.DCL_oPrs],bx	;replace oNam in pcode with oPrs
NotDefFn:
	push	bx			; save oPrs across calls
	push	bx			;pass oPrs to FieldsOfPrs below
	call	PrsDeActivateFar	; make main level variable for
					;  DEF FN or FUNCTION
	cCall	FieldsOfPrsFar		; get oNam in ax, procType in dl
					; parm was already pushed above
	mov	[mkVar.MKVAR_oNam],ax
	push	dx			;save procType for retval
	cmp	dl,PT_FUNCTION		;is this prs for a FUNCTION?
	jnz	ProcFlagsSet		;  brif not - - must be for a DEF FN

	or	[mkVar.MKVAR_flags],FVI_FUNCTION	
ProcFlagsSet:
	call	MakeVariableFar 	;search for and create var if not found
	pop	bx			;restore procType for retval
	pop	cx			; restore oPrs
	or	ah,ah			;an error return?
	js	HandleProc_Error	;  brif so

	DbAssertRel [mkVar.MKVAR_oTyp],nz,ET_IMP,SCAN,<HandleProcName:ET_IMP oTyp>
	pop	dx			;discard caller's grs.oRsCur
HandleProc_Exit:
	ret

HandleProc_Error:
	TESTM	mkVar.MKVAR_exitFlags,FVI_FNNAME	
					;Note: could use DX instead if
					;	MakeVariable in native code
	jnz	ProcNameError		;brif an opStDefFn pcode
	inc	si			;so si points 4-bytes past opcode
	inc	si			; as expected by HandleError
ProcNameError:
	pop	dx			;dx = caller's grs.oRsCur
	push	ax			;save error code
	cCall	RsActivate,<dx> 	; re-activate caller's oRs
	pop	ax			;restore ax = error code
HandleError1:
	jmp	HandleError
HandleProcName	ENDP

;***
;SsVProc StDefFn, StFunction, StSub
;Purpose:
;	Handle the pcodes for SUB, FUNCTION, and DEF.
;
;	For SUB, the proc name is ignored, and we share
;	code with the others for handling each formal
;	parameter (all given as operands to the opcode).
;
;	For DEF, we must bypass the link field; otherwise,
;	it is treated the same as FUNCTION (common code
;	will set the FVI_FUNCTION flag as appropriate).
;
;Inputs:
;	standard rude scan dispatch.
;Outputs:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	StDefFn
	pushf
	inc	si			;move to 2-bytes prior to oPrs
	inc	si			;  DECLARE & FUNCTION have no 'link'
	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jne	DefInDefErr		;brif found in another prs
	mov	cl,PT_DEFFN		;tell HanldeProcName this is a DefFn
	popf
	jmp	short Func_Or_Def

DefInDefErr:
	mov	ax,MSG_InvProc		;"Invalid within procedure"
	jmp	SHORT HandleError1

SsVProc	StFunction
	mov	cx,0			;'mov' doesn't affect flags
Func_Or_Def:
	jz	StProc_DeScan		;skip the following if descanning

	call	HandleProcName		;calls MakeVariable for FUNCTION/DEF
	push	bx			;save bl=procType
	cCall	PrsActivate,<cx>	; make FUNCTION/DEF FN active
	pop	bx			;restore bl=procType
	SsRefreshES			;es = cur pcode seg (new txt tbl)
	mov	ax,es:[si.DCL_atr]	;ax = procAtr operand
	and	ax,NOT DCLA_oTyp	;mask out existing oTyp
	mov	dx,[mkVar.MKVAR_oTyp]	;get actual oTyp of DEF FN or FUNCTION
	DbAssertRel  dx,be,ET_FS,SCAN,<SsV_StFunction: oTyp is invalid>
	or	ax,dx			;set correct oTyp in pcode, for later
	mov	es:[si.DCL_atr],ax	;  checking by execute scanner
	and	[prsCur.PRS_oType],NOT M_PT_OTYPE   ; turn off existing oTyp bits
	or	[prsCur.PRS_oType],dl	; ensure oType field set correctly in prs
	DJMP	jmp SHORT StProc_Scan

SsVProc	StSub
	;at this point, es:[si+2] is the proc oPrs; PSW.Z set if descanning
	mov	bl,PT_SUB
	jz	Not_A_DefFn		;brif descanning to SS_RUDE

	jmp	StProc_Scan1		;brif scanning to SS_PARSE

StProc_DeScan:
	;descanning: walk through parms, converting each oVar to an oNam

	;first, reset prs.oVarHash and replace oPrs with oNam in pcode if this
	; is a DEF FN
	jcxz	Not_A_DefFn
	mov	ax,es:[si.DCL_oPrs]	;get oPrs
	push	dx			;save pVarTable
	cCall	FieldsOfPrsFar,<ax>	;ax = oNam, dl = proctype
	DbAssertRelB dl,z,PT_DEFFN,SCAN,<rude descan: dl should == PT_DEFFN here>
	mov	es:[si.DCL_oPrs],ax	;replace oPrs for DEF FN with oNam
	pop	dx			;restore pVarTable
Not_A_DefFn:
	xor	bx,bx			;bx = zero indicates we have oVar's that
					;  must be converted to oNam's
	add	si,DCL_cParms		;mov to parm count
D_FormalParm_Descan:
	LODSWTX				
	mov	cx,ax			;cx = count of parm sets (3 words/set)
	inc	ax			;no parms? (test for UNDEFINED)
	jz	D_Formal_Exit		;  exit if so - si points to next opcode
	jcxz	D_Formal_Exit		;exit if parm count of zero
D_FormalParm_Loop:
	mov	di,si			;point to the oVar in pcode
	cmp	[SsErrOTx],si
	jz	RetToScan3		;special case: if a scan error occured
					;  in this formal parm, the 'oNam' field
					;  will now contain opEot; just dispatch
					;  to it now if we've descanned to error
	LODSWTX				;fetch oVar (or oNam if DECLARE)
	or	bx,bx			;are we descanning a DECLARE statment?
	jnz	D_ONam_Okay		;  brif so - - oNam field fine as is

	add	ax,dx			; ax = pVariable
	xchg	bx,ax			
	mov	ax,[bx].VAR_oNam	;ax = oNam for variable
	STOSWTX				;emit the oNam
	xor	bx,bx			;bx == 0 ===> not descanning a DECLARE
D_ONam_Okay:
	inc	si			;move source pointer to
	inc	si			;  the oTyp field
	LODSWTX
	cmp	ax,ET_MAX		;user-defined oTyp?
	jbe	D_Formal_Cont		;  brif not - - leave it alone

	push	bx
	cCall	ONamOTyp,<ax>		; ax = oNam for name of this type
	pop	bx
	mov	es:[si-2],ax		;replace oTyp with oNam of type in pcode
D_Formal_Cont:
	loop	D_FormalParm_Loop	;loop for each parm set
D_Formal_Exit:
	or	bx,bx			;descanning a DECLARE?
	jz	RetToScan3		;  brif not
	
	mov	si,bx			;skip past alias text in pcode
RetToScan3:
	jmp	RudeLoop		;return to the main loop

OM_ProcError:
	mov	al,ER_OM		;insufficient memory for var hash table
	dec	si			;[si-4] = opStDefFn
	dec	si
	jmp	short HandleError3

StProcError:
	;Found an error while scanning a formal parameter for a SUB, FUNCTION,
	;  or DEF. SI points past this formal parameter (that was itself
	;  unmodified). 
	;For StProcError, [si-4] = oNam. This will cause oNam of the formal
	;  to be temporarily replaced with opEot; wierd, but saves code.
	
	mov	[fErrWithinOp],1	;tell caller error was in operand
HandleError3:
	jmp	HandleError

StProc_Scan:				;scan each formal parameter for the proc
	;es:si points 2-bytes before the oPrs for FUNCTION/DEF statement
	;bl = procType of proc

	cmp	bl,PT_DEFFN		;are we scanning a DEF FN statement?
	jnz	Not_Def_Fn		;  brif not

	push	bx			
	call	MakePrsTVar		;make variable hash table for DEF FN
	pop	bx			
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ax,ax			;error return?
	mov	al,ER_OM		
	jz	HandleError3		;  brif so

Not_Def_Fn:
	;At this point, we make a RetVal entry for the FUNCTION/DEF FN.
	;This is so there is space in the variable table for this, even
	;if not used, in case we determine at execute scan time that we
	;have a RetVal where we thought we had a reference. Note that this
	;logic depends on the fact that we always end up in SS_RUDE when a
	;FUNCTION or DEF FN is added.
	;Note that we assume that the oTyp and oNam are still valid in mkVar
	;for this FUNCTION or DEF FN
	mov	[mkVar.MKVAR_flags],FVI_LVAL	
	push	bx			
	call	MakeVariableFar 	;search for and create var if not found
	pop	bx			
	;Note that we don't use the return value, i.e., it doesn't go in the
	;pcode - - - the goal is just to create the retval entry.
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ah,ah			;an error return?
	jns	StProc_Scan1		; brif not

	cmp	bl,PT_DEFFN		
	jz	HandleError3		; si-4 points to opStDefFn

	inc	si			
	inc	si			
	DbAssertRelB bl,z,PT_FUNCTION,SCAN,<ssrude:opStFunction, invalid PT_ type>
	jmp	HandleError3		; si-4 points to opStFunction

StProc_Scan1:				;SUB support joins up w/FUNCTION & 
					;  DEF FN support here
	add	si,6			; point si past oPrs and procAttr 
	.errnz	DCL_oPrs - 2		; operands
	LODSWTX				;get count of parameters
	.errnz	DCL_cParms - 6
	mov	cx,ax			;cx = count of parm sets (3 words/set)
	jcxz	RetToScan3		;brif zero parms
	inc	ax			;test for UNDEFINED
					;special value indicating no parameters?
	jz	RetToScan3		;  brif so

	or	[mkVar.MKVAR_flags],FVI_FORMAL	
	mov	BYTE PTR [mkVar.MKVAR_cDimensions],0
					;set this to default for any array parms
DbPub	FormalParm_Loop
FormalParm_Loop:
	mov	di,si			;reset di to point to oNam of parm
	LODSWTX				;ax = oNam of parm
	mov	[mkVar.MKVAR_oNam],ax
	LODSWTX				;ax = flags for parm
	mov	dx,ax
	and	ax,(FVI_ARRAY OR FVI_ASCLAUSE)	
	or	[mkVar.MKVAR_flags],ax
.erre	FVI_ARRAY AND PATR_array	
.erre	FVI_ASCLAUSE AND PATR_asClause	
	mov	ax,ET_IMP
	TESTX	dx,<PATR_asClause OR PATR_explicit>
	jz	Set_Typ			;brif must set oTyp to default based on
					;  oNam
	mov	ax,es:[si]		;oTyp or oNam
	DbAssertRel ax,nz,0,SCAN,<ssrude formal parm found with AS ANY oTyp>
	;(AS ANY clause only valid for DECLARE statement)
	cmp	ax,ET_MAX		;is this a predefined type?
	jbe	Set_Typ			; brif so (CAN'T be fixed-length string)
					;ax is the oNam of a user type
	push	cx			;save count of formals across call
	cCall	RefTyp,<ax,si>		;returns oTyp or error code	
	pop	cx
	or	ah,ah			;an error return?
	jns	Set_Typ			;  brif no error
StProcError1:
	jmp	StProcError
Set_Typ:
	mov	[mkVar.MKVAR_oTyp],ax
	push	cx			;preserve count of formals
	call	MakeVariableFar 	; create the parm entry
	pop	cx
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ah,ah			;was an error code returned?
	js	StProcError1		;  brif so
	
	STOSWTX				;replace oNam with oVar
	mov	ax,[mkVar.MKVAR_oTyp]
	mov	es:[si],ax		;put oTyp of found/created var in pcode
@@:
	inc	si			;skip past oTyp field
	inc	si
	DJMP loop FormalParm_Loop  	;continue for each parameter

	and	[mkVar.MKVAR_flags],NOT FVI_FORMAL	
					;turn off this flag for subsequent
					;  scanning
RetToScan1:
	jmp	RudeLoop		;return to the main loop

;***
;SsVProc StDeclare
;Purpose:
;	Call varmgr with FUNCTION name only - - we don't create variables
;	for SUB's, and the parser guarantees that we'll never see a DECLARE
;	for a DEF FN (invalid syntax).  
;	Note that the oVar returned by MakeVariable is discarded
;	we need to call this to create var entry if it doesn't
;	already exist.
;
;	For each formal parameter, if oTyp not correctly set (based on flags
;	in pcode), set it based on current def type.
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	StDeclare
	pushf
	LODSWTX				;ax = cntEos operand
	add	ax,si			;ax points to next opcode
	popf
	jnz	Scan_StDeclare		;brif scanning, not descanning

	;descanning - - must convert each user-defined oTyp in formal parm
	;  list to an oNam, since the type table is gone when in SS_RUDE.
	;share code with StSub/StDefFn/StFunction for this
	add	si,DCL_cParms-2		;point to count of formal parms	
	xchg	ax,bx			;tell shared code we there are no
					;  oVar's to convert to oNam's
	jmp	D_FormalParm_Descan
Scan_StDeclare:
	push	ax			;save, so we can skip alias text @ end
	dec	si
	dec	si			;si points to cntEos operand
	xor	cx,cx			;can't be a DEFFN
	call	HandleProcName		;make the var if it's DECLARE FUNCTION
	SsRefreshES			;es = cur pcode seg (heap movement)
	cmp	bl,PT_FUNCTION
	jnz	StDeclare_Cont		;only change pCode for DECLARE FUNCTION

	mov	ax,es:[si.DCL_atr]	;ax = procAtr operand
	and	ax,NOT DCLA_oTyp	;mask out existing oTyp
	mov	dx,[mkVar.MKVAR_oTyp]	; get actual oTyp of FUNCTION
	DbAssertRel  dx,be,ET_FS,SCAN,<SsV_StDeclare: oTyp is invalid>
	or	ax,dx			; set correct oTyp in pcode for later
	mov	es:[si.DCL_atr],ax	;	checking by execute scanner
	xchg	ax,cx			; ax = oPrs (from HanldeProcName)
	call	PPrsOPrsSCAN		; bx = pPrs
	and	PTRRS[bx.PRS_oType],NOT M_PT_OTYPE ; turn off existing oTyp bits
	or	BPTRRS[bx.PRS_oType],dl ; ensure oTyp field set correctly in prs
StDeclare_Cont:
	add	si,DCL_cParms		;point to count of formal parms	
	LODSWTX				;ax = cParms operand
	mov	cx,ax			;cx = count of parms in pcode
	inc	ax			;no parms? (test for UNDEFINED)
	jz	StDeclare_Exit		;  exit if so - si points to next opcode
	jcxz	StDeclare_Exit		;brif no formals to scan
Declare_Formal_Loop:
	;loop for each formal parm in DECLARE pcode, setting the oTyp to
	;  the appropriate default if required
	LODSWTX				;ax = oNam of parameter
	xchg	ax,dx
	LODSWTX				;ax = flags, si points to oTyp field
	push	cx			;preserve count of formals
	TESTX	ax,<PATR_asClause OR PATR_explicit>
	jz	Formal_Type_Def_Set	;brif must set oTyp to default based on
					;  oNam
	mov	ax,es:[si]		;oTyp or oNam
	cmp	ax,ET_MAX		;is this a predefined type?
	jbe	Formal_Type_Set		; brif so (CAN'T be fixed-length string)
					;ax is the oNam of a user type
	cCall	RefTyp,<ax,si>		;returns oTyp or error code	
	SsRefreshES			; es = cur pcode seg (heap movement)
	or	ah,ah			;an error return?
	jns	Set_Formal_Typ		;  brif not
	mov	[fErrWithinOp],1	;tell caller error was in operand
HandleError4:
	jmp	HandleError

Formal_Type_Def_Set:
	cCall	oTypOfONamDefault,<dx>	; default oTyp for given oNam
	SsRefreshES			; es = cur pcode seg (heap movement)
Set_Formal_Typ:
	mov	es:[si],ax		;put default oTyp in pcode
Formal_Type_Set:
	pop	cx			;restore count of formals
	inc	si			;skip past this formal
	inc	si
	loop	Declare_Formal_Loop	;brif another formal to scan	
StDeclare_Exit:
	pop	si			;pointer to next pcode
RetToScan4:
	jmp	RetToScan1

;***
;SsVProc StEndDef
;Purpose:
;	This dispatch point is required for END DEF
;	to deactivate the current prs. Keeping prsCur correct during
;	rude scanning is important so that variable search & creation
;	is performed correctly.
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	EndSingleDef
SsVProc	StEndDef
	jz	Operand_Skip_Ret	;do nothing in descan case

	mov	[oNamOfPrsCur],UNDEFINED ; reset to default - just in case
	push	cx			;save opcode for operand skipping
	cCall	PrsDeActivateFar	
	pop	cx
	jmp	short Operand_Skip_Ret


;***
;SsVProc StType
;Purpose:
;	Rude scan an entire TYPE/END TYPE block
;Exit:
;	si points to 1st opcode after opStEndType
;
;*****************************************************************************
SsVProc	StType
	jz	Operand_Skip_Ret	;brif descanning to SS_RUDE

	push	si			;in case of error return
	call	ScanTypeBlock
	pop	cx			;previous (pushed) oTx
	SsRefreshES			;es = cur pcode seg (heap movement)
	or	ax,ax			
	je	RetToScan4		;brif no error

	inc	cx			
	inc	cx			;cx points 4-bytes past opStType
	xchg	cx,si			;si for descanning up to opStType
	push	cx			;oTx of where error really occured
	mov	di,UNDEFINED		;signal special case to HandleError
	jmp	SHORT HandleError4	;descan up to this opcode, report error

;***
;SsVProc StEndType
;Purpose:
;	Report "END TYPE without TYPE error, since all balanced opStEndType
;	opcodes are consumed by ScanTypeBlock.
;
;*****************************************************************************
SsVProc	StEndType
	jz	Operand_Skip_Ret	;brif descanning to SS_RUDE
	inc	si			;bump si by 2 for HandleError
	inc	si
	mov	al,MSG_NoType		;give "END TYPE without TYPE error"
	jmp	SHORT HandleError4

;***
;SsVProc StConst
;Purpose:
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	StConst
	mov	[otxConstCur],si	;remember we're scanning a CONSTant stmt
					;  and save current text pointer
	jmp	short RetToScan4
	
;***
;SsVProc For, Next, NextId
;Purpose:
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	For
SsVProc	Next
SsVProc	NextId
	mov	word ptr es:[si],UNDEFINED
					;replace oBP with UNDEFINED,
					;  so it will be so reset by the time
					;  the scanner sees it again (i.e.,
					;  in case we are descanning or have
					;  descanned from SS_PARSE to SS_RUDE)
	jmp	short Operand_Skip_Ret
	
;***
;SsVProc Bos,Bol,BolLabDef
;Purpose:
;	At the start of each statement, reset mkVar.flags to
;	all zeroes (default bit-flag values). This is necessary,
;	since some flags (such as STATIC, COMMON) must stay in
;	effect for the duration of a statement.
;
;Input:
;	standard rude scan dispatch.
;Output:
;	standard rude scan dispatch.
;*****************************************************************************
SsVProc	Bol
SsVProc	BolEmit
SsVProc	BolLabDef
	mov	ax,[SsLineCount]
	inc	ax
	mov	[SsLineCount],ax
	test	al,LineUpdate-1		;Time to update line count on screen?
	jz	UpdateLine		;brif so
SsVProc	Bos
Bos:
	sub	ax,ax
	mov	[mkVar.MKVAR_flags],ax
	mov	[otxConstCur],ax	;in case we were scanning a CONST stmt
Operand_Skip_Ret:
	mov	bx,cx			;put opcode into bx
	mov	cl,mpOpAtr.[bx]		;load attribute byte
	jmp	Ssv_NOps		;skip past operands, return to loop

UpdateLine:
	cmp	[TargetState],SS_RUDE	;Are we descanning?
	jz	Bos			;  brif so - no line count

	push	cx
	PUSH_ES 			
	push	dx
	cCall	UpdStatusLn,<ax>
	pop	dx
	POP_ES				
	pop	cx
	jmp	short Bos

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssrules.asm ===
page	49,132
	TITLE	ssrules - Scanner Table Definitions
;***
;ssrules.asm - Scanner Table Definitions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This module defines the coercion and rules tables used by the scanner.
;   The following is a description of how all scan tables are organized.
;
;   tOpSsDisp:	    tOpAtr:	    tOpRule:	    tOpExe:
;	    ssOp1	    op1Atr	    op1Rule	    ex1
;	    ssOp2	    op2Atr	    op2Rule	    ex2
;	    ... 	    ... 	    ... 	    ...
;
;   tOpSsDisp is the scan dispatch for the opcode.  Entries are 1 word.
;
;   tOpAtr is the atribute byte for the opcode. Entries are 1 byte.  The
;   atribute value is the number of operand bytes owned by the opcode.
;   Some opcodes own a variable number of operand bytes.  In these cases
;   the first operand word is the number of operand bytes - 2.	This is
;   signified by LOW UNDEFINED in the atribute table.
;
;   tOpRule is a scan helper byte that can be:
;	1. a rule table index.	Used in this way when there are more than one
;	   variables in the opcode to executor algorithm.  The rule table index
;	   is used to index tRuleWord and tRuleByte desribed below.
;	2. an ET type.	Used in this manner when the emitted type is the only
;	   variable in the opcode to executor algorithm.  An example is all
;	   intrinsic functions that have no operands (ERR, ERL,...).
;
;   tOpExe is the executor for the opcode.  If an opcode has several executors
;   then tOpExe contains the address of an ordered list of executors for
;   the opcode.
;
;   tRuleWord:
;	This table usually contains one of the following:
;	1. coercion table address
;	2. other scan routine specific information such as an ET type.
;
;   tRuleByte:
;	This table almost always contains an ET type which is the emitted
;	type for opcodes using this rule.  The special emitted type
;	LOW UNDEFINED indicates that the coerced input type is to be emitted.
;	For example, opAdd emits an I2 when the arguments are I2.
;
;   tCo<rule>
;	These are the coercion tables.	They are either one or two dimensional
;	and overlay each other as much as possible in order to save space.
;	Coercion tables contain:
;	1. ET types.  These are present when coercion may be required.	The
;	   type is the target type to which the current argument(s) must be
;	   coerced.
;	2. 0.  This value is used as a speed hack.  It is present when it is
;	   known that coercion is not required.
;	3. LOW UNDEFINED.  This value is used to indicate "type mismatch"
;	   was detected.
;
;   tCoerceExe is a 2 dimensional (typeXtype) table of coercion executor
;   addresses.
;
;In general, these tables are accessed as follows (refer to following diagram):
;	1. The opcode is used to index into tOpRule to find the rule index
;	   for the current op.	This allows a single scan routine to scan
;	   a family of related opcodes.
;	2. The rule index is used to find the coercion table and the emitted
;	   type for the current op.
;	3. Arguments are popped from the scan stack and used to index the
;	   coercion table.
;	4. For opcodes that emit a value the emitted type and current
;	   expression fragment pcode address are pushed on the stack.
;
;		tOpRule:	   tRuleWord: tRuleByte:
;		    [index]
;    opcode-------->[index]--------> [ptCoerce][ET_emit]
;		    [...  ]		 |
;					 +---------------->tCoerce
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSRULES_ASM = ON
	IncludeOnce	context 	    
	IncludeOnce	opintrsc
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list


assumes cs, SCAN
assumes ds, DATA
assumes SS, DATA

sBegin	CODE

	extrn	exLitI21:near		;Literal executor

	    extrn   exPushSeg:near	
	    extrn   exCopyTmpAr:near	

sEnd	CODE

subttl	Coercion Label Definitions

sBegin	SCAN

	extrn	GetTrueType:near	

mOpExLitR8	label word	    
	DWEXT	exLitR80	    
	DWEXT	exLitR81	    
	DWEXT	exLitR82	    
	DWEXT	exLitR83	    
	DWEXT	exLitR84	    
	DWEXT	exLitR85	    
	DWEXT	exLitR86	    
	DWEXT	exLitR87	    
	DWEXT	exLitR88	    
	DWEXT	exLitR89	    
	DWEXT	exLitR810	    

subttl	Coercion Support Functions
page
;***
;SsCoerceN - coerce n expressions on the scan stack to specified type
;Purpose:
;	Coerce n expressions on the scan stack to specified type.
;
;Input:
;	ax = oTyp of target (Record = ET_RC)
;	cx = count to coerce
;	si/di scan source and destination in pcode
;Output:
;	si/di updated if any coercion was required.
;	f_StaticCalc set FALSE if any expression was not a literal
;
;Preserves:
;	ax,bx
;***************************************************************************

	public	SsCoerceN
SsCoerceN:
	pop	[SsParmCnt]		; Get return address out of the way
	jcxz	EndCoerceN		
	.erre	ET_RC EQ 0		; Assure DEC is sufficient
	dec	ax			; Force ET_RC -> 0ffffh
	cmp	ax,ET_MaxNum		; Numeric type?
	jb	SsCoerceNStart		
	call	TMError 		
	xor	ax,ax			; Use valid type (ET_I2)
SsCoerceNStart: 			
	inc	ax			; Restore correct oTyp
SsCoerceNLoop:
	pop	dx			; Get oType
	push	dx			; But keep it on stack
	xor	dh,high ST_Lit? 	;High bits now zero if literal
	test	dh,0C0H 		;Determine if this index is a literal.
	jz	SsCoerceNNotLit 	;Not a literal index
	mov	f_StaticCalc,FALSE	;Indicate not a $STATIC array if this
SsCoerceNNotLit:			; is the first reference.
	test	dh,ST_ByVal+ST_Seg	; Have ByVal or Seg been used?
	jz	@F			; Brif no
	call	TMError 		
@@:
	call	EnsureArgType		
	loop	SsCoerceNLoop		;Go check next index
EndCoerceN:				
	jmp	[SsParmCnt]		; Return to caller

	page
;***
;EnsureArgType
;Purpose:
;	Ensure that the expression entry on the stack is of the desired
;	type.
;Input:
;	ax = type required for this expression
;	si/di scan source and emit
;
;	ParmW	oTxExp
;	ParmW	oTypExp (Records use ET_RC)
;
;Output:
;	ax = oTyp of target (Records use true oTyp)
;Preserves:
;	bx,cx,dx
;****
cProc	EnsureArgType,<NEAR,PUBLIC>,<ax,bx,cx,dx>
ParmW	oTxExp
ParmW	oTypExp
cBegin
	mov	bx,oTxExp		;Expression location
	cmp	ax,ET_MaxNum		; Is target numeric ?
	xchg	cx,ax			;CX = oTyp of target
	jbe	Numeric 		
	mov	ax,oTypExp		;AX = oTyp of source (Record = ET_RC)
	TestX	ax,ST_Var?		;Is it a variable?
	jz	Coerce			;If not, it won't move
	mov	dh,0			;Assume near - SD/FS
	or	al,al			;[5] Is it a record?
	jnz	SafeRef 		; Make sure reference is safe
	mov	dh,FarArg		;Must be record - want far ref
SafeRef:
	call	SsRefArg		;Make sure it's safe from moving
Numeric:
	mov	ax,oTypExp		;AX = oTyp of source (Record = ET_RC)
Coerce:
	call	SsCoerceReg
cEnd

;SsCoerceReg
;
;Purpose:
;	Insert a coercion token to cause an expression to be coerced to a
;	specified type.
;
;	Literals 0 through 10 may be coerced from I2 to R4 by modification
;	of the executor for these literals.
;
;	If types match, no action is performed.
;
;Inputs:
;	ax = oTyp of expression (with high bits set) (Record = ET_RC)
;	bx = oTx of expression
;	cx = oTyp of target
;Outputs:
;	bx = oTx of expression, after coercion
;	si and di updated if insertion needed
;Exceptions:
;	If expression or target type is not numeric, Type Mismatch Error
;	is generated.
;
;	Coercion token insertion may cause the text table to grow.  This
;	may result in OME.

	public	SsCoerceReg
SsCoerceReg:
	cmp	ax,ET_I2+ST_Lit 	;Determine if lit without operand
	jne	NoLitCoerce		;Can't optimize by replacing lit executor
	cmp     cx,ET_R4		
	jz	LitCoerce		
	cmp	cx,ET_R8
	jne	NoLitCoerce
LitCoerce:
;Target type is R4/R8, so replace executor with 1 word 8087 literal
	mov	dx,bx			;Preserve address of this executor
	mov	bx,PTRTX[bx-2]		;Load literal executor
	GetCodeIntoDs	SCAN		
	mov	bl,byte ptr [bx-1]	; Load MSB of opcode
	push	ss			
	pop     ds			
	.erre	OPCODE_MASK EQ 03ffh	; Assure following code is ok
;	and	bx,HIGH (NOT OPCODE_MASK)
	and	bx,0fch 		; Clear unwanted bits
	shr	bx,1			; Convert to word offset
	mov     ax,mOpExLitR8[bx]	; Get corresponding R8 lit executor
	mov	bx,dx			;Restore address of I2 executor in text
	mov	PTRTX[bx-2],ax		;Store the new R4 literal executor.
EndCoerce:
	ret

RecordChk:
;	At this point, the coercion has been determined to be from a record.
;	However, the true oTyp of the record is not saved on the scan stack
;	ET_RC was used instead.  This code will use the oTx of the IdLd to
;	find the oVar and in turn the true oTyp of the source.	This is
;	then compared to CX to check that types match.	No coercion is
;	possible among records so there is either an error or nothing.
;
;	ax = oTyp of source expression
;	bx = oTx of source expression
;	cx = oTyp of target

	;In non-SizeD versions, it is possible that the oTx from the scan
	;stack will point after an exCopyTmpAr and exPushSeg instead of an
	;exIdLd, exAIdLd, or exOffLd.  To differentiate between the two, the
	;exPushSeg executor is forced to start at an odd address.  Since an
	;oVar and oElem must be even, the exPushSeg can be recognized.

	    cmp     PTRTX[bx-2],codeOFFSET exPushSeg
	    jne     @F			; Brif exIdLd, exAIdLd, or exOffLd
	    DbAssertRel PTRTX[bx-10],e,<codeOFFSET exCopyTmpAr>,SCAN,<SsCoerceReg: exCopyTmpAr>
	    sub     bx,10		; Backup over inserted executors
@@:
	mov	dx,cx			; DX = oTyp of target
	call	GetTrueType		; CX = oTyp of source
	cmp	cx,dx			; Do oTyps match?

	public	TMError,TMErrorNZ
TMErrorNZ:
	;Report type mismatch error if Z flag not set.
	jz	NoError
TMError:
	;Report type mismatch error.  All registers preserved.
	push	ax
	mov	ax,ER_TM		;Type mismatch error
	call	SsError
	pop	ax
NoError:
	ret

NoLitCoerce:
;Calculate the implicit coercion executor by entering tImpCo as a two
;dimensioned table of executor addresses.
	.erre	ET_RC EQ 0		; Assure JZ is sufficient
	or	al,al			
	jz	RecordChk		; Brif source is record
	cmp	cx,ET_MAX		; Is target a primitive type?
	ja	TMError 		; Brif not.  This is an error
	call	MSdFs			; Map ET types: FS=SD
	xchg	ax,cx			; AX = Target type
	call	MSdFs			; Map target type too
	cmp	ax,cx			;Types already match?
	je	EndCoerce		; If match, skip coercion

        .erre   ET_SD EQ 5

	add	ax,cx			;AX = Source + Target
	shl	cx,1			;CX = Source * 2
	shl	cx,1			;CX = Source * 4
	add	ax,cx			;AX = Source * (5|7) + Target
	xchg	ax,bx			;AX = oTx, BX = Table index
	shl	bx,1			;To word index
	mov	cx,tImpCo[bx]		;Enter coercion executor table for executor
	xchg	bx,ax			; oTx to bx
	jcxz	EndCoerce
	mov	ax,cx			;Executor to insert to ax
	dec	cx			; Is this 1 (incompatible types)?
	jcxz	TMError 		; Brif yes
;	jmp	short Insert		;Fall into Insert, below


;*** Insert - Insert word into pcode
;
;Inputs:
;	ax = word to insert
;	bx = oTx to insert
;	cx = Number of bytes to make room for (InsertCx only)
;	si = scan source
;	di = scan destination
;Outputs:
;	cx = number of bytes inserted
;	bx = input bx + output cx: oTx of point after insertion
;	si, di updated for text moves
;Exceptions:
;	If OME:
;		Error recorded by SsError
;		Carry flag set
;Preserves:
;	ax,bx,dx (bx updated)

public	Insert,InsertCx,InsertBranchBos,InsertBranch,Insert1Op
extrn	exBranch:near

Insert:
	mov	cx,2			;Make room for two bytes
InsertCx:
	cmp	[SsErr],0		;Any errors?
	jnz	InsertFail		;Don't let error location get invalid
	push	ax
	push	bx
	push	cx
	push	dx
;Ensure room.  This may cause source side of text to move within the segment.
	call	SsEnsureGap		;Ensure reasonable gap size
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	jc	InsertOME		;Out of memory error
	or	[SsBosFlags],SSBOSF_Inserted	;Remember insertion occured

;Expand the destination text to make room for add'l executor
	push	si
	mov	si,di
	add	di,cx			;New emit address
	push	di
	push	cx
	mov	cx,si
	sub	cx,bx			;cb between insert oTx and old emit oTx
	shr	cx,1			;count of words
	inc	cx			;Include word at old emit address
	push	es
	pop	ds			;Prepare for es -> es copy
	std				;Copy direction is down
	rep	movsw			;Copy to make room for executor
	cld
	mov	[bx],ax 		;Insert additional executor
	pop	cx
	add	bx,cx			;Point bx to next insertion point
	push	ss
	pop	ds			;Restore data segment
	pop	di
	pop	si
	ret

InsertOME:
	push	ax
	mov	ax,ER_OM	;Signal out-of-memory error
	call	SsError
	pop	ax
InsertFail:
	stc			;Inform caller to make sure nothing is inserted
	ret


;***
;InsertBranchBos
;
;Purpose:
;	Inserts an exBranch after opBos in current line.
;Entry:
;	cx = operand
;Exit:
;	bx - oTx after inserted exBranch
;	si, di - adjusted for inserted pcode
;Preserves:
;	cx
;******************************************************************************
InsertBranchBos:			;Insert Branch after opBos
	mov	bx,[SsOTxStart] 	; Points to first opcode after BOS
InsertBranch:
	mov	ax,codeOFFSET exBranch
Insert1Op:
;Insert opcode in ax with operand in cx
;Preserves all (bx updated)
	push	cx
	mov	cx,4			;Has a 2-byte operand
	call	InsertCx
	pop	cx
	jc	NoOperand
	mov	PTRTX[bx-2],cx
NoOperand:
	ret



subttl	Executor Input Types Maps
page

;	These tables allow rapid calculation of what coercion is required
;	for parameters for most BAsiC statements and functions.
;
;	The naming convention is:
;		tCo<input arg count><input type reqs|>to<required type>
;
;	where:
;		<input arg count> is the number of dimensions in the table.
;		<input type reqs> shows the limitations on the types handled
;				  by the statements/functions using this table.
;				  This field may be empty.
;		<required type>   This is the required final coerced type rule.
;				  This is different for "+" and "*" for
;				  example, as both have the same required type
;				  rule (types must be the same), but "*" has
;				  an input types restriction (no strings).
;
;
;	These tables are used to calculate the required input type for unary
;	operators and cases where binary operators require input types coerced
;	to be equal.
;
;	RulTab and related macros added with [14]
;
;------------------------------------------------------------

;Initialize a two-dimensional coercion table
StartTab	MACRO
LinNo	=	0
	ENDM

;Only define a byte if condition is true
DbIf	MACRO	Byte,Cond
IF	Cond
	db	Byte
ENDIF
	ENDM

;Associate a line number (LinNo) with a type
LinNo	=	0
	IRP	Typ,<I2,I4,R4,R8,Cy,Sd,Tx,Field>
LinNo	=	LinNo+1
Lin&Typ	=	LinNo
	ENDM

;Make a line of two-dimensional table
RulTab	MACRO	I2,I4,R4,R8,Cy,Sd,Tx,Field
LinNo	=	LinNo+1

IF	LinNo EQ LinCy
	EXITM
ENDIF
IF	LinNo EQ LinTx
	EXITM
ENDIF
IF	LinNo EQ LinField
	EXITM
ENDIF

	RulLine	I2,I4,R4,R8,Cy,Sd,Tx,Field

	ENDM

;Make a line of a coercion table using only those types enabled
RulLine	MACRO	I2,I4,R4,R8,Cy,Sd,Tx,Field
	Db	I2
	Db	I4
	Db	R4
	Db	R8
	Db	Sd
	ENDM

tCo2toSame:
	StartTab
	public	tCo1toNotSD		
tCo1toNotSD:
RulTab	ET_I2,	ET_I4,	ET_R4,	ET_R8,	ET_CY,	LOWUND,   LOWUND, ET_FIELD;I2
RulTab	ET_I4,	ET_I4,	ET_R8,	ET_R8,	ET_CY,	LOWUND,   LOWUND, ET_FIELD;I4
RulTab	ET_R4,	ET_R8,	ET_R4,	ET_R8,	ET_CY,	LOWUND,   LOWUND, ET_FIELD;R4
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_CY,	LOWUND,   LOWUND, ET_FIELD;R8
RulTab	ET_CY,	ET_CY,	ET_CY,	ET_CY,	ET_CY,	LOWUND,   LOWUND, ET_FIELD;CY
RulTab	LOWUND, LOWUND, LOWUND, LOWUND, LOWUND, ET_SD,	  ET_TX,  ET_FIELD;SD
RulTab	LOWUND, LOWUND, LOWUND, LOWUND, LOWUND, ET_TX,	  ET_TX,  ET_TX   ;TX
RulTab	ET_FIELD,  ET_FIELD,  ET_FIELD,  ET_FIELD,  ET_FIELD,  ET_FIELD, ET_TX,  ET_FIELD;Field

;------------------------------------------------------------

tCo2NotSdtoSame:
	StartTab
RulTab	ET_I2,	ET_I4,	ET_R4,	ET_R8,	ET_CY,	LOWUND, LOWUND, ET_FIELD;I2
RulTab	ET_I4,	ET_I4,	ET_R8,	ET_R8,	ET_CY,	LOWUND, LOWUND, ET_FIELD;I4
RulTab	ET_R4,	ET_R8,	ET_R4,	ET_R8,	ET_CY,	LOWUND, LOWUND, ET_FIELD;R4
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_CY,	LOWUND, LOWUND, ET_FIELD;R8
RulTab	ET_CY,	ET_CY,	ET_CY,	ET_CY,	ET_CY,	LOWUND, LOWUND, ET_FIELD;CY
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;SD
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;TX
RulTab	ET_FIELD,  ET_FIELD,  ET_FIELD,  ET_FIELD,  ET_FIELD,  LOWUND, LOWUND, ET_FIELD   ;Field

;------------------------------------------------------------


;------------------------------------------------------------

tCo2toI2I4:
	StartTab
RulTab	ET_I2,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;I2
RulTab	ET_I4,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;I4
RulTab	ET_I4,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;R4
RulTab	ET_I4,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;R8
RulTab	ET_I4,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;CY
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;SD
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;TX
RulTab	ET_I4,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4	;Field

;------------------------------------------------------------

tCo2toR4R8:
	StartTab
RulTab	ET_R4,	ET_R8,	ET_R4,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;I2
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;I4
RulTab	ET_R4,	ET_R8,	ET_R4,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;R4
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;R8
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;CY
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;SD
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;TX
RulTab	ET_R8,	ET_R8,	ET_R8,	ET_R8,	ET_R8,	LOWUND,	LOWUND,	ET_R8	;Field

;------------------------------------------------------------


;------------------------------------------------------------
tCo2toI2R4:
	StartTab
RulTab	ET_I2,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;I2
RulTab	ET_R4,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;I4
RulTab	ET_R4,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;R8
RulTab	ET_R4,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;R8
RulTab	ET_R4,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;CY
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;SD
RulTab	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND,	LOWUND	;TX
RulTab	ET_R4,	ET_R4,	ET_R4,	ET_R4,	ET_R4,	LOWUND,	LOWUND,	ET_R4	;Field

;------------------------------------------------------------
tCo1toI2SD:
RulLine	ET_I2,	ET_I2,	ET_I2,	ET_I2,	ET_I2,	ET_SD,	ET_TX,	ET_FIELD


;------------------------------------------------------------
tCo1toI2I4:
RulLine	ET_I2,	ET_I4,	ET_I4,	ET_I4,	ET_I4,	LOWUND,	LOWUND,	ET_I4

;------------------------------------------------------------
tCo1toSame:
RulLine	ET_I2,	ET_I4,	ET_R4,	ET_R8,	ET_CY,	ET_SD,	ET_TX,	ET_FIELD

	subttl	Coercion Rules Table
	page

MakRule MACRO
irule = 0
;Rule names are composed of two parts - the input specification
;   and the output specification.  The naming convention is:
;
;	SSR_<input spec>_<output spec>
;
;	<input spec> starts with the number of arguments
;	<output spec> of <LOWUND> indicates op emits the input type.
;
;NOTE:
;   Rules that have an output type the same as the only input type could
;   be represented with <LOWUND> or an explicit type as <output spec>.
;   These are not the same rule, as some scan routines require explicit
;   type as <output spec>.  However, there are no scan routines that
;   handle <LOWUND> as <output spec> but do not handle an explicit type.
;
;NOTE:
;   If output type = ET_MAX then no coercion routine uses that output type.
;   That rule field could be modified for use by some other scan routine.
;
;params:       <ispec><ospec>,	coercion table,  output type

	ruler	2Any_Same,	tCo2toSame,	<LOWUND>
	ruler	2NotSD_Same,	tCo2NotSDtoSame,<LOWUND>
	ruler	2I2I4_Same,	tCo2toI2I4,	<LOWUND>
	ruler	2R4R8_Same,	tCo2toR4R8,	<LOWUND>

	public	SSR_Div 				    

SSR_Div equ	SSR_2R4R8_Same				    

	ruler	2I2R4_I2,	tCo2toI2R4,	ET_I2
	ruler	2Any_I2,	tCo2toSame,	ET_I2


	ruler	2I2R4_None,	tCo2toI2R4,	0



	ruler	1NotSD_Same,	tCo1toNotSD,	<LOWUND>
	ruler	1I2I4_Same,	tCo1toI2I4,	<LOWUND>

	ruler	1I2I4_SD,	tCo1toI2I4,	ET_SD
	ruler	1I2SD_SD,	tCo1toI2SD,	ET_SD


	ruler	1I2SD_I4,	tCo1toI2SD,	ET_I4
	ruler	1NotSD_I2,	tCo1toNotSD,	ET_I2
	ruler	1NotSD_SD,	tCo1toNotSD,	ET_SD

	ruler	1Any_None,	tCo1toSame,	0
	ruler	1I2SD_None,	tCo1toI2SD,	0
;Label Reference Rules
;	       <#labs,#args>	<arg coercion>	<#label>
	ruler	1Lab0Arg,	UNDEFINED,	1
	ruler	1LabMain0Arg,	UNDEFINED,	<1 OR 80h>
	ruler	nLab1Arg,	0,		LOWUND

;Rules for SS_4ET_ET
;     NOTE: The low order nibble applies to the LAST argument in the syntax.
;	    The rule names are in syntax order.

	ruler	I2_None,	<ET_I2>, 		0
	ruler	I4_None,	<ET_I4>, 		0
	ruler	R4_None,	<ET_R4>, 		0
	ruler	R8_None,	<ET_R8>, 		0
	ruler	SD_None,	<ET_SD>, 		0
	ruler	I4I2_None,	<ET_I4,ET_I2>,		0
	ruler	I2I4_None,	<ET_I2,ET_I4>,		0
	ruler	R4I2_None,	<ET_R4,ET_I2>,		0
	ruler	I2SD_None,	<ET_I2,ET_SD>,		0
	ruler	2I2_None,	<ET_I2,ET_I2>,		0
	ruler	2SD_None,	<ET_SD,ET_SD>,		0
	ruler	I2R4_None,	<ET_I2,ET_R4>,		0
	ruler	SDI2_None,	<ET_SD,ET_I2>,		0
	ruler	SDI4_None,	<ET_SD,ET_I4>,		0
	ruler	SD2I4_None,	<ET_SD,ET_I4,ET_I4>,	0
	ruler	I42I2_None,	<ET_I4,ET_I2,ET_I2>,	0
	ruler	SD2I2_None,	<ET_SD,ET_I2,ET_I2>,	0
	ruler	SDI2SD_None,	<ET_SD,ET_I2,ET_SD>,	0
	ruler	4I2_None,	<ET_I2,ET_I2,ET_I2,ET_I2>,0
	ruler	4R4_None,	<ET_R4,ET_R4,ET_R4,ET_R4>,0
	ruler	SDI2SDI2_None,	<ET_SD,ET_I2,ET_SD,ET_I2>,0

	ruler	I2_I2,		<ET_I2>, 		ET_I2
	ruler	I2_I4,		<ET_I2>, 		ET_I4
	ruler	I2_R4,		<ET_I2>, 		ET_R4
	ruler	I2_SD,		<ET_I2>, 		ET_SD
	ruler	I4_I2,		<ET_I4>, 		ET_I2
	ruler	I4_I4,		<ET_I4>, 		ET_I4
	ruler	I4_SD,		<ET_I4>, 		ET_SD
	ruler	R4_R4,		<ET_R4>, 		ET_R4
	ruler	R4_SD,		<ET_R4>, 		ET_SD
	ruler	R8_SD,		<ET_R8>, 		ET_SD
	ruler	SD_I2,		<ET_SD>,		ET_I2
	ruler	SD_I4,		<ET_SD>,		ET_I4
	ruler	SD_R4,		<ET_SD>,		ET_R4
	ruler	SD_R8,		<ET_SD>,		ET_R8
	ruler	SD_SD,		<ET_SD>,		ET_SD

	ruler	I2I4_I2,	<ET_I2,ET_I4>,		ET_I2
	ruler	I2I2_SD,	<ET_I2,ET_I2>,		ET_SD
	ruler	I2I2_I2,	<ET_I2,ET_I2>,		ET_I2
	ruler	I2I2_I4,	<ET_I2,ET_I2>,		ET_I4
	ruler	SDSD_I2,	<ET_SD,ET_SD>,		ET_I2
	ruler	I2SD_SD,	<ET_I2,ET_SD>,		ET_SD
	ruler	SDI2_SD,	<ET_SD,ET_I2>,		ET_SD


	ruler	R4I2_R4,	<ET_R4,ET_I2>,		ET_R4
	ruler	3I2_I2, 	<ET_I2,ET_I2,ET_I2>,	ET_I2
	ruler	I2SDSD_I2,	<ET_I2,ET_SD,ET_SD>,	ET_I2
	ruler	SD2I2_SD,	<ET_SD,ET_I2,ET_I2>,	ET_SD



	ENDM

;First define the rule name constant and build a table of the word parameter
ruler	MACRO rname,ptCoerce,oTypOut
	;params are rule name, coercion table,	output type
	SSR_&rname	=	irule
	irule		=	irule + 1
Rule	=	0
	IRP	Arg,<ptCoerce>
Rule	=	Rule*10H+Arg
	ENDM
	dw	Rule
	ENDM

PUBLIC	tRuleWord
tRuleWord:
	MakRule

;Next build a table of the byte parameter
ruler	MACRO rname,ptCoerce,oTypOut
	;params are rule name, coercion table,	output type
	db	oTypOut
	ENDM

PUBLIC	tRuleByte
tRuleByte:
	MakRule

	.xlist
	include ssoprule.inc
	.list
sEnd	SCAN
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\sstxutil.asm ===
page	49,132
	TITLE	sstxutil - scanner text table management utilities
;***
;sstxutil.asm	- scanner text table management utilities
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	The scanner behaves as a filter, reading pcode in one state
;	and emiting it in another.  The SS_EXECUTE state is larger than
;	either of the other two states, as coercion, opBranch and
;	procedure invocation support executors are present in SS_EXECUTE
;	mode only.
;
;	At the beginning of scan, the text table is moved up in memory.
;	It is then scanned to a point starting at the beginning of the segment.
;
;	When the text expands, a test is made to ensure that there is still
;	space between the source side of the filter and the emit side.  If
;	room is tight, then the unscanned pcode is moved farther up within
;	the segment.
;
;	Links through the pcode are updated when they are scanned, not when
;	the text moves.  For each link list in the text there is a control
;	structure that maintains information about that link list.  See the
;	LNK structure.
;
;
;****************************************************************************

	.xlist
	include		version.inc
SSTXUTIL_ASM = ON
	IncludeOnce	scanner
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	.list


assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA



sBegin	SCAN
assumes cs, SCAN

subttl	
page
;***
;SsEnsureGap
;Purpose:
;	Ensure a gap between the scanner emit side and the source side.
;
;	This routine updates the LNK link control structures used to
;	maintain link lists through the text during scan.  The actual link
;	lists are maintained when the pcodes containg the links are updated.
;
;	The text is only actually moved if one of the two conditions is met:
;	1. The movement would be more than SS_oTxMovThreshold.
;	2. The movement is required to ensure the minimum gap of SS_oTxGapMin.
;
;	When an allocation fails, it is retried with SS_cbTxAllocInc.  OME
;	is detected by noting when the allocation size drops below the 
;	allocation required to maintain the minimum gap between source and
;	emit side in the scanner - SS_cbTxGapMin.
;
;
;	Gap control constants are:
;	SS_oTxMovThreshold	- moves below this aren't made unless necessary
;				  to maintain SS_cbTxGapMin.
;	SS_cbTxAllocInc		- amount by which a request is decremented
;				  before retrying.
;	SS_cbTxGapMin		- minimum required gap size
;
;	Variable SscbTxExpand is maintained as the total bytes of text
;	expansion.
;
;Input:
;	si = 	oTxSrc      - first byte to move
;	di =	oTxEmit     - last byte emited by scanner + 1
;	cx =	cbTxGapPref - preferred gap size (SsMakeGap only)
;Output:
;	si = new address of low byte of source side
;	carry flag set if OME    
;
;**********************************************************************
SS_cbTxMovThreshold	= 64	;cb of minimum move
SS_cbTxAllocInc		= 128	;Decrement by this amount when allocation fails
SS_cbTxGapMin		= 20	;At least 20 bytes between source and emit

SsMakeGap:
public	SsMakeGap
	xor	ax,ax			;No current gap
	and	cl,0FEH			;Always move whole words
	cmp	cx,SS_cbTxMovThreshold	;Request more than minimum?
	jb	MinMove
	jmp	short FigMove

SsEnsureGap:
public	ssEnsureGap
	mov	ax,si
	sub	ax,di			;ax = cb Current gap
	cmp	ax,SS_cbTxGapMin	;Is it big enough now?
	jae	EnsureGapOK		;Yes - exit
MinMove:
	mov	cx,SS_cbTxMovThreshold	;Minimum move to try
FigMove:
	mov	dx,SS_cbTxGapMin	;Absolute minimum allowed gap
	sub	dx,ax			;dx = min move to get to required gap

EnsureAllocLoop:
;	cx = cbMovMax (getting smaller each loop)
;	dx = cbMovMin

	push	cx			;Save cbMovMax
	push	dx			;  and cbMovMin
	Arg	si			;pFirst byte of pcode to move
	Arg	cx			;cbMove
	cCall	TxtMoveUpFar		; Attempt to move the text
	GETSEGTXTCUR			;es = the text segment
	pop	dx
	pop	cx
	or	ax,ax			;Test for success
	jnz	EnsureGapGrew		;Movment succeded - exit
	cmp	cx,dx			;Trying minimum move?
	jz	EnsureGapOME
	sub	cx,SS_cbTxAllocInc	;Decrement for retry
	cmp	cx,dx			;Less than minimum?
	jge	EnsureAllocLoop		;Retry if more than minimum
	mov	cx,dx			;Try absolute minimum
	jmp	EnsureAllocLoop		; and retry

EnsureGapOME:
	stc				;Signal OME
	ret

EnsureGapGrew:
	add	SscbTxExpand,cx		;Update total bytes of movement
	add	si,cx
EnsureGapOK:
	clc
	ret

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssif.asm ===
page	49,132
TITLE	ssif	- scan support for IF related opcodes
;***
;ssif.asm
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Scan IF statement opcodes.
;
;   Runtime behavior of IF-THEN-ELSE opcodes:
;   ----------------------------------------
;      <exp> opStIf(oText) 	    - branch to oText if exp is zero (false)
;      <exp> opStIfLab(label) 	    - branch to label if exp is non-zero (true)
;      <exp> opStIfLabDirect(label) - branch to label if exp is non-zero (true)
;      opStElse(oText) 		    - unconditionally branch to oText
;      opStElseLab(label) 	    - unconditionally branch to label
;      opStElseLabDirect(label)     - unconditionally branch to label
;      opStElseNop 		    - nop
;      <exp> opStIfBlock(oText)     - branch to oText if exp is zero (false)
;      <exp> opStElseIf(oText)      - branch to oText if exp is zero (false)
;      opStEndIfBlock 		    - nop
;
;   NOTE: When in direct mode, Parser emits opStIfLabDirect instead of
;         opStIfLab, and opStElseLabDirect instead of opStElseLab.
;
;   Single line IF statement syntax to pcode mappings:
;   -------------------------------------------------
;
;      Syntax:  IF <exp> GOTO <label>
;   
;      Pcode:   <exp> opStIfLab(label)
;
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list>
;   
;                            +--------------+
;      Pcode:   <exp> opStIf(|) <stmt list> | opBol
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <label> ELSE <label>
;   
;      Pcode:   <exp> opStIfLab(label) opStElseNop opStElseLab(label)
;
;      ============================================================
;      Syntax:  IF <exp> THEN <label> ELSE <stmt list>
;   
;      Pcode:   <exp> opStIfLab(label) opStElseNop <stmt list>
;
;      NOTE:    <stmt list> can contain more single line IF stmts
;   
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list> ELSE <label>
;   
;                            +-------------------------+
;      Pcode:   <exp> opStIf(|) <stmt list> opStElse(|)|opStElseLab(label)|opBol
;                                                    +--------------------+
;
;      ============================================================
;      Syntax:  IF <exp> THEN <stmt list> ELSE <stmt list>
;   
;                            +--------------------------+
;      Pcode:   <exp> opStIf(|) <stmt list> opStElse(|) | <stmt list> | opBol
;                                                    +----------------+
;   
;   Block IF statement syntax to pcode mappings:
;   -------------------------------------------
;      Syntax:  IF <exp> THEN
;   
;      Pcode:	<exp> opStIfBlock(oText to <exp> before ELSEIF, or oText
;		      beyond ELSE/END IF opcode)
;   
;      ============================================================
;      Syntax:  ELSEIF <exp> THEN
;   
;      Pcode:   opBol <exp> opStElseIf(oTx beyond ELSEIF/ELSE/END IF)
;
;			       +- to beyond END IF	
;      Bound:   opBol exBranch(|) <exp> opStElseIf(oTx past ELSEIF/ELSE/END IF) 
;
;      NOTE:    Scanner inserts exBranch(oText to beyond END IF opcode)
;               after the opBol and before <exp>, so code falling into the
;               ELSEIF will branch beyond END IF without evaluating <exp>.
;   
;      ============================================================
;      Syntax:  ELSE 
;   
;      Pcode:   opStElse(oText to beyond END IF opcode)
;   
;      ============================================================
;      Syntax:  END IF
;   
;      Pcode:   opStEndIfBlock
;   
;	The scan routines within this module depend on the BOL scan routine
;	to bind unbound line IF and ELSE operands.  The BOL scan routine
;	binds all IF/ELSE frame entries until it discovers a Block IF/ELSE
;	entry, some other control structure frame that can't be bound, or
;	the bottom of the stack.
;
;	For speed, the IF and ELSE scan routines set a flag to let BOL know
;	that a line version of IF or ELSE has been pushed.  The flag is
;	cleared by BOL after binding all line IF and ELSE entries.
;
;	The IF and ELSE scan routines will not push a Block frame on the stack 
;	when there is a Line frame already on the stack.
;	
;
;****************************************************************************

	.xlist
	include		version.inc
SSIF_ASM = ON
	IncludeOnce	qbimsgs
	IncludeOnce	opmin		
	IncludeOnce	ssint
	IncludeOnce	variable
	.list

assumes ds, DATA
assumes es, NOTHING
assumes ss, DATA
assumes cs, SCAN

sBegin	SCAN
subttl	Static data area definitons.
page
;***
;Ss_If, Ss_IfBlock
;Purpose:
;	Scan entries for IF.
;
;	Scan tasks for IF include:
;	- ensuring the entry type is a fundamental, non string data type.
;	- selecting the IF executor varient for the argument data type.
;	- binding the label of opStIfLab<Direct|>
;	- pushing an IF frame on the scan stack as follows:
;		push  UNDEFINED for start of block IF exBranch chain
;		push  oTx of IF operand
;		push  IF frame label (identifying Standard, Block, or Label IF)
;
;Input:
;	Standard scan entrypoint
;Output:
;	Standard scan exit
;***************************************************************************
SsProc	IfLab
	mov	dx,STYP_IfLab		;Type of stack entry for IF w/ a label
	jmp	short SsIfCom

SsProc	IfBlock
	mov	dx,STYP_IfBlock		;Type of stack entry for block IF
	jmp	short SsIfCom		;Common IF code

SsProc	If
	mov	dx,STYP_IF		;Push an IF entry on the stack
SsIfCom:
	or	SsFlags,SSF_If		;Set end of line IF handling flag
	pop	ax			;Get type of last expression
	pop	cx			;Remove expression address
	cCall	MapOpToExeNumeric	;Type explode the executor
	STOSWTX				;Emit the executor
	PUSHI	ax,UNDEFINED		;Push end of Block IF ExBranch chain
	push	di			;Push operand address
	push	dx			;Push frame type
	test	dx,STYP_Lab		;Is this an IF w/ a label 
	jnz	SsIfLab 		;Brif yes
	MOVSWTX				;Skip the operand in source and dest.
SsIfComX:
	mov	bx,sp			
	sub	bx,2			
	mov	[SsBosStack],bx 	; Reset BOS SP mark for 1 Line If
	mov	[SsOTxStart],di 	; Reset DOS oTx mark for 1 Line If
	jmp	[ScanRet]


SsIfLab:				
	mov	ax,PTRTX[si+2]		
	sub	ax,opBos		; Is this an opBos?
	jz	@F			; Brif yes
	dec	ax			; Is this an opBosSp
	jne	ElsePresent		; Brif yes.	Works ok!
@@:					
	push	[ScanRet]		; Save exit address
	mov	[ScanRet],scanOFFSET BindIfLab	; We need to clean up

ElsePresent:				
	;Bind the label for this If

	mov	cx,1			;need to bind 1 label
	jmp	LabelBindCur		;Bind label to current scope and return to
					;to main scan loop

BindIfLab:				
	pop	[ScanRet]		; Restore loop address
	mov	bx,di			; Insert at current location
	call	InsertBranch		; Insert exBranch.  CY set if error.
	jc	SsIfComX		; Brif error
	mov	bx,sp			; Get stack frame pointer
	lea	ax,[di-2]		; oTx of exBranch operand
	mov	[bx].FIF_Id,STYP_Else	; Allow BOL update
	mov	[bx].FIF_oTx,ax 	; Update in frame
	jmp	SsIfComX		; Exit

;***
;Ss_Else,Ss_ElseNop
;Purpose
;	Scan ELSE varients.
;
;	opElseLab<|Direct> requires label binding only.  These are always
;	immediately preceeded by an opStElseNop or opStElse.  Therefore,
;	opElseLab<|Direct> does not need to examine or push a stack entry.
;	So, opElseLab<|Direct> are scanned as label reference opcodes like
;	GOTO.
;
;	Scan tasks for other Else variants are:
;	- emit executor
;	- walk stack frames to find first non-Else/non-ElseNop frame
;	- check for if frame, check errors:
;	  + IF nesting error if frame is not an IF
;	- change IF stack frame to ELSE stack frame
;	  + frame type is Block if IF was a Block type
;	  + set ELSE variant frame type
;	  + opStElseNop just changes frame to Set STYP_Lab bit -
;	    it requires no further binding.
;	  + leave address of exBranch chain, will be bound at ENDIF time
;	  + set address of ELSE operand
;	- bind IF to address of ELSE if it was not a label varient of IF
;
;	Scan tasks for ELSEIF are:
;	- ensure the entry type is a fundamental, non string data type.
;	- select and emit the ELSEIF executor varient for the argument 
;	  data type.
;	- insert an exBranch at BOS for exit from IF clause.
;	- check for an IF frame, check errors:
;	  + IF nesting error if top frame is not an IF
;	  + BLOCK IF error if IF is not a BLOCK IF.
;	- insert new exBranch into chain
;	- change Block IF frame to an ELSEIF frame on the scan stack as follows:
;		set  new start of exBranch chain
;		set  oTx of ELSEIF operand
;		leave IF frame id so next ELSEIF sees a BLOCK IF entry
;
;Input:
;	Standard scanner convention
;Output:
;	Standard scanner convention
;***************************************************************************
SsProc	ElseIf
	pop	ax			;Get type of last expression
	pop	dx			;Remove expression address
	cCall	MapOpToExeNumeric	;Type explode the executor
					; ax = executor
	STOSWTX				;Emit it

	mov	bx,sp			;point to stack frame
	mov	cx,[bx.FIF_oTxBranch]	;get next entry in ExBranch chain
	call	InsertBranchBos 	;insert exBranch after opBos
					;bx = oTx after exBranch operand
	jc	ElseIfScopeError	;Quit if OME
	xchg	ax,bx			;ax = oTx after exBranch operand
	mov	bx,sp			;point to stack frame
	cmp	[bx.FIF_Id],STYP_IfBlock ;ELSEIF must match block IF
	jnz	ElseIfScopeError	;brif nesting error
	dec	ax
	dec	ax			;point to exBranch operand
	mov	[bx.FIF_oTxBranch],ax	;set next link in exBranch chain
	mov	cx,[bx.FIF_oTx] 	;get if operand address
	mov	[bx.FIF_oTx],di 	;set addr of else operand
	xchg	ax,bx			;bx = ptr to txt
	MOVSWTX 			;skip operand in source and destination
	inc	bx
	inc	bx			;move past exBranch operand
	xchg	bx,cx			;bx = ptr to if operand, cx points past
					;inserted exbranch
	mov	PTRTX[bx],cx		;Bind if to ElseIf expression
SsElseIfX:
	jmp	short SsIfComX		

;Error processing for Else opcodes.

ElseIfScopeError:
	mov	cx,STYP_Else		;push an ELSE frame for ELSEIF error
ElseScopeError:
	mov	ax,MSG_ElseWI		;ELSE without IF error
	call	SsError
	cmp	cx,STYP_ElseNop 	;is this ElseNop?
	jz	SsElseIfX		;brif ElseNop - don't push a frame
	PushI	ax,UNDEFINED		;Flag no exbranch chain
	push	di			;push else operand location
	push	cx			;push else frame
	MOVSWTX 			;skip operand in source and dest
	or	[SsFlags],SSF_IF	;need BOS If processing to remove frame
ElseScopeErrX:
	jmp	short SsElseIfX 	;continue scanning

SsProc	ElseNop
	mov	cx,STYP_ElseNop 	;Signal no stack entry
	jmp	short SsElseCom

SsProc	Else
	mov	cx,STYP_Else		;Prepare to build ELSE frame
SsElseCom:
	STOSWTX				; and emit it
	mov	bx,sp			;set up Frame addressablity
	sub	bx,SIZE FIF		;Adjust for following add

; Skip all nested single line else's currently on scan stack. Walk
; back to first non-single else frame.	If this frame is not an IF/ELSEIF
; frame, then we have a scoping error. Multiple Single else frames can
; be on the stack if a nested single if occurs in a single line else clause.


SkipSingleElseLoop:
	add	bx,SIZE FIF		;point to next stack frame
	mov	ax,[bx.FIF_Id]		;ax = frame type
	cmp	ax,STYP_Else		;is this a single line else frame?
	jz	SkipSingleElseLoop	;brif so, examine next frame
	cmp	ax,STYP_ElseNop 	;is this a frame left from an if <lab>?
	jz	SkipSingleElseLoop	;brif so, examine next frame

; bx - points to first non-single else stack frame.
; ax - frame type of stack frame
; cx - else variant we are processing

	test	ax,STYP_If or STYP_Block
	jz	ElseScopeError		;Not an IF on the stack - scoping error.
	mov	dx,[bx.FIF_oTx] 	;dx = oTx of preceding if operand
	test	ax,STYP_Block		;is frame for BLOCK IF variant?
	jz	NotBlockElse		;brif not - single line variant
	or	cx,STYP_Block		;make this a block else

NotBlockElse:
DbAssertRel cx,nz,<STYP_IfBlock OR STYP_Lab>,SCAN,<Ss_ElseNop:saw opElseNop after BLOCK IF>
	or	SsFlags,SSF_IF		;we may need BOL If processing
	mov	[bx.FIF_Id],cx		;set frame as processed
	test	cx,STYP_Lab		;is this ElseNop?
	jnz	SsElseX 		;brif so, no binding needed
	mov	[bx.FIF_oTx],di 	;emit else op location for else binding
	MOVSWTX 			;skip operand in source and dest
	mov	bx,dx			;bx = If operand location
	mov	PTRTX[bx],di		;bind previous IF/ELSEIF to ELSE
SsElseX:
	jmp	SsIfComX		

EndIfScopeError:
	push	ax			;Restore stack state
	mov	ax,MSG_EWI		;ENDIF without block IF
	call	SsError
	jmp	short EndifX

SsProc	EndIf
	STOSWTX 			; and emit it
	pop	ax
	test	ax,STYP_Block		;Is it a Block type frame entry
	jz	EndIfScopeError		;Not a block IF or ELSE
	pop	bx			;Pop stack frame
	mov	PTRTX[bx],di		;Bind block IF or ELSE to this location
	pop	bx			;get ptr to start of exBranch chain
	call	BindExitCur		;call common EXIT chain binder
EndifX:
	jmp	[ScanRet]		; and continue

;MapOpToExeNumeric
;Purpose:
;	Type explode to executor for this opcode.
;
;	This routine works for full type explosion for numeric
;	data types only
;Input: 
;	ax = type from stack entry
;	bx = opcode * 2
;Output:
;       ax = executor
;Preserves:
;	cx,dx

	public	MapOpToExeNumeric
MapOpToExeNumeric:
	mov	bx,mpOpExe[bx]		;Load the exe map address
	.erre	ST_Typ_Mask EQ 0ffh	; Assure CBW is sufficient
	cbw				; Clear flags in scan stack
	.erre	ET_RC EQ 0		; Assure that DEC is sufficient
	dec	ax			; ET_RC -> 0FFFFh
	cmp	al,ET_MaxNum		; Detect user defined type
	jb	MapType 		;SD and record version not in language

	call	TMError 		
	.erre	ET_I2 EQ 1		; Assure XOR is sufficient
	xor	ax,ax			; Use I2 executor
MapType:
	add	bx,ax
	add	bx,ax			;Index to executor for this type
	mov	ax,word ptr cs:[bx]	; Load executor, zero relative
	ret

subttl	Opcode to executor maps for IF
page
public mStIfBlockOpExe
mStIfBlockOpExe:
	DWEXT	exStIfBlockI2
	DWEXT	exStIfBlockI4
	DWEXT	exStIfBlockR8
	DWEXT	exStIfBlockR8

public	mStIfLabDirectOpExe
mStIfLabDirectOpExe:
	DWEXT	exStIfLabDirectI2
	DWEXT	exStIfLabDirectI4
	DWEXT	exStIfLabDirectR8
	DWEXT	exStIfLabDirectR8

public	mStIfOpExe
mStIfOpExe:
	DWEXT	exStIfI2
	DWEXT	exStIfI4
	DWEXT	exStIfR8
	DWEXT	exStIfR8

public	mStIfLabOpExe
mStIfLabOpExe:
	DWEXT	exStIfLabI2
	DWEXT	exStIfLabI4
	DWEXT	exStIfLabR8
	DWEXT	exStIfLabR8

public	mStIfGotoLabOpExe
mStIfGotoLabOpExe:
	DWEXT	exStIfGotoLabI2
	DWEXT	exStIfGotoLabI4
	DWEXT	exStIfGotoLabR8
	DWEXT	exStIfGotoLabR8

public	mStElseIfOpExe
mStElseIfOpExe:
	DWEXT	exStElseIfI2
	DWEXT	exStElseIfI4
	DWEXT	exStElseIfR8
	DWEXT	exStElseIfR8

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtdeb.asm ===
TITLE	txtdeb.asm - Text Mgr's Debugger support

;==========================================================================
;
;	Module:  txtdeb.asm - Text Mgr's Debugger support
;	System:  Quick BASIC Interpreter
;
;=========================================================================*/

	.xlist
	include		version.inc
	TXTDEB_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	opcontrl
	includeOnce	opid
	includeOnce	opmin
	includeOnce	opstmt
	includeOnce	opintrsc
	IncludeOnce	opaftqb4
	includeOnce	parser
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	scanner
	includeOnce	txtint
	includeOnce	txtmgr
	includeOnce	ui
	.list

	EXTRN	B$SASS:FAR

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING

sBegin	DATA
PUBLIC		cWatch
cWatch		DW	0	;number of Watch expressions in system
pWatch		DW	0	;used during WatchInfo
fWatchBuild	DB	0	;non-zero if tWatch contains out-of-date info

;Watch table contains 1 entry for every watch expression/watchpoint
WT_ST		STRUC
WT_oRs		DW	0	;identifies text table with watch expression
WT_otxStart	DW	0	;text offset to start of watch expression
WT_otxEnd	DW	0	;text offset to end of watch expression
WT_filler	DB	0	;WT_value needs to be even byte aligned
WT_valTyp	DB	0	;type of value
WT_value	DB 8 DUP(?)	;holds R8,R4,I4,I2, or SD
WT_ST		ENDS

		EVEN
;runtime needs string descriptors on even byte boundaries.
tWatch		DB (WATCH_MAX+1) * SIZE WT_ST DUP(0) ; "+1" is for instant watch
tWatchEnd	LABEL WORD

sEnd	DATA

sBegin	CODE
;These opcodes mark the start and end of WATCH expressions
;
PUBLIC	tOpWatch
tOpWatch LABEL WORD
	opTabStart	W
	opTabEntry	W,opEndProg
	opTabEntry	W,opWatchExp
	opTabEntry	W,opWatchStop
	opTabEntry	W,opEot

;Table of all the opcodes (1) that are opBreakPoint
;
tOpBp	LABEL WORD
	opTabStart	BP
	opTabEntry	BP,opBreakPoint
	opTabEntry	BP,opEot

;These opcodes can cause screen I/O
; opcodes opPrintSpc opPrintTab opPrintComma opPrintSemi opPrintEos
; opPrintItemComma opPrintItemSemi and opPrintItemEos are all caught
; by executors, so we don't cause screen flicker on File I/O.
;
; END/EXIT FUNCTION/DEF can cause I/O if their caller included
; the function invocation within any I/O stmt, i.e.
;    PAINT (x,y),FNx
; This causes screen flicker for every END/EXIT DEF/FUNCTION/SUB but
; fNextStmtDoesIO() would have to add a lot of slow special-case code
; to catch the cases where the function was not within an I/O stmt.
;
;Certain control structure opcodes must also be included in the
;list since they branch past the bol/bos of other statements
;which may contain I/O opcodes.


tOpIO	LABEL WORD
	opTabStartAll	IO
	opTabEntry	IO,opStElseLabDirect
	;The reason EndDef, EndProc, ExitProc are listed here is
	;for the case when the user does something like:
	; PAINT (x,y),FNx(z)
	
	opTabEntry	IO,opStEndDef
	opTabEntry	IO,opEndSingleDef
	opTabEntry	IO,opStEndProc
	opTabEntry	IO,opStExitProc
	opTabEntry	IO,opStGotoDirect
	opTabEntry	IO,opStGosubDirect
	opTabEntry	IO,opStRunMain
	opTabEntry	IO,opStRunLabel
	opTabEntry	IO,opStBload1
	opTabEntry	IO,opStBload2
	opTabEntry	IO,opStCircle
	opTabEntry	IO,opStCircleColor
	opTabEntry	IO,opStCls
	opTabEntry	IO,opStColor
	opTabEntry	IO,opStDraw
	opTabEntry	IO,opStFiles0
	opTabEntry	IO,opStFiles1
	opTabEntry	IO,opStGraphicsGet
	opTabEntry	IO,opStGraphicsPut
	opTabEntry	IO,opStInput
	opTabEntry	IO,opStKey
	opTabEntry	IO,opStKeyMap
	opTabEntry	IO,opStLine
	opTabEntry	IO,opStLineColor
	opTabEntry	IO,opStLineStyle
	opTabEntry	IO,opStLineStyleColor
	opTabEntry	IO,opStLineInput
	opTabEntry	IO,opStLocate
	opTabEntry	IO,opStPaint2
	opTabEntry	IO,opStPaint3
	opTabEntry	IO,opStPalette0
	opTabEntry	IO,opStPalette2
	opTabEntry	IO,opStPaletteUsing
	opTabEntry	IO,opStPoke
	opTabEntry	IO,opStPreset
	opTabEntry	IO,opStPresetColor
	opTabEntry	IO,opStPset
	opTabEntry	IO,opStPsetColor
	opTabEntry	IO,opStRandomize1
	opTabEntry	IO,opStScreen
	opTabEntry	IO,opStShell0
	opTabEntry	IO,opStShell1
	opTabEntry	IO,opStSystem
	opTabEntry	IO,opStView
	opTabEntry	IO,opStView0
	opTabEntry	IO,opStViewPrint0
	opTabEntry	IO,opStViewPrint2
	opTabEntry	IO,opStViewScreen
	opTabEntry	IO,opStWidth2
	opTabEntry	IO,opStWindow
	opTabEntry	IO,opStWindow0
	opTabEntry	IO,opStWindowScreen
	opTabEntry	IO,opFnInkey_
	opTabEntry	IO,opFnInput_1
	opTabEntry	IO,opFnInput_2
	opTabEntry	IO,opFnPeek
	opTabEntry	IO,opFnPoint2
	opTabEntry	IO,opFnScreen2
	opTabEntry	IO,opFnScreen3
	opTabEntry	IO,opFnShell
	opTabEntry	IO,opStLoop		
	opTabEntry	IO,opStWend		
	opTabEntry	IO,opStNext		
	opTabEntry	IO,opStNextId		
	opTabEntry	IO,opStSelectCase	
	opTabEntry	IO,opStRandomize0	
	opTabEntry	IO,opBol
		IO_bosMin EQU IO_opBol
	opTabEntry	IO,opBolSp
	opTabEntry	IO,opBolInclude
	opTabEntry	IO,opBolIncludeSp
	opTabEntry	IO,opBolLab
	opTabEntry	IO,opBolLabSp
	opTabEntry	IO,opBos
	opTabEntry	IO,opBosSp
	opTabEntry	IO,opEot


;Table of opcodes used by ToggleBp to ensure that BP line is not a 
;CASE, CASE ELSE, or END CASE statement.

tOpCaseStmt LABEL WORD
	opTabStart	CASESTMT
	opTabEntry	CASESTMT,opStCase
	opTabEntry	CASESTMT,opStCaseTo
	opTabEntry	CASESTMT,opStCaseElse
	opTabEntry	CASESTMT,opStEndSelect
		CASESTMT_CASEMAX = CASESTMT_opStEndSelect
	opTabEntry	CASESTMT,opBol
	opTabEntry	CASESTMT,opBolLab
	opTabEntry	CASESTMT,opBolSp
	opTabEntry	CASESTMT,opBolLabSp
	opTabEntry	CASESTMT,opBolInclude
	opTabEntry	CASESTMT,opBolIncludeSp
	opTabEntry	CASESTMT,opEot

sEnd	CODE

sBegin	CP
assumes	cs,CP

;--------------------------------------------------------------
;		BASIC Debugging support functions
;--------------------------------------------------------------

;**************************************************************
; boolean fBpSet(otxBol)
; Purpose:
;	Return TRUE if indicated line has a breakpoint set.
; Entry:
;	otxBol = text offset to beginning of line opcode for line
;	grs.fDirect must be FALSE
; Exit:
;	al = ax = non-zero if breakpoint was set
;	dx = text offset to opBreakPoint, or where opBreakPoint
;	     could be inserted
;
;**************************************************************
cProc	fBpSet,<PUBLIC,FAR>
	parmW	otxBol
cBegin
	DbAssertRelB [grs.GRS_fDirect],e,FALSE,CP,<fBpSet: fDirect TRUE>
	mov	dx,[otxBol]		
	DbChk	Otx,dx			;error if bx > txdCur.bdlText.cbLogical

;bx = otx to opcode to skip
FbSkipLoop:
	xchg	ax,dx			;pass otx to TxtSkipOp in ax
	call	TxtSkipOp		;skip opBol[Lab][Sp] (or opStSub) opcode
	push	ax			;save ax = otx to potential opBreakPoint
	call	GetDescannedOpcode	;ax = opcode at text offset ax
	pop	dx			;dx = otx to potential opBreakPoint
	cmp	ax,opNoList1
	je	FbSkipLoop		;brif got an opNoList1
	cmp	ax,opStSub
	je	FbSkipLoop		;brif we want to skip a SUB opcode
	cmp	ax,opStFunction
	je	FbSkipLoop		;brif we want to skip a FUNCTION opcode
	cmp	ax,opStDefFn
	je	FbSkipLoop		;brif we want to skip a DEF FN opcode
	sub	cx,cx			;prepare to return FALSE
	cmp	ax,opBreakPoint
	jne	FbExit			;brif breakpoint is not set
	dec	cx			;return TRUE
FbExit:
	xchg	ax,cx			;return boolean in ax
cEnd

;**************************************************************
; GetDescannedOpcode
; Entry:
;	ax = text offset into current text table
; Exit:
;	ax = opcode
;
;**************************************************************
GetDescannedOpcode PROC NEAR
	call	GetWOtx			;ax = opcode at text offset ax
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	GdNotExec		;brif not scanned to SS_EXECUTE
	push	ax
	call	DescanOpcode		;ax = descanned opcode
GdNotExec:
	and	ah,HIGH OPCODE_MASK
	ret
GetDescannedOpcode ENDP

;**************************************************************
; ToggleBp(ln)
; Purpose:
;	Sets or Reset a breakpoint at the indicated line.
;	For most lines, the opBreakPoint is inserted immediately
;	after the opBolXXX.  For SUB, FUNCTION, and DEF FNs,
;	the opBreakPoint is inserted immediately after the
;	opStSub/Function/DefFn opcode so when the procedure is
;	invoked, the breakpoint will be executed.
; Exit:
;	[17]if no error occurs then ax = 0 otherwise
;	[17] ax = txtErr.errcode = error code
;	cBreakpoints - Incremented or decremented.
;
;**************************************************************
cProc	ToggleBp,<PUBLIC,FAR>,<si>
	parmW	ln
cBegin
	call	TxtDescanCP
	push	[ln]
	call	OtxOfLn			;ax = text offset to start of line
	cCall	fBpSet,<ax>		;ax = 0 if line has no breakpoint
	mov	si,dx			;si = dx = otx to opBreakPoint
	or	ax,ax			
	jne	TglBpSet		;brif breakpoint is set

;if target statement of break point is CASE, CASE ELSE, or END SELECT
;then report an error
	push	si			
	PUSHI	ax,<CODEOFFSET tOpCaseStmt> 
	call	TxtFindOp		;dl = txtFindIndex
	cmp	dl,CASESTMT_CASEMAX	
	ja	SetBp			;brif hit end of line before case
	mov	[txtErr.TXER_fDirect],0	;error not in direct mode
	mov	[txtErr.TXER_oRs],UNDEFINED ;don't try to position cursor
	mov	ax,MSG_NoBpCase		;"no bp on case clause or end select"
	mov	[txtErr.TXER_errCode],ax 
	jmp	SHORT TgbErrExit	
SetBp:

;si = text offset to where BreakPoint is to be inserted
;make room for new breakpoint opcode by copying old text up in memory
;
	push	si
	PUSHI	ax,2
	call	TxtMoveUp
	je	TgbExit			;return FALSE if no memory

	push	si
	PUSHI	ax,opBreakPoint
	call	PutWOtx			;insert breakpoint pcode in text table

	;Update program counter, prs.otxDef fields for affected PRSs,
	; and linked lists through this text table's pcode
	
	mov	bx,si			;bx = updated otxInsert
	inc	bx
	inc	bx			;bx = offset beyond inserted pcode
	call	TxtInsUpdate
	jmp	SHORT TgbExit

;si = text offset to breakpoint to be deleted
TglBpSet:
	push	si
	inc	si
	inc	si
	push	si
	call	TxtDelete
TgbExit:
	xor	ax,ax			;return ax = 0 for no error
TgbErrExit:				
cEnd

;**************************************************************
; ClrBpAll()
; Purpose:
;	Reset all breakpoints in the loaded program.
;
; Input:
;	fCountBp - If fCountBp is TRUE then the breakpoints are only counted.
;
;**************************************************************
PUBLIC	ClrBpTxt
ClrBpTxt PROC NEAR
	push	si			;save caller's si
	call	TxtDescanCP
	sub	si,si			;start at beginning of text table
CbLoop:
	push	si
	PUSHI	ax,<CODEOFFSET tOpBp>
	call	TxtFindOp		;ax = offset to next opBreakPoint
					;dl = [txtFindIndex]
	cmp	dl,BP_opEot
	je	CbDone			;brif done with loop
	xchg	si,ax			;si = otxNext
	push	si
	lea	ax,[si+2]		;ax = offset beyond opBreakPoint
	push	ax
	call	TxtDelete		;delete the break point
	jmp	SHORT CbLoop

CbDone:
	mov	ax,sp			;return TRUE (non-zero)
	pop	si			;restore caller's si
	ret	
ClrBpTxt ENDP

PUBLIC	ClrBpAll
cProc	ClrBpAll,<FAR,PUBLIC>		
cBegin	ClrBpAll			
	mov	bx,CPOFFSET ClrBpTxt
	call	ForEachTxtTbl


cEnd	ClrBpAll			



;**************************************************************
; SkipStop
; Purpose:
;	If the next opcode to be executed is an opStStop
;	or opBreakPoint, skip it.  This is called by the
;	user interface for SingleStep and GoTillCursor
;	so the user doesn't have to step twice for a stmt
;	that has a STOP or BREAK-POINT.
; Entry:
;	grs.oRsCur, grs.otxCONT and grs.fDirect identify 
;	next opcode to be executed
; Exit:
;	grs.otxCONT is bumped by 2 if it was opStStop or opBreakPoint
;
;**************************************************************
cProc	SkipStop,<PUBLIC,FAR>
cBegin
	mov	ax,[grs.GRS_otxCONT]
	inc	ax
	je	DontSkipIt		;brif can't CONT
	dec	ax
	call	GetDescannedOpcode	;ax = opcode at text offset ax
	cmp	ax,opBreakPoint
	je	SkipIt
	cmp	ax,opStStop
	jne	DontSkipIt
SkipIt:
	add	[grs.GRS_otxCONT],2
DontSkipIt:
cEnd


;Table of opcodes skipped over while tracing
tNops	LABEL WORD
	DW opLabSp			; Moved these 2 to start of table
	DW opLab			; to make special case easier.
	DW opStConst
	DW opStData
	DW opStDeclare
	DW opStDefType
	DW opStRem 
	DW opQuoteRem
	DW opStShared
	DW opStStatic
	DW opStType
	DW opStEndType
	DW op_Static
	DW op_Dynamic
	DW op_Include
	DW opBol
	DW opBolSp
	DW opBolInclude
	DW opBolIncludeSp
	DW opBolLab
	DW opBolLabSp
	DW opBos
	DW opBosSp
	DW opEndProg
CW_TNOPS EQU ($-tNops) SHR 1

;**************************************************************
; boolean FAR FExecutable()
; Purpose:
;	Called by User Interface code to determine if we need to
;	show the tracing of the next statement.
;
;	WARNING !!! WARNING !!! WARNING !!! WARNING !!! WARNING
;
;	Slime.	This routine is currently only called from
;	DebugTrace to determine whether or not we should stop
;	on the current line.  For this case we need to skip past
;	opLab[Sp] so we recognize that we need to break on lines
;	like "10 foo: print" or on included lines with line #'s
;	(which get opBolInclude + opLab).  If this routine is
;	ever called from anywhere else this will need to be
;	reexamined.
;
;	WARNING !!! WARNING !!! WARNING !!! WARNING !!! WARNING
;
; Entry:
;	grs.oRsCur, grs.otxCur identify next statment to be executed.
; Exit:
;	Returns false if next statement to be executed contains no
;	executable pcode.  Condition codes are set based on value in ax.
;
;**************************************************************
cProc	FExecutable,<PUBLIC,FAR>,<di>
cBegin
	DbAssertRelB [grs.GRS_fDirect],e,0,CP,<FExecutable: grs.fDirect=0>

	mov	ax,[grs.GRS_otxCur]
FExLoop:				
	push	ax			; save otx we're about to use
	call	GetDescannedOpcode	;ax = opcode at text offset ax
	mov	di,CPOFFSET tNops	;di -> 1st opcode in table to search
	mov	cx,CW_TNOPS
	push	cs
	pop	es
	repne scasw			;search for opcode ax in table pointed
					; to by es:di
	jnz	fExExit 		; brif no match (return AX != 0)
	sub	cx,(CW_TNOPS - 3)	; cx <= 0 if not special match
	jbe	fExMatch		; brif normal match
	pop	ax			; get otx we just used
	inc	cx			; cx = 2 if opLab, 3 if opLabSp
	inc	cx			; cx = 3 if opLab, 4 if opLabSp
	shl	cx,1			; cx = length of opLab[Sp] (6 or 8)
	add	ax,cx			; bump otx past opLab[Sp]
	jmp	short FExLoop		; try next opcode
fExMatch:				
	xor	ax,ax			; return false
fExExit:
	pop	cx			; clean up stack
	or	ax,ax			; set condition codes
cEnd


					; in EB it must be converted to a cProc
;**************************************************************
; boolean FAR fNextStmtDoesIO()
; Purpose:
;	Called by User Interface code to determine if we need to
;	show the Output Screen before tracing the next statement.
;	For example, the following would return TRUE where ^ represents
;	grs.otxCur:
;	   opBol^opPrintEos opBol
;	And the following would return FALSE:
;	  ^opBol opPrintEos opBol
;	   opBol opPrintEos^opBol
;	  ^opBol opStClose opBol
;	   opBol^opStClose opBol
;	   opBol opStClose^opBol
;	Because sometimes, the user interface calls this
;	when it is looking beyond the opBos.
; Entry:
;	grs.fDirect, grs.oMrsCur, grs.oPrsCur, grs.otxCur
;	  indicate the next statement to be executed.
;	If grs.fDirect is TRUE, this function assumes the
;	direct mode buffer is in SS_EXECUTE scan state.
;
; Exit:
;	returns TRUE if any opcodes in the next statement can
;	cause I/O to the screen/keyboard.
;
;**************************************************************
PUBLIC	fNextStmtDoesIO
fNextStmtDoesIO PROC FAR
	push	[grs.GRS_otxCur]
	PUSHI	ax,<CODEOFFSET tOpIO>
	call	TxtFindOp
	sub	ax,ax			;prepare to return FALSE
	cmp	dl,IO_bosMin
	jae	FnExit			;brif stmt can't perform I/O
	dec	ax			;return UNDEFINED (TRUE)
FnExit:
	ret	
fNextStmtDoesIO ENDP

;************************************************************
; WatchMoved
; Purpose:
;	Called every time text is inserted/deleted/scanned/descanned
;	to remember to build table 'tWatch' by scanning all pcode.
;
;************************************************************
PUBLIC	WatchMoved
WatchMoved PROC NEAR
	mov	[fWatchBuild],1
	ret
WatchMoved ENDP

;**************************************************************************
; WatchInfo
; Purpose:
;	Given an index for a watch expression, load registers with info
;	about that watch expression from table tWatch.
; Entry:
;	bx = watch index (0 to n)
; Exit:
;	ax = oRs for text table containing expression
;	cx = otx to start of expression
;	dx = otx to end of expression
;	bx points to 1 byte valTyp, 8 byte value structure
;	grs.fDirect is set to FALSE (because TxtFindNextOp is called)
;	[cWatch] = number of watch expressions in all loaded modules
;
;**************************************************************************
cProc	WatchInfo,<PUBLIC,FAR>,<si>
cBegin
	sub	ax,ax
	cmp	[fWatchBuild],FALSE
	je	GotWatchInfo
	test	[flagsTM],FTM_WatchPcode ;is there any watch pcode anywhere?
	je	GotWatchInfo		;brif not - get out quick
	SetfDirect al			;[19]turn off direct mode
	and	[flagsTM],NOT FTM_WatchPcode ;clear flag, gets reset after
					; WatchBuildNext if any pcode is found
	push	bx			;preserve iWatch

	mov	[fWatchBuild],al
	mov	[cWatch],ax
	mov	ax,dataOFFSET tWatch
	mov	[pWatch],ax
	mov	bx,CPOFFSET WatchBuildNext
	call	ForEachTxtTbl

	pop	bx			;bx = iWatch
	cmp	[cWatch],0		;was any watch pcode found?
	je	GotWatchInfo		;brif not
	or	[flagsTM],FTM_WatchPcode ;we have some watch pcode
GotWatchInfo:
	mov	cl,4
	shl	bx,cl			;bx = iWatch * 16
.errnz	(SIZE WT_ST) - 16
	add	bx,DATAOFFSET tWatch	;bx points to entry
	xchg	si,bx			;si points to watch entry
	lodsw				;ax = oRs of watch entry
.errnz	WT_oRs - 0
	push	ax
	lodsw				;ax = otxStart of watch entry
.errnz	WT_otxStart - 2
	push	ax
	lodsw				;ax = otxEnd of watch entry
.errnz	WT_otxEnd - 4
	xchg	dx,ax			;dx = otxEnd
	pop	cx			;cx = otxStart
	pop	ax			;ax = oRs
	xchg	bx,si			;restore caller's si
	inc	bx			;bx points to WT_valTyp entry
.errnz	WT_valTyp - 7
cEnd

;**************************************************************************
; WatchBuildNext
; Purpose:
;	Called for every text table by WatchInfo - finds WATCH pcode
;	and copies relevant information into table tWatch.
;
;**************************************************************************
cProc	WatchBuildNext,<NEAR>,<si,di>
cBegin
	sub	si,si			;start at beginning of table
	mov	di,[pWatch]
NwLoop:
	push	si			;pass otxCur to TxtFindNextOp
	PUSHI	ax,<CODEOFFSET tOpWatch>
	call	TxtFindOp		;ax = offset to next watch pcode
					;dl = [txtFindIndex]
	inc	ax
	inc	ax			;ax now points beyond opWatch opcode
					;i.e. it now ax points to expression
	xchg	si,ax			;si = otxNext, ax=otxPrev
	cmp	dl,W_opEot
	je	NwExit			;brif reached opEot
	cmp	dl,W_opEndProg
	je	NwLoop			;opEndProg just marks start of table,
					;doesn't mean we have a Watch exp
	inc	[cWatch]		;bump # watch expressions in system
	push	ds
	pop	es			;es = DGROUP (for stosw)
	push	ax			;save otxPrev to start of watch exp
	mov	ax,[grs.GRS_oRsCur]
	stosw				;save oRsCur in WT_oRs field
.errnz	WT_oRs - 0
	pop	ax			;ax = otxPrev
	stosw				;save in WT_otxStart field
.errnz	WT_otxStart - 2
	mov	ax,si			;ax = otxNext
	stosw				;save in WT_otxEnd field
.errnz	WT_otxEnd - 4
	inc	di			;di points to WT_valTyp field
	cmp	dl, W_opWatchStop	; Is this a watchpoint?
	jne	@F			
	mov	al, 12H 		; Yes, mark it in watch info.
	stosb				
	dec	di			
@@:					
.errnz	WT_valTyp - 7
	add	di,(SIZE WT_ST) - WT_valTyp	
	DbAssertRel di,be,<dataOFFSET tWatchEnd>,CP,<WatchInfo err 1>
	jmp	SHORT NwLoop

NwExit:
	mov	[pWatch],di		;save for next call
cEnd

;************************************************************
; ZeroWatchVal
; Purpose:
;	Zero a particular Watch value, releasing string if necessary
;	Called from uidebug.asm and WatchRelease below.
; Entry:
;	parm1 points to WT_valTyp field of entry in tWatch
;
;************************************************************
cProc	ZeroWatchVal,<PUBLIC,FAR>	
	ParmW	WatchEntry		
cBegin  ZeroWatchVal			
	mov	bx,[WatchEntry]		
	sub	ax,ax
	cmp	BYTE PTR [bx],24h	;test for string value
	mov	[bx],al	
	je	FreeString		;brif str descriptor needs to be freed
	.errnz WT_value - WT_valTyp - 1
	mov	[bx+1],ax		;zero value so if we later assign
	mov	[bx+3],ax		; won't think garbage is str descriptor
	jmp	SHORT NotString		; a string to this slot, string mgr

FreeString:
	push	ax			;push NULL string descriptor
	push	ax
	mov	ax,sp			;cant push sp, works different on 86/286
	push	ax			;pass ptr to NULL string descriptor
	.errnz WT_value - WT_valTyp - 1
	inc	bx			;bx points to WT_value field
	push	bx			;pass ptr to watch SD
	call	B$SASS			;release string
	pop	ax			;pop NULL string descriptor
	pop	ax
NotString:
cEnd	ZeroWatchVal			

;************************************************************
; WatchRelease
; Purpose:
;	Called before B$RUNINI (runtime initialization),
;	and whenever a watch expression is added or deleted.
;	It sets all values to 0 and releases any strings
;	owned by the WATCH table.
;
;************************************************************
cProc	WatchRelease,<PUBLIC,FAR>,<di>
cBegin
	mov	di,dataOFFSET tWatch
	add	di,WT_valTyp
ZeroLoop:
	cmp	di,DATAOFFSET tWatchEnd
	jae	ZeroDone
	push	di			;push watch entry
	call	ZeroWatchVal		;release it
	add	di,SIZE WT_ST
	jmp	SHORT ZeroLoop

ZeroDone:
cEnd

;************************************************************
; DebugReset
; Purpose:
;	Called by RunInit (just before we call B$RUNINIT) in
;	preparation for program execution.  It does the following:
;	- release any string descriptors owned by Watch table
;	- resets history buffer
; Exit:
;	Preserves grs.fDirect
;
;************************************************************
cProc	DebugReset,<PUBLIC,NEAR>
cBegin
	push	word ptr [grs.GRS_fDirect] ;preserve for caller
	call	WatchRelease		;release any existing WATCH values
					;causes tWatch strings to be released
	sub	bx,bx
	call	WatchInfo		;make sure watch info is up to date
					; since we can't build it after
					; program execution gets under way,
					; because it needs to call TxtFind...
	call	HistReset		;release History buffer
	PopfDirect ax			;restore input setting of this flag
cEnd

;************************************************************
; WatchAdd(fWatchType)
; Purpose:
;	Called whenever the user wants to add a WATCH expression
; Entry:
;	fWatchType = WT_Watch if watch expression is being added
;		     WT_WatchPoint if watch point is being added
;if	FV_INSTWAT
;		     WT_InstantWatch if instant watch is being displayed
;endif
;	ps.bdpSrc contains the 0-terminated source line to be parsed.
;	grs.oMrsCur and grs.oPrsCur identify the scope of the expression.
; Exit:
;	flagsTM.FTM_WatchPcode is set to indicate WatchPcode exists
;	Same as TxtDirect, except ax is meaningless on exit
;
;************************************************************
cProc	WatchAdd,<PUBLIC,FAR>,<si>
	parmB	fWatchType
cBegin

	call	WatchRelease		;release any existing WATCH values
	call	TxtDescanCP		;descan current text table to SS_PARSE
TwRetry:
	call	OtxDefTypeEot		;fill ps.tEtCur[] with default types
					; from end-of-text-table
					;While it is tempting to set
					; the default types to those of
					; grs.otxCONT, we can't do this
					; because if we descan to SS_RUDE,
					; rude-scanner would use def-types
					; of EOT.
	mov	[ps.PS_flags],PSF_fParseExp
	call	ParseLine
	jnc	TwNoParseErr		;brif ParseLine got no error

	;See if the parser wants us to try parsing this line again.  This can
	;happen when:
	; We saw something that made us need to ModuleRudeEdit, but part
	;     of the line's pcode had already been emitted in SS_PARSE
	; Variable manager could not add a variable, because variable heap
	;     was locked (because we can CONTinue).  Parser called AskCantCont
	;     and now wants us to try again (much easier than trying to call
	;     varmgr again from within parser).
	
	test	[ps.PS_flags],PSF_fRetry
	jne	TwRetry			;brif ParseLine wants us to try again
	test	[ps.PS_flags],PSF_UndoEdit
	je	TwErr			;brif user didn't say he wants to back
					; out of the edit while we were in
					; ParseLine (i.e. ParseLine called
					; AskCantCont)
	mov	ax,UNDEFINED
	jmp	SHORT TwErrCode		;tell caller to back out of operation

TwNoParseErr:
	sub	[ps.PS_bdpDst.BDP_pbCur],2
	sub	[ps.PS_bdpDst.BDP_cbLogical],2

	mov	ax,opWatchExp
	cmp	[fWatchType],WT_WatchPoint ; doing a watchpoint?
	jne	TwEmit			; no, emit opWatchExp
	mov	ax,opWatchStop		; emit opWatchStop for watchpoint
TwEmit:
	call	Emit16_AX
	mov	si,[txdCur.TXD_bdlText_cbLogical]
	dec	si
	dec	si			;si = otx to opEot (watch insert point)
	call	TxtInsert		;insert ps.bdpDst in text table at si
	mov	ax,ER_OM		;prepare to return out-of-memory error
	je	TwErrCode		;brif out-of-memory
					;else, ps.errCode = 0, return it
TwErr:
	mov	ax,[ps.PS_errCode]
	and	ah,(PSERR_fAsciiMsg + PSERR_errCode) / 100h
					;mask off parser internal flags
.errnz  PSERR_fAsciiMsg - 8000h		;caller assumes this is high bit
TwErrCode:
	mov	[txtErr.TXER_errCode],ax
	mov	[txtErr.TXER_oRs],UNDEFINED ;don't try to position cursor
	or	[flagsTM],FTM_WatchPcode ;We have watch pcode in system
cEnd

;**************************************************************************
; WatchDel
; Purpose:
;	Given an index for a watch expression, delete pcode for it
;	TxtDelete calls WatchDeleted which causes entry to be discarded
;	from DebugScreen
; Entry:
;	parm1 = watch index (0 to n)
;	grs.fDirect is set to FALSE
; Exit:
;	preserves bx
;
;**************************************************************************
cProc	WatchDel,<PUBLIC,FAR>,<bx>
	parmW	idWatch
cBegin
	mov	bx,[idWatch]
	push	bx			;save idWatch

	call	WatchInfo		;ax = oRs
	push	ax
	call	RsActivateCP		;activate the text table
	call	TxtDescanCP		;descan to SS_PARSE before delete pcode

	pop	bx			;bx = idWatch
	call	WatchInfo		;cx = otxStart, dx = otxEnd
	push	cx			;pass otxStart to TxtDelete
	push	dx			;pass otxEnd to TxtDelete
	call	TxtDelete		;delete the Watch pcode
cEnd

;**************************************************************************
;ChkWatchErr
;Purpose:
;	Called by SystemScan when an error is encountered.
;	Modifies txtErr if error is in Watch expression, so
;	error will be reported to user in better form.
;Entry:
;	txtErr structure contains error information
;Exit:
;	txtErr structure contains updated error information
;
;**************************************************************************
cProc	ChkWatchErr,<PUBLIC,NEAR>,<si>
cBegin
	sub	si,si
CwLoop:
	mov	bx,si			;bx = iWatch for next watch expression
	call	WatchInfo		;ax = oRs for expression's text table
					;bx points to 1 byte valTyp
					;cx = otx to start of expression
					;dx = otx to end of expression

	;we can't do this comparison before calling WatchInfo, because
	;calling WatchInfo can update cWatch
	
	cmp	si,[cWatch]
	jae	CwDone

	inc	si			;bump si for next watch expression
	cmp	ax,[txtErr.TXER_oRs]
	jne	CwLoop			;brif not oRs with error
	cmp	cx,[txtErr.TXER_otx]
	ja	CwLoop			;brif can't be expression of interest
	cmp	dx,[txtErr.TXER_otx]
	jbe	CwLoop			;brif isn't be expression of interest
	mov	BYTE PTR [bx],0FFh	;valtyp = std error code
	mov	ax,[txtErr.TXER_errCode]
	mov	[bx+1],ax		;save error code.  Causes it to be
					; displayed in watch window.
	mov	[txtErr.TXER_oRs],UNDEFINED
					;so we don't try to position the
					; cursor where the error is
CwDone:
cEnd

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtdebug.c ===
/*==========================================================================
*
*  Module:  txtdebug.c
*  System:  Quick BASIC Interpreter
*  Subsystem:  Text Manager
*
*=========================================================================*/
#include "version.h"

#if !CONINT_H
# include "conint.h"
#endif

#if !CONTEXT_H
# include "context.h"
#endif

#if !OPTABLES_H
# include "optables.h"
#endif

#if !OPCODES_H
# include "opcodes.h"
#endif

#if !PARSER_H
# include "parser.h"
#endif

#if !PRSTAB_H
# include "prstab.h"
#endif

#if !QBIMSGS_H
# include "qbimsgs.h"
#endif

#if !RTINTERP_H
# include "rtinterp.h"	/* only needed for DebChkStruct() */
#endif

#if !SCANNER_H
# include "scanner.h"
#endif

#if !TXTINT_H
# include "txtint.h"
#endif

#if !TXTMGR_H
# include "txtmgr.h"
#endif

#if !UI_H
# include "ui.h"
#endif

#if !VARIABLE_H
# include "variable.h"	/* only needed for DebChkStruct() */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtdata.asm ===
TITLE	txtdata.asm - Ascii Load DATA Stmt movement Functions

;==========================================================================
;
;Module:  txtdata.asm
;System:  Quick BASIC Interpreter
;
;This entire module could disappear if previous versions of BASCOM
;either did not allow DATA statements within a SUB, or localized
;access to DATA and RESTORE statements to the context they are in.
;For compatibility, the functions in this module move DATA statements
;and labels for RESTORE statements from SUB/FUNCTIONs to main level code.
;
;
;===========================================================================

	include		version.inc
	TXTDATA_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	msgshort
	includeOnce	names
	includeOnce	opmin
	includeOnce	parser
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	txtint

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING

sBegin	DATA

;-----------------------------------------------------------------------------
;		Description of Table bdData
;
; This table contains 1 entry for every statement in the module significant
; to migration of DATA statements from SUB/FUNCTION to main program.
; The first byte of each entry is a type, which determines what info
; is contained in the rest of the entry as follows:
;
; DT_Data - entry describes a DATA opcode which needs to be moved from an
;           SUB/FUNCTION's text table to the module's text table.
;	    It is followed by 2 byte oPrs and a 2 byte text offset to
;	    the opStData opcode within the prs.  This entry is created
;	    by TDataEntry when text mgr sees opStData during ASCII Load.
;
; DT_Restore - entry describes a RESTORE opcode which may or may not refer to 
;           a label within a SUB/FUNCTION's text table.
;	    It is followed by 2 byte oPrs and a 2 byte text offset to
;	    the opStRestore1 opcode.  This entry is created
;	    by TDataEntry when text mgr sees opStRestore1 during ASCII Load.
;
; DT_EndProc - entry is created when we see the end of a SUB/FUNCTION during
;	    ASCII Load.  It is followed by 2 byte oPrs and a 2 byte text offset
;	    into the module's text table, where the SUB/FUNCTION was encountered
;	    during the Load.
;
; DT_Label - entry describes a new label to be generated in the main program.
;	    This is needed because the label in the prs which was refered to
;	    by a RESTORE, may also be refered to by GOTO or GOSUB.
;	    This entry is created by TDataEnd after the Load has completed.
;
; DT_End  - marks the end of the table.
;
;-----------------------------------------------------------------------------
bdData	bd	<0,0,0>
fIgnoreTDataEntry	DB TRUE 	

CB_TDATA EQU 5				;5 bytes per entry

PUBLIC	fDataMoved
;set to TRUE every time a DATA statement is moved from a SUB to module level
fDataMoved	DB	0		

sEnd	DATA

sBegin	CP
assumes	cs,CP

;*****************************************************************************
; TDataStart
; Purpose:
;	Called at the start of ASCII Load to initialize things for movement
;	of DATA statements from prs to module.
; Exit:
;	returns al=ER_OM if out-of-memory
;	        al=0 if no error
;	        (with condition codes set accordingly)
;
;*****************************************************************************
PUBLIC	TDataStart
TDataStart PROC NEAR

; Don't allow nested calls to TDataStart
	DbAssertRelB [fIgnoreTDataEntry],ne,0,CP,<TDataStart: nested call>

	sub	ax,ax
	mov	[fIgnoreTDataEntry],al
	mov	[bdData.BD_cbLogical],ax

	PUSHI	ax,<dataOFFSET bdData>
	PUSHI	ax,CB_TDATA		;initial size of node buffer
	PUSHI	ax,<IT_NO_OWNERS>	;heap type
	call	BdAlloc
	or	ax,ax			;set condition codes for caller
	mov	al,ER_OM
	je	TDStartExit		;brif out-of-memory error
GotBd:
	mov	bx,[bdData.BD_pb]
	mov	BYTE PTR [bx],DT_End	;make table look empty
					;condition codes still based on ax
	sub	ax,ax			;no error
TDStartExit:
	or	ax,ax			;set condition codes for caller
	ret
TDataStart ENDP

;*****************************************************************************
; TDataEntry
; Purpose:
;	Called during ASCII Load every time a DATA statement
;	or a RESTORE statement is inserted into any text table.
;	It adds info about the statement to a buffer so TDataEnd
;	can move the DATA statements from prs to module at end of load.
;	Always keeps room for a new entry at end of buffer
; Entry:
;	al = DT_Data for DATA stmt, 
;	   = DT_Restore for RESTORE stmt, 
;	   = DT_EndProc for END SUB/FUNCTION stmt
;	bx = otx
;	grs.oPrsCur identifies the text table within the module
; Exit:
;	returns ax=0 (with condition codes set accordingly) if out-of-memory
;
;*****************************************************************************
PUBLIC	TDataEntry
TDataEntry PROC NEAR
DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<TDataEntry: bad scanstate>
DbAssertRelB al,ne,0,CP,<TDataEntry: called with al=0>
	;function assumes we can return al=non-zero if we don't alter ax
	FLoadActive
	je	TdExit			;brif not LOADing a file
	cmp	[fIgnoreTDataEntry],FALSE
	jne	TdExit			;brif TDataEnd is active.  TDataEnd
					; calls TxtInsUpdate, which can call
					; TDataEntry
	cmp	al,DT_Data
	jne	NotData
	test	[txdCur.TXD_flags],FTX_mrs
	jne	TdExit			;brif DATA stmt within main program
NotData:
	push	di			;save caller's di
	mov	di,[bdData.BD_pb]
	DbAssertRel di,ne,NULL,CP,<TDataEntry: no buffer>
	add	di,[bdData.BD_cbLogical]
	sub	di,CB_TDATA
	push	ds
	pop	es			;es = DGROUP
					;NOTE: al must still = TDataEntry parm
	;**********************************
	;NOTE: al still equals entry value 
	;**********************************
	stosb				;store node type
	mov	ax,[grs.GRS_oPrsCur]
	stosw				;store current prs
	xchg	ax,bx			;ax = otx
	stosw

	;make room for next entry
	PUSHI	ax,<DATAOFFSET bdData>
	PUSHI	ax,CB_TDATA
	call	BdGrow
	mov	bx,[bdData.BD_pb]
	add	bx,[bdData.BD_cbLogical]
	mov	BYTE PTR [bx - CB_TDATA],DT_End	;make table look empty
	pop	di			;restore caller's di
TdExit:
	or	ax,ax			;set condition codes for caller
	ret
TDataEntry ENDP

;*****************************************************************************
; TDataEnd
; Purpose:
;	Called at the end of an ASCII Load
;	Step1:	For each RESTORE in bdData, find the label definition.
;		If the label definition is in a prs,
;		  Generate a new unique oNam
;		  Store the new oNam in the restore opcode's operand
;		  Insert DT_Label into bdData with
;		     otx field to the label definition's otx,
;		     oPrs field to the label definition's oPrs
;		else
;		  ignore the entry
;	Step2:  For each DT_Data move the DATA opcode from the prs to
;		the mrs.  For each DT_Label entry in bdData, generate
;		an opBolLab opcode in the mrs.
;
; Exit:
;	returns al=ER_OM if out-of-memory
;	        al=0 if no error
;	        (with condition codes set accordingly)
;
;*****************************************************************************
cProc	TDataEnd,<PUBLIC,NEAR,NODATA>,<si,di>
	localW	lnCur
	localW	oPrsRestore
	localW	oNamNew
cBegin
	cmp	[fIgnoreTDataEntry],0	
	je	@F			; Redundant tDataEnd
J1_TDEndExitOk: 			
	jmp	TDEndExitOk		; Redundant tDataEnd
@@:					

	mov	[lnCur],100d
	mov	[fIgnoreTDataEntry],NOT FALSE
	mov	si,[bdData.BD_pb]
	or	si,si			; is bdData even allocated?
	jz	J1_TDEndExitOK		; brif not, nothing to do
Step1Loop:
	lodsb				;al = node type
	.errnz DT_End
	or	al,al			;test for DT_End
	je	Step1Done		;brif done with step1's pass over list
	cmp	al,DT_Restore
	jne	Step1Next		;brif not a RESTORE node
	lodsw				;ax = oPrs field (may be UNDEFINED)
	mov	[oPrsRestore],ax
	push	ax
	call	PrsActivateCP		;activate opRestore's prs

;Generate a label which has not been used in this module
UniqueLabelLoop:
	inc	[lnCur]
	mov	ax,[lnCur]		;pass line# to ONamOfLn in ax
	call	ONamOfLn		;ax = oNam for line number lnCur
	je	JE1_TdEndOmErr		;brif out-of-memory error
	mov	[oNamNew],ax		;preserve proposed oNam
	test	dl,NM_fLineNumLabel	;dl = flags byte returned by ONamOfLn
	jne	UniqueLabelLoop		;brif name is already used as label

	lodsw				;ax = otx field of opStRestore
	inc	ax			;advance to oNam operand
	inc	ax
	mov	di,ax			;di = otx to opStRestore's oNam
	call	GetWOtx			;ax = label's oNam (from opStRestore)
	call	FindLabelDef		;bx = oPrs, ax = otx of label def
					;current prs is preserved
	inc	ax
	je	Step1Loop		;brif label not found
	inc	bx			;test prs for UNDEFINED
	je	Step1Loop		;brif label defn is in mrs (no need
					; to change RESTORE's operand, we're
					; not moving DATA stmts already in mrs)
	dec	ax			;restore ax = otx
	dec	bx			;restore bx = oPrs where label's defined
	mov	cx,[oNamNew]
	call	InsertLabInTbl		;insert DT_Label entry in bdData
					; si updated if new entry inserted
					; before current si
	inc	ax			;test for UNDEFINED
	je	Step1Loop		;brif label defn is in prs with no DATA
					; stmts (we could handle this case,
					; but it is not worth the code it would
					; take)
	dec	ax			;test for 0
	je	JE1_TdEndOmErr		;brif out-of-memory error

	push	[oPrsRestore]
	call	PrsActivateCP		;activate opRestore's prs

	push	di			;pass otx to PutWOtx
	push	[oNamNew]		;pass new oNam to PutWOtx
	call	PutWOtx			;store new oNam in opStRestore's operand
	SKIP2_PSW			;skip next 2 lodsw instructions
Step1Next:
	lodsw				;skip oPrs field
	lodsw				;skip otx field
	jmp	SHORT Step1Loop

J1_Step2Done:
	jmp	Step2Done

;si points beyond the end of the bdData table
Step1Done:
	call	PrsDeactivate		;make module's text table active
	add	si,CB_TDATA - 1		;si points CB_TDATA bytes beyond
					; DT_End entry
;walk through table bdData backwards
;si points 10 bytes beyond entry to be processed
;di = otx to insert DATA stmts in main module's text table
;
Step2Loop:
	sub	si,CB_TDATA+CB_TDATA	;si points to entry in table bdData
	cmp	si,[bdData.BD_pb]
	jc	J1_Step2Done		;brif done with table
	lodsb				;al = node type
	cbw				;ax = node type (always less than 128)
	xchg	cx,ax			;cx = node type
	lodsw				;ax = oPrs if DT_Data
	xchg	dx,ax			;dx = oPrs if DT_Data
	lodsw				;ax = otx if DT_Data, oNam if DT_Label
	sub	si,[bdData.BD_pb]	;convert pointer to offset in case
					; following code causes heap movement
	dec	cx
	.errnz DT_Data-1
	je	MoveDataStmt		;brif DATA stmt entry
	.errnz DT_EndProc-2
	loop	NotEndProc		;brif not EndProc entry
	xchg	di,ax			;di = otx where following DATA
					; stmts are to be inserted into
					; main program
J1_Step2Next:
	DJMP	jmp SHORT Step2Next

NotEndProc:
	loop	J1_Step2Next		;brif not Label entry
	.errnz DT_Label-3
	;ax = oNam for new label
	push	ax			;save oNam for new label

;  CALL	bdlAlloc(&bdlTxtScrap, 6)	[2]
	PUSHI	ax,<DATAOFFSET bdlTxtScrap>
	PUSHI	ax,6			;number of bytes in a opBolLab opcode
	PUSHBDL_TYPE  pgtypEBGeneric,ax ; pass sb type for EB version
	call	bdlAlloc
	or	ax,ax

	pop	ax			;restore ax = oNam of new label
JE1_TdEndOmErr:
	je	JE2_TdEndOmErr		;brif out-of-memory error
	GETSEG	es,bdlTxtScrap.BDL_seg	;[2]es points to segment of Scrap
	xor	bx,bx
	mov	WORD PTR es:[bx],opBolLab	;store opcode
	mov	es:[bx+4],ax		;store oNam of new label
	jmp	SHORT DoIns

;ax = otx for DATA opcode
MoveDataStmt:
	push	ax			;preserve otxData
	push	dx			;pass oPrs to PrsActivateCP
	call	PrsActivateCP
	pop	ax			;restore ax = otxData

;  CALL TxtCopyScrap(otxData, 2+StartOtx, cb, TRUE)	[2][5]
	push	ax			;pass otxData 
	PUSHI	bx,2+StartOtx		;length of opBol opcode
	inc	ax
	inc	ax			;ax = offset to opStData's cbEos operand
	call	GetWOtx			;ax = cbEos
	add	ax,5			;include opcode, cbEos in count
	and	al,0FEh			;round up to even byte count
	push	ax			;pass cb to TxtExtract
	push	ax			;push TRUE
	call	TxtCopyScrap		;move data from txdCur to bdlTxtScrap
JE2_TdEndOmErr:
	je	TdEndOmErr		;brif out-of-memory error

	GETSEG	es,bdlTxtScrap.BDL_seg	;[2] es points to segment of Scrap
	xor	bx,bx
	mov	WORD PTR es:[bx],opBol
DoIns:
	DbAssertRel di,ne,UNDEFINED,CP,<TDataEnd: missing DT_EndProc>
	call	PrsDeactivate		;make module's text table active
	xchg	si,di			;pass otxInsert in si
	call	TxtInsScrap		;insert pcode in main module @ si
	je	TDEndOmErr		;brif out-of-memory error
	mov	[fDataMoved],1		;so user interface can put up a
					; dialog box that says we've altered
					; his program.
	mov	bx,si			;bx = otxInsert
	add	bx,[bdlTxtScrap.BDL_cbLogical] ;bx=offset past inserted pcode
	call	TxtInsUpdate		;Update static vars affected by insert
	xchg	si,di			;restore si = offset into bdData
					;        di = otxInsert
	je	TDEndOmErr		;brif out-of-memory error
Step2Next:
	add	si,[bdData.BD_pb]	;convert offset to pointer
	jmp	Step2Loop

Step2Done:
	PUSHI	ax,<DATAOFFSET bdData>
	call	BdFree
TDEndExitOk:
	sub	ax,ax			;return 0 (no error)
TDEndExit:
	or	ax,ax			;set condition codes for caller
cEnd	;TDataEnd

TdEndOmErr:
	mov	al,ER_OM
	jmp	SHORT TdEndExit


;*****************************************************************************
; InsertLabInTbl
; Purpose:
;	insert DT_Label entry in bdData
; Entry:
;	ax = otx of label def
;	bx = oPrs
;	cx = oNamLabel (oNam for new label being generated)
; Exit:
;	if new entry is inserted before current si, si is updated
;	if out-of-memory, ax = 0 on exit
;	if no place found to insert entry (because no DATA or RESTORE stmts
;	   occurred in prs with label definition), ax = UNDEFINED
;	else ax = sp (not UNDEFINED or 0)
;
;*****************************************************************************
InsertLabInTbl PROC NEAR
	push	di			;save caller's di, ax

	sub	si,[bdData.BD_pb]	;convert si to offset (in case bdData
					; gets moved during function)
	push	si			;save offset

	push	cx			;save oNamNew
	mov	si,[bdData.BD_pb]	;start search at 1st entry in table
	xchg	di,ax			;di = otx of label definition
ILoop:
	lodsb				;al = node type
	cbw				;ax = node type
	xchg	cx,ax			;cx = node type
	lodsw				;ax = oPrs field
	xchg	dx,ax			;dx = oPrs field
	lodsw				;ax = otx field
	jcxz	IDone			;brif reached DT_End entry
	cmp	dx,bx
	jne	ILoop			;brif not prs of interest
	.errnz DT_End
	loop	INotData		;brif not DT_Data
	.errnz DT_Data - 1
	cmp	ax,di
	jbe	ILoop			;brif otx is too low
	jmp	SHORT IInsert

INotData:
	loop	ILoop			;brif not DT_EndProc
	.errnz DT_EndProc - 2
IInsert:
	;make room for CB_TDATA bytes in bdData buffer before si-CB_TDATA
	; BdShiftRight(bdData, si-CB_TDATA, CB_TDATA)
	
	mov	ax,CB_TDATA
	mov	bx,DATAOFFSET bdData
	sub	si,ax			;si -> start of entry to insert before
	push	bx			;pass &bdData
	sub	si,[bx.BD_pb]		;convert pointer to offset
	push	si			;pass insert offset
	push	ax			;pass cbInsert
	call	BdShiftRight		;make room for new entry
	pop	bx			;restore bx = oNamNew

	or	ax,ax
	je	IExit			;brif out-of-memory
	mov	di,si			;di = destination offset
	add	di,[bdData.BD_pb]	;convert offset to pointer
	push	ds
	pop	es			;es = DGROUP for stosb
	mov	al,DT_Label
	stosb				;store node type field
	xchg	ax,bx			;ax = oNamNew
	stosw				;store oNamNew field
	stosw
	sub	di,[bdData.BD_pb]	;convert pointer to offset
	pop	si			;si = caller's offset into bdNodes
	cmp	si,di
	jb	InsBefore		;brif caller's si not affected by insert
	add	si,CB_TDATA
InsBefore:
	push	si
	mov	ax,sp			;return TRUE (not out-of-memory)

;ax = 0 if out-of-memory error, UNDEFINED if prs not found, otherwise ax=sp
IExit:
	pop	si
	add	si,[bdData.BD_pb]	;convert offset to pointer
	pop	di			;restore caller's di
	ret
InsertLabInTbl ENDP

IDone:
	inc	bx			;is oPrsSearch = UNDEFINED?
	je	IInsert			;brif we're beyond prs of interest
	pop	bx			;pop oNamNew off stack
	mov	ax,UNDEFINED
	jmp	SHORT IExit

;*****************************************************************************
; FindLabelDef
; Purpose:
;	Search all procedures in current module for a label definition
; Entry:
;	ax = oNam for label
; Exit:
;	bx = oPrs
;	ax = otx of label def (UNDEFINED if not found)
;
;*****************************************************************************
FindLabelDef PROC NEAR
	push	di			;preserve caller's di
	xchg	ax,di			;di = oNam to search for
	call	PrsDeactivate		;start in main text table

;di = oNam of label being searched for
FlLoop1:
	GETSEG	es,txdCur.TXD_bdlText_seg   ;[1]
	mov	bx,[txdCur.TXD_otxLabLink]
FlLoop2:
	inc	bx			;test for UNDEFINED
	je	FlDone2			;brif end of linked list of labels
	dec	bx
	cmp	es:[bx+2],di
	je	FlFound			;brif found oNam
	mov	bx,es:[bx]		;bx points to next node in linked list
	jmp	SHORT FlLoop2

FlDone2:
	call	NextTextPrsInMrs
	inc	ax			;test for UNDEFINED
	jne	FlLoop1			;brif got a prs text table
	dec	ax			;return UNDEFINED (not found)
	jmp	SHORT FlExit

FlFound:
	dec	bx
	dec	bx			;bx = otx to op[Bol]Lab[Sp] opcode
	mov	ax,[grs.GRS_oPrsCur]	;ax = oPrs
	xchg	ax,bx			;ax = otx, bx = oPrs
FlExit:
	pop	di			;restore caller's di
	ret
FindLabelDef ENDP

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssscan.asm ===
TITLE	SSSCAN	-	Main Static Scanner Module
;***
;ssscan - Main static scanner module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   This is the main static scanner module.  It contains all external
;   interfaces to the module.  These interfaces are:
;   ssscan	      - scans the current text table to executor mode.
;   SsDescan(toState) - descans current text table to the state specified
;			this state may be SS_PARSE or SS_RUDE.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSSCAN_ASM	= ON
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	opmin
	IncludeOnce	opstmt
	IncludeOnce	optables
	IncludeOnce	pcode
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	ssint
	IncludeOnce	txtmgr
	IncludeOnce	variable
	.list

assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA

extrn	B$IFindEvHandler:far
extrn	exBolLab:far


	    extrn   DimImplicit:far	


sBegin	DATA

EmitErrOtx	dw	0

sEnd	DATA


sBegin	SCAN
assumes cs,SCAN

;*************************************************************************
;UpdateTxdBdl - Update the TXD or BDL for text table
;
; Purpose:
;
;   Update the txdCur (or the direct mode bdl) for this text table.
;
; Entry:
;
;   al = scanState
;   di = cbLogicalNew	    oTx of opEOT + 2
;
;   The structure txdCur identifies the current text table.
;   If grs.fDirect is TRUE, the direct mode text table (grs.bdlDirect)
;      is used instead.
;
; Preserves:
;
;   All
;
;*************************************************************************
UpdateTxdBdl:
	cmp	grs.GRS_fDirect,FALSE
	jne	DirectMode		;branch if in direct mode
	mov	txdCur.TXD_bdlText_cbLogical,di
	mov	txdCur.TXD_scanState,al
	ret

DirectMode:
	mov	[grs.GRS_bdlDirect_cbLogical],di
	ret

;***
; TxLnkInit
; Entry:
;	bx points to table to use for SsLinkCtl
; Exit:
;	ax = 0 (callers assume this)
; preserves: bx,dx (callers assume this)
;
;********************************************************
TxLnkInit PROC NEAR
	push	es
	push	di
	mov	SsLinkCtl,bx		;Save for scan dispatch routines
	push	ds
	pop	es
	mov	di,bx
	mov	cx,(size TXLNK)/2	;Count of bytes in structure
	xor	ax,ax			;Get a zero
	rep	stosw			;Initialize link controls to zero
	pop	di
	pop	es
	ret
TxLnkInit ENDP

;***
;ushort SsScan - Scan pcode from SS_PARSE to SS_EXECUTE
;
;Purpose:
;
;   In the case of an error, the pcode is left entirely
;   in the state in which the pcode was found.	An error
;   code is always returned.
;
;   This procedure causes memory allocations in the
;   interpreter and far heaps.
;
;   Certain scan routines push identified frames on the stack.
;   These frames must be uniquely identifiable, as other scan
;   routines must check to see if they exist.  At scan initialization,
;   an end-of-frame identifier is pushed on the stack, ensuring
;   that the bottom of the stack is not misinterpreted as some
;   particular scan stack entry.
;
;   NOTE: If grs.GRS_fDirect is TRUE on entry, txdCur should be
;	    ignored, and we should assume that the text table (whose
;	    segment is obtained via TxtSegCur) is in SS_RUDE, and
;	    must be scanned to SS_EXECUTE. Note also that the information
;	    in txdCur should be unchanged on return in this case.
;
;Algorithm:
;
;   Determine whether current text table is in SS_EXECUTE already
;      return if so
;   Grow the text table
;      If cbScanned = 0 then guess that cbScanned = 1.3 * cbText
;      Attempt to grow the text table by cbScanned
;	    error if NO growth possible
;      Move text up to end
;	    relink all links
;   Set up for main scan loop
;      install return address
;      set up es, si, di
;      push an end-of-stack frame identifier
;   Loop to completion
;   pop end-of-stack frame identifier
;   Return
;
;Entry:
;
;   grs.GRS_fDirect	 Current context information
;   rs	    mrsCur	 Current context information
;   ushort  oPrsCur	 Offset of current procedure.
;			    UNDEFINED = module
;   prs     prsCur	 Procedure context if
;			    oPrsCur != UNDEFINED
;
;Exit:
;
;   ax	    = 0 if no error occurred
;	      or
;	      error code
;   SsScan		 Standard BASIC error code
;   grs.context 	 Pcode address of the error
;			 or
;			 unmodified
;Exceptions:
;
;   None
;
;********************************************************
cProc	SsScan,<FAR,PUBLIC>,<si,di>

	localV	txLinks,<SIZE TXLNK>

ScanXj: jmp	ScanX

cBegin	SsScan

	DbMessTimer	SCAN,<Enter SsScan - >

;Assume not direct mode
	mov	cx,txdCur.TXD_bdlText_cbLogical ;Bytes of text
	cmp	grs.GRS_fDirect,FALSE		;Direct mode?
	jz	GetTXDInfoX			;Program mode
	xor	cx,cx
GetTXDInfoX:
;Grow the text, ensuring a gap between emit and source
	shr	cx,1
	shr	cx,1
	shr	cx,1			;Gap should equal 1/8 source size.
	GETSEGTXTCUR			;es = the text segment
	xor	ax,ax
	mov	SsCbTxExpand,ax 	;Initialize bytes of text expansion
	mov	[ScannerFlags],ax
	SetStartOtx	si		;oTxSrc
	mov	di,si			;oTxEmit
	DbChkTxdCur			;perform sanity check on txdCur
	call	SsMakeGap		;Ensure enough gap to scan (cx=gap)
	mov	ax,ER_OM		;Indicate out of memory
	jc	ScanXj			;Out of memory - can't scan
	lea	bx,txLinks		;Address of link controls
	call	TxLnkInit		;init txLinks structure to 0
					;ax = 0
					;preserves: bx,ax,dx, uses: cx,es
	mov	dx,txdCur.TXD_otxLabLink;Label link head pointer
	mov	[bx].TXLNK_LabDefNext,dx;offset of next label definition
					;LabDefLast left at zero

	cmp	grs.GRS_fDirect,FALSE	;Direct mode?
	jnz	InitLinks		;If direct mode, don't worry about CONT
	or	[txdCur].TXD_otxLabLink,1 ;Set LSB to indicate unbound

	    mov     bx,dataOFFSET prsCur.PRS_cbFrameTemp    ;Assume PRS
	    test    byte ptr [grs.GRS_oRsCur+1],80H	    ;MRS?
	    jnz     @F					    ;No
	    and     [mrsCur].MRS_flags,not FM_OptionBase1   ;Set option base 0
	    mov     bx,dataOFFSET mrsCur.MRS_cbFrameTemp
	    mov     [mrsCur.MRS_data_otxFirst],UNDEFINED    ;Init head of DATA list
@@:
	    xchg    ax,[bx]		;Zero cbFrameTemp if not direct mode
	push	ax			;Save old cbFrameTemp
	mov	bx,[grs.GRS_otxCONT]	;Get CONT otx
	inc	bx
	jz	InitLinks		;Can't continue, don't swap pcode
	mov	cx,[grs.GRS_oRsCONT]	;Get CONT oRS
	call	GetOtxRS		;Make sure oRS in cx isn't for DefFn
	cmp	cx,[grs.GRS_oRsCur]	;Is it the one we're scanning?
	jnz	InitLinks
	mov	ax,opNoList0
	xchg	ax,PTRTX[bx-1+si-StartOtx] ; Replace CONT pcode with special
	mov	[SsErrOpcode],ax	;Save original pcode

InitLinks:
	xor	ax,ax			;AX = 0

	mov	f_Static,TRUE		;Set $STATIC in effect flag

	;Initialize oTypCur and oValCur fields in COMMON to zero

	    mov     bx,[grs.GRS_bdtComBlk.BD_pb]
	mov	cx,ax
ZeroCom:
	cmp	cx,[grs.GRS_bdtComBlk.BD_cbLogical] ;Within size of block?
	jae	@F
	mov	[bx].COM_oTypCur,ax	;Zero oTypCur
	mov	[bx].COM_oValCur,ax
	add	bx,size COM
	add	cx,size COM
	jmp	ZeroCom

@@:

	mov	ssStackSave,sp		;Preserve the sp from start of scan loop
.errnz	STYP_StackEnd			;Stack base indicator used to determine
	push	ax			; end of control structures on stack

ScanToExeStart:
	xor	ax,ax
	mov	[SsCbFrameTemp],ax	;Count of temps in next statement
	mov	[SsErr],ax		;Error code
	mov	[SsExec],ax		;No executable code yet
	dec	ax
	mov	[SsErrOTx],ax		;Set error location to FFFF
	mov	[grs.GRS_oTxCur],ax	
	mov	[EmitErrOtx],ax
	mov	[SsDelayCnt],ax
	mov	[SsOTxPatchBos],ax	

	;Top of scan loop when pcode has HeapMove flag set

	public	SetScanRet
SetScanRet:
	mov	[SsOtxHeapMove],di
	mov	ScanRet,SCANOFFSET ScanToExeLoop  ;Set return address for
						;  dispatched opcode scanners

	;Main scan loop for SS_PARSE to SS_EXECUTE

	public	ScanToExeLoop
ScanToExeLoop:
	LODSWTX
	and	ax,OPCODE_MASK


	mov	bx,ax
	mov	al,mpOpAtr[bx]
	or	[SsExecFlag],al
	test	al,OPA_fHeapMove	;Cause heap movement?
	jnz	SetHeapMove
GetExe:
	shl	bx,1
	mov	ax,mpOpExe[bx]		;Get nominal executor
	mov	dx,ax			; Some routines want it in DX
DbPub   DispSS
DispSS:
	jmp	mpOpScanDisp[bx]	;Dispatch to scan routine for opcode

SetHeapMove:
	mov	[ScanRet],SCANOFFSET SetScanRet
	jmp	GetExe

Public	ScanExit
ScanExit:
	pop	ax			;Remove stack base indicator
	call	SsFrameType		;Make sure nothing's on the stack
	mov	sp,[SsStackSave]
	mov	al,SS_EXECUTE		;Scan state of text table
	cCall	UpdateTxdBdl		;Update the TXD or BDL for this table
;See if temp space grew.  If there are frames for this procedure on the stack,
;then temps can't grow.  An exception is if the only frame is the one on the
;top of the stack, where the gosub return addresses can be moved down to make
;more room.  Although direct mode allocates temp space off the current proc,
;it doesn't matter if it grows then because the procedure itself doesn't
;need (or use) the space.
	cmp	grs.GRS_fDirect,FALSE	;Direct mode?
	jnz	CouldCont		;Could always continue if direct mode
;Check for CantCont because temps grew
	pop	ax			;Original cbFrameTemp
	test	[SsFlags],SSF_CantCont	;Already detect CantCont situation?
	jnz	SetCantCont
	test	byte ptr [grs.GRS_oRsCur+1],80H	;MRS?
	    mov     bx,dataOFFSET mrsCur.MRS_cbFrameTemp
	    jz	    TempsGrow		;Brif MRS
	    mov     bx,dataOFFSET prsCur.PRS_cbFrameTemp
TempsGrow:
	    cmp     ax,[bx]		;Did it grow?
	jae	CouldCont		;Didn't grow--still can continue
;Grew FrameTemps
	mov	bx,dataOffset b$CurFrame
	cCall	ActiveORs_Frame,<bx>	; See if frame on stack
	or	ax,ax			
	jz	CouldCont		; Didn't find one
SetCantCont:
	call	CantCont
CouldCont:
;Compute max size of blank COMMON type and value tables
	mov	bx,[grs.GRS_bdtComBlk.BD_pb];pBlankCommon
	mov	ax,[bx].COM_oTypCur	;Size of type table
	cmp	ax,[oTypComMax]		;Grow?
	jbe	MaxComSize
	mov	[oTypComMax],ax		;Set new max
	mov	ax,[bx].COM_oValCur
	mov	[oValComMax],ax		;Set new max for value table
MaxComSize:
	DbChkTxdCur			;perform sanity check on txdCur
	DbMessTimer	SCAN,<Leave SsScan - >
	mov	ax,[SsErr]		;Return error code in ax
	or	ax,ax
	jz	ScanX
	cmp	[grs.GRS_fDirect],FALSE ;don't descan direct mode buffer
	jne	ScanX			;branch if in direct mode
	push	ax			;Descan sets it own error--save ours
	call	far ptr SsDescanErr	;Back to parse state if error
	pop	ax
ScanX:
cEnd	SsScan

;CheckSLoop - exe loop nonRELEASE checking code


subttl	SsDescan
page
;***
;SsDescan
;
;Purpose:
;
;   Descan is dispatched as:
;	    [[mpOpScanDisp+(([executor-2])*2)]-2]
;
;   That is, the descan address is in memory as the word before
;   each scan routine.	This is memory conservative, as there are
;   relatively few scan routines compared to opcodes or executors.
;
;   Individual descan routines must determine descan requirements
;   based on ssTarget and the current pcode state.  This is efficient
;   in that there are few descan routines that are state sensitive.
;
;   When descanning from executor state all pcodes that can be inserted
;   by SsScan only are removed.  In other words scan routines do not have
;   to check to see if coercion tokens (for example) have already been
;   inserted.  This is efficient in that it is usually as hard to check
;   to see if the work is required as it is to simply do the work.
;
;   Descan routines are dispatched with:
;   ax = opcode
;   si = descan source
;   di = descan destination
;
;*******************************************************************************
public	SsDescan
cProc	SsDescanErr,<FAR>,<es,si,di>
	localW	oTxtLast		;Offset of last pcode word
	localV	txLinks,<SIZE TXLNK>	;Link list control
SsDescan:
	mov	[SsErrOTx],-1		;Set error location to FFFF
cBegin	SsDescanErr
	DbMessTimer	SCAN,<Enter SsDeScan - >
	DbChkTxdCur			;perform sanity check on txdCur
	DbAssertRelB grs.GRS_fDirect,e,0,SCAN,<descan called for direct mode buffer>
	DbAssertRelB txdCur.TXD_scanState,e,SS_EXECUTE,SCAN,<descan called when not in EXECUTE state>


;Load text segment to es:
	GETSEGTXTCUR			;es = seg adr of cur text table
	SetStartOtx	di		;Start at the beginning of text
					; and debind labels to oTxt
	call	SsLabelRefDebind	;First descan label references
	mov	ax,UNDEFINED
	mov	txdCur.TXD_otxLabLink,ax;Update txd head pointer
	lea	bx,txLinks		;Address of link control struc
	call	TxLnkInit		;init txLinks structure to 0
					;ax = 0
					;preserves: bx,ax,dx, uses: cx,es
	mov	[SsErr],ax
	mov	ax,txdCur.TXD_bdlText_cbLogical
	dec	ax
	dec	ax
	mov	oTxtLast,ax		;Save offset of last pcode word
	SetStartOtx	si		;Descan from the start
	mov	di,si			;Destination = source
	mov	[SsCbTxExpand],si
	mov	[ScanRet],SCANOFFSET ContDescanLoop ;Descan routines
						;return through ScanRet
SortOTx:
	mov	dx,[EmitErrOtx]		;Start sort with error location
	mov	[SsReturnBp],dataOFFSET EmitErrOtx
	call	FCanCont		; ZF set if user can't continue
	jz	SetNextOtxJ		;Don't search others if can't cont.
	push	si
	push	di
	mov	si,[pGosubLast] 	;Head of gosub list
	mov	di,[b$CurFrame]	;Start of bp return addr chain
	mov	cx,[grs.GRS_oRsCONT]	;cx = current pc's oRs
	mov	bx,dataOFFSET grs.GRS_oTxCONT
FixORs:
	call	GetOtxRS		;Make sure oRS in cx isn't for DefFn
CompOTx:
	test	byte ptr [bx],1 	;Special one we should ignore?
	jnz	NextOTx 		;Brif return to direct mode
	call	CheckUpdate
NextOTx:
	;Scan GOSUB return address list for returns in oPRS = cx

	or	si,si
	jz	CheckFrame		;No more gosub returns
	cmp	si,di			;Still within current module/procedure
	ja	CheckFrame
	lea	bx,[si].FR_otxRet
	mov	si,[si]
	jmp	CompOTx

CheckFrame:
	cmp	di,[b$MainFrame]	;End of list?
	jz	SetNext
	lea	bx,[di].FR_otxRet
	mov	cx,[di].FR_oRsRet	;oRS of return address
	mov	di,[di].FR_basBpLink	
	jmp	FixORs

SetNextOtxJ:
	jmp	short SetNextOtx

SetOtxCont:
	mov	ax,di
	inc	ax			;Set LSB of otx to remember it's set
	mov	[grs.GRS_otxCont],ax	;Set new CONT otx
	jmp	SortOtx

SetErrorLoc:
	mov	ax,di
	dec	ax
	dec	ax			;Point into previous pcode
	mov	[grs.GRS_oTxCur],ax	;Location of error
	mov	[EmitErrOtx],UNDEFINED
	jmp	SortOtx

OTxMatch:
	mov	cx,[SsReturnBp]
	cmp	cx,dataOFFSET grs.GRS_oTxCONT	;Is it current PC?
	jz	SetOtxCont
	cmp	cx,dataOFFSET EmitErrOtx	;Is it the location of an error?
	jz	SetErrorLoc

	;At this point, it has been determined that CX contains the offset into
	;DGROUP of a word containing an Otx into the current pcode table.  To
	;update this word to account for descaning and subsequent scanning,
	;an opcode is inserted with an operand of the DGROUP offset.  The
	;scan routine for this opcode will update the static location without
	;emitting the executor or operand.  To prevent this oTx from being
	;found on the next pass through SortOTx, it is set to UNDEFINED (0ffff).
	;If CX is odd then CX contains the location minus one where the update
	;should occur.	This location is the address of an error handler or
	;event handler and the opcode must be inserted after the BOL to
	;prevent an edit of lines before the handler from messing up the
	;update.

	mov	ax,opNoList1		;Return address opcode
	TestM	[SsNextOTx],1		; Is this a handler address?
	jz	@F			; Brif not
	mov	ah,HIGH (opNoList1+OPCODE_MASK+1)
@@:					
	mov	bx,di			;Insert right here
	call	Insert1Op
	mov	bx,cx
	mov	[bx],UNDEFINED		;Blast original oTx
	jmp	SortOTx

SetNext:
	pop	di
	pop	si
;
; See if there is a smaller otx in the Invoke chain.
;

	;See if any event handlers need update

	    push    dx			;Save referenced oTx
	    push    [grs.GRS_oRsCur]
	    call    B$IFindEvHandler	;Get smallest event handler oTx
	    mov     bx,dx		;Offset of smallest
	    pop     dx
	    call    CheckUpdateSkipBOL

	    ;See if references in MRS need update.

	    test    byte ptr [grs.GRS_oRsCur+1],80H  ;At module level?
	    jnz     SetNextOtx

	    ;Update module level error handler

	    mov     bx,dataOFFSET mrsCur.MRS_otxHandler
	    call    CheckUpdateSkipBOLAX

	    ;Update current Data position

	    mov     bx,dataOFFSET mrsCur.MRS_data_otxCur
	    call    CheckUpdateRs

SetNextOtx:
	add	dx,[SsCbTxExpand]	;Adjust for current source position
	jnc	ValidOtx
	mov	dx,UNDEFINED
ValidOtx:
	mov	[SsNextOTx],dx		;oText we're looking for
ContDescanLoop:
	cmp	si,[SsNextOTx]		;Looking for this oText?
	jae	OTxMatch		;Brif current otx >= next update loc

	LODSWTX 			;Load executor
	mov	bx,ax
	GetCodeIntoDs	SCAN		
	mov	ax,[bx-2]		;Load opcode for executor
	push	ss			
	pop	ds			;Move back to data segment
	mov	bx,ax
	and	bh,HIGH OPCODE_MASK
	DbAssertRel bx,be,OP_MAX,SCAN,<Descan: opcode out of range>
	shl	bx,1			;Move to word offset
	mov	bx,mpOpScanDisp[bx]	;Load scan routine address
	jmp	cs:SsProcParse[bx]	;And dispatch w/ ax = opcode


;DescanTerm is installed in ScanRet by descan to SS_PARSE dispatch routines
;that terminate descan.  For example, see SsD_Eot.

public	DescanTerm
DescanTerm:
	mov	al,SS_PARSE
	cCall	UpdateTxdBdl		;Update the TXD or BDL for text table
	call	FCanCont		; See if we can continue
	jz	DescanX			;Can't cont
	and	byte ptr [grs.GRS_otxCont],not 1 ;Reset LSB of CONT otx
	cmp	[SsErr],0		;Any errors?
	jz	DescanX
	call	CantCont		;If errors, can't continue

;DescanX is installed in ScanRet by descan to SS_RUDE dispatch routines
;that terminate descan.  For example, see SsV_Eot
Public	DescanX
DescanX:
	DbChkTxdCur			;perform sanity check on txdCur
	DbMessTimer	SCAN,<Leave SsDeScan - >
cEnd	SsDescan

;*** CheckUpdate,CheckUpdateSkipBOL
;Purpose:
;
;   See if the oTx at [bx] is smaller than the one in dx and is
;   in the same text table.
;
;Input:
;
;   ax = oTx (CheckUpdateSkipBOL only)
;   ds:bx = pointer to an oTx
;   cx = oRS of oTx at [bx]
;   dx = current smallest oTx in current text table
;
;Outputs:
;
;   dx updated with new smallest
;
;Preserves:
;
;   bx,cx

CheckUpdateSkipBOLAX:			
	mov	ax,word ptr [bx]	

CheckUpdateSkipBOL:
	inc	ax
	jz	UpdateX
	dec	ax
	push	bx
	GetCodeIntoDs	SCAN		
	mov	bx,ax			;oTx to bx
	add	bx,ss:[SsCbTxExpand]
	mov	bx,PTRTX[bx]		;Get executor
	mov	bx,[bx-2]		;Get opcode
	push	ss			
	pop	ds
	mov	bl,mpOpAtr[bx]		;Load attribute byte
	and	bx,OPA_CntMask		;Get the operand count from attribute
	add	ax,bx			;Compute oTx after BOL
	dec	ax			; LSB indicates BOL Update
	pop	bx
	jmp	short CheckUpdateAx

CheckUpdate:
	cmp	cx,[grs.GRS_oRsCur]	;In current text table?
	jnz	UpdateX
CheckUpdateRs:
	mov	ax,[bx]
CheckUpdateAx:
	cmp	dx,ax
	jbe	UpdateX
	xchg	dx,ax			;New smallest oTx
	mov	[SsReturnBp],bx		;Location being updated
UpdateX:
	ret

;*** GetOtxRs
;Inputs:
;	cx = any oRS
;Purpose:
;	Map oRS of DefFn back to it oMRS
;Outputs:
;	cx = oRS that owns text table of input oRS
;Preserves:
;	bx,dx,es

GetOtxRs:
	push	es			
	or	cx,cx
	jns	OtxRs			;If MRS, have text table
;See if oPRS is of a DefFn
	xchg	ax,bx			;Preserve bx
	xchg	cx,ax			;cx = old bx, ax = oRS
	and	ax,not 8000H		;Reset MSB
	call	PPrsOPrsSCAN		; bx = pPRS
	or	ax,8000H		;Make ax an oRS again
	cmp	BPTRRS[bx].PRS_procType,PT_DEFFN ; Is proc a DefFn?
	jnz	UsePRS			;If not, PRS in ax is OK
	mov	ax,PTRRS[bx].PRS_oMRS	; Get oMRS for DefFn
UsePRS:
	xchg	cx,ax			;cx = oRS
	xchg	bx,ax			;Restore bx
OtxRs:
	pop	es			
	ret


;***
;SsFrameType - determine type of scanner frame
;Purpose:
;	Report error if there was a scanner frame on the stack.
;Inputs:
;	ax = scan stack entry
;	si = scan source oTx
;	di = scan emit oTx
;	[sp+2] = oTx of source of scanner frame
;Ouputs:
;	if ax = 0, nothing
;	else report appropriate error
;***************************************************************************
	public	SsFrameType

SsFrameType:
	or	ax,ax
	jz	IgnoreErr
	cmp	[SsErr],0		;Already have an error?
	jnz	IgnoreErr		;If so, leave it
	mov	cx,ER_FN		;FOR without Next
	testx	ax,STYP_For		;In FOR block?
	jnz	CxErr
	mov	cx,ER_WH		;WHILE without WEND
	testx	ax,STYP_While
	jnz	CxErr
	mov	cx,MSG_Do		;DO without LOOP
	testx	ax,STYP_Do
	jnz	CxErr
	mov	cx,MSG_Select		;SELECT without END SELECT
	testx	ax,STYP_Case
	jnz	CxErr

	    mov     cx,MSG_DefNoEnd	;DEF without END DEF
	    testx   ax,STYP_DefFn
	    jnz     CxErr
;
;Insert additional control structure tests here
;Scan stack entry must be oTx of last operand
;
	testx	ax,STYP_If+STYP_Else	;In IF block?
	mov	ax,ER_IER		;Internal error if not
	jz	SsError
	mov	cx,MSG_IWE		;Block IF without END IF
CxErr:
	pop	dx			;Return address
	pop	bx			;oTx of error
	push	bx
	push	ax			;Restore frame
	push	dx			;Put return address back
	xchg	ax,cx			;Error code to ax
;	jmp	SsErrorBx		;Fall into SsErrorBx
	
;***
;SsError,SsErrorBx - scanner error handler
;
;Purpose:
;
;   Record scanner error, setting variables as follows:
;
;   [SsErr]		    = error code
;   [grs.GRS_oTxCur]	    = oTx in unscanned pcode of error
;   [SsErrOTx]		    = oTx in scanned pcode when error was found
;
;   This routine returns normally and scanning continues so that
;   all the various link chains will be properly updated.  If a
;   second error is encountered, it is ignored.
;
;Input:
;
;   ax = error code
;   si = Source oTx of pcode that caused the error. (SsError)
;   bx = Emit oTx of error (SsErrorBx)
;   di = Current emit oTx
;
;Modifies:
;
;   none.
;
;Preserves:
;
;   bx,cx,dx
;
;***************************************************************************
public	SsError,SsErrorBx

;NOTE: fallen into by SsFrameType above!
SsErrorBx:
;This variation of SsError reports bx as the emit location of the error
;instead of si as the source location
	cmp	[SsErr],0		;Already have an error?
	jnz	IgnoreErr		;If so, leave it
	mov	[SsErr],ax		;Record error code
	mov	[EmitErrOTx],bx		;Location of error
	mov	[SsErrOTx],di		;Remember current emit oTx
	ret


SsError:
	cmp	[SsErr],0		;Already have an error?
	jnz	IgnoreErr		;If so, leave it
	mov	[SsErr],ax		;Record error code
	mov	ax,si
	sub	ax,[SsCbTxExpand]	;Compute unscanned pcode address
	dec	ax
	dec	ax			;oTx - 2
	mov	[grs.GRS_oTxCur],ax	;Report location of error
	mov	[SsErrOTx],di		;Remember scanned error address too
IgnoreErr:
	ret


subttl	ScanAndExec and ExecuteFromScan
page
;*** ScanAndExec
;
;Purpose:
;
;   Called by rude scanner to scan to execute state, then
;   execute a line of code.  Used for assigning constants.
;
;	Modified in revision [12] to take inputs on stack, use cMacros,
;	become a far entry point.
;Inputs:
;	parm1 = oTx of pcode to execute
;	parm2 = cb of pcode
;Outputs:
;
;   ax = error code, 0 if no error; flags set
;	    if ax != 0, high-bit set indicates that pcode was not changed
;	    (i.e., still contains an oNam, not an oVar).
;   es = current text segment
;
;*** ExecuteFromScan
;
;Purpose:
;
;   Fires up execution from the scanner.  Used to DIM $STATIC arrays
;   in COMMON.	DIM executor direct jumps to ScanExExit to terminate.
;
;	Modified in revision [12] to take dummy parms on stack, use cMacros,
;	become a far entry point.
;Inputs:
;
;   [SsScanExStart] has starting oTx
;
;***************************************************************************
ScanExGrow	=	20
	public	ScanAndExec,SsScanExExit
	public	ExecuteFromScan,ScanExExit

cProc	ExecuteFromScan,<NEAR>,<si,di>	
	parmW	dummy1			; parms provided to match frame
	parmW	dummy2			; conditions of ScanAndExec
cBegin					
	DbAssertRel [SsErr],e,0,SCAN,<ExecuteFromScan: SsErr != 0>
	push	[b$curframe]
	push	[txdCur.TXD_bdlText_cbLogical]
DJMP	jmp	short StartExec		
cEnd					; nogen

cProc	ScanAndExec,<NEAR>,<si,di>	
	parmW	oTxPcode		
	parmW	cbPcode 		
cBegin					
	mov	[ScannerFlags],SSF_ScanAndExec*100H	;Scanning CONST statement
	push	[b$curframe]
	mov	di,[txdCur.TXD_bdlText_cbLogical]
	push	di			;Save current text size
	mov	si,[oTxPcode]		
	mov	cx,[cbPcode]		
	push	cx
	add	cx,ScanExGrow+2 	;Allow some growth and END executor
	push	cx
	call	TxtFreeFar		; Extend text table
	or	ax,ax			
	jz	ScanExOME		;Insufficient memory

	GETSEGTXTCUR			; es = the text segment
	pop	cx
	mov	[SsScanExSrc],si	;Save true oTx of source
	push	di			;Emit address
	add	di,ScanExGrow		;Source address
	push	di
	shr	cx,1			;cx = count of words
	cli				;Double prefix! No interrupts!
rep	movs	PTRTX[si],PTRTX[di]	;Copy pcode to end of text table
	sti
	mov	ax,opEOT
	STOSWTX
	mov	[txdCur.TXD_bdlText_cbLogical],di ;Extend text table
	pop	si
	pop	di
	mov	[SsScanExStart],di
	mov	[SsCbTxExpand],ScanExGrow


	jmp	ScanToExeStart

ScanExOME:
	pop	cx
	pop	dx			;Clean junk off stack
	mov	ax,08000H OR ER_OM	;high bit says pcode is unchanged
	jmp	short ScanExErr

SsScanExExit:
	mov	PTRTX[di],codeOFFSET exScanExExit
	mov	ax,[SsErr]
	or	ax,ax			;Any scanner errors?
	jnz	ScanExErr
StartExec:
;Dispatch execution
	call	far ptr StartExecCP
ScanExErr:
	GETSEGTXTCUR			;es = the text segment
	and	[SsFlags],not SSF_ScanAndExec
	pop	[txdCur.TXD_bdlText_cbLogical]
	pop	[b$curframe]
	or	ax,ax			; Any scanner errors?
cEnd					

sEnd	SCAN

sBegin	CP

assumes cs, CP
assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA

cProc	StartExecCP,<FAR>
cBegin

	call	RtPushHandler		;Save current RT error handler
	mov	ax,cpOFFSET RtScanExTrap
	call	RtSetTrap		;Assign new RT error handler
	call	DisStaticStructs	;Deactivate mrsCur
	mov	[b$curframe],bp 	;Required by math executors
	    TestM   [SsScanExStart],1	; Is this implicit Dim?
	    jnz     @F			; Brif yes
	mov	si,[SsScanExStart]

	jmp	far ptr Start

@@:					
	jmp	DimImplicit		

ScanExExit:
	xor	ax,ax
RtScanExTrap:
	push	ss
	pop	ds			;restore ds == DGROUP from execution
	xchg	ax,si			;Save error code
	call	RtPopHandler
	call	EnStaticStructs 	;Re-activate mrsCur
	xchg	ax,si			;Restore error code


cEnd

sEnd	CP

sBegin	CODE

assumes cs, CODE
assumes ds, DATA
assumes es, NOTHING
assumes SS, DATA

	extrn	Start:far

exScanExExit:	jmp	far ptr ScanExExit

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\ssstmts.asm ===
page	,132
	TITLE	ssstmts - Scan general statements
;***
;ssstmts - scan general statements
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Scan statements other than control flow, procedures, declarations,
;	or I/O or graphics specific formats.
;
;
;****************************************************************************

	.xlist
	include 	version.inc
SSSTMTS_ASM	=	ON
	IncludeOnce	qbimsgs
	IncludeOnce	rtps
	IncludeOnce	ssint
	IncludeOnce	variable
	.list

assumes ds, DATA
assumes es, DATA
assumes ss, DATA


sBegin	SCAN

assumes cs, SCAN

	page
;***
;Ss_NotDefined - Scan routine for unsopported opcodes
;
;Purpose:
;
;   This routine should never be executed since all invalid opcodes should be
;   caught by the rude scanner.
;
;******************************************************************

SsProc	Unsupported,Rude,Local		
	DbHalt	SCAN,<Ss_Unsupported>	
SsD_Unsupported:
	DbHalt	SCAN,<SsD_Unsupported>	

	page
;***
;Ss_StCnt - Scan routine for statements with cnt args of same type
;
;Purpose:
;
;   Scan statement (non-emitting) opcodes with 1 operand which is
;   the count of arguments of the same type (like SCREEN).  The
;   rule table index is the type required.
;
;   The mpOpExe entry is the executor address.	There is one executor
;   for each of the opcodes that use this scan routine.
;
;Input:
;
;   es:si   = pcode emission address
;   es:di   = pcode emission address
;
;Output:
;
;   si updated
;
;Preserves:
;
;   Ss_ChrN requires that dx be preserved [2]
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

SsProc	StCnt
	STOSWTX 			;emit the executor
	LODSWTX 			;Pick up argument count
	STOSWTX 			;Emit the argument count
	xchg	cx,ax
	jcxz	StCntX			;No arguments - exit.
CheckTyps:
	shr	bx,1			;bx = opcode
	mov	al,mpOpRule[bx]		;Load rule table offset
	cbw				;Zero ah
StCntChkLoop:
	call	EnsureArgType
	loop	StCntChkLoop 		;loop to process cx arguments
StCntX:
	jmp	[ScanRet]		;Return to scan loop


;***
;StView[Screen]
;
;	These two opcodes have 6 operands, so a special scan routine is
;	required.
;
;******************************************************************


SsProc	StView
	STOSWTX
	mov	cx,6
	jmp	CheckTyps


	page
;***
;Ss_ChrN - Scan routine for functions with cnt args of same type
;Purpose:
;	Scan function opcodes with 1 operand which is 
;	the count of arguments of the same type.  The
;	rule table index is the type required.
;
;	The mpOpExe entry is the executor address. 
;	Currently this scan routine is only used for QBJ's CHR$
;	function.
;
;Input:
;	es:si	= pcode emission address
;	es:di	= pcode emission address
;Output:
;	si updated
;Modifies:
;Exceptions:
;	Ss_Error
;******************************************************************


	page
;***
;Ss_4ET_ET - Scan routine for case where rule word has 4 ET types
;
;Purpose:
;
;   Scan statements that have independently coerced simple input
;   types, cause no coercion, and have either no operands or where
;   the operands simply get copied.
;
;   This scan routine expects the rule table index to point to a rule
;   entry as follows:
;   Rule Word: Contains 1 to 4 ET types (1 per nibble)
;	       Each nibble describes the next argument type
;   Rule Byte: Emit type or LOWUND
;
;   The mpOpExe entry is the executor address.	There is only one
;   executor for each of the opcodes that use this scan routine.
;
;Input:
;
;   ax	    = executor
;   es:si   = pcode emission address
;   es:di   = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

SsProc	4ET_ET
	;Get EXE for this opcode

	call	EmitExCopyOps		;Emit executor and copy operands
					; bx = opcode on exit
	call	GetRuleInfo		;Get rule table info for opcode bx
					;ax = rule byte
					;bx = rule word
GotRuleInfo:
	xchg	dx,ax			;Save emit type in dx

	;bx = up to 4 oTyps, nybble-packed
	;dx = result oTyp, 0 if none

	or	bx,bx			;Test for work to do
	jz	ss4ETX			;No work to do
NextArg:
	mov	ax,bx
	and	ax,0fH			;ax = required type
	call	EnsureArgType		;Perform the coercion as required

	;Shift to next rule

	mov	cl,4
	shr	bx,cl			;Move to arg type in next nibble
	jnz	NextArg 		;Go coerce next arg if there is one

ss4ETX:
	;Emit output type if there is one

	or	dl,dl			;Test for indication of no emit type
	jz	UpdateOTxStart		; No type to emit
	push	di			;Emit the expression location
	push	dx			;Emit the expression type
ScanX:
	jmp	[ScanRet]		;Return to scan loop

UpdateOTxStart: 			
	mov	[SsOTxStart],di 	; Update clear stack location
	jmp	ScanX			

	subttl	LOCK/UNLOCK
	page
;***
;Ss_StLock - LOCK/UNLOCK Statement Scan Support
;
;Purpose:
;
;   Scan support for the LOCK and UNLOCK statements.
;
;   Pcodes for these statements have a word operand that contains
;   a bit pattern indicating the count of arguments.  This is unlike
;   other statements, and requires specific scan support.
;
;   Syntax:
;
;    LOCK | UNLOCK <filenum> [, (exp [TO exp]) | (TO exp)]
;
;	Pcode:
;
;    (I2channel, [I4RecNo [,I4RecNoTo]]) opSt<Un|>Lock (U2mode)
;
;	U2Mode has following bits set:
;
;	    LOCK_UNLOCK      set if operation is UNLOCK, not LOCK
;	    LOCK_1stToLast   set if only part of file locked
;	    LOCK_RtMask      bits which are meaningful to runtime
;	    LOCK_Def1stArg   set if 1st arg defaulted - used by list
;	    LOCK_DefLastArg  set if last arg defaulted- used by exec
;
;	    bit 1:  set if user specified one or both record numbers,
;		    clear if both record numbers defaulted
;	    bit 15: set if user specified the first record number and
;		    defaulted the second (QBI use only)
;
;Input:
;
;   ax	    = executor
;   es:si   = pcode emission address
;   es:di   = pcode emission address
;
;Output:
;
;   si updated
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

	.errnz	LOCK_DefLastArg -  8000H

SsProc	StLock
	STOSWTX 			;Emit the executor
	LODSWTX 			;Load operand
	STOSWTX 			; and emit it

	test	al,LOCK_1stToLast	;see if user said 'All records'
	jz	StLockAll		;Lock whole file case

	mov	cx,2			;Assume FROM and TO
	test	ah,080H 		;Are they both present?
	jz	StLockLoop		;Both present
	dec	cx			;Back to 1 arg only

StLockLoop:
	mov	ax,ET_I4		;Ensure all I4 arguments
	call	EnsureArgType		;Force arg to I4
	loop	StLockLoop

StLockAll:
	mov	ax,ET_I2
	call	EnsureArgType		;File number argument is an I2

	jmp	[ScanRet]		;Return to main loop


	page
;***
;Ss_FieldItem - Scan routine for Field statement clauses in QB
;
;Purpose:
;
;   This scans the opFieldItem opcodes that appear for each clause in
;   the Field statement.  It is necessary to distinguish fixed strings
;   from variable length strings and report an error for fixed strings.
;   Also, only variables are allowed.  An error is issued for constants.
;
;Input:
;
;   es:si   = pcode emission address
;   es:di   = pcode emission address
;
;Output:
;
;   si updated
;
;Preserves:
;
;Modifies:
;
;Exceptions:
;
;   Ss_Error
;
;******************************************************************

	;Start of [10]


SsProc	FieldItem
	mov	cx,bx			;Save opcode * 2
	pop	ax			;Get type of field item
	pop	bx			;Get oTx for error
	push	bx			;Restore to scan stack
	push	ax
	TestX	ax,ST_Var?		; Is this a variable?
	jnz	@F			; Brif yes, no problem
	mov	ax,ER_VarReq		; Variable is required
	jmp	short FieldError	; Report error
@@:
	cmp	al,ET_FS		;Is this a fixed string?
	jne	FieldOk
	mov	ax,Msg_InvFixStr
FieldError:
	call	SsErrorBx
FieldOk:
	xchg	ax,dx			;AX = Executor
	mov	bx,cx			;BX = Opcode * 2
	jmp	Ss_4ET_ET		;Continue with scanning


	;End of [10]

sEnd	SCAN
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtdir.asm ===
TITLE	txtdir.asm - Text Mgr's Direct Mode Statement support

;==========================================================================
;
;Module:  txtdir.asm - Text Mgr's Direct Mode Statement support
;System:  Quick BASIC Interpreter
;
;=========================================================================*/
;
;		How a direct-mode statement gets executed
;
;                               User-Interface
;                                   /    |
;                          TxtDirect     |
;                              |   \     |
;               +--------------+    \    |
;               |              |     \   |
;               |         ParseLine  SystemScan
;               |                        |
;               |                    ForEach...
;               |                        |
;               |        +---------------+
;               |        |               |
;         +-----+-+  ScanTxtTbl      ReParseTbl
;         |       |   |
;         |  +----)---+
;         |  |    |   |
;     SsRudeScan  SsScan
;
;                                                  
;   User-Interface calls SystemScan for Single-Step, in case user edited
;     program between single steps.  It also calls SystemScan for the
;     Compile... menu, so we don't try to compile a program with errors.
;   TxtDirect calls ParseLine, SsRudeScan and SsScan for the direct
;     mode statement.
;   ReParseTbl calls DoReParse for any statements not yet accepted
;     by the parser, then ScanTypeBlocks, so variable manager knows
;     about all TYPE/END TYPE blocks.
;   ScanTxtTbl then calls SsRudeScan (if necessary) and SsScan (if necessary)
;     to get the text table ready to execute.
;   Some direct mode statements (like SYSTEM) don't require all loaded pcode
;     to be scanned.  In these cases, TxtDirect never calls SystemScan.
;
;=========================================================================*/

	.xlist
	include		version.inc
	TXTDIR_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	lister
	includeOnce	opcontrl
	includeOnce	opid
	includeOnce	opmin
	includeOnce	opstmt
	IncludeOnce	opaftqb4
	includeOnce	parser
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtinterp		
	includeOnce	scanner
	includeOnce	txtint
	includeOnce	txtmgr
	includeOnce	ui
	.list

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING



sBegin	DATA
scanTo		DB	0	;used by ScanTxtTbl


sEnd	DATA

sBegin	CODE

;These opcodes are of special interest whenever they appear in direct mode:
;
tOpDirect LABEL WORD
	opTabStartAll	DIR
	;list of opcodes which are illegal in direct mode
	;many more illegal stmts are caught by NtStatement()
	opTabEntry	DIR,opBolLab
	opTabEntry	DIR,opBolLabSp
	opTabEntry	DIR,opBolInclude
	opTabEntry	DIR,opBolIncludeSp
	opTabEntry	DIR,op_Static
	opTabEntry	DIR,op_Dynamic
	opTabEntry	DIR,op_Include
	opTabEntry	DIR,opStData
	opTabEntry	DIR,opStDefFn
	opTabEntry	DIR,opStEndDef
	opTabEntry	DIR,opStEndIfBlock
	opTabEntry	DIR,opStEndProc
	opTabEntry	DIR,opStEndType
		DIR_ILLEGAL EQU DIR_opStEndType
;All opcodes until end of list cause entire program to be scanned
	;list of opcodes which have direct mode variants
	opTabEntry	DIR,opStGosub
	opTabEntry	DIR,opStGoto
	opTabEntry	DIR,opStElseLab
	opTabEntry	DIR,opStIfLab
		DIR_DM_VARIANT EQU DIR_opStIfLab
	;list of opcodes which cause entire program to be scanned & CantCont
	opTabEntry	DIR,opStRunLabel
	opTabEntry	DIR,opStRunMain
		DIR_CANTCONT EQU DIR_opStRunMain
	opTabEntry	DIR,opStChain
	opTabEntry	DIR,opStCallS
	opTabEntry	DIR,opStCall
	opTabEntry	DIR,opStCallLess
	opTabEntry	DIR,opStRead
	opTabEntry	DIR,opStResume0
	opTabEntry	DIR,opStResumeNext
	opTabEntry	DIR,opStReturn0
	opTabEntry	DIR,opEot

sEnd	CODE

sBegin	CP
assumes	cs,CP


;--------------------------------
; TxtDirect and support functions
;--------------------------------

;**************************************************************
; boolean ScanTxtTbl()
; Purpose:
;	Called by SystemScan via ForEachTxtTbl(ScanTxtTbl).
;
;	Make sure all SUBs and FUNCTIONs are defined and terminated.
;	Note this isn't called for DEF FNs.  Any change to a DEF FN
;	causes a RUDE descan, so rude-scanner is responsible for
;	making sure all DEF FNs are terminated.
;
;	If the text table's scan-state > [scanTo],
;	   First, it makes sure all TYPE/END types have been made known to
;	 the variable manager.
;	   Then it traverses the text table's ReParse linked list,
;	 calling TxtChange() for each line.
;	   Then it calls SsRudeScan(SS_PARSE) to scan the text table to SS_PARSE
;	   or SsScan() to scan the text table to SS_EXECUTE
;
; Entry:
;	grs.fDirect = FALSE
;	Text table to be scanned has been loaded by context mgr.
;
; Exit:
;	ps.bdpSrc (parser's input buffer) is used.
;	If no errors were encountered by either TxtChange or SsScan,
;	   return value is TRUE (so ForEach... will continue)
;	else
;	   return value is FALSE,
;	   it is caller's responsibility to set grs.fDirect = FALSE
;	   txtErr.errCode = an offset into the QBI Message Table (MSG_xxx) or,
;	     if high-bit set, ps.bdpError contains the parser-built
;	     ASCII error message,
;	   txtErr.fDirect is set to FALSE,
;	   txtErr.oRs identifies the text table with the error,
;	   txtErr.otx contains the offset into the text table to the offending
;	     source line (otxDelFirst).
;	   txtErr.oSrcErr contains the column offset into the source line
;	     to the offending token.
;
;Alters:
;	ps.bdpSrc (parser's source buffer)
;
;**************************************************************
DbPub ScanTxtTbl 			
cProc	ScanTxtTbl,<NEAR>
cBegin


	test	txdCur.TXD_flags,FTX_mrs
	jne	ScanTxt 		;brif not a SUB/FUNCTION text table

	test	[prsCur.PRS_flags],FP_DEFINED
	je	ScnSubErr		;brif proc does not have a SUB/FUNC
	test	[prsCur.PRS_flags],FP_ENDPROC
	jne	ScanTxt			;brif proc has END DEF/SUB/FUNCTION

	;error - this SUB/FUNCTION has no END SUB/FUNCTION
	mov	ax,MSG_ProcNoEnd	;SUB/FUNCTION/DEF without END SUB/F...
	mov	dx,[prsCur.PRS_otxDef]
	jmp	short ScnSubErrCom

ScnSubErr:
	;Give "Statement cannot precede SUB/FUNCTION definition" error
	mov	ax,MSG_InvBeforeProcDef	;ax = error code
	sub	dx,dx			;text offset of error = 0

ScnSubErrCom:
	mov	[txtErr.TXER_oSrc],0
DJMP	jmp	SHORT ScanErrCommon	

ScanTxt:
	test	[mrsCur.MRS_flags3],FM3_NotFound 
	je	FileLoaded

	;The user loaded a .MAK file which named this module, but
	;the module could not be found.
	
	mov	[grs.GRS_otxCur],0
	mov	ax,[grs.GRS_oMrsCur]
	call	SetPsErrMsg		;set ps.bdErr to name of module
	;if static err buf, OM err not possible
	mov	ax,ER_OM
   DJMP je	ScanErr			;brif out-of-memory
	mov	ax,MSG_MrsNotFound
	; 'Module not found.  Unload from program? <OK/Cancel>.
	; ReportError() will Unload mrs if OK and MSG_MrsNotFound.
   DJMP jmp	SHORT ScanErr

FileLoaded:
	and	[mrsCur.MRS_flags],NOT FM_AllSsRude ;we have at least one non
					;SS_RUDE text table in this module.
	mov	al,[scanTo]		;al = desired state
	cmp	al,[txdCur.TXD_scanState]
   DJMP jae	SctGoodExit		;brif this table is already scanned
					; to at least [scanTo]
;***** Start Revision [41]
;***** End Revision [41]

STT_DoScan:
	cmp	al,SS_EXECUTE
	je	ToExecute		;brif scanning to SS_EXECUTE
	PUSHI	ax,SS_PARSE		;pass target state to SsRudeScan
	call	SsRudeScan		;scan to SS_PARSE
	or	ax,ax			
	jz	SctGoodExit		; brif no error
					;ax = error code
	jmp	SHORT ScanErr

;Scan current text table from SS_PARSE to SS_EXECUTE
ToExecute:
	call	SsScan			;scan text table to SS_EXECUTE
					;ax = scanner error (0 if none)
					;grs.otxCur = location of error
	DbChk	TxdOps			;see if scanner inserted bad opcode
	or	ax,ax			
	jne	ScanErr			;brif scanner encountered errors
	and	[flagsTm],NOT FTM_NoSsExecute ;we now have a table in
					;SS_EXECUTE

SctGoodExit:

	    mov     ax,UNDEFINED	;double duty - - - non-zero == TRUE
	    cmp     [grs.GRS_otxCONT],ax
	    jnz     SctExit		;brif can CONTinue

	    call    ResetData		;ensure the next READ is to the
					;  first DATA stmt in this module
					;  this is needed only for READ in
					;  direct mode buffer after we set
					;  Cant CONTinue.
	    ;AX already set non-Zero by call to ResetData

SctExit:
	or	ax,ax			
cEnd

;ax = error code, grs.otxCur = text offset to error
ScanErr:
	mov	dx,[grs.GRS_otxCur]	;dx = otx of reported error
	mov	[txtErr.TXER_oSrc],UNDEFINED
					;for scanner detected errors, we cant
					;detect the column, compute from otx
;ax = error code, dx = text offset to error
ScanErrCommon:
	mov	[txtErr.TXER_errCode],ax
	

	
	cmp	dx,UNDEFINED		
	je	SetOtx			;brif otx of error is UNDEFINED

	;Scanner sometimes leaves grs.otxCur pointing within an opcode
	;Force it to an opcode boundary for accurate error reporting.
	;Scanner sets low bit of otx if the otx points to an oVar
	;within an opStDeclare opcode.
	
	mov	bx,dx			;bx = dx = otx of err
	and	dl,0FEh			;turn off low bit
	cmp	bx,dx
	jne	SetOtx			;brif error was within opStDeclare
	sub	ax,ax			;tell TxtSkipOp to start at StartOTx
SeOtxLoop:
	push	bx			;save otxErr
	push	ax			;save otxPrev
	cCall	TxtSkipOp		;ax = otx to next opcode after ax
	pop	dx			;dx = otxPrev
	pop	bx			;bx = otxErr
	cmp	ax,bx
	jbe	SeOtxLoop		;brif current opcode's otx <= otxErr
SetOtx:
	mov	[txtErr.TXER_otx],dx	;save real text offset to error
	mov	ax,[grs.GRS_oRsCur]
	mov	[txtErr.TXER_oRs],ax
	mov	al,[grs.GRS_fDirect]	
	mov	[txtErr.TXER_fDirect],al
	call	ChkWatchErr		;modify txtErr if error in Watch expr
;txtErr.otx = text offset of error
;txtErr.oSrc = column of error
;txtErr.errCode = error code
	sub	ax,ax			;return FALSE
	jmp	SHORT SctExit


;**************************************************************
; boolean SystemScan
; Purpose:
;	Scan all text tables to SS_EXECUTE
; Exit:
;	if any scanner or reparse errors were encountered:
;	   txtErr.errCode = an offset into the QBI Message Table (MSG_xxx) or,
;	     if high-bit set, ps.bdpError contains the parser-built
;	     ASCII error message,
;	   txtErr.fDirect is FALSE,
;	   txtErr.oRs identifies the text table with the error,
;	   txtErr.otx is an offset into the text table where the error
;	      was detected.
;	   txtErr.oSrc identifies the column within the source line where
;	      the error was detected.
;	else
;	   txterr.errCode = 0
;	condition codes set based on value in txterr.errCode == 0
;
;**************************************************************
cProc	SystemScan,<PUBLIC,FAR>
cBegin
	mov	[txtErr.TXER_errCode],0	;assume no errors

	test	[grs.GRS_flags],FG_allSsExecute
	jnz	SsExit			
NotDone:
	SetfDirect	al,FALSE	;tells scanner, parser we're not
					;scanning direct mode stmt,
					;if we find any errors, they won't be
					;in the direct mode buffer
	;See if user entered/loaded a $INCLUDE <filename> statement
	; and the file was not found, or saved an Include file.
	;If so, re-evaluate all $INCLUDE statements in all text tables.
	
	call	NotSavedInc		;save all unsaved INCLUDE files
	or	ax,ax			
					; if files saved ok, ax=0
					; if no need to save any, ax=-1
					; if CANCEL, ax=MSG_GoDirect
					; if NO, ax=-2
					; if I/O error, ax = error code
	jg	SsError			; brif I/O error or cancel
	inc	ax			;test for -1
	je	SsNoSave		;brif no files needed to be saved
	jl	SsCancel		;brif user decided not to save
					; one or more INCLUDE files
SsNoSave:
	call	TxtReInclude		;re-parse all $INCLUDE lines if
					; any INCLUDE mrs's have been saved
	or	ax,ax			;ax = txtErr.errCode
	jne	SsDone			;brif error (errors like FileNotFound
					; would not get caught in ReParse loop)

	call	TxtMoved		;remember pcode has moved


	mov	ax,-MSG_Compiling	;display Loading msg in intense video
	call	StatusMsgCP		; to tell user we're compiling

	;First make sure all DEFFNs/SUBs/FUNCTIONs are defined and terminated

	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
	mov	bx,CPOFFSET ReParseTbl
	call	ForEachCP		;re-parse until no more opReParse
					; opcodes in the system.
	je	SsDone			;brif error

	xor	ax,ax
	mov	[SsLineCount],ax
	cCall	UpdStatusLn,<ax>

	;Next, scan all text tables to SS_PARSE state
	mov	[scanTo],SS_PARSE
	mov	bx,CPOFFSET ScanTxtTbl
	call	ForEachTxtTbl
	je	SsDone			;brif error

	mov	[SsLineCount],0

	;Next, scan all text tables to SS_EXECUTE state
	;If we didn't do it in this order, it would be possible to
	;scan one text table to SS_EXECUTE, which contained references
	;to a function in another text table which was still in SS_RUDE
	;state.  This would be trouble, because the function's return
	;type (needed by the execute-scanner) would not have been
	;stored in the prs table entry by the rude scanner yet.
	
	dec	[scanTo]		;scanTo = SS_EXECUTE
.errnz	SS_PARSE - 1
.errnz	SS_EXECUTE
	mov	bx,CPOFFSET ScanTxtTbl
	call	ForEachTxtTbl
	je	SsDone			;brif error
	call	SsTrimCommon		;call scanner to trim back common tbls
	sub	bx,bx			;iWatch = 0
	call	WatchInfo		;can't update WatchInfo when static
					; structures are disabled
SsDone:
	call	StatusMsg0CP		;tell user we're done compiling

	cmp	[txtErr.TXER_errCode],0
	jne	SsExit
	or	[grs.GRS_flags],FG_allSsExecute
SsExit:
cEnd

SsCancel:
	mov	ax,MSG_GoDirect
SsError:
	mov	[txtErr.TXER_errCode],ax
	jmp	short SsDone



;**************************************************************
; ushort FAR TxtDirect()
;
; Purpose:
;	TxtDirect is called by the user interface to parse and
;	scan a direct mode statement.
;	It first parses direct mode statement to SS_RUDE,
;	then if stmt contains any opcodes which require the
;	  program to be scanned, SystemScan is called to scan
;	  all loaded text tables to SS_EXECUTE.
;	then direct mode buffer is scanned to SS_EXECUTE.
;	The reason we parse to SS_RUDE, instead of SS_PARSE,
;	direct mode statements like PRINT A(1) would cause the
;	array A() to be implicitly dimensioned, where the program,
;	which may still be in SS_RUDE, may have defined it AS STRING,
;	resulting in an error.
;	The reason we scan the entire program for statements like
;	A=1 is because the variable table wouldn't exist if the
;	module was in SS_RUDE state.
;
; Entry:
;	ps.bdpSrc contains the 0-terminated source line to be parsed.
;	grs.oMrsCur and grs.oPrsCur identify the scope of the direct
;	   mode statement.
;
; Exit:
;	If no errors were encountered,
;          [txtErr.TXER_errCode]  = return value = 0
;	   grs.bdlDirect contains the executable pcode,
;	   grs.fDirect = TRUE
;	   grs.otxCur = 0
;	If an error was encountered,
;	   return value = txtErr.errCode = an offset into the QBI Message
;	     Table (MSG_xxx) or, if high-bit set, ps.bdpError contains
;	     the parser-built ASCII error message,
;	   If the error was in the direct mode buffer,
;	      txtErr.fDirect is TRUE,
;	      txt.oSrc identifies the column where the error occurred.
;	   Else, the error was encountered in some program text as a result of
;	      ReParsing or Scanning.
;	      txtErr.fDirect is FALSE,
;	      txtErr.oRs identifies the text table with the error,
;	      txtErr.otx is an offset into the text table where the error
;	         was detected.
;	      txtErr.oSrc identifies the column within the source line where
;	         the error was detected.
;	   If direct mode command would have prevented CONT, and user
;	      wants to backout of the command, error code = UNDEFINED.
;
;**************************************************************
cProc	TxtDirect,<PUBLIC,FAR>,<si>
localW	oPrsPreParse
cBegin	TxtDirect

	mov	ax,[grs.GRS_oPrsCur]	;remember oPrs before parseline
	mov	[oPrsPreParse],ax	;in case an error occurs and
					;ParseLine moves us into a new RS.

	;Setting ps.flags.PSF_fBindVars to 0 tells the parser
	;not to bind variable references.  Direct mode statement
	;variable references are bound by rude scanner after entire program
	;has been scanned (and all variables declared).  Otherwise, a stmt
	;like "print a(1)" would cause array a to be implicitly dimensioned
	;when the program has an explicit DIM a(n) statement.
	
TdRetry:
	sub	ax,ax			;ax = 0
	mov	[ps.PS_flags],al
	mov	[txtErr.TXER_errCode],ax;assume no error
	dec	ax			;ax = UNDEFINED
	mov	[ps.PS_otxLine],ax
	SetfDirect al			;tells parser we're parsing a
					; direct mode stmt, if we find an error,
					; it will be in direct mode stmt

	call	ParseLine		;parse the direct mode stmt
	jnc	TdNoErr			;brif parser encountered no error
	jmp	TdParseErr

TdNoErr:
	push	[ps.PS_bdpDst.BDP_pb]
	PUSHI	ax,<CODEOFFSET tOpDirect>
	call	TxtFindOpDS		;ax = adr of 1st interesting opcode
					;dl = index into tOpDirect for opcode

;	*--------------------------------------------------------------------
;	* examine the pcode opcode by opcode:
;	*
;	*  -  Giving an error if any of the opcodes are illegal in direct mode
;	*	 (like opBolLab, opStDefFn, opStCommon etc.)
;	*
;	*  -  Converting any opcodes which are different in direct mode
;	*	 like opGoto->opGotoDirect etc.
;	*
;	*  -  Remembering if the opcode requires a system-scan.
;	*	 ParseLine() helps by setting ps.flags & PSF_fRef TRUE for all
;	*     opcodes which access variables/labels.
;       *
;	*--------------------------------------------------------------------
;
;NOTE: Since otxCur in this loop is an absolute pointer into DS, it is
;      important that no heap movement occur during the loop
;
TdLoop:
	xchg	si,ax			;si = otxCur
	xchg	ax,dx			;al=[txtFindIndex]
.errnz	DIR_opEot AND 0FF00H	;if tOpDirect has > 255 entries, must use ax
	cmp	al,DIR_opEot
	je	TdDone			;brif done with loop (at or beyond eot)

	cmp	al,DIR_ILLEGAL
	ja	TdLegal			;brif opcode is valid in direct mode

	;got opcode which is illegal in direct mode
	mov	ax,ER_ID		;Illegal in direct mode
J1_TdErr:
	jmp	TdErr

TdLegal:
	or	[ps.PS_flags],PSF_fRef	;remember to scan whole program
	cmp	al,DIR_DM_VARIANT
	ja	TdNotDmVar		;brif not a direct mode specific opcode

	;Got an opcode which has a direct mode variant.
	;Convert opStGoto -> opStGotoDirect etc.
	
	inc	WORD PTR [si]		;bump the opcode
	jmp	SHORT TdNext

TdNotDmVar:
	cmp	al,DIR_CANTCONT
	ja	TdNext			;brif opcode doesn't cause CantCont
;Since CantCont can cause movement we must convert si to an offset from
;the start of ps.bdpDst then after calling CantCont reconvert it back to
;a DGROUP offset
	sub	si,[ps.PS_bdpDst.BDP_pb] 
	call	CantCont
	add	si,[ps.PS_bdpDst.BDP_pb] 
TdNext:
	push	si			;pass otxCur (DS pointer)
	PUSHI	ax,<CODEOFFSET tOpDirect>
	call	TxtFindNextOpDS
	jmp	SHORT TdLoop

TdDone:
	test	[grs.GRS_flags],FG_RetDir
	je	TdNoDirRet		;brif no return address to direct
					; mode buffer is on the stack.
	call	AskCantCont_CP		;ask user "Want to back out?"
	jne	TdNoDirRet		;brif user doesn't want to back out
TdUndo:
	mov	ax,UNDEFINED
J2_TdErr:
	jmp	SHORT J1_TdErr

TdNoDirRet:

;If the parser saw a label in the direct mode statement then set the
;FG_OtxInDir grs flag; otherwise, clear it.
	and	[grs.GRS_flags],NOT FG_OtxInDir ;clear the flag
	test	[ps.PS_flags],PSF_fLabelRef	
	jz	@F				;brif no label ref parsed
	or	[grs.GRS_flags],FG_OtxInDir	;set the flag
@@:						

	;Make sure there's enough free space in the direct-mode
	;text table for the pcode we want to execute
	sub	ax,ax
	mov	[grs.GRS_bdlDirect_cbLogical],ax
	dec	ax			;ax = UNDEFINED
	SetfDirect al			;tells TxtFree we're dealing direct
					; mode buffer
	push	[ps.PS_bdpDst.BDP_cbLogical] 
	call	TxtFree
	mov	ax,ER_OM
	je	J1_TdErr		;brif Out-of-memory error
	PUSHI	ax,<dataOFFSET grs.GRS_bdlDirect>
	SetStartOtx ax			
	push	ax
	push	[ps.PS_bdpDst.BDP_pb]
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	push	ax		;pass [ps.PS_bdpDst.BDP_cbLogical]
	mov	[grs.GRS_bdlDirect_cbLogical],ax ;init logical size of dir buff
	call	BdlCopyTo

	test	[ps.PS_flags],PSF_fRef
	je	TdAllScanned

	;If AskCantCont was called above, current module (grs.oMrsCur)
	;may not be current context (grs.oMrsMain).  Make sure current
	;context is active before scanning, giving error if no main
	;module exists.
	
	mov	dx,UNDEFINED
	mov	ax,[grs.GRS_oMrsCur]
	cmp	[grs.GRS_otxCONT],dx
	jne	CanCont			;brif not starting program from scratch
	mov	ax,[grs.GRS_oMrsMain]	;else, activate MAIN module
	xchg	ax,dx			;ax=UNDEFINED, dx=oMrsMain
	cmp	ax,dx
	mov	ax,MSG_NoMainProg
	je	J2_TdErr		;brif no main module
	cCall	RsActivateCP,<dx>	;activate main module
	and	[grs.GRS_flags],NOT FG_allSsExecute ;force scantxttbl
					; invocation so all Data statments get
					; reset, even if all tables are in
					; SS_EXECUTE.
CanCont:

	;This command contains statements which require a system
	;scan to be performed.
	
	call	SystemScan		;scan all text tables to SS_EXECUTE

;  If SystemScan detected an error in the program, we still want to 
;scan the direct-mode-statement, so if the user types something like
;CALL FOO, and FOO is undefined, we will report that error before
;reporting something like Duplicate Definition of an array in the program.
;If there are no errors in the direct mode statement, we will still
;report any errors found by SystemScan, because txtErr.errCode is non-zero.

; If the current module is in SS_RUDE, we can not scan the direct mode 
; statement because there is no variable table.
	cmp	[txdCur.TXD_scanState],SS_RUDE
	je	TdExit

TdAllScanned:
	SetfDirect al,0FFh		;tells scanner we're scanning direct
					; mode buffer
	PUSHI	ax,SS_PARSE		;pass target state to SsRudeScan
	call	SsRudeScan		;scan direct mode stmt to SS_PARSE
	or	ax,ax			
	jz	NotCantCont		; brif no rude scanner error

	cmp	al,ER_CN
	jne	JNE1_TdErr		;brif not a "Cant CONT" type error
					; like creating a new variable when
					; variable tables are locked and can't
					; grow
	call	AskCantCont_CP		;ask user "Want to back out?"
	jne	J1_TdRetry		;brif user doesn't want to back out
J1_TdUndo:
	jmp	TdUndo			;brif user wants to back out
J1_TdRetry:
	jmp	TdRetry			;brif user doesn't want to back out
					; reparse line - we won't get Retry
					; again because AskCantCont called
					; CantCont.

NotCantCont:
	call	SsScan			;static scan direct mode statement
					;ax = scanner error (0 if none)
					;grs.otxCur = location of error
	or	ax,ax			
JNE1_TdErr:
	jne	TdErr			;brif parse->execute scanner got error

	mov	[grs.GRS_otxCur],0	;set otxCur to 0 (for executor)

;If no error occurred, txtErr.errCode = 0
;else
; tErr.errCode, txtErr.fDirect, txtErr.oRs, txtErr.otx, txtErr.oSrc
; must all be set up
;
TdExit:
	mov	ax,[txtErr.TXER_errCode]
cEnd	TxtDirect

;ParseLine encountered an error - handle it
; The parser could have moved us to a new rs for
; two cases. 1). It could have created a prs for
; a SUB/FUNCTION entered in direct mode, or 2)
; a DEF FN could have been active, and a rude
; edit occurred which the prs for the DEF FN to
; be freed, and its mrs to be activated.
;
; If oPrsCur has changed, one of the above cases
; has occured.	If txdCur is for an prs, then it must
; have been case 1.  If txdCur is for an Mrs, then it
; must have been case 2.

TdParseErr:
	mov	ax,[oPrsPreParse]	;get oPrs on entry for TxtParseUndo
	test	[txdCur.TXD_flags],FTX_mrs ;are we at module level?
	je	TdInSubFunc		;brif not
	mov	ax,[grs.GRS_oPrsCur]	;if so, don't reactivate oPrsPreParse,
					; since it could only have been for
					; a DEF FN, which we have freed.
TdInSubFunc:
	call	TxtParseUndo		;back out of the parser changes

	mov	ax,[ps.PS_oSrcErr]
	mov	[txtErr.TXER_oSrc],ax	;save column error occurred in
	test	[ps.PS_flags],PSF_UndoEdit
	jne	J1_TdUndo		;brif user said he wants to back out
					; of the edit while we were in ParseLine
					; (i.e. ParseLine called AskCantCont)

	;See if the parser wants us to try parsing this line again.  This can
	;happen when:
	; We saw something that made us need to ModuleRudeEdit, but part
	;     of the line's pcode had already been emitted in SS_PARSE
	; Variable manager could not add a variable, because variable heap
	;     was locked (because we can CONTinue).  Parser called AskCantCont
	;     and now wants us to try again (much easier than trying to call
	;     varmgr again from within parser).
	
	test	[ps.PS_flags],PSF_fRetry
	jne	J1_TdRetry		;brif ParseLine wants us to try again
	mov	ax,[ps.PS_errCode]
	and	ah,(PSERR_fAsciiMsg + PSERR_errCode) / 100h
					;mask off parser internal flags
	.errnz  PSERR_fAsciiMsg - 8000h	;caller assumes this is high bit
	jmp	SHORT TdErrOSrc

;Error occurred in direct mode statement, position cursor at column 0
;ax = error code
TdErr:
	mov	[txtErr.TXER_oSrc],0
	mov	[txtErr.TXER_otx],0
;ax = error code
TdErrOSrc:
	mov	[txtErr.TXER_errCode],ax
	mov	[txtErr.TXER_fDirect],1
	jmp	SHORT TdExit







;------------------------------------------------------------
;   WATCH Window Text Manager functions
;------------------------------------------------------------

;************************************************************
; OtxEndProg
; Purpose:
;	Return the text offset in the current text table
;	where WATCH pcode begins
; Exit:
;	grs.fDirect = FALSE
;	ax = text offset to opEndProg opcode
;
;************************************************************
PUBLIC	OtxEndProg
OtxEndProg PROC NEAR
	SetfDirect al,0			;don't search direct mode buffer
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,CB_EMPTY_TEXT-StartOtx ;default oTxEndProg if no watch
					  ; pcode is active is 
					  ; cbLogical - (CB_EMPTY_TEXT-StartOtx)
	test	[flagsTM],FTM_WatchPcode ;is there any watch pcode anywhere?
	je	OtxEndProgExit		;brif not

	sub	ax,ax
	push	ax			;search text offset = 0
	PUSHI	ax,<CODEOFFSET tOpWatch>
	call	TxtFindOp		;ax = text offset to opEndProg
OtxEndProgExit:
	ret
OtxEndProg ENDP


sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtfind.asm ===
TITLE	txtfind.asm - Text Table Searching functions

;==========================================================================
;
;Module:  txtfind.asm - Text Table Searching functions
;System:  Quick BASIC Interpreter
;
;=========================================================================*/

	include		version.inc
	TXTFIND_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	executor	;for EnStaticStructs
	includeOnce	names
	includeOnce	opcontrl
	includeOnce	opid
	includeOnce	opmin
	includeOnce	opstmt
	includeOnce	optables
	includeOnce	pcode
	includeOnce	scanner
	includeOnce	txtint
	includeOnce	txtmgr
	includeOnce	ui

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING


;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------

sBegin	DATA

	cbTbSearchOps = (OP_MAX/8)+1	;byte size of TbSearchOps
pOpListLast	DW 0			;cached ptr to table of opcodes from
					;last call to TxtFindOp
tbSearchOps	DB cbTbSearchOps DUP(0) ;bit packed array for TxtFindOp
					;contains a bit for each opcode in
					;the system
lnFindLast	DW UNDEFINED		;used by FindBol to reduce searching
otxFindLast	DW UNDEFINED		;used by FindBol to reduce searching

sEnd	DATA

sBegin CODE

;Table of opcodes which mark the beginning of a line
;
tOpBol	LABEL WORD
	opTabStart	BOL
	opTabEntry	BOL,opBolInclude
	opTabEntry	BOL,opBolIncludeSp
	opTabEntry	BOL,opBol
	opTabEntry	BOL,opBolLab
	opTabEntry	BOL,opBolSp
	opTabEntry	BOL,opBolLabSp
	opTabEntry	BOL,opEndProg
	opTabEntry	BOL,opEot

;Table of opcodes which mark the beginning of a stmt within a line
;
tOpBos	LABEL WORD
	opTabStart	BOS
	opTabEntry	BOS,opBos
	opTabEntry	BOS,opBosSp
	opTabEntry	BOS,opEot

;Table of opcodes which mark the beginning of a stmt or a line
;
tOpBosBol LABEL WORD
	opTabStart	BOSBOL
	opTabEntry	BOSBOL,opBos
	opTabEntry	BOSBOL,opBosSp
	opTabEntry	BOSBOL,opBol
	opTabEntry	BOSBOL,opBolLab
	opTabEntry	BOSBOL,opBolSp
	opTabEntry	BOSBOL,opBolLabSp
	opTabEntry	BOSBOL,opBolInclude
	opTabEntry	BOSBOL,opBolIncludeSp
	opTabEntry	BOSBOL,opEndProg
	opTabEntry	BOSBOL,opEot

;Table of opcodes which mark the beginning of a stmt within a line
; or start of a then/else clause for single line IF RESUME compatability.
;
tOpResume LABEL WORD
	opTabStart	RESUME
	opTabEntry	RESUME,opStIf
	opTabEntry	RESUME,opStElse
		RESUME_opIfElseMax EQU RESUME_opStElse
	opTabEntry	RESUME,opBos
	opTabEntry	RESUME,opBosSp
	opTabEntry	RESUME,opEot

;Table of opcodes which mark the beginning of a stmt or a line
; or start of a then/else clause for single line IF RESUME NEXT compatability.
tOpResumeNext LABEL WORD
	opTabStart	RESUMENEXT
	opTabEntry	RESUMENEXT,opStIf
		RESUMENEXT_opIfMax EQU RESUMENEXT_opStIf
	opTabEntry	RESUMENEXT,opBos
	opTabEntry	RESUMENEXT,opBosSp
	opTabEntry	RESUMENEXT,opBol
	opTabEntry	RESUMENEXT,opBolLab
	opTabEntry	RESUMENEXT,opBolSp
	opTabEntry	RESUMENEXT,opBolLabSp
	opTabEntry	RESUMENEXT,opBolInclude
	opTabEntry	RESUMENEXT,opBolIncludeSp
	opTabEntry	RESUMENEXT,opEndProg
	opTabEntry	RESUMENEXT,opEot

;Table of legal opcodes which may appear between a SELECT CASE and the
;   First CASE item, CASE ELSE, or END SELECT

tOpSelect label   word
	opTabStart	SEL
	opTabEntry	SEL,opBos
	opTabEntry	SEL,opBosSp
	opTabEntry	SEL,opBol
	opTabEntry	SEL,opBolSp
	opTabEntry	SEL,opBolInclude
	opTabEntry	SEL,opBolIncludeSp
	opTabEntry	SEL,opNoType
	opTabEntry	SEL,opQuoteRem
	opTabEntry	SEL,opStRem
	SEL_opValidMax	EQU SEL_opStRem 	;max valid opcode

	opTabEntry	SEL,opBolLab		;labels aren't allowed
	opTabEntry	SEL,opBolLabSp		;between SELECT / 1st item
	opTabEntry	SEL,opEot




sEnd	CODE

;-------------------------------------------------------------------------
;		CP Segment Functions
;-------------------------------------------------------------------------

sBegin	CP
assumes	cs,CP


;***
;InitSearchTable - Initialize search table for TxtFindOpcode
;
;Purpose:
;	Builds a bit packed array for the specified search opcodes.
;	Each opcode in the passed list will have a bit set in
;	the constructed table.	All other opcodes in the table
;	will have their associated bits set to 0.
;Entry:
;	di - ptr to tbSearchOps (in DGROUP) [6]
;	segCode:si - ptr to list of search opcodes.
;		The first word of the table contains the number
;		of opcodes in the table.
;Exit:
;	tbSearchOps - constructed bitpacked array of search opcodes
;
;***************************************************************************
DbPub 	InitSearchTable
cProc	InitSearchTable,<NEAR>,<si>
cBegin
	GetSegAddr CODE			;ax = current address of CODE seg
	mov	ds,ax			;ds:si = pOpcodeList

assumes ds,NOTHING 
	DbSegMoveOff			;can't allow seg movement
	push	ss
	pop	es			;es = DGROUP

	mov	cx,cbTbSearchOps	;get byte size of table

	push	di			;save table base
	sub	ax,ax			;clear previous table
	shr	cx,1			;byte count -> word count
	rep	stosw			;clear table
	jnc	EvenCount		;brif count even

	stosb				;clear the last (odd) byte
EvenCount:
	pop	di			;recover table base


	lodsw				;pick up cwOpcodes
	and	ah,7fH			;mask out Search all opcodes bit
	mov	dx,ax			;dx = count of opcodes in list

ConstructLoop:
	lodsw				;get opcode
	mov	bx,ax
	shr	bx,1			;divide opcode by 8 to get
	shr	bx,1			;table index for specified opcode
	shr	bx,1			;bx = table index for opcode
	and	al,7			;al = bit number to set in byte
	mov	cl,1
	xchg	ax,cx
	shl	al,cl			;generate bit mask for table byte
	or	es:[di+bx],al		;set bit for opcode
	dec	dx
	jne	ConstructLoop		;get next opcode

	push	ss
	pop	ds			;restore ds = DGROUP
	DbSegMoveOn			;OK to move segs again
assumes ds,DGROUP

cEnd


;*************************************************************************
; TxtFindOpcode(al:operation, otxStart, pOpcodeList)
; Purpose:
;	Given an offset into the current text table, and a
;	list of opcodes to search for, perform a search skipping
;	each opcode's operands.  As a FUTURE optimization all opBol
;	opcodes could be linked.  This would eliminate many calls to
;	this routine.
;	Note: this routine was initially a lot smaller, but SS_EXECUTE
;	and Non SS_EXECUTE searches were split for performance.  This
;	routine shows up significantly in ASCII load/Rude Scan/ and
;	CUT/PASTE/COPY operations.
; Entry:
;	[al] = 0 or more TFC_xxx flags indicating what to do
	TFC_FindNext EQU 1  ; skip 1st opcode in buffer before doing search
	TFC_FindInDS EQU 2  ;search in DS segment, not current text table
	TFC_FindExec EQU 4  ;pcode buffer is in EXECUTE scan state
;	parm1: ushort otxStart - offset into buffer to start search.
;	       [14] A value of 0 always means start at StartOtx.
;	parm2: ushort *pOpcodeList - If this parm is NULL,
;	  the current opcode is skipped.
;	  If it is not NULL, it points to a list of opcodes to search for.
;	  The first word in the list is the count of opcodes which follow.
;	  If the high bit of this first word is set, it means the table
;	  is to be searched even for opcodes which don't have the
;	  OPA_fTxtFind attribute flag set (speed optimization).
;	  NOTE: Make sure one of them is opEot to ensure that we don't
;	  search past end-of-text.
;	  NOTE: This table must reside in the CODE segment.
;	grs.fDirect, oMrsCur, oPrsCur identify the text table being
;	  searched.  txdCur describes its text table.
;	txdCur.TXD_scanState indicates text table's scan state
;
; Exit:
;	DL = txtFindIndex (global static ushort variable) = 0 if 1st opcode in
;	   list was found, 1 if 2nd opcode in list was found etc.
;	   (this is only set if parm2 is not NULL on entry)
;	AX = offset within text where one of the opcodes was found
;	pOpListLast - cached ptr to list of search opcodes.
;			(Speed opt to avoid reconstructing tbSearchOps
;			for each call to TxtFindOpcode).
;
;*************************************************************************
PUBLIC	TxtFindOpDS
TxtFindOpDS PROC NEAR
	mov	al,TFC_FindInDS
	jmp	SHORT TxtFindOpcode
TxtFindOpDS ENDP

PUBLIC	TxtFindNextOpDS
TxtFindNextOpDS PROC NEAR
	mov	al,TFC_FindNext + TFC_FindInDS
	jmp	SHORT TxtFindOpcode
TxtFindNextOpDS ENDP

;TxtFindOpExec and TxtFindNextOpExec are called by scanner when it knows
;that pcode is in SS_EXECUTE even though txdCur.scanState = SS_PARSE.
;It does this when it found an error during scan, and is backing out
;of the scan.

cProc	TxtFindOpExec,<PUBLIC,FAR>	
	parmW	otxStart		
	parmW	pOpcodeList		
cBegin	TxtFindOpExec			
	mov	al,TFC_FindExec 	
	cCall	TxtFindOpcode,<otxStart, pOpcodeList>	
cEnd	TxtFindOpExec			

DbPub TxtFindNextOpExec
TxtFindNextOpExec PROC NEAR
	mov	al,TFC_FindNext + TFC_FindExec
	jmp	SHORT TxtFindOpcode
TxtFindNextOpExec ENDP

PUBLIC	TxtFindOp
TxtFindOp PROC NEAR
	mov	al,TFC_FindExec 	
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	je	TxtFindOpcode		; brif txt tbl in executeable state

	cmp	[grs.GRS_fDirect],FALSE
	jne	TxtFindOpcode		; brif direct mode buffer (This func
					; can assume it is in executable state)
	sub	al,al
	jmp	SHORT TxtFindOpcode	;branch to TxtFindNextOp shared code
TxtFindOp ENDP

PUBLIC	TxtFindNextOp
TxtFindNextOp PROC NEAR
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	je	TxtFindNextOpExec	;brif txt table is in executable state
	cmp	[grs.GRS_fDirect],FALSE
	jne	TxtFindNextOpExec	;brif direct mode buffer (This func
					; can assume it is in executable state)
	mov	al,TFC_FindNext
TxtFindNextOp ENDP
	;fall into TxtFindOpcode

cProc	TxtFindOpcode,<NEAR>,<si,di>
	parmW	otxStart
	parmW	pOpcodeList
	localB	flags
cBegin	;TxtFindOpcode

	DbChk	ConStatStructs		;ensure static structures, else
					; txdCur structure contains garbage.
	mov	[flags],al		;remember what we need to do
	DbChk	TxdCur			;perform sanity check on txdCur

	mov	si,[pOpcodeList]	;get ptr to opcode list
	mov	di,si			;set up in case its TxtSkipOp

	or	si,si			;was an Opcode list specified
	je	NoInitTable		;brif not - skip one opcode case

	mov	di,offset dgroup:tbSearchOps
	cmp	si,[pOpListLast]	;is table already built?
	je	NoInitTable		;brif so - use it

	mov	[pOpListLast],si	;cache constructed table

	call	InitSearchTable 	;Init opcode search table
					;es:di - ptr to search opcode table
NoInitTable:
	GetSegAddr CODE			;ax = current address of CODE segment
	push	ax			;push addr of code seg.
					;  later popped into es
	DbSegMoveOff			;can't allow seg movement

	test	[flags],TFC_FindInDS
	jne	DoItInDS		;brif entry was TxtFind[Next]OpDS
					; in which case the txt table is the
					; direct mode buffer which is in DGROUP
	GetSegTxtCur			;[24] es = seg adr of current txt tbl
	push	es			; ds = seg of current txt table
	pop	ds			
assumes	ds,NOTHING

DoItInDS:
	pop	es			;es = adr of CODE seg

	;********************************************************
	;NOTE: DS register points to text table until end-of-loop
	;      ES points to CODE, where opcodes in execute state can be accessed
	;      SS still points to DGROUP, so local vars can be accessed
	;********************************************************

	mov	si,[otxStart]		;ds:si = ptr to txt table of opcode
					;to start search with
	or	di,di			;is this a TxtSkip request?
	jne	NotSkipOp		;brif not

; We just want to skip one opcode in the text table.
;	ds:si - points to opcode to skip.

	lodsw		 		;ax = current opcode from text table
	test	[flags],TFC_FindExec
	je	SkipOpNotExec		;brif scanState == SS_EXECUTABLE

; map executor to opcode
	xchg	bx,ax			;bx = executor's adr
	mov	ax,es:[bx-2]		;ax = executor's opcode
SkipOpNotExec:
	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands
	mov	dx,ax
	mov	bx,dx			;bx = opcode
	mov	al,cs:[mpOpAtr_UNDONE + bx]    ; al = #bytes of operands
	and	ax,OPA_CntMask		;Isolate attribute count
.errnz	OPA_CntMask AND 0FF00H		;must use ax in next line if not
	cmp	al,OPA_CntMask		;Test for cnt field in operand
	jne	SkipNotVar		;brif variable length operand count

	lodsw				;ax = # bytes of operands
	inc	ax			;round up to odd count as follows:
	and	al,-2			; {0,1,2,3,4,...} => {1,3,3,5,5,...}
SkipNotVar:
	add	si,ax			;si points to next opcode
	push	ss
	pop	ds			;ds -> DGROUP
	DJMP	jmp SHORT FindExit

J1_FindOpExec:
	DJMP	jmp SHORT FindOpExec

; Search for first opcode in text table which matches an opcode specified
; in the search table.

NotSkipOp:
	test	[flags],TFC_FindExec
	jne	J1_FindOpExec		;brif scanState == SS_EXECUTABLE

	test	[flags],TFC_FindNext
	je	TestOp			;brif entry point was TxtFindOp[DS]
	lodsw		 		;ax = current opcode from text table

	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands
	mov	dx,ax

	;Register conventions for TxtFind loop
	;ds:si	- pts to current opcode in txt table
	;ss:di	- pts to base of search opcode bit array
	;dx	- current opcode

TryNext:
	mov	bx,dx			;bx = opcode
	mov	al,cs:[mpOpAtr_UNDONE + bx]    ; al = #bytes of operands
	and	ax,OPA_CntMask		;Isolate attribute count
.errnz	OPA_CntMask AND 0FF00H		;must use ax in next line if not
	cmp	al,OPA_CntMask		;Test for cnt field in operand
	je	VarLenOpcode		;brif variable length operand count
VarLenRet:
	add	si,ax			;si points to next opcode
TestOp:
	lodsw		 		;ax=opcode to search for (from txt tbl)
	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands

; test to see if opcode bit is set in search table

	mov	dx,ax			;dx = current opcode
	mov	bx,ax
	shr	bx,1			;divide opcode by 8 to get byte index
	shr	bx,1			;into bit-packed array for this opcode
	shr	bx,1			;bx=byte in bit packed array for opcode
	and	al,7			;al = bit number in array byte
	mov	cl,al
	mov	al,1
	shl	al,cl			;al = bit mask for opcode in array byte
	test	ss:[di+bx],al		;test opcode bit for match
	jz	TryNext 		;brif no match, try next opcode

; We have found the opcode.  We reenter here from FindOpExec.
;    si - pts two bytes past found opcode.

FoundOpcode:
	dec	si
	dec	si			;si points to found opcode

	push	ss
	pop	ds			;restore ds -> DGROUP
assumes ds,DGROUP
					;es still points to CODE
	mov	di,[pOpcodeList]	;es:di = ptr to original list of opcodes
	inc	di
	inc	di			;advance past size of table to first op
	mov	cx,-1
	xchg	ax,dx			;ax = opcode found
	repne	scasw			;search for found opcode in table
	not	cx			;cx = index+1 into table where opcode
					;was found
	dec	cx			;cx = index
	DbAssertRel cx,be,[cOpcodes],CP,<Error In TxtFindOp: Incorrect opTable>
	mov	[txtFindIndex],cl	;return index for matched opcode in
					; global static variable txtFindIndex
	mov	dl,cl			;return txtFindIndex in dl
FindExit:
	xchg	ax,si			;return offset in ax
	DbSegMoveOn			;OK to move segs again
cEnd	;TxtFindOpcode

; We have a variable length opcode in SS_RUDE or SS_PARSE state.
; Pick up the byte count of the operands, and skip to the next opcode.
;
VarLenOpcode:
	lodsw				;ax = # bytes of operands
	inc	ax			;round up to odd count as follows:
	and	al,-2			; {0,1,2,3,4,...} => {1,3,3,5,5,...}
	jmp	SHORT VarLenRet


	;********************************************************
	;NOTE: DS register points to text table until end-of-loop
	;      ES points to CODE, where opcodes in execute state can be accessed
	;      SS still points to DGROUP, so local vars can be accessed
	;********************************************************
assumes	ds,NOTHING

; We are in SS_EXECUTE state.  Search the pcode for an opcode from
; the passed table.

FindOpExec:
	test	[flags],TFC_FindNext
	je	TestOpExec		;brif entry point was TxtFindOp[DS]
	lodsw		 		;ax = current opcode from text table
; map executor to opcode
	xchg	bx,ax			;bx = executor's adr
	mov	ax,es:[bx-2]		;ax = executor's opcode

	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands
	mov	dx,ax

	;Register conventions for FinOpExec loop
	;ds:si	- pts to current opcode in txt table
	;ss:di	- pts to base of search opcode bit array
	;es	- pts to CODE seg for execute state searches
	;dx	- current opcode

TryNextExec:
	mov	bx,dx			;bx = opcode
	mov	al,cs:[mpOpAtr_UNDONE + bx]    ; al = #bytes of operands
	and	ax,OPA_CntMask		;Isolate attribute count
.errnz	OPA_CntMask AND 0FF00H		;must use ax in next line if not
	cmp	al,OPA_CntMask		;Test for cnt field in operand
	je	VarLenOpcodeExec	;brif variable length operand count
VarLenExecRet:
	add	si,ax			;si points to next opcode
TestOpExec:
	lodsw		 		;ax=opcode to search for (from txt tbl)

; map executor to opcode
	mov	bx,ax			;bx = executor's adr
	mov	ax,es:[bx-2]		;ax = executor's opcode

	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands

; test to see if opcode bit is set in search table

	mov	dx,ax			;dx = current opcode
	mov	bx,ax
	shr	bx,1			;divide opcode by 8 to get byte index
	shr	bx,1			;into bit-packed array for this opcode
	shr	bx,1			;bx=byte in bit packed array for opcode
	and	al,7			;al = bit number in array byte
	mov	cl,al
	mov	al,1
	shl	al,cl			;al = bit mask for opcode in array byte
	test	ss:[di+bx],al		;test opcode bit for match
	jz	TryNextExec		;brif no match, try next opcode
	jmp	FoundOpcode

; We have a variable length opcode in SS_EXECUTE state.
; Pick up the byte count of the operands, and skip to the next opcode.
;
VarLenOpcodeExec:
	lodsw				;ax = # bytes of operands
	inc	ax			;round up to odd count as follows:
	and	al,-2			; {0,1,2,3,4,...} => {1,3,3,5,5,...}
	jmp	SHORT VarLenExecRet

assumes ds,DGROUP


;*************************************************************************
; TxtFindOpFar
; Purpose:
;	Same as TxtFindOp, only has a FAR interface
;
;*************************************************************************
cProc	TxtFindOpFar,<PUBLIC,FAR>
	parmW	otxStart
	parmW	pOpcodeList
cBegin
	cCall	TxtFindOp,<otxStart,pOpcodeList>
cEnd

;*************************************************************************
; TxtFindNextOpFar
; Purpose:
;	Same as TxtFindNextOp, only has a FAR interface
;
;*************************************************************************
cProc	TxtFindNextOpFar,<PUBLIC,FAR>
	parmW	otxStart
	parmW	pOpcodeList
cBegin
	cCall	TxtFindNextOp,<otxStart,pOpcodeList>
cEnd

;*************************************************************************
; TxtSkipOp
; Purpose:
;	Skip over 1 opcode.  Text table can be in any scan-state.
; Entry:
;	grs.fDirect, grs.oRsCur identify text table
;	ax = offset of opcode to be skipped
; Exit:
;	ax = offset beyond skipped opcode
;
;*************************************************************************
cProc	TxtSkipOp,<PUBLIC,NEAR>
cBegin
	push	ax
	PUSHI	ax,0
	cCall	TxtFindNextOp		;ax = result
cEnd

;*************************************************************************
; TxtSkipOpFar
; Purpose:
;	Same as TxtSkipOp, only has a FAR interface, and otx is in BX
;
;*************************************************************************
cProc	TxtSkipOpFar,<PUBLIC,FAR>
cBegin
	xchg	ax, bx			; ax = input value
	cCall	TxtSkipOp		;ax = result
cEnd

;*************************************************************************
; TxtChkValidOpsExec
; Purpose:
;	Verify that expected opcodes exist in an oTx range. The text
;	table is assumed to be in SS_EXECUTE state.  Ensures that only
;	white space and remarks come between a SELECT CASE and the
;	first CASE, END SELECT clause.
; Entry:
;	parm1: ushort oTxFirst - oTx of first opcode of interest.
;	parm2: ushort oTxLast  - oTx of last opcode of interest.
; Exit:
;	ax = oTx of first opcode not found in list, or oTxLast if all opcodes
;	     valid.
;	dx == 0 if all opcodes valid.
; Preserves:
;	si, di
;*************************************************************************
cProc	TxtChkValidOpsExec,<PUBLIC,FAR>,<si>	
parmW	oTxFirst
parmW	oTxLast
cBegin
	DbChk	Otx,otxFirst		
	DbChk	Otx,otxLast		
	mov	ax,oTxFirst		;start at first opcode of interest

TxtChkValidLoop:
	push	ax			;stack oTxCur for Second TxtFind call

	push	ax
	PUSHI	ax,<codeOFFSET tOpSelect> ;get valid op table addr
	call	TxtFindNextOpExec	;ax = oTx of next opcode in list
	pop	bx			;recover oTxCur

	cmp	dl,SEL_opValidMax	;is op within valid range?
	ja	TxtChkValidX		;ax = oTx of bad guy, psw.z clear

	xchg	ax,si			;remember found opcode

	push	bx			;oTxCur
	PUSHI	ax,0			;find next op (oTxCur already stacked)
	cCall	TxtFindNextOpExec	;ax = oTx of next opcode
	cmp	ax,si			;next opcode should have been in list
	jnz	TxtChkValidX		;brif not - offender in AX, psw.z clear

	cmp	ax,oTxLast		;more to search?
	jb	TxtChkValidLoop 	;brif so.

	cmp	ax,ax			;all hunky dory - set psw.z

TxtChkValidX:
	mov	dx,sp			
	jnz	@F			; brif not all opcodes valid

	sub	dx,dx			
@@:					
cEnd

;*************************************************************************
; LOCAL FindBol
; Purpose:
;	Search the current text table from its start for a certain
;	beginning of line opcode, given the following 2 stopping conditions:
;	1 - stop after cx beginning of lines have been seen,
;	2 - stop after going beyond a certain text offset
; NOTE: This routine is crucial for PageUp speed.  Thus some code has been
;	duplicated from TxtFindOpcode to help Page Up performance.
; Entry:
;	ax = txt offset to stop at
;	cx = line # to stop at
; Exit:
;	grs.fDirect is reset to FALSE
;	ax = text offset to beginning of line opcode
;	dx = text offset to beginning of line opcode for previous line
;	cx = initial cx - # lines skipped
;	[fLnNotIncl] = zero if given line was an INCLUDEd line
;
; For example, if pcode contained:
;	[0]opBol,[2]opStop,[4]opBol,[6]opStop,[8]opEndProg,[0A]opEot
; The following inputs would produce the following results:
;	  ax   cx  =>	ax   cx   dx
;	0000 FFFF  => 0004 FFFF 0000
;	0001 FFFF  => 0004 FFFF 0000
;	0002 FFFF  => 0004 FFFF 0000
;	0003 FFFF  => 0004 FFFF 0000
;	0004 FFFF  => 0008 FFFE 0004
;	0005 FFFF  => 0008 FFFE 0004
;	0006 FFFF  => 0008 FFFE 0004
;	0007 FFFF  => 0008 FFFE 0004
;	0008 FFFF  => 0008 FFFE 0004
;	FFFF 0000  => 0000 0000 0000
;	FFFF 0001  => 0004 0000 0000
;	FFFF 0002  => 0008 0000 0004
;	FFFF 0003  => 0008 0000 0004
;
;*************************************************************************

StartFromTop:
	xor	ax,ax			
	mov	[lnFindLast],ax		;set lnFindLast to line # zero

;We must search for the first Bol since the scanner can insert opNoList's
;before the first line.
	push	cx			;save skip line count
	push	ax			
	PUSHI	ax,<CODEOFFSET tOpBol>	;pass ptr to start-of-line table
	call	TxtFindOp		;ax = offset to 1st opBos/opBol/opEot
	pop	cx			;restore cx = skip line count
	mov 	dx,ax			;dx = offset of 0th line
	mov	[otxFindLast],ax	;otxFindLast = offset of 0th line
	jmp	SHORT StartFromLast

; We are in SS_EXECUTE state. Map executor address in ax to opcode.
FBLGotExec:
	xchg	ax,bx			;executor address is in bx
	mov	ax,es:[bx-2]		;get opcode
DJMP	jmp	short FBLGotExecRet

;This value of CLINES_CACHE means in the QBI screen editor, a time
;consuming OtxOfLn search is performed every few page-up keys
;when the user is scrolling up through his file.

CLINES_CACHE EQU 60
DbPub	FindBol
cProc	FindBol,<NEAR>,<si,di,es>
localW	cLnCache
localW	oTxBolPrev
cBegin
	DbChk	Otx,ax			
	SetfDirect dl,FALSE		;turn off direct mode
					;	 for TxtFindNextOp
	mov	[fLnNotIncl],NOT FALSE
	xchg	di,ax			;di = stopping text offset
	mov	ax,[otxFindLast]	;ax = oTxCur
	mov	dx,ax			;dx = oTxPrev

	cmp	di,ax
	jb	StartFromTop		;brif can't used cached value
	cmp	cx,[lnFindLast]
	jb	StartFromTop		;brif can't used cached value
	sub	cx,[lnFindLast]		;start search from last saved location
StartFromLast:
	inc	di			;Adjust otxMax since Lodsw in loop will
	inc	di			; advance 2 bytes past current opcode.
DJMP	jcxz	FindBolExit		;brif we've skipped enough lines (0)
	mov	[cLnCache],CLINES_CACHE+1 ;load count-down counter
	push	dx
	push	cx
	call	TxtSkipOp		;skip first opcode
	xchg	ax,si			;update oTxCur

	GetSegAddr CODE			;ax = current address of CODE seg
	push	ax			;save addr of CODE seg
	GetSegTxtCur			;[24]es = seg of curr txt table
	push	es			
	pop	ds			;ds = seg addr of current text table
assumes	ds,NOTHING
	pop	es			;es = seg addr of CODE seg

	pop	cx			
	pop	dx			

	;*******************************************************************
	; Register useage during loop
	;  DS - register points to text table until end-of-loop
	;  ES - points to CODE, where opcodes in execute state
	;	  can be accessed
	;  SS - still points to DGROUP, so local vars can be accessed
	;  DI - otxMax (stop search if beyond otxMax)
	;  SI - otxCur (current otx of opcode we are searching)
	;  DX - otxBolCur (otx of last BOL encountered)
	;  CX - cLnMax (maximum number of BOLs to visit)
	;  BX - scratch
	;  AX - scratch
	;*******************************************************************

FindBolLoop:
	dec	[cLnCache]
	je	UpdateCache		;brif time to save reference point

FindBolLoop1:
	mov	[oTxBolPrev],dx 	;remember Bol of previous line
FBLInnerLoop:

	lodsw				;ax = opcode/executor
	cmp	[txdCur.TXD_scanState],SS_EXECUTE ;is this table in execute?
DJMP	je	FBLGotExec		;brif so, map executor to opcode

FBLGotExecRet:
	and	ah,HIGH OPCODE_MASK	;upper bits sometimes used for operands
	mov	bx,ax			;bx = opcode
.errnz	opBol
.errnz	opBolSp-1
.errnz	opBolInclude-opBolSp-1
.errnz	opBolIncludeSp-opBolInclude-1
.errnz	opBolLab-opBolIncludeSp-1
.errnz	opBolLabSp-opBolLab-1
.errnz	opBos-opBolLabSp-1
.errnz	opBosSp-opBos-1
.errnz	opEot-opBosSp-1
.errnz	opEndProg-opEot-1

	cmp	ax,opEndProg		;is this opBol -> opEndProg?
	jbe	FBLGotHit		;brif so, we have an interesting opcode

FBLGotHitCont:
	mov	al,cs:[mpOpAtr_UNDONE + bx]    ; al = #bytes in opcode
	and	ax,OPA_CntMask		;Isolate attribute count
.errnz	OPA_CntMask AND 0FF00H
	cmp	al,OPA_CntMask		;is this a variable length opcode?
	je	FBLVarLenOpcode 	;brif so

FBLVarLenRet:
	add	si,ax			;si points to next opcode
	jmp	short FBLInnerLoop	;go grab next opcode

FBLLoopCont:
	loop	FindBolLoop		;brif haven't reached line count limit

;We ran out of lines before we passed oTxMax.  Return the otx of the
; last Bol encountered.
	xchg	ax,dx			;return oTxBolCur
	jmp	short FBLExit1

FindBolDone:
	xchg	ax,si			;return text offset of Bol in ax.
	dec	ax
	dec	ax			;back up to opcode
FBLExit1:
	mov	dx,[oTxBolPrev] 	;return BOL of previous line

FindBolExit:
	push	ss			
	pop	ds			;recover ds=DGROUP
;	DbChk	AtBosBol,ax		;sanity check on ret val
	DbChk	AtBosBol,dx		;sanity check on ret val
cEnd

;We have a variable length opcode. Grab and return count of bytes for opcode
;
FBLVarLenOpcode:
	lodsw				;ax = # bytes of operands
	inc	ax			;round up to odd count as follows:
	and	al,-2			; {0,1,2,3,4,...} => {1,3,3,5,5,...}
	jmp	short FBLVarLenRet


;This gets invoked every CLINES_CACHE times through FindBol's loop
;
UpdateCache:
	mov	[otxFindLast],dx	;save reference text offset
	mov	ax,CLINES_CACHE 	;reload count-down counter
	mov	[cLnCache],ax
	add	[lnFindLast],ax 	;update reference line number
	jmp	FindBolLoop1

;We have an interesting opcode.  It is either an opBos/Bol variant, or
; it is an opEot, opEndProg
FBLGotHit:
	cmp	ax,opBos		;is it an opBol variant?
	jb	FBLGotBol		;brif so
	cmp	ax,opEot		;is it an opBos variant?
	jb	FBLGotHitCont		;brif so, continue search

;We must have either an opEot, or and opEndProg.
;If we found an opEndProg, we're done.  If we found an opEot, it could only
;mean that we were called with an empty text table, and a search line > 0.
;In this case, we force the otxFound to 0.
;
	jne	FindBolDone		;it was an opEndProg
	SetStartOtx ax			;oTxBol = first line
	mov	dx,ax			;oTxBolPrev = first line
	jmp	SHORT FindBolExit

FBLGotBol:
	cmp	si,di			;are we beyond oTxMax?
	ja	FindBolDone		;brif so

	mov	dx,si			;remember this BOL
	dec	dx
	dec	dx			;back up to opBol opcode
;Advance to next opcode
	mov	al,cs:[mpOpAtr_UNDONE + bx]    ; al = #bytes in opcode
	and	ax,OPA_CntMask		;Isolate attribute count
.errnz	OPA_CntMask AND 0FF00H

	add	si,ax			;si points to next opcode
	cmp	[fViewInclude],FALSE
FBLLoopCont_NE:
	jne	FBLLoopCont		;brif user wants to see INCLUDEd text

	mov	[fLnNotIncl],NOT FALSE	;assume line was not included
	cmp	bx,opBolInclude
	jb	FBLLoopCont		;brif line not included
	cmp	bx,opBolIncludeSp
	ja	FBLLoopCont_NE		;brif line not included
	mov	[fLnNotIncl],FALSE	;Line was included
	jmp	FindBolLoop1		;dont count this line if it was included

assumes ds,DGROUP

;*************************************************************************
; TxtChkCache
; Purpose:
;	This function is called whenever:
;	 - Text is editted in the text table (TxtChange, TxtDelete)
;	It resets Watch and History, as well as calling TxtFlushCache if
;	  the editted pcode was prior to the previous cached value.
; Entry:
;	si - oTx of lowest text offset affected by pcode movement
;
;*************************************************************************
;*************************************************************************
; TxtMoved
; Purpose:
;	This function is called whenever:
;	 - Text is moved in the text table (TxtChange, TxtDelete, SsScan,
;	   SsDeScan)
;	It resets Watch and History, as well as calling TxtFlushCache.
;
;*************************************************************************
;*************************************************************************
; TxtFlushCache
; Purpose:
;	This function is called whenever:
;	 - The current text table changes (TxtActivate, TxtCurInit)
;	It discards any static variables used to speed up searching
;	of text tables.
;
;*************************************************************************
PUBLIC	TxtChkCache
TxtChkCache PROC NEAR
	cmp	si,[otxFindLast]	;is affected pcode after cached otx?
	jb	TxtMoved	 	;brif not
					;else txtmgr's cached otx still valid
	call	UiFlushCache		;tell User Interface to flush its cache
	jmp	SHORT TxtMovedNoFlush 	;brif so, cached otx still valid
TxtChkCache ENDP

PUBLIC	TxtMoved
TxtMoved PROC NEAR
	call	TxtFlushCache		;flush cached values
TxtMovedNoFlush:
	test	[mrsCur.MRS_flags2],FM2_NoPcode OR FM2_Include
	jne	NoPcode			;brif editing INCLUDE or DOCUMENT
	cmp	[grs.GRS_fDirect],FALSE
	jne	NoPcode			;brif editing direct mode stmt
	call	HistReset
	call	WatchMoved
NoPcode:
	ret
TxtMoved ENDP

PUBLIC	TxtFlushCache
TxtFlushCache PROC NEAR
	mov	ax,UNDEFINED
	mov	[lnFindLast],ax
	mov	[otxFindLast],ax
	call	UiFlushCache		;tell User Interface to flush its buffer
	ret
TxtFlushCache ENDP

;*************************************************************************
; LnOfOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the physical line number of the line containing the text.
;	Used for error reporting.
;
; Entry:
;	parm1: ushort otx
;
; Exit:
;	grs.fDirect is reset to FALSE
;	AX = 0 relative line number for line containing the offset
;	[fLnNotIncl] = zero if given line was an INCLUDEd line
;
; For example, if pcode contained:
;	[0]opBol,[2]opStop,[4]opBol,[6]opStop,[8]opEndProg,[0A]opEot
; The following inputs would produce the following results:
;	0000 => 0000
;	0001 => 0000
;	0002 => 0000
;	0003 => 0000
;	0004 => 0001
;	0005 => 0001
;	0006 => 0001
;	0007 => 0001
;	0008 => fatal error (only checked in non-release versions)
;
;*************************************************************************
cProc	LnOfOtx,<PUBLIC,FAR>
	parmW	otx
cBegin	LnOfOtx
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	cx,0FFFFH		;don't stop on line count
	mov	ax,[otx]		;stop when we've reached this otx
	call	FindBol 		;search current text table
	mov	ax,0FFFFH
	sub	ax,cx			;ax = line number (0..n)
cEnd	LnOfOtx

;*************************************************************************
; OtxOfLn
;
; Purpose:
;	Given a  physical line	offset (0..n) within the current text
;	table, return  the byte offset into the text table for
;	its opBol opcode.
;
; Entry:
;	parm1: ushort lnSearch
;
; Exit:
;	grs.fDirect is reset to FALSE
;	AX = byte offset into text table
;	[fLnNotIncl] = zero if given line was an INCLUDEd line
;
; For example, if pcode contained:
;	[0]opBol,[2]opStop,[4]opBol,[6]opStop,[8]opEndProg,[0A]opEot
; The following inputs would produce the following results:
;	0000  => 0000
;	0001  => 0004
;	0002  => 0008
;	0003  => fatal error (only checked in non-release versions)
;
;*************************************************************************
cProc	OtxOfLn,<PUBLIC,FAR>
	parmW	ln
cBegin
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	cx,[ln]			;cx = # lines to skip
	mov	ax,[txdCur.TXD_bdlText_cbLogical] ;ax = offset to end-of-text
	call	FindBol 		;ax = offset to bol
cEnd

;*************************************************************************
; OtxBolOfOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the text offset to the start of line.
; Entry:
;	parm1: ushort otx
; Exit:
;	grs.fDirect is reset to FALSE
;	AX = byte offset into text table for line's opBol
;	[fLnNotIncl] = zero if given line was an INCLUDEd line
;
; For example, if pcode contained:
;	[0]opBol,[2]opStop,[4]opBol,[6]opStop,[8]opEndProg,[0A]opEot
; The following inputs would produce the following results:
;	0000 => 0000
;	0001 => 0000
;	0002 => 0000
;	0003 => 0000
;	0004 => 0004
;	0005 => 0004
;	0006 => 0004
;	0007 => 0004
;	0008 => fatal error (only checked in non-release versions)
;
;*************************************************************************
cProc	OtxBolOfOtx,<PUBLIC,FAR>
	parmW	otx
cBegin	OtxBolOfOtx
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	cx,0FFFFH		;don't stop on line count
	mov	ax,[otx]		;stop when we've reached this otx
	call	FindBol
	xchg	ax,dx			;ax = offset to start of line
cEnd	OtxBolOfOtx

;*************************************************************************
; OtxBosOfOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the text offset to the start of statement.
; Entry:
;	parm1: ushort otx
; Exit:
;	grs.fDirect is reset to FALSE
;	AX = byte offset into text table for stmt's opBol/opBos
;
; For example, if pcode contained:
;	[0]opBol,[2]opStop,[4]opBol,[6]opStop,[8]opEndProg,[0A]opEot
; The following inputs would produce the following results:
;	0000 => 0000
;	0001 => 0000
;	0002 => 0000
;	0003 => 0000
;	0004 => 0004
;	0005 => 0004
;	0006 => 0004
;	0007 => 0004
;	0008 => fatal error (only checked in non-release versions)
;
;*************************************************************************
cProc	OtxBosOfOtx,<PUBLIC,FAR>
	parmW	otx
cBegin	OtxBosOfOtx
	DbChk	TxdCur			;perform sanity check on txdCur
	push	[otx]
	call	OtxBolOfOtx		;ax = offset to opBol for this line
BosLoop:
	push	ax			;save potential return value
	push	ax			;pass current text offset
	PUSHI	ax,<CODEOFFSET tOpBos>	;pass ptr to start-of-line table
	call	TxtFindNextOp		;ax = offset to next opBos/opEot
	pop	dx			;dx = potential return value
	cmp	[otx],ax
	ja	BosLoop 		;brif bos is before otx of interest
	xchg	ax,dx			;ax = return value
cEnd	OtxBosOfOtx

;*************************************************************************
; OtxBosNext
; Purpose:
;	Given a text offset into current text table or Direct Mode buffer,
;	find the text offset for the next beginning of statement/line.
;	This is used by UI debugger to find statement boundaries to
;	highlight for trace.
; Entry:
;	parm1 = text offset of interest
;	grs.fDirect, oMrsCur, oPrsCur identify the text table being
;	  searched.  txdCur describes its text table.
; Exit:
;	ax = text offset to next opBol/opBos/opEot opcode
;
;*************************************************************************
cProc	OtxBosNext,<PUBLIC,FAR>		
	parmW	otx			
cBegin	OtxBosNext			
	DbChk	Otx,otx			
	push	[otx]			;pass offset of interest to TxtFind...
	PUSHI	ax,<CODEOFFSET tOpBosBol> ;pass ptr to start-of-line table
	call	TxtFindNextOp		;ax = offset to next opBos/opBol/opEot
cEnd	OtxBosNext			

;*************************************************************************
; OtxBolNext0
; Purpose:
;	Given a text offset into current text table or Direct Mode buffer,
;	find the text offset for the next beginning of line.
;	This is used by CALLS menu and PreScanAsChg().
; Entry:
;	parm1 = text offset of interest
;	grs.fDirect, oMrsCur, oPrsCur identify the text table being
;	  searched.  txdCur describes its text table.
; Exit:
;	ax = text offset to next opBol/opEot opcode
;
;*************************************************************************
cProc	OtxBolNext0,<FAR,PUBLIC>	
	parmW	otx			
cBegin	OtxBolNext0			
	DbChk	Otx,otx			
	push	[otx]			;pass offset of interest
	PUSHI	ax,<CODEOFFSET tOpBol>	;pass ptr to start-of-line table
	call	TxtFindOp		;ax = offset to next opBos/opBol/opEot
cEnd	OtxBolNext0			


;*************************************************************************
; OtxResume
;
; Purpose:
;	Same as OtxBosOfOtx, except that it will also stop at opStIf
;	and opStElse opcodes.  This is needed for RESUME compatability
;	in single line IF statements.
; Entry:
;	parm1: ushort otx
; Exit:
;	grs.fDirect is reset to FALSE
;	AX = byte offset into text table for stmt's opBol/opBos, or
;	     past opStElse, opStIf operand.
;
;*************************************************************************
cProc	OtxResume,<PUBLIC,NEAR>
	parmW	otx
cBegin	OtxResume
	DbChk	TxdCur			;perform sanity check on txdCur
	push	[otx]
	call	OtxBolOfOtx		;ax = offset to opBol for this line
ResLoop:
	push	ax			;save potential return value
	push	ax			;pass current text offset
	PUSHI	ax,<CODEOFFSET tOpResume> ;pass ptr to start-of-line table
	call	TxtFindNextOp		;ax = offset to next opBos/opEot

; We are sensitive to opStIf and opStElse here so that an error in a
; then or else clause will cause RESUME to restart execution in the
; appropriate clause instead of at the beginning of the IF expression.
; This is necessary for compiler compatability. This only applies to
; Single line IF/THEN/ELSE, as the multi line versions are line oriented.

	cmp	dl,RESUME_opIfElseMax	;did we stop at a single IF/ELSE opcode?
	ja	ResNotIfElse		;brif not
	call	TxtSkipOp		;ax = opcode beyond opStIf/opStElse
ResNotIfElse:
	pop	dx			;dx = potential return value
	cmp	[otx],ax
	ja	ResLoop 		;brif bos is before otx of interest
	xchg	ax,dx			;ax = return value
cEnd	OtxResume

;*************************************************************************
; OtxResumeNext
; Purpose:
;	Given a text offset into current text table or Direct Mode buffer,
;	find the text offset for the next beginning of statement/line.
;	This is used by RESUME NEXT statement.
; Entry:
;	parm1 = text offset of interest
;	grs.fDirect, oMrsCur, oPrsCur identify the text table being
;	  searched.  txdCur describes its text table.
; Exit:
;	ax = text offset to next opBol/opBos/opEot opcode, or opcode after
;	  opStIf.
;
;*************************************************************************
cProc	OtxResumeNext,<PUBLIC,FAR>	
	parmW	otx			
cBegin	OtxResumeNext			
	;Preserve and clear grs.fDirect in case RESUME NEXT is being entered
	;from direct mode.
	
	push	WORD PTR ([grs.GRS_fDirect])
	SetfDirect al,FALSE		;switch off direct mode

	push	[otx]			;pass offset of interest to TxtFind...
	PUSHI	ax,<CODEOFFSET tOpResumeNext> ;pass ptr to start-of-line table
	call	TxtFindNextOp		;ax = offset to next opBos/opBol/opEot

;  We need to be sensitive to opStIf in case the error occurred in the IF
;  expression.	An error in the If expresion, and RESUME next in the compiler
;  will cause execution to restart in the THEN clause.	Wierd, but we must
;  do this to be compatable.  An error in the then clause however, will
;  not cause execution to RESUME NEXT into the else clause, execution starts
;  after the else clause, thus we don't need to be sensitive to opStElse here.
;  This is only a concern for Single line IF/THEN/ELSE, as the multi-line
;  variants are line oriented by nature.
;
	cmp	dl,RESUMENEXT_opIfMax	;did we stop at a single IF/ELSE opcode?
	ja	ResNxtNotIf		;brif not
	call	TxtSkipOp		;ax = opcode beyond opStIf/opStElse
ResNxtNotIf:
	PopfDirect dx			
cEnd	OtxResumeNext			

;*************************************************************************
; OtxLabOfOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the text offset for the highest opLab/opBolLab/opLabSp/opBolLabSp
;	opcode which precedes this text offset.
; Entry:
;	ax = otx of interest
; Exit:
;	ax = UNDEFINED if no label precedes this text offset
;	     else, offset into text table to link field of label opcode
;
;*************************************************************************
PUBLIC	OtxLabOfOtx
OtxLabOfOtx PROC NEAR
	DbChk	Otx,ax			
	DbChk	TxdCur			;perform sanity check on txdCur
	xchg	dx,ax			;dx = text offset of interest
	GetSegTxtTblCur	es		;[24]es = seg adr of current text tbl
	mov	ax,UNDEFINED		;ax = default return value (not found)
	mov	bx,[txdCur.TXD_otxLabLink] ;bx = offset to 1st link in list
LinkLoop:
	cmp	bx,dx
	jae	LinkExit		;brif beyond otx of interest
	mov	ax,bx			;ax = previous link
	mov	bx,es:[bx]		;bx points to next in linked list
	jmp	SHORT LinkLoop

LinkExit:
	ret
OtxLabOfOtx ENDP

;**************************************************************
; OtxNoInclude,OtxNoInclPrev
; Purpose:
;	Return the text offset to the next/previous line which did not
;	come from an INCLUDE file.
; Entry:
;	parm ushort otx = text offset where search is to start
; Exit:
;	grs.fDirect is reset to FALSE
;	ax = otx to opBol/opEot for next line which was not INCLUDed
;
;**************************************************************
PUBLIC	OtxNoInclude
OtxNoInclude PROC FAR
	mov	ax,1
	SKIP2_PSW			;skip following sub ax,ax
OtxNoInclude ENDP
PUBLIC	OtxNoInclPrev
OtxNoInclPrev PROC FAR
	sub	ax,ax
OtxNoInclPrev ENDP
;Common entry for OtxNoInclude, OtxNoInclPrev
?DFP = DFP_NONE 			; don't generate non-Release
					;   code to smash regs
cProc	NoIncl,<FAR>			
	ParmW	otx			
cBegin	NoIncl				
?DFP = DFP_CP				; restore switch value
	mov	bx,[otx]		;bx = otx of where to start search
	push	WORD PTR [fViewInclude]
	mov	[fViewInclude],FALSE

	push	ax			;save ln increment
	push	bx			;pass otxStart
	call	LnOfOtx			;ax = line (0..n)
	pop	bx			;bx = ln increment
	add	ax,bx			;bump line# by 1 if OtxNoInclude
	push	ax
	call	OtxOfLn			;ax = text offset to ln

	pop	dx
	mov	[fViewInclude],dl	;restore previous value
cEnd	NoIncl				

;*************************************************************************
; OPrsOfOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the oPrs for the DEF-FN which it falls within.
;	Text table is assumed to not be in SS_EXECUTE state.
; Entry:
;	parm1: ushort otx
; Exit:
;	if text table's scan state = SS_RUDE or if otx does not fall
;	   within a DEF FN, this function returns AX = UNDEFINED
;	else AX = byte offset into procedure table for DEF FN
;
;*************************************************************************
cProc	OPrsOfOtx,<PUBLIC,FAR>
	parmW	otx
cBegin
	DbChk	Otx,otx			
 DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<OPrsOfOtx: bad scanstate>
	DbChk	TxdCur			;perform sanity check on txdCur
	GetSegTxtTblCur	 es		;es = seg adr of cur txt tbl
	mov	ax,UNDEFINED		;default return value = UNDEFINED
	cmp	[grs.GRS_oPrsCur],ax
	je	NotInProc		;branch if not in SUB/FUNCTION
	cmp	[prsCur.PRS_procType],PT_DEFFN
	jne	DefFnExit		;no DEF FNs within SUB/FUNCTION
NotInProc:
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	DefFnExit		; return UNDEFINED if SS_RUDE
	mov	bx,[mrsCur.MRS_otxDefFnLink]
DefFnLoop:
	cmp	bx,[otx]
	ja	DefFnExit		;brif beyond otx of interest
	mov	ax,UNDEFINED		;default return value = UNDEFINED
	cmp	WORD PTR es:-4[bx],opStDefFn
	jne	NotInDef		;brif its an END DEF
	mov	ax,es:2[bx]		;ax = oPrs of this DEF FN
NotInDef:
	mov	bx,es:[bx]		;bx points to next in linked list
	jmp	SHORT DefFnLoop

DefFnExit:
cEnd

;*************************************************************************
; OtxTypDefined
;
; Purpose:
;	Given an oNam, return an offset within the current text table,
;	to the TYPE statement that defines type oNam.
;	Text table is assumed to not be in SS_EXECUTE state.
; Entry:
;	parm1: ushort oNam
; Exit:
;	AX = UNDEFINED if type is not defined
;	     else, offset into text table to opStType's link field
;
;*************************************************************************
cProc	OtxTypDefined,<PUBLIC,NEAR>,<si>
	parmW	oNam
cBegin
 DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<OtxTypDefined: bad state>
	DbChk	TxdCur			;perform sanity check on txdCur
	push	[grs.GRS_oPrsCur]	;save caller's prs
	call	PrsDeactivate		;make module's text table active
	GetSegTxtTblCur	es		;es = seg adr of cur txt tbl
	mov	si,[txdCur.TXD_otxTypeLink]
	mov	ax,[oNam]
	DbChk	ONam,ax
OtxTypeLoop:
	cmp	si,UNDEFINED
	je	OtxTypeDone		;brif not found
	cmp	WORD PTR es:2[si],ax
	je	OtxTypeDone		;brif found
	mov	si,es:[si]		;si points to next in linked list
	jmp	SHORT OtxTypeLoop

OtxTypeDone:
	call	PrsActivateCP		;re-activate caller's prs.  Parm pushed
					; at entry to function, may be UNDEFINED
	mov	ax,si			;return result in ax
	inc	si
	je	OtxTypeExit		;brif type is UNDEFINED
	test	[txdCur.TXD_flags],FTX_mrs
	jne	OtxTypeExit		;brif ref is in module text table
	SetStartOtx ax			;for procedure references, forward
					; referncing is not a problem,
					; pretend definition is at start of text
OtxTypeExit:
cEnd




sEnd	CP


end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtload.asm ===
TITLE	txtload.asm - ASCII Load Functions

;==========================================================================
;
;Module:  txtload.asm - ASCII Load Functions
;System:  Quick BASIC Interpreter
;
;=========================================================================*/

	include		version.inc
	TXTLOAD_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	conint		
	includeOnce	fdb
	includeOnce	heap
	includeOnce	names		
	includeOnce	opid
	includeOnce	opmin
	includeOnce	opstmt
	includeOnce	opaftqb4
	includeOnce	parser
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	rttemp
	includeOnce	sb
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	txtint
	includeOnce	ui
	includeOnce	util
	includeOnce	stack2		

	includeOnce	edit		


	ASC_TAB		EQU 09h
	ASC_LF		EQU 0Ah
	ASC_CR		EQU 0Dh
	ASC_EOF 	EQU 1AH
	ASC_DBL_QUOTE	EQU 22h
	ASC_QUOTE	EQU 27h

	assumes	DS,DATA
	assumes	SS,DATA
	assumes ES,NOTHING


	externFP	B$ISTALCTMPSUB	
	externFP	B$ISTDALCTMP	


sBegin	DATA
	extrn	b$PTRFIL:WORD	;Read only for QBI - channel Ptr

	extrn	szUntitled:BYTE 	


fInQuote DB 0
PUBLIC	fMergeInSub
fMergeInSub DB 0		;non-zero if MERGING a file into a SUB
				; in this case, LoadEnterProc & LoadExitProc
				; will never be called.

;temp buffers for filename before and after Normalization [7]
PUBLIC NormFname
NormFname 	DB	FILNAML DUP (?)	;buffer for temp storage of filename 

	EVEN				; SD must be word-aligned!
PUBLIC sdNormFname
sdNormFname	SD	<0,dataOFFSET NormFname> ;string descriptor 

	externB	b$BAS_EXT		;".bas" constant
	externW	b$PN_NAME		

	globalB	fLoadInclude,0		; Nonzero when loading include file

	externB fInitialized		; non-zero if we've completed
					; initialization of QB

sEnd	DATA

	EXTRN	B$FREF:FAR
	EXTRN	B$OPEN:FAR
	EXTRN	B$IDISK_SINP:FAR
	EXTRN	B$CLOS:FAR
	EXTRN	B$SEEKSTART:FAR
	EXTRN	B$IDISK_BAKC:FAR
	EXTRN	B$IValidatePath:FAR	
	EXTRN	B$CHAN:FAR


sBegin	CODE

;Table of opcodes which make up '$STATIC, '$DYNAMIC and DEFINT
;and INCLUDE statements.
;The order of entries in this table is VERY important
;
tOpProcHdr LABEL WORD
	opTabStart PROCHDR
	opTabEntry PROCHDR,opStDefType
	opTabEntry PROCHDR,op_Dynamic
	opTabEntry PROCHDR,op_Static
	opTabEntry PROCHDR,opStRem
	opTabEntry PROCHDR,opQuoteRem
	opTabEntry PROCHDR,opBol
		PROCHDR_opBolMin equ PROCHDR_opBol
	opTabEntry PROCHDR,opBolSp
	opTabEntry PROCHDR,opBolInclude
	opTabEntry PROCHDR,opBolIncludeSp
	opTabEntry PROCHDR,opBolLab		
	opTabEntry PROCHDR,opBolLabSp		
	opTabEntry PROCHDR,opEndProg
		;must be 2nd to last entry in table
	opTabEntry PROCHDR,opEot
		;must be last entry in table


sEnd	CODE

sBegin	DATA

;-------------------------------------------------------------------
; During ASCII Load/Merge, we don't update threaded linked lists
; through the pcode for each line, because it is very slow.
; Much faster to update them all at once when we're done.
; This must be done at the following points:
;
;	  1 - when we enter a procedure, since we are moving into
;	      a new text table.
;	  2 - when we exit a procedure, since we are returning to
;	      the module's text table.
;	  3 - When the Load reaches end-of-file
;
; otxUpdLinks represents an offset into the current text table to the
; 1st byte of pcode which UpdateLinks() has not been called for yet.
;
;-------------------------------------------------------------------

	EXTRN	tabStops:WORD	;defined in edit manager

PUBLIC	otxUpdLinks
otxUpdLinks	DW 0

;fDynArrays is initialized to FALSE by AsciiMerge, set TRUE when $DYNAMIC is
;seen by TxtChange, set FALSE when $STATIC is seen by TxtChange
;
PUBLIC	fDynArrays
fDynArrays	DB 0

;fDynArraysMod is set to the value of fDynArrays when we enter a procedure
; (LoadEnterProc), so we can restore the $DYNAMIC/$STATIC state when we
; return back to module level (LoadExitProc).
;
fDynArraysMod	DB 0

;fProcDyn is TRUE if a $DYNAMIC deleted later than a $STATIC,
;i.e. the state at the end of the deleted range was $DYNAMIC
;and not $STATIC.
;
PUBLIC	fProcDyn
fProcDyn	DB 0

;otxLastProc = text offset in module's text table where we were
;when we entered the most recent SUB/FUNCTION.  One way to think
;of it is, when were in a procedure, its the module's text offset
;where the 1st line after the END SUB/FUNCTION will be inserted
;into the module's text table.
;
otxLastProc	DW 0

;otxNewInsert is initialized to UNDEFINED by AsciiMerge,
;and set by LoadEnterProc and LoadExitProc to tell AsciiMerge
;that we switched text tables
;
otxNewInsert	DW 0

;cbAftMerge is initialized to 0 by LoadFile,
;if we're doing anything except a MERGE.  If we're doing a MERGE,
;it marks the insertion point in the main module.
;
cbAftMerge DW 0

;otxDefStart and otxDefEnd represent the range of text in the module's
;text table for DEFtype statements synthetically emitted by LoadExitProc.
;If, when the Load completes, this range is at the end of the module,
;it is discarded.  If we didn't do this, the module would grow with
;every subsequent LOAD/SAVE
;
otxDefStart	DW 0
otxDefEnd	DW 0

;used to keep procedure DEFtype stmts independent of module's DEFtype statements
;
PUBLIC	tEtTemp
tEtTemp		DB 26 DUP(0)

PUBLIC	chanCur
chanCur		DW 0	;current channel # used by Load/Save
PUBLIC	cChansOpen	;only referenced by FLoadActive macro
cChansOpen	DB 0	;number of recursive calls to LoadFile active, bumped
			; every time file is opened, decremented when closed.
cAsciiLoadsActive DB 0	;number of recursive calls to LoadFile active for
			; ASCII files

sEnd	DATA


		;---------------------------------------
		; SUB/FUNCTION Window Support Functions 
		;---------------------------------------

externFP FindFile		

sBegin	CP
assumes	cs,CP

;*************************************************************
; boolean NEAR InsertEtDiff(ax:otxInsert, ptEtBase, ptEtNew)
; Purpose:
;	Emit opBol and opStDefType statements necessary to move from
;	one set of default-types to another.
;	The new pcode is emitted at otxInsert in the current module.
;
; NOTE: This routine doesn't update the line count for any inserted BOLs.
;	The caller is responsible for updating the line count if it is
;	needed.
;
; Entry:
;	ax:otxInsert = offset into current module's text table where
;	   synthetic pcode is to be emitted.
;	ptEtBase and ptEtNew point to an arrays of 26 bytes, one ET_xx for each
;	   letter from A to Z.
;
; Exit:
;	If ptEtBase is identical to ptEtNew, no pcode is emitted.
;	else the pcode emitted is the most efficient way to get from
;	   ptEtBase to ptEtNew.
;	If out-of-memory, returns ax = 0 (and psw.z set)
;	else returns ax non-zero
;
;*************************************************************
DEFLN	STRUC
DEFLN_bolOpcode		DW	0
DEFLN_defOpcode		DW	0
DEFLN_defLinkField	DW	0
DEFLN_defOperandLO	DW	0
DEFLN_defOperandHI	DW	0
DEFLN	ENDS

cProc	InsertEtDiff,<PUBLIC,NEAR>,<si,di>
	parmW	ptEtBase
	parmW	ptEtNew
	localV	deflnNew,<SIZE DEFLN>
cBegin
	xchg	di,ax			;di = insertion point (otxInsert)
	mov	[deflnNew.DEFLN_bolOpcode],opBol
	mov	[deflnNew.DEFLN_defOpcode],opStDefType
	mov	si,CBASETYPEMAX		;init etCur
InsEtLoop:
	dec	si			;decrement etCur
	js	InsEtEnd		;brif we've done all primitive types

	push	[ptEtBase]
	push	[ptEtNew]
	push	si			;pass etCur
	call	EtDiff			;[dx:ax] = bit mask representing
					; difference between base and new type
					; with respect to si (etCur)
	mov	[deflnNew.DEFLN_defOperandLO],ax
	mov	[deflnNew.DEFLN_defOperandHI],dx
	or	ax,dx
	je	InsEtLoop		;brif no difference between base & new

	push	di			;pass otxInsert
	PUSHI	ax,<SIZE DEFLN>
	call	TxtMoveUp		;make room for pcode to be inserted
	je	InsEtExit		;return FALSE if out-of-memory

	;insert new pcode in current text table
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	push	di			;pass otxInsert
	lea	ax,[deflnNew]
	push	ax
	PUSHI	ax,<SIZE DEFLN>
	call	BdlCopyTo
	jmp	SHORT InsEtLoop

InsEtEnd:
	mov	ax,sp			;return TRUE (non-zero)
InsEtExit:
	or	ax,ax			;set condition codes for caller
cEnd

;*************************************************************
; boolean InsertDynDiff(ax:otxInsert, dh:fDynBase, dl:fDynNew)
; Purpose:
;	Emit pcode for REM $STATIC or REM $DYNAMIC if fDynBase <> fDynNew.
;	The new pcode is emitted at otxInsert in the current module.
;
; NOTE: This routine doesn't update the line count for any inserted BOLs.
;	The caller is responsible for updating the line count if it is
;	needed.
;
; Entry:
;	ax = otxInsert = offset into current module's text table where
;	   synthetic pcode is to be emitted.
;	dh = fDynBase = 1 if we were already in $DYNAMIC mode.
;	dl = fDynNew = TRUE if we want to move into $DYNAMIC mode.
; Exit:
;	ax = 0 if out-of-memory error (psw.z set as well)
;
;*************************************************************
PUBLIC	InsertDynDiff
InsertDynDiff PROC NEAR
	push	si			;save caller's si,di
	push	di
	xchg	di,ax			;di = text offset where pcode is to go
	cmp	dh,dl
	je	InsDynGoodExit		;brif we're already in mode we want

	mov	si,op_Static
	or	dl,dl
	je	ItsStatic		;brif new state is $STATIC
	mov	si,op_Dynamic
ItsStatic:
	;insert the pcode into text table in reverse order
	push	di			;push source of move to TxtMoveUp
	PUSHI	ax,10d			;push number of bytes to insert
	call	TxtMoveUp
	or	ax,ax
	je	InsDynExit		;return FALSE if out-of-memory

	GetSegTxtTblCur es		;es = seg adr of heap entry for txt tb
	mov	ax,opBol
	stosw				;insert beginning-of-line opcode
	mov	ax,opStRem
	stosw				;insert REM opcode
	sub	ax,ax
	stosw				;insert rem's cb operand
	mov	ax,si			;ax = op_Static or op_Dynamic
	stosw
	sub	ax,ax
	stosw				;insert op_Dynamic/op_Static's operand
InsDynGoodExit:
	mov	ax,sp			;return TRUE (non-zero)
InsDynExit:
	pop	di			;restore caller's si,di
	pop	si
	or	ax,ax			;set condition codes for caller
	ret
InsertDynDiff ENDP

;*************************************************************
; void SqueezeDefs(si:otxCur)
; Purpose:
;	Squeeze out all opStDefType, op_Dynamic and op_Static opcodes
;	from otxCur to the end of the current text table.
;	We squeeze them out and synthetically generate new ones
;	to eliminate redundant statements which could be introduced
;	as a result of moving SUBs and FUNCTIONs to their own text tables
;	during ASCII load.
; Entry:
;	si = text offset where we are to start deleting opcodes
; Exit:
;	The static variable [fProcDyn] is TRUE if a $DYNAMIC deleted
;	later than a $STATIC, i.e. the state at the end of the deleted
;	range was $DYNAMIC and not $STATIC.
;
;*************************************************************
cProc	SqueezeDefs,<PUBLIC,NEAR>,<si,di>
	localW	otxLastBol
	localB	fDeleted
	localB	opIndex
cBegin
	sub	ax,ax
	mov	[fProcDyn],al		;default state is $STATIC
	mov	[fDeleted],al		;so far we've deleted nothing
	dec	ax			;ax = UNDEFINED
	mov	[otxLastBol],ax

	push	si			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpProcHdr>
	call	TxtFindOp		;ax = text offset to 1st found opcode
					;dl = [txtFindIndex]
	cmp	dl,PROCHDR_opEot
	jb	NotEot
	jmp	SqExit			;brif end of table

NotEot:
	xchg	si,ax			;update si = otxCur
	cmp	dl,PROCHDR_opBolMin
	jb	SqLoop			;brif not opBol or opBolSp
	mov	[otxLastBol],si		;save offset to last start of line

;NOTE that TxtFindNextOp(x, p) sets txtFindIndex but
;TxtSkipOp() does not
;dl = txtFindIndex from last call to TxtFind[Next]Op
;
SqLoop:
	mov	[opIndex],dl		;save opcode's id (PROCHDR_xxx)
	push	si			;pass search start text offset
	PUSHI	ax,<CODEOFFSET tOpProcHdr>
	call	TxtFindNextOp		;ax=txt offset to next opcode from list
	xchg	di,ax			;di=txt offset

	mov	ax,si			;pass search start text offset in ax
	call	TxtSkipOp		;ax = offset to opcode after si
	cmp	ax,di
	je	SameOp			;brif this opcode is in list of
					;opcodes which could be deleted

	;some opcode not found in tOpProcHdr is on this line,
	;remember that we can't delete this line.
	
	mov	[otxLastBol],UNDEFINED
SameOp:
	mov	al,[opIndex]		;al = id of previous opcode
	cmp	al,PROCHDR_opStRem
	jae	GotRem			;brif REM or bol opcode
	;current opcode is opStDefType, op_Static, or op_Dynamic, delete it.
	push	ax			;save id of previous opcode

	push	di			;pass ptr beyond opcode to be deleted
	push	si			;pass ptr to opcode to be deleted
	call	TxtMoveDown		;delete current opcode

	pop	ax			;restore al = id of previous opcode
	mov	[fDeleted],1		;remember that something on this
					; line has been deleted
	mov	di,si			;otxCur remains unchanged for next
					; iteration of loop (because we
					; deleted the opcode)
	cmp	al,PROCHDR_op_Dynamic
	jne	NotDyn			;brif not $DYNAMIC
	mov	[fProcDyn],1
NotDyn:
	cmp	al,PROCHDR_op_Static
	jne	ChkNextOp
	mov	[fProcDyn],FALSE
	jmp	SHORT ChkNextOp

;al = PROCHDR_xxx for current opcode (we know its a REM or Begin Of Line opcode)
GotRem:
	cmp	al,PROCHDR_opBolMin
	jae	ChkNextOp		;brif opcode isnt opQuoteRem or opStRem
	lea	dx,[si+6]		;dx = otxCur + 6
	cmp	di,dx
	jbe	ChkNextOp		;brif REM has no text after it (kill it)
	;REM has significant text after it - can't delete it
	mov	[otxLastBol],UNDEFINED	;remember we can't delete this line
;Now test the opcode after this one
ChkNextOp:
	cmp	[txtFindIndex],PROCHDR_opBolMin
	jb	SqNext
	;next opcode is an opBol or opBolSp or opEot
	cmp	[otxLastBol],UNDEFINED
	je	SqNoDel			;brif we can't delete this line
	cmp	[fDeleted],FALSE
	je	SqNoDel			;brif some opcodes on this line has
					;not been deleted
	cmp	al,PROCHDR_opBolMin
	jae	SqNoDel

	;we have deleted all opcodes on this line, delete opBol as well.
	push	word ptr [TxtFindIndex] ;preserve index of last TxtFind call

	push	[otxLastBol]
	push	di
	call	TxtDelete
	mov	di,[otxLastBol]
	pop	ax
	mov	[TxtFindIndex],al	;restore TxtFindIndex for last TxtFind
					; call prior to TxtDelete
SqNoDel:
	mov	[fDeleted],FALSE	;so far, we've deleted nothing on line
	mov	[otxLastBol],di		;remember where last start of line
					; was so we can delete it later if
					; nothing significant is on the line
SqNext:
	mov	dl,[txtFindIndex]
	mov	si,di			;advance to next op (otxCur = otxNext)
	cmp	dl,PROCHDR_opEndProg
	jae	SqExit			;brif end of table
	jmp	SqLoop

SqExit:
cEnd


;*************************************************************
; boolean NEAR LoadEnterProc(otxProcDef)
; Purpose:
;	Called during ASCII Load when we encounter a SUB or FUNCTION
;	statement.  SUB/FUNCTION definition line has already been emitted.
;	Insert synthetically generated DEFxxx statements to make this
;	text table in the same state as the module's table where the
;	SUB/FUNCTION statement was seen.
;
; Entry:
;	procedure's text table is active
;	otxProcDef = where we were in module's text table when the procedure
;	   definition was seen.  We need this so we can update
;	   linked lists which thread through the module's text table.
;
; Exit:
;	modifies ps.bdpDst
;	grs.fDirect = FALSE
;	If out-of-memory,
;	    returns 0 (FALSE),
;	    text table which generated OM error is active.
;	else
;	    ax is non-zero
;	    procedure's text table is active
;	condition codes set based on value in ax
;
;*************************************************************
;.errnz ET_SD - ET_I2 - 4	 ;code assumes ET_I2...ET_SD
cProc	LoadEnterProc,<PUBLIC,NEAR>,<si,di>
	parmW	otxProcDef
	localW	oPrsProc
	localW	otxStartRem
	localW	otxStartBlank
	localW	otxPrev
	localB	prevType
	localB	fInRemBlock
cBegin
	mov	ax,[grs.GRS_oPrsCur]
	mov	[oPrsProc],ax		;remember which proc we just entered

	mov	si,[txdCur.TXD_bdlText_cbLogical]
					;si = current size of text table
					;     before synthetic code emitted
	SetStartOtx ax			;ax = start of text
	mov	bx,dataOFFSET tEtTemp
	call	OtxDefType		;fill tEtTemp with default types
					; i.e. ET_R4 for all letters


	;If we've seen a $DYNAMIC more recently than a $STATIC before
	;place where this procedure occurred in source file,
	;emit a $DYNAMIC at start of procedure's text table
	
	FLoadActive
	je	NotLoading		;brif being called for an edit, not load
	SetStartOtx ax			;ax = start of text
	mov	dh,al			;old state was $STATIC
	mov	dl,[fDynArrays]		;dl = new state ($STATIC or $DYNAMIC)
	mov	[fDynArraysMod],dl	;save so LoadExitProc can restore
	call	InsertDynDiff
	je	J1_LentEx		;return FALSE if out-of-memory error

NotLoading:
	;emit opStDefType opcodes which represent text table's initial state.
	PUSHI	ax,<dataOFFSET tEtTemp>
	PUSHI	ax,<dataOFFSET ps.PS_tEtCur>
	SetStartOtx ax			;ax = start of text
	call	InsertEtDiff
	je	J1_LentEx		;return FALSE if out-of-memory error
	neg	si
	add	si,[txdCur.TXD_bdlText_cbLogical]
					;si = txdCur.bdlText.cbLogical
					;   - cbLogical before insertion
					;   = #bytes of synthetic pcode emitted
	push	si
	mov	bx,si
	SetStartOtx si			;si = start of text
	call	TxtInsUpdate		;update line count from 0 to si for
DbAssertRel ax,ne,0,CP,<Unexpected OM error in LoadEnterProc>
	pop	si			;si = number of bytes inserted
	FloadActive			;test if we are currently loading -
					;  if not then we don't migrate rem's
	jne	InsOk			
J1_LentEx:
	jmp	LentEx			;return value in ax
InsOk:

	;Find the start of a contiguous block of Comments/Bol opcodes
	;that precedes the SUB definition.  Keep this block with the
	;procedure window, not the module window.  This allows users
	;to put comment blocks before their SUB/FUNCTION definitions
	
	;When done, we'll move the comment block, and delete the blank
	;lines preceeding the comment block.  If we didn't delete these
	;blank lines, several contiguous subs with 1 blank line between
	;would leave a huge block of blank lines.
	
	call	PrsDeactivate		;make module's txt table active
	mov	di,[otxLastProc]	;otxCur = otxLastProc
	mov	[otxStartRem],di
	mov	[otxStartBlank],di
	mov	[prevType],PROCHDR_opBol
	mov	[fInRemBlock],0
LentLoop:
	push	di			;pass otxCur to TxtFindNextOp
	PUSHI	ax,<CODEOFFSET tOpProcHdr>
	call	TxtFindNextOp
	cmp	dl,PROCHDR_opEot
	je	LentLoopEx
	mov	cx,[txdCur.TXD_bdlText_cbLogical]
	sub	cx,[cbAftMerge]		;cx = otx beyond any MERGEd text
	cmp	ax,cx
	jb	NotPastMerge		;brif not beyond MERGE's insertion point
	mov	dl,PROCHDR_opEndProg	;treat it like reaching opEndProg
	xchg	ax,cx			;use otx of merge insertion point
NotPastMerge:
	mov	dh,[prevType]		;dh = txtFindIndex for prev iteration
	mov	[prevType],dl		;dl=type of cur opcode, dh=type of prev
	push	dx

	xchg	di,ax			;update di = otxCur, ax = otxPrev
	mov	[otxPrev],ax
	call	TxtSkipOp		;ax = otx beyond opcode otxPrev

	pop	dx			;restore dl=type of cur, dh=type of prev
	cmp	ax,di
	mov	ax,di			;setup for branch to StartBlankBlock
	jne	StartBlankBlock		;brif next opcode wasn't in tOpProcHdr

	cmp	dh,PROCHDR_opBolInclude
	jae	StartBlankBlock		;brif last line came from $INCLUDE file
	cmp	dl,PROCHDR_opBolMin
	jb	InCommentBlk		;brif current op isn't a BOL, bolSp, or
					; opEndProg opcode
	cmp	dh,PROCHDR_opBolMin	;check type of previous opcode
	jb	InCommentBlk		;brif not looking at blank line

	;We now know that di points to opBol that terminates a blank line
	;If any non-blank lines have been seen since the last blank line,
	;reset the start of the blank line block.
	
	cmp	[fInRemBlock],0
	je	StartRemBlock		;brif not start of new block of blanks
	mov	ax,[otxPrev]		;ax points to start of blank line

;we saw blank line - don't include it with SUB's comment header block
; but include it in block of leading blank lines to be deleted.
; ax either points to start of blank line, or within line that is to
; remain at module level.
;
StartBlankBlock:
	mov	[fInRemBlock],0
	mov	[otxStartBlank],ax	 ;reset start of blank line block

;Found an opcode not in tOpProcHdr, or a blank line.
;di points to next opcode found which was in table (di > ax).
;
StartRemBlock:
	mov	[otxStartRem],di	;otxStartRem = otxCur
	jmp	SHORT LentNext

InCommentBlk:
	mov	[fInRemBlock],1		;causes any subsequent blank lines
					; to reset otxStartBlank
LentNext:
	cmp	[prevType],PROCHDR_opEndProg
	jb	LentLoop		;brif end of text table

;[otxStartRem] points to 1st opcode before opStSub which could be
; included with SUB.  For example, if pcode was:
;  opBol opStPrint opQuoteRem
;  opBol opRem
;  opBol opStSub
; otxStartRem would point to the opQuoteRem opcode, meaning the 2nd
; line should be included with the SUB.
; Move otxStartRem to the start of the next line.
;
LentLoopEx:
	push	[otxStartBlank]		; push otx arg.
	call	OtxBolNext0		;ax points to next opBolxxx if ax
	mov	[otxStartBlank],ax	; doesn't currently point to opBolxxx

	push	[otxStartRem]		; push otx arg.
	call	OtxBolNext0		;ax points to next opBolxxx if ax
	mov	[otxStartRem],ax	; doesn't currently point to opBolxxx
	mov	di,[otxProcDef]
	sub	di,ax			;di = cbMove (otxProcDef - otxStartRem)
	je	NoMove			;brif there is any text to be moved

; move cbMove(di) bytes from module's to proc's text table
; Start by making sure there is room for temp buffer & in proc's text table
;
	push	[oPrsProc]
	call	PrsActivateCP		;make new proc's txt table active

	push	di			;pass cbMove
	call	TxtFree			;make sure there's room in prs txt tbl
	je	JE1_LentEx		;brif out-of-memory error
	call	PrsDeactivate		;make module's txt table active

	;Move pcode from module's text table to bdlScrap	[8]
	;  CALL TxtCopyScrap(otxStartRem, StartOtx, di, TRUE)		[8]
	push	[otxStartRem]		;pass otx for start of move
	SetStartOtx ax			;[39]ax = StartOtx
	push	ax			;copy to start of scrap. 0 offset
	push	di			;pass cbMove
	push	sp			;push TRUE so text will be deleted
					;	from text table
	call	TxtCopyScrap		;move bytes from txdCur to bdlScrap
JE1_LentEx:
DJMP	je	LentEx			;return FALSE if out-of-memory

	push	[oPrsProc]
	call	PrsActivateCP		;make new proc's txt table active

	;note that we already called TxtFree to ensure we have enough memory
	;so no error is possible.
	
	call	TxtInsScrap		;insert bdlScrap in txdCur @ si

	mov	bx,di			;bx = cbMove
	add	bx,si			;bx = offset beyond pcode insertion
	call	TxtInsUpdate		;update line count for inserted lines
DbAssertRel ax,ne,0,CP,<Unexpected OM error 2 in LoadEnterProc>

	;squeeze all $DYNAMIC, $STATIC and DEFxxx statements out
	;of block copied from module.  They are redundant after
	;calling InsertEtDiff and InsertDynDiff
	
	call	SqueezeDefs		;takes parm in si
NoMove:
	call	PrsDeactivate		;make module's txt table active

;Delete redundant synthetic DEFxxx statments generated by last LoadExitProc()
;if no user-generated statements were loaded in between.
;If we didn't do this, each time SOME programs are Ascii loaded and saved
;and they contain one or more blank lines between subs, and so
;they grow by the introduction of these redundant DEFtype statements.
;
	mov	ax,[otxDefEnd]
	cmp	ax,[otxStartBlank]
	jne	NoDeadDefTypes		;brif non-synthetic lines exist
					; between end of synthetic lines and
					; start of leading blank lines
	mov	ax,[otxDefStart]
	mov	[otxStartBlank],ax	;else delete synthetic ones
NoDeadDefTypes:
	;Now delete blank lines that preceeded the comment block.
	mov	ax,[otxStartBlank]
	mov	[otxLastProc],ax
	push	[otxUpdLinks]		;pass otxUpdLinks to UpdateLinks
	push	ax			;pass otxLastProc to UpdateLinks
	;NOTE: parms to UpdateLinks are on stack
	push	ax			;pass start of block to delete
	push	[otxStartRem]		;pass end of block to delete
	call	TxtDelete		;delete blank lines from mrs text table
	call	UpdateLinks		;update linked lists which thread
					; through module's pcode up to where
					; SUB/FUNCTION line was encountered
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.

	;save current def type state so we can bring module
	;back up to date at LoadExitProc (if any DEFxxx stmts occur
	;within the procedure being loaded)
	
	mov	ax,[otxLastProc]	;text offset for new end of module
	mov	bx,dataOFFSET tEtTemp
	call	OtxDefType		;fill tEtTemp with default types
					; at end of module

	mov	[otxUpdLinks],StartOtx	;next UpdateLinks will start at
					; start of new proc
	push	[oPrsProc]
	call	PrsActivateCP		;make new proc's txt table active

	;Tell AsciiMerge that we've changed text tables, and
	;where to insert next line in the procedure's text table
	
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,CB_EMPTY_TEXT - StartOtx ;ax = offset to opEndProg
	mov	[otxNewInsert],ax
	DbAssertRel ax,ne,0,CP,<LoadEnterProc: return value zero> 
LentEx:
	mov	[ps.PS_bdpDst.BDP_cbLogical],0 ;release temp buffer
	or	ax,ax			;set condition codes for caller
cEnd

;*************************************************************
; boolean NEAR LoadExitProc()
; Purpose:
;	Called during ASCII Load when we encounter an END SUB or
;	END FUNCTION statement.
;
; Entry:
;	procedure's text table is active
;
; Exit:
;	If out-of-memory
;	   returns psw.c set
;	else
;	   ax = otx where next stmt should be inserted in module's
;	        text table
;	module's text table is active
;
;*************************************************************
PUBLIC	LoadExitProc
LoadExitProc PROC NEAR
	push	si			;save caller's si
	push	[otxUpdLinks]
	push	[txdCur.TXD_bdlText_cbLogical]
	call	UpdateLinks		;update linked lists which thread
					; through procedure's pcode
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.
	mov	ax,[otxLastProc]
	mov	[otxUpdLinks],ax
	xchg	bx,ax			;bx = otxLastProc
	mov	al,DT_EndProc
	call	TDataEntry		;add entry to table so we can
					;move DATA stmts from prs to mrs
	pushf				;preserve error status
	call	PrsDeactivate		;make module's txt table active
	popf				;recover error status
	je	LexExit 		;return PSW.C if out-of-memory

	;emit DEFxxx statements to module, bringing its state up
	;to the state at the end of the procedure, for BASCOM compatibility.
	;In BASCOM, DEFxxx statements are globally scoped, but in QBI,
	;we want to give the user the feeling that each procedure source
	;window stands independently of the module's source window
	
	mov	si,[txdCur.TXD_bdlText_cbLogical]

	PUSHI	ax,<dataOFFSET tEtTemp>
	PUSHI	ax,<dataOFFSET ps.PS_tEtCur>
	mov	ax,[otxLastProc]	;ax = insertion point
	call	InsertEtDiff
	je	LexExit 		;return PSW.C if out-of-memory

	mov	ax,[otxLastProc]	;ax = insertion point
	mov	dh,[fDynArraysMod]	;dh = old state for module level code
	mov	dl,[fDynArrays]		;dl = new state ($STATIC or $DYNAMIC)
	call	InsertDynDiff
	je	LexExit			;return PSW.C if out-of-memory error

	neg	si			;si = -(old cbLogical)
	add	si,[txdCur.TXD_bdlText_cbLogical]
					;si = txdCur.bdlText.cbLogical-(old)
 					; = #bytes of synthetic pcode emitted
	mov	ax,[otxLastProc]
	cmp	[otxDefEnd],ax
	je	GotDeadCode

	;some module level statements have been emitted since the
	;last synthetically emitted DEFxxx statements, so those
	;DEFxxx statements can't be deleted at the end of AsciiMerge.
	;The reason we try to delete them is to keep the file from
	;growing with every ASCII Save/Load by useless DEFxxx statements.
	
	mov	[otxDefStart],ax
;ax = otxLastProc
;si = #bytes of synthetic pcode generated
GotDeadCode:
	xchg	ax,si			;si = otx of 1st inserted DEFxxx
	xchg	ax,bx			;bx = cbInserted
	add	bx,si			;bx = otx after inserted DEFxxx
	push	bx			;preserve across call
	call	TxtInsUpdate		;update line count for inserted lines
DbAssertRel ax,ne,0,CP,<Unexpected OM error in LoadExitProc>
	pop	ax			;recover oTx after inserted text

	;Tell AsciiMerge that we've changed text tables, and
	;where to insert next line in the module's text table
	
	mov	[otxNewInsert],ax
	mov	[otxDefEnd],ax
	stc				;not out-of-memory
LexExit:
	cmc				;return psw.c set if out of memory
	pop	si			;restore caller's si
	ret
LoadExitProc ENDP


			;***************
			;* ASCII Load  *
			;***************


;*********************************************************************
; ushort NEAR GetLineBd(bx:pbd, cx=cbAppend)
; Purpose:
;	Input an arbitrarily long line into the buffer pointed to by pbd.
;
; Entry:
;	pbd points to destination buffer descriptor
;	cx = number of bytes already in buffer to preserve
;          = 0 if append is not desired
; Exit:
;	returns 0 if got a line, dx = length of line in bytes
;	if out-of-memory,
;	   returns ax = ER_OM
;	if end-of-file
;	   returns UNDEFINED
;	If new line is longer than pbd->cbLogical,
;	   pbd->cbLogical = new length
;	Line is 0-byte terminated
;
; Exceptions:
;	Can cause runtime error (Out of memory, I/O errors)
;
;*********************************************************************
PUBLIC GetALine				;for profiling only
cProc	GetALine,<NEAR>,<si,di>
	parmW	pBufDst			;destination buffer
	parmW	cbMax			;# of free bytes in dest. buffer
cBegin
	;Register usage:
	;	SI contains b$PTRFIL, i.e., ptr to FDB for input channel
	;	DI contains a ptr to the destination buffer
	;	BX contains the offset to next unread char in buffer
	;	CX contains cbMax (input)
	;	DX contains count of chars read in so far

	mov	si,[b$PTRFIL]
	or	si,si			;is the current channel valid?
	jne	GlStart 		;brif so, use it
	call	UpdChanCur		;refresh channel in case of error
	mov	si,[b$PTRFIL]
GlStart:
	FDB_PTR es,si,si		;(ES:)[SI] = *FDB
	mov	bx,FileDB.FD_BUFCNT	;offset to next unread char in FDB
	mov	di,[pBufDst]		;di = start of dest buffer
	sub	dx,dx			;dx = 0 (count of chars read so far)
GlStartLoop:
	mov	cx,[cbMax]
GlLoop:
	cmp	cx,dx
	jbe	J1_GlEol		;brif reached end of dest. buffer

	cmp	bx,FileDB.FD_INBUFCNT	;any unread chars left?
	jz	FillBuff		;  brif not
	mov	al,FileDB.FD_BUFFER[BX] ;fetch char from FDB

	inc	bx			;update offset to next unread char
GlCont1:
	cmp	al,ASC_DBL_QUOTE	;test for ", CR, TAB, LF, CTRL-Z
	jbe	GlQuoteOrLess		;brif TAB, or end-of-line
GlCont:
	mov	[di],al			;put char in dst buffer
	inc	di			;bump dst ptr
	inc	dx			;bump count
	jmp	SHORT GlLoop

J1_GlEol:
	jmp	short GlEol

FillBuff:
	push	dx			;preserve count
	mov	FileDB.FD_BUFCNT,bx	;update based on chars we've read so far
	call	B$IDISK_SINP		;al = next byte from file
	FDB_PTR es			;make sure ES still in FDB segment
	mov	bx,FileDB.FD_BUFCNT	;restore offset to next char in FDB
	pop	dx
	jcxz	GlEof			;brif EOF (cx set by B$IDISK_SINP)
	mov	cx,[cbMax]		;refresh
	jmp	short GlCont1


GlQuote:
	not	[fInQuote]		;toggle "quoted string" state
	jmp	SHORT GlCont

GlQuoteOrLess:
	je	GlQuote
	cmp	al,ASC_EOF		;test for CR, TAB, LF, CTRL-Z
	ja	GlCont			;brif not TAB or end-of-line
	jne	GlCrOrLess		;brif Not CtrlZ
	or	dx,dx			;was CtrlZ at beginning of line?
	je	GlEof			;brif so - treat as EOF
					;fall thru and loop to GlCont
GlCrOrLess:
	cmp	al,ASC_CR		;test for carriage return
	je	GlLoop			;brif carriage return - ignore
	cmp	al,ASC_LF		;test for line feed
	je	GlEol			;brif end-of-line
	cmp	al,ASC_TAB		;test for TAB
	jne	GlCont			;brif not TAB
	cmp	[fInQuote],0
	jne	GlCont			;brif within "quoted string"

	;expand TABs to spaces as follows:
	; emit (tabs - (col MOD tabs)) spaces
	; where col is current column (0..n) and
	;       tabs is #columns per tab stop (from user interface)
	; if buffer gets full before done expanding tabs, don't
	; worry about continuing into next buffer.
	
	or	[mrsCur.MRS_flags2],FM2_EntabSource ;remember to reentab at
						    ;ascii save time
	push	dx			;save current column
	xchg	ax,dx			;ax = current column
	cwd				;DX:AX = current column
	mov	cx,[tabStops]		;gets value from user interface

	; User interface should ensure that 0 is not a valid value
	; for tabstops.
	;
DbAssertRel	cx,nz,0,CP,<tab stops = 0 in ascii load>
	div	cx			;dx = remainder = modulus
	sub	cx,dx			;cx = # spaces to emit
	pop	dx			;restore current column
	mov	al,' '			;for now, map TAB to space
TabLoop:
	mov	[di],al
	inc	di			;bump dst ptr
	inc	dx			;bump count
	cmp	[cbMax],dx
	jbe	GlEol			;brif reached end-of-buffer
	loop	TabLoop
	jmp	GlStartLoop

;Reached end-of-file while reading a line
GlEof:
	or	dx,dx
	jne	GlEol			;brif line had valid data before EOF
	dec	dx			;return -1 for EOF

;Reached end-of-line while reading a line
GlEol:
	mov	FileDB.FD_BUFCNT,bx	;update based on chars we read
	xchg	ax,dx			;return byte count in ax
cEnd

CB_LINE EQU 80
cProc	GetLineBd,<PUBLIC,NEAR>,<si,di>
cBegin
	mov	[fInQuote],0		;toggle "quoted string" state
	mov	si,bx			;si points to buffer descriptor
	mov	di,cx			;di = cbLogical


;The following loop only executes 1 iteration for lines less than
;or equal to CB_LINE bytes in length
;
GlBdLoop:
	;make sure there's room for at least CB_LINE+1 more bytes
	push	si			;pass pointer to buffer descriptor
	lea	ax,[di+CB_LINE+1]	;ax = number bytes we need
	push	ax
	call	BdCheckFree
	or	ax,ax
	mov	ax,ER_OM		;prepare for out-of-memory error
	je	GlBdExit		;brif out-of-memory error
	mov	ax,[si.BD_pb]		;ax points to start of result buffer
	add	ax,di			;add cbLogical
	push	ax			;pass ptr to destination
	mov	ax,[si.BD_cbPhysical]	;ax = size of buffer
	sub	ax,di			;ax = number of free bytes in buffer
	dec	ax			;leave room for 0-byte terminator
	push	ax			;pass maximum byte count
	call	GetALine		;read bytes from the file, stop at CR
	cmp	ax,UNDEFINED		;test for end-of-file
	jne	GotData			;brif not end-of-file
	or	di,di
	jne	GotData1		;brif we've already got part of a line
	jmp	SHORT GlBdExit		;return end-of-file indication
					; ax = UNDEFINED (eof)

GotData:
	add	di,ax			;di = total # bytes read so far
GotData1:
	mov	ax,[si.BD_cbPhysical]
	dec	ax
	cmp	ax,di
	je	GlBdLoop		;brif read stopped because of end-of-buf
	mov	bx,[si.BD_pb]
	mov	BYTE PTR [bx][di],0	;zero terminate the line
	mov	dx,di			;return line length in dx
	inc	di			;include 0-byte terminator in count
	cmp	[si.BD_cbLogical],di
	jae	NotNewHigh
	mov	[si.BD_cbLogical],di	;cbLogical = length of longest
					;line read into this bd
NotNewHigh:
	sub	ax,ax			;not end-of-file return code
GlBdExit:
cEnd

;Near gateway to StatusMsgFar - display msg on status line
PUBLIC	StatusMsgCP, StatusMsg0CP
StatusMsg0CP PROC NEAR
	mov	ax,MSG_StatusEdit	; display edit window status line
StatusMsg0CP ENDP			; fall into StatusMsgCP

StatusMsgCP PROC NEAR
	cCall	StatusMsgFar,<ax>
	ret
StatusMsgCP ENDP

;*************************************************************
; ushort NEAR AsciiMerge(ax:otxInsert)
;
; Purpose:
;	Merge the contents of an ASCII source file into the current
;	text table.
;
; Entry:
;	ax = otxInsert = place to insert text
;	grs.oMrsCur, grs.oPrsCur have their usual meaning
;	Current input channel has been opened to file to be merged.
;	cAsciiLoadsActive == 1 if this file is being loaded/merged,
;		           > 1 if this file is being $INCLUDEd
;
; Exit:
;	grs.fDirect = FALSE
;	al = 0 if no error, else Standard BASIC error code (i.e. ER_xxx)
;	ps.bdpSrc is used
;
; Exceptions:
;	Can cause runtime error (Out of memory, I/O errors)
;
;*************************************************************
DbPub	AsciiMerge
cProc	AsciiMerge,<NEAR>,<si,di>
cBegin
	DbChk	Otx,ax			
	mov	si,ax			;ax = si = otxInsert
	sub	di,di			;initial line count = 0
	inc	[cAsciiLoadsActive]
	cmp	[cAsciiLoadsActive],1
	jne	AmLoop

	;this isn't a recursive $INCLUDE call, init static variables
	mov	[otxUpdLinks],ax
	mov	[otxDefEnd],ax
	mov	[otxDefStart],ax
	mov	[otxLastProc],ax
	sub	ax,ax
	mov	[fDynArrays],al		;default to $STATIC
	mov	[fMergeInSub],al
	dec	ax			;ax = UNDEFINED
	mov	[otxNewInsert],ax
	test	[txdCur.TXD_flags],FTX_mrs
	jne	NotMergingInSub
	mov	[fMergeInSub],al	;set fMergInSub non-zero
NotMergingInSub:
	test	[mrsCur.MRS_flags2],FM2_NoPcode
	jne	NoStatusMsg		;dont display "precompiling" if document
	mov	ax,-MSG_Loading		;display Loading msg in intense video
	call	StatusMsgCP		; to tell user we're loading
NoStatusMsg:

	;init default ps.tEtCur[] (default type array)
	mov	ax,si			;ax = text offset
	call	OtxDefTypeCur

;Get source lines and append them until EOF
AmLoop:
	mov	bx,dataOFFSET ps.PS_bdpSrc
	sub	cx,cx			;don't append, just fill buffer
	call	GetLineBd
	inc	ax			;test for UNDEFINED
	je	AmLoopExit		;brif got End-of-file (with ax=0)
	dec	ax			;ax = error code
	jne	AmLoopExit		;brif out-of-memory error

	test	di,1Fh			;update status line every 32 lines
	jne	NotYet			; just to tell user we're not hung
	cCall	UpdStatusLn,<di>
NotYet:
	inc	di			;bump line count
	push	[txdCur.TXD_bdlText_cbLogical]
					;save current size of text table

	test	[mrsCur.MRS_flags2],FM2_NoPcode ; Document file?
	je	@F			;brif not, insert into text table
	push	WORD PTR [mrsCur.MRS_pDocumentBuf] ; ptr to buffer info
	PUSHI	ax,<dataOFFSET ps.PS_bdpSrc.BD_pb> ; ptr to ptr to text
	call	AppendLineBuf		;Append line to document buffer
	and	ax, ER_OM		; convert 0, -1 to 0, ER_OM
	jmp	short InsertDone	
@@:					
	push	si			;insert the line in the text table
	push	si
	sub	ax,ax			;clear fNoInsert flag
	push	ax			;We have text to insert
	call	TxtChange		;al = error code

InsertDone:				
	pop	cx			;cx = old size of text table
	cmp	al,ER_OM
	je	AmLoopExit		;brif out-of-memory (only fatal error)
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,cx			;ax = size of inserted line
	add	si,ax			;update insertion point
	cmp	[otxNewInsert],UNDEFINED
	je	AmLoop			;brif we're still in same text table

	;We just got a SUB, FUNCTION, END SUB, or END FUNCTION statement
	;and as a result, have switched text tables
	
	mov	si,[otxNewInsert]	;si = new insertion point
	mov	[otxNewInsert],UNDEFINED
	jmp	SHORT AmLoop

;We are done loading this file.
;[al] = 0 if we've reached end-of-file.
;[al] = error code if fatal error occurred while loading.
;	Fatal errors (like out-of-memory) cause mrs to be discarded
;	unless they occurred within an INCLUDE file.
;
AmLoopExit:
	dec	[cAsciiLoadsActive]
	jne	StillLoading		;brif we're still in nested INCLUDE

	;this isn't a recursive $INCLUDE call
	push	ax			;save error code

	call	StatusMsg0CP		;tell user interface we're done loading

	;Now delete any redundant DEFxxx statements which were synthetically
	;generated by LoadExitProc.
	
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,CB_EMPTY_TEXT-StartOtx 
	cmp	ax,[otxDefEnd]
	je	GotRedundant		;brif module-level-code couldn't have
					; been inserted after last loaded proc
	dec	ax			;don't treat a blank line as significant
	dec	ax			; only a blank line could be 2 bytes
	cmp	ax,[otxDefEnd]
	jne	NoRedundant		;brif module-level-code was inserted
					; after last loaded procedure
GotRedundant:
	push	[otxDefStart]
	push	ax			;pass otxDefEnd
	call	TxtDelete
	mov	si,[otxDefStart]	;update links up to deleted text
NoRedundant:
	;update linked lists which thread through pcode
	
	push	[otxUpdLinks]
	push	si
	call	UpdateLinks
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.

	pop	ax			;restore al = error code

;al = fatal error code (or 0)
StillLoading:
cEnd

;*************************************************************
; MakFilename
; Purpose:
;	Fill a buffer with <filename>.MAK
; Entry:
;	bx points to string descriptor for source of filename
;	di points to destination (must be FILNAML bytes long)
;	si points to destination string descriptor
; Exit:
;	ax = 0, or error code
;	es = ds = dgroup
;	buffer pointed to by di contains 0-terminated filename.MAK
;	si.pb points to 1st byte of destination buffer
;
;	Flags set on value in ax
;*************************************************************
cProc	MakFilename,<PUBLIC,NEAR>,<di>
cBegin
	call	NormFilename		;Normalize path of filename and add
					; .bas extension 
					; if filename doesn't already have ext.
					;We now know that the filename has
					; an extension, either the one supplied
					; by user or .BAS
	jne	BadMakFileName		;brif error - AX = error code

	add	di,[si.SD_cb]		;di points to 0-byte terminator
;search backward for start of extension
OMakLoop:
	cmp	di,[si.SD_pb]
	jbe	OMakDone		;brif got illegal filename like "/"
	dec	[si.SD_cb]
	dec	di
	cmp	BYTE PTR [di],'.'
	jne	OMakLoop		;brif haven't found extention yet
OMakDone:
	mov	WORD PTR [di+1],'AM'	;append "MAK" extension
	mov	WORD PTR [di+3],'K'	;put K and 0-terminator in buf
	add	[si.SD_cb],4
BadMakFileName:
	or	ax,ax			;set flags
cEnd

;*************************************************************
; OpenChan
; Purpose:
;	Call BASIC Runtime to open a named file.
; Entry:
;	dx = open mode
;	si points to string descriptor for filename
; Exit:
;	[chanCur] = channel #
;	al = standard error code if error (0 if not)
;	condition codes set based on value in al
; Exceptions:
;	assumes caller has called SetRtTrap to trap runtime errors
;	like File not found, etc.
;
;*************************************************************
PUBLIC	OpenChan
OpenChan PROC NEAR

	call	RtPushHandler		;save caller's runtime error handler
					; (NOTE: alters stack pointer)
					; (preserves dx)
	mov	ax,CPOFFSET OcExit	;if any runtime errors occur,
	call	RtSetTrap		; branch to OcExit with sp,di =
					; current values  (preserves dx)
	push	dx			;save open mode
	call	B$FREF			;ax = free channel number

	pop	dx			;dx = open mode
	push	ax			;preserve channel #
	push	si			;pass &sdFilenameNew
	push	ax			;pass channel
	sub	ax,ax
	mov	[chanCur],ax		;so CloseChan won't be called
					; if error in B$OPEN
	dec	ax			;ax = UNDEFINED
	push	ax			;no record size specified
	push	dx			;pass open mode
	call	B$OPEN			;open the file. errors trapped OcExit
	inc	[cChansOpen]		;no error, bump # opened channels
	pop	[chanCur]		;save channel
	call	UpdChanCur		;Tell runtime to use [chanCur] for
					; following I/O calls, test device type
	or	al,al			;is this a block device?
	mov	al,0
	jns	OcExit			;brif it is - no error
	mov	al,MSG_NotBlock		;"Can't load from non-block device"
;al = error code (0 if no error)
OcExit:
	call	RtPopHandler		;restore caller's runtime error handler
					; (saved on stack by RtPushHandler)
					; (preserves ax)
	or	al,al			;set condition codes for caller
	ret
OpenChan ENDP


;*************************************************************
; CloseChan/CloseMfh (EB)
; Purpose:
;	Call BASIC Runtime/OMEGA to close a file
; Entry:
;	[chanCur] = the channel-#/module-file-handle to be closed
;
;*************************************************************
cProc	CloseChan,<PUBLIC,NEAR>
cBegin
	mov	cx,[chanCur]
	jcxz	CcNeverOpened		;brif error before got file opened
	sub	ax,ax
	mov	[chanCur],ax		;remember channel is closed

	dec	[cChansOpen]		; assume close will work
	push	cx			;pass channel number of current load
	inc	ax			;ax = 1
	push	ax			;number of channels on stack
	call	B$CLOS			;close current file - no error possible
					; EXCEPT int 24's.
CcNeverOpened:
cEnd

;***
;UpdChanCur
;
;Purpose:
;	Near interface that uses the global 'chanCur' to make sure b$ptrfil
;	is updated to reflect the current input/output channel. Should be
;	called prior to using save/load I/O whenever the channel is changed,
;	or ANY heap movement could have occured.
;Entry:
;	chanCur assumed to be set up.
;Exit:
;	AL = the device number (as returned by B$CHAN).
;	The runtime b$ptrfil is updated.
;Exceptions:
;	Same as B$CHAN
;*******************************************************************************
PUBLIC	UpdChanCur
UpdChanCur	PROC NEAR
	push	[chanCur]
	call	B$CHAN			;ensure current output channel correct
	ret
UpdChanCur	ENDP


;*******************************************************************************
;ModulePermanent
;Purpose:
;	Set mrsCur.flags fTemporary bit to FALSE.
;	This is called via ForEachCP at the successful conclusion of a LOAD
;	for each text table (module and procedures) in every module.
;Entry:
;	none.
;Exit:
;	AX = TRUE (for ForEachCP)
;
;*******************************************************************************
ProcPerm PROC NEAR
	call	ClrBpTxt		;clear all breakpoints in this
					; text table

	;delete all Watch expressions in this text table
	or	[flagsTM],FTM_WatchPcode ;assume we have watch pcode
	call	OtxEndProg		;ax = otx to Watch pcode
	inc	ax			;skip opEndProg
	inc	ax
	push	ax			;pass start of block to delete
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
.erre	CB_EMPTY_TEXT - 4 EQ StartOtx
	dec	ax			;don't count opEot
	dec	ax
	push	ax			;pass end of block to delete
	call	TxtDelete

	call	TblReInclude
	mov	ax,sp			;return non-zero for ForEachCP
ProcPerm ENDP

ModulePermanent	PROC NEAR
	test	[mrsCur.MRS_flags],FM_TEMPORARY
	je	MpExit			;brif this isn't one of the modules
					; we just loaded
	and	[mrsCur.MRS_flags],NOT FM_TEMPORARY
	and	[mrsCur.MRS_flags2],NOT (FM2_Modified or FM2_ReInclude) 
					;reset modified and temp flags

	test	[mrsCur.MRS_flags3],FM3_Translated ; module binary xlated?
	jz	NotTranslated		; brif not -- FM2_Modified stays 0
	and	[mrsCur.MRS_flags3],NOT FM3_Translated	; reset temp flag
	or	[mrsCur.MRS_flags2],FM2_Modified	; mark as modified
					; so it will be saved in new format
NotTranslated:				

	test	[mrsCur.MRS_flags2],FM2_AsciiLoaded	
	jnz	MpExit			;brif module was not binary loaded

	;re-include all $INCLUDE files in this binary module
	;If we did it right after calling BinaryLoad, TxtChange would
	;have screwed up because it would think a LOAD was still active.
	
	mov	al,FE_CallMrs+FE_PcodePrs+FE_SaveRs
	mov	bx,OFFSET CP:ProcPerm
	call	ForEachCP
MpExit:
	mov	ax,sp			;return TRUE for ForEach...
	ret
ModulePermanent	ENDP


;**********************************************************************
; TxtGrowPsSrcEmScratch (pBd, cbNew)
; Purpose:
;	Called whenever we need to grow ps.bdpSrc or bdEmScratch.  The
;	editmgr REQUIRES that the logical size of these buffers are
;	the same.  This routine takes a bd and checks to see if the passed
;	bd is either ps.bdpSrc or bdEmScratch.	If so, both bds are grown
;	to be the same size.  If the bd is not either of these then we just
;	call BdRealloc.  If we get OM while trying to grow either ps.bdpSrc
;	or bdEmScratch, we will trim the cbLogical
;	routine is a nop.
;
;	Added with revision vision [68].
;
; Entry:
;	pBd - ptr to bd.
;	cbNew - new size of Bd
; Exit:
;	AX - 0 if OM error code.
;
;**********************************************************************
cProc	TxtGrowPsSrcEmScratch,<PUBLIC,FAR>,<si,di>
parmW	pBd
parmW	cbNew
cBegin
	mov	si,dataOffset bdEmScratch
	mov	di,dataOffset ps.PS_bdpSrc
	push	pBd			;pass pbdDst to BdRealloc
	push	cbNew			;pass cbNew to BdRealloc
	call	BdRealloc
	or	ax,ax
	je	TGPSES_OM		;brif out-of-memory

	mov	bx,di			;assume ps.bdpSrc needs grown too
	cmp	pBd,si			;is this bdEmScratch?
	je	GrowSpecBuf		;brif so - grow ps.bdpSrc too
	mov	bx,si			;assume bdEmScratch should grow
	cmp	pBd,di			;is this ps.bdpSrc?
	jne	TGPSES_X		;brif not - nothing special to do

; We get here if we have to grow either ps.bdpSrc or bdEmScratch.  These
; two buffers must grow together for the edit mgr.


GrowSpecBuf:
	push	bx
	push	cbNew
	call	BdRealloc		;realloc other buffer too
	or	ax,ax
	je	TGPSES_OM		;brif OM error

TGPSES_X:
DbAssertRel ps.PS_bdpSrc.BDP_cbLogical,e,bdEmScratch.BD_cbLogical,CP,<TxtGrowPsSrcEmScratch:bdEmScratch and ps.bdpSrc not same size>
cEnd

;if we get an out of memory while growing ps.bdpSrc or bdEmScratch.  Trim them
;both back to the smallest cbLogical.

TGPSES_OM:
	cmp	pBd,si			;is this bdEmScratch?
	je	TrimCbLogical		;brif so - trim back size of both
	cmp	pBd,di			;is this ps.bdpSrc?
	jne	TGPSES_X		;brif not - nothing special to do

TrimCbLogical:
	mov	bx,[si].BD_cbLogical	;get size of bdEmScratch
	cmp	bx,[di].BD_cbLogical
	jb	TrimPs			;trim Ps since it is larger
	mov	bx,[di].BD_cbLogical	;get size of ps.bdpSrc
	mov	[si].BD_cbLogical,bx	;set new size of bdEmScratch
	jmp	short TGPSES_X

TrimPs:
	mov	[di].BD_cbLogical,bx	;set new size of ps.bdpSrc
	jmp	short TGPSES_X


STKCHK_LoadFile EQU 350d ;actually 208d, add 142 for maintenance/uncertainty
;
;STKCHK_ToLoadFile is the number of bytes of stack space needed to get from
; UserInterface (where caller ensures STACK_CHECK bytes exist between sp
; and b$pend) and LoadFile().
;   UserInterface->LoadFile (188d) ([67] 174d)
;
STKCHK_ToLoadFile EQU 400d ;actually 188, add 212 for maintenance/uncertainty

;*************************************************************
; ushort LoadFile(psdFilename, otxInsert)
; Purpose:
;	This is called by LOAD executor, File/Load&Merge menu items,
;	and recursively from TxtChange in response to $INCLUDE.
;	If the filename has no extension, .BAS is appended to
;	a copy of psdFilename.  The copy is then 0-byte terminated.
;	It opens the specified file and loads it, optionally doing
;	a NEW.  Based on 1st byte in file, does an ASCII or BINARY load.
;	If a runtime error is encountered at any INCLUDE level,
;	this function backs all the way out, returning directly to
;	the caller for the 1st level of INCLUDE via RtSetTrap.
;
; Entry:
;	psdFilename points to string descriptor for filename to be loaded.
;	   (the filename itself need not be 0-byte terminated, and
;	    psdFilename.cb MUST not include any 0-byte terminator)
;	otxInsert = LF_NewProg if file may be ASCII or BINARY and if
;	            a NEW is to be performed before the load
;	          = LF_NewModule if file may be ASCII or BINARY and if
;	            a NEW is NOT to be performed before the load
;	          = LF_NewDoc if file is ASCII document
;	          = LF_ViewIncl if file is $INCLUDE file which is not
;	 	    to be loaded in-place, but into another mrs so user
;		    can edit it.
;	          = text offset into current module where text is to be inserted
;	            for MERGE or INCLUDE.  File must be ASCII format for this.
;	            For example, if otxInsert == 0, file's content will be
;	            inserted before text offset 0.
;		    It is important to call TxtDescan before computing
;		    the text offset for the insert.
;	stFileName [only used in EB] Fully qualified FileName in st format.
;	OpenMode = [only used in EB] Specifies whether the input file is to
;		    be loaded from the active database, from a file, or 
;		    whether this is unknown. This parameter is just passed
;		    through to OpenChan.
;
; Exit:
;	ax = Standard BASIC error code (i.e. ER_xxx) if error occurred.
;	   Possible errors include Out-of-memory (ER_OM)
;	   file I/O errors, File-not-found (ER_FNF), Duplicate Mrs
;	   (MSG_DupMrs), Duplicate Prs (MSG_DupPrs)
;	For all errors detected by LoadFile, txtErr.oRs is set to UNDEFINED,
;	   meaning no cursor positioning will take place when error is reported.
;	   Errors which can be represented with an opReParse are not reported
;	   until the user attempts to RUN the program, at which time, TxtDirect
;	   will re-parse and report them.
;	If called by an executor, (i.e. ExStRunFile) and an untrappable error
;	   occurred, grs.otxCur is set to 2, in which case, the module with
;	   the error is grs.GRS_oRsCur and the text offset is grs.otxCur.
;	If called by an executor, and a trappable error occurred,
;	   grs.otxCur is not altered, and the module with the error
;	   is grs.GRS_oRsCur and the text offset is grs.otxCur.
;	   
;	txtErr structure is filled in with error info
;	ps.bdpSrc is used.
;	rsNew is set by MrsMake for all cases but Merge (this tells the
;	  user interface to show this rs in a list window)
;	Preserves grs.fDirect in all cases (needed at least by exStRunFile
;	  when entered in direct mode and error (like file not found) occurs)
;	Preserve's caller's runtime-error-trap handler (if any) and [chanCur]
;
;*************************************************************
J1_RtErrOmStack:
	EXTRN	RtErrOmStack:NEAR
	jmp	RtErrOmStack

cProc	LoadFile,<PUBLIC,FAR>,<si,di>
	parmW	psdFilename
	parmW	otxInsert
	localW	oRsSave
	localW	otxCurSave
cBegin
	DbAssertRel [b$CurFrame],a,bp,CP,<LoadFile: b$CurFrame .GE. bp>
	;otherwise, runtime error recovery fails

	push	WORD PTR ([grs.GRS_fDirect]) ;save caller's fDirect
	push	[chanCur]		;save caller's current chan
					; (for recursive calls)
	call	RtPushHandler		;save caller's runtime error handler
					; (NOTE: alters stack pointer)
	mov	ax,CPOFFSET LfDone	;if any runtime errors occur,
	call	RtSetTrap		; branch to LfDone with sp,di =
					; current values

	;Runtime ensures we never enter the user interface with less
	;than STACK_CHECK bytes free.  Make sure that STACK_CHECK is big enough
	;to satisfy parser's requirements.
	
DbAssertRel <STKCHK_ToLoadFile+STKCHK_LoadFile>,b,STACK_CHECK,CP,<LoadFile stk>
	mov	ax,[b$pend]
	add	ax,STKCHK_LoadFile
	cmp	sp,ax
	jbe	J1_RtErrOmStack		;brif almost out of stack space

	mov	ax,[grs.GRS_oRsCur]
	mov	[oRsSave],ax

	mov	ax,[grs.GRS_otxCur]
	mov	[otxCurSave],ax

	sub	ax,ax
	mov	[chanCur],ax		;in case we don't get file opened
					; before we branch to LfDone (error)
	SetfDirect al			;we're dealing with text tables
					;       not direct stmt buffer
	dec	ax			;ax = UNDEFINED
	FLoadActive
	jne	Not1stLoad		;brif we're being called for
					; recursive load ($INCLUDE or
					; from LoadMakFile)
	mov	[oRsDupErr],ax		;so we can tell if any Duplicate
					; Prs or Mrs errors occur during
					; load

	mov	[cbAftMerge],0
	test	[txdCur.TXD_flags],FTX_mrs
	je	LfNotMerge		;brif we're in a SUB or FUNCTION
	mov	ax,[otxInsert]
	cmp	ax,LF_NewDoc
	jae	LfNotMerge		;brif we're not MERGEing a file
	sub	ax,[txdCur.TXD_bdlText_cbLogical]
	neg	ax			;ax = #bytes beyond insertion point
	mov	[cbAftMerge],ax

LfNotMerge:
Not1stLoad:

	mov	bx,[psdFilename]	;bx points to source filename sd
	push	ss			
	pop	es			; assure es==dgroup

	cmp	[fLoadInclude],NULL	; loading include file?
	jz	SkipSearch		; no, go process as usual

	mov	al,ER_ADF		; "advanced feature unavailable"
	jmp	short J1_LfDone 	; exit
SkipSearch:				
	mov	di,dataOFFSET NormFname
	mov	si,dataOFFSET sdNormFname

	call	NormFilename		;normalize path of filename and
					; append .bas to sd pointed to by si
	jne	J1_LfDone		;brif bad filename

Lf_Cont:				
	cmp	[fInitialized],FALSE
	je	InInit			;if we're initializing we want to
					;create the mrs for the module even
					;if the file isn't found.

;Before we toss the current text table (via NewStmt), make sure
;file exists, so we can report an error.  Note: this doesn't cover
;case where one of the modules in a multi-module load was not found.
;It is VERY expensive to handle the multi-module case, and
;handling the single module case lets the user test any error
;trapping code the same way as it would work in the compiler,
;since in the compiler, even a multi-module program consists of
;a single EXE file.  Handling multi-modules would be of little
;value if we didn't handle missing $INCLUDE files, which
;would be more than prohibitive.
;
	cCall	FileExists,<di>		;see if file [di] found
	or	ax,ax
	mov	al,ER_FNF
	jne	InInit
J1_LfDone:
	jmp	LfDone			;brif couldn't find filename

InInit:
	;Any errors encountered after this point are untrappable.
	call	CantCont		;loading/re-including a file prevents
					; CONTinue (because we can't back out
					; of it after the n'th line)
					; NOTE: CantCont closes all files
					; if CONT was possible, so this
					; must be called before OpenChan.
					; It also calls _BRUNINI which
					; shows and clears the user screen.
	mov	ax,[otxInsert]
	.errnz	LF_NewDoc - 0FFFCh
	cmp	ax,LF_NewDoc
	jb	LoadFile_Cont		;brif doing a MERGE or $INCLUDE
	.errnz	LF_NewProg - 0FFFFH
DbAssertRelB [cChansOpen],e,0,CP,<NewStmt called for recursive LoadFile()>
	call	NewStmt			;erase content of this module
	call	StatusMsg0CP		;NewStmt erases function key line (25)
					; which is same as status line
	mov	[otxCurSave],2		;so we will position cursor @
					; top of new window if ExStRunFile
					; calls RtErrorCODE
	mov	[oRsSave],UNDEFINED	;remember that we can't restore
					; the caller's oRs for error
					; recovery.  NewStmt also sets
					; grs.otxCont to UNDEFINED,
					; for runtime error recovery.
NoNewStmt:
	cCall	OgNamOfPsd,<si>		; get ogNam of given filename
	or	ax,ax			; OM error return?
	jnz	GotOgNam		;   brif not

	mov	al,ER_OM		
	jmp	SHORT J1_LfDone

GotOgNam:				
	push	ax			; parm to MrsMake
	mov	cx,FM_TEMPORARY + (100h * FM2_File) 
					;set TEMP in case LOAD fails somewhere
					;so we'll know to discard the mrs
	mov	ax,[otxInsert]
	cmp	ax,LF_ViewIncl
	jne	NotIncl
	or	ch,FM2_Include		;so we'll know to do a ReInclude
					;if/when this file gets saved.
NotIncl:
	cmp	ax,LF_NewDoc
	jne	NotDoc			;brif not loading a Document file
	or	ch,FM2_NoPcode
NotDoc:
	push	cx			;pass flags
	call	MrsMake			;create new mrs for this file
	or	ax,ax
	jne	J1_LfDone		;brif error, al = error code
	or	[mrsCur.MRS_flags3], FM3_NotFound 
	call	ModuleRudeEdit
LoadFile_Cont:
	push	[rsNew] 		;DoDrawDebugScr resets rsNew,
					; which was set by MrsMake.
					; We need to preserve this so correct
					; rs is active after MakeExe, or
					; MakeLib.
	call	DoDrawDebugScrFar	;so screen isn't blank with just
					; title bar for too long during a
					; binary load. (It was cleared by
					; CantCont above, and title may
					; have changed by MrsMake above)

	pop	[rsNew]
	;If we could assume DOS 3.0 or greater, (we can't yet) we could set
	;dx to (ACCESS_READ OR LOCK_WRITE) SHL 8 OR MD_SQI
	
	fLoadActive			
	jne	@F			
	call	TDataStart		;init for movement of DATA stmts
					; from prs(s) to mrs
	jne	LfDone			;[37] brif no error occurred
@@:					

	mov	dx,MD_SQI
	call	OpenChan		;Sets [chanCur] which tells LfDone to
					; close the file. Tells AsciiLoad/Binary
					; Load to use this channel
	jne	LfDone			;brif error
	and	[mrsCur.MRS_flags3],NOT FM3_NotFound 
	call	B$IDISK_SINP		;al = 1st byte from file
					; errors trapped @ LfDone
	jcxz	Empty_File		;brif trying to load an empty file
	push	ax			;save 1st char
	call	B$IDISK_BAKC		;put the char back in the buffer
	pop	ax			;restore al = 1st char of file
	cmp	al,BINSAV_1stByte	
	jne	DoAsciiLoad		;brif not binsav flag
	call	fEditorActive		; is this the Editor?
	jnz	DoAsciiLoad		; brif so, no binary files
	mov	al,ER_BFM		; otherwise, it is an error
	jmp	LfDone			

Empty_File:
	xchg	ax,cx			;ax = 0 == no error
	jmp	SHORT LfDone

DoAsciiLoad:
	mov	ax,[otxInsert]		;ax = line where text is to be inserted
	cmp	ax,LF_NewDoc
	jb	DoMerge			;brif doing a MERGE or $INCLUDE
	or	[mrsCur.MRS_flags2],FM2_AsciiLoaded
	SetStartOtx ax			;start load at offset 0
DoMerge:
	
DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<LoadFile: bad scan state>
	call	AsciiMerge		;merge file at offset [ax]
					;Note: AsciiLoad can make recursive
					; calls to LoadFile()
					; some errors trapped @ LfDone

;al = error code (0 if no error)
LfDone:
	mov	[txtErr.TXER_oRs],UNDEFINED
					;don't try to position cursor to
					; offending stmt for errors caused
					; by LoadFile.  Values of txtErr.otx
					; and txtErr.oSrc are unimportant
					; if txtErr.oRs = UNDEFINED
	cmp	al,ER_FNF		;test for FileNotFound
	jne	NotInInit		;brif not
	cmp	[fInitialized],FALSE
	jne	NotInInit
	FLoadActive
	jne	NotInInit
	cmp	[cInclNest],0		;test for INCLUDE file not found
	jne	NotInInit		; brif include file not found
	test	[cmdSwitches],CMD_SW_RUN ;Want to Run program, or just load it?
	jne	NotInInit		;brif /RUN <filename>
	and	[mrsCur.MRS_flags3],NOT FM3_NotFound 
	sub	ax,ax			;qb <filename> when filename not
					; found should just create file
;al = error code (0 if no error)
NotInInit:
	sub	ah,ah			;ax = result
	xchg	si,ax			;si = result
	call	CloseChan		;close [chanCur]
					; don't care about int 24 errors
					; here, since we were reading
	FLoadActive
	jne	LfExit1			;brif not done with multi-module load
					; or recursive $INCLUDE
	call	TDataEnd		;move DATA stmts from prs(s) to mrs
	je	NoDataMoveErr
	mov	si,ER_OM		;return out-of-memory error
NoDataMoveErr:
	call	LfDupRs			;if duplicate mrs or prs encountered
					; during load, set si=errcode
					; if dup mrs, (sets txtErr.oRs),
					; it will be reset to UNDEFINED if mrs
					; is discarded.
	or	si,si			;test result
	je	MakeMods_Perm		; brif no error

	or	[flagsTm],FTM_PrsDefDeleted
					;make sure discarded PRSs are freed
	call	MrsDeactivate		; required so NextMrsFile starts
					; at the beginning
TempMrs_Discard_Loop:			
	call	far ptr NextMrsFile	; activate next file mrs
	inc	ax			; no more file mrs's?
	jz	@F			; brif so - exit loop

	test	[mrsCur.MRS_flags],FM_TEMPORARY
	je	TempMrs_Discard_Loop

	mov	ax,[txtErr.TXER_oRs]
	cmp	ax,[grs.GRS_oMrsCur]
	je	DmNotErr

	mov	[txtErr.TXER_oRs],UNDEFINED
					;don't try to position cursor to
					; offending stmt for error.
DmNotErr:
	call	MrsDiscard
	jmp	TempMrs_Discard_Loop	

MakeMods_Perm:				
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs+FE_TextMrs 
	mov	bx,OFFSET CP:ModulePermanent ;reset 'fTemporary' in each mrs
	call	ForEachCP
@@:					

; We call ChkAllUndefPrsSaveRs here to make sure that FTM_PrsDefDeleted
; flag is reset.  If this flag didn't get reset, then the next PRS
; that is created would accidentally be freed in TxtChange.  The case
; where this flag doesn't get reset is when we don't find any Temp mrs's.

	call	ChkAllUndefPrsSaveRs	;search for new defining
					;references for Prs entries
					;which had their "defining"
					;reference deleted.

LfExit1:
	mov	ax,[oRsSave]
	inc	ax
	je	LfExit2			;brif entry mrs has been discarded
	dec	ax			;ax = oRs to restore
	push	ax
	call	RsActivateCP		;activate it (for ExStRun)
LfExit2:
	mov	ax,[grs.GRS_oRsCur]
	inc	ax			;test for UNDEFINED
	jne	LfExit3			;brif not - we need an oMrsCur
	DbAssertRel [grs.GRS_oMrsMain],ne,UNDEFINED,CP,<LoadFile: no oMrsMain>
	mov	ax,[grs.GRS_oMrsMain]
	mov	[rsNew],ax		;if UserInterface has not yet been
					; called, we need rsNew non-zero
					; to cause windows to be initialized
	push	ax
	call	RsActivateCP		;activate oRsMain
LfExit3:
	mov	ax,[otxCurSave]
	mov	[grs.GRS_otxCur],ax	;restore caller's grs.otxCur (or
					; set it to 2 if NewStmt was done)
					; This is done for ExStRunFile.
	call	RtPopHandler		;restore caller's runtime error handler
					; (saved on stack by RtPushHandler)
	pop	[chanCur]
	cmp	[chanCur],0		;do we need to update channel for
	jz	NoChanUpd		;recursive opens?
	call	UpdChanCur		;Update channel
NoChanUpd:

	; The user interface needs the source and scratch buffers to be the
	; same size.  If the scratch is smaller, then horizontal scrolling
	; (like CTRL-PGDN) could cause garbage characters to be displayed.
	; This does not cause any data or code corruption, but is visually
	; disconcerting.  Since this is only a visual bug, special out-of-
	; memory handling is not necessary.

	PUSHI	ax,<dataOFFSET bdEMScratch>;pass Scratch buffer
	mov	ax,[ps.PS_bdpSrc.BDP_cbLogical] ; get current size
	push	ax
	call	TxtGrowPsSrcEmScratch	;grow bdEmScratch
	;can ignore OM errors here since cbLogical will have been
	;trimmed to the same value for both buffers.

	PopfDirect ax			;restore direct mode status

	call	fEditorActive		; Did we start with /EDITOR
	jz	@F			; no, ok to exit
	test	[mrsCur.MRS_flags2],FM2_NoPcode ; is it a document table?
	jnz	@F			; brif so, it is ok

	; We must insure that we are using a document table, so create
	; a new one

	mov	ax,DATAOFFSET szUntitled; psz of title
	push	ax			; first parm to OgNamofPsd
	push	ax			; parm to CbSz
	call	CbSz			; get the length
	push	ax			; second parm to OgNamofPsd
	call	OgNamofPbCb		; convert to OgNam
	xchg	bx,ax			; save OgNam in BX
	or	bx,bx			; did we make the OgNam?
	mov	ax,ER_OM		; assume not, prepare OM error
	jz	NoOgName		; no, give OM Error
	push	bx			; ogNam
	PUSHI	ax,<(FM2_File + FM2_NoPCode) * 100h> ; flags
	call	MrsMake 		; create the MRS
NoOgname:
	or	ax,ax			; is there an error
	jz	@F			; brif not, all ok
	or	si,si			; is there already an error?
	jz	SaveError		; brif not, use the new error
@@:					
	xchg	ax,si			;ax = result
	or	ax,ax			;set condition codes for caller
	je	LfExit			;brif no error occurred
SaveError:
	mov	[txtErr.TXER_errCode],ax
LfExit:
cEnd



;*********************************************************************
; SetPsErrMsg
; Purpose:
;	Set the parser's error message buffer to the name of a
;	register set (module or procedure).
; Entry:
;	ax = oRs (condition codes set based on value in ax)
; Exit:
;	ps.bdErr contains ASCII name of module/procedure.
;	ax = 0 if out-of-memory (condition codes set based on value in ax)
;
;*********************************************************************
cProc	SetPsErrMsg,<PUBLIC,NEAR>
cBegin
	push	ax			;preserve the oRs
	cCall	RsActivateCP,<ax>	;activate the oRs
	pop	ax			;ax = oRs
	mov	bx,[prsCur.PRS_ogNam]	
	or	ax,ax			;test the oRs
	js	ItsPrs			;brif procedure (not module)
	mov	bx,[mrsCur.MRS_ogNam]	
ItsPrs:
	;set ps.PS_bdErr contents to mrs/prs name
	mov	[ps.PS_bdErr.BD_cbLogical],0 ;set bdErr buffer to empty
	PUSHI	dx,<DATAOFFSET ps.PS_bdErr> ;pass param1 = ptr to Bd
	push	bx			;pass param2 = ogNam 

	call	BdAppendOgNam		; copy name of proc/module to err 
					;   buf, alloc err buf if required
	or	ax,ax			;test for out-of-memory error
cEnd

;*********************************************************************
; LfDupRs
; Purpose:
;	Report duplicate prs or mrs during LOAD
; Entry:
;	if [oRsDupErr] <> UNDEFINED, it identifies duplicate PRS
;	or MRS encountered during a Load
; Exit:
;	if duplicate mrs was found
;	   si = MSG_DupMrs
;	   txtErr.oRs = oRs of existing mrs, txtErr.otx = 0
;	else if duplicate prs was found
;	   si = MSG_DupPrs
;	else
;	   si is unchanged
;
;*********************************************************************
cProc	LfDupRs,<PUBLIC,NEAR>
cBegin
	mov	ax,[oRsDupErr]
	inc	ax
	je	DupErrExit		;brif no duplicate mrs or prs
	dec	ax			;restore ax = oRsDupErr
	push	ax			;save oRsDupErr
	call	SetPsErrMsg		;set ps.bdErr to name of oRs ax
	pop	ax			;restore oRsDupErr
	;if static err buf, OM err not possible
	mov	si,ER_OM
	je	DupErrExit		;return ER_OM if SetPsErrMsg error
	or	ax,ax
	mov	si,MSG_DupPrs
	js	LFDGotPrs		;brif ax is prs, not mrs
	.errnz	MSG_DupPrs - MSG_DupMrs - 1
	dec	si			;si = MSG_DupMrs
	mov	[txtErr.TXER_oRs],ax	;as convenience to user, position
	mov	[txtErr.TXER_otx],UNDEFINED ; cursor at top of module that was
	mov	[txtErr.TXER_oSrc],0
					; already loaded.
LFDGotPrs:
DupErrExit:
cEnd

;*************************************************************************** 
; NormFileName
;
;Purpose:
;	Normalizes the path of a filename and appends ".bas" if there 
;	previously was no extension. Uses runtime routines B$IValidatePath
;	Generates the fully-qualified pathname from a filename.
;	Converts name to upper case, and removes "\..\" and "\.\" from the
;	pathname.  Resulting pathname is null-terminated.  Appends the drive
;	letter and a ":" to the front if it doesn't have one already.
;
;	Names within pathname do not have '*'s expanded to '?'s.  No checks
;	are done for too many slashes or length.  These checks are not
;	necessary, since the DOS calls that take as input this processed
;	pathname should perform those checks.  Both forward and backward
;	slashes are accepted as path characters.
;
;	Filenames without extentions that are longer than 8 characters have
;	a "." inserted after the 8th position.  An error is given if a filename
;	has more than one dot.
;	
;
;Entry:
;	bx = string descriptor of filename
;	di = destination for processed pathname 
;		(for QB must be FILNAML bytes long)
;	     For EB this is filled with an st for the module name
;	        and the SD_pb field of bx must point to the second 
;		byte in this buffer.
;	si = destination string descriptor
;	grs.GRS_oMrsCur: [in EB] the name of the current module 
;			is passed to OMEGA
;
;Exit:
;	ax = standard error code if error (0 if not)
;	condition codes set based on value in al
;	si.SD_cb = length of pathname (NOT including the null byte)
;	es = ds
;	Upper case, fully-specified pathname filled in.
;
;******************************************************************************
DbPub	NormFileName
cProc	NormFileName,<NEAR>
cBegin

	call	RtPushHandler		;save caller's runtime error handler
					; (NOTE: alters stack pointer)
					; (preserves ax,bx, dx)
	mov	ax,CPOFFSET NfnExit	;if any runtime errors occur,
	call	RtSetTrap		; branch to NfnExit with sp,di =
					; current values  (preserves bx,cx, dx)

	push	[bx.SD_pb]		;parm1 = near pointer to filename
	push	[bx.SD_cb]		;parm2 = filename length
	push	di			;parm3 = near pointer to destination
	PUSHI	ax,<dataOFFSET b$BAS_EXT> ;parm4 = near pointer to ".bas"
	call	B$IValidatePath		; ax = length of resulting filename
					; NOT including 0 byte
	mov	[si.SD_cb],ax		;set byte count field of SD
	xor	ax,ax			;clear ax to indicate no error

;al = error code (0 if no error)
NfnExit:		
	call	RtPopHandler		;restore caller's runtime error handler
					; (saved on stack by RtPushHandler)
					; (preserves ax)
	xor	ah,ah			;clear ah so ax is condition code
	or	al,al			;set condition codes for caller
cEnd


sEnd	CP



end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtmgr.asm ===
;==========================================================================
;
;Module:  txtmgr.asm - Text Management Functions
;System:  Quick BASIC Interpreter
;
;=========================================================================

	.xlist
	include		version.inc
	TXTMGR_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	names
	includeOnce	opcodes
	includeOnce	parser
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtps
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	txtint
	includeOnce	ui
	includeOnce	util
	includeOnce	variable
	.list

assumes	ds,DATA
assumes	ss,DATA
assumes	es,NOTHING

;-----------------------------------------------------------------------
; Scoping of legal statements:
;
; Some statements are invalid in protected-direct mode (i.e. only
;   valid in a program or unprotected-direct-mode).  These are
;   caught by the parser's NtStatement() function which checks
;   a list of statements which ARE legal in protected direct mode
;   (a much smaller list than those which are illegal).
;
; Some statements are invalid in direct mode (i.e. only valid within
;   a program).  Those which can be identified by Reserved Word are
;   caught by the parser's NtStatement() function which checks the
;   'no_direct' flag as set in file 'bnf.prs'.
;   Those which can be identified by opcode are caught by TxtDirect()
;   when it finds entries for them in the table tOpDirect[].
;
; Some statements are only valid at module level.  This includes
;   DECLARE, DEF FNxxx, which are caught by the parser, and
;   END DEF, DATA which are caught by TxtChange.
;
; Some statements are only valid within a SUB/FUNCTION.  This includes
;   SUB/FUNCTION which is caught by the parser, and
;   END SUB/FUNCTION which is caught by TxtChange.
;
; Some opcodes are only valid after the defintion line of a SUB/FUNCTION.
;   These are caught by TxtChange.  Those which can precede a SUB/FUNCTION
;   include opBol, opBolSp, opBolInclude, opStRem, opQuoteRem,
;   opStDefType, opStInclude
;   (and op_Static, op_Dynamic in QB4 and the like [4]).
;
;-----------------------------------------------------------------------

; Typical text table:
; ------------------
;			         opBol:...
;    txdCur.otxLabLink---------->opBolLab(x)
;			         opBol:...
;				    :
;			         opBol:...
;				 opEndProg:...
;    				 opEot
;    txdCur.bdlText.cbLogical--->
; 
; 
; Text table with active Watch expressions:
; ----------------------------------------
; 			         opBol:...
;			 	    :
; 			         opBol:...
;    				 opEndProg
;			         <exp>:opWatchExp
;			         <exp>:opWatchStop
;			         <exp>:opWatchExp
;			         opEot
;    txdCur.bdlText.cbLogical--->
;
;----------------------------------------------------------------------------



sBegin	DATA

	extrn	fMergeInSub:byte	;non-zero if MERGING into SUB/FUNCTION
					;only valid when FLoadActive is TRUE

	extrn	b$SdBuf1:word		; SD to b$Buf1 (from runtime)

;see comments in txtint.inc for bigEditState flag values, and TxtStartBigEdit
;for further details.
;
DbPub	bigEditState
bigEditState DB BIG_EDIT_FALSE

cForDel		DB 0			;1+num of FOR stmts deleted by TxtDelete
cForStepDel	DB 0			;1+num of FOR ... STEP stmts deleted

;bdlTxtScrap holds deleted pcode in case the user wants to back out of the
;edit (for Edit & Continue).
;
PUBLIC	bdlTxtScrap			
bdlTxtScrap	BDL <0,NOT_OWNER,0,0> ;initializes status field to NOT_OWNER

;fFillScrap is FALSE if TxtDelete should not copy deleted text to bdTxtScrap
;	(see comments for Big Edit)
;
fFillScrap	DB 0

;otxScrapStart & otxScrapEnd represent the offsets into the current text table
;where pcode was deleted and copied into bdTxtScrap
;
otxScrap	DW 0

;otxBigIns and cbBigIns identify all pcode inserted since the BigEdit
;started.  If the user wants to back out of the BigEdit, they represent
;the text which needs to be deleted.
;
otxBigIns	DW 0
cbBigIns	DW 0

;fBindStatic is input parm to TxtBindPrs
;
fBindStatic	DB 0

;bindErrCode is result parm of TxtBindPrs
;
bindErrCode	DW 0

;text mgr flags - FTM_xxx
PUBLIC	flagsTm
flagsTm 	DB 0
flagsTm2	DB 0	;must immediately follow flagsTm
FTM2_PrsRefDeleted EQU 01h


externB fLoadInclude	


sEnd	DATA

sBegin	CODE

;Table of all the opcodes that contain oPrs operands
;The order of entries in this table is VERY important
;
tOpPrsDef LABEL WORD
	opTabStart	PRSDEF
	opTabEntry	PRSDEF,opStDeclare
	opTabEntry	PRSDEF,opStSub
	opTabEntry	PRSDEF,opStFunction
	opTabEntry	PRSDEF,opStDefFn
		PRSDEF_DefineMax EQU PRSDEF_opStDefFn
	opTabEntry	PRSDEF,opStCall
	opTabEntry	PRSDEF,opStCallS
	opTabEntry	PRSDEF,opStCallLess
	opTabEntry	PRSDEF,opEot

;These opcodes are of special interest BEFORE they are deleted:
; Reasons why we have to descan to RUDE when certain opcodes are deleted:
;  opStSub, opStFunction, opStDefFn :
;    MakeVariable would be called again to evaluate the parm list, and
;    would give duplicate definition errors for each parm.
;
;  If line containing opStDimTo, opStRedimTo, opShared, opStShared,
;     opStStatic, opAsType, opAsTypeExp, or opAsTypeFixed 
;     (or opCmdAsType in EB) is edited, the variable
;     manager would give a duplicate definition error when new edited line
;     is inserted.
;
;  If a break point is being toggled on the current line, then edit and
;     continue is allowable, as only the opBreakPoint will be inserted
;     on the line.
;
tOpPreDel LABEL WORD
	opTabStart	PREDEL
	; opBol and opBolLab are in this list as TxtFind terminators
	; They will keep us from Searching to opEot if no other interesting
	; opcodes are found after the otx range deleted.  This significantly
	; speeds up edits for generic programs with large text tables.
	
	opTabEntry	PREDEL,opBol
	opTabEntry	PREDEL,opBolLab
		PREDEL_BolMax EQU PREDEL_opBolLab
	opTabEntry	PREDEL,op_Include
		PREDEL_IncludeMax EQU	PREDEL_op_Include
		;The following opcodes cause rude-edit when deleted
	opTabEntry	PREDEL,opStDefType
		PREDEL_rudeMin EQU PREDEL_opStDefType
	; opStDeclare is included here to ensure that variable tables get
	; recreated in case a DECLARE for a quicklib function is deleted.
	; e.g. DECLARE FUNCTION FOO () : x = foo where foo is in a qlb.
	; deleting the DECLARE will cause a variable named foo to be defined.
	
	opTabEntry	PREDEL,opStDeclare
	opTabEntry	PREDEL,opStSub
	opTabEntry	PREDEL,opStFunction
	opTabEntry	PREDEL,opStDefFn
	opTabEntry	PREDEL,opEndSingleDef
	opTabEntry	PREDEL,opStEndDef
	opTabEntry	PREDEL,opStConst
	opTabEntry	PREDEL,opStCommon
	opTabEntry	PREDEL,opAVtRf	
	opTabEntry	PREDEL,opStReDimTo
	opTabEntry	PREDEL,opShared
	opTabEntry	PREDEL,opStShared
	opTabEntry	PREDEL,op_Static  
	opTabEntry	PREDEL,op_Dynamic 
	opTabEntry	PREDEL,opStStatic
	opTabEntry	PREDEL,opStType
	opTabEntry	PREDEL,opStEndType
	opTabEntry	PREDEL,opAsType
	opTabEntry	PREDEL,opAsTypeExp
	opTabEntry	PREDEL,opAsTypeFixed 
	opTabEntry	PREDEL,opNoList1
	;Scanner inserts opNoList1 in a statement whenever the stack
	; contains a return address into that statement.  Deleting
	; an opNoList1 means we're deleting a return address - Cant Continue.
	; opNoList1 could just be AskCantCont instead of AskRudeEdit,
	; but its not worth the extra code to let users print variables
	; after deleting a return address, and other than that,
	; AskCantCont is identical to AskRudeEdit

	opTabEntry	PREDEL,opStOptionBase0	
	opTabEntry	PREDEL,opStOptionBase1	
	opTabEntry	PREDEL,opEot

;These opcodes are of special interest AFTER they have been deleted:
;
tOpDel	LABEL WORD
	opTabStart	DEL
	opTabEntry	DEL,opLab
	opTabEntry	DEL,opLabSp
	opTabEntry	DEL,opBolLab
		DEL_bolMin EQU DEL_opBolLab
	opTabEntry	DEL,opBolLabSp
		DEL_labMax EQU DEL_opBolLabSp
	opTabEntry	DEL,opBol
	opTabEntry	DEL,opBolSp
	opTabEntry	DEL,opBolInclude
	opTabEntry	DEL,opBolIncludeSp
		DEL_bolInclMin EQU DEL_opBolInclude
		DEL_bolMax EQU DEL_opBolIncludeSp
	opTabEntry	DEL,opStFor
	opTabEntry	DEL,opStForStep
		DEL_forMax EQU DEL_opStForStep
	opTabEntry	DEL,opWatchExp
	opTabEntry	DEL,opWatchStop
		DEL_watchMax EQU DEL_opWatchStop
	opTabEntry	DEL,opAsType
	opTabEntry	DEL,opStEndProc
	opTabEntry	DEL,opStCommon
	opTabEntry	DEL,opAVtRf	
	opTabEntry	DEL,opBreakPoint
		DEL_NonSubRefMax EQU DEL_opBreakPoint 
;Remaining entries in table are all the opcodes that could contain references
; to SUBs.  We need to look for these in order to correctly reset the SUB
; name space bit.
	opTabEntry	DEL,opStDeclare 	
	opTabEntry	DEL,opStSub		
	opTabEntry	DEL,opStCall		
	opTabEntry	DEL,opStCallS		
	opTabEntry	DEL,opStCallLess	
	opTabEntry	DEL,opEot


;These opcodes are of special interest BEFORE they are inserted
; NOTE: if any entries in this table change, update PiDispatch
;
tOpPreIns LABEL WORD
	opTabStart	PI
	opTabEntry	PI,op_Static
	opTabEntry	PI,op_Dynamic
	opTabEntry	PI,op_Include
	opTabEntry	PI,opStSub
	opTabEntry	PI,opStFunction
	opTabEntry	PI,opStEndProc
	opTabEntry	PI,opEndSingleDef
	opTabEntry	PI,opStEndDef
	opTabEntry	PI,opStData
	opTabEntry	PI,opStShared
	opTabEntry	PI,opStDefType
	opTabEntry	PI,opStCommon
	opTabEntry	PI,opStEndType
	opTabEntry	PI,opStFor
	opTabEntry	PI,opStForStep
	opTabEntry	PI,opStConst
	opTabEntry	PI,opShared
	opTabEntry	PI,opStOptionBase0	
	opTabEntry	PI,opStOptionBase1	

	opTabEntry	PI,opElemRef
	opTabEntry	PI,opEot

;These opcodes are of special interest AFTER they are inserted
; NOTE: if any entries in this table change, update AiDispatch
;
tOpAftins LABEL WORD
	opTabStart	AFTINS
	opTabEntry	AFTINS,opBolInclude
	opTabEntry	AFTINS,opBolIncludeSp
		AFTINS_bolInclMax EQU AFTINS_opBolIncludeSp
	opTabEntry	AFTINS,opBol
	opTabEntry	AFTINS,opBolSp
	opTabEntry	AFTINS,opBolLab
		AFTINS_dispMin EQU AFTINS_opBolLab
	opTabEntry	AFTINS,opBolLabSp
		AFTINS_bolMax EQU AFTINS_opBolLabSp
	opTabEntry	AFTINS,opLab
	opTabEntry	AFTINS,opLabSp
	opTabEntry	AFTINS,opStFunction
	opTabEntry	AFTINS,opStSub
	opTabEntry	AFTINS,opStDeclare
	opTabEntry	AFTINS,opStCall
	opTabEntry	AFTINS,opStCallS
	opTabEntry	AFTINS,opStCallLess
	opTabEntry	AFTINS,opStEndProc
	opTabEntry	AFTINS,opEndSingleDef
	opTabEntry	AFTINS,opStEndDef
	opTabEntry	AFTINS,opStData
	opTabEntry	AFTINS,opStRestore1
	opTabEntry	AFTINS,opEot

;List of opcodes which are legal in SUB/FUNCTION window before
;the procedure's definition
;
tOpPreProc LABEL WORD
	opTabStart	PREPROC
	opTabEntry	PREPROC,opBol
	opTabEntry	PREPROC,opBolSp
	opTabEntry	PREPROC,opBolInclude
	opTabEntry	PREPROC,opBolIncludeSp
		PREPROC_bolMax EQU PREPROC_opBolIncludeSp
	opTabEntry	PREPROC,opStDefType
	opTabEntry	PREPROC,opStRem
	opTabEntry	PREPROC,opQuoteRem
	opTabEntry	PREPROC,op_Static
	opTabEntry	PREPROC,op_Dynamic
	opTabEntry	PREPROC,opNoType	;for SUB x.y
	opTabEntry	PREPROC,opReParse
	opTabEntry	PREPROC,opStEndProc	;only if SUB opStSub or
						; opStFunction precedes it.
	opTabEntry	PREPROC,opStSub
		PREPROC_SubOrFuncMin EQU PREPROC_opStSub
	opTabEntry	PREPROC,opStFunction
	opTabEntry	PREPROC,opEot

tOpEndProc LABEL WORD
	opTabStart	ENDPROC
	opTabEntry	ENDPROC,opStEndProc
	opTabEntry	ENDPROC,opEot

sEnd	CODE



;--------------------------------------------------------------------
; Functions which keep track of where the current "defining" reference
; to a Prs is.  If there are any references to a prs in any loaded pcode,
; we keep track of the "most powerful" or "defining" reference in
; prs.oRsDef, prs.otxDef.
;
; A SUB/FUNCTION/DEF FN statement is the "most powerful" possible
;   definition for a prs entry.
; If no SUB/FUNCTION/DEF FN statements refer to a prs, the next most
;   powerful definition is a DECLARE statement.
; If no DECLARE statements refer to a prs, the only remaining possible
;   definition is a CALL statement.
;
; When all pcode references to a prs have been deleted,
; and the prs has no text table, PrsFree is called to remove the entry.
;
; The management of "defining" references happens in two stages during
; an edit.  When a "defining" reference is deleted, prs.otxDef is set
; to undefined by UndefPrs.  At the end of the edit operation, RedefOrDelPrs
; is called to search for a new "defining" reference, or free the prs.
;
; This is done in two stages as a speed optimization for text edits.
; This will help speed up the cases where you are discarding text
; tables, or terminating ASCII load because of an out of memory error.
; This way we accumulate and process all prs defining reference changes
; at one time.
;
;			Call Trees
;			==========
;
; Deleting a defining reference
; -----------------------------
; MrsDiscard   PrsDiscard
;	  \    /
;          \  /
;       TxtDiscard                     ParseLine
;           |                             |
;       TxtDelete             ParseUndo MakeProc (when renaming a sub/function)
;           |                        |    |
;   ForEachPrsInPlaceCP(UpdatePrs)   |	  |
;			      |      |	  |
;			      +------+----+
;				     |
;				  UndefPrs
;
; End of edit - find new defining reference
; -----------------------------------------
;    TxtChange	    LoadFile
;	 |	       |
;	 |	       |
;	 |	       |
;	 |	      MrsDiscard   PrsDiscard
;	 |	       |      \     /	  |
;	 |	       |     PrsDiscard1  |
;	 |	       |		  |
;	 +-------------+------------------+
;		  |
;	   ChkAllUndefPrs		 
;		  |			 
;		  --------
;		  |	 |
;	          | 	 
;	   ForEachCP(TryToDefPrs)
;
;--------------------------------------------------------------------

sBegin	DATA

;** the static structure uPrs is defined in SetPrsDefn header
DPRS_ST	STRUC
DPRS_oRs		DW 1 DUP (?)
DPRS_oMrs		DW 1 DUP (?)
DPRS_otx		DW 1 DUP (?)
DPRS_flags		DB 1 DUP (?)
DPRS_ST	ENDS

dprs	DB size DPRS_ST DUP (?)

;** the static structure uPrs is defined in UpdatePrs's header
UPRS_ST	STRUC
UPRS_oRsEdit		DW 1 DUP(?)
UPRS_otxEdit		DW 1 DUP(?)
UPRS_cbDel		DW 1 DUP(?)
UPRS_cbIns		DW 1 DUP(?)
UPRS_oPrsDel		DW 1 DUP (?)
UPRS_fPrsDelFound	DW 1 DUP (?)
UPRS_fNoRefSameMod	DW 1 DUP (?)
UPRS_oMrsRefDel		DW 1 DUP (?)
UPRS_ST	ENDS

uprs	DB size UPRS_ST DUP (?)

sEnd	DATA

sBegin	CP
assumes	cs,CP

;**************************************************************
; void SetPrsDefn
; Purpose:
;	Called when a prs reference is inserted in pcode.  If this is the
;	"most powerful" definition we've seen so far for the current prs,
;	the the prs entry is changed to remember this text offset
;	as the "defining" reference.
;
; Entry:
;	dprs.DPRS_oRs,oMrs,otx identify where in the pcode
;	  the reference lives.
;	dprs.DPRS_flags = FP_DEFINED if this is for a SUB/FUNCTION/DEF FN stmt.
;	                = FP_DECLARED if this is for a DECLARE stmt.
;	                = 0 if this is for a CALL stmt.
;	grs.oPrsCur identifies the prs being referenced.
;
;**************************************************************
SetPrsDefn PROC NEAR
	test	[dprs.DPRS_flags],FP_DEFINED
	jne	SpNewDef		;brif reference is SUB,FUNC,DEF FN stmt
	test	[prsCur.PRS_flags],FP_DEFINED
	jne	SpNoNewDef		;brif prs is already defined by SUB,...
	test	[dprs.DPRS_flags],FP_DECLARED
	jne	SpNewDef		;brif reference is DECLARE
	test	[prsCur.PRS_flags],FP_DECLARED
	jne	SpNoNewDef		;brif prs is already declared
SpNewDef:
	;Got a SUB, FUNCTION or DEF FN   OR
	;    a DECLARE for prs with no definition  OR
	;    a CALL to an as yet undeclared, undefined SUB.
	; This is the "most powerful" reference seen so far,
	; make this text reference the new owner of the prs entry.
	
	; We need to set prsCur.oMrs even though in most cases, it
	; is redundant given prsCur.oRsDef.  The case where it is
	; valuable info is for DECLAREd prs's with no text tables.
	; If it were not set here, there would be cases when ForEachPrsInMrs
	; would not pick up this prs
	
	mov	ax,[dprs.DPRS_oRs]
	mov	[prsCur.PRS_oRsDef],ax
	mov	ax,[dprs.DPRS_otx]
	mov	[prsCur.PRS_otxDef],ax
	mov	al,[dprs.DPRS_flags]
	or	[prsCur.PRS_flags],al
	test	[txdCur.TXD_flags],FTX_mrs
	je	SpNoNewDef		;brif prs has text table
					;If we didn't, commenting out
					;a SUB stmt would move the prs to
					;another module.
	mov	ax,[dprs.DPRS_oMrs]
	mov	[prsCur.PRS_oMrs],ax
	cmp	[prsCur.PRS_procType],PT_DEFFN
	jne	SpNoNewDef		;brif not a DEF FN
	mov	[prsCur.PRS_oRsDef],ax	;for DEF FNs, the oRsDef is the
					; module's text table.
SpNoNewDef:
	ret
SetPrsDefn ENDP

;**************************************************************
; boolean TryToDefPrs()
; Purpose:
;	Called to see if current text table contains any references
;	to prs uprs.UPRS_oPrsDel.
;
; Entry:
;	uprs.UPRS_oPrsDel is the prs whose reference has been deleted
;uprs.UPRS_oMrsRefDel is the mrs from which the reference was deleted
;uprs.UPRS_fNoRefSameMod: if TRUE then TryToDefPrs must search for
;	a reference to oPrsDel in text tables of module oMrsDel.
;dprs.DPRS_flags: if set to 0 then TryToDefPrs must search for any
;	ref's to oPrsDel. 
; Exit:
;uprs.UPRD_fNoRefSameMod is set to FALSE if it is TRUE on entry and 
;	the text table being searched is in module uprs.UPRS_oMrsRefDel
;	and a ref to procedure uprs.UPRS_oPrsDel is found.
;	uprs.UPRS_fPrsDelFound = TRUE if any other references were found
;	if a "defining" reference is found (i.e. anything but a CALL),
;	   dprs.DPRS_oRs,otx are set to identify the text table and text
;	   offset for the new "defining" reference.
;dprs.DPRS_flags is set to FP_DECLARED if a DECLARE for the deleted
;	Prs is found.
;FALSE is returned when no more searching is required, i.e. when
;	dprs.DPRS_flags = FP_DECLARED and uprs.UPRS_fNoRefSameMod
;	is FALSE.
;	
; 
;**************************************************************
TryToDefPrs PROC NEAR
	push	si			;save caller's si,di
	push	di			
	cmp	[txdCur.TXD_ScanState],SS_SUBRUDE 
	je	JE_TryDone		;	
	mov	di,[uprs.UPRS_fNoRefSameMod] 
	or	di,di			
	jz	TrySearch		;brif already found another ref
					; to the proc in the module with 
					; the deleted reference
	mov	di,[uprs.UPRS_oMrsRefDel] ;di = oMrs of module from which
					; a reference was deleted
	sub	di,[grs.GRS_oMrsCur]	;di = 0 iff the text table is in
					; the same module as the text tbl
					; from which a ref was deleted
	jz	TrySearch		;brif in same module as deleted ref
	test	[dprs.DPRS_flags],FP_DECLARED 
	jnz	TryDone			;exit if we don't need to search
					; this text table for a declare
TrySearch:	 			
	call	TxtDescanCP		;descan current txt tbl to SS_PARSE
	sub	ax,ax
	push	ax
	PUSHI	ax,<CODEOFFSET tOpPrsDef>
	call	TxtFindOp		;ax = offset to 1st opcode in cur text
					; table with prs operand
					;dl = [txtFindIndex]
TryLoop:
	mov	si,ax			;si = otxCur
	cmp	dl,PRSDEF_opEot
JE_TryDone:				
	je	TryDone			;brif done with text table
	add	ax,4			;advance to oPrs operand
	cmp	dl,PRSDEF_opStDefFn
	jne	TryNotDefFn		;brif ref is not a DEF FN
	inc	ax			;skip DEF FN's link field
	inc	ax
TryNotDefFn:
	call	GetWOtx			;ax = oPrs of reference (ax)
	cmp	ax,[uprs.UPRS_oPrsDel]
	jne	TryNext			;brif not ref to prs of interest
	mov	[uprs.UPRS_fNoRefSameMod],di  ;set flag indicating whether
					      ; or not another ref was found
					      ; in module of deleted ref
	test	[dprs.DPRS_flags],FP_DECLARED 
	jnz	TryExit1		;brif not searching for defining ref
	mov	[uprs.UPRS_fPrsDelFound],sp
					;tell caller we found a reference
	;remember where new reference is in static dprs struct
	mov	ax,[grs.GRS_oRsCur]
	mov	[dprs.DPRS_oRs],ax
	mov	ax,[grs.GRS_oMrsCur]
	mov	[dprs.DPRS_oMrs],ax
	mov	[dprs.DPRS_otx],si	;save otxCur
	cmp	[txtFindIndex],PRSDEF_DefineMax
	ja	TryNext			;brif reference was a CALL

	;Since this is only called when the current "defining"
	;reference has been deleted, we know we're never going
	;to find a SUB or FUNCTION pcode.  A DECLARE is the
	;strongest definition we can hope to find, so there's
	;no need to search any further
	
	test	[mrsCur.MRS_flags2],FM2_INCLUDE ;is this an INCLUDE mrs?
	jne	TryNext 		;force it to a "weak" owner

	mov	[dprs.DPRS_flags],FP_DECLARED
TryExit1:
	xchg	ax,di			;ax = 0 iff no longer need to search
	jmp	SHORT TryExit

TryNext:
;if we've just seen a CALL ref, keep searching for DECLARE
	push	si
	PUSHI	ax,<CODEOFFSET tOpPrsDef>
	call	TxtFindNextOp
	jmp	SHORT TryLoop

TryDone:
	mov	ax,sp			;return TRUE (non zero)
TryExit:
	pop	di			;restore caller's di
	pop	si			;restore caller's si
	ret	
TryToDefPrs ENDP

;**************************************************************
; FreeAllUndefinedPrs, ChkAllUndefPrs, ChkAllUndefPrsSaveRs
; Purpose:
;	FreeAllUndefinedPrs has two purposes:
;	(1) It is called to check all prs's to see
;	if the the "defining" text reference to a prs has
;	been marked as deleted. If so, it calls RedefOrDelPrs
;	to search for a new "definition" if none are found, then
;	the Prs is released via PrsFree.
;	(2) It is called to check all prs's to see
;	if the last reference to the prs has been deleted from the
;	module being editted. 
;	ChkAllUndefPrs differs from FreeAllUndefPrs in that it 
;	knows that searching only needs to be performed when a 
;	reference is deleted.
;
;	FreeAllUndefinedPrs is called to Free prs entries created
;	by undefined direct mode references.
;
;	The FTM_PrsDefDeleted bit of flagsTm is used to
;	to determine if we need to search for a new "defining"
;	reference for the prs.
;
; Entry:
;	flagsTm.FTM_PrsDefDeleted set if we need to search
;	  for a new "defining" reference.
;
; Exit:
;	Deleted prs entries with no new definitions are freed
;	Deleted prs entries with new definitions have otxDef
;	  and oRsDef set to the new definition.
;**************************************************************
PUBLIC	ChkAllUndefPrsSaveRs
ChkAllUndefPrsSaveRs PROC NEAR
	push	[grs.GRS_oRsCur]	;preserve current oRs
	call	ChkAllUndefPrs		;check all undefed prs entries
	call	RsActivateCP		;Reactivate current oRs
	ret
ChkAllUndefPrsSaveRs ENDP

PUBLIC	ChkAllUndefPrs
ChkAllUndefPrs	PROC NEAR
	test	WORD PTR [flagsTm],FTM_PrsDefDeleted OR FTM2_PrsRefDeleted*100h
					;have any definitions been deleted?
	jne	FreeAllUndefinedPrs	;brif so - Redef or Del all UNDEFINED
					; prs entries
	ret
ChkAllUndefPrs	ENDP

PUBLIC	FreeAllUndefinedPrs
FreeAllUndefinedPrs PROC NEAR
	push	si			
	push	di			
	mov	ax,[grs.GRS_oMrsCur]	
	mov	[uprs.UPRS_oMrsRefDel],ax	;store mrs of deleted text
	mov	si,UNDEFINED		
FreeAllUndef_Cont:			
	cCall	PrsDeActivate		; ensure all proc.s are in Rs table
FreeAllUndef_Cont1:			
	mov	di,si			
FreeAllUndef_Cont2:			
	mov	ax,di			
	call	GetNextPrs		; PTRRS:ax points to first prs
					;	ax == UNDEFINED ==> no prs's
	inc	ax			
	jnz	FAU_DontExit		
	jmp	FreeAllUndef_Exit	
FAU_DontExit:				

	dec	ax			
	mov	si,ax			; cache, so we don't end up starting
					; from the beginning of the prs
					; chain each time we free a prs
	mov	bx,ax			
	RS_BASE add,bx			; bx = oPrs

; assign cx = 0 if no reference to the Prs has been deleted otw non-zero
	xor	cx,cx			
	test	PTRRS[bx.PRS_flags2],FP_RefDeleted ;[38]
	jz	NoRefDeleted		;brif no reference has been deleted
	and	PTRRS[bx.PRS_flags2],NOT FP_RefDeleted ;[38]clear flag
	not	cx			;set cx = non-0 since ref was deleted
NoRefDeleted:				
	mov	[uprs.UPRS_fNoRefSameMod],cx ;initialize fNoRefSameMod
					;     to TRUE if we must search for
					;     a ref to the Prs in the module

; assign ax = 0 if otxDef is defined otw non-zero
	mov	al,1			;assume otxDef is undefined
	cmp	PTRRS[bx.PRS_otxDef],UNDEFINED
	je	otxDefUnDefined		;brif otxDef is UnDefined
	jcxz	FreeAllUndef_Cont1	;brif otxDef is Defined and 
					; no ref to the prs has been
					; deleted -- nothing to do
	xor	ax,ax			;set ax = 0 since otxDef is defined
otxDefUnDefined:
	push	cx			;preserve condition flag
	push	ax			;preserve condition flag

	push	si			; pass to PrsActivateCP
	call	PrsActivateCP		;activate prs which may be freed

	pop	cx			;cx = 0 iff otxDef is defined
	pop	ax			;ax = 0 iff no ref to proc was del'd
	jcxz	DontSearchForDeclare	;brif otxDef of proc is defined
	xor	dx,dx			;assume that we will need to search
					; for a new defining ref
	test	[flagsTm],FTM_PrsDefDeleted 
	jnz	SearchForRef		;brif a defining ref has been del'd
	or	ax,ax			;ax = 0 if no ref to proc was del'd
	jz	ChkDeletePrs		;This branch is taken if no ref to
					; this proc has been deleted and
					; no defining ref has been deleted
DontSearchForDeclare:	     		
	mov	dl,FP_DECLARED		
SearchForRef:				
	mov	[dprs.DPRS_flags],dl	;set dprs.flags to FP_DECLARED
					; if we don't need to search for
					; a new defining ref otw set to 0
	mov	[uprs.UPRS_fPrsDelFound],dx ;set fPrsDelFound to 0 if we
					; are searching for a defining ref
	mov	dx,[grs.GRS_oPrsCur]	;set up global specifying which proc
	mov	[uprs.UPRS_oPrsDel],dx	;  we are searching for references to
	push	cx			;preserve condition flag

	;Note that we search even text mrs's because the reference
	;to the prs may be within an INCLUDE mrs.  It is tempting to
	;make INCLUDE mrs's be FM2_NoPcode mrs's, but doing so would
	;prevent the ability to select the 'View/Include File' menu
	;item when an INCLUDE mrs is active, because the $INCLUDE
	;lines would not have been parsed.
	
	;This leads to the situation that an INCLUDE mrs can be
	;the owner of a prs.  This keeps the prs from being deleted until
	;all references to the prs are gone.  However, we must also insure
	;that the include mrs does not become an owner of a prs when other
	;"stronger" definitions exist.	Therefore, all prs references from
	;an include mrs will be treated as the "weakest" possible owners.
	
	mov	bx,CPOFFSET TryToDefPrs
	mov	al,FE_PcodeMrs+FE_TextMrs+FE_CallMrs+FE_PcodePrs+FE_SaveRs
	call	ForEachCP
	cmp	[uprs.UPRS_fNoRefSameMod],FALSE	
	je	GotRefInSameModule	;brif another ref in module found

;We have not found another reference to the Prs in the module from which
;the ref was deleted. Clear the NMSP_sub name table bit of the sub's oNam
;in that module so that it can be used now as a variable name.
	push	[grs.GRS_oRsCur]	;save current oRs for reactivation
	push	[uprs.UPRS_oMrsRefDel]	
	call	MrsActivateCP		;activate the module 
	cCall	FieldsOfPrs,<si>	;ax = oNam of proc
	xchg	bx,ax			;pass bx = oNam of proc
	mov	al,NMSP_SUB		;pass al = flag to clear
	call	ResetONamMask		;clear sub bit of oNam of Mrs
	call	RsActivateCP		;reactivate the Rs we were searching
GotRefInSameModule:			
	pop	cx			;cx = 0 iff otxDef is defined
	jcxz	J1_FreeAllUndef_Cont	;brif otxDef is defined - i.e. we
					; were only searching for another
					; ref in module of deletion
	cmp	[uprs.UPRS_fPrsDelFound],0 ;was a new defining reference found
	je	ChkDeletePrs		;brif didn't find new "defining" ref

	;found new "defining" reference
	
	call	SetPrsDefn		;parms are in static struct dprs
J1_FreeAllUndef_Cont:			
	jmp	FreeAllUndef_Cont 	;[37] go on to next prs

ChkDeletePrs:
	;Prs has no "defining" reference
	;If prs has no text table, release it via PrsFree
	;  By the time this function has been called by PrsDiscard,
	;    any text table that this prs might have owned will have
	;    been released.
	
	test	[txdCur.TXD_flags],FTX_mrs ;does this prs have a text table?
	je	J1_FreeAllUndef_Cont	; brif so, will eventually be freed
					; by PrsDiscard

	call	PrsFree 		;free the prs
	DbAssertRel [grs.GRS_oPrsCur],z,UNDEFINED,CP,<FreeAllUndefinedPrs err>
	jmp	FreeAllUndef_Cont2 	;[37] go on to look for next prs,
					 ; starting from last prs that
					 ; we did not free ...
FreeAllUndef_Exit:			
	pop	di			
	pop	si			
	and	WORD PTR[flagsTm],NOT(FTM_PrsDefDeleted+FTM2_PrsRefDeleted*100h)
					;all Prs entries are clean
	ret
FreeAllUndefinedPrs ENDP

;**************************************************************
; UndefPrs(ax:oPrsDelete)
; Purpose:
;	This function is called whenever the "defining"
;	text reference to a prs is deleted.  It clears
;	the prs definition flags and sets prs.otxDef to
;	undefined.
;
; NOTE: The caller is responsible for calling ChkAllUndefPrs
;	to search for a new defining reference, or release
;	the prs entry if no more references to the prs exist.
; NOTE: Some callers expect no heap movement from this routine.
;
; Entry:
;	ax is the oPrs whose reference is being deleted
;
; Exit:
;	prs.otxDef = UNDEFINED
;	prs definition flags are cleared.
;	restores caller's active register set.
;
;**************************************************************
PUBLIC	UndefPrs
UndefPrs PROC NEAR
	push	[grs.GRS_oRsCur]	;save caller's active register set

	push	ax			;pass to PrsActivateCP
	call	PrsActivateCP		;activate prs which may be freed
	or	[flagsTm],FTM_PrsDefDeleted ;we have deleted a defining reference
	mov	[prsCur.PRS_otxDef],UNDEFINED ;remember that current "defining"
					;reference has been deleted
	Msk EQU NOT (FP_DEFINED OR FP_DECLARED OR FP_CDECL)
	and	[prsCur.PRS_flags],Msk	;turn off these flag bits
					;SetPrsDefn will be called to turn
					;one or more back on if another ref
					;is found in the pcode
	call	RsActivateCP		;activate caller's register set
					; oRs parm is already on stack
	ret
UndefPrs ENDP

;**************************************************************
; boolean UpdatePrs()
; Purpose:
;	This is called after text has been inserted into, or deleted
;	from any text table.  It is called for each prs which could be
;	declared in this text table (even if by CALL <compiled sub>),
;	If the prs's "defining" reference is in this text table:
;	   If the reference was deleted by the edit:
;	      Set its Otx field to UNDEFINED
;		a new defining reference will be searched for at completion
;		of the current edit operation
;	   else if the "defining" reference was moved by the edit:
;	      its otx field is updated
;	This function will flag many prs entries if the
;	deleted text included many DECLAREs, where the DECLARE was the
;	only remaining reference.
;
;	NOTE: to drastically improve text edit performance, this routine
;	gets called by ForEachPrsInPlaceCP, which marches through the
;	prs table without activating the PRS.  Thus, this routine MUST
;	NOT cause heap movement which would invalidate the pointer
;	used to march the prs table.
;
; Entry:
;	si = ptr to prs entry being examined
;	uprs.UPRS_oRsEdit = text table in which edit occurred
;	uprs.UPRS_otxEdit = text offset where text was inserted/deleted
;	uprs.UPRS_cbDel = number of bytes deleted
;	uprs.UPRS_cbIns = number of bytes inserted
;
;**************************************************************
DbPub	UpdatePrs
UpdatePrs PROC NEAR
	GETRS_SEG es,dx,<SIZE,LOAD>	;[11]
	mov	dx,PTRRS[si.PRS_otxDef] ; dx = text offset to prs's "defining"
					; reference
	inc	dx			;test for UNDEFINED
	je	UpExit			;brif prs has no references
	dec	dx			;restore dx = otxDef
	mov	ax,PTRRS[si.PRS_oRsDef] 
	cmp	BPTRRS[si.PRS_procType],PT_DEFFN 
	jne	UpdNotDefFn		;brif not a DEF FN
	mov	ax,PTRRS[si.PRS_oMrs]	; DEF FNs live in a module's text table
UpdNotDefFn:
	cmp	ax,[uprs.UPRS_oRsEdit]
	jne	UpExit			;brif not text table being edited
	;prs is currently defined by reference in edited text table
	mov	ax,[uprs.UPRS_otxEdit]
	cmp	dx,ax
	jb	UpExit			;brif reference unaffected by edit
	add	ax,[uprs.UPRS_cbDel]
	cmp	ax,dx
	jbe	UpMoved			;brif defining ref moved by edit

	;Defining reference has been deleted.
	;Mark Prs to indicate that defining reference has been deleted.
	
	mov	ax,si		;ax = ptr to prs entry
	RS_BASE sub,ax		;ax=oPrs for entry, parm to UndefPrs
	call	UndefPrs	;Mark Prs as "defining" reference as
				;deleted
	jmp	SHORT UpExit

;defining reference has been moved up or down in memory
UpMoved:
	mov	ax,[uprs.UPRS_cbIns]
	sub	ax,[uprs.UPRS_cbDel]
	add	PTRRS[si.PRS_otxDef],ax ; update otx based on edit
UpExit:
	or	ax,sp		; return ax != 0 and NZ
	ret
UpdatePrs ENDP



;**************************************************************
; boolean NEAR TxtDelete(otxDelFirst, otxDelLast)
; Purpose:
;	Delete some text from the current text table.
;	Doesn't update linked lists if ASCII load is active.
;
; NOTE:
;	If a Prs's "defining" reference is being deleted, this function
;	will cause the prs to be marked as UNDEFINED.  It is up to
;	the caller to insure that orphaned "New" defining references
;	the prs do not exist by calling ChkAllUndefPrs if the possibility
;	of deleting a "defining" reference has occurred during the
;	edit operation.
;
; Entry:
;	Same as for TxtChange:
;
; Exit:
;	Same as for TxtChange
;	[cForDel] = 1 + number of FOR statements deleted
;	[cForStepDel] = 1 + number of FOR...STEP statements deleted
;	Condition codes are set based on value in ax
;
;**************************************************************
cProc	TxtDelete,<PUBLIC,NEAR,NODATA>,<si,di>
	parmW	otxDelFirst
	parmW	otxDelLast
	localW	otxNext
	localW	otxTop
	localW	otxBottom
	localW	oTyp
	localW	cbDel
cBegin
 DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<TxtDelete err 1>
	DbChk	Otx,otxDelFirst		;error if > txdCur.bdlText.cbLogical
	DbChk	Otx,otxDelLast		;error if > txdCur.bdlText.cbLogical
	DbAssertRel [otxDelFirst],be,[otxDelLast],CP,<TxtDelete err 2>
	mov	di,[otxDelFirst]
	mov	al,[bigEditState]
	cmp	al,BIG_EDIT_CANCEL
	jne	DelNoCancel
	jmp	DelGoodExit		;backout of BigEdit if user CANCELed

DelNoCancel:
	cmp	[txdCur.TXD_SCANSTATE],SS_SUBRUDE 
	jne	DelNotSubRude		;	
	jmp	DelNoThreads		;don't need to examine text before
					; deletion if no oPrs's in code
DelNotSubRude:				;	
	cmp	al,BIG_EDIT_FALSE
	jne	DelInBigEdit		;brif in a BigEdit
	mov	[cForDel],1
	mov	[cForStepDel],1
DelInBigEdit:

;-------------------------------------------------------------------
;Examine the block of pcode being deleted opcode by
;opcode, looking for a RUDE EDIT
;   
	mov	cx,[otxDelLast]
	sub	cx,di			;compute cb to be deleted
	mov	[cbDel],cx
	jcxz	DelPreDone		;brif no text to delete, destroy scrap

	test	[mrsCur.MRS_flags2],FM2_Include OR FM2_NoPcode
	jne	DelNotTextMrs		;brif document/include file is active

	cmp	[b$cNonQBIFrames],0	;nonzero when non-QBI frames are on 
					; the stack.  Any edit at this point
					; could invalidate return addresses on 
					; the stack.  At this point we have 
					; decided to askcantcont instead of 
					; trying to fix up the return addresses
					; on the stack.
					;are non qbi return addresses on stack?
	jne	DelAskCantCont		;brif so, check for possible back out
DelNotTextMrs:
	test	[mrsCur.MRS_flags2],FM2_Include
	je	DelNotIncl1		;brif not editing an include file
DelAskCantCont:
	call	AskCantCont_CP		;ask user "Want to back out?"
	je	J1_DelBackOut		;return FALSE if user wants to back out
DelNotIncl1:
	push	di			;pass [otxDelFirst]
	PUSHI	ax,<CODEOFFSET tOpPreDel>
	call	TxtFindOp		;find 1st opcode of interest

;ax = offset to 1st opcode of interest
;dl = [txtFindIndex]
DelPreLoop:
	cmp	ax,[otxDelLast]
	jae	DelPreDone		;brif no significant opcodes were in
					;deleted range
	xchg	si,ax			;si = text offset to current opcode
	;opBol and opBolLab are in the PREDEL list to keep us from unnecessarily
	; searching all the way to opEot for innocuous edits of large "simple"
	; txt tables.  This can significantly speed up simple edits.
	
	cmp	dl,PREDEL_BolMax	;is this just a Bol?
	jbe	J1_DelPreNext		;brif so, search for next opcode.

	cmp	dl,PREDEL_IncludeMax
	jbe	DelInclude		;brif INCLUDE (or $INCLUDE [QB4])

	;It must be PREDEL_rudeMin or greater - rude edit
	push	dx			;save txtfindindex in case AskRudeEdit
					;calls TxtFind
	call	AskRudeEdit		;see if user wants to back out of edit
	pop	ax			;al = txtfindindex
	je	J1_DelBackOut		;return FALSE if user wants to
					; back out of edit
	FloadActive			;don't descan if Loading
	jne	DelPreNext
	cmp	al,PREDEL_opStDefType
	jne	DelPreNext		;brif not DEFINT..DEFSTR stmt
	call	SystemDescanCP		;implicit parms in DECLARE, SUB,
					; FUNCTION stmts need to be rechecked
					; by the scanner
DelPreNext:
	push	si
	PUSHI	ax,<CODEOFFSET tOpPreDel>
	call	TxtFindNextOp		;find next opcode of interest
	jmp	SHORT DelPreLoop

DelInclude:
	push	si			;pass otx
	call	OtxNoInclude		;ax = otx to opBol/opEot for next line
					; which has no $INCLUDE
	cmp	ax,[otxDelLast] 	;is end of $INCLUDE pcode beyond
					; requested delete?
	jbe	J1_DelPreNext		;brif not
	mov	[otxDelLast],ax		;delete all included lines as well
	sub	ax,di			;ax = new cbDel
	mov	[cbDel],ax
J1_DelPreNext:
	jmp	SHORT DelPreNext


J1_DelBackOut:
	jmp	DelBackOut		;return FALSE - user wants to
					; back out of edit

;-------------------------------------------------------------------
; If fFillScrap and bdTxtScrap is empty,
;    fFillScrap = FALSE
;    copy deleted text to bdTxtScrap
;    otxScrap = otxDelFirst
; If cbBigIns > 0, cbBigIns -= cbDel
;
;Note that cbDel may actually be zero but that we still create the scrap
;because we may subsequently be called during a big edit with fFillScrap
;TRUE but we don't want to fill the scrap.

DelPreDone:
	cmp	[fFillScrap],FALSE
	je	DelNoCopy		;brif no need to copy text to scrap
	cmp	[bdlTxtScrap.BDL_status],NOT_OWNER	
	jne	DelNoCopy		;brif scrap is already in use
	mov	[fFillScrap],FALSE	;reset one-shot flip-flop
	mov	[otxScrap],di		;remember text offset of deleted text

;  CALL TxtCopyScrap(otxDelFirst, 0, cbDel, FALSE)	[9]
	push	di			;push otxDelFirst
	xor	ax,ax			
	push	ax			;offset of where to copy into Scrap
	push	[cbDel]
	push	ax			;push FALSE meaning don't delete text
	call	TxtCopyScrap		;ax = 0 if out of memory
	jnz	CopiedOK		;brif buffer allocated successfully

	call	AskRudeEdit		;Give user a chance to back out of edit
					; if CONT is currently possible.
	je	J1_DelBackOut		;return FALSE if user wants to
					; back out of edit
	jmp	SHORT DelNoCopy

CopiedOK:

;-------------------------------------------------------------------
;NOTE: At this point, the user CANNOT back out of the edit.
;      All actions from this point on are irreversible.
;
;Examine the block of pcode being deleted opcode by
;opcode, taking special action for each opcode of interest.
;   
; Register usage for loop: si = otxCur, di = otxDelFirst
;
DelNoCopy:
	cmp	[cbDel],0		;was any text deleted?
	jne	DelAfterDel		;brif so
					; - look for special deleted opcodes
	jmp	DelGoodExit		;no pcode deleted - exit

DelAfterDel:
	push	di			;pass [otxDelFirst]
	PUSHI	ax,<CODEOFFSET tOpDel>
	call	TxtFindOp		;ax = offset to 1st interesting opcode

;ax = offset to 1st opcode of interest
;dl = [txtFindIndex]
DelLoop:
	cmp	ax,[otxDelLast]
	jae	J1_DelDone		;brif reached end of deleted range
	xchg	si,ax			;si = offset to current opcode (otxCur)
	xchg	ax,dx			;al = [txtFindIndex]
	cmp	al,DEL_bolMax
	ja	DelNotBol		;brif not a label or bol opcode
	cmp	al,DEL_labMax
	ja	DelNotLab		;brif not a label definition opcode
	lea	ax,[si+4]		;ax = text offset to oNam field
	call	GetWOtx			;ax = oNam for label
	xchg	bx,ax			;pass oNam in bx
	mov	al,NM_fLineNumLabel	;pass mask to reset in al
	call	ResetONamMask		;reset bit that says the label by
					; this name is defined
DelNotLab:
	mov	al,[txtFindIndex]
	cmp	al,DEL_bolMin
	jb	J1_DelNext		;brif not a begin of line opcode
	dec	[txdCur.TXD_cLines]	;decrement text table's line count
	cmp	al,DEL_bolInclMin
	jb	J1_DelNext			;brif not included line
	dec	[txdCur.TXD_cLinesIncl]	;decrement text table's INCLUDE line cnt
	jmp	SHORT J1_DelNext

DelNotBol:
	cmp	al,DEL_NonSubRefMax	
	jle	DelNotSubRef		;brif not a procedure reference
DbAssertRelb [txdCur.TXD_SCANSTATE],ne,SS_SUBRUDE,CP,<TxtDelete: tbl in SUBRUDE>
	lea	ax,[si+4]		
	call	GetWOtx			;ax = oPrs referenced
	call	pPrsOPrs		;es:bx points to Rs
	cmp	PTRRS[bx.PRS_procType],PT_SUB 
	jne	J1_DelNext		;brif not a sub Prs
	or	PTRRS[bx.PRS_flags2],FP_RefDeleted ;[38]set flag indicating that
					; a ref has been deleted
	or	[flagsTm2],FTM2_PrsRefDeleted ;set flag indicating
					; that a Prs Ref has been deleted
	jmp	SHORT J1_DelNext	

J1_DelDone:
DJMP    jmp	SHORT DelDone

DelNotSubRef:				
	cmp	al,DEL_forMax
	ja	DelNotFor		;brif FOR pcode not being deleted
	.errnz DEL_forMax - DEL_opStForStep
	je	DelForStep		;brif deleted a FOR STEP
	inc	[cForDel]
	jmp	SHORT J1_DelNext

DelForStep:
	inc	[cForStepDel]
	jmp	SHORT J1_DelNext

DelNotFor:
	cmp	al,DEL_watchMax
	ja	NotDelWatch		;brif WATCH pcode not being deleted
	call	WatchDeleted		;reduce number of lines allocated to
					; watch window, remember to redraw
					; DebugScreen
J1_DelNext:
	jmp	SHORT DelNext

NotDelWatch:
	cmp	al,DEL_opStEndProc
	jne	DelNotEndProc		;brif not END DEF/SUB/FUNCTION
	;user is deleting an END SUB or END FUNCTION
	and	[prsCur.PRS_flags],NOT FP_ENDPROC
	jmp	SHORT DelNext

DelNotEndProc:
	cmp	al,DEL_opAVtRf		;[1]
	je	DoResetCommon		; brif deleting a DIM statement
	cmp	al,DEL_opStCommon
	jne	DelNotCommon		;brif not COMMON
DoResetCommon:				
	DbAssertRelB cChansOpen,e,0,CP,<TxtDelete: Tried to delete COMMON while load is active>
	call	ResetCommon		;Eliminate all common type tables
	call	SystemDescanCP		;scanner will rebuild common tables
	jmp	SHORT DelNext		; for each txt tbl next scan

DelNotCommon:
	cmp	al,DEL_opBreakPoint
	jne	DelNotBreakPoint	;brif no Break Point set on this line
	or	[flagsTm],FTM_BpDeleted ;we deleted a break point
	jmp	SHORT DelNext

DelNotBreakPoint:
	DbAssertRelB cChansOpen,e,0,CP,<TxtDelete: Tried to delete AS usrtyp while load is active>
	DbAssertRelB al,e,DEL_opAsType,CP,<TxtDelete err 3>
	;DELETING AS <usertyp>

	;remember to call PreScanAsChg before scanning program
	mov	ax,si			;pass text offset in ax
	mov	bx,di			;pass otxDelFirst in bx
	mov	cx,[otxDelLast]		;pass otxDelLast  in cx
	call	ChkLastAsText		;if last instance of 'x AS user-type'
					; in module, reset x's NM_fAs name
					; table bit and set module's
					; FM_asChg bit so we'll call
					; PreScanAsChg before scanner
DelNext:
	push	si
	PUSHI	ax,<CODEOFFSET tOpDel>
	call	TxtFindNextOp
	jmp	DelLoop

DelDone:
	mov	cx,[cbDel]
	cmp	[cbBigIns],0
	je	DelNotBig
	sub	[cbBigIns],cx
DelNotBig:

	FloadActive			;don't update linked lists if Loading
	jne	DelNoThreads

	push	di			;pass otxDelFirst
	push	cx			;pass cbMove
	call	TxtDelThread		;update linked lists for delete

DelNoThreads:
	mov	si,[otxDelLast]
	push	si			;pass otxDelLast
	push	di			;pass otxDelFirst
	call	TxtMoveDown		;Actually delete text from text table
	sub	si,di			;si = cbDel

	test	[flagsTM],FTM_SaveProcHdr
	jne	DelGoodExit		;brif SaveProcHdr was in critical
					; section. A temp txt table is active,
					; which is NOT oRsCur.

	;Update program counter and any other runtime text pointers
	push	di			;pass otxDelFirst
	sub	ax,ax
	push	ax			;pass cbIns (0)
	push	si			;pass cbDel
	push	ax			;fTestOnly = FALSE
	call	UpdatePcs

	;pass information about the edit to UpdatePrs in static struct updPrs
	mov	ax,[grs.GRS_oRsCur]
	mov	[uprs.UPRS_oRsEdit],ax
	mov	[uprs.UPRS_otxEdit],di	;save otxDelFirst
	mov	[uprs.UPRS_cbDel],si
	mov	[uprs.UPRS_cbIns],0

	mov	bx,CPOFFSET UpdatePrs
	call	ForEachPrsInPlaceCPSav	;Preserve callers oRs
DelGoodExit:
	mov	ax,sp			;return TRUE (non zero)
DelExit:
	or	ax,ax			;set condition codes for caller
cEnd

;-------------------------------------------------------------------
;    If delete would prevent continuing, & user wants to back out of edit,
;       if bigEditState != BIG_EDIT_FALSE, then bigEditState = BIG_EDIT_CANCEL
;       return without changing anything
;
DelBackOut:
	cmp	[bigEditState],BIG_EDIT_FALSE
	je	DelNotBigEdit		;brif not in a BigEdit
	mov	[bigEditState],BIG_EDIT_CANCEL
DelNotBigEdit:
	sub	ax,ax			;return FALSE
	jmp	SHORT DelExit



;**************************************************************
; ushort FAR TxtChange(otxDelFirst, otxDelLast, fNoInsert)
;
; Purpose:
;	The editor or ASCII Loader calls TxtChange() to
;	replace zero or more lines with zero or 1 line of text
;	in the current text table.  If no new text is to be inserted,
;	but only deleted, call TxtChange with fNoInsert <> 0.
;	TxtDescan() should be called before this, to ensure that
;	the text table is descanned to SS_PARSE state.
;
; Note: This function need not worry about the case where the
;	user is trying to insert something between a line with $INCLUDE
;	and an included line below it, because the user interface
;	does not allow ANY editting while 'View/Include Files' is active.
;
; Entry:
;	grs.oMrsCur, grs.oPrsCur have their usual meaning
;	ps.bdpSrc contains source line to be inserted
;	parm1: ushort otxDelFirst - text table offset to opBol
;	   opcode for 1st line to delete.  It also indicates where
;	   new line is to be inserted.
;	parm2: ushort otxDelLast - text table offset to opBol
;	   opcode beyond last line to delete
;	parm3: ushort fNoInsert - non-zero if no pcode should be inserted
;	   (i.e. only text deletion should occur
;
; Exit:
;	If no errors were encountered,
;	   the return value = txtErr.errCode = 0.
;	Else if an error occurred which we will overlook at entry time,
;	   but which must be considered fatal when we are going through
;	   each module's ReParse list in preparation to execute the program,
;	   return value = 0,
;	   txtErr.errCode = an offset into the QBI Message Table
;	   (MSG_xxx) or, if high bit is set, ps.bdpError contains the
;	   parser-built ASCII error message,
;	   The text is inserted in text table in an opReParse opcode.
;	   txtErr.fDirect is set to FALSE,
;	   txtErr.oMrs identifies the module with the error,
;	   txtErr.oPrs identifies the procedure (if any) with the error,
;	   txtErr.otx is an offset into the text table where the error
;	 was detected (otxDelFirst).
;	   txtErr.oSrcErr contains the column offset into the source line
;	 to the offending token.
;	Else if its a really serious error (like out-of-memory or syntax error),
;	   all txtErr fields are set as above, and return value = txtErr.errCode
;
; Major Steps of Algorithm:
;	 Delete the pcode to be replaced (taking some special action for
;	    some opcodes being deleted), giving user a chance to
;	    back out of edit if edit would prevent continuing.
;	 Parse line to be inserted, checking for variable manager/syntax errors,
;	    again giving user a chance to back out of the edit
;	 Scan pcode to be inserted for rude edits, again giving user a chance
;	    to back out of the edit.  This pcode scan can result in calling
;	    CantCont(), ModuleRudeEdit(), SystemDescan().
;	 If statement contains variable mgr/syntax errors, change pcode to
;	    be inserted to an opReParse, which has the actual ASCII source
;	    as an operand.
;	 Insert the new pcode (taking some special action for some opcodes
;	    being inserted).
;
;**************************************************************
cProc	TxtChange,<PUBLIC,FAR,NODATA>,<si,di>
	parmW	otxDelFirst
	parmW	otxDelLast
	parmW	fNoInsert
	localW	fInclude		
 	localW	cbIns
	localW	result
	localW	otxMrsDelFirst
	localW	oRsPreParse
	localW	oPrsPreParse
	localW	otxEndProc
	localB	flagsPrsPreParse
	localB	flagsTc
		FTC_GotEndProc		EQU 1
		FTC_GotEnterProc	EQU 2
cBegin
 DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<TxtChange err1>


	DbChk	Otx,otxDelFirst		;error if > txdCur.bdlText.cbLogical
	DbChk	Otx,otxDelLast		;error if > txdCur.bdlText.cbLogical

	mov	si,[otxDelFirst]
	sub	ax,ax
	mov	[txtErr.TXER_errCode],ax
	mov	[ps.PS_errCode],ax
	mov	[result],ax

	;We need to init these vars in case we don't call ParseLine.
	;(i.e. maybe the caller is only deleting text)
	mov	[flagsTc],al		;default local flags to 0
	mov	[fInclude],ax		;assume we'll see no $INCLUDE directive

	mov	ax,[grs.GRS_oPrsCur]
	mov	[oPrsPreParse],ax

	cmp	[bigEditState],BIG_EDIT_ACTIVE
	je	BigEditActive		;BpDeleted set by first BigEdit Call
					; to TxtChange.
	and	[flagsTm],NOT FTM_BpDeleted ;clear BP deleted flag

BigEditActive:
	cmp	[bigEditState],BIG_EDIT_CANCEL
	jne	TcNotBECancel		;brif not backing out of BigEdit
	jmp	TcRet			;backout of BigEdit if user CANCELed

TcNotBECancel:
	FLoadActive
	je	TcNotLoading		;brif not loading a file
	jmp	TcLoading1		;brif LOADing a file - makes ASCII
					; load MUCH faster.

	;We're not loading, make sure there is enough memory for the
	;inserted and deleted text, otherwise, it would be possible for
	;Search/Change to loose an existing line entirely - too rude.
	;We loosely approximate size of pcode being inserted as 200.
	;Don't check it for edits of immediate (FM2_File=0), since that
	;could prevent users from executing a SYSTEM statement in
	;the immediate window.
	
TcNotLoading:
	test	[mrsCur.MRS_flags2],FM2_File
	je	NotOmErr		;brif not editing a file
	cmp	[fNoInsert],0		;is there any text to parse and insert?
	jne	NotOmErr		;brif not - no need to reserve space
					; otherwise, user could get out of
					; memory, and not be able to delete
					; any text to recover - locked up.
	PUSHI	ax,200d
	call	TxtFree
	jne	NotOmErr
	jmp	TcOmErr
NotOmErr:


;********************* start of revision [56]
;No edits on pcode tables are allowed if there is a return address to
;the direct mode buffer and the direct mode buffer contains a label reference
	mov	al,[grs.GRS_flags]	
	and	al,FG_RetDir+FG_OtxInDir
	cmp	al,FG_RetDir+FG_OtxInDir
	jne	@F			;brif NOT (RetDir & OtxInDir)
	test	[mrsCur.MRS_flags2],FM2_NoPcode 
	jnz	@F			;brif this not a pcode buffer
	call	AskCantCont_CP		;ask user if he wants to continue
djmp	jz	TcRetGoDirect		;brif user wants to backout
@@:
;*********************** end of revision [56]

	;we're not loading, set DEFtypes etc. based on insert point.
	;if in module, traverse DEF-FN chain to otxDelFirst
	;and if we're inside a DEF-FN, PrsActivate that prs
	
	mov	bx,si			;bx = otxDelFirst
	cmp	[bigEditState],BIG_EDIT_ACTIVE 
	jne	TcFindPrs		;If not in a big edit, use passed
					; otxDelFirst.

	;If a big edit is active, we need to stop searching the DEF FN chain
	; at otxBigIns, since txt change gets called multiple times for a
	; big edit.  If we didn't do this, splitting a line immediately
	; prior to a DEF FN could cause us to search a Bogus DEF FN chain.

	mov	ax,[otxBigIns]		;get oTx for start of big edit
.errnz	UNDEFINED+1			
	inc	ax			;UNDEFINED if first call to txtchg
	je	TcFindPrs		;brif so, use oTxDelFirst
	dec	ax			;get back otxBigIns
	xchg	ax,bx			;bx = oTxBigIns
TcFindPrs:				
	push	bx			;pass offset to 1st byte of edit
	call	OPrsOfOtx		;ax = oPrs if si falls in DEF FN
	inc	ax			;test for UNDEFINED
	je	TcNotDefFn	

	;if we are in a big edit, we can't depend upon DEF-FN chain after
	; the first call to TxtChange.	Therefore, ask rude edit, to ensure
	; that there is no prs for the DEF-FN.	Subsequent calls will use
	; the DEF FNs mrs.
	cmp	[bigEditState],BIG_EDIT_ACTIVE
	jne	TcNotBigE		;DEF-FN chain is ok.

; Assert that TcUndo won't take unexpected actions for early termination.
DbAssertRel [cbBigIns],e,0,CP,<TxtChange: DEF FN-error1>
DbAssertRel [bdlTxtScrap.BDL_status],e,NOT_OWNER,CP,<TxtChange: DEF FN-error 2>
	call	AskRudeEdit		;see if user wants to back out of edit
	jne	short TcNotDefFn	;use module Rs.
	jmp	TcUndo			;brif user wanted to back out of edit


TcNotBigE:
	dec	ax			;restore ax = oPrs we're in
	push	ax			;otxDelFirst falls within a DEF FN
	call	PrsActivateCP		;activate it (for var mgr)

;     *--------------------------------------------------------------
;     * Examine the block of pcode being deleted opcode by
;     * opcode, taking special action for each opcode of
;     * interest.  May result in AskCantCont, ModuleRudeEdit, SystemDescan.
;     * 
;     *---------------------------------------------------------------

TcNotDefFn:
	test	[mrsCur.MRS_flags2],FM2_NoPcode
	jne	TcInBigEdit		;brif editing document or immediate
					; window - no need to ever back out
					; of edit.  If we didn't do this,
					; we could get out-of-memory error
					; when trying to delete immediate window
					; history, which we do when we're
					; trying to recover from tight memory
	cmp	[bigEditState],BIG_EDIT_FALSE
	jne	TcInBigEdit		;brif we're in a BigEdit, if so
					;TxtStartBigEdit already set this
					;flag, and TxtDelete may have been
					;called independantly of TxtChange
	mov	[fFillScrap],1		;tell TxtDelete to copy text to scrap
					; so we can back-out of edit
TcInBigEdit:
	push	si			;pass otxDelFirst
	push	[otxDelLast]
	call	TxtDelete		;delete the text
	mov	[fFillScrap],FALSE
	jne	TcDelOk			;brif TxtDelete returned FALSE in ax

TcRetGoDirect:				
	mov	[result], MSG_GoDirect	

J1_TcRet:
	jmp	TcRet			;brif user wants to back out of edit
					;just return without doing anything

;Set up ps.tEtCur[] with the default types for this point in the source
;
TcDelOk:
					;save current oRs for reactivation
					; after Redefining/Deleting undefined
					; prs entries. It is guaranteed that
					; that this is safe, since SUB/FUNCs
					; only get PrsFreed at ?rsDiscard time.
					; DEF FNs have the Mrs active at edit
					; time.
	call	ChkAllUndefPrsSaveRs	;Find new "defining" references for all
					; Prs entries which had defining.
					; references deleted. If no more
					; references to prs exist, free it.
	cmp	[fNoInsert],0		;is there any text to parse and insert?
	jne	J1_TcRet		;brif not - finished

; We can't call OtxDefTypeCur if accumulating opReparses for BigEdit,
; since the linked list are not updated until we start processing the
; reparse list at TxtEndBigEdit time.  The processing of the reparse
; list will insure the the DEF type state is accurate.

	cmp	[bigEditState],BIG_EDIT_ACTIVE
	je	TcDoReParse		;brif we're accumulating BigEdit
					;changes, but TxtEndBigEdit has not
					;been called yet
	mov	ax,si			;ax = text offset
	call	OtxDefTypeCur

TcLoading1:
	test	[mrsCur.MRS_flags2],FM2_NoPcode
	je	TcNotDoc		;brif not a document module

	;this module is not BASIC source, just text (maybe Scrap,
	; command window, document file)
	
TcDoReParse:
	call	ResetDstPbCur		;so ParseUndo won't do anything
	jmp	TcReParse1

;Parse the source line to pcode
TcNotDoc:
	;tell parser (and type manager) to recognize any TYPEs which have been
	; declared before the place this line is being inserted.  This
	; prevents forward referencing of types, which BASCOM cannot support.
	
	mov	[ps.PS_otxLine],si	

	;Call the parser to parse the source line.  grs.oPrs is updated
	;if a SUB/FUNCTION/DEF statement for an as yet undefined procedure
	;is parsed, in which case, the we insert the text at the beginning
	;of the new text table.
	
	mov	ax,[grs.GRS_oPrsCur]
	mov	[oPrsPreParse],ax
	mov	ax,[grs.GRS_oRsCur]	;save Entry so we can tell UI to
	mov	[oRsPreParse],ax	; display new text table if we create
					; a new SUB/FUNCTION.
	mov	al,[prsCur.PRS_flags]	;get prs flags in case we insert a
	mov	[flagsPrsPreParse],al	;SUB/FUNCTION statement.  If we are
					; just renaming then FP_DEFINED will
					; have be cleared when the Sub/Func
					; was deleted.

Retry:
	mov	[ps.PS_flags],0
	call	ParseLine
	jnc	TcNoParseErr		;brif parser encountered no error

	;ParseLine encountered some error
	mov	ax,[oPrsPreParse]
	call	TxtParseUndo
	test	[ps.PS_flags],PSF_UndoEdit
	jne	J1_TcUndo		;brif user said he wants to back out
					; of the edit while we were in ParseLine
					; (i.e. ParseLine called AskCantCont)
	test	BYTE PTR [ps.PS_errCode + 1],PSERR_fRude / 100h
	je	TcNotRude		;brif error isn't cause for a rude-edit

	;Variable manager returned an error code which
	;means a RudeEdit is being performed.
	;Save the line in an opReParse, but do not report the error to
	;the user.  SsDescan the module to SS_Rude (if the user wants
	;to go through with the edit).
	;See if user wants to back out of edit or descan to SS_RUDE
	
	call	AskRudeEdit		;see if user wants to back out of edit
	jne	TcNotRude		;brif user didn't back out of edit
J1_TcUndo:
	jmp	TcUndo			;undo delete (if any) and return

;See if the parser wants us to try parsing this line again.  This can
;happen when:
; We saw something that made us need to ModuleRudeEdit, but part
;     of the line's pcode had already been emitted in SS_PARSE
; Variable manager could not add a variable, because variable heap
;     was locked (because we can CONTinue).  Parser called AskCantCont
;     and now wants us to try again (much easier than trying to call
;     varmgr again from within parser).
;
TcNotRude:
	test	[ps.PS_flags],PSF_fRetry
	jne	Retry			;brif ParseLine wants us to try again
	jmp	SHORT TcParseErr	

TcNoParseErr:				
	
;     *--------------------------------------------------------------
;     * At this point, source line has been parsed with no errors.
;     * Examine the block of pcode being inserted opcode by
;     * opcode, calling a text-mgr routine for each opcode of interest.
;     * Each of these routines in addition to doing other work,
;     * returns a value which will cause either
;     * No Action, ModuleRudeEdit(), SystemDescan(), or CantCont().
;     * 
;     * NOTE: When reviewing changes to this block, make sure it isn't possible
;     * to take some state-changing action, then encounter an error which
;     * causes the edit to be discarded (AskCantCont or MakeOpReParse).
;     * In general, it is safer to 'remember' state changing actions to
;     * be taken, and take them when the pcode has actually been inserted.
;     *
;     *--------------------------------------------------------------

	call	ChkAllUndefPrsSaveRs	;check all undefed prs entries
					;in case this was a rename

	push	[ps.PS_bdpDst.BDP_pb]
	PUSHI	ax,<CODEOFFSET tOpPreIns>
	call	TxtFindOpDS		;ax = ptr to 1st interesting opcode
PiLoop:
	cmp	dl,PI_opEot
	je	J1_PiDone		;brif done with loop
	xchg	di,ax			;di = ptr to current opcode
	sub	dh,dh			;dx = dispatch index
	shl	dx,1			;dx = dispatch offset
	mov	ax,di			;ax = pointer to opcode of interest
	sub	di,[ps.PS_bdpDst.BDP_pb] ;convert ptr to offset in case
 					; dispatched function causes
					; ps.bdpDst to move
	mov	bx,dx			;bx = dispatch offset
	jmp	WORD PTR cs:PiDispatch[bx]

;All the PiOpxxx dispatches either branch to an error handler, or PiNext
PiNext:
	add	di,[ps.PS_bdpDst.BDP_pb] ;convert offset back to pointer
	push	di			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpPreIns>
	call	TxtFindNextOpDS		;ax = pointer to next opcode of interest
	jmp	SHORT PiLoop

J1_PiDone:
	jmp	SHORT PiDone		;finished with loop

TcParseErr:				
	mov	ax,[ps.PS_oSrcErr]
	mov	[txtErr.TXER_oSrc],ax
	mov	ax,[ps.PS_errCode]
	mov	dx,ax
	.errnz  PSERR_fAsciiMsg - 8000h	;TxtChange callers assume it is high bit
	and	ah,(PSERR_fAsciiMsg + PSERR_errCode) / 100h
					;mask off parser flags
	;pass error code in ax to TcReParse or TcAlert
	test	dh,PSERR_fAlert / 100h
	jne	TcAlert			;serious error, event at entry time,
					; let alone reparse time
	jmp	SHORT TcReParse		;brif not a serious error

;ax = error code
TcAlert0:
	mov	[txtErr.TXER_oSrc],UNDEFINED
					;for txtmgr detected errors, we cant 
					;detect the column, compute from otx
	
	;Encountered some error, make sure entry prs is active before
	;Undoing the change.  This solves the bug where you enter a
	;SUB line and the SUB already exists, but is undefined
	; (SUB stmt is a reparse).  The line parses without error, and
	;the parser changes to the new prs.  When we call PrsMake, we
	;get a duplicate definition error.  We were getting here with
	;the wrong prs active.
	
	mov	bx,[oPrsPreParse]
	cmp	bx,[grs.GRS_oPrsCur]
	je	TcAlert 		;brif parser didn't move into a new PRS
	push	ax			;save error code
	push	bx
	call	PrsActivateCP		;get back to module level/old prs
	pop	ax			;recover error code
TcAlert:
	cmp	[fSyntaxCheck],0
	je	TcReParse		;brif user has disabled editor
					; syntax error reporting
	mov	[result],ax		;serious error - return code in ax
TcReParse:
	mov	[txtErr.TXER_errCode],ax
TcReParse1:
	mov	ax,[oPrsPreParse]
	call	TxtParseUndo		;undo any changes to prs table or
					; name table which parsing this
					; line caused.

	test	[ps.PS_flags],PSF_fRudeIfErr
	je	MakeOpRp

	;Some irreversible action took place, like calling varmgr to
	;create a CONSTant, and then some error took place.  The user
	;already said he didn't want to CONT before PSF_fRudeIfErr was
	;set, so its ok to blow away the module's variable table.
	
	call	ModuleRudeEdit	
MakeOpRp:
	call	MakeOpReParse
	and	[flagsTc],NOT (FTC_GotEndProc+FTC_GotEnterProc)
	jmp	SHORT TcPrescanDone	;don't call LoadEnterProc, LoadExitProc

;si = otxDelFirst
PiDone:
	FLoadActive
	jne	TcPrescanDone		;brif LOADing a file
	test	[txdCur.TXD_flags],FTX_mrs
	jne	TcPrescanDone		;brif we're in a module's text table

	call	ChkInsProc		;see if valid line to insert in proc
	je	TcPrescanDone		;brif valid line
	jns	TcAlert0		;brif illegal
	jmp	J1_TcUndo		;user wants to back out of edit

;MakeOpReParse could have resulted in an out-of-memory error
;check for it
;si = otxDelFirst
;
TcPrescanDone:
	mov	ax,[ps.PS_errCode]
	cmp	al,ER_OM
	je	J1_TcOmErr		;brif out-of-memory error

;     *--------------------------------------------------------------
;     * At this point, the user does not want to back out of the edit
;     * for the sake of edit & continue, and we are not going to
;     * convert the line to an opReParse due to errors.
;     *--------------------------------------------------------------

	sub	[ps.PS_bdpDst.BDP_cbLogical],2 ;don't count opEot as part
					   ; of the line to be inserted

;make room for new text by copying old text up in memory
;making sure there's enough free space in the current text table
;to insert the pcode we want to insert
;si = otxDelFirst
;
TcDoMove1:
	mov	ax,[ps.PS_bdpDst.BDP_cbLogical]
	mov	[cbIns],ax
	call	TxtInsert		;insert ps.bdpDst in text table @ si
	je	J1_TcOmErr		;brif out-of-memory

;     *--------------------------------------------------------------
;     * If we've gotten a SUB or FUNCTION statement
;     *    Move SUB/FUNCTION statement to a new PRS text table,
;     *    generating synthetic DEFxxx statements, and keeping leading
;     *    comments in SUB/FUNCTION's text table.
;     *
;     * NOTE: LoadEnterProc modifies ps.bdpDst
;     * It also moves REMs from the module table to the start of
;     * the procedure text table, since these REMs may be a proc header.
;     * otxDelFirst (si) is updated to reflect this insert.
;     * 
;     *--------------------------------------------------------------
;
TcAfterIns:
	test	[flagsTc],FTC_GotEnterProc
	je	TcNoEnterProc		;brif not inserting SUB/FUNC stmt
	sub	si,[txdCur.TXD_bdlText_cbLogical]
	push	[otxMrsDelFirst]
	call	LoadEnterProc		;move pcode from module to proc tbl
	jne	TcNotOm3
	call	PrsDeactivate		;make module active for error recovery
J1_TcOmErr:
	jmp	TcOmErr			;brif out-of-memory error

TcNotOm3:
	;update otxDelFirst after copying leading remarks, defints etc. to prs
	add	si,[txdCur.TXD_bdlText_cbLogical]

;     *--------------------------------------------------------------
;     * Call TxtInsUpdate to examine every opcode which was inserted
;     * in the text table, taking any opcode specific action required.
;     * 
;     *--------------------------------------------------------------
;
TcNoEnterProc:
	mov	bx,si			;bx = updated otxDelFirst
	add	bx,[cbIns]		;bx = offset beyond inserted pcode
	call	TxtInsUpdate		;update program counter and other
					; static entries which are affected
					; by pcode movement.
	je	J1_TcOmErr		;brif out-of-memory

	cmp	[bigEditState],BIG_EDIT_FALSE
	je	TcNotInBigEdit		;brif we're not accumulating BigEdit
					; changes
	test	[flagsTc],FTC_GotEnterProc 
	jnz	TcNoIncr		;don't increment cbBigIns if proc
	mov	ax,[cbIns]		
	add	[cbBigIns],ax		;remember how much text we've inserted
TcNoIncr:
	cmp	si,[otxBigIns]
	jae	TcNotInBigEdit
	mov	[otxBigIns],si		;remember base of inserted pcode
					; (so we can later back out of BigEdit)

;     *--------------------------------------------------------------
;     * If we've gotten an END SUB or END FUNCTION statement
;     * restore the module's text table.
;     * 
;     *--------------------------------------------------------------
;
TcNotInBigEdit:
	test	[flagsTc],FTC_GotEndProc
	je	TcNoExitProc
	FLoadActive
	je	TcNoExitProc		;brif not LOADing a file
	call	LoadExitProc		;clean up, return to Module level
	jnc	TcNoExitProc
	jmp	TcOmErr			;brif out of memory error

TcNoExitProc:
	test	[flagsTm],FTM_BpDeleted
	je	TcNoBp			;brif breakpoint was not deleted
	push	si			;pass otxDelFirst
	call	LnOfOtx			;ax = line text was inserted
	push	ax
	call	FAR PTR ToggleBp	;set breakpoint
	and	[flagsTm],NOT FTM_BpDeleted ;clear BP deleted flag
	cmp	[bigEditState],BIG_EDIT_ACTIVE
	jne	TcNoBp			;brif we're not accumulating BigEdit
					; changes
	add	[cbBigIns],2		;2 more bytes for inserted BP

;     *--------------------------------------------------------------
;     * If this line had an $INCLUDE 'filename' directive, recurse here.
;     *--------------------------------------------------------------
;
DbPub TcNoBp
TcNoBp:
	cmp	[fInclude],NULL
	je	J_TcRet 	       ;brif line contained no $INCLUDE
	cmp	[txtErr.TXER_errCode],0
	je     @F
J_TcRet:
	jmp	SHORT TcRet		; brif $INCLUDE line has error in it
@@:

	PUSHI	ax,<dataOFFSET b$SdBuf1>;bx = SD for filename.
	inc	[cInclNest]
	mov	ax,si			;ax = otxDelFirst
	add	ax,[cbIns]		;ax = offset beyond inserted text
	push	ax			;pass insertion point to LoadFile
	inc	[fLoadInclude]		; inform LoadFile of $INCLUDE
	call	LoadFile		;merge the $INCLUDE file
	dec	[fLoadInclude]		; reset flag
	dec	[cInclNest]
	or	ax,ax
	jz	TcNoErr			;brif no $INCLUDE error
					; If we fell into TcRet, we would
					; be over-writing errors already
					; recorded by recursive calls to
					; TxtChange via LoadFile.
TcIncErr:				
	push	ds
	pop	es			;ES=DGROUP for stosw
	mov	di,[ps.PS_bdpDst.BDP_pb]
	mov	[ps.PS_bdpDst.BDP_cbLogical],6
	mov	ax,opReParse
	stosw				;insert opReParse in text table
	mov	ax,2
	stosw				;insert cb field in text table
					;garbage link field is ok for now

	xchg	ax,si			;pass otxDelFirst in ax
	call	TxtSkipOp		;ax = adr of 1st opcode after Bol
	xchg	si,ax			;si = adr of place to insert opReParse
	call	TxtInsert
	mov	bx,si
	add	bx,6			;bx = offset beyond inserted pcode
	call	TxtInsUpdate

TcRet:
	cmp	[txtErr.TXER_errCode],0
	je	TcNoErr

	;tell caller which Mrs & Prs the error occurred in
	mov	[txtErr.TXER_fDirect],FALSE 
	mov	ax,[grs.GRS_oRsCur]
	mov	[txtErr.TXER_oRs],ax
	mov	[txtErr.TXER_otx],si
TcNoErr:
	cmp	[bigEditState],BIG_EDIT_FALSE
	jne	TcExit			;brif in a BigEdit, accumulate changes
	cmp	[bdlTxtScrap.BDL_status],NOT_OWNER	
	je	TcExit
	PUSHI	ax,<dataOFFSET bdlTxtScrap> 
	call	BdlFree			;release DELETE scrap
TcExit:
	test	[txdCur.TXD_flags],FTX_mrs ;make sure current oRs has a
					; text table
	je	TcExit1 		;brif sub or function is active
	call	PrsDeactivate		;deactivate DEF FN if any

TcExit1:
	DbChk	TxdOps			;see if TxtChange inserted bad opcode
	mov	ax,[result]		;return error code or 0 in ax
cEnd

TcOmErr:
	mov	ax,ER_OM		;out-of-memory error
	mov	[txtErr.TXER_errCode],ax
	mov	[result],ax
J2_TcRet:
	jmp	SHORT TcRet		;just return

;The user has decided to back out of the edit, because it would prevent CONT
;reinsert deleted text (if any).
;
; If bigEditState != BIG_EDIT_FALSE
;    If cbBigIns > 0, TxtDelete(otxBigIns, otxBigIns + cbBigIns)
;    bigEditState = BIG_EDIT_CANCEL
; If bdTxtScrap is not empty, Insert bdTxtScrap at otxScrap
;
TcUndo:
	mov	ax,MSG_GoDirect
	mov	[result],ax		;tell editor to stop the edit
	mov	[txtErr.TXER_errCode],ax
	cmp	[bigEditState],BIG_EDIT_FALSE
	je	NotInBigEdit		;brif not in BigEdit
	mov	cx,[cbBigIns]
	jcxz	TcNoIns			;brif no text has been inserted
	mov	ax,[otxBigIns]
	push	ax	
	add	ax,cx			;ax = offset beyond inserted text
	push	ax
	call	TxtDelete		;delete the inserted text
					; doesn't place deleted text in scrap
					; either because fFillScrap is false
					; or scrap is already in use
TcNoIns:
	mov	[bigEditState],BIG_EDIT_CANCEL
NotInBigEdit:
	cmp	[bdlTxtScrap.BDL_status],NOT_OWNER 
	je	J2_TcRet		;brif no text deleted - done with undo

	mov	ax,[bdlTxtScrap.BDL_cbLogical] ;ax = number of bytes in scrap
	cmp	ax,2			; check for empty scrap
	jb	J2_TcRet		; bfir empty scrap - done.

	mov	[cbins],ax		;store this in [cbins] static
;  CALL TxtInsScrap(si = otxScrap)	[9]
	mov	si,[otxScrap]		;si = insertion point in 
					;	current text table
	call	TxtInsScrap		;copy scrap back into text table and
					;	release bdlTxtScrap
	jz	TcOmErr
	jmp	TcAfterIns


;
;**************************************************************
; ChkInsProc
; Purpose:
;	We're not loading and we're inserting a line in a SUB/FUNCTION
;	text table.  This function sees if it is legal.
; Entry:
;	si = text offset where line is being inserted in SUB/FUNCTION
; Exit:
;	ax = error code if illegal line to insert in a SUB/FUNCTION
;	   = 0 if no error
;	   = negative number if user wants to back out
;	condition codes set based on value in ax
;
;**************************************************************
DbPub	ChkInsProc
ChkInsProc PROC NEAR
	DbChk	Otx,si			;error if > txdCur.bdlText.cbLogical
	push	di			;preserve caller's di
	test	[prsCur.PRS_flags],FP_DEFINED
	je	CiNotDefined		;brif proc has no SUB/FUNCTION stmt
	cmp	[prsCur.PRS_otxDef],si
	jae	CiNotDefined		;brif insertion is before definition
	jmp	CiDone			;insertion is after definition
CiNotDefined:
	;Trying to insert something into SUB/FUNCTION window before
	;the SUB/FUNCTION definition.  Only certain things can
	;be inserted before the definition - make sure this is
	;one of them
	
	push	si			;save si
	sub	si,si			;set fNonBolSeen=fSubOrFuncSeen=false
					; the high bit set means an opStSub,
					; or opStFunction has been seen,
					; when si is non-zero then we have
					; seen some non-bol/non opEot opcode.
	mov	di,[ps.PS_bdpDst.BDP_pb] ;di->start of pcode to insert (in DS)
;di = otxCur (into parser's DS pcode buffer ps.bdpDst)
CiLoop:
	mov	ax,[ps.PS_bdpDst.BDP_pb]
	add	ax,[ps.PS_bdpDst.BDP_cbLogical]
	dec	ax
	dec	ax
	cmp	di,ax
	jae	CiLoopExit		;brif done scanning line to be inserted
	push	di			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpPreProc>
	call	TxtFindNextOpDS		;ax = offset to next interesting opcode

	cmp	dl,PREPROC_bolMax	;are we looking at a bol opcode?
	jbe	CiLoopNext		;brif so
	cmp	dl,PREPROC_opEot	;at end of text?
	je	CiLoopNext		;brif so
	cmp	dl,PREPROC_opStEndProc	;is this an opStEndproc?
	jne	CiNotEndProc		;brif not
	or	si,si			;have we seen preceding OpStSub/Function
	jns	CiInvBeforeProc 	;brif not, illegal before SUB/FUNCTION
CiNotEndProc:
	cmp	dl,PREPROC_SubOrFuncMin ;is this opStSub or opStFunction?
	jb	CiNotSubOrFunc
	or	si,8000H		;set sub of function seen flag
CiNotSubOrFunc:
	or	si,1			;set fNonBolSeen flag

CiLoopNext:
	push	di			;pass otxCur
	mov	di,ax			;di = otxNext
	sub	ax,ax			;just get next opcode (not next found in
	push	ax			; some list)
	call	TxtFindNextOpDS		;ax = offset to next opcode
	cmp	ax,di
	je	CiLoop			;brif opcode is in list
	or	si,si			;have we seen a SUB or FUNCTION?
	js	CiLoop			;brif so - ok if after SUB.

	;some invalid opcode was found in line
CiInvBeforeProc:
	pop	si			;recover otx
	mov	ax,MSG_InvBeforeProcDef
	jmp	SHORT CiExit

CiLoopExit:
	or	si,si			;did we see a non-bol?
	pop	si			;recover otx
	jne	CiDone			;brif non-Bol seen
	cmp	[txdCur.TXD_bdlText_cbLogical],CB_EMPTY_TEXT ;is txt tbl empty?
	je	CiDone			;brif so, allow an opBol

;  Inserting a blank line, see if user will allow a single quote rem instead
;  We do this so ascii save/ascii load will be able to migrate
;  comment blocks correctly with text tables.
;

	sub	ax,[ps.PS_bdpDst.BDP_pb] ;convert ptr to offset, AskMakeRem
					; can cause heap movement
	xchg	ax,di			;di = offset to opEot
	call	AskMakeRem		;ask if usr would like a comment instead
	add	di,[ps.PS_bdpDst.BDP_pb] ;convert offset back to ptr to opEot
	or	ax,ax			;does user want to back out of edit?
	mov	ah,-1			;prepare for back-out
	je	CiExit			;return high bit set for backout
	mov	ax,opQuoteRem		;get single quote rem opcode
	xchg	ax,[di] 		;xchg opQuoteRem for opEot
DbAssertRel ax,e,opEot,CP,<ChkInsProc: expected opEot>
	push	ax			;push opEot (will be emitted last)
	sub	ax,ax
	push	ax			;push column for opQuoteRem
	inc	ax
	inc	ax			;2 bytes of REM (for column field)
	call	Emit16_AX		;emit cbRem
	call	Emit16			;emit Column (already on stack)
	call	Emit16			;emit opEot to ps.pbDst
					; (already on stack)
CiDone:
	test	[prsCur.PRS_flags],FP_ENDPROC
	je	CiOk			;brif proc has no END SUB/FUNCTION
	cmp	[ps.PS_bdpDst.BDP_cbLogical],4
	jbe	CiOk			;brif not inserting a blank line

	;user is trying to append something more than a blank
	;line (opBol,opEot).  See if its beyond the END SUB/FUNCTION statement
	
	sub	ax,ax			;search from top of table
	push	ax
	PUSHI	ax,<CODEOFFSET tOpEndProc>
	call	TxtFindOp		;ax = offset to END SUB/FUNCTION
	cmp	ax,si
	jae	CiOk			;brif inserted before END SUB/FUNCTION
	mov	ax,MSG_EndProc
	SKIP2_PSW			;skip next instruction
CiOk:
	sub	ax,ax			;return FALSE (no error)
CiExit:
	or	ax,ax			;set condition codes for caller
	pop	di			;restore caller's di
	ret
ChkInsProc ENDP



;-------------------------------------------------------------------
; Opcode specific code which gets executed BEFORE pcode is inserted
; in text table.  Pixxx stands for Pre Insert <opcode name>
; All of this 'functions' enter with:
;     si = otxDelFirst
;     di = offset into pcode buffer 'ps.bdpDst'
;     ax = pointer into pcode buffer 'ps.bdpDst'
; When they've completed their work, they branch to one of:
;   PiNext - normal exit when everything looks ok
;   TcUndo - when user has been warned that the edit would prevent
;     continuing, and the user responded CANCEL.
;   TcAlert0 - ax = error code, when error is to be reported to user
;     and line is to be saved as an opReParse
;   TcReParse - ax = error code, when error is NOT to be reported to user
;     immediately (unless we're going through the reparse loop in preparation
;     to execute a direct mode statement).  The line is saved as an opReParse.
;   TcOmErr - if some memory allocation couldn't be satisfied.
;
;-------------------------------------------------------------------

;extract filename out of OpStInclude(cnt,filename) and/or op_Include
;di points to (opcode,cb,text)
DbPub	PiInclude
PiInclude:
	push	ax
	call	AskCantCont_CP		;see if user wants to back out of edit
	pop	ax
	jne	PiInclCont		;brif ok to edit
	jmp	TcUndo			;brif user wanted to back out of edit

PiInclCont:
	cmp	[cInclNest],INCLUDE_DEPTH_MAX
	jb	NotTmf
	or	[flagsTm],FTM_reInclude	;cause all $INCLUDE lines to be
					;reparsed before next RUN
					;so we'll report the error again.
	mov	ax,ER_TMF		;error: Too many files
J2_TcAlert0:
	jmp	TcAlert0

NotTmf:
	push	si			;preserve otxDelFirst
	push	di			;save offset of opcode
	add	di,[ps.PS_bdpDst.BDP_pb] ;convert offset to pointer
	add	di,4			;point to first byte of operand
	push	di			;pass pSrc to CopyBlk

	push	ds
	pop	es			;set es = dgroup
	mov	cx,-1
	mov	al,27H			;search for terminating ' in filename
	repne	scasb
	not	cx			;cx = length of filename including '
	dec	cx			;cx = length of filename
PiOpStInc:
	cmp	cx,FILNAML		;compare length of name 	[8]
					; to length of static buffer
	jb	NotTooBig		;brif OK
	mov	ax,ER_IFN		;report bad filename error
	jmp	SHORT J2_TcAlert0
NotTooBig:
	mov	[fInclude],sp		;set flag for loading of include file
	DbChk	HoldBuf1		;ensure availability of Buf1 [8]
	mov	si,dataOFFSET b$SdBuf1	;si ptr to sd for B$Buf1
	mov	[si.SD_cb],cx		;save filename length
	push	[si.SD_pb]		;pass ptr to B$Buf1
	push	cx			;pass cb to copy
	call	CopyBlk 		;copy $INCLUDE's operand to temp buffer
					; we just 0-terminated filename for
					; FileExists, set cbLogical to real len
	pop	di			;recover opcode offset
	pop	si			;recover otxDelFirst
J1_PiNext:
	jmp	PiNext

DbPub	PiOpStSub
PiOpStSub:
PiOpStFunction:
	FLoadActive
	jne	CheckNestedProcs	;brif loading
	;Parser ensures that we will be in SS_RUDE when an insertion
	;of a SUB or FUNCTION statement is seen.
	cmp	[oPrsPreParse],UNDEFINED ;were we in a sub or function?
	je	NotNestedProcs		;brif not - user entered SUB/FUNCTION
					;statement in module level text table

	;If we are renaming a SUB/FUNCTION, then the deletion of the
	;SUB/FUNCTION line caused the FP_DEFINED flag to be reset.
	;If the user just entered a SUB/FUNCTION statement in a SUB or
	;FUNCTION, the FP_DEFINED bit will still be set.  If the user
	;happened to be trying to insert a SUB or FUNCTION, in a SUB
	;or FUNCTION that has been commented out, then this new SUB/FUNCTION
	;statement will inherit the text table instead of creating a new
	;SUB.
	
	test	[flagsPrsPreParse],FP_DEFINED ;is this a rename?
	je	J1_PiNext		;brif so, prs already exists.
	jmp	SHORT NotNestedProcs

CheckNestedProcs:
	;See if we were in an unterminated SUB/FUNCTION.  If so,
	;then we need to call LoadExitProc to clean up the previous
	;call to LoadEnterProc.
DbAssertRelb [fMergeInSub],e,0,CP,<TxtChange: fMergeInSub TRUE when sub/func ins>

NotMergingInSub:
	cmp	[oPrsPreParse],UNDEFINED ;were we in a SUB/FUNCTION?
	je	NotNestedProcs		;brif not
	push	[grs.GRS_oPrsCur]	;push oPrsCur for PrsActivate after
					;call to load exit proc
	push	[oPrsPreParse]
	call	PrsActivateCP		;activate the previous PRS
	call	LoadExitProc		;clean up it's state
	jnc	NotOmErr2		;brif not out of memory error
PiTcOmErr:				
	jmp	TcOmErr
NotOmErr2:
	xchg	si,ax			;si = otx of insertion point in
					; module's text table
	call	PrsActivateCP		;activate new Prs(oPrs already on stack)

NotNestedProcs:

	;If in ASCII Load, or the user entered SUB or FUNCTION in
	;the current window. Parser called PrsDefine to
	;create the proc's context and make it current.
	;Now make the SUB/FUNCTION's text table
	
	push	[prsCur.PRS_ogNam]	
	push	WORD PTR([prsCur.PRS_procType])
	call	PrsMake
	or	ax,ax			
	jne	JNE_J1_TcAlert0 	;brif PrsMake err

	;Proc definition will be inserted at start of newly created text
	;table.  Remember where we were in module's text table so we
	;can tell LoadEnterProc()
	
	mov	[otxMrsDelFirst],si
	SetStartOtx si			;set otxDelFirst to 0
	or	[flagsTc],FTC_GotEnterProc ;set TRUE
	FloadActive			;don't change window contents if
	jne	J1_PiNext		; ascii loading
	push	[grs.GRS_oRsCur]
	call	WnResetMove		;tell UI that new SUB/FUNC is active
	mov	[txdCur.TXD_lnCursor],1 ;position new window's cursor at line 1

	mov	ax,[ps.PS_bdpDst.BDP_pb] ;bx->start of pcode for cur line
	push	ax			
	PUSHI	ax,<CODEOFFSET tOpEndProc> 
	call	TxtFindOpDS		;dl = index into tOpEndProc table
	cmp	dl,ENDPROC_opStEndProc	;does parse buf already have an
					;end proc (e.g. was it
					;SUB FOO:END SUB)?
	je	J3_PiNext		;brif so - don't insert endproc


	mov	cx,6			;size of 2 bols and opStEndProc
	call	CheckFreeDstBuf 	;see if enough room in parser buf
	jz	PiTcOmErr		;for inserted pcode. brif not

	sub	[ps.PS_bdpDst.BDP_cbLogical],2 ;eat the opEot
	sub	[ps.PS_bdpDst.BDP_pbCur],2 ;eat the opEot
	.errnz	opBol
	sub	ax,ax			;ax = opBol
	call	Emit16_AX		;emit opBol to parser buf to create
					; a blank line
	.errnz	opBol
	sub	ax,ax			;ax = opBol
	call	Emit16_AX		;emit opBol to parser buf
	mov	ax,opStEndProc
	call	Emit16_AX		;emit opStEndProc to parser buf
	mov	ax,opEot
	call	Emit16_AX		;emit opEot to parser buffer
J3_PiNext:
	jmp	SHORT J2_PiNext

PiOpStEndProc:
	mov	ax,MSG_InvMain		;Illegal in main program
	test	[txdCur.TXD_flags],FTX_mrs
JNE_J1_TcAlert0:
	jne	J1_TcAlert0		;brif we're looking at module text table

	mov	ax,MSG_InvIncl		;error msg = illegal in include
	test	[mrscur.MRS_flags2],FM2_Include 
	jne	J1_TcAlert0		;error if this is an include module
	cmp	[cInclNest],0		
	jne	J1_TcAlert0		;error if merging include file

	test	[prsCur.PRS_flags],FP_ENDPROC
	jne	LastNotEndErr		;brif already has END SUB
	call	OtxEndProg		;ax = otxEndProg (end of user pcode)
	cmp	si,ax
	je	PiGotEndProc		;brif inserted at end of text
DbAssertRel	ax,a,si,CP,<TxtChange: insertion point of End Proc beyond opEndProg>
	sub	ax,si			;ax = cbDelta from Insertion point
					; to opEndProg
	push	ax
	GetSegTxtCur			;es = text segment
	pop	bx			;bx = cbDelta

	;look at all opcodes between opEndProg (exclusive) and insertion point
	;don't allow any opcode except opBol (i.e. only allow trivial blank
	;lines from END SUB/FUNCTION to opEndProg. Start search at opcode
	;prior to opEndProg, and terminate at insertion point.
	

EndProcBlankSearch:
	mov	ax,es:[si+bx-2] 	;ax = opcode

.errnz	opBol
	and	ax,OPCODE_MASK		;mask out spaces
	jne	LastNotEndErr		;brif found non opBol opcode
	dec	bx
	dec	bx			;advance to next opcode
	jne	EndProcBlankSearch

PiGotEndProc:
	FLoadActive
	je	NotMergingInSub1	;brif not loading
	cmp	[fMergeInSub],0		;non-zero if MERGING a file into a SUB
	je	NotMergingInSub1
MrgInSubErr:				
	mov	ax,MSG_InvProc		;illegal in SUB/FUNCTION
	jmp	TcReParse		

NotMergingInSub1:
	or	[flagsTc],FTC_GotEndProc ;set TRUE
J2_PiNext:
	jmp	PiNext

;user is inserting END SUB in window that has one, or before end of table
LastNotEndErr:
	mov	ax,MSG_EndProc
J1_TcAlert0:
	jmp	TcAlert0

PiOpStShared:
	test	[txdCur.TXD_flags],FTX_mrs
	je	J2_PiNext		;ok if in procedure text table
	mov	ax,MSG_InvMain		;illegal outside SUB/FUNCTION/DEF FN
	jmp	SHORT J1_TcAlert0

;See if DATA statement is in a SUB or FUNCTION.  If we're ASCII loading,
;the statement will eventually be moved to module level.  If the user
;is editing, give an error.
PiOpStData:
	cmp	[fLoadInclude],FALSE	;[J2]
	jne	InvProcLevel		;[J2]
	FLoadActive
	jne	J2_PiNext		;brif loading (DATA stmts will be
					; moved from prs(s) to mrs at end of
					; load
InvProcLevel:				;[J2]
	test	[txdCur.TXD_flags],FTX_mrs
	jne	J2_PiNext		;ok if not in procedure text table
	jmp	short InvProcErr	;invalid in SUB or FUNCTION

;Opcodes which cause ModuleRudeEdit
;DEF FN within SUB/FUNCTION is caught in prsid.asm's MakeProc
PiOpEndSingleDef:
PiOpStEndDef:
	test	[txdCur.TXD_flags],FTX_mrs
	jne	NotInSub		;ok if not in procedure text table

InvProcErr:
	mov	ax,MSG_InvProc		;illegal in SUB/FUNCTION
	jmp	SHORT J1_TcAlert0

PiOp_Dynamic:
	mov	[fDynArrays],1		;set TRUE for ASCII Load
	jmp	SHORT PiOpStEndType	

PiOp_Static:
	mov	[fDynArrays],FALSE	;set FALSE for ASCII Load
	jmp	SHORT PiOpStEndType	

;Opcodes which cause SystemDescan
; The reason we can't depend on the variable manager to cause a rude edit
; when a NEW common variable is created (as it does for SHARED etc.)
; is because it is legal to have DIM x(1) followed by COMMON x().
; 
PiOpStCommon:				;scanner will rebuild common tables
PiOpStOptionBase0:			
PiOpStOptionBase1:			
PiOpStDefType:
	call	SystemDescanCP		;implicit parms in DECLARE, SUB,
					; FUNCTION stmts need to be rechecked
					; by the scanner

;When we insert an A as B in a TYPE/END TYPE block we need to take
; the system to SS_RUDE to force reevaluation of the TYPE block.
;When we insert a SHARED statement, we need to take the system to SS_RUDE
; for the Variable Manager.
;When inserting a CONST statement, we need to take the system to SS_RUDE,
; so that the rude scanner will evaluate the CONST expression.

NotInSub:
PiOpElemRef:
PiOpShared:
PiOpStConst:
PiOpStEndType:
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	J2_PiNext		; speed opt. - we're already rude
	call	AskRudeEdit		;see if user wants to back out of edit
	je	J2_TcUndo		;brif user backed out of edit
	jmp	Retry			;brif user didn't back out of edit
					;re-parse line, won't get back here,
					; because now text table is in SS_RUDE

J2_TcUndo:
	jmp	TcUndo			;undo delete (if any) and return

PiOpStFor:
	dec	[cForDel]		;cForDel = 1+#FOR stmts deleted 
					; by TxtDelete.
	jmp	SHORT PiInsFor

PiOpStForStep:
	dec	[cForStepDel]		;cForStepDel = 1+#FOR STEP stmts deleted
					; by TxtDelete.
PiInsFor:
	je	AskForCont		;brif we've inserted more FORs than
					; were deleted
	call	FindORsFrame		;see if active prs (if any) has a
					; frame on the stack
	or	ax,ax			
	je	J2_PiNext		;brif not found
					;else (can't edit buried prs FOR)
					; because it could require change in
					; frame size
AskForCont:
	call	AskCantCont_CP		;see if user wants to back out of edit
	je	J2_TcUndo		;brif user backed out of edit
	jmp	SHORT J2_PiNext		;brif user didn't back out of edit

; dispatch table used for processing inserted opcodes.
PiDispatch:
	DW	PiOp_Static
	DW	PiOp_Dynamic
	DW	PiInclude		
	DW	PiOpStSub
	DW	PiOpStFunction
	DW	PiOpStEndProc
	DW	PiOpEndSingleDef
	DW	PiOpStEndDef
	DW	PiOpStData
	DW	PiOpStShared
	DW	PiOpStDefType
	DW	PiOpStCommon
	DW	PiOpStEndType
	DW	PiOpStFor
	DW	PiOpStForStep
	DW	PiOpStConst
	DW	PiOpShared
	DW	PiOpStOptionBase0	
	DW	PiOpStOptionBase1	
	DW	PiOpElemRef



;**************************************************************
; TxtParseUndo
; Purpose:
;	We are about to make a line into an opReParse.
;	Any prs's that were created by this call to ParseLine
;	need to be freed.
;	We need to deactivate the active prs if it is
;	going to be freed.
; Entry:
;	ax = oPrs that was active before ParseLine was called.
;
;**************************************************************
cProc	TxtParseUndo,<PUBLIC,NEAR>	
cBegin
	cmp	ax,[grs.GRS_oPrsCur]
	je	NoDeact			;brif parser didn't move into a new PRS
	test	[txdCur.TXD_flags],FTX_mrs
	je	NoDeact			;brif new prs has text table (is
					; probably the result of renaming
					; a prs, and discovering an error
					; after the prs was renamed).
	push	ax
	call	PrsActivateCP		;get back to module level/old prs
NoDeact:
	call	ParseUndo		;We must call this before ModuleRudeEdit
					; or else we will try to free some
					; DEF FN prs's which no-longer exist
	call	ChkAllUndefPrsSaveRs	;check all undefed prs entries
					;in case parser created one before error
cEnd

;**************************************************************
; TxtInsert
; Purpose:
;	Insert a block of pcode in the current text table
; Entry:
;	si = text offset where new pcode is to be inserted
;	ps.bdpDst = buffer to be inserted
; Exit:
;	If out-of-memory, returns ax=0 and psw.z set
;
;**************************************************************
PUBLIC	TxtInsert
TxtInsert PROC NEAR
	push	si			;pass otxInsert
	push	[ps.PS_bdpDst.BDP_cbLogical] ;pass cbIns
	call	TxtMoveUp
	je	TInsExit		;brif out-of-memory error

	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	push	si			;pass otxInsert
	push	[ps.PS_bdpDst.BDP_pb]	;pass ptr to pcode to insert
	push	[ps.PS_bdpDst.BDP_cbLogical] ;pass cbIns
	call	BdlCopyTo		;copy from DS to text table
	mov	ax,sp
TInsExit:
	or	ax,ax			;set condition codes for caller
	ret
TxtInsert ENDP

;**************************************************************
; TxtInsBdl [40]
; Purpose:
;	Insert text from a bdl into current text table.
;
; Entry:
;	si = text offset where new pcode is to be inserted
;	di -> bdl to be inserted
;	ax = # bytes to be inserted. 
;		The start of the text to be copyied
;		is always StartOtx
; Exit:
;	If out-of-memory, returns ax=0 and psw.z set
;
;**************************************************************
PUBLIC	TxtInsBdl
TxtInsBdl PROC NEAR
	push	ax			;preserve cbInsert
	push	si			;pass otxInsert
	push	ax			;pass cbInsert
	call	TxtMoveUp		;move text starting at otxInsert
					; up by cbInsert bytes if possible
	pop	cx			;cx = cbInsert
	jz	TIBExit			;brif Out-of-Memory
	push	di			;pass source bdl
	SetStartOtx ax			
	push	ax			;pass otxSrc
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText> ;pass bdlDst
	push	si			;pass otxDst
	push	cx			;pass cbInsert
	call	BdlCopyFromTo		;copy text from the bdl into gap
	mov	ax,sp			;return non-zero
	or	ax,ax			;set condition flag
TIBExit:
	ret
TxtInsBdl ENDP

;*****************************************************************************
; TxtCopyScrap
; Purpose:
;	Copy a block of pcode from the current text table to bdlTxtScrap
;
;	Added as part of revision [9]
;	
; Entry:
;	parm1: otxStart: offset into text table for 1st byte to move
;	parm2: oDst: offset of where to place text in Scrap - if non-zero
;		this leaves a gap at the start of the buffer
;	parm3: cbMove: number of bytes to move
;	parm4: fDelete: true if TxtDelete is to be called to delete the text
;	FLoadActive should return FALSE if links in deleted text are
;	       up-to-date
; Exit:
;	If out-of-memory error, returns ax = 0, else ax = non-zero
;	   condition codes set based on value in ax
;
;*****************************************************************************
cProc	TxtCopyScrap,<PUBLIC,NEAR>,<di>
	parmW	otxStart
	parmW	oDst
	parmW	cbMove
	parmW	fDelete
cBegin
DbAssertRel [otxStart],ae,StartOtx,CP,<TxtCopyScrap: bad otxStart>
DbAssertRel [bdlTxtScrap.BDL_status],e,NOT_OWNER,CP,<bdlTxtScrap in use> 

	mov	di,[cbMove]		;di = cbMove for speed

;  CALL bdlAlloc(&bdlTxtTemp, cbMove + oDst)
	PUSHI	ax,<dataOFFSET bdlTxtScrap>
	mov	ax,di
	add	ax,[oDst]		;ax = cbMove + oDst
	jnz	TcsNotZero
	inc	ax			;cb can't be zero - this is needed
					;by TxtDelete
TcsNotZero:
	push	ax			;total number of bytes to allocate
	PUSHBDL_TYPE  pgtypEBGeneric,ax ; pass sb type for EB version
	call	bdlAlloc
	or	ax,ax
	jz	TcsExit			;exit if out-of-memory	

;  CALL bdlCopyFromTo(&txtCur.bdlText, otxStart, 	- source
;		      &bdlTxtscrap    , oDst,		- destination
;		      cbMove)				- number of bytes
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	push	[otxStart]
	PUSHI	bx,<dataOFFSET bdlTxtScrap>
	push	[oDst]
	push	di			;push cbMove
	call	BdlCopyFromTo		;no error is possible (checked above)

;  if (fDelete) CALL TxtDelete(otxStart, otxStart + cbMove)
	cmp	[fDelete],FALSE
	je	TcsReturnTrue		;brif we're not to delete text
	mov	ax,[otxStart]
	push	ax			;pass otxStart
	add	ax,di			;ax = otxStart + cbMove
	push	ax			;pass otxEnd
	call	TxtDelete		;delete pcode from prs's text table

TcsReturnTrue:
	mov	ax,sp			;return TRUE (no error)
TcsExit:
	or	ax,ax			;set condition codes for caller
cEnd

;**************************************************************
; TxtInsScrap
; Purpose:
;	Insert text in Scrap buffer into text table and release 
;	the Scrap buffer.
;
;	Added as part of revision [9]
;
; Entry:
;	si = text offset where new pcode is to be inserted
;	bdlTxtScrap = buffer to be inserted
; Exit:
;	If out-of-memory, returns ax=0 and psw.z set
;
;**************************************************************
PUBLIC	TxtInsScrap
TxtInsScrap PROC NEAR
	push	di			;preserve caller's di
	DbChk	Otx,si			

	mov	di,dataOFFSET bdlTxtScrap 
	mov	ax,[di.BDL_cbLogical]	
DbAssertRel	ax,ae,2,CP,<TxtInsScrap: tried to insert empty scrap> 
					
	call	TxtInsBdl		
	jz	TisExit			

; CALL BdlFree(&bdlTxtScrap)
	PUSHI	ax,<dataOFFSET bdlTxtScrap>
	call	BdlFree	

	mov	ax,sp
TisExit:
	or	ax,ax			;set condition codes for caller
	pop	di			;restore caller's di
	ret
TxtInsScrap ENDP

;--------------------------------------------------------------------
;
; Management of linked lists through a text table's pcode:
;
; TxtInsUpdate is called after ANY pcode has been inserted into
; any text table to update static variables and structures affected
; by the pcode inserted (prs definitions etc.).  Unfortunately,
; we cannot call UpdateLinks every time TxtChange is called during
; ASCII load, because it would be far too slow.  Instead, we call
; it for a block of lines from LoadEnterProc, LoadExitProc, and AsciiMerge.
;
;
; TxtChange TDataEnd TxtPrsInit SaveDeclares ToggleBp
;    |           |      |           |           |
;    +-----------+------+-----------+-----------+
;                       |
;	       TxtInsUpdate LoadEnterProc LoadExitProc AsciiMerge TxtEndBigEdit
;		     |	|	   |	       |	     |	      |
;	   +---------+	+----------+-----------+-------------+--------+
;	   |	     |		   |
;    UpdatePcs UpdatePrs       UpdateLinks
;
;--------------------------------------------------------------------

;**************************************************************
; TxtInsUpdate
; Purpose:
;	Called after TxtInsert to update program counter and other
;	static entries which are affected by pcode movement.
; Entry:
;	si = text offset where new pcode was inserted
;	bx = text offset beyond last byte of pcode inserted
;	If Loading a file (i.e. FLoadActive), or a big edit is active,
;	   UpdateLinks is not called.
;	   This makes ASCII Load and BLOCK CUT/COPY/PASTE MUCH faster
; Exit:
;	If out-of-memory, returns ax=0 and psw.z set
;	NOTE: Out-of-memory is only possible if opStData or opStRestore1
;	      is being inserted
;
;**************************************************************
cProc	TxtInsUpdate,<PUBLIC,NEAR,NODATA>,<di>
	localW	otxEndInsert
	localW	oRsSave
cBegin
	DbChk	Otx,si			;error if > txdCur.bdlText.cbLogical
	DbChk	Otx,bx			;error if > txdCur.bdlText.cbLogical
	mov	[otxEndInsert],bx

	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,CB_EMPTY_TEXT-StartOtx 
	cmp	bx,ax
	jae	TiDontUpd		;brif inserting before end-of-text
					; Could be true even if we're loading,
					; in case of FILE/MERGE, or $INCLUDE.

;     *--------------------------------------------------------------
;     * pass information about the edit to UpdatePrs in static struct uprs.UPRS_
;     * UpdatePrs will update the prs.otx field for all prs entries affected
;     * by this text insert.
;     * 
;     *--------------------------------------------------------------
;
	mov	ax,[grs.GRS_oRsCur]
	mov	[uprs.UPRS_oRsEdit],ax
	mov	[uprs.UPRS_otxEdit],si
	sub	ax,ax			;cbDel = 0
	mov	[uprs.UPRS_cbDel],ax
	sub	bx,si			;bx = cbIns
	mov	[uprs.UPRS_cbIns],bx	;pass cbIns

	;Update program counter and any other runtime text pointers
	push	si			;pass otxInsert
	push	bx			;pass cbIns
	push	ax			;pass cbDel (0)
	push	ax			;fTestOnly = FALSE
	call	UpdatePcs		;update program counter and any
					; stacked return addresses

	mov	bx,CPOFFSET UpdatePrs
	call	ForEachPrsInPlaceCPSav	;preserve callers oRs

; If we are in a text paste, then the inserted pcode can only
;  contain opBols and opReparses.  TxtPaste updates the line
;  count, so no further processing is needed.
;
TiDontUpd:
	test	[flagsTm],FTM_TxtPaste	;are we in a paste operation
	jne	TiExitTrue		;if so, exit

	push	si
	PUSHI	ax,<CODEOFFSET tOpAftIns>
	call	TxtFindOp		;ax = offset to 1st inserted opcode
					;dl = [txtFindIndex]
AiLoop:
	xchg	di,ax			;di = otxCur
	cmp	di,[otxEndInsert]
	jae	AiDone			;brif beyond inserted pcode
DbAssertRelB dl,b,AFTINS_opEot,CP,<TxtInsUpdate - found EOT before expected>
	cmp	dl,AFTINS_bolInclMax
	ja	AiChkBol		;brif not opBolInclude opcode
	inc	[txdCur.TXD_cLinesIncl] ;bump include line count
AiChkBol:
	cmp	dl,AFTINS_bolMax
	ja	AiDisp			;brif not opBol opcode
	inc	[txdCur.TXD_cLines]	;bump line count
AiDisp:
	sub	dl,AFTINS_dispMin	;adjust index for non-dispatched opcodes
	jc	AiNext			;brif no more work for this opcode
	sub	dh,dh			;dx = dispatch index
	shl	dx,1			;dx = dispatch offset
	mov	bx,dx			;bx = dispatch offset
	jmp	WORD PTR cs:AiDispatch[bx]
;All the AiOpxxx dispatches either branch to an error handler, or AiNext
AiNext:
	push	di			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpAftIns>
	call	TxtFindNextOp
	jmp	SHORT AiLoop

;     *--------------------------------------------------------------
;     * If we're not loading, update all linked lists which traverse
;     * the pcode that were affected by the edit.
;     * If we did this for every line during ASCII Load, load time
;     * would increase about 1000 percent.  For ASCII Load, we do
;     * it at the end of every procedure's text table, and finally
;     * at end of file.
;     * 
;     * This also applies to Big Edits.  To speed up block cut/copy/paste
;     * we will only update links at the end of a Big Edit.
;     *--------------------------------------------------------------
;
AiDone:
	FLoadActive
	jne	TiExitTrue		;brif LOADing a file
					; (speed optimization)
	cmp	[bigEditState],BIG_EDIT_ACTIVE
	je	TiExitTrue		;brif in a BigEdit

	push	si			;pass otxInsert
	push	[otxEndInsert]		;pass offset beyond inserted text
	call	UpdateLinks		;update linked lists through pcode
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.
TiExitTrue:
	mov	ax,sp			;return non-zero (success)
TiExit:
	or	ax,ax			;set condition codes for caller
cEnd	;TxtInsUpdate

AiDispatch:
	DW	AiOpBolLab
	DW	AiOpBolLabSp
	DW	AiOpLab
	DW	AiOpLabSp
	DW	AiOpStSub
	DW	AiOpStFunction
	DW	AiOpStDeclare
	DW	AiOpStCall
	DW	AiOpStCallS
	DW	AiOpStCallLess
	DW	AiOpStEndProc
	DW	AiOpEndSingleDef
	DW	AiOpStEndDef
	DW	AiOpStData
	DW	AiOpStRestore1


;-------------------------------------------------------------------
; Opcode specific code which gets executed AFTER pcode is inserted
; in text table.  Aixxx stands for After Insert <opcode name>
;
; di = offset into text table to opcode
;
;-------------------------------------------------------------------

;set bit that says the label by this name is defined
AiOpLab:
AiOpLabSp:
AiOpBolLab:
AiOpBolLabSp:
	lea	ax,[di+4]		;pass ptr to oNam field
	call	GetWOtx			;ax = label's oNam
	push	ax			;pass it
	PUSHI	ax,NM_fLineNumLabel
	call	SetONamMask		;set bit used for duplicate label check
	jmp	SHORT J1_AiNext

;See if this reference to oPrs is the "strongest" seen so far.
;If so, make it the owner of the prs entry, that is, make the
;prs entry refer back to this text offset.
;
AiOpStSub:
AiOpStFunction:
AiOpStDeclare:
AiOpStCall:
AiOpStCallS:
AiOpStCallLess:
	lea	ax,[di+4]		;ax = offset to oPrs field
definePrs:
	call	GetWOtx			;ax = referenced oPrs
	push	ax			;pass to PrsActivateCP

	mov	ax,[grs.GRS_oRsCur]	;ax = rs containing new reference
	mov	[oRsSave],ax
	mov	[dprs.DPRS_oRs],ax	;fill dprs structure for SetPrsDefn
	mov	ax,[grs.GRS_oMrsCur]
	mov	[dprs.DPRS_oMrs],ax
	mov	[dprs.DPRS_otx],di
	test	[mrsCur.MRS_flags2],FM2_INCLUDE ;is this an INCLUDE mrs?
	jne	SetRef			;force it to a "weak" owner

	mov	al,[txtFindIndex]
	mov	dl,FP_DEFINED
	cmp	al,AFTINS_opStDeclare	;compare with txtFindIndex
	jb	SetFlags		;brif not DECLARE or CALL reference
	mov	dl,FP_DECLARED
	je	SetFlags		;brif DECLARE reference
SetRef:
	sub	dl,dl			;else it must be a CALL reference
SetFlags:
	mov	[dprs.DPRS_flags],dl

					;parm was pushed several lines above
	call	PrsActivateCP		;activate referenced prs

	call	SetPrsDefn		;set its defn to dprs.xxx if strongest

	push	[oRsSave]
	call	RsActivateCP		;reactivate txt tbl containing the ref
J1_AiNext:
	jmp	AiNext

;If we're ASCII loading, DATA statements need to be moved from procedure
;level to module level, and RESTORE statements need to be adjusted to
;point to the module level label.  Call TDataEntry to mark where this
;DATA/RESTORE statement is.  The actual movement will be done by TDataEnd
;when the ASCII load completes.
;
AiOpStData:
	mov	al,DT_Data
	SKIP2_PSW			;skip next 2 byte instr (mov al,const)
AiOpStRestore1:
	mov	al,DT_Restore
	mov	bx,di			;bx = otxCur
	call	TDataEntry		;add entry to table, so we know
					; what needs to be moved at end-of-load
	jne	J1_AiNext		;brif no error
	jmp	TiExit			;return FALSE (out of memory)


AiOpEndSingleDef:
AiOpStEndDef:
AiOpStEndProc:
	;we got an END SUB/FUNCTION.
	;Remember we've seen an end-proc for this procedure
	
	or	[prsCur.PRS_flags],FP_ENDPROC
	jmp	SHORT J1_AiNext	
	


;**************************************************************
; ushort TxtBindPrs
; Purpose:
;	Called by TxtBindPrsS for each text prs.  See comments
;	in TxtBindPrsS.
;
;**************************************************************
TxtBindPrs PROC NEAR
	push	si			;save caller's si,di
	push	di
	DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<TxtBindPrs err1>
	mov	ax,[grs.GRS_oRsCur]	;Setup for call to SetPrsDefn
	mov	[dprs.DPRS_oRs],ax
	mov	ax,[grs.GRS_oMrsCur]
	mov	[dprs.DPRS_oMrs],ax

	sub	ax,ax
	push	ax
	PUSHI	ax,<CODEOFFSET tOpPrsDef>
	call	TxtFindOp		;ax=off to 1st opcode with oPrs operand
					;dl = [txtFindIndex]
TbLoop:
	mov	[dprs.DPRS_otx],ax	;pass otx to SetPrsDefn
	xchg	si,ax			;si = otxCur
	cmp	dl,PRSDEF_opEot
	jne	TbNotDone
	jmp	TbExit			;brif done with loop

TbNotDone:
	lea	si,[si+4]		;si = otxPrs
	cmp	dl,PRSDEF_opStDefFn
	jne	TbNotDefFn1		;brif not a DEF FN
	inc	si
	inc	si			;skip DEF FN's link field
; assert that scan state is SS_RUDE or SS_SUBRUDE
DbAssertRelb [txdCur.TXD_scanState],ae,SS_RUDE,CP,<TxtBindPrs: invalid scan state>
	jmp	TbNext			;leave DEF FN's operand as an oNam
					; when scanState is SS_RUDE
TbNotDefFn1:
	mov	ax,si
	call	GetWOtx			;ax = oNam or oPrs
	.errnz DCL_oPrs	- 2
	xchg	di,ax			;di = oNam or oPrs
	cmp	[fBindStatic],TBIND_Save1
	jne	TbBindNamToPrs
	jmp	TbBindPrsToNam		;brif binding oPrs to oNam


;convert oNam to oPrs for Binary Load
TbBindNamToPrs:
	mov	ax,si			;ax = otxPrs
	inc	ax
	inc	ax
	call	GetWOtx			;ax = procAtr field
	.errnz	DCL_atr - 4
	and	al,DCLA_oTyp		;al = proc's oTyp
	mov	dx,ax
	sub	cx,cx			;cx = FALSE
	mov	al,[txtFindIndex]	;al = opcode type
	cmp	al,PRSDEF_DefineMax
	DJMP	ja TbCall		; brif not DECLARE/SUB/FUNC/DEFFN

;Got a SUB/FUNCTION/DEFFN or DECLARE
	.errnz	PRSDEF_opStDeclare
	or	al,al
	jne	TbNotDeclare		;brif not DECLARE stmt

;Got a DECLARE stmt, dx = procAtr field
;
	mov	al,dh
	and	al,03h			;al = procType (PT_SUB, etc.)
	.errnz	DCLA_procType - 0300h
	cbw				;ax = prsType
	sub	dh,dh			;dx = oTyp
	push	di			;pass oNam
	push	ax			;pass proc type
	push	dx			;pass oTyp
	mov	al,1			;(can't push sp because PrsDefine
					; expects a byte parm)
	push	ax			;pass TRUE (for fDeclare)
	call	PrsDefine		;ax = error code
	or	ax,ax			
	jne	JNE1_TbErr		;brif error
	mov	al,FP_DECLARED		;al = flags for SUB/FUNCTION/DEF FN
	jmp	SHORT TbGotPrs

;Got a SUB/FUNCTION/DEF FN stmt
;al = txtFindIndex = proc type (PT_SUB etc.)
;dx = oTyp
;
TbNotDeclare:
	cmp	al,PRSDEF_opStDefFn
	jne	TbNotDefFn		;brif not DEF FN statement
					;SUBs and FUNCTIONs already have
					;a prs, no need to create one
	.errnz	ET_IMP
	or	dl,dl			;test dl for ET_IMP
	jne	TbNotDefType		;brif explicitly typed
	mov	ax,si			;pass text offset in ax
	call	OtxDefTypeCur		;fill tEtCur with default types for
					;this text offset

	cCall	OTypOfONamDefault,<di>	; ax = default oTyp
	xchg	dx,ax			;dx = default type
TbNotDefType:
	push	di			;pass oNam
	PUSHI	ax,PT_DEFFN		;pass procType (PT_DEFFN)
	DbAssertRelB dh,e,0,CP,<TxtBindPrs dh!=0>
	push	dx			;pass oTyp

	;pass fDeclare as FALSE if TBIND_Load, TRUE if TBIND_Save2
	;If we passed FALSE for TBIND_Save2, we'd get duplicate definition err
	;since prs is already declared.  In TBIND_Save2, we don't want to
	;create a prs entry, we just want to map an oNam to oPrs.
	
	sub	ax,ax
	mov	al,[fBindStatic]
	.errnz	TBIND_Load
	push	ax			;pass fDeclare
	call	PrsDefine
	or	ax,ax			
JNE1_TbErr:
	jne	TbErr			;brif error
TbNotDefFn:
	mov	al,FP_DEFINED		;al = flags for SUB/FUNCTION/DEF FN
TbGotPrs:
	mov	di,[grs.GRS_oPrsCur]	;di = oPrs
	DbAssertRel di,ne,UNDEFINED,CP,<TxtBindPrs err2>
	jmp	SHORT TbSetDefn

TbCall:
	;Got some kind of CALL statement
	push	di			;pass oNam
	PUSHI	ax,PT_SUB
	PUSHI	ax,UNDEFINED
	call	PrsRef			;ax = oPrs (or error code if MSB set)
	js	TbErr			;brif error (like out-of-memory)
	mov	di,ax			;save di = oPrs
	push	ax			;pass oPrs
	call	PrsActivateCP
	sub	al,al			;SetPrsDefn flags = 0 (CALL)
TbSetDefn:
	mov	[dprs.DPRS_flags],al
	call	SetPrsDefn		;definition is in static struct dprs
	push	[dprs.DPRS_oRs]
	call	RsActivateCP
	jmp	SHORT TbPut

;convert oPrs to oNam for Binary Save
TbBindPrsToNam:
	push	di			;pass oPrs
	call	FieldsOfPrs		;ax = prs's oNam.
	mov	di,ax			;di = oNam
TbPut:
	push	si			;pass otxPrs
	push	di			;pass oNam/oPrs
	call	PutWOtx
TbNext:
	push	[dprs.DPRS_otx]		;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpPrsDef>
	call	TxtFindNextOp
	jmp	TbLoop

;Error is not necessarily fatal, for example, during Binary Save
;TxtBindPrsS(0) is called, then TxtBindPrsS(TRUE) is called.  In this
;case, TxtBindPrsS(TRUE) will always report duplicate definition errors.
;The caller (binary Save) ignores errors - It is only meaningful
;during binary load.
TbErr:
	and	ah,7FH			;turn off MSB (set by PrsDefine)
	mov	[bindErrCode],ax
	jmp	SHORT TbNext

TbExit:
	mov	[txdcur.TXD_ScanState],SS_RUDE ;if binding change scanstate
					;from SUBRUDE to RUDE otw it will
					;already be in rude & this is a NOP
	mov	ax,sp			;return TRUE (non-zero)
	pop	di			;save caller's si,di
	pop	si
	ret
TxtBindPrs ENDP

;**************************************************************
; ushort TxtBindPrsS(ax:fBind)
; Purpose:
;	Called during Binary Load with fBind==TRUE to go through all
;	text tables just loaded, and for each opcode which refers to
;	a prs (opStSub/Function/DefFn/Declare/Call/CallS) convert
;	the prs id from oNam to oPrs.
;
;	Called during Binary Save with fBind==FALSE to go through all
;	text tables about to be saved, and for each opcode which refers
;	to a prs (opStSub/Function/DefFn/Declare/Call/CallS) convert
;	the prs id from oPrs to oNam.
;	This is because, when the module is re-loaded, offsets into the
;	procedure table may not be the same.
;
; Entry:
;	al = TBIND_Load:  map pcode oNam->oPrs, call PrsDefine
;	     TBIND_Save1: map pcode oPrs->oNam - called before writing to file
;	     TBIND_Save2: map pcode oNam->oPrs - called after writing to file
;	grs.fDirect must be FALSE
;	grs.oMrsCur identifies module just loaded.
;	All text tables in this mrs are assumed to be in SS_RUDE or SS_PARSE
;
; Exit:
;	returns 0 if no error, else a standard Basic error code.
;	condition codes are set based on value in ax
;	NOTE: If called with ax = zero, no error is possible, and no
;	heap movement will occur - Binary Save depends on this.
;
;**************************************************************
PUBLIC	TxtBindPrsS
TxtBindPrsS PROC NEAR
	mov	[fBindStatic],al
	mov	[bindErrCode],0

	DbAssertRelB [grs.GRS_fDirect],e,FALSE,CP,<TxtBindPrsS:fDirect TRUE>
	;convert the module's text table and each procedure's text table
	mov	bx,CPOFFSET TxtBindPrs
	call	ForEachTxtTblInMrs
	mov	ax,[bindErrCode]	;return error code to caller
	or	ax,ax			;set condition codes for caller
	ret
TxtBindPrsS ENDP


;----------------------------------------------------------------------
;			BigEdit Related Functions
;
; These EditMgr operations translate into several Text Manager calls:
;   Split Line:
;	ReplaceLineBuf -> TxtChange(1st half of line, delete split line)
;	InsertLineBuf -> TxtChange(2nd half of line, no delete)
;
;   Join Lines:
;	DeleteLinesInBuf -> TxtChange(delete 2 lines, no insert)
;	InsertLineBuf -> TxtChange(joined lines, no delete)
;
;   Block Paste:
;	DeleteLinesInBuf(selected lines)
;	InsertLineBuf -> TxtChange(1st line, no delete)
;	   :
;	InsertLineBuf -> TxtChange(nth line, no delete)
;
; The text manager takes advantage of the fact that no big edit does more
; than 1 delete of any of the user's original pcode.  It would need more
; than 1 bdTxtScrap if this were not the case.
;
; This presents a problem for Edit & Continue, since the nth text manager
; call may be the 1st operation that would prevent continuing.
; When we know we're in a BigEdit (by examining 'bigEditState'),
; all calls to TxtChange are done as a ReParse.  When the BigEdit is done,
; (i.e. when TxtEndBigEdit is called), we ReParse all lines entered
; during the BigEdit, and if any would prevent continuing, and the user
; indicates he wants to back out of the edit:
;   The inserted text (otxBigIns, cbBigIns) is deleted (via TxtDelete)
;
; As a speed optimization for block paste, we only update the txt links
; at the end of a big edit.  This significantly reduces the over head for
; large edit operations.
;   
; The following shows the BigEdit related actions performed by various routines:
;
; bigEditState is initialized to BIG_EDIT_FALSE
;
; TxtStartBigEdit:
;    bigEditState = BIG_EDIT_ACTIVE
;    fFillScrap = TRUE
;    cbBigIns = 0
;    otxBigIns = UNDEFINED
;
; TxtDelete(otxDelFirst, otxDelLast)
;    If bigEditState == BIG_EDIT_CANCEL, return without changing anything
;    If delete would prevent continuing, & user wants to back out of edit,
;       if bigEditState == BIG_EDIT_ACTIVE, then bigEditState = BIG_EDIT_CANCEL
;       return without changing anything
;    If fFillScrap and bdTxtScrap is empty,
;       fFillScrap = FALSE
;	copy deleted text to bdTxtScrap
;       otxScrap = otxDelFirst
;    If cbBigIns > 0, cbBigIns -= cbDel
;
; TxtChange(otxDelFirst, otxDelLast, fNoInsert)
;    If bigEditState == BIG_EDIT_CANCEL, return without changing anything
;    fFillScrap = TRUE
;    If otxDelFirst != otxDelLast
;       if TxtDelete(otxDelFirst, otxDelLast) == FALSE
;          return without changing any pcode (user wants to back out of edit)
;    If fNoInsert return
;    fFillScrap = FALSE
;    If bigEditState == BIG_EDIT_ACTIVE
;       insert line as an opReParse
;	cbBigIns += cbInsert
;       if otxDelFirst < otxBigIns
;	   otxBigIns = otxDelFirst
;    else
;	Parse source line to pcode
;       If insert would prevent continuing, and user wants to back out of edit,
;          If cbBigIns > 0, TxtDelete(otxBigIns, otxBigIns + cbBigIns)
;	   If bdTxtScrap is not empty, Insert bdTxtScrap at otxScrap
;          bigEditState = BIG_EDIT_CANCEL
;
; TxtEndBigEdit:
;    bigEditState = BIG_EDIT_REPARSE
;    otxCur = otxBigIns
;    While bigEditState != BIG_EDIT_CANCEL && otxCur < otxBigIns + cbBigIns
;       call TxtChange to reparse line at otxCur
;       otxCur = next opReParse(otxCur)
;    release bdTxtScrap
;    call update links to rethread the pcode linked lists.
;
;-------------------------------------------------------

;**************************************************************
; TxtStartBigEdit()
; Purpose:
;	Called by the Edit Mgr at the start of some operation which results
;	multiple calls to InsertLineInBuf/ReplaceLineBuf/DeleteLinesBuf.
;	Examples include multi-line-paste/cut/copy, line-split, line-join.
;
;**************************************************************
cProc	TxtStartBigEdit,<PUBLIC,FAR>	
cBegin	TxtStartBigEdit 		
	DbAssertRelB [bigEditState],e,BIG_EDIT_FALSE,CP,<TxtStartBigEdit:Already in big edit>
	mov	[bigEditState],BIG_EDIT_ACTIVE
	and	[flagsTm],NOT FTM_BpDeleted ;clear BP deleted flag
	mov	[cForDel],1
	mov	[cForStepDel],1
	sub	ax,ax			;ax = 0
	mov	[cbBigIns],ax		;cbBigIns = 0
	dec	ax			;ax = FFFF
	mov	[otxBigIns],ax		;otxBigIns = UNDEFINED
	mov	[fFillScrap],al		;fFillScrap = TRUE
cEnd	TxtStartBigEdit 		

;**************************************************************
; bool TxtEndBigEdit()
; Purpose:
;	Called by the Edit Mgr at the end of some operation which results
;	multiple calls to InsertLineInBuf/ReplaceLineBuf/DeleteLinesBuf.
; Exit:
;	same as TxtChange
;
;**************************************************************
cProc	TxtEndBigEdit,<PUBLIC,FAR>,<si,di> 
cBegin	TxtEndBigEdit			
DbAssertRelB [bigEditState],ne,BIG_EDIT_FALSE,CP,<TxtEndBigEdit:Not in big edit>
	sub	ax,ax			;prepare to return 0
	mov	si,[otxBigIns]		;si = otxStart of big edit
	inc	si			;did any edit occur?
	jz	TeDone			;brif not
	dec	si
	mov	di,si
	add	di,[cbBigIns]		;di = otxEnd of big edit
	cmp	[bigEditState],BIG_EDIT_ACTIVE ;did we successfully complete
	jne	TeLoop			;the big edit - brif backed out
	push	si
	push	di
	call	UpdateLinks		;update txt threads before processing
					;op reparse list.
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.
	mov	cx,[grs.GRS_oRsCur]	;cx = oRsCur on entry
TeLoop:
	sub	ax,ax			;prepare to return 0
	test	[mrsCur.MRS_flags2],FM2_NoPcode
	jne	TeDone			;if document or command window, done
	cmp	[bigEditState],BIG_EDIT_CANCEL
	je	TeDone			;brif user backed out of BigEdit
	cmp	cx,[grs.GRS_oRsCur]	;did we change from one SUB/FUNCION
					; into a different SUB/FUNCTION?
	jne	TeDone			;brif so, leave the rest of edit as
					; opReparses.
	mov	[bigEditState],BIG_EDIT_REPARSE
	mov	ax,si			;pass otxStart to DoReParse
	mov	bx,di			;bx = otx to stop looking for opReParse
	sub	di,[txdCur.TXD_bdlText_cbLogical]
					;prepare for add di,_cbLogical below
	push	cx			;preserve entry oRs
	call	DoReParse		;parse next opReParse in text table
					;ax = non-zero if serious error
	pop	cx			;recover entry oRs
	jc	TeDone			;brif this edit caused an error
	add	di,[txdCur.TXD_bdlText_cbLogical]
					;adjust terminating otx for delta this
					; edit caused.
	jmp	SHORT TeLoop		;brif 1 line was successfully reparsed

;ax = error code (0 if none)
TeDone:
	cmp	[bdlTxtScrap.BDL_status],NOT_OWNER
	je	TeDontFree
	push	ax			;save return value from DoReParse
	PUSHI	ax,<dataOFFSET bdlTxtScrap>
	call	BdlFree			;release DELETE scrap
	pop	ax			;ax = DoReParse (and TxtChange's)
					; return value
TeDontFree:
	mov	[bigEditState],BIG_EDIT_FALSE
	cmp	ax,ER_OM
	je	TeExit
	cmp	ax, MSG_GoDirect	; Also, allow this error
	je	TeExit			
	sub	ax,ax			;all errors except Out-of-memory
					; are ignored.  User may be joining
					; or spliting two lines, which will
					; temporarily result in a syntax error,
					; which the user fully intends to fix.
					; Giving the error when the user
					; moves off the line is soon enough.
					; Anything else is very annoying.
TeExit:
cEnd	TxtEndBigEdit			

;**************************************************************
; ushort FAR TxtPaste(otxInsert, oRsSrc)
;
; Purpose:
;	The editor calls TxtPaste() to insert a block of
;	opReparses into a text table.  This is called in
;	association with BigEdits, after TxtStartBigEdit,
;	and prior to TxtEndBigEdit.  This speeds up block
;	pastes since the opReparses that are in the scrap
;	do not have to be listed to ascii, and multiple
;	TxtChange calls are avoided.
;	TxtDescan() should be called before this, to ensure that
;	the text table is descanned to SS_PARSE state.
;
; Entry:
;	grs.oMrsCur, grs.oPrsCur have their usual meaning
;	parm1: ushort otxInsert - text table offset to opBol
;	   opcode for where lines should be inserted.
;	parm2: ushort oMrsSrc - Describes the MRS and text table
;	   containing the block to be inserted.
;
; Exit:
;	ax = 0 if out of memory
;
;**************************************************************
; This version of TxtPaste will not work in EB since it pushes pointers
; to text tables onto the stack and calls RsActivate.
cProc	TxtPaste,<PUBLIC,FAR>,<si,di>
parmW	otxInsert
parmW	oRsSrc
localW	cbIns
cBegin


	mov	[fFillScrap],0		;just paste, nothing to put in Scrap
	push	[grs.GRS_oRsCur]	;save destination oRs
	push	[oRsSrc]
	call	RsActivateCP		;activate Src txt table
	mov	ax,[txdCur.TXD_bdlText_cbLogical] ;get size of text to copy
	sub	ax,CB_EMPTY_TEXT-StartOtx ;don't include opEndProg and opEot
	mov	[cbIns],ax		;save amount to move.  We can't assign
					; to cbBigIns until after we have called
					; TxtMoveUp in case of OM.
	mov	di,[txdCur.TXD_cLines]	;grap number of lines in source buf

	call	RsActivateCP		;reactivate oRsDst (already on stack)

; Make room for reparse block
	mov	ax,[otxInsert]		;get insertion point
	mov	[otxBigIns],ax		;remember for TxtEndBigEdit
	push	ax			;pass insertion point
	push	[cbIns] 		;pass amount of space to free
	call	TxtMoveUp
	je	TxtPasteExit		;brif out-of-memory error
	mov	ax,[cbIns]
	mov	[cbBigIns],ax		;save amount moved for TxtEndBigEdit
	add	[txdCur.TXD_cLines],di	;adjust dest for inserted lines

; Copy bytes to txdcur from source txt table
	DbSegMoveOff			;assert no far calls
	push	[grs.GRS_oRsCur]	;save destination oRs for reactivation
					; after move
	push	ds			;save dgroup
	GetSegTxtCur			;es = seg adr of current txt tbl
	push	es			;save dest seg

	push	[oRsSrc]
	call	RsActivateCP		;activate Src txt table
	GetSegTxtCur			;es = seg adr of current txt tbl
	mov	cx,[cbIns]
	SetStartOtx si			;start of src txt table
	mov	di,[otxInsert]		;insert at otxInsert in cur text table
	push	es
	pop	ds			;ds = txt seg of src
	pop	es			;es = txt seg of dst
	shr	cx,1			;move words
	rep	movsw			;insert opReparses
	pop	ds			;recover ds = dgroup
	DbSegMoveOn			;Far calls are OK again

DbAssertFlags nc,CP,<TxtPaste: err2>

	call	RsActivateCP		;reactivate oRsDst (already on stack)

	mov	si,[otxInsert]
	mov	bx,si			;si = otxInsert
	add	bx,[cbIns]		;bx = otxAfterInsert
	or	[flagsTm],FTM_TxtPaste	;we are pasting, so don't update line
					; count.
	call	TxtInsUpdate		;update line count, IP, etc.
	and	[flagsTm],NOT FTM_TxtPaste ;clear paste flag

; OpReparse links will be updated by call to TxtEndBigEdit from
;   otxBigIns to otxBigIns+cbBigIns
;
	DbChk	TxdOps			;check for bad linked lists through
					; pcode, bad opcodes, etc.
	mov	ax,sp			;return True
TxtPasteExit:
cEnd


sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtthr.asm ===
TITLE	txtthr.asm - Text Table Linked List Maintenance Functions

;==========================================================================
;
;Module:  txtthr.asm - Text Table Linked List Maintenance Functions
;System:  Quick BASIC Interpreter
;
;=========================================================================*/

	include		version.inc
	TXTTHR_ASM = ON
	IncludeOnce	architec
	IncludeOnce	context
	IncludeOnce	opcodes
	IncludeOnce	opaftqb4
	IncludeOnce	qbimsgs
	includeOnce	txtint
	includeOnce	txtmgr
	includeOnce	types
	includeOnce	variable

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING

sBegin	CODE

;These opcodes are of special interest whenever they are inserted:
;
PUBLIC	tOpUpdl
tOpUpdl	LABEL WORD
	opTabStart	UPDL
	opTabEntry	UPDL,opLab
	opTabEntry	UPDL,opLabSp
	opTabEntry	UPDL,opBolLab
	opTabEntry	UPDL,opBolLabSp
		UPDL_labMax EQU UPDL_opBolLabSp
	; Put in opBol to keep terminate most searches in update links
	; before encountering opEot.  This significantly speeds up generic
	; edits which don't have any threads past the point of the edit.
	opTabEntry	UPDL,opBol
		UPDL_SkipMax EQU UPDL_opBol
	opTabEntry	UPDL,opReParse
	opTabEntry	UPDL,opStDefType
	opTabEntry	UPDL,opStType
	opTabEntry	UPDL,opStEndType
	opTabEntry	UPDL,opStDefFn
	opTabEntry	UPDL,opStEndDef
	opTabEntry	UPDL,opEndSingleDef
	opTabEntry	UPDL,opEot

;Opcodes which are valid within TYPE/END TYPE blocks
;
tOpTypes LABEL WORD
	opTabStart	TYPES
	opTabEntry	TYPES,opElemRef
	opTabEntry	TYPES,opAsType
	opTabEntry	TYPES,opAsTypeExp
	opTabEntry	TYPES,opAsTypeFixed	
	opTabEntry	TYPES,opStEndType
		TYPES_DispatchMax EQU TYPES_opStEndType
	; the following opcodes are allowed but no processing is required
	; by ScanBlock
	opTabEntry	TYPES,opBol
	opTabEntry	TYPES,opBos
	opTabEntry	TYPES,opBolSp
	opTabEntry	TYPES,opBolInclude
	opTabEntry	TYPES,opBolIncludeSp
	opTabEntry	TYPES,opStRem
	opTabEntry	TYPES,opQuoteRem
	opTabEntry	TYPES,op_Static
	opTabEntry	TYPES,op_Dynamic
	opTabEntry	TYPES,op_Include
	opTabEntry	TYPES,opEot

sEnd	CODE

sBegin	CP
assumes	cs,CP

;Threaded pcode descriptor
THR_DSC STRUC
THR_otxPrev	DW 0	;points to previous thread
THR_fInDS	DW 0	;non-zero if THR_otxPrev is a DS offset
THR_DSC ENDS

;*************************************************************************
; TxtDeThread(ax:pHead, di:otxDelFirst, cx:cbDel)
;
; Purpose:
;	Called when a block of text is deleted.
;	Traverse a linked list through the current text table,
;	removing any nodes which are being deleted, and updating
;	next-node-offsets for those nodes beyond the deleted range.
;	This function is called BEFORE the text has been deleted.
;
; Entry:
;	ax =  pointer to ushort which heads linked list
;	       for example, &txdCur.otxLabLink
;	di =  text offset to 1st byte being deleted
;	cx =  number of bytes being deleted
;
; Preserves:
;	cx (callers depend on this)
;
;*************************************************************************
cProc	TxtDeThread,<PUBLIC,NEAR>,<si>
	localW	segTxtTab		;text table's segment
cBegin
	xchg	si,ax			;si points to head of list
	DbChk	TxdCur			;perform sanity check on txdCur
	GetSegTxtTblCur			;es = seg adr of cur txt tbl
					;preserves cx
	mov	[segTxtTab],es		;save text table's segment
	mov	dx,ds			;dx -> prev link node's segment (DGROUP)
	mov	bx,[si] 		;bx -> 1st node in linked list (in ES)
	mov	ax,di
	add	ax,cx			;ax -> last byte deleted
	DbChk	Otx,ax
DeThrLoop:
	cmp	bx,UNDEFINED
	je	DeThrExit		;branch if done with linked list
	DbChk	Otx,bx
	cmp	bx,di
	jb	DeThrUnaffected 	;brif node is unaffected by delete
					; (i.e. node < 1st byte deleted)
	cmp	bx,ax
	jb	DeThrDeleted		;brif node is in deleted range
					; (i.e. node < last byte deleted)
					;else node is beyond deleted range
	mov	es,dx			;es = segment of predecessor node
					;may be DGROUP:pHead or es:<node>
	mov	es:[si],bx		;update predecessor node
	sub	es:[si],cx
	mov	es,[segTxtTab]		;es = text table's segment
DeThrUnaffected:
	mov	si,bx			;save offset of prev node ptr in si
	mov	dx,es			;save seg of prev node ptr in dx
DeThrDeleted:
	mov	bx,es:[bx]		;bx points to next node in list
	jmp	SHORT DeThrLoop
DeThrExit:
	mov	es,dx			;es = segment of predecessor node
					;may be DGROUP:pHead or es:<node>
	mov	es:[si],bx		;update predecessor node
cEnd

;**********************************************************************
; TxtDelThread
; Purpose:
;	Called BEFORE pcode is deleted from current text table.
;	Traverses all linked lists through the text table,
;	updating the linked lists for the delete.
; Entry:
;	parm1 = offset to start of delete
;	parm2 = cbDel
;
;**********************************************************************
; TxtDeThread(&txdCur.otxLabLink, otxDelFirst, cbDel)
; TxtDeThread(&txdCur.otxReParseLink, otxDelFirst, cbDel)
; TxtDeThread(&txdCur.otxDefTypeLink, otxDelFirst, cbDel)
; TxtDeThread(&txdCur.otxTypeLink, otxDelFirst, cbDel)
;
; NOTE: TxtDeThread takes ax,cx,di as parms and preserves cx
;
cProc	TxtDelThread,<PUBLIC,NEAR>,<si,di>
	parmW	otxStart
	parmW	cbDel
cBegin
	mov	di,[otxStart]
	mov	cx,[cbDel]
	mov	si,CPOFFSET TxtDeThread	;si = adr of function to call
	mov	ax,dataOFFSET txdCur.TXD_otxTypeLink
	call	si			;fixup otxTypeLink list
	mov	ax,dataOFFSET txdCur.TXD_otxDefTypeLink
	call	si			;fixup otxDefTypeLink list
	mov	ax,dataOFFSET txdCur.TXD_otxReParseLink
	call	si			;fixup otxReParseLink list
	mov	ax,dataOFFSET txdCur.TXD_otxLabLink
	call	si			;fixup otxLabLink list

	test	[txdCur.TXD_flags],FTX_mrs
	je	DelNotMod		;brif not module text table

	; The linked list of opcodes headed by mrsCur.MRS_data_otxFirst
	; only needs to be maintained while in SS_EXECUTE state, so
	; we don't need to fix it up here
	
	mov	ax,dataOFFSET mrsCur.MRS_otxDefFnLink
	call	si	
DelNotMod:
cEnd

;*************************************************************************
; TxtInsThread(pHead, pThrDsc, otxInsFirst, cbIns)
;
; Purpose:
;	Called when a block of text is inserted.  Traverse a linked
;	list through the current text table, updating next-node-offsets
;	for those nodes beyond the inserted range.
;	This function is called AFTER the text has been inserted.
;
; Entry:
;	parm1: pointer to ushort which heads linked list
;	       for example, &txdCur.otxLabLink
;	parm2: pointer to thread descriptor which on exit contains fields:
;	       THR_otxPrev: offset to head or node which precedes the node
;			being inserted in the list
;	       THR_fInDS:   non-zero if THR_otxPrev is an offset into DS
;			zero if THR_otxPrev is an offset into text table
;	parm3: text offset to 1st byte inserted
;	parm4: number of bytes being deleted
;
; Exit:
;	*pThrDsc is updated so it refers to the last link which
;	precedes otxInsFirst.
;
;*************************************************************************
cProc	TxtInsThread,<PUBLIC,NEAR>,<si,di>
	parmW	pHead
	parmW	pThrDsc
	parmW	otxInsFirst
	parmW	cbIns
cBegin
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	si,[pHead]		;si -> head of linked list (in DGROUP)
	mov	di,[pThrDsc]
	mov	[di.THR_otxPrev],si	;default THR_otxPrev to head of list
	mov	[di.THR_fInDS],1 	;set flag indicating THR_otxPrev is
					; offset in DS
	GetSegTxtTblCur			;es = seg adr of cur txt tbl
	mov	ax,es			;ax = seg adr of cur txt tbl
					;NOTE: ax=es for remainder of function
	mov	dx,ds			;dx -> prev link node's segment (DGROUP)
	mov	bx,[si] 		;bx -> 1st node in linked list (in ES)
	mov	cx,[cbIns]		;cx = #bytes inserted
InsThrLoop:
	cmp	bx,[otxInsFirst]	;compare with adr of 1st byte inserted
	jb	InsThrUnaffected	;brif node is unaffected by insert
					; (i.e. node < 1st byte inserted)
	cmp	bx,UNDEFINED
	je	InsThrExit		;branch if done with linked list
	mov	es,dx			;es = segment of predecessor node
					;may be DGROUP:pHead or es:<node>
	add	bx,cx			;bx points to where node is after insert
	mov	es:[si],bx		;update predecessor node
	mov	es,ax			;es = text table's segment
	jmp	SHORT NextLink

InsThrUnaffected:
	mov	[di.THR_otxPrev],bx	;THR_otxPrev points to last link before
					; inserted block of text
	mov	[di.THR_fInDS],0 	;reset flag to 0, indicating THR_otxPrev
					; is relative to the text segment
NextLink:
	mov	si,bx			;save offset of prev node ptr in si
	mov	dx,es			;save seg of prev node ptr in dx
	mov	bx,es:[si]		;bx points to next node in list
	jmp	SHORT InsThrLoop

InsThrExit:
cEnd

;*************************************************************************
; TxtAddThread(pThrDsc, otxNewLink)
;
; Purpose:
;	Called AFTER a block of text has been inserted which contains
;	an opcode having an operand that should be added to a linked
;	list through the text table.  This function inserts this opcode
;	in the list.
;
; Entry:
;	parm1: pointer to thread descriptor which contains following fields:
;	       THR_otxPrev: offset to head or node which precedes the node
;			being inserted in the list
;	       THR_fInDS: non-zero if THR_otxPrev is an offset into DS
;			zero if THR_otxPrev is an offset into text table
;	parm2: pointer to new link field to add to linked list
;
;*************************************************************************
cProc	TxtAddThread,<PUBLIC,NEAR>,<si,di>
	parmW	pThrDsc
	parmW	otxNewLink
cBegin
	DbChk	TxdCur			;perform sanity check on txdCur
	GetSegTxtTblCur			;es = seg adr of cur txt tbl
	mov	ax,es			;ax = seg adr of cur txt tbl
	mov	si,[pThrDsc]		;si -> thread descriptor
	mov	bx,[si.THR_otxPrev]	;bx -> prev node / head of list
	cmp	[si.THR_fInDS],0
	je	prevInTxt		;brif bx is offset within text table
	mov	[si.THR_fInDS],0 	;reset THR_fInDS to 0
	push	ds
	pop	es			;es -> DGROUP
prevInTxt:
	mov	dx,es:[bx]		;dx -> next node
	mov	di,[otxNewLink] 	;di -> new node
	DbChk	Otx,di
	mov	es:[bx],di		;prev node -> new node
	mov	es,ax			;es -> text table
	mov	es:[di],dx		;new node -> next node
	mov	[si.THR_otxPrev],di	;save adr of new node in thread dsc
cEnd

;**************************************************************
; void NEAR UpdateLinks(otxInsStart, otxInsEnd)
; void NEAR NoWalkUpdateLinks(otxInsStart, otxInsEnd)
;
; Purpose:
;	Called after some text has been inserted into the current text table.
;	During ASCII Load, it is not called for every line, but every
;	time we switch text tables (speed optimization for LOAD).
;	For each inserted opcode which has a link-field operand, it
;	is inserted into its appropriate linked list.  The NoWalkUpdateLinks
;	entrypoint allows the binary translator to adjust links for pcode
;	growth without looking at the inserted pcode.  This is necessary as
;	the pcode is not valid until after all translation has been performed.
;
; Entry:
;	grs.oMrsCur, grs.oPrsCur have their usual meaning
;	txdCur.bdlText describes the current text table.
;	ps.bdpSrc contains source line to be inserted
;	parm1: ushort otxInsStart - text table offset to opBol
;	   opcode for 1st line inserted.
;	parm2: ushort otxInsEnd - text table offset to opBol
;	   opcode beyond last line inserted.
;	   (parm2 - parm1) should equal the number of bytes inserted.
;	   If this (parm2 - parm1), this function is effectively a nop.
;
; Exit:
;	no error or exception is possible.
;
;**************************************************************

;DoInsThread
;Entry:
;	ax = adr of head of linked list (in DS)
;	bx = adr of local thread descriptor used to remember previous link
;	si = adr of 1st byte inserted
;	di = # bytes inserted
;
DoInsThread PROC NEAR
	push	ax			;pass DS offset to head of linked list
	push	bx			;pass offset to thread descriptor
	push	si			;pass otxInsStart
	push	di			;pass cbIns
	call	TxtInsThread		;update linked list for inserted pcode
	ret
DoInsThread ENDP

cProc	NoWalkUpdateLinks,<PUBLIC,NEAR> 
cBegin
	mov	al, 00h
	SKIP2_PSW
cEnd	<nogen>

cProc	UpdateLinks,<PUBLIC,NEAR>	
cBegin
	mov	al, 01h
cEnd	<nogen>

cProc	UpdateCommon,<PUBLIC,NEAR>,<si,di>  
	parmW	otxInsStart
	parmW	otxInsEnd
	localV	thrLab,<size THR_DSC>
	localV	thrReParse,<size THR_DSC>
	localV	thrType,<size THR_DSC>
	localV	thrDefType,<size THR_DSC>
	localV	thrDefFn,<size THR_DSC>
	localB	fWalkNew		; !0 => walk inserted pcode
cBegin
	mov	fWalkNew, al		; save flag for later

	DbChk	Otx,[otxInsStart]
	DbChk	Otx,[otxInsEnd]
	mov	si,[otxInsStart]	;si = offset to 1st byte to delete

	DbAssertRel si,be,otxInsEnd,CP,<UpdateLinks err 1>
	mov	di,[otxInsEnd]		;di = offset to last byte to delete
	sub	di,si			;di = cbIns

;Traverse all linked lists through the text table,
;updating the linked lists for the insert
;
	mov	ax,dataOFFSET txdCur.TXD_otxLabLink
	lea	bx,[thrLab]
	call	DoInsThread

	mov	ax,dataOFFSET txdCur.TXD_otxReParseLink
	lea	bx,[thrReParse]
	call	DoInsThread

	mov	ax,dataOFFSET txdCur.TXD_otxTypeLink
	lea	bx,[thrType]
	call	DoInsThread

	mov	ax,dataOFFSET txdCur.TXD_otxDefTypeLink
	lea	bx,[thrDefType]
	call	DoInsThread

	test	[txdCur.TXD_flags],FTX_mrs
	je	UpdNotMod		;brif we're not looking at module text

	;fix linked lists which can only occur in a module text table
	mov	ax,dataOFFSET mrsCur.MRS_otxDefFnLink
	lea	bx,[thrDefFn]
	call	DoInsThread

	; The linked list of opcodes headed by mrsCur.MRS_data_otxFirst
	; only needs to be maintained while in SS_EXECUTE state, so
	; we don't need to fix it up here

UpdNotMod:
	mov	al, fWalkNew		; check if we need to walk new pcode
	or	al, al			
	jz	UpdDone 		; brif no need to walk inserted pcode

	push	si			;pass otxInsStart
	PUSHI	ax,<CODEOFFSET tOpUpdl>
	call	TxtFindOp		;ax = offset to 1st interesting opcode
UpdLoop:
	mov	si,ax			;si = otxCur (offset to cur opcode)
	cmp	ax,[otxInsEnd]
	jae	UpdDone			;brif beyond end of inserted pcode
	mov	al,[txtFindIndex]
	cmp	al,UPDL_labMax
	ja	UpdNotLab		;brif not a label opcode

	lea	ax,[thrLab]
	push	ax
	lea	ax,[si+2]		;ax = offset to link field
	push	ax
	call	TxtAddThread
	jmp	SHORT UpdNext

UpdNotLab:
	;OpBol is in the UPDL_SkipMax range to cause us to terminate
	; the TxtFindOp Calls before opEot if no threads are after
	; oTxInsEnd.  This significantly speeds up generic edits.
	
	cmp	al,UPDL_SkipMax 	;should we skip this opcode?
	jbe	UpdNext 		;brif so, get next opcode
	sub	al,UPDL_opReParse
	sub	ah,ah			;ax = dispatch index
	shl	ax,1			;ax = dispatch offset
	xchg	ax,bx			;bx = dispatch offset
	jmp	WORD PTR cs:UpdDisp[bx]
UpdDisp:
	DW	UpdOpReParse
	DW	UpdOpStDefType
	DW	UpdOpStType
	DW	UpdOpStEndType
	DW	UpdOpStDefFn
	DW	UpdOpStEndDef
	DW	UpdOpEndSingleDef
	DW	UpdDone			;for opEot (caller can pass
					;txdCur.cbLogical which would allow
					;opEot to be found by TxtFind...
UpdNext:
	push	si			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpUpdl>
	call	TxtFindNextOp
	jmp	SHORT UpdLoop

UpdDone:
	DbChk	TxdThr			;check all threads through cur txt table
cEnd	;UpdLinks

;for opReParse, the 1st operand is a byte count,
;               the 2nd operand is the link field
;
UpdOpReParse:
	lea	ax,[thrReParse]
	jmp	SHORT UpdAdd4

UpdOpStDefType:
	lea	ax,[thrDefType]
	push	ax
	lea	ax,[si+2]		;ax = offset to link field
	push	ax
	jmp	SHORT UpdAdd

UpdOpStType:
UpdOpStEndType:
	lea	ax,[thrType]
	push	ax
	lea	ax,[si+2]		;ax = offset to link field
	push	ax
	call	TxtAddThread
	jmp	SHORT UpdNext

;for these opcodes, the 1st operand is a byte count,
;                   the 2nd operand is the link field
;
UpdOpStDefFn:
UpdOpStEndDef:
UpdOpEndSingleDef:
	lea	ax,[thrDefFn]
UpdAdd4:
	push	ax
	lea	ax,[si+4]		;ax = offset to link field
	push	ax
UpdAdd:
	call	TxtAddThread
	jmp	UpdNext

;**************************************************************
; ushort ScanTypeBlock
; Purpose:
;	This function goes through the a TYPE block in the current text table
; NOTE:
;	Parse->Execute Scanner prevents   id AS type   statement outside
;	TYPE/END TYPE block.
; Entry:
;	si = text offset beyond opStType opcode
; Exit:
;	If no error occurred
;	   returns 0
;	   si points beyond opStEndType's operands
;	Else returns standard qbi error message code in ax (see qbimsgs.h):
;	   MSG_UndType if "x AS foo" was seen, but either foo is not defined
;	     or it is defined beyond the reference (forward refs are illegal
;	     because BASCOM doesn't know how to handle them)
;	   ER_DD if either "TYPE x" has already been defined, or
;	     2 elements within 1 type record have the same name
;	   MSG_InvInTypeBlk if some statement which is illegal within
;	     a TYPE block was seen
;	   ER_OM if out-of-memory
;	   si points to 1st byte of opcode which caused error
;
;**************************************************************
cProc	ScanTypeBlock,<PUBLIC,FAR>,<di> 
	localW	oNamElem
	localW	oTypType
cBegin
	xor	ax,ax			;ax = 0
	mov	[oNamElem],ax		;initialize [oNamElem] to zero
	lea	ax,[si+2]		;ax points to oNam field
	call	GetWOtx			;ax = oNam field
	push	ax
	call	DefineTyp
	or	ax,ax
	js	J1_StExit		;brif got some error
	mov	[oTypType],ax
	dec	si
	dec	si			;si points to opStType's opcode

	;now try to define each element within the type block
	;Element definitions in the type block have the form:
	;  foo AS bar	   ==>	opElemRef(oNam<foo>) opAsType(oNam<bar>,column)
	;  foo AS INTEGER  ==>	opElemRef(oNam<foo>) opAsTypeExp(ET_I2,column)
	;  foo AS STRING * 6 ==> opElemRef(oNam<foo>) opAsTypeExp(0x8006,column)
	
StLoop:
	mov	di,si			;di points to opStType's opcode
	mov	ax,di			;pass otxPrev in ax
	call	TxtSkipOp		;ax = offset to next opcode
	xchg	si,ax			;si = text offset
	push	di			;pass otxPrev
	PUSHI	ax,<CODEOFFSET tOpTypes>
	call	TxtFindNextOp
	cmp	ax,si
	mov	ax,MSG_InvInTypeBlk
	jne	StExit			;brif invalid opcode was found in line
	cmp	dl,TYPES_DispatchMax	
	ja	StLoop			;brif no special processing required

	lea	ax,[si+2]		;ax points to opcode's 1st operand
	push	dx			;save [txtFindIndex]
	call	GetWOtx			;ax = 1st operand
	pop	dx			;dl = [txtFindIndex]

	xor	dh,dh
	shl	dx,1			;dx = dispatch offset
	mov	bx,dx			;bx = dispatch offset
	jmp	WORD PTR CP:AsTypeDispatch[bx] ;dispatch to handler	

AsTypeDispatch:				
	DW	CPOFFSET TyOpElemRef	
	DW	CPOFFSET TyOpAsType	
	DW	CPOFFSET TyOpAsTypeExp	
	DW	CPOFFSET TyOpAsTypeFixed
	DW	CPOFFSET TyOpStEndType	

TyOpStEndType:
	mov	ax,MSG_UndElem		;prepare for no elements in type
	mov	bx,[oTypType]		; bx = ptr to type entry
	add	bx,[mrsCur.MRS_bdVar.BD_pb] ;[4] get type table base
	cmp	[bx.TYP_oElementFirst],0 ;were any elements defined?
	je	StExit			;brif not, generate error

	lodsw				;skip opStEndType opcode
	lodsw				;skip opStEndType's operand
	sub	ax,ax			;no error occurred
J1_StExit:
	jmp	SHORT StExit

; id AS within a TYPE/END TYPE block - save oNam in oNamElem
; ax = oNam field
;
TyOpElemRef:
	mov	[oNamElem],ax
StLoop2:				;fix jump out of range
	jmp	SHORT StLoop

; saw an AS <user type> within a TYPE/END TYPE block
; call DefineElem to define the element
;
TyOpAsType:
	push	ax			;pass oNam of element's user type
	push	si			;pass text offset
	call	RefTyp			;ax = oTyp for element's oNam
CheckError:
	or	ax,ax
	js	StExit			; brif RefTyp returned error code
	; Fall into dispatch routine for TyOpAsTypeExp

; saw an AS <explicit type> within a TYPE/END TYPE block -
; call DefineElem to define the element
;
TyOpAsTypeExp:
	mov	bx,CPOFFSET DefineElem	;prepare to call DefineElem
CallDefineElemxxx:
	xor	cx,cx			;cx = 0
	xchg	cx,[oNamElem]		;cx = oNam; zero [oNamElem]
	jcxz	GotADim			;brif oNam is zero
	push	cx			;pass oNam given by opElemRef
	push	[oTypType]		;pass oTyp for TYPE block being built
	push	ax			;pass oTyp for element
	call	bx			;call DefineElem[Exp]
	or	ax,ax
	je	StLoop2 		;brif no error
StExit:
	and	ah,7FH			;mask off high bit set by Variable Mgr
cEnd

; saw an AS STRING*[oNam | cb] within a TYPE/END TYPE block - 
; call DefineElemFixed to define the element
;
TyOpAsTypeFixed:			
	xchg	di,ax			;save oTyp in di
	lea	ax,[si+4]		;ax -> opcode's second operand
	call	GetWOtx 		;ax = byte count or oNam of constant
	push	ax			;pass as 1st arg to DefineElemFixed
	xchg	ax,di			;restore ax = oTyp
	mov	bx,CPOFFSET DefineElemFixed ;bx = routine to define element
	jmp	SHORT CallDefineElemxxx	

;we've encountered an AsTypexxx opcode which was not preceeded by an
; opElemRef opcode. This can occur in a Dim statement and perhaps other places.
GotADim:				
	mov	ax,MSG_InvInTypeBlk	;message "invalid in type block"
	jmp	SHORT StExit		;exit

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtutil.asm ===
TITLE	TXTUTIL - Text Table Management Routines

;============================================================================
;
; Module: TxtUtil.asm - Text Table Management Routines
; System: Quick BASIC Interpreter
;
;	--------- --- ---- -- ---------- ----
;	COPYRIGHT (C) 1985 BY MICROSOFT, INC.
;	--------- --- ---- -- ---------- ----
;
;
;============================================================================

	.xlist
	include version.inc
	TXTUTIL_ASM = ON
	includeOnce architec
	includeOnce context
	includeOnce executor
	includeOnce heap
	includeOnce lister
	includeOnce msgshort
	includeOnce names
	includeOnce optables
	includeOnce opcontrl
	includeOnce opid
	includeOnce opmin
	includeOnce opstmt
	includeOnce opaftqb4
	includeOnce parser
	includeOnce pcode
	includeOnce qbimsgs
	includeOnce rtinterp	;just needed for CbStrucErrRet
	includeOnce rtps
	includeOnce scanner
	includeOnce txtint
	includeOnce txtmgr
	includeOnce ui
	includeOnce variable

	.list

assumes DS,DATA
assumes SS,DATA
assumes ES,NOTHING

externFP B$GetCompSwitches	; runtime routine for QuickLIB switch info


;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------

sBegin	DATA

PUBLIC	fViewInclude
fViewInclude	DB 0	;non-zero if included source lines are visible
PUBLIC	fLnNotIncl
fLnNotIncl	DB 0	;static return value of LnOfOtx, OtxOfLn, OtxBolOfOtx
			;zero if given line was an INCLUDEd line
PUBLIC	cInclNest
cInclNest	DB 0	;$INCLUDE nesting depth.  Non-zero if currently loading
			;an $INCLUDE file

;used to pass info to DoDescan()
descanTo	DB 0

PUBLIC	compSwitches
compSwitches	DB 0	;Set by SetCompSwitches()
fPreScanAsChg	DB 0	;non-zero when PreScanAsChg is active

;statics needed by ChkLastAs()
oNamAs		DW 0
oRsAs		DW 0
otxAsDelStart	DW 0
otxAsDelEnd	DW 0

externB fLoadInclude	



sEnd	DATA


;-------------------------------------------------------------------------
;		CODE (execution-time) Segment Functions
;-------------------------------------------------------------------------

sBegin CODE
assumes CS,CODE

;Table of all the opcodes that are searched for by PreScanAsChg
;
tOpAs	LABEL WORD
	opTabStartAll	AS
	opTabEntry	AS,opOffLd
	opTabEntry	AS,opOffSt
	opTabEntry	AS,opNoType	;assumed to be 2nd to last
	opTabEntry	AS,opEot

;Table of all opcodes which represent  AS <usertype>
tOpAsType LABEL WORD
	opTabStart	ASTYPE
	opTabEntry	ASTYPE,opAsType
	opTabEntry	ASTYPE,opStDefFn    ;must preceed Declare,Sub,Function
	opTabEntry	ASTYPE,opStDeclare
	opTabEntry	ASTYPE,opStSub
	opTabEntry	ASTYPE,opStFunction
	opTabEntry	ASTYPE,opEot

;Table of all the opcodes that are op_Include (or opStInclude [03])
;
tOpReInclude LABEL WORD
	opTabStart	RI
	opTabEntry	RI,op_Include
	opTabEntry	RI,opEot

;Table of all the opcodes which affect the setting of Compiler switches
;Can't use opTab... macros because we need opEot as 1st entry in table.
;
tOpCompSw LABEL WORD
	opTabStart	CSW
	opTabEntry	CSW,opStOnError
	opTabEntry	CSW,opEvGosub
	opTabEntry	CSW,opEvOff
	opTabEntry	CSW,opEvOn
	opTabEntry	CSW,opEvStop
			CSW_EventMax EQU CSW_opEvStop
	opTabEntry	CSW,opStResume
	opTabEntry	CSW,opStResume0
	opTabEntry	CSW,opStResumeNext
	opTabEntry	CSW,opEot

;These functions are included in the CODE segment, because they
; are called by runtime code, and we wouldn't want to swap in
; the entire CP segment just to do these functions.

;*************************************************************************
; DescanOpcode(opcode)
;
; Purpose:
;	Given the address of an executor for an opcode, return the opcode's
;	id.  For example, give, ExStStop, it would return opStStop.
;
; Entry:
;	parm1: ushort - opcode's executor offset into CODE segment
;
; Exit:
;	AX = opcode id
;
;*************************************************************************
cProc	DescanOpcode,<PUBLIC,FAR,ATOMIC>	
	parmW	opcode
cBegin
	mov	bx,[opcode]
	mov	ax,cs:[bx-2]
cEnd

sEnd	CODE

;-------------------------------------------------------------------------
;		CP (compile) Segment Functions
;-------------------------------------------------------------------------


					; the current text table

sBegin	CP
assumes CS,CP

;*************************************************************************
; TxtTblSegCurCP(), TxtSegCurCP()
;
; Purpose:
;	Return the segment address for the start of the current text table.
;
; NOTE: TxtTblSegCurCP never returns the adr of the direct mode buffer.
;	TxtSegCurCP return the adr of the direct mode buffer if
;	  grs.fDirect is TRUE.
;
; Entry:
;	The structure txdCur identifies the current text table.
;	For TxtSegCurCP, if grs.fDirect is TRUE, the direct mode
;	   text table (grs.bdlDirect) is used instead.
;
; Exit:
;   TxtTblSegCurCP:  ES = segment address,
;	             cx preserved (callers depend on this)
;   TxtSegCurCP:     ES = segment address
;	             All other registers preserved (including flags)
;		     (callers depend on all being preserved)
;
;*************************************************************************
PUBLIC	TxtTblSegCurCP
TxtTblSegCurCP PROC NEAR
	DbChk	ConStatStructs		;ensure static structures
	GETSEG	es,[txdCur.TXD_bdlText_seg],,<SPEED,LOAD> ;[2]
	ret
TxtTblSegCurCP ENDP

PUBLIC	TxtSegCurCP
TxtSegCurCP PROC NEAR
	pushf
	push	bx
	DbChk	TxdCur			;perform sanity check on txdCur
	DbChk	ConStatStructs		;ensure static structures
	mov	bx,dataOFFSET txdCur.TXD_bdlText
	cmp	[grs.GRS_fDirect],FALSE
	je	NotDirectMode		;branch if not in direct mode
	mov	bx,dataOFFSET grs.GRS_bdlDirect
NotDirectMode:
	GETSEG	es,[bx.BDL_seg],bx,<SPEED,LOAD> ;[2] es = seg adr of text table
	pop	bx
	popf
	ret
TxtSegCurCP ENDP

sEnd	CP				

sBegin	SCAN				
assumes CS,SCAN 			

;***
; TxtSegCurSCAN
;
; Purpose:
;	Return the segment address for the start of the current text table.
;	Added as revision [20].
;
;	TxtSegCurSCAN returns the adr of the direct mode buffer if
;	  grs.fDirect is TRUE.
;
; Entry:
;	The structure txdCur identifies the current text table.
;	if grs.fDirect is TRUE, the direct mode
;	   text table (grs.bdlDirect) is used instead.
;
; Exit:
;   TxtSegCurSCAN:   ES = segment address
;	             All other registers preserved (including flags)
;		     (callers depend on all being preserved)
;
;*************************************************************************
PUBLIC	TxtSegCurSCAN
TxtSegCurSCAN PROC NEAR
	assumes ds,NOTHING		
	pushf
	push	bx
	DbChk	TxdCur			;perform sanity check on txdCur
	DbChk	ConStatStructs		;ensure static structures
	mov	bx,dataOFFSET txdCur.TXD_bdlText
	cmp	[grs.GRS_fDirect],FALSE
	je	@F			;branch if not in direct mode

	mov	bx,dataOFFSET grs.GRS_bdlDirect
@@:
	GETSEG	es,ss:[bx.BDL_seg],bx,<SPEED,LOAD> ;[2] es = seg adr of text table
	pop	bx
	popf
	ret
	assumes DS,DATA 		
TxtSegCurSCAN ENDP

sEnd	SCAN				


sBegin	CP				
assumes CS,CP				

;**************************************************************
; void DoDescan()
; Purpose:
;	Called indirectly by SystemDescan and ModuleRudeEdit.
;	See comments in those functions.
;
; Entry:
;	descanTo = SS_PARSE or SS_RUDE
; Exit:
;	grs.fDirect = FALSE
;	returns ax = non-zero (so ForEach... continues)
;
;**************************************************************
DoDescan PROC NEAR
	DbAssertRelB [descanTo],ne,SS_EXECUTE,CP,<DoDescan - bad descanTo>
	SetfDirect al,FALSE		;turn off direct mode if on
	and	[grs.GRS_flags],NOT FG_allSsExecute
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	DdExit			; brif text table is already SS_RUDE
					; or lower (we never descan lower
					; than SS_RUDE)
	cmp	[txdCur.TXD_scanState],SS_EXECUTE
	jne	NotExec			;we always descan at least to SS_PARSE
	call	SsDescan		;descan from SS_EXECUTE to SS_PARSE
	DbChk	TxdOps			;see if rude scanner inserted bad opcode
	;Only call TxtMoved if we descanned the text table, if we call
	; it every time we call DoDescan, Txt Edits slow down because we
	; have lost the cache unnecessarily.
	call	TxtMoved		;can't depend on cached text offsets
					;reset History and Watch info too
NotExec:
	cmp	[descanTo],SS_RUDE
	jne	DdExit			;brif only descanning to SS_PARSE
	push	WORD PTR ([descanTo])	;pass SS_RUDE to SsRudeScan
	call	SsRudeScan
	DbChk	TxdOps			;see if rude scanner inserted bad opcode

DdExit:
	mov	ax,sp			;return non-zero result for ForEachCP
	ret
DoDescan ENDP

;**************************************************************
; SystemDescan()
; Purpose:
;	This is called to descan all module and procedure text table's
;	to SS_PARSER or lower.  It occurs after some edits like
;	the definition of a function, to force the scanner to re-check
;	all references to the function for type compatability.  It
;	is also called just before a Binary SAVE is executed, so we
;	write opcodes to the file instead of executor addresses.
; SystemDescanRude() is identical, but all text tables are descanned
;	to SS_RUDE instead of SS_PARSE.
;
; This function never results in an error (not even out-of-memory)
;
; Exit:
;	grs.fDirect = FALSE
;
;**************************************************************
PUBLIC	SystemDescanCP
SystemDescanCP PROC NEAR
	test	[flagsTm],FTM_NoSsExecute ;speed opt - skip if all
	jnz	SystemDescanCPX 	;txt tables are already SS_PARSE
					;or lower
	mov	al,SS_PARSE
	mov	[descanTo],al

	;descan each prs in a module before descanning the module itself
	mov	al,FE_PcodeMrs+FE_CallMrsAfter+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET DoDescan
	call	ForEachCP		;DoDescan returns no error codes
	or	[flagsTm],FTM_NoSsExecute ;all txt tables at least in
SystemDescanCPX:			;SS_PARSE scan state
	SetfDirect al,FALSE		;turn off Direct mode
	ret
SystemDescanCP ENDP

cProc	SystemDescanRudeCP,<PUBLIC,NEAR>
cBegin
;	If a def fn is active, we need to deactivate it.  ForEachCP
;	saves/restores oPrsCur.  ModuleRudeEdit frees all def fn's.
;	The combination of these two would cause ForEachCP to attempt
;	to activate a freed prs if oPrsCur is for a def fn.

	mov	ax,[grs.GRS_oPrsCur]	
	inc	ax			; have an active procedure?
	jz	NotDefFn		; brif not
	dec	ax			
	cCall	FieldsOfPrs,<ax>	; returns dl = proctype
	cmp	dl,PT_DEFFN		; is it a def fn?
	jne	NotDefFn		; brif not
	call	PrsDeactivate		; deactivate active def fn
NotDefFn:				

	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
	mov	bx,CPOFFSET ModuleRudeEdit
	call	ForEachCP		;ModuleRudeEdit returns no error codes
cEnd

cProc	SystemDescanRude,<PUBLIC,FAR>
cBegin
	call	SystemDescanRudeCP
cEnd


;**************************************************************
; ModuleRudeEdit()
; Purpose:
;	This is called after some edit has occurred which could have
;	made existing variable tables and/or pcode inconsistent.
;	For example, after a DEFINT statement is inserted in a text
;	table.  It descans to SS_RUDE all text tables in this module.
;	It then eliminates the module's variable table (which
;	holds all procedure variables for this module as well).
;
;	Resets the NM_fShared name table bit and for each name table
;	entry, maps NMSP_Variable to NMSP_UNDEFINED
;
; Exit:
;	This function never results in an error (not even out-of-memory)
;	ax = non-zero (so it can be called by ForEachCP
;	grs.fDirect = FALSE
;
;**************************************************************
cProc	ModuleRudeEdit,<PUBLIC,NEAR>
cBegin

	test	[mrsCur.MRS_flags2],FM2_NoPcode OR FM2_Include
	DJMP	jne  NoVarTbl		;brif this mrs has no variable tables

	test	[mrsCur.MRS_flags],FM_AllSsRude ;speed opt - skip if all module
	jnz	FreeVarTbl		;text tables are already in SS_RUDE

	test	[txdCur.TXD_flags],FTX_mrs
	je	GotSubOrFunc		;brif a SUB or FUNC txt tbl is active
	call	PrsDeactivate		;deactivate DEF FN or DECLARE (if any)
					; since DEF FNs are discarded.  This
					; lets us call ForEachCP with FE_SaveRs
					; without crashing when we try to
					; restore a discarded DEF FN.
GotSubOrFunc:
	call	VarDealloc		;must free all owners in module var
					;  table BEFORE rude descan, because
					;  rude descan resets the oVarHash field
					;  in each prs to UNDEFINED
	mov	[descanTo],SS_RUDE

	;descan each prs in a module before descanning the module itself
	mov	al,FE_CallMrsAfter+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET DoDescan
	call	ForEachCP		;DoDescan can return no error codes

;start of revision [39]
	;Note that the below scheme depends on the fact that NextPrsInMrs
	;finds the first prs in the table if grs.GRS_oPrsCur is UNDEFINED, and
	;then subsequent prs's based on grs.GRS_oPrsCur.  It is not safe to
	;call ForEachCP to do this, because that scheme depends on walking
	;the prs chain, and PrsFree causes PrsCur to be Unlinked.  The next
	;call ForEach pass uses the unlinked entry, and thinks that it must
	;be looking at prsCur.
	;In essense we are starting from the top of the prs chain each time
	;through the loop below after freeing a Def Fn. If not a Def Fn we
	;walk from prs to prs, not freeing them.
	push	[grs.GRS_oRsCur]		;remember oRsCur for reacivation
FreeDefFn_Loop:
	call	far ptr NextPrsInMrs		;activate next prs in this mrs
	inc	ax				;no more prs's in this module?
	jz	FreeDefFn_Done			;  brif so
	cmp	[prsCur.PRS_procType],PT_DEFFN
	jne	FreeDefFn_Loop			;brif not a DEF FN (must be
						; DECLARE, SUB, or FUNCTION)
	call	PrsFree 			;release DEF FN's prs entry
	jmp	short FreeDefFn_Loop		; resets grs.oRsCur to UNDEFINED
FreeDefFn_Done:
	cCall	RsActivate			;reactivate oRsCur - already
						; on stack
;end of revision [39]

	mov	al,NOT (NM_fShared OR NMSP_Variable)
	call	ResetTNamMask
FreeVarTbl:
	call	VarRudeReset		;erase module's variable & type tables
NoVarTbl:
	or	[mrsCur.MRS_flags],FM_AllSsRude ;all tables are now SS_RUDE
	SetfDirect al,FALSE		;turn off Direct mode
	mov	ax,sp			;return non-zero (for ForEachCP)
cEnd

cProc	ModuleRudeEditFar,<PUBLIC,FAR>
cBegin
	call	ModuleRudeEdit
cEnd

;**************************************************************
; TxtDescan()
; Purpose:
;	Descan the current text table to SS_PARSE in preparation
;	for an edit (i.e. a call to TxtDelete or TxtChange).
;	If it is a module's text table being descanned, all procedures
;	within the module are descanned as well, because they could
;	contain text offsets into module's text table which are now
;	invalid.  For example, RESTORE <label>, ON ERROR GOTO <label>,
;	ON <event> GOSUB <label>.
;
;**************************************************************
cProc	TxtDescanCP,<PUBLIC,NEAR>
cBegin
	mov	[descanTo],SS_PARSE
	test	[txdCur.TXD_flags],FTX_mrs
	je	ProcOnly	;brif descanning a procedure text table
	mov	al,FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET DoDescan
	call	ForEachCP		;DoDescan can return no error codes
ProcOnly:
	call	DoDescan
cEnd

;**************************************************************
; TxtModified()
; Purpose:
;	Descan the current text table to SS_PARSE in preparation
;	for an edit (i.e. a call to TxtDelete or TxtChange).
;	It also sets FM2_Modified bit in current module, so user
;	will be prompted to save it before next NEW or LOAD
; Exit:
;	current module's fModified bit is set TRUE
;
;**************************************************************
cProc	TxtModified,<FAR,PUBLIC>		
cBegin	TxtModified				
	test	[mrsCur.MRS_flags2],FM2_File
	je	TmExit			;brif this mrs has no FILE
TmMod:
	or	[mrsCur.MRS_flags2],FM2_Modified or FM2_ReInclude 
					;This call is always followed
					; by a call to TxtChange/TxtDelete
TmExit:
	jmp	SHORT StartTxtDescan		
TxtModified ENDP

cProc	TxtDescan,<FAR,PUBLIC>			
cBegin	TxtDescan				
StartTxtDescan:					
	call	TxtDescanCP		;far to near call gate
cEnd	TxtDescan				

;*********************************************************************
; AskCantCont()
;
; Purpose:
;  AskCantCont() is called by TextMgr when it is about to make an
;  edit which would prevent continuing program execution.
;  This routine can not be called during execution.
;  If already impossible to continue (i.e. grs.otxCONT ==
;     UNDEFINED) AskCantCont returns TRUE.  Otherwise, the user is warned
;     with a dialog box that this edit will prevent continuing.
;  If the user says OK, grs.otxCONT is set to UNDEFINED
;     and the context manager's CantCont() is called (which
;     sets grs.otxCONT to UNDEFINED among other things.
;     AskCantCont() then returns TRUE.
;  If the user says CANCEL, the Debug screen is refreshed (discarding
;     the current edit) and AskCantCont() returns FALSE.
;
; Exit:
;  Returns FALSE if user wants to abort current edit, with
;  condition codes set based on value in ax.
;
;*********************************************************************
cProc	AskCantCont_CP,<PUBLIC,NEAR>
cBegin
	call	AskCantCont
	or	ax,ax			;set condition codes for caller
cEnd	;AskCantCont_CP


;**************************************************************
; AskRudeEdit
; Purpose:
;	Ask if user wants to back out of what will be a RUDE edit
; Note:
;	This function can cause heap movement
; Exit:
;	If user wants to back out, ax = 0
;	else ModuleRudeEdit is performed, ax = nonzero
;	condition codes set based on value in ax
;
;**************************************************************
cProc	AskRudeEdit,<PUBLIC,NEAR>
cBegin
	call	AskCantCont_CP		;ask user "Want to back out?"
	je	AskRudeExit		;brif user wants to back out of edit
	call	ModuleRudeEdit		;descan module to SS_RUDE, discard
					; module's variable & type tables
	mov	ax,sp
AskRudeExit:
	or	ax,ax			;set condition codes for caller
cEnd

;Far gateway to AskRudeEdit
cProc	AskRudeEditFar,<PUBLIC,FAR>
cBegin
	call	AskRudeEdit
cEnd

;**************************************************************
; UpdatePcs(otxEditStart, cbIns, cbDel, fTestOnly)
; Purpose:
;	Update program counter due to the insertion or deletion of text.
;	If pc is deleted, AskCantCont.
;	If pc moves (because of insert/delete),
;	   and fTestOnly=FALSE, update the pc.
; Entry:
;	grs.oRsCur identifies text table being edited
;	otxEditStart = offset into text table to 1st byte inserted/deleted
;	cbIns = # bytes inserted
;	cbDel = # bytes deleted
;	fTestOnly = non-zero if we're testing for Edit & Continue
;	   not really updating pc
;
; Exit:
;	Carry is set if edit would prevent CONT
;
;NOTE: exit conditions of UpdatePcs never return
; with carry set.  Some code could be saved.
;
;**************************************************************
cProc	UpdatePcs,<PUBLIC,NEAR>,<si>
	parmW	otxEditStart
	parmW	cbIns
	parmW	cbDel
	parmW	fTestOnly
cBegin
	call	ORsCurTxtTbl		;ax = oRs of current text table
	cmp	ax,[grs.GRS_oRsContTxtTbl]
	jne	UpcUnaffected		;brif edit didn't affect PC
	mov	ax,[grs.GRS_otxCONT]	;ax = current program counter
	inc	ax			;test for UNDEFINED
	je	UpcUnaffected		;brif can't continue
	dec	ax			;restore ax = otxCONT
	mov	dx,[otxEditStart]
	cmp	dx,ax
	je	SetToBol
	ja	UpcUnaffected		;brif PC was below edit (unaffected)

	;This edit is having an effect on the current instruction pointer
	add	dx,[cbDel]		;dx points beyond end of delete
	cmp	dx,ax
	jbe	UpcNotDel		;brif PC wasn't deleted by edit
SetToBol:
	mov	ax,[otxEditStart]	;Reset program counter to start
					; of edited line
	jmp	SHORT UpcUpdated

;line with program counter has been moved up or down in memory
UpcNotDel:
	add	ax,[cbIns]
	sub	ax,[cbDel]
UpcUpdated:
	cmp	[fTestOnly],FALSE
	jne	UpcUnaffected		;brif just testing for Edit & Cont
	mov	[grs.GRS_otxCONT],ax
UpcUnaffected:
	clc				;indicate no error
UpcExit:
cEnd

;*************************************************************************
; ORsCurTxtTbl
; Purpose:
;	Get oRs of current text table.  Only time this is different from
;	grs.oRsCur is when grs.oRsCur is for a DEF FN (which uses module's
;	text table).
;
; Exit:
;	ax = oRs of current text table.
;
;*************************************************************************
cProc	ORsCurTxtTbl,<PUBLIC,NEAR>
cBegin
	mov	ax,[grs.GRS_oMrsCur]	;ax = oRs of module's text table
	test	[txdCur.TXD_flags],FTX_mrs
	jne	OctExit			;brif module's txt tbl is active
	mov	ax,[grs.GRS_oRsCur]	;ax = oRs of procedure's text table
OctExit:
cEnd

;*************************************************************************
; OtxDefType(otx), OtxDefTypeCur, OtxDefType0, OtxDefTypeEot
;
; Purpose:
;	This causes  the text  manager to  traverse the linked
;	list of  DEFxxx statements  for the current text table
;	and accumulate	the current  state  for  a  particular
;	offset into  the  text	table.	  If  the  text  table
;	contains no  DEFxxx statements,  on exit, the array is
;	filled with 26 * ET_R4 (ET_R8 for EB).
;	A opStDefType opcode looks like:
;
;		<opStDefType><link field><high-word><low-word>
;	where
;		<high-word> has 1 bit set for each letter from A..P
;		<low-word> has 1 bit set for each letter from Q..Z in the
;			high bits, and type (ET_I2..ET_SD) in the low 3 bits.
;
; Entry:
;	OtxDefType, OtxDefTypeCur: ax = otx - byte offset into text table
;	OtxDefType: bx = pointer to table of 26 bytes to be filled
;
; Exit:
;	OtxDefType: parm2's table is filled with result
;	OtxDefTypeCur: fills tEtCur with result
;	OtxDefType0: fills tEtCur with ET_R4 (ET_R8 for EB)
;	OtxDefTypeEot: fills tEtCur with the default types at the end
;	   of the current text table.
;	grs.fDirect is preserved in all cases
;
;*************************************************************************
PUBLIC	OtxDefTypeEot
OtxDefTypeEot PROC NEAR
	mov	ax,[txdCur.TXD_bdlText_cbLogical] ;go until end-of-text
	SKIP2_PSW			;skip following sub ax,ax
OtxDefTypeEot ENDP

OtxDefType0 PROC NEAR
	SetStartOtx ax			;ax = start of text
OtxDefType0 ENDP

PUBLIC	OtxDefTypeCur
OtxDefTypeCur PROC NEAR
	mov	bx,dataOFFSET ps.PS_tEtCur
OtxDefTypeCur ENDP

PUBLIC	OtxDefType

cProc	OtxDefType,<NEAR>,<si,di>
	localW	EndOtx
	localW	EtTable
cBegin	OtxDefType
	mov	[EndOtx],ax		;initialize Endotx for loop
	mov	[EtTable],bx		;init ptr to top of table for loop


; Initialize table to all ET_R4 (ET_R8 for EB)
	mov	di,bx	 		;di -> type table
	push	ds			;need es=ds for rep stosb
	pop	es

	mov	cx,26			;26 letters in alphabet
	mov	al,ET_R4		;default type is single precision
	rep stosb


	DbChk	TxdCur			;perform sanity check on txdCur

	;Now go through text table, altering table for each DEFxxx
	; NOTE: this need not be done if parser never builds var table entries
	
	GETSEG	es,[txdCur.TXD_bdlText_Seg],,<SIZE,LOAD>
	mov	bx,[txdCur.TXD_otxDefTypeLink]
					;bx points to start of this text
					; table's linked list of DEFxxx stmts
					; or = FFFF if linked list is empty
;bx = otxCur
DefLoop1:
	mov	ax,[EndOtx]		;ax = otx parm
	mov	di,[EtTable]		;di = ptr to table
	cmp	bx,ax			;see if we're beyond place of interest
	jae	DefTypeEnd		;branch if so

	mov	si,bx			;si points to next DefType link
					; or FFFF if end of linked list
	lods	WORD PTR es:[si]	;ax points to next DefType link
					; or = FFFF if end of linked list
	xchg	bx,ax			;bx points to next DefType link
	mov	dl,es:[si]		;dl = low byte of args
	and	dl,02FH			;dl = type (ET_I2..ET_SD)
	mov	cx,16			;examine 16 bits in 1st word
	mov	dh,1			;go through DefLoop2 twice
	mov	ax,es:[si+2]		;ax = high mask of bits
	jmp	SHORT DefLoop3

DefLoop2:
	lods	WORD PTR es:[si]	;ax = low mask of bits
DefLoop3:
	shl	ax,1
	jnc	BitNotSet		;brif bit not set for this letter
	mov	[di],dl 		;save type in type table
BitNotSet:
	inc	di			;advance to next entry in type table
	loop	DefLoop3		;advance to next bit in mask
	mov	cx,10			;examine 10 bits in 2nd word
	dec	dh			;test DefLoop2 flag
	je	DefLoop2		;brif need to do 2nd word
	jmp	SHORT DefLoop1		;advance to next DEFxxx stmt

DefTypeEnd:
cEnd	OtxDefType


cProc	OtxDefType0Far,<PUBLIC,FAR>	;added as part of revison [20]
cBegin
	call	OtxDefType0
cEnd

cProc	OtxDefTypeCurFar,<PUBLIC,FAR>	;added as part of revison [20]
	parmW	oTx
cBegin
	mov	ax,[oTx]
	call	OtxDefTypeCur
cEnd

;**********************************************************************
; EtDiff
; Purpose:
;	Determine the difference between two tables of ET_xxx's
;	Used by ASCII Load and ASCII Save for inserting DEFxxx statements
;	which let each procedure text table appear to be independant of
;	the module's text table's DEFxxx statements.
; Entry:
;	parm1 points to a table of 26 bytes, on ET_xxx for each letter
;	parm2 points to another table of 26 bytes, on ET_xxx for each letter
;	parm3 = ET_xxx
; Exit:
;	ax:dx = DEFTYPE bit mask, as would appear in opStDefType's operand,
;	representing the difference between table 1 and table2 with
;	respect to parm3's type.
; Example:
;	parm1 contains ET_I2, ET_I4, ET_I2, ET_R4, ..., ET_R8
;	parm2 contains ET_I4, ET_I4, ET_I4, ET_R4, ..., ET_R8
;	parm3 contains ET_I4
;	result = 0xA0000002
;
;**********************************************************************
cProc	EtDiff, <NEAR, PUBLIC, NODATA>,<si,di>
	parmW	tEtBase
	parmW	tEtNew
	parmB	etNew
cBegin	EtDiff
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	di,[tEtBase]		;di points to old deftype table
	mov	si,[tEtNew]		;si points to new deftype table
	mov	cx,26			;cx = repeat count (1 for each letter)
	sub	bx,bx			;init mask dx:bx to 0
	sub	dx,dx
EtCmpLoop:
	lodsb				;al = base type
	cmp	al,[di] 		;compare with new type
	je	NoDiff			;branch if no difference
	cmp	al,[etNew]		;compare with type we're interested in
	jne	NoDiff			;branch if we don't care about this type
	or	bl,20H			;set bit which represents Z+1
NoDiff:
	inc	di
	shl	bx,1			;shift dx:bx left 1
	rcl	dx,1
	loop	EtCmpLoop		;repeat for all letters a..z
	mov	ax,bx			;dx:ax = result
	or	bx,dx			;bx = high word ORed with low word
	je	EtDiffX 		;brif no difference between 2 tables
					; with respect to type etNew
	or	al,[etNew]		;dx:ax = opStDefType's operand
EtDiffX:
cEnd	EtDiff



;--------------------------------------------------------------
;	Re-Parsing Functions
;
; Many errors are ignored at edit-time, on the assumption that
; the user will repair the problem before attempting to execute.
; The general solution when one of these errors are encountered
; at edit time is to store the entire source line in the pcode
; within an opReParse opcode.  Then, when the user is about to
; execute, we re-parse these lines and report any errors encountered
; with the following call-tree:
;
;                       ReParseTbl
;                           |
;                      +----+-----+
;                      |          |
;                  DoReParse  PreScanAsChg
;                      |
;                 TxtReEnter
;                      |
;                  +---+---+
;                  |       |
;              ListLine TxtChange
;
;--------------------------------------------------------------

;**************************************************************
; TxtReEnter, TxtReEnterBol
; Purpose:
;	Convert a line of pcode to source, parse it to pcode
;	and replace old pcode with new pcode.  This is done
;	for each line in the ReParse list before execution.
;	It is also done for each $INCLUDE line for FILE/REINCLUDE menu.
; Entry:
;	ax = offset into current text table anywhere within source line
;	     (points to opBol opcode for TxtReEnterBol variant)
; Exit:
;	same as for TxtChange
; Alters:
;	ps.bdpSrc (parser's source buffer)
;
;**************************************************************
PUBLIC	TxtReEnter
TxtReEnter PROC NEAR
	DbChk	Otx,ax			;error if ax > txdCur.bdlText.cbLogical
	push	ax
	call	OtxBolOfOtx		;ax = otx for start of INCLUDE line
	;fall into TxtReEnterBol
TxtReEnter ENDP

TxtReEnterBol PROC NEAR
	DbChk	Otx,ax			;error if ax > txdCur.bdlText.cbLogical
	push	ax			;pass otx to start of line to TxtChange

	push	ax			;pass otx to ListLine
	PUSHI	ax,<DATAOFFSET ps.PS_bdpSrc>	;pass dst adr to ListLine
	call	ListLine
	inc	ax			;test for UNDEFINED
	je	TrOmErr			;brif out-of-memory
	dec	ax			;restore ax = cb

	;If this line was included, set cInclNest non-zero, so parser
	;will generate an opBolInclude instead of an opBol for this line
	
	mov	al,[fLsIncluded]
	mov	[cInclNest],al

					;otxStart pushed several lines above
	push	[otxListNextInc]	;pass offset beyond end of line
	sub	ax,ax			;clear fNoInsert flag
	push	ax			;We have txt to insert
	call	TxtChange
	mov	[cInclNest],0		;restore: we know we're not loading
					; an INCLUDE file
TrExit:
	ret
TxtReEnterBol ENDP

;Out-of-memory error
TrOmErr:
	mov	ax,ER_OM		;ax = std error code for out-of-memory
	mov	[txtErr.TXER_errCode],ax
	jmp	SHORT TrExit

;**************************************************************
; DoReParse
; Purpose:
;	Re-Parse the 1st line after a given point in the current
;	tables 'reparse' list.
; Entry:
;	ax = text offset to start looking for lines to reparse
;	bx = text offset to stop looking for lines to reparse
; Exit:
;	ax = same as for TxtChange
;	If line was reparsed without errors
;	   carry clear on exit
;	else
;	   carry set on exit
;	   if error occurred (i.e. didn't just reached end of reparse list)
;	      txtErr struct is filled in.
;
;**************************************************************
PUBLIC	DoReParse
DoReParse PROC NEAR
	push	si			;save caller's si
	mov	si,[txdCur.TXD_otxReParseLink] ;si = otxLink
	xchg	dx,ax			; dx = starting otx, ax = garbage
	GetSegTxtTblCur			;es = seg addr of current text tbl
DrNext:
	sub	ax,ax			;prepare to return 0 (no TxtChange err)
	cmp	si,bx
	jae	DrEOL			;brif end of reparse list
	cmp	si,dx			;compare with otxStart parm
	jae	DrAbove
	mov	si,es:[si]		;si points to next opReParse link
	jmp	SHORT DrNext		;brif below otxStart
DrEOL:
	DJMP	jmp SHORT DrEndOfList

;si = otxLink = text offset to next re-parse opcode's link field.
;List this line and re-parse it.
;
;NOTE: It is real tempting to just call OtxBolOfOtx to get the
; offset to the start of the reparse line.  This SIGNIFICANTLY
; slows down paste.  We are guaranteed that the only opcodes that
; we may see before an opReParse are opBol, opBolInclude, opBolLab, and
; opBreakPoint.  Therefore the following opcode sequences could be seen:
;			  opBol  [opBreakPoint]
;	     opBolInclude(depth) [opBreakPoint]
;    opBolLab(otxNextLink, oNam) [opBreakPoint]
;
; The following code assumes the following:
;    opBol = 0
;    depth for include files is [1-5].
;    oNam for opBolInclude > 5
;    oTxNextLink > opBolInclude
;

DrAbove:
	mov	bx,-6			;amount to backup past count and
					; opcode field for opReparse

	mov	ax,si			;pass otxLink in ax
	cmp	word ptr es:[si+bx],opBreakPoint ;is there a BP set at the start
					; of this line?
	jne	DrGotBol		;brif not, already at opBol
	dec	bx			;back up past opBreakPoint
	dec	bx			; to opBol

; Parser guarantees only opBol, opBolLab, or opBolInclude before an opReparse.

DrGotBol:
	mov	cx,es:[si+bx]		;cx = opcode
	and	cx,OPCODE_MASK		;upper bits = leading spaces
	.errnz	opBol
					;have a standard opBol?
	jcxz	DrReenter		;brif so, reenter line

; We must have a line starting with opBolInclude, or opBolLab
	DbAssertRel oNamFirst,a,INCLUDE_DEPTH_MAX,CP,<DoReParse: err2>
	dec	bx
	dec	bx			;back up over include depth/oNam
	mov	cx,es:[si+bx]		;cx = opcode
	and	cx,OPCODE_MASK		;upper bits = leading spaces

	DbAssertRel opBolInclude,be,5,CP,<DoReParse: err3>
	cmp	cx,opBolInclude 	;is this an opBolInclude?
	je	DrReenter		;brif so

; We must have a line starting with opBolLab
	dec	bx
	dec	bx			;back up over include otxNextLink

DrReenter:
	add	ax,bx			;back up to bol opcode

	call	TxtReEnterBol		;reparse line ax
	cmp	[txtErr.TXER_errCode],0 ;tell caller a line was successfully
					; reparsed
	je	DrExit			;brif no error (carry is clear)
DrEndOfList:
	stc				;return carry set (no reparse, or error)
DrExit:
	pop	si			;restore caller's si
	ret
DoReParse ENDP

;**************************************************************
; ReParseTbl
; Purpose:
;	Called by SystemScan via ForEachMrs.  Finds all lines
;	that contain opReParse, and re-parses them until current
;	module contains no opReParse opcodes.
;	Caller should reset FM_asChg bit in mrsCur.MRS_flags
;	after all text tables in this module have no opReParse opcodes.
; Exit:
;	Same as ScanTxtTbl
;
;**************************************************************
cProc	ReParseTbl,<PUBLIC,NEAR>,<si>
cBegin

RptLoop0:
	;change any pcode which results from insertion/deletion of
	;AS clauses (due to their affect on ids with .)
	
	mov	al,[mrsCur.MRS_flags]
	mov	si,ax			
	and	[mrsCur.MRS_flags],NOT FM_asChg

RptLoop1:
	test	si, FM_asChg		
	je	NoAsChg			;brif no 'x AS' clauses have been
					; inserted or deleted in module.
	call	PreScanAsChg		;Re-Parse every line in current
					; text table with AS <user type>
					; or any non-record var with a
					; period in its name.
NoAsChg:
	call	ReParseTxdCur		
	jz	RptExit			
	call	NextTextPrsInMrs	;activate next procedure in module
	inc	ax
	jne	RptLoop1		;brif not at end of proc list
	dec	ax			;ax = UNDEFINED (return TRUE)
	test	[mrsCur.MRS_flags],FM_asChg
	jne	RptLoop0		;brif ReParse loop made added any
					; X AS clauses.
RptExit:
cEnd


;**************************************************************
; ReParseTxdCur
; Purpose:
;	Finds all lines in txdCur that contain opReParse,
;	and re-parses them.
;
;	This code was split out of ReParseTbl in revision [32].
; Exit:
;	Same as ScanTxtTbl
;	NZ and AX != 0	- Ok
;	Z and AX == 0	- Fail
;
;**************************************************************
cProc ReParseTxdCur,<NEAR,PUBLIC>,<DI>
cBegin
	mov	di,[grs.GRS_oRsCur]	;remember current oRs

;Now re-parse every line in current text table with opReParse opcode
;
RptLoop2:
	cmp	di,[grs.GRS_oRsCur]	;did we change our Rs?
	je	RptSameRs		;brif not

;A call to TxtRenEnter caused us to change to a new Rs.  This can only
; happen in the extremely rare case where a SUB or FUNCTION definition
; is a reparse (e.g. could already have one with the same name), and
; it can now be reparsed successfully, which causes a new Rs to be
; created and activated (e.g. the user Deleted the duplicate SUB or
; function before trying to execute).  In this case, we reactivate
; the original Rs continue reparsing it to completion.	If we don't
; do this, we could try to scan a text table containing reparses.
;
	extrn	RsActivateIfNotFree:near
	mov	ax,di			;ax = oRs to activate.
	call	RsActivateIfNotFree	;reactivate previous oRs (in AX)
					; unless ParseLine just renamed

RptSameRs:
	mov	ax,[txdCur.TXD_otxReParseLink]
	inc	ax			;test for UNDEFINED
	je	RptDone			;brif done with ReParse lines
	dec	ax
	mov	bx,0FFFFh		;search until end of text table
	call	DoReParse		;parse next opReParse in this text tbl
	jnc	RptLoop2		;brif progress was made (i.e. a line
					; was re-parsed with no errors)
	;TxtReEnter encountered an error.  txtErr struct was set up by TxtChange
	sbb	ax,ax			;ax = -1

RptDone:
	inc	ax			;Return 0 for fail, 1 for Ok
cEnd



;--------------------------------------------------------------
;		INCLUDE file support functions
;--------------------------------------------------------------

;**************************************************************
; SetViewInclude
; Purpose:
;	Enable or disable the visibility of $INCLUDEd source lines
; Entry:
;	parm uchar fEnable = TRUE if lines are to be visible
;
;**************************************************************
cProc	SetViewInclude,<PUBLIC,FAR>
	parmB	fEnable
cBegin
	mov	al,[fEnable]
	mov	[fViewInclude],al
	call	TxtFlushCache
cEnd

;**************************************************************
; TblReInclude
; Purpose:
;	Called for each text table to re-invoke $INCLUDE directives
;	in this text table.
; Exit:
;	returns ax = 0 if fatal error occurred (like out-of-memory,
;	or File-not-found) else returns non-zero
;
;**************************************************************
cProc	TblReInclude,<PUBLIC,NEAR>
cBegin
	PUSHI	ax,0
	call	CmdViewInclude		;make $INCLUDEd lines invisible
	DbAssertRelB [fViewInclude],e,0,CP,<TblReInclude fViewInclude != 0>
	and	[mrsCur.MRS_flags2], NOT FM2_ReInclude 
	sub	ax,ax
TblLoop:
	push	ax			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpReInclude>
	call	TxtFindNextOp		;ax = otx to next op_Include ($INCLUDE)
					;		(or OpStInclude [01])
					;dl = [txtFindIndex]
	cmp	dl,RI_opEot
	je	TblDone			;brif done with this text table


	;NOTE: next 3 lines must remain contiguous
	push	ax			;pass otx to OtxNoInclude
	call	TxtReEnter		;re-evaluate it, ignoring all errors
	call	OtxNoInclude		;ax = offset to next opBol/opEot
					; which was not included
	cmp	[txtErr.TXER_errCode],ER_OM
	jne	TblLoop			;brif TxtReEnter was successful
	sub	ax,ax			;return 0 (out-of-memory return code)
	jmp	SHORT TblExit

TblDone:
	sub	ax,ax
	mov	[txtErr.TXER_errCode],ax ;any errors encountered are in the
					; form of opReParse
	dec	ax			;return TRUE (non-zero)
TblExit:
cEnd

;**************************************************************
; TxtReInclude
; Purpose:
;	Called when user tries to execute a program.  If no loaded
;	INCLUDE files have been modified since last saved, it just
;	returns.  Else, it re-invokes the $INCLUDE directives in all
;	loaded text tables.  Errors are not reported, but reparsed.
;	The user will see any errors when he attempts to execute.
; Entry:
;	none
; Exit:
;	grs.fDirect = FALSE
;	ax = txtErr.errCode = error code if any error occurred while loading
;
;**************************************************************
cProc	TxtReInclude,<PUBLIC,FAR>
cBegin
	mov	[txtErr.TXER_errCode],0
	test	[flagsTm],FTM_reInclude
	je	NoReInclude
	and	[flagsTm],NOT FTM_reInclude
	call	SystemDescanCP		;descan all tables to SS_PARSE
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET TblReInclude
	call	ForEachCP
NoReInclude:
	mov	ax,[txtErr.TXER_errCode]
cEnd

;*********************************************************************
; TxtFLnIncluded
; Entry:
;	parm1 = ln
; Exit:
;	ax = 0 if line was from $INCLUDE file
;
;*********************************************************************
cProc	TxtFLnIncluded,<PUBLIC,FAR>
	parmW	ln
	localV	bdBuf,<size BD>
cBegin
	push	[ln]			;pass line # to OtxOfLn
	call	OtxOfLn			;ax = otx for line
	push	ax			;pass otx to ListLine
	lea	bx,bdBuf		;pass pbd to ListLine
	mov	[bx.BD_pb],DATAOFFSET bufStdMsg
	mov	[bx.BD_cbLogical],0
	push	bx			;can't use bdpSrc, because editor
					; may have dirty copy of a line in it.
	call	ListLine		;set fLsIncluded for current line
					; since cbLogical is < 80, ListLine will
					; not try to grow buffer (it assumes
					; it is static). We just need the
					; 1st pass of the lister to execute,
					; not Stage2, since fLsIncluded is
					; set up during Stage1.
	mov	al,[fLsIncluded]
	cbw				;ax = result
cEnd

;*********************************************************************
; ushort TxtViewIncl(lnIncl, fDoIt)
; Purpose:
;	Called when user selects View/Include while insertion point
;	is on a line that has $INCLUDE in it.  This function creates
;	a new mrs by that name, and loads the file into that mrs.
; Entry:
;	grs.oRsCur is loaded with active window's register set.
;	lnIncl = the current line number in the active list window.
;	fDoIt = TRUE if the file is to actually be loaded (FALSE
;	   if we're just checking to see if current line contains $INCLUDE)
; Exit:
;	If fDoIt was FALSE on entry
;          if the line contains no $INCLUDE opcode, the function returns
;	      0
;	   else
;             it returns non-zero
;	   if lnIncl came from an $INCLUDE file, fLsIncluded is set
;	      non-zero, else it is set to 0.
;	else
;	   exit conditions are the same as LoadFile
; Alters:
;	ps.bdpDst (parser's pcode result buffer)
;
;*********************************************************************
cProc	TxtViewIncl,<PUBLIC,FAR>,<si>
	parmW	lnIncl
	parmW	fDoIt
	localV	filenameInc,FILNAML64
	localV	sdFilenameInc,<SIZE SD>
	localV	bdBuf,<size BD>
cBegin
	lea	si,sdFilenameInc
	lea	ax,filenameInc
	mov	[si.SD_pb],ax
	sub	ax,ax
	mov	[si.SD_cb],ax
	mov	[bdBuf.BD_cbLogical],ax ;pass cbMax to ListLine
					; since it is < 80, ListLine will
					; not try to grow buffer (it assumes
					; it is static). We just need the
					; 1st pass of the lister to execute,
					; not Stage2, since psdLsIncl is
					; set up during Stage1.
	mov	[bdBuf.BD_pb],DATAOFFSET bufStdMsg
					;pass ptr to buffer to ListLine

	push	[lnIncl]		;pass current line
	call	OtxOfLn			;ax = text offset to start of line
	push	ax
	call	OtxNoInclPrev		;ax = otx of $INCLUDE line if this
					; line is from an include file

	push	ax			;pass text offset
	lea	ax,bdBuf
	push	ax			;can't use bdpSrc, because editor
					; may have dirty copy of a line in it.
	mov	[psdLsIncl],si		;causes ListLine to load sdFilenameInc
	call	ListLine		; with arg to $INCLUDE
	sub	ax,ax
	mov	[psdLsIncl],ax
	cmp	[fDoIt],ax
	mov	ax,[si.SD_cb]		;ax = non-zero if $INCLUDE was found
	je	TviExit			;return if fDoIt was FALSE

	;should never be called with fDoIt true if line contains no $INCLUDE
	DbAssertRel ax,ne,0,CP,<TxtViewIncl: err2>
	push	si			;pass &sdFilenameInc
	PUSHI	ax,LF_ViewIncl		;pass file type
	inc	[fLoadInclude]		; inform LoadFile of $INCLUDE
	call	LoadFile		;ax = error code
	dec	[fLoadInclude]		; reset flag
TviExit:
cEnd

;**************************************************************
; SetCompSwitches
; Purpose:
;	Called by user interface when it is about to invoke
;	Compiler to produce an EXE file.  This function
;	scans the current text table's pcode, and sets the
;	following masks in the global static variable
;	'compSwitches' as follows:
;	  COMP_SW_E is set for each module which has ON ERROR stmt
;	  COMP_SW_X is set for each module which has RESUME [NEXT] stmt
;	  COMP_SW_V is set if any module has ON <event> stmt
;	  COMP_SW_W is set if any module has ON <event> stmt
;
; Exit:
;	ax is always non-zero (so it can be called by ForEach...)
;
;**************************************************************
cProc	SetCompSwitches,<PUBLIC,FAR>
cBegin
	call	B$GetCompSwitches	; AX nonzero if QLB used /V or /W
	or	ax,ax			
	jz	ScLoop			;brif no /V or /V in QLB
	or	[compSwitches],COMP_SW_V + COMP_SW_W ;set /V/W switches

	sub	ax,ax			;start at text offset 0
ScLoop:
	push	ax			;pass otxCur
	PUSHI	ax,<CODEOFFSET tOpCompSw>
	call	TxtFindNextOp		;ax = otx to next opcode of interest
					;dl = txtFindIndex
	cmp	dl,CSW_opEot
	je	ScExit			;brif reached opEot

	mov	bl,COMP_SW_E
	.errnz	CSW_opStOnError
	or	dl,dl
	je	ScOrMask

	mov	bl,COMP_SW_V + COMP_SW_W
	cmp	dl,CSW_EventMax
	jbe	ScOrMask		;brif ON <event>  or  <event> ON

;	If we fall through to here we have some sort of RESUME statement.
;	All variants except one require /X.  The exception is opStResume
;	with an operand other than UNDEFINED.  In this case /E is sufficient,
;	/X is overkill.  Because generated code for /E is significantly
;	smaller than /X we check for that special case here.

	mov	bl,COMP_SW_X		; assume not special case
	cmp	dl,CSW_opStResume	; found an opStResume?
	jne	ScOrMask		; no, can't be special case
	GetSegTxtTblCur 		; es = seg adr of current txt tbl
	xchg	ax,bx			; es:bx = oTx of opStResume
	cmp	word ptr es:[bx+2], UNDEFINED ; "RESUME 0" statement?
	xchg	ax,bx			; bl = /X again
	je	ScOrMask		; brif it's "RESUME 0", need /X
	mov	bl,COMP_SW_E		; got it! only need /E
ScOrMask:
	or	[compSwitches],bl
	jmp	SHORT ScLoop

;we know ax is non-zero because there is always an opEndProg before an opEot
; in every text table
ScExit:
cEnd

;**************************************************************
; ONamOVarRudeOrParse
; Purpose:
;	Get the oNam for a variable
; Entry:
;	parm1 = oNam if txdCur.scanState == SS_RUDE
;	      = oVar if txdCur.scanState == SS_PARSE
; Exit:
;	ax = variable's oNam
;
;**************************************************************
cProc	ONamOVarRudeOrParse,<FAR,PUBLIC> 
	ParmW	oNamoVar		
cBegin	ONamOVarRudeOrParse		
	mov	ax,[oNamoVar]		
	DbChk	ConStatStructs		;ensure static structures
	cmp	[txdCur.TXD_scanState],SS_RUDE
	jae	NoVarConv		; brif table is in rude-edit state
	DbChk	oVar,ax
	xchg	ax,bx			;bx is now the oVar
	add	bx,[mrsCur.MRS_bdVar.BD_pb] ;bx points to entry for variable
	mov	ax,VAR_oNam[bx] 	;fetch oNam from variable table
NoVarConv:				;ax = variable's oNam
	DbChk	oNam,ax			;pass oNam from op[A]Idxxx opcode
cEnd	ONamOVarRudeOrParse		


;--------------------------------------------------------------
; Functions which let identifiers with periods (like A.B)
; be either a scalar/array (for compatibility) or a record
; element (to support records with C-like syntax).
; In some future version of BASIC, it is conceivable that
; A.B will always mean 'element of record'.
;--------------------------------------------------------------

;**************************************************************
; ONamOfAs
; Purpose:
;	Given a pointer to an  opAsType(oNamTyp) op[A]VtRef(oNamId),
;	which is produced for syntax like 'id as user-type' in a DIM
;	type statement,	return the oNam for id.
; Entry:
;	ax = text offset into current text table to opAsType pcode
;	current text table's scan state is either SS_RUDE or SS_PARSE
; Exit:
;	carry is set if opAsType is from expression in TYPE/END TYPE block
;	else ax = oNam of id
;
;**************************************************************
ONamOfAs PROC NEAR
DbAssertRelB [txdCur.TXD_scanState],ne,SS_EXECUTE,CP,<ONamOfAs: bad scanState>
	xchg	bx,ax			;bx = text offset
	GetSegTxtTblCur			;[42]es = seg addr of current txt tbl
	cmp	WORD PTR es:[bx-4],opElemRef 
	stc				;assume we are in a TYPE block
					;note JE ONLY checks psw.z.
	je	OaExit			;brif in TYPE/END TYPE block
	
	mov	ax,es:[bx+6]		;ax = opcode following opAsType
	mov	dx,es:[bx+8]		;dx = oNam/oVar operand if scalar
.erre	opIdLd LT opVtRf		
.erre	opAIdLd GT opVtRf		
.erre	opAVtRf	GT opVtRf		
	cmp	ax,opVtRf		
	jle	OaGotONam		;brif got opVtRf or opIdLd
	mov	dx,es:[bx+10d]		;dx = oNam/oVar operand for array

OaGotONam:
	push	dx			;pass parm = oNam/oVar
	call	ONamOVarRudeOrParse 	;ax = variable's oNam
	clc
OaExit:
	ret
ONamOfAs ENDP


;**************************************************************
;ChkAsInTbl
;Purpose:
;	Checks to see if there are any refs to oNam AS in this
;	text table, for a particular oNam.  Any pcode within
;	a range which is being deleted is ignored.
;	If oNam AS is found within a TYPE block, it is ignored,
;	because type elements have their own name space.
;Entry:
;	oNamAs - oNam in question
;	oRsAs - identifies text table where text is being deleted.
;	otxAsDelStart - offset to 1st byte being deleted
;	otxAsDelEnd - offset to last byte being deleted
;Exit:
;	If oNam AS is found, returns 0
;
;**************************************************************
ChkAsInTbl PROC NEAR
	push	si			;preserve caller's si
	sub	si,si			;initial text offset = 0
CiLoop:
	push	si
	PUSHI	ax,<CODEOFFSET tOpAsType>
	call	TxtFindNextOp		;ax points to next opcode of interest
	cmp	dl,ASTYPE_opEot
	je	CiDone			;brif done with text table
	mov	si,ax			;si points to current opcode
	mov	cx,[oRsAs]
	cmp	cx,[grs.GRS_oRsCur]
	jne	CiCountIt		;brif it's not being deleted
	cmp	ax,[otxAsDelStart]
	jb	CiCountIt		;brif it's not being deleted
	cmp	ax,[otxAsDelEnd]
	jb	CiLoop			;brif it's being deleted
CiCountIt:
	cmp	dl,ASTYPE_opStDefFn
	jb	CiNotDeclare		;brif its not SUB/FUNC/DEFFN/DECLARE op

;Walk through parm list seeing if there are any oNam AS ... in parm list
	push	si			;save ptr to opStDeclare/Sub/Func
	jne	CiNotDefFn
	inc	si			;skip link field
	inc	si
CiNotDefFn:
	add	si,DCL_cParms+2		;si points to parm count field
	GETSEG	es,[txdcur.TXD_BDLTEXT_SEG] 
	lods	WORD PTR es:[si]	;ax = parm count (UNDEFINED same as 0)
	xchg	cx,ax			;cx = parm count
CiParmLoop:
	dec	cx
	js	CiParmDone		;brif done with parm list
	lods	WORD PTR es:[si]	;ax = parm's oNam/oVar
	xchg	bx,ax			;bx = parm's oNam/oVar
	lods	WORD PTR es:[si]	;ax = parm's atr flags
	xchg	dx,ax			;dx = parm's atr flags
	lods	WORD PTR es:[si]	;ax = parm's oTyp (oNam of type if rude)
	test	dx,PATR_asClause
	je	CiParmLoop		;brif parm has no AS clause
	cmp	ax,ET_MAX
	jbe	CiParmLoop		;brif ANY,INTEGER,...,STRING
	xchg	ax,bx			;ax = parm's oNam/oVar
	cmp	[txtFindIndex],ASTYPE_opStDeclare
	je	CiDeclare		;brif we're looking at DECLARE parm
					; list - no oVars, just oNams
	push	ax			;pass parm1 = oNam/oVar
	call	ONamOVarRudeOrParse	;ax = variable's oNam
CiDeclare:
	sub	ax,[oNamAs]		;see if it is id of interest
	jne	CiParmLoop		;brif not
	pop	si			;restore ptr to opStDeclare/Sub/Func
	jmp	SHORT CiDone		;return 0 - terminates ForEach...

CiParmDone:
	pop	si			;restore ptr to opStDeclare/Sub/Func
	jmp	SHORT CiLoop

CiNotDeclare:
	call	ONamOfAs		;ax = oNam of id
	jc	CiLoop			;brif AS clause was within TYPE/END TYPE
	sub	ax,[oNamAs]		;see if it is id of interest
	jne	CiLoop			;brif not
					;return 0 - terminates ForEach...
CiDone:
	pop	si			;restore caller's si
	ret
ChkAsInTbl ENDP

;**************************************************************
; ChkLastAs
; Purpose:
;	Called when opAsType op[A]Idxxx(oNam) pcode sequence is deleted.
;	If there are no other refs to oNam AS in pcode, oNam's NM_fAs
;	name table bit is reset.
;	This causes lexer to know all future references to oNam.xxx are not
;	user-type record element references.
; Entry:
;	ax = oNam
; Exit:
;	carry set if no more  <oNam> AS  constructs exist in pcode
;
;**************************************************************
PUBLIC	ChkLastAs
ChkLastAs PROC NEAR
	mov	[oRsAs],UNDEFINED
ChkLastAs ENDP
ChkLastAs1 PROC NEAR
	mov	[oNamAs],ax		;pass oNam to ChkAsInTbl
	;scan all text tables in module to see if any more AS x
	mov	bx,CPOFFSET ChkAsInTbl
	call	ForEachTxtTblInMrs
	or	ax,ax			;test return value
	je	NotLastAs		;brif found an AS x
					; exit with carry clear
	mov	bx,[oNamAs]		;pass oNam in bx
	mov	al,NM_fAS		;pass mask for bit to be reset
	call	ResetONamMask
	stc				;set return code
NotLastAs:
	ret
ChkLastAs1 ENDP

;**************************************************************
; ChkLastAsText
; Purpose:
;	Same as ChkLastAs except for input parm.
;	Pcode is assumed to be in SS_RUDE state.
; Entry:
;	ax = text offset to opAsType opcode being deleted from
;	     current text table
;	bx = text offset to 1st byte being deleted
;	cx = text offset beyond last byte being deleted
;
; Pcode is:
;  For id AS type: opAsType(oNamType) opVtRf(oNamId)
;  For id(10,20) AS type: 10,20,opAsType(oNamType) opAVtRf(2,oNamId)
;  For typeElem AS type: opElemRef(oNamElem) opAsType(oNamType)
; si is pointing to opAsType in all cases
;
;**************************************************************
cProc	ChkLastAsText,<PUBLIC,NEAR>
cBegin
	;if PreScanAsChg is active, 'AS <userType>' is not really
	;being deleted, just re-parsed, so don't reset name table bit.
	
	cmp	[fPreScanAsChg],0
	jne	ClatExit

	;save ptr to opAsType being deleted, so ChkAsInTbl doesn't
	;count one being deleted when looking for other occurances
	;of  x AS <usertype>
	
	mov	[otxAsDelStart],bx
	mov	[otxAsDelEnd],cx
	mov	dx,[grs.GRS_oRsCur]
	mov	[oRsAs],dx
	call	ONamOfAs		;ax = oNam of x for  x as <type>
	jc	ClatExit		;brif not  x as <type> pcode
	call	ChkLastAs1
	jnc	ClatExit		;brif not last  x as <type>  in pcode
	or	[mrsCur.MRS_flags],FM_asChg
					;remember to call PreScanAsChg
					; before trying to scan/run program
ClatExit:
cEnd

;**************************************************************
; PreScanAsChg
; Purpose:
;	Called just before we scan a text table in preparation
;	for execution.  Only called when text table's FM_asChg
;	bit is set, so we know that either:
;	   an 'x AS y' clause has been inserted in this table, or
;	   an 'x AS y' clause has been deleted from this table and
;	      the module contained no more 'x AS <user type>' clauses
;	It walks through every pcode in current text table.
;	For every record element x.a, if x's NM_fAs bit is not set,
;	   the line is re-parsed.
;	If the line contains an 'opNoTyp' opcode, meaning the line
;	   contains an identifier other than a record element with
;	   a period in it's name, the line is re-parsed.
;
;**************************************************************
cProc	PreScanAsChg,<PUBLIC,NEAR>,<si,di>
cBegin
	mov	[fPreScanAsChg],1
	SetStartOtx si			;si = offset to start of text table
	mov	di,si			
PsLoop:
	push	si
	PUSHI	ax,<CODEOFFSET tOpAs>
	call	TxtFindNextOp		;ax = offset to next opcode of interest
					;dl = [txtFindIndex]
	xchg	si,ax			;si = offset to opcode
	cmp	dl,AS_opNoType
	ja	PsDone			;brif got opEot
.errnz	AS_opEot - AS_opNoType - 1
	je	PsReParse		;brif opcode is opNoType
	;else opcode must be opOff...
	xchg	ax,di			;ax = ptr beyond last opOffxxx opcode
	mov	di,si			;di = ptr to current opOffxxx opcode
	add	di,4			;di = ptr beyond current opOffxxx opcode
	DbAssertRel ax,be,si,CP,<PreScanAsChg: err2>
	cmp	si,ax
	je	PsLoop			;this is just an offset modifier, like
					; c in a.b.c
	GETSEG	es,[txdCur.TXD_bdlText_seg] 
	push	es:[si-2]		;push oNam/oVar from op[A]Idxxx opcode
	call	ONamOVarRudeOrParse	;ax = variable's oNam
	push	ax			;pass oNam from op[A]Idxxx opcode
	call	FlagOfONam		;al = oNam's flags
	test	al,NM_fAS
	jne	PsLoop			;brif valid record element
	;Else, what used to look like a record element should now be a simple id
PsReParse:
	push	si			;pass opcode offset to LnOfOtx
	call	LnOfOtx			;ax = current line #
	inc	ax			;ax = line after current line
	push	ax			;pass to OtxOfLn below
	mov	ax,si			;ax = offset to opcode of interest
	call	TxtReEnter		;re list & parse line @ ax
	call	OtxOfLn			;ax = offset to next opBol/opEot
					;     (Must be done after TxtReEnter)
	xchg	si,ax			;si = offset to next opBol/opEot
	jmp	SHORT PsLoop

PsDone:
	mov	[fPreScanAsChg],0
cEnd




sEnd	CP

;**************************************************************
;      Support for GetSegAddr MACRO
;
;**************************************************************

;seg_cp = segment address for the CP segment
;It can be referenced from any module as follows:
	;	EXTRN	Seg_CP:abs
	;	mov	ax,SEG Seg_CP
	; These statements are generated by the macro call:
	;       GetSegAddr CP

	Seg_CP	=	SEG ModuleRudeEdit
	PUBLIC	Seg_CP



assumes DS,DATA 			
sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtmove.asm ===
TITLE	txtmove.asm - Contains text manager's text movement functions

;======================================================================
; Module: txtmove.asm - Contains text manager's text movement functions
;
;	--------- --- ---- -- ---------- ----
;	COPYRIGHT (C) 1985 BY MICROSOFT, INC.
;	--------- --- ---- -- ---------- ----
;     
;
;=======================================================================*/

	.xlist
	include version.inc
	TXTMOVE_ASM = ON	;don't include EXTRNs defined in this file
	includeOnce architec
	includeOnce heap
	includeOnce conint			
	includeOnce context
	includeOnce opcontrl
	includeOnce opmin
	includeOnce optables
	includeOnce parser
	includeOnce pcode
	includeOnce rtps
	includeOnce scanner
	includeOnce txtint
	includeOnce txtmgr
	includeOnce util
	.list

assumes	ds,DATA
assumes	ss,DATA

sBegin	DATA

	externB b$errinfo		;defined by runtime - extended Out of
					; memory error code.

sEnd	DATA

sBegin	CP
assumes	cs,CP


;*************************************************************************
; TxtCurInit()
;
; Purpose:
;	Sets the txdCur.xxx fields to reflect a newly initialized text table.
;	It is called by the context manager functions MrsMake, PrsMake.
;	An empty text table is allocated for the text descriptor.
;	If we're creating a PRS and not loading, the text table contains:
;	   opBol opStSub/opStFunc(cntEos,oPrs,oTyp,0)
;	   opBol opStEndProc
;	   opEndProg
;	   opEot
;	else the text table contains
;	   opEndProg
;	   opEot
;
; Entry:
;	Assumes no txdCur is active
;
; Exit:
;	All fields of the global structure 'txdCur' are filled in.
;	If no error occurred, returns Non-Zero else FALSE
;	NOTE: If an error occurs, this function guarentees caller need not
;	deallocate txdCur.bdlText.
;	Condition codes set based on value in ax
;	
;*************************************************************************
cProc	TxtCurInit,<PUBLIC,NODATA,NEAR>,<di>
	localW	tempBuf
cBegin
	and	[grs.GRS_flags],NOT FG_allSsExecute
	call	TxtFlushCache		;can't depend on cached text offsets
	PUSHI	ax,<dataOffset txdCur>
	PUSHI	ax,<SIZE TXD/2>		;bx = #words in txtCur
	call	FillUndef		;fill whole struct with UNDEFINED
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	PUSHI	ax,CB_EMPTY_TEXT	;ask for minimal req'd size initially.
					;  Important that we ask for no more,
					;  so that when we discard an existing
					;  mrs, we can always find enough room
					;  to create an empty unnamed mrs again.
	PUSHBDL_TYPE  pgtypEBPcode,ax	; pass sb type for EB version
	call	BdlAlloc
	or	ax,ax
	jne	GotMem
	jmp	short TxtCurExit	;return FALSE if out-of-memory
GotMem:
	mov	[txdCur.TXD_scanState],SS_PARSE
	sub	ax,ax
	mov	[txdCur.TXD_cLines],ax
	mov	[txdCur.TXD_cLinesIncl],ax
	mov	[txdCur.TXD_flags],al
	mov	ax,[grs.GRS_oPrsCur]
	inc	ax			;test for UNDEFINED
	jne	TxtCurPrs		;brif we're creating a prs text table
	or	[txdCur.TXD_flags],FTX_mrs
					;remember that this is a module txt tbl
	test	[mrsCur.MRS_flags2],FM2_NoPcode OR FM2_Include
	je	TxtCurExitGood		;brif not an $INCLUDE or Document mrs
	inc	[txdCur.TXD_scanState]	;convert SS_PARSE to SS_RUDE
	.errnz SS_RUDE - SS_PARSE - 1
	jmp	SHORT TxtCurExitGood

TxtCurPrs:
	;If module is in SS_RUDE state, and we're creating a procedure,
	;put that procedure in SS_RUDE state as well.
	
	mov	al,[mrsCur.MRS_txd.TXD_scanState]
	cmp	al,SS_RUDE
	jb	TxtCurExitGood		; brif module's not in SS_RUDE state
	mov	[txdCur.TXD_scanState],al
TxtCurExitGood:
	call	TxtInitTxtTbl		;set up initial txt table.
DbAssertRel ax,ne,0,CP,<TxtCurInit:Unexpected OM error>
; ax should be non-zero after call to TxtInitTxtTbl
TxtCurExit:
	or	ax,ax			;set condition codes for caller
cEnd

;*************************************************************************
; TxtInitTxtTbl()
;
; Purpose:
;	Added with revision [26].
;	Inits a minium txt table.  Inserts opEndProg and opEot.
; Entry:
;	txdCur defines current text table.
; Exit:
;	AX = 0 if OM. Condition codes set via or ax,ax
;
;*************************************************************************
cProc	TxtInitTxtTbl,<NEAR>,<DI>
cBegin
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
					;pass adr of bdl for text table
	PUSHI	ax,CB_EMPTY_TEXT	;make sure we have enough free
	call	BdlCheckFree		;ax = result
	or	ax,ax
	je	TITT_Exit		;brif out of memory

;We use GetSeg to get the seg addr of the text table here so that
;sbCur does not need to preserved to create a text table.
	GETSEG	es,[txdCur.TXD_bdlText_seg],,<SIZE,LOAD> ;es points to text tbl
	SetStartOtx di			;otxInsert = start of text
	mov	ax,opEndProg
	stosw
	mov	ax,opEot
	stosw
.erre CB_EMPTY_TEXT - 4 EQ StartOtx	;empty text table has 4 bytes of pcode
	mov	[txdCur.TXD_bdlText_cbLogical],CB_EMPTY_TEXT
.erre	opEot
TITT_Exit:
	or	ax,ax
cEnd

;*************************************************************************
; TxtDelAllFar()
;
; Purpose:
;	Added with revision [26].
;	Deletes all text in the module, leaving a minimal text table.
;	Called by the user interface to remove all text from a text table,
;	leaving opEndProg and opEot.
; Entry:
;	grs.oMrsCur indicates current module
;	grs.oMrsPrs indicates current procedure (UNDEFINED if none)
; Exit:
;	none.
;
;*************************************************************************
PUBLIC	TxtDelAll
TxtDelAll PROC FAR
	call	TxtDeleteAll		;delete all text in the text
					; table except endprog and eot
	call	ChkAllUndefPrsSaveRs	;discard any prs's with last
					;reference deleted by delete
	ret
TxtDelAll ENDP

;*************************************************************************
; TxtDeleteAll()
;
; Purpose:
;	Deletes all text in the module, leaving a minimal text table.
; Entry:
;	grs.oMrsCur indicates current module
;	grs.oMrsPrs indicates current procedure (UNDEFINED if none)
; Exit:
;	none.
;
;*************************************************************************
PUBLIC	TxtDeleteAll
TxtDeleteAll PROC NEAR
	cmp	[txdCur.TXD_bdlText_cbLogical],CB_EMPTY_TEXT
	jbe	EmptyText		;brif text table is empty (TxtLoad
					;    does this for temp text tables)
					;Don't need delete OpEndProg OpEot
	test	[grs.GRS_flagsDir],FDIR_new
	je	NotNewStmt		;brif NewStmt is not active (speed
					; optimization - NEW takes forever
					; if this is not done)
	mov	[prsCur.PRS_otxDef],UNDEFINED
					;if prs is active, this will cause
					;PrsDiscard to call PrsFree
					;if mrs is active, this has no effect
	jmp	SHORT EmptyText

NotNewStmt:
	call	TxtModified		;descan current text table to SS_PARSE
					;this may alter txdCur.bdlText.cbLogical
					;It also sets FM2_Modified
	PUSHI	ax,StartOtx		;delete from start of text table
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	dec	ax
	dec	ax
	push	ax			;entire text table is being discarded
	call	TxtDelete		;ax = return code
					;Note: TxtDelete may cause TxtActivate/
					; TxtDeactivate to be called via
					; ForEachPrsInMrs, but before it
					; returns, it restores whatever text
					; table was active when it was called.

	call	TxtInitTxtTbl		;set up default txt table
DbAssertRel ax,ne,0,CP,<TxtDeleteAll: unexpected OM error>
EmptyText:
	ret
TxtDeleteAll ENDP

;*************************************************************************
; TxtDiscard()
;
; Purpose:
;	Takes any text-mgr action needed before a text table is discarded
;	by the context manager.  This includes prompting the user with
;	"This action will prevent CONT" if appropriate.
;
; Sequence of events for NewStmt, as it affects text tables:
; NewStmt calls MrsDiscard for each mrs in system which has file associated
;    with it (i.e. doesn't call it for command window or scrap mrs's)
; MrsDiscard calls PrsDiscard for each prs which has a text table and
;    whose PRS_oMrs field = mrs.  It then calls TxtDiscard to discard
;    module's text table.
; PrsDiscard calls TxtDiscard to discard the procedure's text table.
;
; Entry:
;	grs.oMrsCur indicates current module
;	grs.oMrsPrs indicates current procedure (UNDEFINED if none)
; Exit:
;	if no error, returns 0
;
;*************************************************************************
PUBLIC	TxtDiscard
TxtDiscard PROC NEAR
	;NOTE - we can't call DbChk TxdCur here because txtload.c calls
	; it for a temporary buffer where it would fail.
	

	call	TxtDeleteAll		;delete all text in text table

; If we are discarding a prs, make sure that the defining ref deleted
; flag gets set.  TxtDelete won't do this if the there are no references
; to the prs, and the prs has a text table.  This could happen if the
; SUB or FUNCTION statment is a reparse, and no other reference exists.

	test	[txdCur.TXD_flags],FTX_Mrs  ; are we discarding an PRS
	jne	MrsTxtTbl		; text table?  brif so
	or	[flagsTM],FTM_PrsDefDeleted 
MrsTxtTbl:
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
					;pass ptr to bdl structure for txt tbl
	call	BdlFree			;release it (note that this sets
					; bdlText_status to NOT_OWNER in txdCur)
	inc	ax			;return 'no-error' (0) result
	ret
TxtDiscard ENDP

;*************************************************************************
; TxtActivate()
;
; Purpose:
;	Sets the txdCur.xxx fields to reflect the current text table.
;	This involves copying the txd struct from mrsCur or the global Rs table.
;	If grs.oPrsCur is UNDEFINED, or represents a procedure with
;	no text table (i.e. for a DECLARE or DEF FN prs), then the
;	copy is from the mrsCur.txd, else it is from the global Rs table.
;	It is called by the context manager functions MrsActivate & PrsActivate
;	NOTE: Callers can (and do) depend on this function causing
;	      NO heap movement.
;
; Entry:
;	grs.oMrsCur indicates current module
;	grs.oMrsPrs indicates current procedure (UNDEFINED if none)
;
; Exit:
;	All fields of the global structure 'txdCur' are copied from
;	mrsCur or the global Rs table.
;	
;*************************************************************************
PUBLIC	TxtActivate
TxtActivate PROC NEAR
	call	TxtFlushCache		;can't depend on cached text offsets
	sub	al,al			;copy mrs/prs -> txd
	sub	cx,cx			;assume we're activating module txt tbl
	mov	bx,[grs.GRS_oPrsCur]
	inc	bx
	.errnz	UNDEFINED - 0FFFFH
	jz	TxtAct1			;brif no prs is active

	dec	bx
	RS_BASE add,bx			; bx pointer to start of prs in table
	GETRS_SEG es,cx,<SIZE,LOAD>	;[3]
	mov	cx,PTRRS[bx.PRS_txd.TXD_bdlText_status] 
	sub	cx,NOT_OWNER		;cx = 0 if prs doesn't own a text table
	jmp	SHORT TxtAct1
TxtActivate ENDP

;*************************************************************************
; TxtDeactivate()
;
; Purpose:
;	Copies the txdCur.xxx fields to the txd struct in mrsCur or the
;	appropriate place in the global Rs table.
;	If grs.oPrsCur is UNDEFINED, or represents a procedure with
;	no text table (i.e. for a DECLARE or DEF FN prs), then the
;	copy is to the mrsCur.txd, else it is to the global Rs table.
;	It is called by the context manager functions MrsDeactivate &
;	PrsDeactivate.
;	NOTE: Callers can (and do) depend on this function causing
;	      NO heap movement.
;
; Entry:
;	grs.oMrsCur indicates current module
;	grs.oMrsPrs indicates current procedure (UNDEFINED if none)
;
; Exit:
;	All fields of the global structure 'txdCur' are copied to mrsCur
;	or the global Rs table.
;	
;*************************************************************************
PUBLIC	TxtDeactivate
TxtDeactivate PROC NEAR

	DbChk	TxdCur			;perform sanity check on txdCur

	;eliminate any free space at the end of current text table,
	;so if far heap mgr needs space, the only places it needs to
	;look are static structures txdCur and mrsCur.  This is smaller
	;code than having to walk the far heap.  If it becomes a performance
	;bottleneck, we'll have to delete this and walk the far heap.
	
	PUSHI	ax,<DATAOFFSET txdCur.TXD_bdlText>
	call	BdlTrim

	mov	al,1			;tell common code we're deactivating
	sub	cx,cx
	test	[txdCur.TXD_flags],FTX_mrs
	jne	TxtAct1			;brif deactivating module text table
	dec	cx			;we're deactivating prs text table

;This code is shared between TxtActivate and TxtDeactivate
; al = 0 for Activate, non-zero for Deactivate
; cx = 0 if activating/deactivating module text table
;    = non-zero for procedure text table
;
TxtAct1:
assumes ds,nothing			
     DbAssertRel grs.GRS_oMrsCur,ne,UNDEFINED,CP,<Txt[De]Activate mrs=UNDEFINED>
	push	si			;save caller's si/di
	push	di
	push	ss			
	pop	es			; assume DGROUP->DGROUP copy
	mov	di,dataOFFSET mrsCur.MRS_txd  ; di -> current mrs's txd struct
	jcxz	NoPrs			      ;brif text table not for prsCur
	GETRS_SEG es,di,<SPEED,LOAD>	;[3] assume we're deactivating
	mov	di,[grs.GRS_oPrsCur]	
	RS_BASE add,di			
	add	di,PRS_txd		; di -> current prs's txd struct
     DbAssertRel grs.GRS_oPrsCur,ne,UNDEFINED,CP,<Txt[De]Activate prs=UNDEFINED>
NoPrs:
	mov	si,dataOFFSET txdCur	; si -> cur text tbl descriptor
	or	al,al
	jnz	DoTheCopy		; brif we're deactivating
	xchg	si,di			; we're activating
DoTheCopy:
.errnz	(SIZE TXD) MOD 2		;block copy assumes even # of bytes
	mov	cx,(SIZE TXD) SHR 1	;cx = # words to copy

	push	si			;pass src BdlChgOwner
	push	di			;pass dst to BdlChgOwner
	rep movsw			; do the copy
	call	BdlChgOwner		
	pop	di			;restore caller's si/di
	pop	si
assumes ds,DATA 			
	ret
TxtDeactivate ENDP

;*************************************************************************
; TxtMoveUp(otxSrcLow, cbIns)
;
; Purpose:
;	Move a block of text from a low address to a higher address
;	within the current text table.  Typically used to make room
;	for text to be inserted.
;
; Entry:
;	parmW otxSrcLow: offset of source of lowest byte to be moved
;	parmW cbIns: number of bytes to make room for
;	if grs.fDirect is TRUE,
;	   grs.bdlDirect (the direct mode pcode buffer) is the buffer to
;	   be shifted, and grs.bdlDirect.cbLogical = current logical
;	   size of text table
;	else txdCur.bdlText is the buffer to be shifted and
;	   txdCur.bdlText.cbLogical = current logical size of text table
;
; Exit:
;	returns ax = zero if out-of-memory, else non-zero
;	condition codes set based on value in ax
;	if grs.fDirect is TRUE
;	   grs.bdlDirect.cbLogical is updated for the move
;	else
;	   txdCur.bdlText.cbLogical is updated for the move
;
; Example:
;   Before:
;	high memory 	
;	  txdCur.TXD_bdlText_cbLogical->+-----+
;					|  E  |
;	  otxSrcLow + cbIns------------>|  D  |
;					|  C  |
;	  otxSrcLow-------------------->|  B  |
;					|  A  |
;	low memory			+-----+
;
;   After:
;	high memory 	
;	  txdCur.TXD_bdlText_cbLogical->+-----+
;					|  E  |
;					|  D  |
;					|  C  |
;	  otxSrcLow + cbIns------------>|  B  |
;					|  -  |
;	  otxSrcLow-------------------->|  -  |
;					|  A  |
;	low memory			+-----+
;
;*************************************************************************
cProc	TxtMoveUp,<PUBLIC,NODATA,NEAR>,<si,di>
	parmW otxSrcLow
	parmW cbIns
cBegin	TxtMoveUp
	DbChk	Otx,otxSrcLow		;assert otxSrcLow is valid
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	si,[otxSrcLow]		;si = source offset
					; (is parm for TxtAdjust)
	call	TxtChkCache		;adjust/reset cached text offsets
					;reset History and Watch info too
	push	[cbIns]
	call	TxtFree			;make sure we have enough free space
	je	TxtMoveUpExit		;brif out-of-memory
	GetSegTxtCur			;es = seg adr of current txt tbl
					; (this may be direct mode buffer)
	mov	dx,[cbIns]		;dx = #bytes to insert
	mov	bx,dataOFFSET grs.GRS_bdlDirect_cbLogical
	cmp	[grs.GRS_fDirect],FALSE
	jne	Up_InDirMode		;branch if in direct mode
	mov	bx,dataOFFSET txdCur.TXD_bdlText_cbLogical
Up_InDirMode:
	mov	di,si			;di = source offset
	add	di,dx			;di = destination offset
	mov	cx,[bx]			;cx = current size of text table
	add	[bx],dx			;update cbLogical for move
	sub	cx,si			;cx = # bytes to copy
	add	di,cx			;start copying at top of block
	dec	di			; so we don't overwrite end of
	dec	di			; source before we've copied it
	add	si,cx
	dec	si
	dec	si
	shr	cx,1			;we will move words
DbAssertFlags	nc,CP,<TxtMoveUp: err1>
	push	ds			;save caller's ds
	push	es			;push seg adr of current txt tbl
	pop	ds			;set up source seg
	std				;copy moving down
	rep movsw
	cld				;always leave D flag clear by convention
	pop	ds			;restore caller's ds
	mov	ax,sp			;success result
TxtMoveUpExit:
	or	ax,ax			;set condition codes for caller
cEnd	TxtMoveUp

cProc	TxtMoveUpFar,<PUBLIC,NODATA,FAR> 
	parmW otxSrcLow 		
	parmW cbIns			
cBegin	TxtMoveUpFar			
	cCall	TxtMoveUp,<otxSrcLow, cbIns>  
cEnd	TxtMoveUpFar			

;*************************************************************************
; TxtMoveDown(otxSrcLow, otxDstLow)
;
; Purpose:
;	Move a block of text from a high address to a lower address
;	within the current text table.  Typically used to delete text.
;
; Entry:
;	parmW otxSrcLow: offset of source of lowest byte to be moved
;	parmW otxDstLow: offset of destination of lowest byte to be moved
;	if grs.fDirect is TRUE,
;	   grs.bdlDirect (the direct mode pcode buffer) is the buffer to
;	   be shifted, and grs.bdlDirect.cbLogical = current logical
;	   size of text table
;	else txdCur.bdlText is the buffer to be shifted and
;	   txdCur.bdlText.cbLogical = current logical size of text table
;
; Exit:
;	if grs.fDirect is TRUE
;	   grs.bdlDirect.cbLogical is updated for the move
;	else
;	   txdCur.bdlText.cbLogical is updated for the move
;
; Example:
;   Before:
;	high memory 	
;	  txdCur.TXD_bdlText_cbLogical->+-----+
;					|  F  |
;					|  E  |
;	  otxSrcLow-------------------->|  D  |
;					|  C  |
;	  otxDstLow-------------------->|  B  |
;					|  A  |
;	low memory			+-----+
;
;   After:
;	high memory 	
;	  txdCur.TXD_bdlText_cbLogical->+-----+
;	  otxSrcLow-------------------->|  F  |
;					|  E  |
;	  otxDstLow-------------------->|  D  |
;					|  A  |
;	low memory			+-----+
;
;*************************************************************************
cProc	TxtMoveDown,<PUBLIC,NODATA,NEAR>,<si,di>
	parmW otxSrcLow
	parmW otxDstLow
cBegin	TxtMoveDown
	DbChk	Otx,otxDstLow		
	DbChk	Otx,otxSrcLow		
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	si,[otxDstLow]		;si = destination offset
					; (is parm for TxtAdjust)
	call	TxtChkCache		;adjust/reset cached text offsets
					;reset History and Watch info too
	GetSegTxtCur			;es = seg adr of cur txt tbl
	mov	di,si			;di = destination offset
	mov	si,[otxSrcLow]		;si = source offset
	mov	dx,si			;dx = source offset
	sub	dx,di			;dx = number of bytes being deleted
	mov	bx,dataOFFSET grs.GRS_bdlDirect_cbLogical
	cmp	[grs.GRS_fDirect],FALSE
	jne	Dn_InDirMode		;branch if in direct mode
	mov	bx,dataOFFSET txdCur.TXD_bdlText_cbLogical
Dn_InDirMode:
	mov	cx,[bx]			;cx = current size of text table
	sub	[bx],dx			;update cbLogical for move
	sub	cx,si			;cx = # bytes to copy
	shr	cx,1			;move words instead of bytes
DbAssertFlags nc,CP,<TxtMoveDown: err1>
	push	ds			;save caller's ds
	push	es			;push seg adr of current text tbl
	pop	ds			;set up source seg
	rep movsw			;copy block
	pop	ds			;restore caller's ds
cEnd	TxtMoveDown

;*************************************************************************
; TxtFree
;
; Purpose:
;	Ensure that the current text table's cbPhysical exceeds its cbLogical
;	by a given value, i.e. guarentee a given amount of free space.
; Entry:
;	parm1: ushort cbFree
;	if grs.fDirect is TRUE,
;	   table grs.bdlDirect is checked
;	else
;	   table txdCur.bdlText is checked
; Exit:
;	returns ax = zero if out-of-memory, else non-zero
;	condition codes set based on value in ax
;
;*************************************************************************
cProc	TxtFree,<PUBLIC,NODATA,NEAR>
	parmW	cbFree
	localW	fDirectMode
cBegin	TxtFree
	DbChk	TxdCur			;perform sanity check on txdCur
	mov	[fDirectMode],0 	;default not directmode buffer
	mov	ax,dataOFFSET txdCur.TXD_bdlText
	cmp	[grs.GRS_fDirect],FALSE
	je	NotDirMode		;branch if not in direct mode
	mov	ax,dataOFFSET grs.GRS_bdlDirect
	mov	[fDirectMode],sp
NotDirMode:
	push	ax			;pass adr of bdl for text table
	push	cbFree
	call	BdlCheckFree		;ax = result
	or	ax,ax			;set condition codes for caller
	jne	TxtFreeExit		;brif not out of memory

; We have an out of memory error.  Determine what caused the error so
; we can give the user a better idea of how to resolve the problem.
; If the we attempted to grow the text table beyond 64k then we will
; set the variable b$errinfo to one of the following values:
;	Not changed - Was direct mode buffer, or legit out of memory.
;	OMErr_Mod   - Module level code blew past 64k.
;	OMErr_Proc  - Procedure level code blew past 64k.
;	OMErr_Inc   - Include file blew past 64k.
;	OMErr_Doc   - Document blew past 64k.

	cmp	[fDirectMode],0 	;was it the direct mode buffer?
	jne	TxtFreeOmExit		;brif so, standard OM error
	mov	ax,[txdCur.TXD_bdlText_cbLogical] ;get current size of text table
	add	ax,[cbFree]		;add requested increment
	jnc	TxtFreeOMExit		;brif request wasn't > 64K

.errnz	OMErr_Mod-OMErr_Proc-1
.errnz	OMErr_Inc-OMErr_Mod-1
.errnz	OMErr_Doc-OMErr_Inc-1
	mov	cx,OMErr_Proc		;assume we are in a SUB/FUNC
	test	[txdCur.TXD_flags],FTX_mrs ;is this a SUB/FUNC?
	je	TxtFreeOMSet		;brif so, set b$errinfo
	mov	al,[mrsCur.MRS_flags2]
	inc	cx			;assume in a MODULE
	test	al,FM2_NoPcode OR FM2_Include ;is this an Include/Document?
	je	TxtFreeOMSet		;brif not, module text table
	inc	cx			;assume an INCLUDE file
	test	al,FM2_Include		;is this an include?
	jne	TxtFreeOMSet		;brif so
	inc	cx			;must be a document
DbAssertTst al,ne,FM2_NoPcode,CP,<TxtFree: Expected a Document txt table>

TxtFreeOMSet:
	mov	[b$errinfo],cl 	;set extended OM error code

TxtFreeOMExit:
	sub	ax,ax			;set ax and condition codes for caller
TxtFreeExit:
cEnd	TxtFree

cProc	TxtFreeFar,<PUBLIC,NODATA,FAR>	
	parmW	cbFree			
cBegin	TxtFreeFar			
	cCall	TxtFree,<cbFree>	
cEnd	TxtFreeFar			

;*************************************************************************
; TxtPrsInit
; Purpose:
;	This is called by User Interface code after File/New/Sub
;	to put the following pcode into the newly created text table:
;	   DEFxxx state from the end of the module so user who has
;	   DEFINT A-Z in module will get it in SUB as well.
;	   SUB/FUNCTION name
;	   END SUB/FUNCTION
; Entry:
;	prs in question is active
;	otype - If proc is a FUNCTION then otype is its return type
; Exit:
;	No error return.  If out of memory, the user just gets an
;	empty text table.
;
;*************************************************************************
cProc	TxtPrsInit,<PUBLIC,FAR>,<si,di>
	parmB	oType				
cBegin
	;Following is guarenteed by by PrsMake()
	DbAssertRel [grs.GRS_oMrsCur],e,[prsCur.PRS_oMrs],CP,<TxtPrsInit: err2>
	DbAssertTst [txdCur.TXD_flags],Z,FTX_mrs,CP,<TxtPrsInit: got an mrs>

	and	[prsCur.PRS_flags],NOT FP_STATIC
					;in case this prs used to have a
					; txt tbl, with FP_STATIC bit set,
					; and then prs was discarded.  FP_STATIC
					; would still be set.
	SetStartOtx di			;otxInsert = 0
	push	di			;pass otxInsert
	PUSHI	ax,16d			;we're about to insert 16 bytes
	call	TxtMoveUp		;make room for pcode to be inserted
	je	TxtPExit		;brif out-of-memory

	GetSegTxtTblCur	es		;es = seg adr of txt tbl
	sub	ax,ax			;ax = opBol
	.errnz	opBol
	stosw				;emit opBol
	mov	ax,opStSub
	cmp	[prsCur.PRS_procType],PT_SUB
	je	TxtSub
	mov	ax,opStFunction
TxtSub:
	stosw				;emit opStSub/opStFunction
	mov	ax,6
	stosw				;emit cntEos operand
	mov	ax,[grs.GRS_oPrsCur]
	stosw				;emit oPrs operand
.errnz	ET_IMP
	sub	ax,ax			;al = ET_IMP
	mov	ah,[prsCur.PRS_procType];ah = PT_SUB or PT_FUNCTION
	cmp	ah, PT_FUNCTION 	
	jne	@F			
	mov	al, [otype]		
	.errnz	ET_IMP			
	or	al,al			;ET_IMP?
	jz	@F			;brif yes.
	or	ax, DCLA_Explicit	
@@:					
	stosw				;emit oTypFn operand
	sub	ax,ax
	stosw				;emit parm count operand (0)
.errnz	opBol				;ax = 0 = opBol
	stosw				;emit opBol
	mov	ax,opStEndProc
	stosw
	or	[mrsCur.MRS_flags2],FM2_Modified
	push	[grs.GRS_oPrsCur]	;save caller's oPrs
	call	PrsDeactivate
	call	OtxDefTypeEot		;fill ps.tEtCur with module's def state
	call	PrsActivateCP		;reactivate caller's prs

	;init default ps.tEtCur[] (default type array)
	SetStartOtx ax			;ax = start of text
	mov	bx,dataOFFSET tEtTemp
	call	OtxDefType		;fill tEtTemp with default types
					; i.e. ET_R4 for all letters

	PUSHI	ax,<DATAOFFSET tEtTemp>
	PUSHI	ax,<DATAOFFSET ps.PS_tEtCur>
	SetStartOtx ax			;ax = otxInsert = start of text
	call	InsertEtDiff
	SetStartOtx si			;otx for inserted pcode
	mov	bx,[txdCur.TXD_bdlText_cbLogical]
	sub	bx,CB_EMPTY_TEXT-StartOtx ;otx beyond end of inserted pcode
	call	TxtInsUpdate		;update any static structures
					; as a result of inserting this pcode.
TxtPExit:
cEnd

;*************************************************************************
; GetWOtx
;
; Purpose:
;	Given an  offset within the current text table, return
;	the 16 bit value stored at that offset.
; Entry:
;	ax = otx
; Exit:
;	ax = 16 bit value from text table
;
;*************************************************************************
PUBLIC	GetWOtx
GetWOtx	PROC NEAR
	DbChk	Otx,ax			;check for invalid text offset
	;NOTE - we can't call DbChkTxdCur here because DebChkTxdCur
	; calls GetWOtx, which causes infinite recursion.
	

DbAssertTst [conFlags],nz,F_CON_StaticStructs,CP,<GetWOtx: static structs not enabled>

	GetSegTxtTblCur			;es = seg addr of current text table
	xchg	bx,ax			;bx = offset into text table
	mov	ax,es:[bx]		;ax = value at that offset
	ret
GetWOtx	ENDP

;*************************************************************************
; PutWOtx
;
; Purpose:
;	Store a 16 bit value at a given offset within the current text table
; Entry:
;	parm1: ushort otx
;	parm2: ushort value
;
;*************************************************************************
cProc	PutWOtx,<PUBLIC,NODATA,NEAR>
	parmW	otx
	parmW	value
cBegin	PutWOtx
	DbChk	Otx,otx			;check for invalid text offset
	DbChk	TxdCur			;perform sanity check on txdCur
	GetSegTxtTblCur es		;es = seg adr of txt tbl
	mov	bx,[otx]		;bx = offset into text table
	mov	ax,[value]		;ax = value to store at that offset
	mov	es:[bx],ax		;store it
cEnd	PutWOtx


;-----------------------------------------
;	Non-RELEASE CP segment Functions
;-----------------------------------------
sEnd	CP



end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\txtsave.asm ===
TITLE	txtsave.asm - ASCII Save Functions

;==========================================================================
;
;Module:  txtsave.asm - ASCII Save Functions
;System:  Quick BASIC Interpreter
;
;=========================================================================*/

	include		version.inc
	TXTSAVE_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	lister
	includeOnce	names
	includeOnce	opcontrl
	includeOnce	opid
	includeOnce	opmin
	includeOnce	opstmt
	includeOnce	parser
	includeOnce	pcode
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	rttemp
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	txtint
	includeOnce	util
	includeOnce	ui
	includeOnce	variable
	includeOnce	edit		

	assumes	DS,DATA
	assumes	SS,DATA
	assumes	ES,NOTHING

	ASC_CRLF	EQU 0A0Dh	;ASCII Carriage return/Line Feed
	ASC_TAB 	EQU 9		;ASCII Tab

sBegin	DATA

	EXTRN	tabStops:WORD	;defined in edit manager
	EXTRN	b$PTRFIL:WORD	;defined by runtime - current channel ptr

CrLf		DW	ASC_CRLF	;for file line termination
oMrsSaveDecl	DW	0		;used by SaveDeclares
sEnd	DATA

sBegin	CODE

;Table of opcodes used to search for DECLARE or CALL statements
;
tOpDecl LABEL WORD
	opTabStart	DECL
	opTabEntry	DECL,opStDeclare
	opTabEntry	DECL,opStCall
	opTabEntry	DECL,opStCalls
	opTabEntry	DECL,opStCallLess
	opTabEntry	DECL,opEot

sEnd	CODE

	EXTRN	B$BUFO:FAR
	EXTRN	B$KILL:FAR

sBegin	CP
assumes	cs,CP

;*************************************************************
; ushort SaveTxdCur(ax:otxStart)
; Purpose:
;	ASCII save the contents of the current text table
; Entry:
;	ax = text offset to start saving text
; Exit:
;	ax = size of last line output (=2 if trailing blank line)
;	ps.bdpSrc is used
; Exceptions:
;	Can cause runtime error (Out of memory, I/O errors)
;
;*************************************************************
SaveTxdCur PROC NEAR
	DbChk	Otx,ax			
	push	si
	push	di
	sub	di,di			;Init cbLastLine = 0
	mov	[otxListNext],ax	;ListLine() updates [otxListNext]
	test	[mrsCur.MRS_flags2],FM2_NoPcode ; document file?
	je	GetOtxEndProg		; file is measured in Otxs, not lines

	DbAssertRel [otxListNext],e,0,CP,<SaveTxdCur:Not starting at the begining of file>
	push	[mrsCur.MRS_pDocumentBuf] 
	call	S_LinesInBuf		; get # lines in document buffer
	jmp	short SetMaximumSave	

GetOtxEndProg:
	call	OtxEndProg		;ax = otx to Watch pcode
SetMaximumSave:
	xchg	si,ax			;si = otx to Watch pcode
StLoop:
	mov	ax,[otxListNext]	;ax=offset for next line to list
	cmp	ax,si
DJMP	jae	SlDone			;brif done with this text table

	test	[mrsCur.MRS_flags2],FM2_NoPcode ; document file?
	je	ListPcodeLine		; brif not, let lister get line

	push	[mrsCur.MRS_pDocumentBuf] ; document table to list from
	push	ax			; line to list
	push	ps.PS_bdpSrc.BDP_cbLogical ; length of buffer
	push	ps.PS_bdpSrc.BDP_pb	;pass ptr to dest buf
	call	S_cbGetLineBuf		; AX = cBytes in line
	inc	[otxListNext]		; bump pointer to next line
	mov	[cLeadingSpaces],0	; start with no leading spaces
	mov	bx,[ps.PS_bdpSrc.BDP_pb]; BX = ptr to 0 terminated string

CheckNextChar:				
	cmp	byte ptr [bx],' '	; Is it a space
	jne	GotLine 		; brif not, say that we got line

	inc	[cLeadingSpaces]	; indicate another space
	inc	bx			; point to next character
	jmp	CheckNextChar		; check it for a space

ListPCodeLine:				

	push	ax			;pass offset to ListLine
	PUSHI	ax,<DATAOFFSET ps.PS_bdpSrc>	;pass dst buf ptr to listline
	call	ListLine		;ax=char count
	inc	ax			;test for UNDEFINED
	jne	NotOmErr		;brif out-of-memory
	jmp	OmErrCP
NotOmErr:
	dec	ax			;restore ax = byte count
GotLine:
	cmp	[fLsIncluded],0
	jne	StLoop			;brif line was part of $INCLUDE file

	test	mrsCur.MRS_flags2,FM2_EntabSource ;do we need to entab leading
					;blanks?
	jz	NoEntab 		;brif not
	mov	cl,[cLeadingSpaces]	;cl = count of leading spaces
	or	cl,cl			;any leading spaces?
	jnz	EntabLeadingSpaces	;brif so, replace with tabs
NoEntab:
	mov	bx,[ps.PS_bdpSrc.BDP_pb]
EntabCont:
	; There is currently no need to call UpdChanCur here, because
	; there is no chance of having nested open files during ascii save.
DbAssertRel b$PTRFIL,ne,0,CP,<SaveTxdCur:Invalid channel>

	; Call OutLine as we can not guarentee that the buffer
	; pointed to by BX contains at least two more bytes.
	; This is slower, but will not trash the heaps.
	mov	di,ax			; DI = new "cbLastLine"
	inc	di			; account for CRLF
	inc	di			
	call	OutLine 		; Print line and CRLF
DJMP	jmp	SHORT StLoop

SlDone:
	xchg	ax,di			;ax = cb last line emitted
	pop	di
	pop	si
	ret
SaveTxdCur ENDP

; We have a line with leading spaces which needs to be entabbed.
; We will convert spaces to tabs in the buffer, and return the
; new buffer char count, and a ptr to the start of the buffer.
;
; Entry:
;	ax = count of chars in line buffer
;	cl = count of leading spaces
; Exit:
;	ax = adjusted count of chars in line buffer
;	bx = ptr to first char in buffer
; Uses:
;	bx,cx,dx

EntabLeadingSpaces:
	push	ax			;preserve buffer char count
	xchg	ax,cx
	sub	ah,ah			;ax = cLeadingSpaces
	mov	dx,ax			;remember cLeadingSpaces
	mov	cx,[tabStops]		;get user defined tabstop settings

; User interface guarantees tabStops will not be set to 0
DbAssertRel cx,nz,0,CP,<tabStops=0 detected in Ascii save>

	div	cl			;al=tab count, ah=space count
	mov	bx,[ps.PS_bdpSrc.BDP_pb] ;bx=ptr to line buffer

	add	bx,dx			;bx=ptr to first non-leading space
	sub	dl,al
	sub	dl,ah			;dx=excess space in buffer
	sub	bl,ah			;backup over remaining spaces
	sbb	bh,0
	xchg	ax,cx
	sub	ch,ch			;cx=tab count
	jcxz	NoTabs			;brif none to replace
	mov	al,ASC_TAB
TabLoop:
	dec	bx			;back up a char
	mov	[bx],al 		;replace space with tab
	loop	TabLoop
NoTabs:
	pop	ax			;recover buffer char count
	sub	ax,dx			;adust for removed spaces
	jmp	EntabCont

;*************************************************************
; OutLine, OutCrLf
; Purpose:
;	OutLine - Output line and CR-LF to current file
;	OutCrLf - Output CR-LF to current file
; Entry:
;	bx points to 1st byte to output
;	ax = byte count
;
;*************************************************************
OutLine PROC NEAR
	; There is currently no need to call UpdChanCur here, because
	; there is no chance of having nested open files during ascii save.
DbAssertRel b$PTRFIL,ne,0,CP,<OutLine:Invalid channel>

	push	ds			;pass segment of buffer
	push	bx			;pass offset of buffer
	push	ax			;pass length of buffer
	call	B$BUFO			;output line via runtime
	;fall into OutCrLf
OutLine ENDP

OutCrLf PROC
	; There is currently no need to call UpdChanCur here, because
	; there is no chance of having nested open files during ascii save.
DbAssertRel b$PTRFIL,ne,0,CP,<OutCrLf:Invalid channel>

	push	ds
	PUSHI	ax,<dataOFFSET CrLf>
	PUSHI	ax,2
	call	B$BUFO			;output CR/LF via runtime
	ret
OutCrLf ENDP

;*************************************************************
; RelShBuf
; Purpose:
;	Release temporary text table used by SaveProcHdr.
;	Called when we're done saving, or when an error occurs.
;
;*************************************************************
RelShBuf PROC NEAR
	mov	[txdCur.TXD_bdlText_cbLogical],0
					;so TxtDiscard won't examine deleted txt
	call	TxtDiscard		;discard temporary text table
	call	TxtActivate		;make module's text table cur again
	mov	[ps.PS_bdpDst.BDP_cbLogical],0 ;release space held by temp bd
	ret
RelShBuf ENDP

;*************************************************************
; ushort SaveProcHdr(ax:otxProcDef)
; Purpose:
;	ASCII save the current procedure's header.
;
; Entry:
;	ax = otxProcDef = offset into procedure's text table to opBol for line
;	   containing SUB/FUNCTION statement.  0 if this table has no
;	   SUB/FUNCTION statement yet.
;
; Exit:
;	ps.bdpSrc is used
;	grs.fDirect = FALSE
;	ax = 0 if no error, else Standard BASIC error code (i.e. ER_xxx)
;
; Exceptions:
;	Can cause runtime error (Out of memory, I/O errors)
;
;*************************************************************
SaveProcHdr PROC NEAR
	push	si			;save caller's si,di
	push	di

	mov	di,ax			;di = otxProcDef
	push	[grs.GRS_oPrsCur]	;pass current oPrs to PrsActivate below

	;fill tEtTemp[] with DEFTYP's from start of proc table to SUB line
	mov	ax,di			;ax = otxProcDef
	mov	bx,dataOFFSET tEtTemp	;bx -> type table
	call	OtxDefType

	;move everything up to proc def from procedure's to temp text table
	PUSHI	ax,<dataOFFSET ps.PS_bdpDst>
	push	di			;pass otxProcDef
	call	BdRealloc
	or	ax,ax
	je	JE1_ShOmErr		;brif out-of-memory error

	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	SetStartOtx ax			
	push	ax
	push	[ps.PS_bdpDst.BDP_pb]
	push	di			;pass otxProcDef
	call	BdlCopyFrom

	;Now we create a temporary text table for saving the synthetically
	;generated procedure header.  We must go through the following steps
	; to do this:
	;  PrsDeactivate()  ---  causes module's text table to be made active
	;  TxtDeactivate()  ---  causes no text table to be made active
	;  TxtCurInit()     ---  make temp text table active
	;  put synthetically generated pcode into txdCur
	;  ASCII save this pcode buffer to the file
	;  TxtDiscard()     ---  discard temporary text table
	;  TxtActivate()    ---  make module's text table current again
	;  PrsActivate(oPrsSave)
	

	;[flagsTM.FTM_SaveProcHdr] is non-zero while in critical state
	; within function SaveProcHdr. Tells SaveFile's error cleanup
	; to take special action.
	
	or	[flagsTM],FTM_SaveProcHdr ;if err, remember to clean up
	call	PrsDeactivate		;make module's text table active
	call	TxtDeactivate		;causes no text table to be made active
	call	TxtCurInit		;make temp text table active
	je	ShOmErr			;brif out-of-memory error

	;emit synthetic DEFxxx statements as transition from end of last
	;text table to procedure definition line
	PUSHI	ax,<dataOFFSET ps.PS_tEtCur>
	PUSHI	ax,<dataOFFSET tEtTemp>
	SetStartOtx ax			;insert at start of text
	call	InsertEtDiff
JE1_ShOmErr:
	je	ShOmErr			;brif out-of-memory error
	call	OtxEndProg		;ax = otx to Watch pcode
	xchg	si,ax			; = offset beyond synthetic DEFxxx stmts

	;Append everything up to SUB line to temp table
	push	si			;pass otx to Watch pcode
	push	di			;pass otxProcDef
	call	TxtMoveUp
	je	ShOmErr			;brif out-of-memory error
	PUSHI	ax,<dataOFFSET txdCur.TXD_bdlText>
	push	si			;pass otx to Watch pcode
	push	[ps.PS_bdpDst.BDP_pb]
	push	di			;pass otxProcDef
	call	BdlCopyTo
	call	SqueezeDefs		;takes parm in si

	;if setting of $STATIC/$DYNAMIC differs between procedure's header
	;and where procedure will be listed in source file,
	;insert pcode to change the state for the procedure,
	;Note: fLsDynArrays's value will be changed by ListLine() when it
	;      lists the line emitted by InsertDynDiff (if any)
	
	SetStartOtx ax			;insert at start of text
	mov	dh,[fLsDynArrays]	;dh = old $STATIC/$DYNAMIC state
	mov	dl,[fProcDyn]		;dl = new $STATIC/$DYNAMIC state
	call	InsertDynDiff
	je	ShOmErr			;brif out of memory error
	SetStartOtx ax			;start saving at start of text
	call	SaveTxdCur		;save procedure's header to file
	call	RelShBuf		;release temp text tbl
	and	[flagsTM],NOT FTM_SaveProcHdr ;reset critical section flag

	;oPrs parm was pushed on entry to this function
	call	PrsActivateCP
	sub	ax,ax			;return no-error result
;al = error code
ShExit:
	mov	[ps.PS_bdpDst.BDP_cbLogical],0 ;release space held by temp bd
	or	al,al			;set condition codes for caller
	pop	di			;restore caller's si,di
	pop	si
	ret

ShOmErr:
	pop	ax			;discard oPrs
	mov	al,ER_OM		;return al = out-of-memory error
	jmp	SHORT ShExit
SaveProcHdr ENDP

;Cause runtime error "Out of memory"
OmErrCP:
	mov	al,ER_OM
	call	RtError

;*************************************************************
; ONamOtherOMrs
; Purpose:
;	Given an oNam in current mrs, convert it to an oNam
;	in another mrs (which has a different name table).
; Entry:
;	grs.oMrsCur = source oMrs
;	ax = source oNam
;	dx = target oMrs
; Exit:
;	ax = target oNam (0 if out of memory error)
;	flags set based upon return value.
;
;*************************************************************
cProc	ONamOtherOMrs,<NEAR>		
	localV	bufNam,CB_MAX_NAMENTRY	
cBegin
	cmp	[grs.GRS_oMrsCur],dx
	je	OnOExit			;brif source mrs = target mrs

	xchg	ax,bx			;bx = oNam (save until CopyONamPb)
	push	di
	push	[grs.GRS_oRsCur]	;save caller's oRs -for RsActivate below

	mov	di,dx			;di = target oMrs
	lea	ax,bufNam
	push	ax			;save ptr to string
					; string ptr in ax
					; oNam to CopyONamPb in bx
	cCall	CopyONamPb,<ax,bx>	; ax = byte count
	push	ax			;save byte count
	cCall	MrsActivateCP,<di>	;activate target mrs
	pop	cx			;cx = byte count
	pop	ax			;ax = ptr to bufNam
	call	ONamOfPbCb		;ax = target oNam (ax=Pb, cx=Cb)
	xchg	di,ax			;di = target oNam

	call	RsActivateCP		;re-activate caller's oRs
					; parm was pushed on entry
	xchg	ax,di			;ax = target oNam
	pop	di			;restore caller's es,di
OnOExit:
	or	ax,ax			;set condition codes
cEnd

;*************************************************************
; SaveDeclares
; Purpose:
;	Generate synthetic DECLARE stmts for forward referenced
;	SUBs and FUNCTIONs in this module as follows:
;	Pass1:
;	 For every prs in system,
;	   reset FTX_TmpDecl
;	   if prs type is FUNCTION and prs is in mrs being saved,
;	      set FTX_TmpRef bit, else reset it
;	Pass2:
;	 For every text table in this module
;	   Search text table for a reference to a SUB or FUNCTION
;	    if opStDeclare ref found
;	       set FTX_TmpDecl bit
;	    else if CALL, CALLS, implied CALL
;	       set FTX_TmpRef bit
;	Pass3:
;	 For every prs in system,
;	   if FP_DEFINED and FTX_TmpRef bit are set, and FTX_TmpDecl bit is not,
;	   copy pcode for definition to module, changing opcode to opStDeclare,
;	   and changing the oNam for each formal parm and explicitly
;	   listing the TYPE.
;
; Exit:
;	grs.fDirect = FALSE
;	ax = 0 for out of memory error.
;	flags set on value in ax
;*************************************************************

;----------------------------------------------------------------
;	 For every prs with a text table in system,
;	   reset FTX_TmpDecl
;	   if prs type is FUNCTION and prs is in mrs being saved,
;	      set FTX_TmpRef bit, else reset it
;----------------------------------------------------------------
cProc	SdPass1,<NEAR>
cBegin
	and	[txdCur.TXD_flags],NOT (FTX_TmpDecl OR FTX_TmpRef)
					;start out by turning both bits off
	cmp	[prsCur.PRS_procType],PT_FUNCTION
	jne	Sd1ResetBits		;exit if SUB
	mov	ax,[oMrsSaveDecl]
	cmp	ax,[prsCur.PRS_oMrs]
	jne	Sd1ResetBits		;exit if Func defined in another module

	;for func in module, assume it is referenced.  For external func
	;refs, even qbi requires user have a DECLARE stmt for it.
	
	or	[txdCur.TXD_flags],FTX_TmpRef ;turn on FTX_TmpRef bit
Sd1ResetBits:
	mov	ax,sp			;return TRUE for ForEachCP
cEnd

;-----------------------------------------------------------------
;	 For every text table in module being saved:
;	   Search text table for a reference to a SUB or FUNCTION
;	    if opStDeclare ref found
;	       set FTX_TmpDecl bit
;	    else if CALL, CALLS, implied CALL
;	       set FTX_TmpRef bit
;-----------------------------------------------------------------
cProc	SdPass2,<NEAR>,<si>
cBegin
	SetStartOtx si			;otxCur = start of text
Sd2Loop:
	push	si
	PUSHI	ax,<CODEOFFSET tOpDecl>
	call	TxtFindNextOp		;ax = otx to next opStDeclare opcode
	cmp	dl,DECL_opEot
	je	Sd2Exit
	xchg	si,ax			;si = new otxCur
	GetSegTxtTblCur			;es = seg addr of text table
	mov	ax,es:4[si]		;ax = oPrs field
	call	PPrsOPrs		; es:bx points to prs structure
					;all other regs preserved
	test	BPTRRS[bx.PRS_flags],FP_DEFINED 
	je	Sd2Loop			;don't count references to native-code
					; procedures, only those defined with
					; a SUB/FUNCTION stmt
	mov	al,FTX_TmpRef
	.errnz	DECL_opStDeclare
	or	dl,dl			;dl = 0 for DECLARE, non-zero for CALL
	jne	Sd2SetBit		;brif CALL
	mov	al,FTX_TmpDecl
Sd2SetBit:
	or	BPTRRS[bx.PRS_txd.TXD_flags],al 
	jmp	SHORT Sd2Loop

Sd2Exit:
	mov	ax,sp			;return TRUE for ForEachCP
cEnd

;***
;GetWord
;Purpose:
;	This header block added as part of revision [5]
;Preserves:
;	All but ES, BX, and SI
;******************************************************************************
GetWord PROC NEAR
	GetSegTxtTblCur			;es = seg addr of text table
	lods	WORD PTR es:[si]	;ax = cntEos
	ret
GetWord ENDP

MoveWord PROC NEAR
	call	GetWord
	jmp	Emit16_AX		;emit cntEos operand
					; and return to caller
MoveWord ENDP

;------------------------------------------------------------------------------
;	 For every prs with a text table in system,
;	   if FP_DEFINED and FTX_TmpRef bit are set, and FTX_TmpDecl bit is not,
;	   copy pcode for definition to module, changing opcode to opStDeclare,
;	   and changing the oNam for each formal parm and explicitly
;	   listing the TYPE.
;
;------------------------------------------------------------------------------
cProc	SdPass3,<NEAR>,<si,di>
	localW	oNamParm
cBegin
	test	[prsCur.PRS_flags],FP_DEFINED
	je	J1_Sd3Exit		; don't count references to
					; undefined procedures

	test	[txdCur.TXD_flags],FTX_TmpRef
	je	J1_Sd3Exit		;don't generate DECLARE for text tbl
					; with no references in this module
	test	[txdCur.TXD_flags],FTX_TmpDecl
	je	EmitDecl		;don't generate DECLARE for prs which
J1_Sd3Exit:
	jmp	Sd3Exit			; already has a declare in this prs

EmitDecl:
	mov	ax,[prsCur.PRS_otxDef]	; ax = otx to opStSub/Function
	mov	si,ax			;ax = si = text offset
	call	OtxDefTypeCur		;fill ps.tEtCur with default types
					; at definition of procedure
	mov	ax,opBol
	call	Emit16_AX

	mov	ax,opStDeclare
	call	Emit16_AX

	lodsw				;si=si+2 (points to cntEos parm)
	.errnz DCL_cntEos
	call	MoveWord		;move cntEos from es:[si] to ps.bdpDst

	.errnz DCL_oPrs	- 2
	call	MoveWord		;move oPrs from es:[si] to ps.bdpDst

	.errnz DCL_atr - 4
	call	GetWord			;ax = procAtr from es:[si]
	push	ax			;save proc atr
	.errnz	DCLA_procType - 0300h
	and	ah,DCLA_procType / 100h	;ah = procType
	cmp	ah,PT_FUNCTION
	jne	NoProcType		;brif this is not a FUNCTION
  	.errnz DCLA_Explicit - 0080h
	or	al,al
	js	NoProcType		;brif it was explicitly typed
	push	[prsCur.PRS_ogNam]	
	call	ONamOfOgNam		; ax = oNam of this prs
	DbAssertRel  ax,nz,0,CP,<txtsave.asm: ONamOfOgNam returned ax = 0>
	cCall	OTypOfONamDefault,<ax>	; ax = default oTyp (ax)
  	or	al,DCLA_Explicit	;remember this was Explicitly typed
	pop	dx
	mov	ah,dh			;ax = new procAtr
	push	ax
;top of stack = procAtr
NoProcType:
	call	Emit16			;emit proc atr operand

	.errnz DCL_cParms - 6
	call	GetWord			;ax = cParms operand from es:[si]
	mov	di,ax			;di = cParms
	call	Emit16_AX		;emit cParms operand
	inc	di
Sd3ParmLoop:
	dec	di			;decrement parm count
	jz	Sd3Exit			;brif done with parms
	.errnz	DCLP_id - 0	
	call	GetWord			;ax = parm's oNam or oVar
	cCall	oNamoVarRudeOrParse,<ax>;if we text not in rude map oVar
					; to oNam
	mov	[oNamParm],ax
	mov	dx,[oMrsSaveDecl]
	call	ONamOtherOMrs		;ax = equivalent oNam in module dx
					; (es is preserved)
	je	Sd3OmExit		;brif OM error (AX=0) to stop ForEach
	call	Emit16_AX		; oVar in SS_PARSE or SS_EXECUTE

 	.errnz DCLP_atr - 2		;Formal parm attributes (PATR_xxx)
	call	GetWord			;ax = formal parm atr
	push	ax			;save parmAtr
	.errnz	PATR_asClause AND 0FFh
	test	ah,PATR_asClause / 100h
	jne	Sd3AsClause		;brif 'id AS xxx'
	.errnz	PATR_explicit AND 0FFh
	or	ah,PATR_explicit / 100h	;in DECLARE, force it to be explicit
Sd3AsClause:
	call	Emit16_AX

	; if not SS_RUDE, it is oTyp of user type.
	
	.errnz DCLP_oTyp - 4		;Type of the formal parm
	call	GetWord			;ax = oNam for <user type> if > ET_MAX

	pop	bx			;bx = parmAtr
	.errnz	PATR_asClause AND 0FFh
	.errnz	PATR_explicit AND 0FFh
	test	bh,(PATR_explicit OR PATR_asClause) / 100h
	jne	NotImpl			;brif not implicitly typed
	push	[oNamParm]		
	call	OTypOfONamDefault	;ax = default oTyp for parm (ax)
NotImpl:
	cmp	ax,ET_MAX
	jbe	NotUserTyp		;brif it is a primitive type

	;Since declares are inserted before any type declarations, we cannot
	;insert any references to a type name in the declare.  SOOO, we
	;just always use as ANY for synthetic declares with user defined
	;types.
	sub	ax,ax			;ax = AS ANY
NotUserTyp:
	call	Emit16_AX
	jmp	SHORT Sd3ParmLoop

Sd3Exit:
	mov	ax,sp			;return TRUE for ForEachCP
Sd3OmExit:
cEnd

;-------------------------------------------------------------
; SaveDeclares - main code
;-------------------------------------------------------------
PUBLIC	SaveDeclares			;for debugging only
cProc	SaveDeclares,<NEAR>,<si>
cBegin
DbAssertRelB [txdCur.TXD_scanState],e,SS_RUDE,CP,<SaveDeclares:TxdCur not in SS_RUDE>
	call	PrsDeactivate		;make module's txt tbl active
	mov	ax,[grs.GRS_oMrsCur]
	mov	[oMrsSaveDecl],ax

	test	[mrsCur.MRS_flags2],FM2_Include ;is this an include mrs?
	jne	SdGoodExit		;don't insert decls into include
					;mrs's.  Re-Including could break
					;a previously running program.

	;For each prs in system which has a text table:
	mov	al,FE_PcodeMrs+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET SdPass1	;bx = adr of function to call
	call	ForEachCP

	;For each text table in module being saved:
	mov	al,FE_CallMrs+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET SdPass2	;bx = adr of function to call
	call	ForEachCP

	sub	ax,ax			
	mov	[ps.PS_bdpDst.BDP_cbLogical],ax
	call	SetDstPbCur

	;For each prs in system which has a text table:
	mov	al,FE_PcodeMrs+FE_PcodePrs+FE_SaveRs
	mov	bx,CPOFFSET SdPass3	;bx = adr of function to call
	call	ForEachCP
	je	SdExit			;brif out-of-memory

	SetStartOtx si			;insert DECLAREs at start of module
	call	TxtInsert
	je	SdExit			;brif out-of-memory

	SetStartOtx si			;otxInsert = start of text
	mov	bx,[ps.PS_bdpDst.BDP_cbLogical] ;pass cbInserted in bx
	or	bx,bx			;was any pcode inserted?
	je	NoDeclaresInserted	;brif not
	or	[mrsCur.MRS_flags2],FM2_Modified ;set modified bit so compiler
					;will compile same source as QBI for
					;MakeExe.
	push	bx			;save cbInsert
	call	DrawDebugScrFar		;update list windows for inserted text
	pop	bx			;restore bx=cbInsert
NoDeclaresInserted:
	call	TxtInsUpdate
SdGoodExit:				
	mov	ax,sp			;return non-zero (not out-of-memory)
SdExit:
	or	ax,ax			;set condition codes
cEnd


;*************************************************************
; SaveAllDeclares
; Purpose:
;	Generate synthetic DECLARE stmts for forward referenced
;	SUBs and FUNCTIONs for every module in the system.
;	Called by UI before MakeExe to ensure that Compiler
;	will compile same source as interpreter.  This solves
;	the situation for a QB2/3 program is loaded and works
;	correctly for QBI, but will not compile in BC.	If we
;	have inserted synthetic declares, or altered the pcode
;	in some way, we need to make sure that the dirty bit
;	gets set for the module.
; Entry:
;	none.
; Exit:
;	grs.fDirect = FALSE
;	ax = 0 for no error, else QBI standard error code.
;*************************************************************
cProc	SaveAllDeclares,<PUBLIC,FAR>
cBegin
	;For each mrs in system which has a pcode text table:
	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
	mov	bx,CPOFFSET SaveDeclares ;bx = adr of function to call
	call	ForEachCP
	mov	ax,ER_OM		;default Out of memory error
	je	SaveAllDeclaresExit	;brif out-of-memory
	sub	ax,ax
SaveAllDeclaresExit:
cEnd

;*************************************************************
; ushort AsciiSave()
; Purpose:
;	ASCII save the current module (with all its procedures)
;
; Exit:
;	grs.fDirect = FALSE
;	ps.bdpSrc is used
;	ax = 0 if no error, else Standard BASIC error code (i.e. ER_xxx)
;
; Exceptions:
;	Can cause runtime error (Out of memory, I/O errors)
;
;*************************************************************
cProc	AsciiSave,<NEAR>,<si>
cBegin
	call	AlphaBuildORs		; build sorted list of all oRs's
	or	ax,ax			;set flags based on returned value
	mov	ax,ER_OM		;prepare to return Out-of-memory error
	je	AsDone			;brif error
	call	PrsDeactivate		;make module's txt table active
	sub	ax,ax
	mov	[fLsDynArrays],al	;default state is $STATIC
	DbAssertRel ax,e,0,CP,<AsciiSave: ax!=0> ;SaveTxdCur needs ax=0

;ax = otx of 1st line in current text table to be written to file
AsLoop:
	call	SaveTxdCur		;save module/procedure text table
	test	[mrsCur.MRS_flags2],FM2_NoPcode ; document file?
	jne	NotModuleText		; brif so, never add blank line
	cmp	ax,2			;was last line a blank one?
	jbe	NotModuleText		;brif so
	call	OutCrLf 		;output a blank line so comment blocks
					;are associated with correct text tbls
NotModuleText:
	call	OtxDefTypeEot		;fill ps.tEtCur with default types
					; at end of module/procedure
	call	NextAlphaPrs		;activate next procedure in module
	or	ax,ax			;set flags
	je	AsDone			;brif no more procedures in module
	SetStartOtx ax			
	test	[prsCur.PRS_flags],FP_DEFINED
	je	ProcNotDefined		;brif no SUB/FUNCTION stmt
	push	[prsCur.PRS_otxDef]	;push offset to opStSub/opStFunction
	call	OtxBolOfOtx		;ax = text offset for 1st line of SUB
ProcNotDefined:
	mov	si,ax			;si = ax = otxProcDef
	call	SaveProcHdr		;save proc hdr(ax) (may contain some
					; synthetically generated statements
	jne	AsDone			;brif error
	xchg	ax,si			;ax = otxProcDef
	jmp	SHORT AsLoop

;al = 0 if no error, else standard QBI error code
AsDone:
cEnd	;AsciiSave

;****************************************************************************
;SaveModName - save the name of the current module to the file
;
;Purpose:
;	Used by Save to save the name of each module in a .MAK file.
;Entry:
;	The .MAK file is open to current channel
;	si points to static buffer holding name of the MAK file's directory.
;	di points to static buffer which can be used to hold module's name
;Exceptions:
;	Assumes caller called RtSetTrap to trap runtime errors.
;
;****************************************************************************
SaveModName PROC NEAR
	mov	ax,di			; pDest (parm to CopyOgNamPbNear)
	mov	bx,[mrsCur.MRS_ogNam]	; ogNam (parm to CopyOgNamPbNear)
	call	CopyOgNamPbNear		; copies name to buffer, returns 
					;   ax = cbName
	mov	bx,di			
	add	bx,ax			; add cbName
	mov	BYTE PTR [bx],0		; zero terminate

	;MakeRelativeFileSpec(szFilename, szMakDirectory)
	cCall	MakeRelativeFileSpec,<di,si> ;convert szFilename to relative
					; path from szMakDirectory if possible
	cCall	CbSz,<di>		;ax = length of result path
					;ax = size of line to output
	mov	bx,di			;bx points to start of line to output
	call	OutLine			;output the line
	ret
SaveModName	ENDP

;****************************************************************************
; FNotMainModule
; Purpose:
;	Called via ForEachCP to see if there is any pcode module
;	that is not the main module (i.e. to see if this is a
;	multiple-module program.
; Exit:
;	Return 0 in ax if current module is not main-module
;	else return non-zero in ax
;
;****************************************************************************
FNotMainModule PROC NEAR
	mov	ax,[grs.GRS_oMrsCur]
	cmp	ax,[grs.GRS_oMrsMain]
	mov	ax,sp			;prepare to return non-zero
	je	FNotMainExit
	sub	ax,ax			;return 0 (not main module)
FNotMainExit:
	ret
FNotMainModule ENDP

;*************************************************************
; SaveMakFile
; Purpose:
;	Called by SaveFile to see if we're saving the main module
;	of a multi-module program.  If so, this creates <filename>.MAK
;	file and writes the names of all modules in the program.
; Entry:
;	mrsCur.ogNam is current module's filename
; Exit:
;	ax = error code (0 if none), condition codes set
; Exceptions:
;	assumes caller has called SetRtTrap to trap runtime errors
;
;*************************************************************
cProc	SaveMakFile,<NEAR>,<si,di>
	localV	szDir,FILNAML		
	localV	filenameNew,FILNAML	; size expected by runtime routines
					; used for filename normalization
	localV	sdFilenameNew,<SIZE SD>
cBegin
	mov	ax,[grs.GRS_oMrsMain]
	cmp	ax,[grs.GRS_oMrsCur]
	jne	SmfGood			;brif this isn't main module

	mov	bx,si			;bx = psdFilename
	lea	si,[sdFilenameNew]	;si = &sdFilenameNew
	lea	di,[filenameNew]	
	mov	[si.SD_pb],di		; set up string descr.
	call	MakFilename		;fill di with <moduleName>.MAK
	jne	SmfExit 		;brif Bad File Name

	mov	al,FE_PcodeMrs+FE_CallMrs+FE_SaveRs
	mov	bx,CPOFFSET FNotMainModule ;bx = adr of function to call
	call	ForEachCP		;ax=0 if multi-module program
	je	MultiModules		;brif multi-module program is loaded
	push	di			;pass ptr to szFilenameNew
	call	DelFile			;delete filename.MAK
	jmp	SHORT SmfGood		;exit if not multi-module program

;Open filename in sdFilename (si) (.MAK file) and write all module names to it
MultiModules:
	;If we could assume DOS 3.0 or greater, (we can't yet) we could set
	;dx to (ACCESS_WRITE OR LOCK_BOTH) SHL 8 OR MD_SQO
	
	mov	dx,MD_SQO
	call	OpenChan		;al = error code (0 if no error)
	jne	SmfExit			;brif errors

	;fill si with sz for directory of .MAK file
	lea	si,szDir		;si points to working static buffer
	push	di			;pass pbSrc (filenameNew)
	push	si			;pass pbDst (szDir)
	mov	bx,[sdFilenameNew.SD_cb]
	push	bx			;pass byte count
	mov	BYTE PTR [bx+si],0	;0-terminate destination
	call	CopyBlk			;copy module name to static buffer
	push	si			;pass szDir
	call	FileSpec		;ax points beyond pathname
	xchg	bx,ax			;bx points beyond pathname
	mov	BYTE PTR [bx-1],0	;0-terminate szDir

	;Save the name of the Main Module first, so it will be loaded first
	;si points to szDir
	;di points to filenameNew (will be used for temp buffer)
	
	call	SaveModName		;write main module's relative path
	call	MrsDeactivate		;start writing other module names
SmLoop:
	call	NextMrsFile_All 	;make next mrs active
	inc	ax			;test for UNDEFINED (end of mrs list)
	je	SmDone			;brif done with all mrs's
	dec	ax			;restore ax = module's name
	cmp	ax,[grs.GRS_oMrsMain]
	je	SmLoop			;brif this is MAIN mod (already output)
	test	[mrsCur.MRS_flags2],FM2_NoPcode OR FM2_Include
	jne	SmLoop			;skip document and include mrs's
	call	SaveModName
	jmp	SHORT SmLoop

SmDone:
	push	[grs.GRS_oMrsMain]	;we know the main module was active
	call	MrsActivateCP		; on entry - reactivate it on exit

	call	CloseChan		;close [chanCur]
SmfGood:
	sub	ax,ax
SmfExit:
	or	ax,ax			;set condition codes for caller
cEnd

;*************************************************************
; ushort SaveFile()
; Purpose:
;	Open the specified file and save program to it.
;
; Entry:
;	mrsCur.ogNam = filename to be saved.
;	   (the filename need not be 0-byte terminated)
;	mrsCur.flags2 FM2_AsciiLoaded is TRUE for ASCII Save
;	FOR EB: parm1 = mode for opening file
;
; Exit:
;	ps.bdpSrc is used
;	grs.fDirect = FALSE
;	ax = 0 if no error, else Standard BASIC error code (i.e. ER_xxx)
;
;*************************************************************
cProc	SaveFile,<PUBLIC,FAR,NODATA>,<si>
	localV	FileName,FILNAML	
	localV	sdFileName,<SIZE SD>	
cBegin
	mov	ax,-MSG_Saving		;display Saving msg in intense video
	call	StatusMsgCP		; to tell user we're loading
	call	AlphaORsFree		;release table of sorted oRs's
					; (user interface may have chosen
					;  a new name for this mrs)
	push	[grs.GRS_oRsCur]	;save mrs/prs - restored on exit

	call	RtPushHandler		;save caller's runtime error handler
					; could be called by LoadFile->NewStmt
					; (NOTE: alters stack pointer)
	SetfDirect al,FALSE		;turn off direct mode
	mov	ax,CPOFFSET SfDone	;if any runtime errors occur,
	call	RtSetTrap		;branch to SfDone with sp,di =
					;current values

					; doesn't have to be recompiled
	call	ModuleRudeEdit		
	call	SaveDeclares		;generate synthetic DECLARE stmts
					; for forward-referenced
	mov	ax,ER_OM		;default to OM error
	je	SfDone			;brif error

	lea	si,[sdFileName]		;cant use buffers here used for
	lea	ax,[FileName]  		;load because we may need to save
	mov	[si.SD_pb],ax		;current module during fileopen
	mov	bx,[mrsCur.MRS_ogNam]	
	call	CopyOgNamPbNear		; ax = number of chars copied
	mov	[si.SD_cb],ax		
	call	SaveMakFile		;create <filename>.MAK if main
					; program of multi-module program.
	jne	SfDone			;brif errors

	;If we could assume DOS 3.0 or greater, (we can't yet) we could set
	;dx to (ACCESS_WRITE OR LOCK_BOTH) SHL 8 OR MD_SQO
	
	mov	dx,MD_SQO
	call	OpenChan		;[chanCur] = channel #
	jne	SfDone			;brif error


DoAsciiSave:
	call	AsciiSave		;al = errCode

;We're done trying to write the file, now try to close it.
;Closing the file can cause I/O errors when close flushes the buffer.
;al = 0 if no error, else standard QBI error code
SfDone:
	sub	ah,ah			;ax = error code
SfDone2:				
	xchg	si,ax			;si = return value
	test	[flagsTM],FTM_SaveProcHdr
	je	NoShCleanup		;brif SaveProcHdr was not in critical
					; section.
	call	RelShBuf		;release temp text tbl used by
					; SaveProcHdr
NoShCleanup:
	call	RtFreeTrap		;free previous trap address
	mov	ax,CPOFFSET SfGotErr	;if any runtime errors occur,
	call	RtSetTrap		;branch to SfGotErr with sp,bp,si,di
					;set to current values
	call	CloseChan		;close file before kill
					; (sets ChanCur = 0)
	cCall	RtFreeTrap		; release error handler
	test	si,7FFFh		; test low 15 bits for error code
	je	SfNoErr			;brif no error before close

	xor	ax, ax			; no error during close

;If we got an error during save, delete partially created file
SfGotErr:

	test	si, 7fffh		; do we already have an error
	jnz	SfTestDelFile		; brif so, use it
	or	si, ax			; else add in new error


;	Only delete the file if we actually created and started to save
;	a binary file.	We don't want to delete an existing file if we
;	got an error on or before the open, and we also don't want to
;	delete a partially written ascii file.

SfTestDelFile:
	or	si,si			; got to BinarySave?
	jns	SfExit			; no, then don't kill the file

	push	di			
	mov	ax,CPOFFSET SfKillErr	; trap & ignore any runtime errors
	cCall	RtSetTrap		; in KILL 
	sub	sp,((FILNAML+SIZE SD+2)+1) AND 0FFFEh ;[3] create a fake sd
						      ;    on the stack
	mov	di,sp			
	add	di,6			; pnt to strt of where string will be
	mov	[di-2],di		; setup pb part of fake sd
	mov	ax,di			; parm to CopyOgNamPbNear
	mov	bx,[mrsCur.MRS_ogNam]	; parm to CopyOgNamPbNear
	call	CopyOgNamPbNear		; copy name onto stack, ax = cbName
	sub	di,4			; di = pFakeSd
	mov	[di],ax			; set up cb part of fake sd
	cCall	B$KILL,<di>		; call rt to delete file
	add	sp,((FILNAML+SIZE SD+2)+1) AND 0FFFEh ;[3] restore stack ptr

SfKillErr:				; branched to if error during KILL
	pop	di			

	jmp	SHORT SfExit

SfNoErr:
	and	[mrsCur.MRS_flags2],NOT (FM2_Modified or FM2_ReInclude) 
	and	[mrsCur.MRS_flags3],NOT FM3_NotFound ;If the user told
					;us to save the file, we have
					;found it.
	test	[mrsCur.MRS_flags2],FM2_Include
	je	SfExit			;brif this is not an $INCLUDE file
	or	[flagsTm],FTM_reInclude	;re-parse all $INCLUDE lines in
					;all modules before next RUN
SfExit:
	and	[flagsTM],NOT FTM_SaveProcHdr ;reset critical section flag
	call	RtPopHandler		;restore caller's runtime error handler
					; (saved on stack by RtPushHandler)
	call	RsActivateCP		;restore caller's mrs/prs
	call	StatusMsg0CP		;tell user interface we're done saving
	xchg	ax,si			;restore ax = error code
	and	ah,7Fh			; clear BinarySave flag bit
cEnd


sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\typmgr.asm ===
TITLE	TYPMGR - Type Table Management Code for QBI

;***
;TypMgr.asm - Type Table Management Code for QBI
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Create and search for User defined types and elements of types
;Assumptions:
;	The "module type table" was at one point an actual table. With QB5/EB,
;	it was moved into the module variable table - - - both VAR and
;	TYP/ELEM structures have no particular order requirements, being
;	chained together, and both are created and discarded at the same
;	time. We can therefore have VAR, TYP, and ELEM structs interleaved 
;	in the one physical table, but continue to think of them as unique 
;	logical tables.
;
;	Each module type table consists of a single chain of TYP structures
;	the offset to the first TYP in this chain is at offset oOFIRST_TYP 
;	in the table.
;
;	The first TYP struct in each module type table must start at an offset
;	greater than ET_MAX so an oTyp for a user-defined record is always 
;	greater than any predefined type constant. Besides the offset to the 
;	first TYP, the number of currently defined types is found in the table
;	following the offset to the first TYP at offset oCTYPES.
;
;	Each user-defined type has an associated chain of elements. The offset
;	to the first element in a type is contained in the TYP structure. The
;	elements are always chained in the same order as they are found in
;	the text; this is ensured by the fact that the entire type table
;	is discarded (and the module put in SS_RUDE) whenever a type is
;	removed or an element is inserted out of order (i.e., not sequentially
;	after the last element inserted in the type).
;
;	Note that TYP and ELEM structures are intermingled in the table
;	The physical order doesn't matter, only the chain order (we can
;	never walk each physical entry in the table, only walk the TYP
;	chain and each ELEM chain).
;
;	The TYP and ELEM structures are similar; we take advantage of the
;	fact that the oNam field is in the same location for both.
;
;*******************************************************************************

	.xlist
	include version.inc
	TYPMGR_ASM = ON		;don't include EXTRNs defined in this file
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	names
	includeOnce	qbimsgs
	includeOnce	rtps
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	variable
	.list

;	.sall

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA
assumes CS,CP

sBegin	DATA
staticW	oElemLast,0		;used to allow DefineElem to leverage off of
				;some code in RefElem
externB b$ErrInfo
sEnd	DATA



sBegin	CP
assumes	cs,CP

;***
;DefineTyp(oNam) - create a new entry in the type table
;Purpose:
;  Called when the parser encounters a TYPE statement, to create a new
;  entry in the module type table for the type. 
;
;  Note that the scanner uses bits 13, 14, & 15 of an oTyp, so type tables
;  can be no larger than 8k.
;
;  Note: EB has a special use for this where the 'oNam' is really something
;	 else. The high bit set on input indicates that this is not really
;	 an oNam - - - the high bit is maintained in the oNam field of the typ.
;
;Entry:
;  oNam - module name table offset for the name of the type.
;
;Exit:
;  returns an offset into mrsCur.bdVar for the new type entry, or an
;  error code, depending on bit 15 of the return value. If bit 15 is
;  clear, an offset is returned, if set, the return value with bit 15
;  masked off is a standard basic error code.
;
;Exceptions:
;  none.
;  
;
;******************************************************************************
cProc	DefineTyp,<FAR,PUBLIC,NODATA>,<SI,DI>	
	parmW	oNam
	localW	oTypLast
cBegin	DefineTyp
;	register si = pTypBase
;	register di = pTyp
;	dx = cbOld
	DbChk	MrsCur
	mov	si,[mrsCur.MRS_bdVar.BD_pb]	
	mov	di,[si+oOFIRST_TYP]		
	mov	dx,[mrsCur.MRS_bdVar.BD_cbLogical] ; dx = cbOld
	jmp	SHORT DefineTyp_Loop_Check
DefineTyp_Loop:
	add	di,si		;pTyp = pTyp + pTypBase
	mov	ax,PTRVAR[di.TYP_oNam]
	cmp	[oNam],ax
	jnz	DefineTyp_No_Error

	mov	ax,08000H OR ER_DD
	jmp	short DefineTyp_Exit
DefineTyp_No_Error:
	mov	ax,PTRVAR[di.TYP_oTypNext]
	and	ah,07FH 	; mask off flag bit
	sub	di,si
	mov	[oTypLast],di	;oTypLast = pTyp - pTypBase
	xchg	ax,di		;di = new oTyp
DefineTyp_Loop_Check:
	or	di,di		;end of TYP chain?
	jnz	DefineTyp_Loop	;  brif not

	cmp	WORD PTR PTRVAR[si+oCTYPES],CTYPESMAX	;[3]
	je	DefineTyp_OM_ER1 ;brif this would cause table to have more than 
				;the legal max. number of types
	push	dx		;save cbOld across call
	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdVar>	
	PUSHI	ax,<SIZE TYP>
	call	BdGrowVar	; grow type table enough for new type
	; we can't just blindly call BdGrowVar at a point where the user CAN
	;  continue - - - but txtmgr guarantees that any edit of a TYPE 
	;  statement or of an element in a TYPE block causes module rude edit
	DbAssertRel  grs.GRS_otxCONT,z,UNDEFINED,CP,<DefineTyp: CAN Continue>
	pop	dx		;restore cbOld
	or	ax,ax
	jne	DefineTyp_Cont	; brif attempt to grow table succeeded
DefineTyp_OM_ER1:		
	jmp	short DefineTyp_OM_ER		

DefineTyp_Cont:			
	mov	si,[mrsCur.MRS_bdVar.BD_pb]
				;update pTypBase in case of heap movement
	inc	PTRVAR[si+oCTYPES]		
				; increment count of types in table
	mov	di,dx		;cbOld
	add	di,si		;di = pTyp
	mov	ax,[oNam]
	mov	PTRVAR[di.TYP_oNam],ax		
	sub	ax,ax
	mov	PTRVAR[di.TYP_cbData],ax	
	mov	PTRVAR[di.TYP_oElementFirst],ax	
	mov	PTRVAR[di.TYP_oTypNext],ax	
	mov	bx,[oTypLast]
	cmp	PTRVAR[si+oOFIRST_TYP],ax	
				;special case of start of type table?
	jne	ChainTyp	;  brif not

	mov	bx,oOFIRST_TYP - TYP_oTypNext	
				; this will make the following instruction
				; put this oTyp in the table, to start the 
				; TYP chain
ChainTyp:
	or	PTRVAR[bx.TYP_oTypNext][si],dx	
	xchg	ax,dx		;cbOld = oTypNew = retval
DefineTyp_Exit:
cEnd	DefineTyp

DefineTyp_OM_ER:
	mov	ax,ER_OM OR 08000H
	jmp	SHORT DefineTyp_Exit

;***
;RefTyp(oNam, oTxRef) - Return oTyp for a type described by oNam
;
;Purpose:
;  Given an oNam and the text offset at which it was found, return the 
;  offset into the type table for the type of this name.
;  If the text offset at which the type was defined is larger than oTxRef
;  (i.e., if this amounts to a forward reference), return an error code,
;  MSG_UndType.
;
;Entry:
;  oNam - offset into the module name table.
;  oTxRef - offset into active text table where type reference was found
;
;Exit:
;  If bit 15 is clear, return value is an offset into the module type table 
;  for the desired type entry; if bit 15 is set, the return value is an 
;  error code; this error code with bit 15 masked off is a standard basic 
;  error code.
;  Only one error code is defined: the case where no type entry is found
;  with the input oNam.
;  If this error occurs, the parser will emit an opReParse - - - it is NOT
;  safe to create an empty type entry in this case, because the reference
;  might create a static variable entry, which would end up with a size
;  of zero for the value field ... a type reference prior to definition
;  must trigger an error.
;
;Exceptions:
;  none.
;Preserves:
;  ES
;******************************************************************************
cProc	RefTyp,<PUBLIC,FAR,NODATA>,<ES>   
	parmW	oNam
	parmW	oTxRef
cBegin	RefTyp
	DbChk	MrsCur

	;Check to see that this is not a forward reference
	cCall	OtxTypDefined,<oNam>
RefTyp_Cont:				
	mov	bx,[mrsCur.MRS_bdVar.BD_pb] 
	mov	dx,PTRVAR[bx+oOFIRST_TYP]; dx = offset to first typ in chain
	xchg	bx,dx
	cmp	ax,[oTxRef]		;returned from OtxTypDefined
	jb	RefLoop_Start
RefTyp_Err_Exit:
	mov	ax,MSG_UndType OR 08000H
	jmp	SHORT RefTyp_Exit
RefTyp_Loop:
	mov	bx,PTRVAR[bx.TYP_oTypNext] ; offset to next type (oTypCur)
	and	bh,07FH 		; mask off flag bit
RefLoop_Start:
	or	bx,bx
	je	RefTyp_Err_Exit		;brif no more entries - not found

	add	bx,dx			;bx = pTypCur
	mov	ax,PTRVAR[bx.TYP_oNam]	
	cmp	[oNam],ax
	jne	RefTyp_Loop		;brif names don't match
	or	BPTRVAR[bx.TYP_fReferenced],080H	
					;set fReferenced bit
	xchg	ax,bx
	sub	ax,dx			;subtract off table base for retval
RefTyp_Exit:
cEnd	RefTyp

;***
;DefineElem(oNam, oTyp, oTypElem) - Add an element to a type
;DefineElemFixed(cbFixed, oNam, oTyp, oTypElem) - alternate entry point.
;
;Purpose:
;  Given an oNam for a new element, the oTyp for the type entry the element
;  is to be a part of, and the oTyp for the type of the new element,
;  add the element to the chain of elements for that type.
;  DefineElemExp converted to DefineElemFixed as part of revision [7].
;Entry:
;  oNam - offset into mrsCur.bdlNam for the element being defined
;  oTyp - offset into mrsCur.bdVar for the type entry it will belong to
;  oTypElem - oTyp for the element that's being defined, i.e., the type
;             of the new element (can be some user defined type).
;  For DefineElemExp, oTypElem will be ET_FS or ET_FT, and this word
;	      parameter will also have its high bit set (per pcode) if
;	      the cbFixed parameter is really an oNam of a constant which
;	      contains the length of the fixed-length string/text.
;Exit:
;  A new element entry is allocated, completely filled in, and linked in to
;     the end of the element chain for the given type.
;  Return value is a standard BASIC error code, OR'd with 0x8000 for 
;     consistency with other TypeMgr functions. Possible error codes are:
;
;     ER_DD - already exists an element of this type of that oNam
;     ER_OM - Out of Memory
;     MSG_UndType - recursive definition, i.e., element not allowed to
;                       be of the same oTyp as its parent type.
;     MSG_InvConst - DefineElemExp called with the oNam for a CONSTant, and
;			some error occured in finding a matching CONSTant.
;     If all bits are clear (i.e., 0 is returned), no error.
;
;  NOTE: As a side effect of this routine, mkVar.MKVAR_oTyp can be modified.
;        This is wierd, but it saves some code in RefElem and callers.
;
;Exceptions:
;  none.
;
;******************************************************************************
cProc	DefineElemFixed,<PUBLIC,NEAR,NODATA>
	parmW	cbFixed
	parmW	oNam
	parmW	oTyp
	parmW	oTypElem
cBegin
	mov	cx,[cbFixed]
	cCall	DefineElemCommon,<oNam,oTyp,oTypElem>
cEnd

cProc	DefineElem,<PUBLIC,NEAR,NODATA>
cBegin	<nogen>
	xor	cx,cx
cEnd	<nogen>

cProc	DefineElemCommon,<NEAR,NODATA>,<SI,DI>
	parmW	oNam
	parmW	oTyp
	parmW	oTypElem
	localW	cbOld
	localW	pTyp
	localW	cbFixed 		
cBegin
	mov	[cbFixed],cx		; remember if fixed-length string/text
					;   element or not
	jcxz	DefineElem_Shared	;brif DefineElem was called
	mov	ax,[oTypElem]
	or	ah,ah			
	jns	DefineElem_Shared	; brif cbFixed actually is a byte count

	and	ah,07FH 		; mask off high bit
	mov	[oTypElem],ax		; restore as an actual ET_ type
	xchg	ax,cx			
	;ax = oNam of a CONSTant
	mov	[mkVar.MKVAR_oNam],ax
	mov	[mkVar.MKVAR_oTyp],ET_I2
	mov	[mkVar.MKVAR_flags],0	;only want to find ET_I2 match
	or	[mkVar.MKVAR_flags2],MV_fDontCreate
	call	MakeVariable
	xchg	ax,bx			;put retval in bx
	mov	ax,MSG_InvConst	OR 08000H ;in case of error return
	or	bx,bx
	js	DefineElem_Exit2	;brif some error finding the CONSTant

	add	bx,[mrsCur.MRS_bdVar.BD_pb]
	mov	ax,PTRVAR[bx.VAR_value] ;get the I2 CONSTant value
	mov	[cbFixed],ax
DefineElem_Shared:			;code common to both entry points from
					;  here on
	DbChk	oNam,oNam
	DbChk	oTyp,oTyp
	DbChk	oTyp,oTypElem
	mov	ax,[mrsCur.MRS_bdVar.BD_cbLogical] 
	mov	[cbOld],ax
	mov	ax,[oTypElem]
	cmp	[oTyp],ax
	mov	ax,MSG_UndType OR 08000H ;give this error for self recursion.
					 ;note that that parser won't allow
					 ;indirect recursion case to occur
	jz	DefineElem_Exit2	;brif self recursion - error

	mov	[oElemLast],0		

	push	[oNam]			; parm to RefElem
	PUSHI	ax,ET_IMP		; error if match regardless of type
	mov	ax,[oTyp]		
	mov	[mkVar.MKVAR_oTyp],ax	
	call	far ptr RefElem 	; ax = retval - better be an error
					;  NOTE: Updates oElemLast
	cmp	ax,MSG_UndElem OR 08000H ; RefElem shouldn't have found elem
	mov	ax,ER_DD OR 08000H	;ER_DD if it did
	jz	DefineElem_Cont0
DefineElem_Exit2:
	jmp	DefineElem_Exit1	
DefineElem_Cont0:
	mov	cx,[cbFixed]		
	jcxz	Grow_tElem		; brif not fixed-length string/text elem
					
	mov	cx,2			; size of ELEM_cbFixed field
Grow_tElem:				
	add	cx,SIZE ELEM
	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdVar>	
	push	cx			
	call	BdGrowVar		; grow type table enough for new type
	or	ax,ax
	je	DefineElem_OM_Error_1

	mov	di,[mrsCur.MRS_bdVar.BD_pb] ;di points to base of type table
	mov	ax,[oTyp]
	add	ax,di
	mov	[pTyp],ax
	mov	si,[cbOld]
	add	si,di			;si points to element being defined
	mov	ax,[oNam]
	mov	PTRVAR[si.ELEM_oNam],ax	
	mov	PTRVAR[si.ELEM_oElementNext],0 ;[3]
	mov	ax,[oTypElem]
	mov	PTRVAR[si.ELEM_oTyp],ax	
	cCall	CbTyp,<ax>
	jnz	Got_cbTyp		; brif type wasn't ET_FS or ET_FT
					
	mov	ax,[cbFixed]		
	mov	PTRVAR[si.ELEM_cbFixed],ax 
Got_cbTyp:
	mov	bx,[pTyp]
	mov	cx,PTRVAR[bx.TYP_cbData]
	mov	PTRVAR[si.ELEM_oVar],cx	
	add	PTRVAR[bx.TYP_cbData],ax
	jc	DefineElem_OM_Error	; brif wrap beyond 64k

	mov	ax,[oTypElem]
	cmp	ax,ET_MAX
	jbe	@F			; brif new elem not of user-def. type

	or	BPTRVAR[bx.TYP_fReferenced],080H    
					;set fReferenced bit
@@:
	cmp	ax,ET_SD		; dynamic string?
	jnz	@F			; brif not
	or	BPTRVAR[bx.TYP_flags],F_NOBLKCPYTYP 
					; remember that in order to assign a
					; var of this type to another such
					; var, we can't simply block copy
@@:					
	mov	bx,[oElemLast]
	mov	ax,[cbOld]
	or	bx,bx			
	jne	Not_1st_Elem		;brif this is not 1st elem in typ
	mov	bx,[pTyp]		;special start of elem chain code
	mov	PTRVAR[bx.TYP_oElementFirst],ax	
	jmp	SHORT DefineElem_Cont2
DefineElem_OM_Error_1:			
DefineElem_OM_Error:
	mov	ax,ER_OM OR 08000H
DefineElem_Exit1:
	jmp	short DefineElem_Exit
Not_1st_Elem:				;link new element in @ end of chain
	mov	PTRVAR[bx.ELEM_oElementNext][di],ax	
DefineElem_Cont2:
	sub	ax,ax
DefineElem_Exit:
cEnd	DefineElem

;***
;RefElem - return offset to specified element in tTyp
;
;Purpose:
;  Given the oNam for an element in type mkVar.MKVAR_oTyp, return the offset 
;  into mrsCur.bdVar for the element, and place the type of the element into
;  mkVar.MKVAR_oTyp.
;
;Entry:
;  oNam - name of the element to be found
;  oTypElem - oTyp of element; ET_IMP if caller doesn't know type.
;		This is used so we can give ER_TM if user puts an (incorrect)
;		explicit type char on an element reference.
;  The oTyp of the parent type is in mkVar.MKVAR_oTyp.
;Exit:
;  return value is an offset into mrsCur.bdVar for the element if bit
;     15 is clear, or is a standard BASIC error code OR'd with bit 15 if set.
;  If successful, mkVar.MKVAR_oTyp is changed to the oTyp of the found element.
;  If the found element is a fixed-length string/text, mkVar.MKVAR_fsLength
;	is changed to the length of the string.
;  Static oElemLast:
;	if the element contains no types of the found element is the first
;		in the chain, oElemLast will be unchanged.
;	else if the element is found, oElemLast will be an offset to the
;		previous element in the chain.
;	else (element not found in non-empty element chain), oElemLast is
;		an offset to the last element in the chain.
;
;Exceptions:
;  none.
;
;******************************************************************************
cProc	RefElem,<PUBLIC,FAR>,<si,di>	
	parmW	oNamElem		
	parmW	oTypElem		
cBegin					
	mov	si,[mrsCur.MRS_bdVar.BD_pb] 
	mov	bx,[mkVar.MKVAR_oTyp]	
	DbChk	UserTyp,bx		;Ensure the oTyp we're looking in is 
					;  valid, and a user defined oTyp
	mov	ax,PTRVAR[bx.TYP_oElementFirst][si]	
	and	ah,07FH			;mask off fReferenced bit
	xchg	di,ax			;di = table offset to first elem in typ
	mov	dx,[oNamElem]		
	DbChk	oNam,dx 		
	jmp	short RefElem_LoopStart 

RefElem_MSG_Undefined:
	mov	ax,MSG_UndElem OR 08000H
	jmp	SHORT RefElem_Exit

RefElem_Loop:
	mov	di,PTRVAR[di.ELEM_oElementNext]	
RefElem_LoopStart:
	or	di,di			
	jz	RefElem_MSG_Undefined	;brif end of elem chain - elem not found
	
	mov	[oElemLast],di		;always keep oElem of last elem here
	add	di,si			;di = pElem
	cmp	PTRVAR[di.ELEM_oNam],dx	
	jnz	RefElem_Loop		;brif no match

	mov	ax,PTRVAR[di.ELEM_oTyp]	
	mov	[mkVar.MKVAR_oTyp],ax	;set oTyp of found element in location
					;  provided by caller
	mov	bx,ax			
	cmp	ax,ET_FS		
	jnz	RefElem_Exit1		

	mov	bx,ET_SD		; explicit type char for ET_SD ($)
					; legally matches element of ET_FS
	mov	ax,PTRVAR[di.ELEM_cbFixed] 
	mov	[mkVar.MKVAR_fsLength],ax  
RefElem_Exit1:
	xchg	ax,di			;ax = pElemFound
	sub	ax,si			;ax = retval = oElemFound

	.errnz	ET_IMP - 0		
	mov	cx,[oTypElem]		
	jcxz	RefElem_Exit		; brif caller doesn't want to
					; check type of element
	cmp	cx,bx			; does element match given oTyp?
	jz	RefElem_Exit		; brif so

	mov	ax,ER_TM OR 08000H	; type mismatch error
RefElem_Exit:				
cEnd					


;***
;CompareTypsRecurse - compare 2 types to see if they're the same
;
;Purpose:
;	Given two oTyps, compare them (recursively element-by-element)
;	to see if they're the same. The given oTyp's do not have to be
;	for user-defined types - - - any valid oTyp's are okay.
;
;Entry:
;  ax = oTyp1 - first type
;  bx = oTyp2 - first type
;  if SizeD,
;		ds is set to seg of type table for oTyp1,
;		es is set to seg of type table for oTyp2.
;  else
;		si points to base of type table for oTyp1
;		di points to base of type table for oTyp2
;Exit:
;  PSW.Z set if the two types match, reset if not.
;	if PSW.Z set, CX = 0 indicates no further comparison need be made.
;	if CX != 0, however, the oTyp's are either ET_FS or ET_FT, and
;	the lengths must be compared by the caller (who presumeably has
;	access to these lengths).
;  If PSW.Z reset, CX = 0 if routine succeeded, ER_OM if insufficient
;	stack space for required recursion.
;Exceptions:
;  none.
;
;******************************************************************************
cProc	CompareTypsRecurse,<NEAR,NODATA>
cBegin	CompareTypsRecurse
	cmp	bx,ET_MAX		;is oTyp2 user-defined?
	jbe	Compare_Cmp_Exit	; brif not

	cmp	ax,ET_MAX		;is oTyp1 user-defined?
	jbe	Compare_Cmp_Exit	; brif not
	add	ax,si			;ax = pTyp1
	add	bx,di			;bx = pTyp2
	mov	bx,PTRVAR[bx.TYP_oElementFirst]	
	and	bh,07FH			;mask off fReferenced bit
	xchg	ax,bx
	mov	bx,[bx.TYP_oElementFirst]
	and	bh,07FH			;mask off fReferenced bit
Elem_Compare_Loop:
	;bx = oElem1, ax = oElem2
	or	bx,bx			
	jz	Compare_Cmp_Exit	;end of chain 1 - set exit code based on
					; whether both chains end
	or	ax,ax			;end of chain 2?
	jz	Compare_Cmp_Exit	;brif end of chain 2  - reset PSW.Z,exit
					;not end of either chain - - continue

	add	bx,si			;bx = pElem1
	push	bx			;save across recursive call
	mov	bx,[bx.ELEM_oTyp]
	xchg	ax,bx			;ax = oTyp of element 1, bx = oElem2
	add	bx,di			;bx = pElem2
	push	bx			;save across recursive call
	mov	bx,PTRVAR[bx.ELEM_oTyp]	; bx = oTyp of element2
	mov	cx,sp
	sub	cx,6			;CompareTypsRecurse requires 6 bytes
					; of stack space per invocation
	cmp	cx,[b$pend]
	ja	Compare_Cont		;brif sufficient stack space to recurse

	mov	cx,ER_OM		;abnormal termination - not enough stack
	mov	[b$ErrInfo],OMErr_STK;note this is really Out of Stack space
	pop	ax			; clean stack
	pop	ax			; clean stack
	or	sp,sp			;reset PSW.Z to indicate failure
	jmp	short CompareTypsRec_Exit1
Compare_Cont:
	call	CompareTypsRecurse	;compare these types
	pop	bx			;pElem2Old
	pop	ax			;pElem1Old
	jnz	CompareTypsRec_Exit	;if any element match fails, whole
					; process terminates
	jcxz	Compare_Cont_1

	;ET_FS or ET_FT - - - oTyp's compare, but must also check string
	;lengths - - -
	xchg	ax,bx			
	mov	cx,[bx.ELEM_cbFixed]	; cx = size of element1
	xchg	ax,bx			
	cmp	cx,PTRVAR[bx.ELEM_cbFixed] 
	jnz	CompareTypsRec_Exit	; if lengths are different, no match
Compare_Cont_1:
	mov	bx,PTRVAR[bx.ELEM_oElementNext]	; fetch new oElem2
	xchg	ax,bx			;ax = oElem2, bx = pElem1Old
	mov	bx,[bx.ELEM_oElementNext]
	jmp	short Elem_Compare_Loop	;continue until end of both chains
					; found, or an element pair is found
					; that doesn't match
Compare_Cmp_Exit:
	cmp	ax,ET_FS		; special comparison required?
	jnz	CompareTypsRec_Cmp	; brif no special compare step
	;ax is either ET_FS or ET_FT	
	cmp	ax,bx			; set condition codes for retval
	mov	cx,sp			; caller must check string lengths
	jmp	short CompareTypsRec_Exit1 
CompareTypsRec_Cmp:			
	cmp	ax,bx			;sets condition codes for retval
CompareTypsRec_Exit:
	mov	cx,0			;routine terminated normally
CompareTypsRec_Exit1:
cEnd	CompareTypsRecurse

;***
;CompareTyps - compare 2 types to see if they're the same
;
;Purpose:
;	Given two oTyps, compare them (recursively element-by-element)
;	to see if they're the same. The given oTyp's do not have to be
;	for user-defined types - - - any valid oTyp's are okay.
;
;	This routine does the start-up work, and uses
;	CompareTypsRecurse to do the actual comparison.
;
;	Interface modified as revision [15].
;
;Entry:
;  ax = oRs1  - oRs of first type
;  bx = oRs2  - oRs of first type
;  cx = oTyp1 - first type
;  dx = oTyp2 - first type
;
;  parm1 = oRs1 = oRs of 1st type
;  parm2 = oRs2 = oRs of 2nd type
;  parm3 = oTyp1 = oTyp of 1st type
;  parm4 = oTyp2 = oTyp of 2nd type
;Exit:
;  PSW.Z set if the two types match, reset if not.
;  If PSW.Z reset, CX = 0 if routine succeeded, ER_OM if insufficient
;	stack space for required recursion.
;
;  AX = 0 if two types match
;  If AX != 0, DX = 0 if routine succeeded, ER_OM if insufficient
;	stack space for required recursion.
;Preserves:
;  ES - scanner depends on this (in non-windows versions)
;Exceptions:
;  none.
;
;******************************************************************************
cProc	CompareTyps,<PUBLIC,FAR,NODATA>,<SI,DI,ES>	
	parmW	oRs1			
	parmW	oRs2			
	parmW	oTyp1			
	parmW	oTyp2			
cBegin	CompareTyps
assumes ds,DATA 			
	mov	ax,[oRs1]		; parm to OMrsORs
	call	OMrsORs 		;get oMrs of type1
	mov	si,[oRs2]		
	xchg	si,ax			;si = oMrs1, ax = oRs2
	call	OMrsORs			;get oMrs of type2
	xchg	ax,di			;di = oMrs2, ax = garbage
	mov	cx,[oTyp1]		
	mov	dx,[oTyp2]		
	cmp	si,di			;oTyp's in different modules?
	jnz	Diff_Module		; brif so

	cmp	cx,dx			;return PSW.Z set appropriately
	mov	cx,0			;CompareTyps terminated normally
	jmp	short CompareTyps_Exit
Diff_Module:
	push	[grs.GRS_oRsCur]
	push	cx			;preserve oTyp's across call
	push	dx
	call	MrsDeActivate		;so both mrs's are in mrs table
	RS_BASE add,si			; si = pMrs1
	RS_BASE add,di			; di = pMrs2
	GETRS_SEG es,bx,<SIZE,LOAD>	;[5] es == Rs table seg, trashes bx
	mov	si,PTRRS[si.MRS_bdVar.BD_pb] ;[2] si = base pointer to type table 1
	mov	di,PTRRS[di.MRS_bdVar.BD_pb] ;[2] di = base pointer to type table 2
	pop	bx			;bx = oTyp2
	pop	ax			;ax = oTyp1
	call	CompareTypsRecurse
	pop	ax			;oRsCur on entry
	pushf				;save retval flags
	cCall	RsActivateCP,<ax>	;restore oRsCur to entry value
	popf
CompareTyps_Exit:
	mov	dx,cx			; per new interface
	mov	ax,sp			; non-zero
	jnz	CompareTyps_Exit_1	; brif types don't match

	sub	ax,ax			
CompareTyps_Exit_1:			
cEnd	CompareTyps

;***
;ONamOElem, ONamOTyp - Return the oNam for the name of a given element or type
;Purpose: 
;  Used for descanning. Given an offset into mrsCur.bdVar to an element or type
;  entry, returns the oNam for the name of the element.
;
;Entry:
;  oElem or oTyp - offset into mrsCur.bdVar for the desired element or type
;
;Exit:
;  return value is an offset into the module name table for the name of the
;	element or type.
;
;Exceptions:
;  none.
;
;Preserves:
;  All but AX and BX (for callers in CP. Callers from outside CP cannot
;  assume this).
;
;******************************************************************************
PUBLIC	ONamOTyp
ONamOTyp PROC FAR
	.errnz	TYP_oNam - ELEM_oNam
	;fall into ONamOElem, taking advantage of the fact that the oNam
	;  field is in the same position in the ELEM and TYP structures.
ONamOTyp ENDP
cProc	ONamOElem,<PUBLIC,FAR,NODATA>
	parmW	oStruc			
cBegin	ONamOElem
	mov	bx,[oStruc]		
	add	bx,[mrsCur.MRS_bdVar.BD_pb]
	mov	ax,[bx.ELEM_oNam]
cEnd	ONamOElem

;===============================================================================

;***
;ForEachPrimElem - recursively walk each primitive element in a TYPE
;
;Purpose:
;  Recursively visit each primitive element in a TYPE. By "primitive element"
;  we mean an element that is not itself of some user-defined type.
;  For each primitive element, call the near routine pointed to by SI.
;  In the special case where SI == 0, just increment CX instead, i.e., this
;  routine then simply counts all primitive elements.
;
;Entry:
;  an oTyp in ax.
;  SI == 0 to count, or is a near pointer to a helper routine.
;
;Exit:
;  if SI == 0, cx = count of primitive elements on exit,
;  otherwise cx is not touched, and can be used as a return value by the
;	helper routine.
;  Does not use dx - - - caller & helper routine can also use dx as desired.
;
;Exceptions:
;  In non-RELEASE case, DebHalt may be called if input not a valid 
;     user-defined oTyp.
;
;******************************************************************************
DbPub	ForEachPrimElem 		
cProc	ForEachPrimElem,<NEAR,NODATA>,<DI>
cBegin
	DbChk	oTyp,ax
	mov	bx,[mrsCur.MRS_bdVar.BD_pb] 
	mov	di,ax
	mov	di,PTRVAR[di.TYP_oElementFirst][bx]	
	and	di,07FFFH		;mask off fReferenced bit
	add	di,bx			;di = pElem
	add	ax,bx
	cmp	ax,di
	jz	ForEachPrimElem_Exit

ForEachPrimElem_Loop_Start:
	lea	ax,[bx+0]		
	cmp	ax,di
	jz	ForEachPrimElem_Exit	;brif end of chain

	mov	ax,PTRVAR[di.ELEM_oTyp] 
	cmp	ax,ET_MAX
	ja	@F			; brif user-defined type

	or	si,si			; special case?
	jnz	CallHelper		; brif not - - call helper

	inc	cx			; increment count of prim elements
	jmp	short ForEachPrimElem_Continue 
CallHelper:				
	;ax == oTyp of primitive element
	;if SizeD, es == segment of type table
	;di == pElem for primitive element
	call	si			; call helper for this prim element
	jmp	short ForEachPrimElem_Continue 
@@:					
	call	ForEachPrimElem 	; recurse to handle elements in
					;	this user-defined type
ForEachPrimElem_Continue:		
	mov	di,PTRVAR[di.ELEM_oElementNext]
	add	di,bx			;add table base to get next element
	jmp	short ForEachPrimElem_Loop_Start
ForEachPrimElem_Exit:
cEnd


;***
;CPrimElemFar(oTyp) - return the number of primitive elements in a type
;
;Purpose:
;  Recursively count the total number of primitive elements owned by a 
;  given user-defined type. 
;
;Entry:
;  an oTyp.
;
;Exit:
;  a count of the number of actual elements (i.e., of type ET_I2, ET_I4,
;     ET_R4, ET_R8, fixed-length string, etc) in the type.
;
;Exceptions:
;  In non-RELEASE case, DebHalt may be called if input not a valid 
;     user-defined oTyp.
;
;******************************************************************************
cProc	CPrimElemFar,<PUBLIC,FAR,NODATA>,<SI>
	parmW	oTyp
cBegin	CPrimElemFar
	mov	ax,[oTyp]
	sub	si,si			; just inc cx for each prim element
	sub	cx,cx			; initialize count
	call	ForEachPrimElem 	; cx == count of primitive elemtns
	xchg	ax,cx			; ax == retval
cEnd	CPrimElemFar

;===============================================================================


sEnd	CP


;===============================================================================


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\uiutil.asm ===
TITLE UiUtil.asm - Misc User Interface Functions

COMMENT	\

--------- --- ---- -- ---------- ----
COPYRIGHT (C) 1986 BY MICROSOFT, INC.
--------- --- ---- -- ---------- ----

\

;============================================================================
; Module: UiUtil.asm - Misc User Interface Functions
; System: Quick BASIC Interpreter
;============================================================================

	.xlist
	include		version.inc
	UIUTIL_ASM = ON	
	includeOnce	lister
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	ui
	.list

assumes	DS,DATA
assumes	SS,DATA
assumes	ES,NOTHING

	externFP B$IValidatePath		
	externFP SetUiErrFar			


;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------
sBegin	DATA

	EXTRN	uierr:word

	externB iHelpId 			

PUBLIC	cbStdMsg				
cbStdMsg	dw	?			; length of message
PUBLIC	bufStdMsg
bufStdMsg	db	CB_bufStdMsg dup(?)	;big enough for biggest msg

TEMPORARY_PADDING   db	(6+16) dup(?)
MORE_PADDING        db  (70)   dup(?)
; [QH1] - To make room for long MS-DOS 6.0 online-help index strings


; We are calling HelpGetLineAttr to get an array of help line attributes
; into bufStdMsg.  We need this padding for Beta Release for 2 reasons:
;
; 1.  Bug in HelpGetLine Attr that causes it to trash 6 bytes past the
;	 end of the array without first checking if there is room.
; 2.  Even if bug #1 was fixed, we still need the room!
;
; The 6 bytes SHOULD keep us from trashing DGROUP (a BDL in release QB!)
; The 16 bytes is extra padding.



sEnd	DATA

;-------------------------------------------------------------------------
;	Ascii Message Utility Functions (for internationalization)
;	Since B$ExecQBC throws away all of QBI except for segment LOADRTM,
;	and it needs to output prompts, we need to keep messages and
;	the code which accesses them in segment LOADRTM.
;-------------------------------------------------------------------------

sBegin	LOADRTM
assumes	cs,LOADRTM

externW tpMsgStd
externB TransTab
externB HuffTab


;*********************************************************************
; ushort NEAR ListStdMsg(iMsg), ListStdMsgRtmNear(), FAR ListStdMsgFar(iMsg)
;
; Purpose:
;	List a standard ASCII message to the global static buffer bufStdMsg.
;	ListStdMsgRtmNear is used by the runtime loader.
;
; Entry:
;	iMsg is standard error index from qbimsgs.h (ER_xxx or MSG_xxx)
;	AX is standard error index for ListStdMsgRtmNear
;
; Exit:
;	bufStdMsg contains a zero terminated string.
;	  note that bufStdMsg is guarenteed to be large enough to
;	  hold the largest message's text.
;	cbStdMsg contains the byte count of the string.
;	as function result, it returns the byte count of the string.
;
;*********************************************************************
cProc	ListStdMsgFar <PUBLIC,FAR,NODATA>
	parmW	iMsg
cBegin	ListStdMsg
	mov	ax,iMsg
	call	ListStdMsgRtmNear	;call common code to list message
cEnd					;message in bufStdMsg, length in AX

cProc	ListStdMsgRtmNear <PUBLIC,NEAR,NODATA>,<si,di>
cBegin
	xchg	ax,si			;si = iMsg
	dec	si			;si = iMsg - 1
	DbAssertRel si,b,IMSG_MAX,LOADRTM,<invalid iMsg in ListStdMsg>
	DbAssertRel CB_MSG_MAX+1,be,CB_bufStdMsg,LOADRTM,<CB_bufStdMsg too small>
	shl	si,1			;si = offset into msg table
	push	ds			;set es pointing to DGROUP
	pop	es
	push	cs			;set ds pointing to LOADRTM segment
	pop	ds
assumes	ds,LOADRTM
assumes	es,DGROUP
	mov	si,tpMsgStd[si]		;si = ptr to standard msg
	or	si,si
	jne	NotZero
	mov	si,[tpMsgStd - 2 + ER_UE * 2] ;si = "Unprintable error"
	mov	iHelpId,ER_UE		; tell help we changed messages
NotZero:
	mov	di,dataOFFSET bufStdMsg
	cCall	dcd,<si,di>		;decode string, returns with size
	push	es			;restore ds pointing to DGROUP
	pop	ds
assumes	DS,DATA
assumes	es,NOTHING
	add	di,ax			;point to end of string
	mov	byte ptr [di],0		;zero terminate string in bufStdMsg
cEnd	ListStdMsgFar


;*******************************************************************
; ushort dcd (pbSrc, pbDst)
; char *pbSrc, *pbDst
;
; Purpose:
;	to decode a bit stream into a string of characters.
;	The bit stream should start off with the number of
;	encoded characters in the bit stream in the first byte.
;
; Algorith:
;	The code should implement the following C code
;
;int dcd (pbSrc, pbDst)
;char *pbSrc, *pbDst
;{
;    char *pn
;    int bc = 0, n, size
;
;    for (size = n = (unsigned char) *pbSrc++; n; n--) {
;	 pn = HuffTab
;	 while (1) {
;	     pn = pn + getbit (pbSrc, bc++)
;	     if (*pn & (1 << 7)) {
;		 *pbDst++ = TransTab[(unsigned char) *pn & ~(1 << 7)]
;		 break
;	     }
;	     pn = HuffTab + (*pn << 1)
;	 }
;    }
;    return (size)
;}
;
;int getbit (b, n)
;char *b
;int n
;{
;    if (b[n/8] & ((1<<7) >> (n%8))) return (1)
;    return (0)
;}
;
;
; Entry:
;	NOTE: DS points to segment LOADRTM, ES points to DGROUP
;	pbSrc is a pointer to the input bit buffer, and pbDst is
;	a pointer to the output string.
;	It expects HuffTab, and TransTab to be defined properly
;	by qbimsgs.asm.
;
; Exit: Returns the number of characters translated in ax.
;
;*******************************************************************

assumes	ds,LOADRTM
assumes	es,DGROUP
cProc	dcd,<NEAR,PUBLIC>,<si,di>
	parmW	<pbSrc,pbDst>
	localW	<n>

cBegin
	mov	di,[pbDst]	;get pointer to output buffer
	mov	si,[pbSrc]	;get pointer to input buffer
	lodsb		 	;get count to al
	DbAssertRelB al,b,80h,LOADRTM,<dcd: count exceeds 127>
	cbw			;clear high byte of ax
	cwd			;initialize bit counter (dx) to 0
	push	ax		;save count for return value

	mov	[n],ax		;and set n to count
	inc	[pbSrc]		;inc input buffer pointer to start of bits

loopChar:			;loop through the characters
	dec	[n]		;Decrement counter
	jl	doneDcd 	;If less than zero, exit.
	mov	si,offset HuffTab;put table pointer into si

loopTab:			;Start of loop through table
	mov	ax,dx		;prepare to divide bc
	mov	bl,8		;by 8
	div	bl		;al = bc/8, ah = bc%8
	inc	dx		;increment bit counter

	mov	ch,10000000b	;prepare to shr (1<<7)
	mov	cl,ah		;by bc%8
	shr	ch,cl		;ch = (1<<7) >> (bc%8)

	DbAssertRelB al,b,80h,LOADRTM,<dcd: count larger than 127>
	cbw			;ax = al = quotient
	xchg	bx,ax		;bx = quotient (i.e. bc/8)

	add	bx,[pbSrc]
	test	[bx],ch		;see if bit ch is on in pbSrc[bc/8]
	jz	dontInc		;if not, don't increment table pointer
	inc	si		;increment table pointer
dontInc:
	sub	bh,bh
	mov	bl,[si] 	;move table entry to bl
	rcl	bl,1		;rotate left to see if high bit is set
	jnc	continue	;if not, continue looking through table
	shr	bl,1		;otherwise, shift back, losing high bit
	mov	al,TransTab[bx] ;translate character through table.
	stosb			;move byte to output buffer
	jmp	SHORT loopChar	;and do another character.

continue:			;continue looking through table
	mov	si,offset HuffTab;re-initialize si to start of table
	add	si,bx		;add already *2 entry to the base of table
	jmp	SHORT loopTab 	;so loop through table again.

doneDcd:			;We are done.
	pop	ax		;return character count.
cEnd


assumes	ds,DGROUP
assumes	es,NOTHING

sEnd	LOADRTM

sBegin	UI
assumes	cs,UI

cProc	ListStdMsg <PUBLIC,NEAR,NODATA>
	parmW	iMsg
cBegin	ListStdMsgFar
	push	iMsg
	call	ListStdMsgFar
cEnd	ListStdMsg

;*********************************************************************
; char *SzGetIth( char *pbStrings, ushort iString )
;
; Purpose:
;   Return pointer to i'th string in a buffer of null terminated strings
;
; Entry:
;    pbStrings - pointer to array of characters containing the null terminated
;                strings.
;    iString - Which string to return.
;
; Exit:
;   return pointer.
;
;*********************************************************************
cProc SzGetIth,<NEAR,PUBLIC>,<DI>
	parmW	pbStrings		
	parmW	iString
cBegin
	push	ds
	pop	es
	mov	di, [pbStrings]
	mov	dx, [iString]
	inc	dx
	xor	ax,ax
	jmp	short PbSzI_LoopEnd

PbSzI_LoopStart:
	mov	cx, 0ffffH
	repnz scasb

PbSzI_LoopEnd:
	dec	dx
	jnz	PbSzI_LoopStart

	mov	ax, di
cEnd

sEnd	UI

sBegin	CP
assumes	CS,CP

;*********************************************************************
; LongToStdMsg
; Purpose:
;	Fill 'bufStdMsg' with a 0-terminated ASCII equivalent of a
;	long positive integer parameter.
;
;*********************************************************************
cProc	LongToStdMsg,<PUBLIC,FAR>,<di>
	parmD	val
cBegin
	lea	bx,val			;bx points to binary number (in DS)
	mov	al,VT_I4		;al = value type (long)
	sub	ah,ah			;no explicit terminating char
	mov	di,DATAOFFSET bufStdMsg	;di points to destination buffer (in DS)
	call	ListNum
cEnd

;*********************************************************************
; HexToStdMsg
; Purpose:
;	Fill 'bufStdMsg' with a 0-terminated ASCII equivalent of
;	an unsigned short parameter.
;	Used to display Compiled-Code-Runtime-Error-Adr
;
;*********************************************************************
cProc	HexToStdMsg,<PUBLIC,FAR>,<di>
	parmW	val
cBegin
	sub	dx,dx			;dx = high word = 0
	mov	ax,[val]		;ax = low word
	mov	di,DATAOFFSET bufStdMsg	;di points to destination buffer (in DS)
	mov	bh,'H'			;convert number to Hexadecimal
	call	ListBaseNum
cEnd

;***
;  WriteFileErr(fhandle, offBuf, cb)
;
;  Write cb bytes to file fhandle, trapping Int24 errors
;
;  Inputs:
;     fhandle	- file handle to write to.
;     offBuf	- address of buffer.
;     cb	- length of buffer.
;
;  Outputs:	AX == 0 if no error, else, non-zero standard error code
;
;****
cProc WriteFileErr,<PUBLIC,FAR>
	ParmW	fhandle
	ParmW	offBuf
	ParmW	cb
cBegin
	mov	ax,CPOFFSET WfExit	;if any runtime errors occur,
	call	RtSetTrap		; branch to WfExit with sp,di =
					; current values.
					; RtFreeTrap called if error occurs
	mov	bx,[fhandle]
	mov	cx,[cb]
	mov	dx,[offBuf]
	mov	ah,40H
	int	21h
	mov	ax,0			;prepare to return "No error"
	jnc	FreeTrap		; brif no error
	mov	ax,ER_IOE		;Return error condition.
FreeTrap:				
	call	RtFreeTrap		;preserves AX
WfExit:					
cEnd

;***************************************************************************
; NormFileNameFar
;	Moved with revision [8].
;
;Purpose:
;	Normalizes the path of a filename and appends an extension if there
;	previously was no extension.  Uses runtime routine B$IValidatePath
;	to generate the fully-qualified pathname from a filename.
;
;	See NormFileName (in \QB\IR\TXTLOAD.ASM) for more information.
;
;Entry:
;	pSource = near pointer to source string
;	cbSource = # bytes in source filespec
;	pDest = near pointer to destination buffer (length = FILNAML)
;	pExt = near pointer to extension to add
;
;Exit:
;	Upper case, fully-specified pathname filled in.
;	ax = length of pathname (NOT including null), or UNDEFINED if error
;
;******************************************************************************
cProc	NormFileNameFar,<PUBLIC,FAR>
parmW	pSource
parmW	cbSource
parmW	pDest
parmW	pExt
cBegin

	call	RtPushHandler		;save caller's runtime error handler
					; (NOTE: alters stack pointer)
					; (preserves ax,bx, dx)
	mov	ax,CPOFFSET NfnfExit	;if any runtime errors occur,
	call	RtSetTrap		; branch to NfnfExit with sp,di =
					; current values  (preserves bx,cx, dx)
	push	pSource			;parm1 = near pointer to filename
	push	cbSource		;parm2 = filename length
	push	pDest			;parm3 = near pointer to destination
	push	pExt			;parm4 = near pointer to extension
	call	B$IValidatePath		;ax = length of resulting filename
					;     NOT including 0 byte
	jmp	short NoRTError		;return ax = length
;ax = error code
NfnfExit:		
	cCall	SetUiErrFar		;notify UI that error AX occurred
	mov	ax,UNDEFINED		;ax = UNDEFINED ==> error
NoRTError:

	call	RtPopHandler		;restore caller's runtime error handler
					; (saved on stack by RtPushHandler)
					; (preserves ax)
cEnd


sEnd	CP



end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hd\edit.inc ===
;***	EDIT.INC - Structures and constants for the Document Text Manager
;
; DESCRIPTION
;	Constants, structures and function prototypes required to deal
;	with the TEXTMGR.
;
;	NOTE: any changes should also be made to EDIT.H
;
;****


	includeOnce	context

MRS_pDocumentBuf EQU MRS_oPastLastVar


extrn	AppendLineBuf:far
extrn	NewBuf:far
extrn	FreeBuf:far
extrn	S_LinesInBuf:far
extrn	S_CbGetLineBuf:far


sBegin	UI
extrn	CbFindLine:near
extrn	BigMoveUp:near
extrn	BigMoveDown:near
extrn	LinearAddr:near
extrn	SegAddr:near

extrn	S_ReplaceLineBuf:near
extrn	S_InsertLineBuf:near
extrn	S_InsertBufInBuf:near
extrn	S_DeleteLinesBuf:near
sEnd	UI
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\vardebug.c ===
/***
*vardebug.c - non-release code to validate varmgr.c
*
*  Copyright <C> 1986, Microsoft Corporation
*
*Purpose:
*  contains routines used for debugging the variable manager.
*
*******************************************************************************/

static	char tmpNameAry[60];  /* array to temporarily hold name of variables  */
static	cTotEntries;	      /* count of entries in a hash table	      */
static	cMaxChain;	      /* count of entries in longest hash chain       */
unsigned short fOutAll = 0;   /* if FALSE, don't print all info when dumping
                                 tables; used for internal testing            */
char fSkipDrive = 0;	      /* if non-zero, bash the drive letter when
				 printing a filename so test suites can be run
				 from any drive.			 */

static unsigned short recurseLevel = 0;
			      /* used for recursing in record variables      */

#pragma data_seg(C_STRINGS)

#include "version.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\util.asm ===
TITLE	util.asm - general purpose utilities (not provided by runtime)
;***
;util.asm - general purpose utilities for the interpreter
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Any general purpose (i.e., code that is deemed to be not tied to
;	any single function area) utility routine in the interpreter
;	will be placed here. In some cases, speed-critical routines may
;	be present which duplicate runtime code, but for which we don't
;	want to pay the size and speed penalty of a long call, and/or we 
;	don't want to pay for the C calling convention.
;
;
;****************************************************************************

	.xlist
	UTIL_ASM = 1		;We need to do this before including version.inc
				;since version.inc ultimately includes
				;debug.inc, which depends on UTIL_ASM
	include version.inc
	includeOnce	heap
	includeOnce	context
	.list

sBegin	DATA


sEnd	DATA

sBegin	RT
	EXTRN	B$SCAT:FAR
	EXTRN	B$FLEN:FAR
	EXTRN	B$END:FAR
sEnd	RT

;	.sall

assumes CS,CP
assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	page

sBegin	CP

	subttl	Zero fill routine.
	page

;***
;ZeroFill(pDst, cbFill) - Zero fills a block of size cbFill, starting at pDst
;
;Entry:	two values on the stack (C calling convention):
;		- a pointer to the string.
;		- the number of bytes to fill.
;	NOTE: This routine shares code with FillUndef; the interface to these
;		two routines must match, as they share a common exit.
;
;Exit:	
;	On exit, [ax] == 0
;Uses:
;	none.
;****
cProc	ZeroFill,<PUBLIC,FAR>,<DI>
	parmW	pDst		
	parmW	cbFill
cBegin
	xor	ax,ax
	mov	cx,cbFill
FillBytes:			;start of shared code with FillUndef (below)
	jcxz	ZeroEnd

	push	ds		;require ES = DS for rep movs
	pop	es
	cld
	mov	di,pDst

	shr	cx,1		;convert to a word count
	repz	stosw
	jnc	ZeroEnd		;no carry if byte count was even

	stosb			;move the last (odd) byte
	DbChk	Heaps		;check in case we hosed the heap
ZeroEnd:
cEnd
	
	subttl	Routine to fill a block of words with UNDEFINED
	page

;***
;FillUndef(pDst, cwFill) - fills cwFill words w/UNDEFINED, starting at pDst
;
;Entry:	two values on the stack (C calling convention):
;		- a pointer to the start of the block to fill.
;		- the number of words to fill.
;	NOTE: This routine shares code with ZeroFill; the interface to these
;		two routines must match, as they share a common exit.
;
;Exit:	
;	On exit, [ax] == UNDEFINED
;Uses:
;	none.
;****
cProc	FillUndef,<PUBLIC,FAR>,<DI>
	parmW	pDst		
	parmW	cwFill

cBegin
	mov	cx,cwFill
	shl	cx,1		;convert word count to byte count for fill
	mov	ax,UNDEFINED	;NOTE: assuming here that low byte and high
				;	byte of UNDEFINED are the same
	jmp	short FillBytes	;share code with ZeroFill, above
cEnd	nogen

;***
;VOID CopyBlk(pbSrc, pbDst, cb) - do a simple block copy within DGROUP
;
;Purpose:
;	Copy a block of bytes.  This function should not be used
;	if the source block intersects with the destination block,
;	and begins at a lower address than the destination block,
;	otherwise, it will overwrite part of the destination before
;	it gets to it.  Use function CopyBlkHighLow (as yet unwritten)
;	for this case.
;Entry:
;	3 values on the stack (C calling convention):
;	- a pointer to the lowest addressed source byte,
;	- a pointer to the lowest addressed destination byte,
;	- the number of bytes to copy.
;Exit:
;	none
;
;****
cProc	CopyBlk,<PUBLIC,FAR>,<si,di>
	parmW pbSrc
	parmW pbDst
	parmW cb
cBegin
	mov	si,pbSrc		;si = source offset
	mov	di,pbDst		;di = destination offset
	mov	cx,cb
	push	ds			;movsb requires es = ds
	pop	es
	rep movsb			;copy block
	DbChk	Heaps			;check in case we hosed the heap
cEnd


;********************************************************************
; short CmpPsdIns(psd1, psd2, cbMax)
; Purpose:
;	Perform a CASE insensitive comparison of two strings
;
; Entry:
;	parm1: ax = psd1 - points to 1st string descriptor
;	parm2: bx = psd2 - points to 2nd string descriptor
;	parm3: dx = cbMax cmp - max. number of chars to use in comparison
;
; Exit:
;	If strings are the same, returns ax=0
;	If psd1 <> psd2, return ax not 0
;	(it is much faster for this function to not differentiate
;	 between psd1 < psd2 or psd1 > psd2, and callers just care
;	 about equality AND SPEED)
;	Also sets PSW flags via or ax,ax just prior to exit.
;
;********************************************************************
cProc	CmpPsdIns,<PUBLIC,NEAR>,<si>
cBegin
	xchg	ax,si			;si -> sd 1
	lodsw				;ax = byte count for string 1
	mov	cx,ax			;cx = byte count for string 1
	cmp	dx,cx
	jae	Got_Cb1			;brif count is <= max cout to be used

	mov	cx,dx
Got_Cb1:
	lodsw				;ax -> string 1
	mov	si,bx			;si -> sd 2
	mov	bx,ax			;bx -> string 1

	lodsw				;ax = byte count for string 2
	cmp	dx,ax
	jae	Got_Cb2
	xchg	ax,dx
Got_Cb2:
	cmp	ax,cx
	mov	ax,UNDEFINED		;prepare for Not-Equal return
	jne	CmpPsdExit		;brif strings are of different lengths
	lodsw				;ax -> string 2
	xchg	ax,si			;si -> string 2

	;At this point,
	;   bx points to 1st byte of string 1,
	;   si points to 1st byte of string 2
	;   cx = # bytes to compare
	
	call	CmpStrIns		;compare strings, ax=0 if equal
CmpPsdExit:				;return ax
	or	ax,ax			;set flags
cEnd

;********************************************************************
; CmpStrIns
; Purpose:
;	Compare 2 strings, ignoreing case sensitivity
;
; Entry:
;	bx points to 1st byte of string 1,
;	si points to 1st byte of string 2
;	cx = # bytes to compare
;
; Exit:
;	If strings are the same, returns ax=0
;	If string1 < string2, return ax=FFFFh
;	if string1 > string2, return ax=0001h
;	Also sets PSW flags via or ax,ax just prior to exit.
;
;********************************************************************
cProc	CmpStrIns,<PUBLIC,NEAR>,<si>
cBegin
	mov	dx,0DFDFH		; mask for converting lower->upper
CmpLoop:
	lodsb				;al = next byte from string 2
	mov	ah,[bx]			;ah = next byte from string 1
	inc	bx
	and	ax,dx			;force al and ah to upper case
	cmp	al,ah
	loope	CmpLoop			;branch if equal so far, and cx<>0
	mov	ax,1
	jb	CmpStrExit		;branch if string1 > string2
	je	CmpStrEqual		;branch if string1 = string2
	dec	ax			;else string1 < string2
CmpStrEqual:
	dec	ax
CmpStrExit:
	or	ax,ax			;set PSW flags for callers
cEnd

;*********************************************************************
; MapCpW, MapEsW
; Purpose:
;	Map a value from one table to another.
;	If value not found in search table, word beyond end of
;	map table is returned.
; Entry:
;	ax = value to search for
;	cx = number of values in search table
;	dx = ptr to table of values to search for
;	bx = ptr to cooresponding table of map (result) values
; Exit:
;	ax = value from map table
;
; MapCpW Alters ES
;
;*********************************************************************
PUBLIC	MapCpW
MapCpW	PROC NEAR			;maps using CP segment
	push	cs
	pop	es			;es = code segment
MapCpW	ENDP
	;fall into MapEsW
PUBLIC	MapEsW
MapEsW	PROC NEAR
	push	di			;save caller's di
	push	cx			;save number of bytes in table
	mov	di,dx			;di -> 1st word in table to search
	repne scasw			;search for value in table pointed
					; to by di (uses es)
	pop	ax			;ax = number of bytes in table
	sub	ax,cx			;ax = offset into table
	add	bx,ax			;bx = pointer to result value
	mov	ax,es:[bx]
	pop	di			;restore caller's di
	ret
MapEsW	ENDP

;*************************************************************************
; ushort CbSz(sz)
;
; Purpose:
;	Return the number of bytes in a 0-byte terminated string.
;	Does not include terminator in count.
;
; Entry:
;	parm1: char *sz - ptr to source string
;	  
; Exit:
;	[AX] = byte count
;
;*************************************************************************
cProc	CbSz,<PUBLIC,FAR>,<di>
	parmW   sz			
cBegin
	push	ds
	pop	es			;es = DGROUP
	mov	di,sz			;di points to start of string
	mov	cx,0FFFFH		;ax = max byte count
	sub	ax,ax			;al = byte to search for
	repne	scasb			;while cx != 0 and es:[di] != al, di++
	sub	ax,cx
	dec	ax
	dec	ax			;ax = length of string (0..n)
cEnd

;*************************************************************
;RelTempSd_CP
;Purpose:
;	release temp string descriptor
;Entry:
;	stack parm points to temp string descriptor to be released
;
;*************************************************************
PUBLIC	RelTempSd_CP
RelTempSd_CP PROC NEAR
	pop	bx			;bx = return adr
	pop	ax			;ax = parm
	push	bx			;push back return adr
	push	ax			;pass ptr to string desc
	call	B$FLEN			;release temp descriptor
					; (side effect of LEN function)
	ret
RelTempSd_CP ENDP

	
sEnd	CP


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hd\edit.h ===
/***	EDIT.H - Structures and constants for the Document Text Manager
*
* GLOBAL
*	None
*
* LOCAL
*	None
*
* DESCRIPTION
*	Constants, structures and function prototypes required to deal
*	with the TXTMGR and EDITMGR at a low level.
*
*	NOTE: any changes should also be made to EDIT.INC
*
*/

#if	!HEAP_H
#include <heap.h>
#endif

#define LOCAL	static
#define GLOBAL


#define pDocumentBuf oPastLastVar

/*--------------------------- Debug Macros ------------------------*/

#define DbHeapMoveOn()
#define DbHeapMoveOff()
#define DbChkPBufInfo(pbufinfo)


/*--------------------------- Constants ---------------------------*/

/* Incremental buffer size for allocation.
*/

#define CBSRCBLK			512

/* Number of document buffers available to the system
*/

#define CBUFINFO			5

/* Maximum number of lines in a document buffer.  This is forced by
 * some edit manager strangeness at 32K-a little bit. If these were
 * fixed, we could go to 64K (minus a little bit because of CW strangeness)
*/

#define CLNMAX				32700

/*----------------------- BUFINFO Structure -----------------------*/

/* NOTE: I am using a FHD structure to inforce the fact that this */
/* NOTE: heap entry is NOT a BDL.  It is a FHD, as BDLs can not   */
/* NOTE: support a size > 64K, and FHDs can.			  */

typedef struct
{
	WORD	oData;
	WORD	hData;
	WORD	pNext;
	WORD	cPara;
} FHD;

typedef FHD *PFHD;

typedef struct
{
	FHD	fhd;		/* File descriptor of in-memory file */
	WORD	cln;		/* Number of lines in the buffer */
	DWORD	cb;		/* Buffer size */
	DWORD	obNext;		/* Offset in buffer of next available byte */
	WORD	olnCache;	/* Line number of last line looked at */
	DWORD	obCache;	/* Offset in buffer of last line looked at */
} BUFINFO;

typedef BUFINFO *PBUFINFO;


/*----------------------- Exported variables -----------------------*/


/*---------------------- Function Prototypes ----------------------*/

/* TEXT.ASM
*/

extern VOID	NEAR	PASCAL	DeTab(char far *, char far *, WORD, WORD);
extern WORD	NEAR	PASCAL	ExpandTabs(char far *, char far *, WORD, WORD);
extern WORD	NEAR	PASCAL	CbFindLine(DWORD *, WORD);
extern VOID	NEAR	PASCAL	BigMoveUp(DWORD, DWORD, DWORD);
extern VOID	NEAR	PASCAL	BigMoveDown(DWORD, DWORD, DWORD);
extern DWORD	NEAR	PASCAL	LinearAddr(char far *);
extern char far *(NEAR PASCAL	SegAddr(DWORD));

extern BOOL	FAR	PASCAL	FhdAlloc(PFHD, DWORD);
extern BOOL	FAR	PASCAL	FhdRealloc(PFHD, DWORD);
extern VOID	FAR	PASCAL	FhdDealloc(PFHD);


/* TEXTMGR.C
*/

extern PBUFINFO FAR	PASCAL	NewBuf(VOID);
extern VOID	FAR	PASCAL	FreeBuf(PBUFINFO);
extern WORD	FAR	PASCAL	AppendLineBuf(PBUFINFO, char **);
extern VOID	FAR	PASCAL	CompressBufs(VOID);

extern WORD	FAR	PASCAL	S_LinesInBuf(PBUFINFO);
extern WORD	FAR	PASCAL	S_CbGetLineBuf(PBUFINFO, WORD, WORD, char *);
extern BOOL	NEAR	PASCAL	S_ReplaceLineBuf(PBUFINFO, WORD, WORD, char **);
extern BOOL	NEAR	PASCAL	S_InsertLineBuf(PBUFINFO, WORD, WORD, char **, BOOL);
extern VOID	NEAR	PASCAL	S_InsertBufInBuf(PBUFINFO, WORD, PBUFINFO);
extern VOID	NEAR	PASCAL	S_DeleteLinesBuf(PBUFINFO, WORD, WORD);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hd\variable.inc ===
;*** 
; Variable.inc - QB5-specific struct offsets and other constants for the VarMgr
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;*******************************************************************************
	IncludeOnce	varmgr		;generic QB varmgr stuff

VARIABLE_INC = ON


;==================== Common Block Table =================================

;COM Structure - common block entry
COM	STRUC
COM_ogNam	DW 0	
COM_bdType	DB SIZE BD DUP(0)
COM_bdValue	DB SIZE BD DUP(0)
COM_oTypCur	DW 0
COM_oValCur	DW 0
COM	ENDS

;These equates used only by scanner, but are here because they
;tie closely to COM defintion

SsComSize	equ	(size COM) - 2		; Don't include COM_ogNam
COM_oCom	equ	word ptr COM_oValCur+2	;Next word after end of structure
COM_cbFixed	equ	word ptr COM_oValCur+4	
SsCom		equ	COM_bdType	;Skip bdName



;COMREF Structure -	value part of a COMMON scaler variable
COMREF		STRUC
COMREF_oCommon	DW 0
COMREF_oValue	DW 0
COMREF		ENDS

;ACOM Structure -	value part of a COMMON array variable
ACOM		STRUC
ACOM_oCommon	DW 0
ACOM_cDims	DB 0
ACOM_filler1	DB 0
ACOM_oValue	DW 0
ACOM		ENDS


;This flag bit is stored in the oHashLink field
FV_STATIC	EQU 01h		;TRUE implies array is $STATIC array

FV_TYP_MASK	EQU 07H		;used to mask off oTyp bits from flags word

;entry flag bits
FVFUN		EQU 0008h
FVCOMMON	EQU 0010h
FVSTATIC	EQU 0020h
FVSHARED	EQU 0040h
FVFORMAL	EQU 0080h
FV_STATICSET	EQU 0100h	;TRUE implies $STATIC flag set
FVEVEREXPLICIT	EQU 0200h
FVARRAY		EQU 0400h
FVINDEXED	EQU 0800h
FVVALUESTORED	EQU 1000h
FVDECLDVAR	EQU 2000h
FVREDIRECT	EQU 4000h
FVCONST  	EQU 8000h


;MKVAR_flags Definitions
; Global inputs and outputs to MakeVariable.
; The below constants match existing FV constants (in varmgr.inc), and are
; present to allow parser and rude scanner changes go in without switches.

FVI_FUNCTION	EQU 0008h
FVI_COMMON	EQU 0010h
FVI_STATIC	EQU 0020h
FVI_SHARED	EQU 0040h
FVI_FORMAL	EQU 0080h
FVI_IMPLICIT	EQU 0100h
FVI_LVAL	EQU 0200h
FVI_ARRAY	EQU 0400h
FVI_INDEXED	EQU 0800h
FVI_DIM		EQU 1000h
FVI_ASCLAUSE	EQU 2000h
FVI_FNNAME	EQU 4000h
FVI_CONST	EQU 8000h

FVFUNCTION		EQU 0008h
;FVCOMMON		EQU 0010h	;Same as for VAR_flags above
;FVSTATIC		EQU 0020h	;Same as for VAR_flags above
;FVSHARED		EQU 0040h	;Same as for VAR_flags above
;FVFORMAL		EQU 0080h	;Same as for VAR_flags above
FVIMPLICIT		EQU 0100h
FVLVAL			EQU 0200h
FVFORCEARRAY		EQU 0400h
;FVINDEXED		EQU 0800h	;Same as for VAR_flags above
FVDIM			EQU 1000h
FVASCLAUSE		EQU 2000h
FVFNNAME		EQU 4000h
;FVCONST  		EQU 8000h	;Same as for VAR_flags above

sBegin	CP
	EXTRN	MakeVariable:near
	EXTRN	CreateVar:near
	EXTRN	ReDirect:near
	EXTRN	GetDefaultType:near
	EXTRN	AdjustMrsVarTable:near
	EXTRN	AdjustPrsVarTable:near
ife VARUTIL_ASM
	EXTRN	MakeVariableFar:far
	EXTRN	MakeMrsTVar:near
	EXTRN	MakePrsTVar:far
	EXTRN	MakeCommon:far
	EXTRN	ClearCommon:near
	EXTRN	ResetCommon:near
	EXTRN	VarRudeReset:near
	EXTRN	OTypOfONamDefault:far
	EXTRN	FirstVar:near
	EXTRN	NextVar:near
	EXTRN	ClearMV:near
	EXTRN	ClearPV:near
	EXTRN	CbTyp:near
	EXTRN	CbTypOTyp:near
	EXTRN	CbTypOTypOMrs:near
	EXTRN	CbTypFar:far		    
endif	;VARUTIL_ASM

sEnd	CP
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\help.inc ===
; 
;* help.h
;*
;* typedefs & definitions used in the help system and by those who use it.
;*
;* define:
;*  HOFFSET	- to define buffer pointers (PB's) as handle/offset, else
;*		  they are defined as void far *.
; 
; 
;* lineattr
;* external representation of line attributes, as returned by HelpGetLineAttr
; 
lineattr struc
    attrLA          dw  0
    cbLA            dw  0
lineattr ends
; 
;* mh
;* a memory handle is defined for use with systems that use dynamic, moveable
;* memory. It is long, so that in simple cases where memory is NOT moveable,
;* the handle can contain the far pointer to the base.
; 
; 
;* nc
;* a context number is a unique id associated with each context string.
; 
; 
;* topichdr
;* header placed (by HelpDecomp) at the begining of every decompressed topic
; 
topichdr struc
    appCharTH       db  0
    linCharTH       db  0
    ftypeTH         db  0
    lnCurTH         dw  0
    lnOffTH         dw  0
topichdr ends
; 
;* hotspot
;* defines the position of an embedded cross reference, or "hotspot". Used by
;* HelpHlNext and HelpXRef
; 
hotspot struc
    lineHS          dw  0
    colHS           dw  0
    ecolHS          dw  0
    pXrefHS         dd  0
hotspot ends
;******************************************************************************
;*
;* Some versions of the help engine run with SS!=DS, and thus require the
;* _loadds attribute on function calls.
; 
ifdef DSLOAD
else
LOADDS              equ 1
endif
;******************************************************************************
;*
;* PB
;* pointer to a buffer. Based on the switch HOFFSET, it is either a
;* handle-offset or a far pointer. In the handle/offset case, the high word
;* contains a memory handle which must be locked, to get a "real" address, to
;* which the offset is added.
; 
ifdef HOFFSET
else
endif
;******************************************************************************
;*
;* Forward declarations
; 
;******************************************************************************
;*
;* constant declarations
;*
;* Character attribute bits. These bits are order together to form attribute
;* indecies. Data in the help file has associated with it attribute information
;* encoded in length/index pairs. Each index is simply a constant which
;* indicates which of several attributes should be applied to the characters in
;* that portion of the line.
; 
A_PLAIN             equ 0
A_BOLD              equ 1
A_ITALICS           equ 2
A_UNDERLINE         equ 4
;******************************************************************************
;*
;* Help Error Codes.
;*
;* Return values greater than HELPERR_MAX are valid nc's.
; 
HELPERR_FNF         equ 1
HELPERR_READ        equ 2
HELPERR_LIMIT       equ 3
HELPERR_BADAPPEND   equ 4
HELPERR_NOTHELP     equ 5
HELPERR_BADVERS     equ 6
HELPERR_MAX         equ 10
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\kkif.h ===
/*	KKIF.H	*/

/*	GENERAL DEFINITIONS	*/

#define	FAILURE	-1
#define	SUCCESS	0
#define	THROUGH	1

/*	MS$KANJI CONSTANTS and DEFINITIONS	*/

typedef struct	{
	short	wType ;		/* Data type of wAscii			*/
	short	wScan ;		/* Key scan code			*/
	short	wAscii ;	/* Ascii code				*/
	short	wShift ;	/* Shift key status			*/
	short	wExShift ;	/* Extended Shift key status		*/
									
	short	cchResult ;	/* Length of Result string		*/
	LPSTR	lpchResult ;	/* Pointer to Result string buffer	*/
									
	short	cchMode ;	/* Length of Mode string		*/
	LPSTR	lpchMode ;	/* Pointer to Mode string buffer	*/
	LPSTR	lpattrMode ;	/* Pointer to Mode attribute buffer	*/
									
	short	cchSystem ;	/* Length of System string		*/
	LPSTR	lpchSystem ;	/* Pointer to System string buffer	*/
	LPSTR	lpattrSystem ;	/* Pointer to System attribute buffer	*/
									
	short	cchBuf ;	/* Length of Display string		*/
	LPSTR	lpchBuf ;	/* Pointer to Display string buffer	*/
	LPSTR	lpattrBuf ;	/* Pointer to Display attribute buffer	*/
	short	cchBufCursor ;	/* Cursor position in Display buffer	*/
									
	char	Reserved[34] ;	/* All elements must be set to 0	*/
} DATAPARM, FAR *LPDATAPARM ;

int	(FAR PASCAL KKOpen)  (DATAPARM far *lpKKData);
int     (FAR PASCAL KKClose) (void);
int	(FAR PASCAL KKJoin)  (DATAPARM far *lpKKData);
int	(FAR PASCAL KKFree)  (void);
int	(FAR PASCAL KKInOut) (DATAPARM far *lpKKData);
BOOL	(FAR PASCAL fKKMode) (void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uiext.h ===
/******
* Text Manager routines - Supplied by the application 
*
*******************************************************************/

void TEXT_MGR StartBigEdit(void);
void TEXT_MGR EndBigEdit(void);
ushort TEXT_MGR LinesInBuf(ushort);
bool TEXT_MGR InsertLineBuf(ushort, ushort, ushort, char *);
ushort TEXT_MGR hbufScrap(void);
void  TEXT_MGR InsertBufInBuf(ushort, ushort, ushort);
ushort TEXT_MGR cbGetLineBuf(ushort, ushort, ushort, char *);
void TEXT_MGR FreeScrap(void);
void TEXT_MGR DeleteLinesBuf(ushort, ushort, ushort);
bool TEXT_MGR ReplaceLineBuf(ushort, ushort, ushort, char *);
LineAttr *(TEXT_MGR GetLineAttrs(ushort));
bool TEXT_MGR fReadOnlyBuf(ushort);

char COW GetEditMgrState(void);
void COW SetTabs (ushort);
ushort COW GetTabs (void);
ISA COW SetInverseIsa (ISA);
WORD COW fInitColorTable (void);

/* Other Application supplied routines */
void APPL AppAlertOmf(void);
void APPL SetAbortFlag(void);
void COW  DrawToggles(void);
bool COW IsWordChar(byte);	/* Far for use in CW editmgr */
bool APPL IsLabelChar(byte);
void APPL strupr(char *);
void APPL lower(char *);
char APPL ToUpperNoAccent(char);
void APPL SwitchDiskettes(char);

char *(APPL UiStackAlloc(ushort));
void APPL UiStackFree(ushort);

ushort APPL OpenFile(char *);
ushort APPL CreateFile(char *);
bool   APPL DeleteFile(char *);
bool   APPL CloseFileNear(ushort);
ushort APPL WriteFile(ushort, char *, ushort );
ushort APPL ReadFile(ushort, char *, ushort );
void   APPL FlushFile(ushort);

char *(LIBC strcat(char *, char *));
char *(LIBC strcpy(char *, char *));
char *(LIBC strncpy(char *, char *, ushort));
char *(LIBC memset(char *, char, ushort));
char *(LIBC memmove(char *, char *, ushort));
ushort LIBC strlen(char *);
int LIBC strcmp (char *, char *);
int LIBC strcmpi (char *, char *);
char *(LIBC memchr(char *, char, ushort));
char *(LIBC memcmp(char *, char *, ushort));
int LIBC atoi (char *);
char *(LIBC itoa (int, char *, int));

short FAR PASCAL NormFileNameFar (char *, ushort, char *, char *);
extern char *b$PN_NAME;
extern char b$BAS_EXT;		// ".BAS"
extern char b$Buf1;		// buffer of length FILNAML
extern char b$Buf2;		// buffer of length FILNAML

#define	DbChkHoldBuf1() {;}
#define	DbChkHoldBuf2() {;}
#define	DbChkHoldBuf3() {;}
#define	DbChkFreeBuf1() {;}
#define	DbChkFreeBuf2() {;}
#define	DbChkFreeBuf3() {;}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hd\variable.h ===
/*** 
* Variable.h - QB5-specific type definitions and data for the Variable Manager
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*******************************************************************************/

#undef VARIABLE_H					/* it will have been defined as 0 in switch.h */
#define VARIABLE_H -1			/* to prevent duplicate #include's	*/

/* Array Descriptor definition */
typedef struct dm {
	ushort	cElements;		/* Count of elements for this dimension */
	ushort	iLbound;			/* Lower bound of this dimension */
	} dm;

typedef struct ad {
	char		far *pData;		/* Address of data */
	ushort	pNext;
	ushort	cPhysical;
	uchar		cDims;			/* Count of dimensions of the array */
	char		fFeatures;		/* For future features that impact the ad */
	ushort	oAdjusted;		/* Adjusted offset */
	ushort	cbElement;		/* Size of a single array element */
	char		tDM;				/* First byte of Dimension specific information */
	} ad;

/* fFeatures flag definitions */
#define	FADF_STATIC	0x40	/* Array is a $STATIC array */
#define	FADF_SD		0x80	/* Array is a string array */


/* Common Block entry */
/* NOTE: code exists (in context.asm) to adjust backpointers in grs.bdtPrs,
			grs.bdtMrs, or grs.bdtComBlk - - - one piece of code handles all
			three table types, and counts on the fact that the entry types
			for the latter two tables have 3 bd's, bdtPrs has a single bd, and 
			that these bd's are adjacent, and at the beginning of the entry.
			This code is also written to make a special check which assumes
			bdValue is the last bd in this structure.										*/
typedef struct com {
	ushort	ogNam;		/* [5] This is the name of the common data block.
				   [5] In the case of unnamed common, this field
				   [5] contains a 0.			      */
	bd	bdType; 	/* This is the owner field for the type block,
				   which has entries for all the values. For
				   format of this table, see ..\id\common.doc	   */
	bd	bdValue;	/* This is the owner field for the data block,
				   which holds the actual values of common
				   variables												   */
	ushort oTypCur; 	/* Current offset into type table  */
	ushort oValCur; 	/* Current offset into value table */
	} com;

/* value part of a scaler COMMON variable												*/
typedef struct comRef {
	ushort	oCommon;	/* Offset into table of COMMON blocks if fCommon 	*/
	ushort	oValue;	/* Offset into COMMON block oCommon 					*/
	} comRef;

/* value part of a COMMON array variable											*/
typedef struct aCom {
	ushort	oCommon;   // Offset into table of COMMON blocks if fCommon
	uchar	cDims;	   // Dimension count - set by varmgr at var creation
	uchar	filler1;
	ushort	oValue;    // Offset into COMMON block oCommon
	} aCom;	

#if !VARMGR_H
#include "varmgr.h"				/* include generic QB .h file			*/
#endif

#define VAR_INIT_SIZE	10	/* number of bytes to initially grow var table by 
										when creating a new entry - - - a large number
										lowers the number of vars the user can add and 
										still continue, a small number increase the
										chance that the initial request will ultimately
										be too small												*/

#define ONamOf(pVar)	*((ushort *)((char *)pVar + VAR_oNam))
#define OHashLinkOf(pVar)	*((ushort *)((char *)pVar + VAR_oHashLink))
#define FlagsOf(pVar)	*((ushort *)((char *)pVar + VAR_flags))
#define ValueOf(pVar,valType)	((val *)((char *)pVar + VAR_value))->valType

#define OTypOf(pVar) (FlagsOf(pVar) & 0x07 ? \
								FlagsOf(pVar) & 0x07 : \
								*((ushort *)((char *)pVar + VAR_oTyp)))


/* flag constants used for the flags word in the above (var) structure
	NOTE: These flags overlap with another set of flag constants defined below;
			Do not change these without changing equiv.s (of the same name) below.
																										*/
#define FV_STATIC		0x01 	 /* TRUE implies array is $STATIC array				*/

#define FV_TYP_MASK	0x07	 /* used to mask off all but oTyp bits from flags	*/

#define FVFUN			0x0008 /* FUNCTION - DEF FN or a FUNCTION						*/
#define FVCOMMON		0x0010 /* COMMON variable                          		*/
#define FVSTATIC		0x0020 /* variable used in a STATIC statement				*/
#define FVSHARED		0x0040 /* If entry in a tPV, value is an oMV, else ...	*/
#define FVFORMAL		0x0080 /* TRUE if var is a procedure formal					*/
#define FV_STATICSET	0x0100 /* TRUE implies $STATIC flag set (in oHashLink)	*/
#define FVEVEREXPLICIT 0x0200 /* TRUE if var was EVER referenced explicitly	*/
#define FVARRAY		0x0400 /* Variable is an array									*/
#define FVINDEXED		0x0800 /* TRUE if var name was followed with a '('			*/
#define FVVALUESTORED 0x1000 /* TRUE if actual value is stored in entry; if
										 FALSE, value is an oMV or an oFrame				*/
#define FVDECLDVAR	0x2000 /* TRUE if var was explicitly declared				*/
#define FVREDIRECT	0x4000 /* TRUE if there's likely an old oVar in pcode		*/
#define FVCONST		0x8000 /* TRUE if defining a CONSTant							*/

/* Global inputs and outputs to the MakeVariable routine. 
	The constants given below are used with the global mkVar.flags
	NOTE: These flags overlap with another set of flag constants defined above;
			Do not change these without changing equiv.s (of the same name) above.
																										*/
#define FVFUNCTION	0x0008 /* TRUE if in a FUNCTION definition or declare		*/
#define FVCOMMON		0x0010 /* TRUE if input is from a COMMON declaration		*/
#define FVSTATIC		0x0020 /* TRUE if input is from a STATIC statement			*/
#define FVSHARED		0x0040 /* TRUE if SHARED keyword associated with var		*/
#define FVFORMAL		0x0080 /* TRUE if a formal in a proc def. or declare		*/
#define FVIMPLICIT	0x0100 /* TRUE if user didn't explicitly type variable
												NOTE: This is NOT an input; it's set
														by MakeVariable as if it were			*/
#define FVLVAL			0x0200 /* TRUE if on left side, or in INPUT, READ stmt	*/
#define FVFORCEARRAY	0x0400 /* TRUE if input variable is DEFINITLY an array	*/
#define FVINDEXED		0x0800 /* TRUE if input could be an array or Function		*/
#define FVDIM    		0x1000 /* TRUE if input found in a DIM statement			*/
#define FVASCLAUSE	0x2000 /* TRUE if var type declared via an AS clause		*/
#define FVFNNAME		0x4000 /* TRUE if var name is of the form FNxxxx. 
												NOTE: This is NOT an input; it's set 
														by MakeVariable as if it were			*/
#define FVCONST		0x8000 /* TRUE if var entry is for a CONSTant				*/

/*  Global inputs and outputs to the MakeVariable routine.
    The below constants match existing FV constants (above), and are
    present to allow parser and rude scanner changes go in without switches.
*/

#define FVI_FUNCTION		0x0008	/* [2] */
#define FVI_COMMON		0x0010	/* [2] */
#define FVI_STATIC		0x0020	/* [2] */
#define FVI_SHARED		0x0040	/* [2] */
#define FVI_FORMAL		0x0080	/* [2] */
#define FVI_IMPLICIT		0x0100	/* [2] */
#define FVI_LVAL			0x0200	/* [2] */
#define FVI_ARRAY			0x0400	/* [2] */
#define FVI_INDEXED		0x0800	/* [2] */
#define FVI_DIM    		0x1000	/* [2] */
#define FVI_ASCLAUSE		0x2000	/* [2] */
#define FVI_FNNAME		0x4000	/* [2] */
#define FVI_CONST			0x8000	/* [2] */

/*
	oTypComMax and oValComMax are used by the scanner to trim
	a BLANK common block during a CHAIN.  They are initially
	0, and get set to the max by the scanner.  They are reset
	by ResetCommon, and the txtmgr calls SsTrimCommon to trim
	back the block at the end of SystemScan.			*/

extern	ushort	oTypComMax;	/* Max oTyp for all BLANK Common declarations */
extern	ushort	oValComMax;	/* Max oVal for all BLANK Common declarations */

ushort	FAR  MakeCommon(ushort);
VOID		NEAR ClearCommon(VOID);
VOID		NEAR ResetCommon(VOID);

/* Non-RELEASE support, used with vardebug.c */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uidec.h ===
/*** 
*uidec.h - External declarations internal to UI
*
*	Copyright <C> 1985-1988 Microsoft Corporation
*
*Purpose:
*	Provided external declarations for C files in the UI directory.
*	This file is included only by UIINT.H.
*
* NOTE: When making changes to this file, be sure to make equivalent   
*	changes to file UIINT.INC
*
*******************************************************************************/

/* external declarations */

void near CwInit (void);
void near CwReInit (void);
void near CwTerm (void);
void near CwHook (void);
void near CwUnHook (void);
void near WndInit (void);

void near RestoreUserScreen (void);
void near SaveUserScreen (void);
void near TossUserScreen (void);

void near DoCaption (WORD, AX, AY);
void near WndDeactivate(void);
void near WndActivate(PWND);
void near WndOpen(ushort);
void near WndSplit(void);
void near WndClose(void);
void near WatchInfoUI(void);
void near WndHelpOpen(WORD);	//[10]
void near WndHelpClose(void);
void near WndReset(ushort);
void near WndSaveRestoreCursors(bool);
void near WndAssign(void);
void near WndAssignList(void);
void near WndAssignNext(boolean);
void near WndGrow(void);
void near WndShrink(void);
void near WndNoFullScreen(void);
void near WndCmdCLnMin(ushort);
void near MoveCursorPwndCur(ushort, ushort);
void near MoveCursorPwnd(PWND, ushort, ushort);
void near MoveTxdCursor(void);
void near ViewPrev(void);
void near ViewNext(void);
void near ViewFull(void);
void near ViewProcedure(void);
void near CmdNewProc(char);
VOID NEAR CmdGo(boolean);
VOID NEAR CmdStep(boolean);
VOID NEAR CmdRestart(void);
VOID NEAR CmdToggleBp(void);
VOID NEAR CmdGoUntilHere(void);
VOID NEAR CmdViewSubs(void);
VOID NEAR CmdOptnsDisplay(void);
VOID NEAR CmdOptnsPaths(void);
VOID NEAR ReadQbIni(void);
VOID NEAR WriteQbIni(void);
VOID NEAR CmdHelpKey(void);
VOID NEAR CmdHelpHelp(void);
VOID NEAR CmdHelpSyntax(void);
VOID NEAR CmdHelpClose(void);
VOID NEAR CmdSearchFind(boolean, boolean, boolean);
VOID NEAR CmdSearchChange(void);
VOID NEAR InitHelpMenu(void);
VOID NEAR SetHelpKeyword(char *);
VOID NEAR WatchNameId(ushort);

VOID NEAR CmdFileNew(void);
VOID NEAR CmdFilePrint(void);
VOID NEAR CmdFileOpen(void);
boolean NEAR CmdFileSave(void);
boolean NEAR CmdFileSaveAs(void);
boolean NEAR CmdFileSaveAll(boolean);
VOID NEAR CmdFileLoad(void);
VOID NEAR CmdFileExit(void);
void near CmdSetNextStmt(void);
void near ViewSourceFile(void);
void near WaitForEvent(void);
void near FlushMsgs(void);
void near DrawTogglesLnCol(ushort, ushort);
bool near DoDrawDebugScr(void);
void near DoLoadFile(ushort, bd *);
void near DrawWatch(void);
void near DrawSyntaxHelp(void);
void near DrawDebugScr(void);
void near DrawCaptions(void);
void near DrawStatusLine(void);
void near StatusLineMsg(short);
void near DoStatusMsg(PWND);
void near UiTerminate(void);
void near GetCmd(void);
void near EnsShowOutSaveRs(void);
void near EnsShowDebugScr(void);
void near EnsShowOutputScr(void);
void near CallsMenuInit(void);
void near CallsMenuTerm(void);
void near CmdCalls(ushort);
void near WnActivate(PWND);
void near EditMgrFlush(void);
void near EditMgrFlush1(void);
WORD FAR MainWndProc (PWND, WORD, WORD, DWORD);
void near ExitUserInterface(void);
void near EnterUserInterface(void);
void near UiGrabSpace(void);
void near UiReleaseSpace(void);
ushort near UiAlphaORsBuild(void);
ushort far AlphaOfORsFar(ushort);
void near Search(boolean, boolean, boolean);
void near Replace(void);
void near Run(void);
void far LongToStdMsg(ulong);
void far HexToStdMsg(ushort);
void near ActivateHbuf(ushort);
void near SetUiErr(ushort);
void near SetUiErrOm(void);
void near SetUiErrCond(ushort);			//[18]
void near ReportError(void);
void near SetBookMark(ushort);
void near GotoBookMark(ushort);
void near ReAssignBookMark(ushort, ushort);	//[1]
ushort NEAR UIMessageBox(char *, char *, char *, ushort);	//[14]
ushort near MsgBoxStd(ushort, ushort);
ushort NEAR MsgBoxBd(ushort, bd *);
ushort NEAR MsgBoxStdBd(ushort, ushort, bd *);
ushort NEAR PromptForString(ushort, char far *, ushort);
void NEAR DoDlgGreetingBox(void);
void NEAR DoCmd(char *);

void NEAR UnHookInt24(void);
void NEAR HookInt24(void);
boolean fInt24Err(void);

ushort near SeekFile(ushort, ulong);
ushort FAR FindAndOpenFile(char *, ushort, ushort);
char far * FAR FindFile(char *, ushort);

ushort NEAR GetEditLine(void);
ushort NEAR GetEditColumn(void);
ushort NEAR GetEditWord(char *, ushort);
ushort NEAR GetEditWordMask(char *, ushort, ushort);   //[6]
int NEAR FilterSpecialKeys(MSG *);
boolean NEAR fCodeWnd(void);
ushort NEAR GetSelText(char*, ushort);
void near CutAll(ushort);
void near PasteAll(void);

uchar NEAR DebugError(void);
uchar NEAR DebugStop(void);
uchar NEAR DebugEnd(void);
uchar NEAR DebugTrace(void);
void NEAR ShowStmt(ushort, ushort, ushort );

void NEAR AddExtension (char *, char *);
char *(FAR FileSpec (char *));

extern ushort uierr;
   /* 0 = no error needs to be reported by GetCmd,
      UNDEFINED = report parser built ASCII error message contained in ps.bdErr
      else its a standard qbi error message code.
      Other error information is in text mgr's txtErr structure.
      Reset by ReportError()
   */

extern boolean fGotCmd;
extern boolean NEAR CmdEnter(void);
extern boolean NEAR fCanContUI(void);
extern void NEAR ClrNonStickyBp(void);
extern bd bdAlphaRs;

extern VOID FAR DispatchCmd(void);

/* Called by WndReassign to update the register sets */
extern void NEAR SrchReAssign(ushort, ushort);

extern boolean NEAR ContContext(void);
extern boolean NEAR NeedContContext(void);

extern boolean fDoCmd;
extern bool fMenuInit;

extern boolean fScrollBars;
bool fSyntaxCheck;

ushort near RsMake(sd *, char);
void near UiRsActivate(ushort);
void near UiRsActivateWnd(void);
ushort near GetRsName(ushort, boolean, ushort);
PWND near pwndActive (void);
void near SetActiveFocus(void);
void near RemoveScrollBars(void);
void near AddScrollBars(void);

/* Windows stuff */
extern PWND pwndAct;
extern PWND pwndTop;
extern PWND pwndFull;
extern WND wndCmd;
extern ushort hbufOfCmd;
extern bool fWndSplit;		//[08]

void near GetCurDriveDir(char *);	//[17]
char near GetCurDrive2(void);
void near SetCurDrive2(char);
bool near SetCurDir2( char * );

short near CbSzUi (char near *);	//[11]
void near fstrcpy2 (char far *, char far *);
void near fmemcpy (char far *, char far *, ushort);

void near CowMoo(void);

/* help routines */

extern	ushort curHelpFile;		//[14]

ushort near GetHelpTitleStr(bdl *,ushort); //[2]
ushort near GetHelpContextLen(bdl *);	//[2]
ushort near GetHelpMsgSz(char *, bdl *);  //[2]
void   near KeywordHelp(void);		//[2]
ushort near KeywordHelpLookup(void);	//[2]
ushort near DisplayHlpWndSz(char *);	//[2]
void   near CmdHelpClose(void); 	//[2]
char * (near CreateContext(ushort));	//[2]
void   near GiveHelpOOM(void);		//[2]
ushort near StartHelp(void);		//[2]
void   near DiscardHelpBookMarks(void); //[14]
void   near CloseCurHelpFile(void);	//[14]
long   near SendHelpMsg(ushort, ushort);//[15]
ushort near SelectHotLink(ushort,ushort,boolean); //[3]
void   near CmdHelpPrev(void);		      //[2]
void   near CmdHelpNext(void);		      //[2]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uihelpid.h ===
/*
 * Help IDs for the dialogs.  These IDs are hardcoded into the help file
 * The only restriction to the numbers used is that they must not conflict
 * with any numbers in QBIMSGS.TXT, which is why I started the numbers
 * at 900.
 *
 * NOTE: all defines in this file must not have a space between the
 *	 # and the define.  No other constructs besides defines and
 *	 comments should be in the file, as it is mechanically converted
 *	 into a different form to be used with converting help files.
 *
 *	 The format must be identical to qbimsgs.h for the makehelp.sed
 *	 script to work properly.
 *
 */

#define hidFileSave		902 /* File Save Dialog */
#define hidFilePrint		904 /* File Print Dialog */
#define hidPrintSet		905 /* File Print Dialog */
#define hidSearchChange 	907 /* Search & Change Dialog */
#define hidSearchFind		908 /* Search/Find Dialog */
#define hidConfirm		909 /* Confirm Search & Change Dialog */
#define hidViewSubs		911 /* View Subs Dialog */
#define hidNewProc		912 /* New PRocedure Dialog */
#define hidOptnsDisplay 	913 /* Options Display Dialog */
#define hidOptnsPaths		914 /* Options Path Dialog */
#define hidGreetingBox 		916 /* Greeting Box Dialog */

#define hidFileOpen		917 /* File Open Dialog (Not in .DES file) */

#define hidFileNew 		919 /* File New Dialog */

#define hidPrintSetup   920   /* Print Setup Dialog */

#define helpOnHelpId		9998 /* HelpOnHelp Menu Item */
#define helpIndexId		9997 /* HelpIndex Menu Item */
#define helpTableId		9996 /* Help Table of Contents Menu Item */
#define helpSurvivalId		9995 /* QB survival guide */

#define helpKeyboardId		9994 /* Help.Keyboard */
#define helpStartedId		9993 /* Help.Getting Started */
#define helpEditorHelp		9992 /* SHIFT+F1 in editor */
#define helpHowToUseId		9991 /* QHELP How To Use... */
#define helpQHContentsId        9990 /* QHELP Contents */


#define QB_ER_NF		 2001 /* NEXT without FOR */
#define QB_ER_SN		 2002 /* Syntax error */
#define QB_ER_RG		 2003 /* RETURN without GOSUB */
#define QB_ER_OD		 2004 /* Out of DATA */
#define QB_ER_FC		 2005 /* Illegal function call */
#define QB_ER_OV		 2006 /* Overflow */
#define QB_ER_OM		 2007 /* Out of memory */
#define QB_ER_UL		 2008 /* Label not defined */
#define QB_ER_SOR		 2009 /* Subscript out of range */
#define QB_ER_DD		 2010 /* Duplicate definition */
#define QB_ER_DV0		 2011 /* Division by zero */
#define QB_ER_ID		 2012 /* Illegal in direct mode */
#define QB_ER_TM		 2013 /* Type mismatch */
#define QB_ER_OS		 2014 /* Out of string space */
#define QB_ER_BS		 2016 /* String formula too complex */
#define QB_ER_CN		 2017 /* Cannot continue */
#define QB_ER_UF		 2018 /* Function not defined */
#define QB_ER_NR		 2019 /* No RESUME */
#define QB_ER_RE		 2020 /* RESUME without error */
#define QB_ER_DTO		 2024 /* Device timeout */
#define QB_ER_DF		 2025 /* Device fault */
#define QB_ER_FN		 2026 /* FOR without NEXT */
#define QB_ER_OP		 2027 /* Out of paper */
#define QB_ER_WH		 2029 /* WHILE without WEND */
#define QB_ER_WE		 2030 /* WEND without WHILE */
#define QB_ER_DL		 2033 /* Duplicate label */
#define QB_ER_US		 2035 /* Subprogram not defined */
#define QB_ER_AC		 2037 /* Argument-count mismatch */
#define QB_ER_UA		 2038 /* Array not defined */
#define QB_ER_CaseElse		 2039 /* CASE ELSE expected */
#define QB_ER_VarReq		 2040 /* Variable required */
#define QB_ER_FOV		 2050 /* FIELD overflow */
#define QB_ER_IER		 2051 /* Internal error */
#define QB_ER_BFN		 2052 /* Bad file name or number */
#define QB_ER_FNF		 2053 /* File not found */
#define QB_ER_BFM		 2054 /* Bad file mode */
#define QB_ER_FAO		 2055 /* File already open */
#define QB_ER_FSA		 2056 /* FIELD statement active */
#define QB_ER_IOE		 2057 /* Device I/O error */
#define QB_ER_FAE		 2058 /* File already exists */
#define QB_ER_BRL		 2059 /* Bad record length */
#define QB_ER_DFL		 2061 /* Disk full */
#define QB_ER_RPE		 2062 /* Input past end of file */
#define QB_ER_BRN		 2063 /* Bad record number */
#define QB_ER_IFN		 2064 /* Bad file name */
#define QB_ER_TMF		 2067 /* Too many files */
#define QB_ER_DNA		 2068 /* Device unavailable */
#define QB_ER_CBO		 2069 /* Communication-buffer overflow */
#define QB_ER_PRM		 2070 /* Permission denied */
#define QB_ER_DNR		 2071 /* Disk not ready */
#define QB_ER_DME		 2072 /* Disk-media error */
#define QB_ER_ADF		 2073 /* Advanced feature unavailable */
#define QB_ER_RAD		 2074 /* Rename across disks */
#define QB_ER_PAE		 2075 /* Path/File access error */
#define QB_ER_PNF		 2076 /* Path not found */
#define QB_ER_UE		 2077 /* Unprintable error */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\color.h ===
/*
	COW : Character Oriented Windows

	color.h : color info header file

*/

typedef struct _sa
	{
	union
		{
		struct
			{
			BYTE caMono;		/* initial B/W COLOR */
			BYTE caColor;		/* initial COLOR */
			} init;
		struct
			{
			BYTE bFiller;
			BYTE caSa;		/* the actual drawing ca */
			} draw;
		BYTE *rgcaFill;		/* special fill mode array */
		} u;
	} SA;		/* screen attribute */


#define coBlack			0x0
#define coBlue			0x1
#define coGreen			0x2
#define coRed			0x4
#define coCyan			(coBlue + coGreen)
#define coMagenta		(coBlue + coRed)
#define coOrange		(coRed + coGreen)
#define coWhite			(coRed + coGreen + coBlue)
#define	CoBright(co)		((co) | 8)
#define	coGrey			CoBright(coBlack)
#define	coBrightWhite		CoBright(coWhite)
#define coYellow		CoBright(coOrange)

#define CaMake(coFore, coBack)	(((coBack) << 4) | (coFore) )

/* valid monochrome colors */
#define	caWhite			CaMake(coWhite, coBlack)
#define	caBlackOnWhite		CaMake(coBlack, coWhite)
#define	caBrightWhite		CaMake(coBrightWhite, coBlack)
#define	caBrightBlack		CaMake(coBlack, coBrightWhite)
		/* black on bright background */

/* color on standard background (grey) */
#define Ca(coFore)		CaMake(coFore, coGrey)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uiint.h ===
/***
*uiint.h - Defines to the QB user interface
*
*	Copyright <C> 1985-1988 Microsoft Corporation
*
*Purpose:
* NOTE: When making changes to this file, be sure to make equivalent
*	changes to file UIINT.INC
*
*******************************************************************************/
#undef UIINT_H
#define UIINT_H ON         /* remember that this file has been included */

#include <uidec.h>
#include <uimenu.h>

#define Unreferenced(x) ((void)x)

/*------------------------- Window Definitions -------------------------------*/


/* maximum physical line width of edit field.  COW library's edit.c
   must change if infinite length lines are allowed */
#define MAX_EDITLINE	256

#define MAX_SEARCH_PATH	127+1		//[6] path size + null
extern WORD b$fInt24Err;		//[6]


// a-emoryh
#define MAX_PATH  80
#define cDEVICES  4

#define DEV_LPT1  0
#define DEV_LPT2  1
#define DEV_LPT3  2
#define DEV_COM1  3
#define DEV_COM2  4


extern WND wndMain;
extern WND wndDebug;
extern WND wndHelp;
extern WND wndStatus;

/* Window id's */
#define idWndMain	1
#define idWndEdit	2
#define idWndDebug	3
#define idWndHelp	4
#define idWndStatus	5
#define idWndScrollV	6
#define idWndScrollH	7

/* Window stlye bits used by the user interface */
#define UIWS_MOVECURSOR	0x0001		//[09]

#define hbufHelp	0xFFFE

/* register set types - as passed to RsMake() */
#define RS_scrap	(char)0	/* for Scrap */
#define RS_cmdWnd	(char)1	/* for Command Window */
#define RS_module       (char)2
#define RS_includeFile  (char)3
#define RS_document     (char)4
#define RS_sub          (char)5
#define RS_function     (char)6

/* flag parms for GetRsName() */
#define RSN_fFullName	(uchar) 1
#define RSN_fIndent	(uchar) 2

/* Direct Mode Action flags */
#define FDM_ShowStmt 1
#define FDM_GetCmd 2
#define FDM_ExecCmd 4
#define FDM_ShowWatch 8


/*[4] Masks to eliminate certain characters or sets of characters in */
/*[4] a call to GetEditWordMask.  Note that these constants are not  */
/*[4] abitrary, and must relate to the table in UIWORD.ASM.	     */

#define GEW_DFLTMASK	0x5E03	/* default (normal) search characters */
#define GEW_NODOTMASK	0x5E01	/* Do not include . in search	      */
#define GEW_HELPMASK	0x1E01	/* Do not include . or ! in search    */
#define GEW_VARMASK	0x0000	/* Rules for variable help search     */
#define GEW_VARDOTMASK	0x0002	/* variable help with . allowed       */

/* Return codes from routines in uinhelp.asm */

#define HELP_OK 	0
#define HELP_NF 	1
#define HELP_HANDLED	2	//[7] We got a help error that someone else
				//[7] will handle (by putting up a dialog box)
#define HELP_NOVARHELP	4	//[11] unable to regenerate variable help

/* flag values for HelpFlags */

#define HLP_GOTBUF	0x01	/* help buffer is allocated and initialized */
#define HLP_NOSHRINK	0x02	/* do not call HelpShrink in ShrinkHelp */
#define HLP_COMPRESS	0x04	/* help has been compressed (need to */
				/* not re-open help window when UI restarts) */
#define HLP_INHELP	0x08	/* We are in help system. Do not re-enter */
#define HLP_VARHELP	0x10	/* We are displaying Variable Help */
#define HLP_FAILOOM	0x20	/* We failed callback (insufficient memory) */
#define HLP_FAILFNF	0x40	/* We failed callback (file not found) */
#define HLP_RTERR	0x80	/* Next call to ReportError is for a runtime
				   generated error, not for an interpreter
				   error [8]*/

// Flag values for HelpFlags2

#define HLP2_DLGBOX	0x01	/* [10] this help will go in a dialog box */


/* Prefix characters for context strings [NOTE: used in SED script] */

#define PREFIX_MESSAGE	'-'

/* base number of Special Interpreter Version Help Ids.  The message box
   that is displayed is identical to a runtime error, but the help topic
   is different */

#define HELP_INTERPBASE 2000	//[8]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uiint.inc ===
;***
;uiint.inc
;
;	Copyright <C> 1985-1988 Microsoft Corporation
;
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file UIINT.H
;
;*******************************************************************************

	IncludeOnce	HEAP	

; Window stlye bits used by the user interface
UIWS_MOVECURSOR	EQU	0001H	

;Register Set Types (as passed to RsMake)
RS_scrap	EQU	0	;for Command Window or Scrap
RS_module	EQU	1
RS_includeFile	EQU	2
RS_document	EQU	3
RS_sub		EQU	4
RS_function	EQU	5

;flag parms for GetRsName()
RSN_fFullName	EQU 1
RSN_fIndent	EQU 2

;edit field id's
EFID_Default	EQU	128d	;for dialog boxes with only 1 edit field

;Direct Mode Action flags
FDM_ShowStmt	EQU	1
FDM_GetCmd	EQU	2
FDM_ExecCmd	EQU	4
FDM_ShowWatch	EQU	8

	CBMAX_CALLS	EQU 15d

; Masks to eliminate certain characters or sets of characters in
; a call to GetEditWordMask.  Note that these constants are not
; abitrary, and must relate to the table in UIWORD.ASM.

GEW_DFLTMASK	EQU	5E03h  ; default (normal) search characters
GEW_NODOTMASK	EQU	5E01h  ; Do not include . in search
GEW_HELPMASK	EQU	1E01h  ; Do not include . or ! in search
GEW_VARMASK	EQU	0000h  ; Rules for variable help search
GEW_VARDOTMASK	EQU	0002h  ; variable help with . allowed

hbufHelp	equ	0FFFEh

; Definition of a help buffer	

HelpBufType STRUC
	ContextNum	DD	?		;context number of topic
	bdlHelpText	DB   (SIZE BDL) DUP (?) ;BDL referencing topic
HelpBufType ENDS


helpDefaultId = 9998

; Return codes from routines in uinhelp.asm

HELP_OK        = 0
HELP_NF        = 1
HELP_HANDLED   = 2	; Someone else is responsible for informing the user
HELP_NOVARHELP = 4	; unable to regenerate variable help

; Flag values for HelpFlags

HLP_GOTBUF     = 01h	; Help system is initialized
HLP_NOSHRINK   = 02h	; Do not call HelpShrink in ShrinkHelp.
HLP_COMPRESS   = 04h	; Do not re-open help window when we re-enter UI
HLP_INHELP     = 08h	; In help system, do not recursively reenter.
HLP_VARHELP    = 10h	; We are displaying Variable Help
HLP_FAILOOM    = 20h	; We failed a memory alloc from the help engine
HLP_FAILFNF    = 40h	; We failed a file open in OpenFileOnPath
HLP_RTERR      = 80h	; a RT error (not Interp error) occured.

; Flag values for HelpFlags2

HLP2_DLGBOX    = 01h	; this help will go in a dialog box
; Prefix characters for context strings

PREFIX_MESSAGE = '-'

; base number of Special Interpreter Version Help Ids.	The message box
; that is displayed is identical to a runtime error, but the help topic
; is different

HELP_INTERPBASE = 2000

MAX_SEARCH_PATH	EQU	127+1	; path size + null


;; a-emoryh
MAX_PATH  EQU  80
cDEVICES  EQU  4

DEV_LPT1  EQU  0
DEV_LPT2  EQU  1
DEV_LPT3  EQU  2
DEV_COM1  EQU  3
DEV_COM2  EQU  4

externW iPrintPort
externW fPrintToFile
externB szPrintDest


sBegin	DATA
	extrn	fHistOn:BYTE
	extrn	fGotCmd:word
	extrn	uierr:word
	extrn	wndMain:word
	extrn	wndDebug:word
	extrn	wndHelp:word
	extrn	wndCmd:word
	extrn	wnd1:word
	extrn	wnd2:word
	extrn	pwndTop:word
	extrn	pwndAct:word
	extrn	fWndSplit:byte		
	extrn	fHelpVisible:byte
	extrn	b$fInt24Err:word	

ife UIEDIT_ASM
	extrn	hbufOfCmd:word
	extrn	fDoCmd:word
	extrn	bdEMScratch:byte
endif

ife	HENGINE_ASM			
	extrn	curHelpFile:word	
endif					

sEnd	DATA


sBegin	UI
	extrn	CwInit:near
	extrn	CwHook:near
	extrn	CwUnHook:near
	extrn	CwTerm:near
	extrn	UiRsActivate:near
	extrn	UiRsActivateWnd:near
	extrn	CmdFileSaveAll:near
	extrn	CmdSearchFind:near
	extrn	CmdSearchChange:near
	extrn	MsgBoxStd2:near
	extrn	MsgBoxBd:near		
	extrn	MsgBoxStdBd:near	
	extrn	MsgBoxCompErr:near
	extrn	WndAssign:near
	extrn	WndAssignList:near
	extrn	WndAssignList1:near
	extrn	WndAssignNext:near
	extrn	WndActivate:near
	extrn	RsMake:near
	extrn	GetEditLine:near
	extrn	GetEditColumn:near
	extrn	GetEditWord:near
	extrn	SelectTextPwndCur:near
	extrn	DrawTogglesLnCol:near
	extrn	DoDrawDebugScr:near
	extrn	DoLoadFile:near
	extrn	EnsShowDebugScr:near
	extrn	EnsShowOutputScr:near
	extrn	EnsShowOutSaveRs:near
	extrn	GetCmd:near
	extrn	FlushMsgs:near
	extrn	PromptForString:near
	extrn	DrawDebugScr:near
	extrn	StatusLineMsg:near
        extrn   DoStatusMsg:near

ife UIFILEIO_ASM			
	extrn	ReadQbIni:near		
	extrn	WriteQbIni:near 	
endif	;UIFILEIO_ASM			


ife	UIWORD_ASM			
	extrn	GetEditWordMask:near	
endif					



ife UIMAIN_ASM
	extrn	ExitUserInterface:near
	extrn	EnterUserInterface:near
	extrn	UiGrabSpace:near
	extrn	UiReleaseSpace:near
	extrn	UiAlphaORsBuild:near
	extrn	UiInit:far
endif	;UIMAIN_ASM

ife UIEDIT_ASM
	extrn	CowMoo:near
	extrn	DoCmd:near
	extrn	EditMgrFlush:near
	extrn	EditMgrFlush1:near
	extrn	SetUiErr:near
	extrn	SetUiErrOm:near
	extrn	SetUiErrCond:near	
	extrn	ShowStmt:near
	extrn	fCodeWnd:near
	extrn	GetSelText:near
	extrn	MoveTxdCursor:near
	extrn	CutAll:near
	extrn	PasteAll:near
	extrn	ReAssignBookMark:near	
	extrn	DiscardHelpBookMarks:near
endif	;UIEDIT_ASM

ife UIRS_ASM
	extrn	fCanContUI:near
	extrn	GetRsName:near
	extrn	ContContext:near
	extrn	NeedContContext:near
endif	;UIRS_ASM

ife UIMISC_ASM
	extrn	HookInt24:near
	extrn	UnHookInt24:near
	extrn	FInt24Err:near
	extrn	UIMessageBox:near	
	extrn	MsgBoxStd:near		
	extrn	MsgBoxStdRt:near	
endif	;UIMISC_ASM

ife	UIDEBUG_ASM
	extrn	DrawWatch:near
	extrn	DebugEnd:near
	extrn	DebugError:near
	extrn	DebugStop:near
	extrn	DebugTrace:near
	extrn	WatchInfoUI:near
endif	;UIDEBUG_ASM

ife	UIMEMORY_ASM
	EXTRN	UiStackAlloc:NEAR
	EXTRN	UiStackFree:NEAR
endif	;UIDEBUG_ASM

ife	UIUTIL_ASM
	EXTRN	LongToStdMsg:far
	EXTRN	HexToStdMsg:far
	extrn	fstrcpy2:near		
	extrn	fmemcpy:near		
	extrn	CbSzUi:near		
endif	;UIUTIL_ASM


ife	UINHELP_ASM			
	extrn	GetHelpTitleStr:near	
	extrn	GetHelpContextLen:near	
	extrn	GetHelpMsgSz:near	
	extrn	CmdHelpClose:near	
	extrn	DisplayHlpWndSz:near	
	extrn	DisplayHlpWndNc:near	
	extrn	KeywordHelp:near	
	extrn	KeywordHelpLookup:near	
	extrn	SelectHotLink:near	
	extrn	BufferNc:near		
	extrn	RetrieveHelpHistory:near
	extrn	RecordHelpHistory:near	
	extrn	CreateContext:near	
	extrn	GiveHelpOOM:near	
	extrn	StartHelp:near		
	extrn	SendHelpMsg:near	
endif					

ife	HENGINE_ASM			
	extrn	CloseCurHelpFile:near	
endif					


sEnd	UI
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uimenu.inc ===
; WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
;
;	If you make any changes to this file, you must make the identical
;	change to UIMENU.H (in this directory)!
;
; WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

; Menu constants
CBMAX_CALLS		EQU 15 	; proc names are truncated after 15 characters

midFile 		EQU 0
midEdit 		EQU 1
midSearch		EQU 2
midView 		EQU 3
midRun			EQU 4
midDebug		EQU 5
midCalls		EQU 6
midOptns		EQU 7
midHelp 		EQU 8
midCount		EQU 9

miFileBase		EQU midCount
miFileNew		EQU 0
miFileOpen		EQU 1
miFileMerge		EQU 2
miFileSave		EQU 3
miFileSaveAs		EQU 4
miFileSaveAll		EQU 5
miFileCreate		EQU 6
miFileLoad		EQU 7
miFileUnload		EQU 8
miFilePrint		EQU 9
miFileShell		EQU 10
miFileExit		EQU 11
miFileExitQH		EQU 12
miFileCount		EQU 13

miEditBase		EQU (miFileBase + miFileCount)
miEditUndo		EQU 0
miEditCut		EQU 1
miEditCopy		EQU 2
miEditClear		EQU 3
miEditPaste		EQU 4
miEditNewSub		EQU 5
miEditNewFunc		EQU 6
miEditCount		EQU 7

miViewBase		EQU (miEditBase + miEditCount)
miViewSubs		EQU 0
miViewNextProc		EQU 1
miViewSplit		EQU 2
miViewNextStmt		EQU 3
miViewOutScrn		EQU 4
miViewInclFile		EQU 5
miViewInclLns		EQU 6
miViewCount		EQU 7

miSearchBase		EQU (miViewBase + miViewCount)
miSearchFind		EQU 0
miSearchSel		EQU 1
miSearchNext		EQU 2
miSearchChange		EQU 3
miSearchLabel		EQU 4
miSearchCount		EQU 5

miRunBase		EQU (miSearchBase + miSearchCount)
miRunStart		EQU 0
miRunRestart		EQU 1
miRunContinue		EQU 2
miRunSetCmd		EQU 3
miRunMakeExe		EQU 4
miRunMakeLib		EQU 5
miRunSetMain		EQU 6
miRunCount		EQU 7

miDebugBase		EQU (miRunBase + miRunCount)
miDebugStep		EQU 0		
miDebugPStep		EQU 1		
miDebugAddWatch 	EQU 2		
miDebugInstantWatch	EQU 3		
miDebugWatchPoint	EQU 4		
miDebugDelWatch 	EQU 5		
miDebugDelAllWatch	EQU 6		
miDebugTraceOn		EQU 7		
miDebugHistoryOn	EQU 8		
miDebugToggleBp 	EQU 9		
miDebugClearAllBp	EQU 10		
miDebugBreakOnErr	EQU 11		
miDebugSetNextStmt	EQU 12		
miDebugCount		EQU 13		

miOptnsBase		EQU (miDebugBase + miDebugCount)
miOptnsDisplay		EQU 0
miOptnsPaths		EQU 1
miOptnsMouse		EQU 2
miOptnsSyntax		EQU 3
miOptnsFullMenu 	EQU 4
miOptnsCount		EQU 5

miHelpBase		EQU (miOptnsBase + miOptnsCount)
miHelpIndex		EQU 0
miHelpTable		EQU 1
miHelpSyntax		EQU 2
miHelpHelp		EQU 3
miHelpStarted		EQU 4					
miHelpKeyboard		EQU 5					
miHelpAbout		EQU 6					
miHelpHowToUse		EQU 7
miHelpCount		EQU 8

miNoMenuBase		EQU (miHelpBase + miHelpCount)	
miNextWindow		EQU 0
miPreviousWindow	EQU 1
miViewPrev		EQU 2
miViewFull		EQU 3
miGotoCursor		EQU 9
miHelpKey		EQU 10
miEditCut2		EQU 12
miEditClear2		EQU 13
miViewPrevProc		EQU 14
miWndGrow		EQU 15
miWndShrink		EQU 16
miWndRestore		EQU 17
miWndMaximize		EQU 18

; For the new help system, HelpClose is an accelerator (and defined here).
; For all other help systems, HelpClose is a menu item and is defined with
; the Help Menu

miHelpClose		EQU 19
miHelpBack		EQU 20
miHelpNext		EQU 21
miEnter			EQU 22



midFileNew		EQU (miFileBase + miFileNew)
midFileOpen		EQU (miFileBase + miFileOpen)
midFileMerge		EQU (miFileBase + miFileMerge)
midFileSave		EQU (miFileBase + miFileSave)
midFileSaveAs		EQU (miFileBase + miFileSaveAs)
midFileSaveAll		EQU (miFileBase + miFileSaveAll)
midFileCreate		EQU (miFileBase + miFileCreate)
midFileLoad		EQU (miFileBase + miFileLoad)
midFileUnload		EQU (miFileBase + miFileUnload)
midFilePrint		EQU (miFileBase + miFilePrint)
midFileShell		EQU (miFileBase + miFileShell)
midFileExit		EQU (miFileBase + miFileExit)
midFileExitQH		EQU (miFileBase + miFileExitQH)

midEditUndo		EQU (miEditBase + miEditUndo)
midEditCut		EQU (miEditBase + miEditCut)
midEditCopy		EQU (miEditBase + miEditCopy)
midEditClear		EQU (miEditBase + miEditClear)
midEditPaste		EQU (miEditBase + miEditPaste)
midEditNewSub		EQU (miEditBase + miEditNewSub)
midEditNewFunc		EQU (miEditBase + miEditNewFunc)

midViewSubs		EQU (miViewBase + miViewSubs)
midViewNextProc 	EQU (miViewBase + miViewNextProc)
midViewSplit		EQU (miViewBase + miViewSplit)
midViewNextStmt 	EQU (miViewBase + miViewNextStmt)
midViewOutScrn		EQU (miViewBase + miViewOutScrn)
midViewInclFile 	EQU (miViewBase + miViewInclFile)
midViewInclLns		EQU (miViewBase + miViewInclLns)

midSearchFind		EQU (miSearchBase + miSearchFind)
midSearchSel		EQU (miSearchBase + miSearchSel)
midSearchNext		EQU (miSearchBase + miSearchNext)
midSearchChange 	EQU (miSearchBase + miSearchChange)
midSearchLabel		EQU (miSearchBase + miSearchLabel)

midRunStart		EQU (miRunBase + miRunStart)
midRunRestart		EQU (miRunBase + miRunRestart)
midRunContinue		EQU (miRunBase + miRunContinue)
midRunSetCmd		EQU (miRunBase + miRunSetCmd)
midRunMakeExe		EQU (miRunBase + miRunMakeExe)
midRunMakeLib		EQU (miRunBase + miRunMakeLib)
midRunSetMain		EQU (miRunBase + miRunSetMain)

midStep			EQU (miDebugBase + miDebugStep)		
midPStep		EQU (miDebugBase + miDebugPStep)	
midDebugAddWatch	EQU (miDebugBase + miDebugAddWatch)
midDebugInstantWatch	EQU (miDebugBase + miDebugInstantWatch)
midDebugWatchPoint	EQU (miDebugBase + miDebugWatchPoint)
midDebugDelWatch	EQU (miDebugBase + miDebugDelWatch)
midDebugDelAllWatch	EQU (miDebugBase + miDebugDelAllWatch)
midDebugTraceOn 	EQU (miDebugBase + miDebugTraceOn)
midDebugHistoryOn	EQU (miDebugBase + miDebugHistoryOn)
midDebugToggleBp	EQU (miDebugBase + miDebugToggleBp)
midDebugClearAllBp	EQU (miDebugBase + miDebugClearAllBp)
midDebugBreakOnErr	EQU (miDebugBase + miDebugBreakOnErr)
midDebugSetNextStmt	EQU (miDebugBase + miDebugSetNextStmt)

midOptnsDisplay		EQU (miOptnsBase + miOptnsDisplay)
midOptnsPaths		EQU (miOptnsBase + miOptnsPaths)
midOptnsMouse		EQU (miOptnsBase + miOptnsMouse)
midOptnsSyntax		EQU (miOptnsBase + miOptnsSyntax)
midOptnsFullMenu	EQU (miOptnsBase + miOptnsFullMenu)

midHelpSyntax		EQU (miHelpBase + miHelpSyntax)
midHelpHelp		EQU (miHelpBase + miHelpHelp)
midHelpIndex		EQU (miHelpBase + miHelpIndex)
midHelpTable		EQU (miHelpBase + miHelpTable)
midHelpStarted		EQU (miHelpBase + miHelpStarted)	
midHelpKeyboard 	EQU (miHelpBase + miHelpKeyboard)	
midHelpAbout		EQU (miHelpBase + miHelpAbout)		
midHelpHowToUse 	EQU (miHelpBase + miHelpHowToUse)

; The following id's aren't really menu items at all.	They are
; just so we can use the menu dispatcher to Process some control Keys
midViewPrev		EQU (miNoMenuBase + miViewPrev)
midViewFull		EQU (miNoMenuBase + miViewFull)
midGoUntilCursor	EQU (miNoMenuBase + miGotoCursor)
midHelpKey		EQU (miNoMenuBase + miHelpKey)
midNextWindow		EQU (miNoMenuBase + miNextWindow)
midPreviousWindow	EQU (miNoMenuBase + miPreviousWindow)
midEditCut2		EQU (miNoMenuBase + miEditCut2)
midEditClear2		EQU (miNoMenuBase + miEditClear2)
midViewPrevProc 	EQU (miNoMenuBase + miViewPrevProc)
midWndGrow		EQU (miNoMenuBase + miWndGrow)
midWndShrink		EQU (miNoMenuBase + miWndShrink)
midWndRestore		EQU (miNoMenuBase + miWndRestore)
midWndMaximize		EQU (miNoMenuBase + miWndMaximize)

midHelpClose		EQU (miNoMenuBase + miHelpClose)
midHelpBack		EQU (miNoMenuBase + miHelpBack)
midHelpNext		EQU (miNoMenuBase + miHelpNext)
midEnter		EQU (miNoMenuBase + miEnter)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uimenu.h ===
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
	If you make any changes to this file, you must make the identical
	change to UIMENU.INC (in this directory)!
 WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */

/* Menu constants */
#define CBMAX_CALLS 15 /* proc names are truncated after 15 characters */

#define midFile 		0
#define midEdit 		1
#define midSearch		2
#define midView 		3
#define midRun			4
#define midDebug		5
#define midCalls		6
#define midOptns		7
#define midHelp 		8
#define midCount		9

#define miFileBase		midCount
#define miFileNew		0
#define miFileOpen		1
#define miFileMerge		2
#define miFileSave		3
#define miFileSaveAs		4
#define miFileSaveAll		5
#define miFileCreate		6
#define miFileLoad		7
#define miFileUnload		8
#define miFilePrint		9
#define miFileShell		10
#define miFileExit		11
#define miFileExitQH		12
#define miFileCount		13

#define miEditBase (miFileBase + miFileCount)
#define miEditUndo		0
#define miEditCut		1
#define miEditCopy		2
#define miEditClear		3
#define miEditPaste		4
#define miEditNewSub		5
#define miEditNewFunc		6
#define miEditCount		7

#define miViewBase (miEditBase + miEditCount)
#define miViewSubs		0
#define miViewNextProc		1
#define miViewSplit		2
#define miViewNextStmt		3
#define miViewOutScrn		4
#define miViewInclFile		5
#define miViewInclLns		6
#define miViewCount		7

#define miSearchBase (miViewBase + miViewCount)
#define miSearchFind		0
#define miSearchSel		1
#define miSearchNext		2
#define miSearchChange		3
#define miSearchLabel		4
#define miSearchCount		5

#define miRunBase (miSearchBase + miSearchCount)
#define miRunStart		0
#define miRunRestart		1
#define miRunContinue		2
#define miRunSetCmd		3
#define miRunMakeExe		4
#define miRunMakeLib		5
#define miRunSetMain		6
#define miRunCount		7

#define miDebugBase (miRunBase + miRunCount)
#define miDebugStep		0			//[1]
#define miDebugPStep 		1			//[1]
#define miDebugAddWatch 	2			//[1]
#define miDebugInstantWatch 	3			//[1]
#define miDebugWatchPoint	4			//[1]
#define miDebugDelWatch 	5			//[1]
#define miDebugDelAllWatch	6			//[1]
#define miDebugTraceOn		7			//[1]
#define miDebugHistoryOn	8			//[1]
#define miDebugToggleBp 	9			//[1]
#define miDebugClearAllBp	10			//[1]
#define miDebugBreakOnErr	11			//[1]
#define miDebugSetNextStmt	12			//[1]
#define miDebugCount		13			//[1]

#define miOptnsBase (miDebugBase + miDebugCount)
#define miOptnsDisplay		0
#define miOptnsPaths		1
#define miOptnsMouse		2
#define miOptnsSyntax		3
#define miOptnsFullMenu 	4
#define miOptnsCount		5

#define miHelpBase (miOptnsBase + miOptnsCount)
#define miHelpIndex		0
#define miHelpTable		1
#define miHelpSyntax		2
#define miHelpHelp		3
#define miHelpStarted		4		//[2]
#define miHelpKeyboard		5		//[2]
#define miHelpAbout		6		//[2]
#define miHelpHowToUse		7
#define miHelpCount		8		//[2]

#define miNoMenuBase (miHelpBase + miHelpCount)		//[1]

#define miNextWindow		0
#define miPreviousWindow	1
#define miViewPrev		2
#define miViewFull		3
#define miGotoCursor		9
#define miHelpKey		10
#define miEditCut2		12
#define miEditClear2		13
#define miViewPrevProc		14
#define miWndGrow		15
#define miWndShrink		16
#define miWndRestore		17
#define miWndMaximize		18

/* For the new help system, HelpClose is an accelerator (and defined here).
   For all other help systems, HelpClose is a menu item and is defined with
   the Help Menu */

#define miHelpClose		19
#define miHelpBack		20
#define miHelpNext		21
#define miEnter			22



#define midFileNew		(miFileBase + miFileNew)
#define midFileOpen		(miFileBase + miFileOpen)
#define midFileMerge		(miFileBase + miFileMerge)
#define midFileSave		(miFileBase + miFileSave)
#define midFileSaveAs		(miFileBase + miFileSaveAs)
#define midFileSaveAll		(miFileBase + miFileSaveAll)
#define midFileCreate		(miFileBase + miFileCreate)
#define midFileLoad		(miFileBase + miFileLoad)
#define midFileUnload		(miFileBase + miFileUnload)
#define midFilePrint		(miFileBase + miFilePrint)
#define midFileShell		(miFileBase + miFileShell)
#define midFileExit		(miFileBase + miFileExit)
#define midFileExitQH		(miFileBase + miFileExitQH)

#define midEditUndo		(miEditBase + miEditUndo)
#define midEditCut		(miEditBase + miEditCut)
#define midEditCopy		(miEditBase + miEditCopy)
#define midEditClear		(miEditBase + miEditClear)
#define midEditPaste		(miEditBase + miEditPaste)
#define midEditNewSub		(miEditBase + miEditNewSub)
#define midEditNewFunc		(miEditBase + miEditNewFunc)

#define midViewSubs		(miViewBase + miViewSubs)
#define midViewNextProc 	(miViewBase + miViewNextProc)
#define midViewSplit		(miViewBase + miViewSplit)
#define midViewNextStmt 	(miViewBase + miViewNextStmt)
#define midViewOutScrn		(miViewBase + miViewOutScrn)
#define midViewInclFile 	(miViewBase + miViewInclFile)
#define midViewInclLns		(miViewBase + miViewInclLns)

#define midSearchFind		(miSearchBase + miSearchFind)
#define midSearchSel		(miSearchBase + miSearchSel)
#define midSearchNext		(miSearchBase + miSearchNext)
#define midSearchChange 	(miSearchBase + miSearchChange)
#define midSearchLabel		(miSearchBase + miSearchLabel)

#define midRunStart		(miRunBase + miRunStart)
#define midRunRestart		(miRunBase + miRunRestart)
#define midRunContinue		(miRunBase + miRunContinue)
#define midRunSetCmd		(miRunBase + miRunSetCmd)
#define midRunMakeExe		(miRunBase + miRunMakeExe)
#define midRunMakeLib		(miRunBase + miRunMakeLib)
#define midRunSetMain		(miRunBase + miRunSetMain)

#define midStep 		(miDebugBase + miDebugStep)	//[1]
#define midPStep 		(miDebugBase + miDebugPStep)	//[1]
#define midDebugAddWatch	(miDebugBase + miDebugAddWatch)
#define midDebugInstantWatch	(miDebugBase + miDebugInstantWatch)
#define midDebugWatchPoint	(miDebugBase + miDebugWatchPoint)
#define midDebugDelWatch	(miDebugBase + miDebugDelWatch)
#define midDebugDelAllWatch	(miDebugBase + miDebugDelAllWatch)
#define midDebugTraceOn 	(miDebugBase + miDebugTraceOn)
#define midDebugHistoryOn	(miDebugBase + miDebugHistoryOn)
#define midDebugToggleBp	(miDebugBase + miDebugToggleBp)
#define midDebugClearAllBp	(miDebugBase + miDebugClearAllBp)
#define midDebugBreakOnErr	(miDebugBase + miDebugBreakOnErr)
#define midDebugSetNextStmt	(miDebugBase + miDebugSetNextStmt)

#define midHelpSyntax		(miHelpBase + miHelpSyntax)
#define midHelpHelp		(miHelpBase + miHelpHelp)
#define midHelpIndex		(miHelpBase + miHelpIndex)
#define midHelpTable		(miHelpBase + miHelpTable)

#define midHelpStarted		(miHelpBase + miHelpStarted)	//[2]
#define midHelpKeyboard 	(miHelpBase + miHelpKeyboard)	//[2]
#define midHelpAbout		(miHelpBase + miHelpAbout)	//[2]
#define midHelpHowToUse 	(miHelpBase + miHelpHowToUse)

#define midOptnsDisplay 	(miOptnsBase + miOptnsDisplay)
#define midOptnsPaths		(miOptnsBase + miOptnsPaths)
#define midOptnsMouse		(miOptnsBase + miOptnsMouse)
#define midOptnsSyntax		(miOptnsBase + miOptnsSyntax)
#define midOptnsFullMenu	(miOptnsBase + miOptnsFullMenu)

/* The following id's aren't really menu items at all.	They are
   just so we can use the menu dispatcher to Process some control Keys */
#define midViewPrev		(miNoMenuBase + miViewPrev)
#define midViewFull		(miNoMenuBase + miViewFull)
#define midGoUntilCursor	(miNoMenuBase + miGotoCursor)
#define midHelpKey		(miNoMenuBase + miHelpKey)
#define midNextWindow		(miNoMenuBase + miNextWindow)
#define midPreviousWindow	(miNoMenuBase + miPreviousWindow)
#define midEditCut2		(miNoMenuBase + miEditCut2)
#define midEditClear2		(miNoMenuBase + miEditClear2)
#define midViewPrevProc 	(miNoMenuBase + miViewPrevProc)
#define midWndGrow		(miNoMenuBase + miWndGrow)
#define midWndShrink		(miNoMenuBase + miWndShrink)
#define midWndRestore		(miNoMenuBase + miWndRestore)
#define midWndMaximize		(miNoMenuBase + miWndMaximize)

#define midHelpClose		(miNoMenuBase + miHelpClose)
#define midHelpBack		(miNoMenuBase + miHelpBack)
#define midHelpNext		(miNoMenuBase + miHelpNext)
#define midEnter		(miNoMenuBase + miEnter)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uinhelp.h ===
/***
*uinhelp.h - Defines and data for the New Help System
*
*   Copyright <C> 1985-1988 Microsoft Corporation
*
*Purpose:
* NOTE: When making changes to this file, be sure to make equivalent
*   changes to file UINHELP.INC
*
*******************************************************************************/

#define UINHELP_H   /* flag that file has already been included */


/* These constants define the source of calls to Help().  Each type of caller
 * passes parameters in a different way and expects the text to be displayed
 * differently
 */

#define hemWindowHid    hemUserMin+1    /* Display help (ID = hid) in window */
#define hemAllWindow    hemUserMin  /* F1 pressed in any window */


#define WM_FIRSTHELPMSG WM_USER+20  //[8] WM_USER+15 is the last editmgr
                    //[8] message.Use +20 in case of change

#define WM_HELPBACK WM_FIRSTHELPMSG
#define WM_HELPNEXT WM_FIRSTHELPMSG + 1
#define WM_HELPDISP WM_FIRSTHELPMSG + 2
#define WM_HELPCURTOPIC WM_FIRSTHELPMSG + 3
#define WM_HELPNXTTOPIC WM_FIRSTHELPMSG + 4
#define WM_HELPCHGTOPIC WM_FIRSTHELPMSG + 5
#define WM_HELPRESTORETOPIC  WM_FIRSTHELPMSG + 6    //[7]
#define WM_HELPTITLE    WM_FIRSTHELPMSG + 7
#define WM_HELPLINE WM_FIRSTHELPMSG + 8
#define WM_HELPATTR WM_FIRSTHELPMSG + 9
#define WM_HELPFILESIZE WM_FIRSTHELPMSG + 10

#define NUM_HELPMSG 11              //[7]

// a-emoryh - Max size of command-line topic, in Dos6 QHelp.
#define cbmaxTOPIC  40

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\uinhelp.inc ===
;***
;uinhelp.h - Defines and data for the New Help System
;
;   Copyright <C> 1985-1988 Microsoft Corporation
;
;Purpose:
; NOTE: When making changes to this file, be sure to make equivalent
;   changes to file UINHELP.H
;
;***************************************************************************


; These constants define the source of calls to Help().  Each type of caller
; passes parameters in a different way and expects the text to be displayed
; differently

hemWindowHid    = hemUserMin+1    ; Display help (ID = hid) in window */
hemAllWindow    = hemUserMin      ; F1 pressed in any window */

WM_FIRSTHELPMSG = WM_USER+20      ; WM_USER+15 is the last editmgr message.
                  ; use +20 in case of change.

WM_HELPBACK = WM_FIRSTHELPMSG
WM_HELPNEXT = WM_FIRSTHELPMSG + 1
WM_HELPDISP = WM_FIRSTHELPMSG + 2
WM_HELPCURTOPIC = WM_FIRSTHELPMSG + 3
WM_HELPNXTTOPIC = WM_FIRSTHELPMSG + 4
WM_HELPCHGTOPIC = WM_FIRSTHELPMSG + 5
WM_HELPRESTORETOPIC = WM_FIRSTHELPMSG + 6   
WM_HELPTITLE    = WM_FIRSTHELPMSG + 7
WM_HELPLINE = WM_FIRSTHELPMSG + 8
WM_HELPATTR = WM_FIRSTHELPMSG + 9
WM_HELPFILESIZE = WM_FIRSTHELPMSG + 10

NUM_HELPMSG = 11

;; a-emoryh - Max size of command-line topic, in Dos6 QHelp.
cbmaxTOPIC  EQU  40


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\cowproc.inc ===
externFP	FEnableMouse
externFP	EnableKeyboard
externFP	PollKeyboard
externFP	SetShiftKk
externFP	DisableExtendedKeyboard
externFP	GetCharMap
externFP	MessageBox
externFP	SetDialogCaption
externFP	HiliteDialogAccel
externFP	SetEditText
externFP	GetEditText
externFP	EditWndProc
externFP	SetAlarm
externFP	KillAlarm
externFP	UngetMessage
externFP	PeekMessage
externFP	GetFocus
externFP	SetFocus
externFP	FlushAbort
externFP	SetCapture
externFP	ReleaseCapture
externFP	DispatchMessage
externFP	PostMessage
externFP	SendMessage
externFP	InitMenu
externFP	FEnableMenuBar
externFP	EnableMenu
externFP	EnableMenuItem
externFP	CheckMenuItem
externFP	FMenuItemChecked
externFP	FindMenuItem
externFP	DrawMenubar
externFP	SetCursorBlock
externFP	ScrollBarWndProc
externFP	SetScrollPos
externFP	GetScrollPos
externFP	SetScrollRange
externFP	AddChild
externFP	RemoveChild
externFP	EnableWindow
externFP	GetClientRrc
externFP	SetWindowStyle
externFP	SetWindowSize
externFP	DrawWindow
externFP	DrawBorder
externFP	TextOut
externFP	CharOut
externFP	FillRrc
externFP	BltRrc
externFP	DrawBox
externFP	SaveRrc
externFP	RestoreRrc
externFP	EnableCursor
externFP	MoveCursor
externFP	MoveWindow
externFP	IntersectRect
externFP	UnionRect
externFP	IsRectEmpty
externFP	SetRect
externFP	PtInRect
externFP	CwSizeRrc
externFP	ShadowArc
externFP	ListBoxWndProc
externFP	DoSound
externFP	ClockTicks
externFP	FValidDrive
externFP	SetIsaColor
externFP	GetIsaColor
externFP	SetIsaRgca
externFP	TmcDoDlg
externFP	HcabAlloc
externFP	FreeCab
externFP	FreeCabData
externFP	SzToCab
externFP	SzFromCab
externFP	EnableTmc
externFP	FEnabledTmc
externFP	SetTmcVal
externFP	GetTmcVal
externFP	SetTmcSel
externFP	GetTmcText
externFP	SetTmcText
externFP	SetFocusTmc
externFP	RedisplayListBox
externFP	RedisplayTmc
externFP	SetDefaultTmc
externFP	InitCab
externFP	ReinitCab
externFP	PwndOfListbox
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\cowdef.inc ===
;*****************************************************************************
;*	* Structures:
;*	* NOTE: not generated

_ARC	STRUC		;* Absolute Rectangle
	axLeftArc	DB	?
	ayTopArc	DB	?
	axRightArc	DB	?
	ayBottomArc	DB	?
_ARC	ENDS

STF	RECORD	fEnabledStf:1, styleStf:15		;* style & flag

;*	* WND : window structure *
WND	STRUC
	idWnd		DW	?			;* id
	stfWnd		DB	(WIDTH STF) / 8 DUP (?)
	arcWindow	DB	SIZE _ARC DUP (?)
	arcClipping	DB	SIZE _ARC DUP (?)
	pfnWndProc	DD	?
	pwndParent	DW	?
	pwndSibbling	DW	?
	pwndChild	DW	?
	axCursor	DB	?
	ayCursor	DB	?
	rgwExtra	DW	?			;* array of WORDS
WND	ENDS

BOX	STRUC	;* Single and Double BCS
	chTopLeftBox	DB	?
	chTopRightBox	DB	?
	chBottomLeftBox	DB	?
	chBottomRightBox DB	?
	chTopBox	DB	?
	chBottomBox	DB	?
	chLeftBox	DB	?
	chRightBox	DB	?
BOX	ENDS


;*****************************************************************************


IDDEFAULT	=	1
IDCANCEL	=	2
IDNO		=	3
IDOK		=	IDDEFAULT
IDYES		=	IDDEFAULT
IDRETRY 	=	IDDEFAULT
IDABORT 	=	IDDEFAULT

tmcNull 	=	0
tmcOK		=	1
tmcOk		=	tmcOK
tmcCancel	=	2
tmcSysMin	=	0010H
tmcSysMax	=	0100H
tmcGrouped	=	8000H

tmcUserMin	=	tmcSysMax
tmcUserMax	=	tmcGrouped


MB_OK		=	1
MB_YESNOCANCEL	=	2
MB_RETRYCANCEL	=	3
MB_OKCANCEL	=	4
MB_ABORT	=	5
MB_YESNO	=	6
MB_RETRY	=	7
MB_TYPE 	=	00fH		; message type
MB_BEEP 	=	010H
MB_CAPTION	=	020H		; 1st param is caption
MB_NOHELP	=	8000H		; No Help button
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\csdmtmpl.h ===
/*
	CW : Character Windows

	csdmtmpl.h : SDM template header (include for .sdm files only)				CS Compiled only !!

-- Created Mon Aug 29 22:44:57 1988 */ 

#define	SDM_COW		1
/* #define SDM_ST */
/* #define SDM_LOCK */


/* -- defined Dialog Item */
typedef struct _sdmtm
	{
	BITS	tmtBase:6;	/* item type */
	BITS	tmsBase:4;	/* sub-type */
	BIT	f1:1;		/* general purpose # 1 */
	BIT	f2:1;		/* general purpose # 2 */
	BIT	f3:1;		/* general purpose # 3 */
	BIT	fDisable:1;	/* if originally disabled */
	BIT	fProc:1;	/* if call dialog proc */
	BIT	fDismiss:1; 	/* if dismiss dialog */

#ifdef CC
	WORD	bpString;	/* based pointer or wParam */
#else
#ifdef SDM_ST
	char	st[];		/* based pointer or wParam */
#else
	char	sz[];		/* based pointer or wParam */
#endif
#endif /*!CC*/

	LONG	l;		/* compact rectangle or PFN */
#ifdef SDM_LONG_COORD
	LONG	l2;
#endif
	} SDMTM;


#ifdef SDM_COW
/* Compact Rectangle */
typedef struct _crc
	{
	BYTE	x, y, dx, dy;		/* order critical */
	} CRC;		/* Compact Rectangle */
#endif

/* Dialog Proc Type */
typedef BOOL	(FARPUBLIC *PFFN_DLG)(WORD, TMC, WORD, WORD, WORD);


/* dialog header */
typedef struct _dlg
	{
#ifdef SDM_COW
	CRC	crcDlg;			/* Compact Rectangle */
#else
	WRC wrcDlg;
	long lStyle;			/* dialog style */
#endif /*!SDM_COW*/

/* title string : based pointer */
#ifdef CC
	WORD bpTitle;			/* based pointer to title */
#else
#ifdef SDM_ST
	char stTitle[];
#else
	char szTitle[];		/* dialog title */
#endif
#endif /*!CC*/

	WORD	hid;			/* dialog help id */

	PFFN_DLG pfnDlg; 		/* dialog function */
	TMC	tmcSelInit;		/* initial selection */
#ifndef CC
	SDMTM	rgtm[];			/* variable length for CS */
#else
#ifdef SDM_ENGINE
	SDMTM	rgtm[1];		/* array starts here */
#endif
#endif /*CC*/
	} DLG;	/* Dialog Template */

/*****************************************************************************/

/* instances of tmtBase  (basic tm types) */
#define	tmtNull			0
#define	tmtEnd			0
#define	tmtStaticText		1
#define	tmtFormattedText	2
#define	tmtTrackingText		3
#define	tmtGroupBox		4

#define	tmtPushButton		5
#define	tmtCheckBox		6
#define	tmtRadioButton		7
#define	tmtToggleBox		8
#define	tmtToggleButton		9
#define	tmtEdit			10
#define	tmtListBox		11
#define	tmtStandardButton	12

#define	tmtDummyText		13		/* dummy static text */
#define	tmtGeneralPicture	14		/* with Render Proc */

#define	tmtNormalMax		15

#define	tmtUserMin		16
/* App / future  extensions (32 types) */
#define	tmtUserMax		48

#define	tmtSpecialMin		48
/* Special Records */
#define	tmtConditional		48

/* Extension Records (still Special) */
#define	tmtExtensionMin		61

#define	tmtExtension1		61
#define	tmtExtension2		62
#define	tmtExtension3		63

#define	tmtSpecialMax		64

#define	tmtMax			64		/* 6 bits */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\csdm.h ===
/*
	CW : Character Windows

	csdm.h : SDM global exports
-- Created Mon Aug 29 22:44:46 1988 */ 

typedef WORD TMC;		/* iTeM Codes */
typedef WORD DLM;		/* Dialog Messages */
typedef WORD TMM;		/* Control proc Messages */

/* standard item codes (tmc) */
#define	tmcNull		((TMC) 0)
#define	tmcOK		((TMC) 1)
#define	tmcOk		tmcOK
#define	tmcCancel	((TMC) 2)
#define	tmcSysMin	((TMC) 0x10)
#ifdef HELP_BUTTON
#define tmcHelp 	((TMC) tmcSysMin-1)
#endif
#define	tmcSysMax	((TMC) 0x100)
#define	tmcGrouped	0x8000		/* OR'd to specify whole group
					  as opposed to first button */
#define	tmcUserMin	tmcSysMax
#define	tmcUserMax	tmcGrouped



/* special ninch (No Input, No CHange) values */
#define	wNinch		(-32767)	/* ints */
#define	uNinch		(0xffff)	/* unsigned */
#define	iszNinchList	uNinch		/* listboxes */
#define	uNinchList	uNinch		/* other name */
#define	uNinchRadio	uNinch		/* radio groups */
#define	uNinchCheck	2		/* check boxes */
#define	wNinchCheck	uNinchCheck	/* old name */

/* special parse error values */
#define	wError		(-32766)	/* ints */
#define	uError		(0xfffe)	/* unsigneds */


/* command argument block header */
typedef struct _cabh
	{
	WORD	cwData;			/* total size of CAB less CABH */
	WORD	cagHandle;		/* # of handles */
	} CABH;

typedef void **HCAB;		/* CAB is just a concept, no real type */
typedef	void *PCAB;		/* pointer to CAB */

typedef	struct _dlg *PDLG;	/* Dialog pointer */

/* minimum CAB size : header + SAB */
#define	cwCabMin	((sizeof(CABH) + sizeof(WORD)) / sizeof(WORD))

/* Dialog Messages */
#define	dlmInit 	0	/* do custom initialization */
#define	dlmClick	1	/* item clicked */
#define	dlmChange	2	/* edit control may have changed */
#define	dlmKey		3	/* any untrapped key */
#define	dlmDblClk	4	/* double click in listbox/radio */

#define	dlmSetFocus	5	/* set focus */
#define	dlmKillFocus	6	/* lose focus */

#define	dlmTerm 	7	/* termination for one of many reasons */
#define	dlmIdle		8	/* idle for dialogs */

#define	dlmUnclick	9	/* item unclicked */

#define	dlmUserMin	16	/* for user extensions */


/* ListboxProc (pfnTm) messages */
#define	tmmCount	0	/* return number of items in listbox */
#define	tmmText 	1	/* return text associated with n'th item in listbox */
#define	tmmEditText	2	/* like msgText for Combo listboxes */

#define	cszUnknown	((WORD) -1)	/* return to tmmCount if unknown */

/* ParseProc (pfnTm) messages */
#define	tmmFormat	0	/* format data */
#define	tmmParse	1	/* parse data */
#define	tmmCwVal	2	/* return size of data in words */

/* RenderProc (pfnTm) messages */
#define	tmmPaint	0	/* paint yourself */


#define	tmmUserMin	16	/* for user extensions */


/* default no help */
#define	hidDlgNull	0	/* for no help */


/* macro to get void pointer to general CAB arg */
#define	PvParseArg(hObj, bArg) ((VOID *) (*((WORD *)(hObj)) + (bArg)))


/* Iag macro
   returns iag corresponding to field fld in application structure str
*/
#define Iag(str, fld)	((WORD)((int)&(((str *)0)->fld) / sizeof(int) - cwCabMin))


/* Globally Exported Function Definitions */
#ifdef CC

TMC		FARPUBLIC TmcDoDlg(VOID *, HCAB);
HCAB		FARPUBLIC HcabAlloc(WORD);
VOID		FARPUBLIC FreeCab(HCAB);
VOID		FARPUBLIC FreeCabData(HCAB);
VOID		FARPUBLIC SzToCab(HCAB, char *, WORD);
char *		FARPUBLIC SzFromCab(HCAB, char *, WORD, WORD);
VOID		FARPUBLIC PszToCab(HCAB, char **, WORD);	/*OPTIONAL*/

VOID		FARPUBLIC EnableTmc(TMC, BOOL);
BOOL		FARPUBLIC FEnabledTmc(TMC);
VOID		FARPUBLIC SetTmcVal(TMC, WORD);
WORD		FARPUBLIC GetTmcVal(TMC);
VOID		FARPUBLIC SetTmcSel(TMC, WORD, WORD);
VOID		FARPUBLIC GetTmcText(TMC, char *, WORD);
VOID		FARPUBLIC SetTmcText(TMC, char *);
VOID		FARPUBLIC SetFocusTmc(TMC);
VOID		FARPUBLIC RedisplayListBox(TMC);
VOID		FARPUBLIC RedisplayListBoxOriented(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC GetTmcListBoxOrientation(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC RedisplayTmc(TMC);
VOID		FARPUBLIC SetDefaultTmc(TMC);
WORD		FARPUBLIC ParseInt(WORD, char *, HANDLE, TMC, WORD, WORD); /*OPTIONAL*/
VOID		FARPUBLIC SetTmcListWidth(TMC, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetTmcEditWidth(TMC, WORD);		/*OPTIONAL*/

VOID		FARPUBLIC InitCab(HCAB, WORD);
VOID		FARPUBLIC ReinitCab(HCAB, WORD);

PWND		FARPUBLIC PwndOfListbox(TMC);
#define	TmcListBoxResetcontent(tmc)	\
	SendMessage(PwndOfListbox(tmc), LB_RESETCONTENT, 0, 0L)
#define	TmcListBoxAddstring(tmc,sz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_ADDSTRING, (WORD) sz, MAKELONG(fRedraw,0))
#define	TmcListBoxInsertstring(tmc,sz,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_INSERTSTRING,(WORD)sz, MAKELONG(fRedraw,isz))
#define	TmcListBoxDeletestring(tmc,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_DELETESTRING, 0, MAKELONG(fRedraw,isz))
#define	TmcListBoxReplacestring(tmc,sz,isz)	\
	SendMessage(PwndOfListbox(tmc), LB_REPLACESTRING, (WORD) sz, MAKELONG(0,isz))
#define TmcListBoxRepaint(tmc)	\
	SendMessage(PwndOfListbox(tmc), WM_PAINT, 0, 0L)
#define TmcGetClientRrc(tmc,prrc)	\
	GetClientRrc(PwndOfListbox(tmc), prrc)

#endif /*CC*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\dlg.h ===
//WARNING: This file contains some of the same constants as DLG.INC
//WARNING: When making a change to one, make it to both!

#include <cw/csdm.h>
#include <cw/csdmtmpl.h>

#define DLG_CONST	FAR
TMC NEAR PASCAL 	TmcDoDlgFar(VOID FAR *, WORD, HCAB);

#define isNothing	0xffff
#define HELP_BUTTON


#include <uihelpid.h>	// define help Ids for all the dialogs

#define tmcMake 	(tmcUserMin+0)
#define tmcMakeExit	(tmcUserMin+1)
#define tmcSzFileName	(tmcUserMin+2)
#define tmcFileType	(tmcUserMin+3)
			// NOTE: next one must start at +6
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\cwindows.h ===
/*
	CW : Character Windows
	cwindows.h

	CC should be defined for compilation with Cmerge.

    If defined, the following flags inhibit definition
      of the indicated constants.

    NOALL		Defines all the following:
    NOMINMAX		Macros min(a,b) and max(a,b)
    NOWND		WND / PWND typedef's or macros
    NOWINSTYLES		WS_*
    NOCOLOR		colors or ISA's
    NORECT		typedefs ARC, RRC
    NOMSG		typedef MSG
    NOWINMESSAGES	WM_*
    NOMENUS		menus
    NOMEMMGR		LMEM_*
    NODRAW		drawing macros / constants
    NOSCROLL		SB_*
    NOSUBSTYLES		BS_*, LBS_*, ES_*
    NOVIRTUALKEYCODES	VK_*
    NOMB		MB_* & ID's
    NOPROCS		procedure definitions (always for CS)
    NOWNDMACROS		window creation macros

-- Created Wed Sep 14 16:42:26 1988 */ 

#ifdef NOALL
#define NOMINMAX
#define NOWND
#define NOWINSTYLES
#define NOCOLOR
#define NORECT
#define NOMSG
#define NOWINMESSAGES
#define NOKEYSTATE
#define NOMENUS
#define NOMEMMGR
#define NODRAW
#define NOSCROLL
#define NOSUBSTYLES
#define NOVIRTUALKEYCODES
#define NOMB
#define NOWNDMACROS
#endif /*NOALL*/


#ifndef CC
/* -- Pcode Specific Definitions -- */
#ifndef EXPORT
#define	EXPORT	export
#endif
#ifndef NATIVE
#define	NATIVE	native
#endif
#else
/* -- Cmerge Compiler -- */
#ifndef CDECL
#define CDECL cdecl
#endif
#endif /*CC*/


#ifndef PASCAL
#define	PASCAL pascal
#endif

#define	FALSE	0
#define	TRUE	1
#define	NULL	0

#define	FAR	far
#define	LONG	long
#define	VOID	void
#ifdef CC
#define	NEAR	near
#else
#define NEAR
#endif

#define FARPUBLIC	FAR PASCAL		/* all interfaces FAR */

typedef unsigned char	BYTE;
typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef int		BOOL;
typedef int	(FARPUBLIC *PFN)();		/* General Procedure */
typedef BOOL	(FARPUBLIC *PFFN)();		/* BOOL Procedure */
typedef VOID	(FARPUBLIC *PVFN)();		/* Void Procedure */
typedef WORD	(FARPUBLIC *PWFN)();		/* Word Procedure */
typedef DWORD	(FARPUBLIC *PLFN)();		/* DWORD Procedure */
typedef VOID	(FARPUBLIC *LPFN)();		/* explicit FAR procedure */
typedef WORD		HANDLE;
typedef unsigned	BIT;
typedef unsigned	BITS;

/* special type for WndProc pointers */
typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(struct _wnd *, WORD, WORD, DWORD);

/* BYTE/WORD types */
#ifndef CC	/* Pcode => WORD */
typedef WORD		AX;
typedef WORD		AY;
typedef WORD		RX;
typedef WORD		RY;
typedef WORD		ISA;
#else
typedef BYTE		AX;
typedef BYTE		AY;
typedef BYTE		RX;
typedef BYTE		RY;
typedef BYTE		ISA;
#endif /*CC*/

typedef char FAR	*LPSTR;
typedef int  FAR	*LPINT;

#ifndef NOMINMAX
#define	max(a,b)	((a) > (b) ? (a) : (b))
#define	min(a,b)	((a) < (b) ? (a) : (b))
#endif

#define	MAKELONG(l, h)	((long)(((unsigned)(l)) | ((unsigned long)((unsigned)(h))) << 16))
#define MAKEWORD(l, h)	((WORD)(((BYTE)(l)) | ((WORD)((BYTE)(h))) << 8))
#define	LOWORD(l)	((WORD)(l))
#define	HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xffff))
#define	LOBYTE(w)	((BYTE) ((w) & 0xff))
#define	HIBYTE(w)	((BYTE)(((WORD)(w) >> 8) & 0xff))

/* DCHAR = Double Byte Character */
typedef	WORD		DCHAR;
/* CHAR = unsigned char */
typedef unsigned char	CHAR;

/* ACHAR = either a DCHAR or a CHAR */
typedef	CHAR		ACHAR;

/*****************************************************************************/

#ifndef NORECT
typedef struct _rrc
	{
	BYTE	rxLeft;
	BYTE	ryTop;
	BYTE	rxRight;
	BYTE	ryBottom;
	} RRC;
typedef RRC *PRRC;
typedef struct _arc
	{
	BYTE	axLeft;
	BYTE	ayTop;
	BYTE	axRight;
	BYTE	ayBottom;
	} ARC;
typedef ARC *PARC;
typedef struct _box
	{
	char	chTopLeftCorner;
	char	chTopRightCorner;
	char	chBottomLeftCorner;
	char	chBottomRightCorner;
	char	chTopSide;
	char	chBottomSide;
	char	chLeftSide;
	char	chRightSide;
	} BOX;
extern BOX PASCAL boxSingle, PASCAL boxDouble;
extern BOX PASCAL boxActiveWindowOut;
extern BOX PASCAL boxInactiveWindowOut;
extern BOX PASCAL boxActiveWindowIn;
extern BOX PASCAL boxInactiveWindowIn;
extern BYTE PASCAL axMac;
extern BYTE PASCAL ayMac;
/* all CW applications should work with screens up to 254x254 */
#define axMax 254
#define ayMax 254

#endif /*!NORECT*/

#ifndef NOWND

#ifndef cwExtraWnd
#ifdef CC
/* -- for CC compiler : fixed length */
#define cwExtraWnd 1 
#else
/* -- for CS compiler : variable length */
#define cwExtraWnd
#endif
#endif

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	ARC	arcWindow;
	ARC	arcClipping;
	PLFN_WNDPROC pfnWndProc;			/* Medium Model */
	struct _wnd *pwndParent;
	struct _wnd *pwndSibling;
	struct _wnd *pwndChild;
	BYTE	axCursor;
	BYTE	ayCursor;
	WORD	rgwExtra[cwExtraWnd];
	} WND;

typedef WND *PWND;
#endif /*!NOWND*/


extern BYTE	PASCAL	fMousePresent;		/* valid after init */

VOID		FARPUBLIC LeaveCow(BOOL);			/*OPTIONAL*/
				/* temporary leave COW */
/* Swapped Cow init/exit */
#ifdef CC
VOID		FAR CDECL exit(int);				/*OPTIONAL*/
#endif

VOID		FARPUBLIC GetProgDir(char *);			/*OPTIONAL*/

/* Non-swapped Cow init/end */
BOOL		FARPUBLIC FInitCow(void);			/*OPTIONAL*/
VOID		FARPUBLIC EndCow(WORD);				/*OPTIONAL*/


/*** mcb - mouse cursor block */
typedef struct mcb
	{
	WORD	colHot;					/* Hot Spot for								*/
	WORD	rowHot;					/*   graphics mouse cursor.				*/
	WORD	rgwAndMaskGfx[16];	/* Bit map masks for							*/
	WORD	rgwXorMaskGfx[16];	/*   graphics mouse cursor.				*/
	WORD	wAndMaskText;			/* Character and Attribute masks for	*/
	WORD	wXorMaskText;			/*   text mouse cursor.						*/
	} MCB; 

/*** mcb - mouse conditional off block */
typedef struct mcob
	{
	WORD	xLeft;
	WORD	yTop;
	WORD	xRight;
	WORD	yBottom;
	} MCOB; 

/* Key state masks for mouse messages (in wParam) */
#define	MK_LBUTTON		0x0001
#define	MK_RBUTTON		0x0002
#define	MK_SHIFT		0x0004
#define	MK_CONTROL		0x0008
#define	MK_MBUTTON		0x0010
#define	MK_NONCLIENT		0x0060	/* either X or Y outside */
#define	MK_NONCLIENT_X		0x0020
#define	MK_NONCLIENT_Y		0x0040
#define	MK_MENU			0x8000

BOOL		FARPUBLIC FEnableMouse(BOOL);
VOID		FARPUBLIC SetMouseCursor(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC MouseConditionalOff(PARC);	/*OPTIONAL*/
VOID		FARPUBLIC SetMousePos(WORD, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetMouseDoubleSpeed(WORD);		/*OPTIONAL*/
BOOL		FARPUBLIC SwapMouseButton(BOOL);		/*OPTIONAL*/
WORD		FARPUBLIC CbSizeMouseState(void);		/*OPTIONAL*/
VOID		FARPUBLIC SaveMouseState(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC RestoreMouseState(BYTE FAR *);	/*OPTIONAL*/


extern BYTE PASCAL	fShellPresent;		/* DOS 3 : SHELL.EXE hook */

HANDLE		FARPUBLIC GlobalAlloc(WORD, DWORD);		/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalFree(HANDLE);			/*OPTIONAL*/
LPSTR		FARPUBLIC GlobalLock(HANDLE);			/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalReAlloc(HANDLE, DWORD, WORD);	/*OPTIONAL*/
BOOL		FARPUBLIC GlobalUnlock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalCompact(DWORD);			/*OPTIONAL*/

DWORD		FARPUBLIC RerrExec(char *, char *, char *, BOOL, BOOL);/*OPTIONAL*/
VOID		FARPUBLIC BindSegment(PFN, BOOL);		/*OPTIONAL*/
VOID		FARPUBLIC AccessSwapFile(BOOL);			/*OPTIONAL*/

/* RerrExec return values */
#define	rerrOk		0
#define	rerrBadFile	2
#define	rerrBadPath	3
#define	rerrNoMemory	8
#define	rerrBadFormat	11
#define	rerrBadRead	30
#define	rerrBadVersion	90
#define	rerrBadMemReq	91

/* Key state masks for keyboard messages (in HIWORD(lParam)) */
#define	KK_EXTENDED		0x8000	/* from extended keypad usually */
/* shifts */
#define	KK_CAPLOCK		0x4000
#define	KK_NUMLOCK		0x2000
#define	KK_SCRLOCK		0x1000
#define	KK_ALT			0x0800
#define	KK_CONTROL		0x0400
#define	KK_SHIFT		0x0200

/* for WM_CHAR */
#define	KK_VK			0x01ff	/* mask to get untranslated VK_ */

/* for WM_KEYUP / WM_KEYDOWN */
#define	KK_SC			0x00ff	/* mask to get scan code */

extern BOOL PASCAL fAbort;			/* normal Abort */
extern BOOL PASCAL fPollKeyboard;		/* Poll the keyboard ? */
extern BYTE PASCAL fKeyIsUp, fKeyWasUp;		/* Key transitions */
extern WORD PASCAL wRateKeyRepeat;		/* repeat rate */
VOID		FARPUBLIC EnableKeyboard(BOOL);
VOID		FARPUBLIC PollKeyboard(void);
VOID		FARPUBLIC SetShiftKk(WORD);
VOID		FARPUBLIC DisableExtendedKeyboard(void);

/*****************************************************************************/
/* Extra Font info */

typedef	struct _inft
	{
	/* character/font size */
	BYTE	dxChar;			/* width of character in pixels */
	BYTE	dyChar;			/* height of character in pixels */

	BYTE	dyBaseLine;		/* base line height */
	BYTE	ifont;			/* font index */
	} INFT;

/*****************************************************************************/
/* Installable state */

typedef WORD	FINST;
#define	finstText	1		/* text mode */
#define	finstGraphics	2		/* graphics mode */
#define	finstMonochrome	4		/* monochrome */
#define	finstAlternate	8		/* alternate adapter (2nd screen) */
#define	finstFont	0x10		/* supports fonts */
#define	finstCgaSnow	0x20	/* indicate snow CGA (see user\screen.asm) */
#define	finstDisableMouse	0x1000		/* for color grpahics mode not supported by mouse (hercules)*/
#define	finstFastScroll 0x2000	/* fast scroll (BltArc) for graphics text */
#define	finstQuestionable 0x4000	/* questionable mode selection */
#define	finstAvailable	0x8000		/* available with current hardware */

typedef struct _inst
	{
	FINST	finst;
	BYTE	axMac;
	BYTE	ayMac;

	/* color palette info */
	BYTE	coMac;			/* maximum color index */
	BYTE	covMac;			/* maximum color value (palette) */
	WORD	coiMac;			/* maximum color intensity */

	/* Extra information */
	WORD	imode;			/* video mode */

	INFT	inft;			/* font info (pointers may be NULL) */
	WORD	ffontSupported;	/* valid ffont values */

	/* buffers (if non-zero then do not need to be allocated */
	WORD	psPrim;			/* primary screen buffer */
	WORD	psSec;			/* secondary screen buffer */

	WORD	cwExtra;		/* requested extra size */
	WORD	psExtra;		/* extra screen buffer (driver's use) */

	/* CW internal info */
	BIT	fAllocPrim:1;
	BITS	filler:15;

	/* Driver specific info */
	WORD	wDriver1;
	WORD	reserved2[7];
	} INST;

/* Special IMODEs */
#define	imodeUnknown	0xffff	/* unknown mode */

/*****************************************************************************/
/* Installable characters */

typedef struct _inch
	{
	/* Single Line Box */
	char	_chTopLeftCorner1;
	char	_chTopRightCorner1;
	char	_chBottomLeftCorner1;
	char	_chBottomRightCorner1;
	char	_chTopSide1;
	char	_chBottomSide1;
	char	_chLeftSide1;
	char	_chRightSide1;

	/* other single line */
	char	_chMiddleLeft1;
	char	_chMiddleRight1;

	/* Double Line Box */
	char	_chTopLeftCorner2;
	char	_chTopRightCorner2;
	char	_chBottomLeftCorner2;
	char	_chBottomRightCorner2;
	char	_chTopSide2;
	char	_chBottomSide2;
	char	_chLeftSide2;
	char	_chRightSide2;
	/*note: no middles */

	/* Arrows */
	char	_chUpArrow;
	char	_chDownArrow;
	char	_chLeftArrow;
	char	_chRightArrow;

	/* Misc */
	char	_chBullet;			/* for menu */
	char	_chMiddleDot;			/* for edit */
	char	_chScrollbar;			/* for scroll bar */
	char	_chElevator;			/* for scroll bar */
	char	_chShadowInit;			/* b&w shadow character */

	/* For Overlapping windows */
	char	_chClose;			/* Close box */
	char	_chZoomIn;			/* Zoom in */
	char	_chZoomOut;			/* Zoom out */
	char	_chUpDownArrow;			/* double arrow */
	char	_chLeftRightArrow;		/* double arrow */

	WORD	reserved[16];
	} INCH;

/*****************************************************************************/
/* font variations */

#define	ffontNormal		0x0000	/* normal attributes */

#define	ffontUnderline		0x0001
#define	ffontDoubleUnderline	0x0002
#define	ffontOrUnderline	0x0003	/* ... underline */
#define	ffontStrikeThrough	0x0004	/* horizontal strike through */
#define	ffontBold		0x0008
#define	ffontSubscript		0x0010
#define	ffontSuperscript	0x0020
#define	ffontMiniCap		0x0030	/* mini capital */
#define	ffontItalic		0x0040
#define	ffontOrCharacter	0x0080	/* extra field => font extension */
#define	ffontReservedBits	0x0f00
#define	ffontExtraMask		0xf000	/* one of 16 extra items */
#define	ffontOrUnderlineSupport	0x1000

/*****************************************************************************/
/* screen save info */

typedef WORD	FVIDS;			/* flags */
#define	fvidsChAttr	1		/* video buffer is in form ch:attr */

typedef	struct _vids
	{
	BYTE	mode;			/* screen mode */
	BYTE	page;			/* page # */
	FVIDS	fvids;			/* flags for saved state */
	WORD	cwVidData;		/* # of bytes of screen data */
	WORD	cwExtra;		/* # of extra bytes for mode info */
	WORD	rgwExtra[1];		/* actually rgwExtra[cwExtra] */
	} VIDS;	/* Video state */

/*****************************************************************************/

#define	fmemFixed	1		/* always set !! */
#define	fmemNear	2		/* allocate near */

/* limit of near space / driver service */
#define	cbNearMemServiceMax	128

/* INDT: Driver Service Types */
#define	indtNil			0
#define	indtKeyboard		1			/* .KBD */
#define	indtCharacterScreen	2			/* .CSD */
#define	indtGraphicScreen	3			/* .GSD */
#define	indtCharacterPrinter	4			/* .PRD */
#define	indtGraphicPrinter	5			/* .GPD */
#define	indtSystem		6			/* .SYD */
#define	indtSerialComm		7			/* .SCD */
/* ... others to be defined ... */

typedef struct _indv
	{
	/* input values */
	BYTE	indt;				/* service wanted */
	BYTE	filler;				/* reserved */
	LPFN *	rglpfn;				/* where to put vectors */
	WORD	cpfnNeedMin;			/* # entries needed */
	WORD	cpfnNeedMac;			/* # entries wanted */
	/* return values */
	WORD	psLoaded;			/* != 0 => loaded */
	WORD	cpfnLoaded;			/* # entries loaded */
	} INDV;

WORD	FARPUBLIC RerrLoadDrv(char *, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrv(char *);		/* OPTIONAL */


extern INST PASCAL instCur;
extern INCH PASCAL inch;		/* near buffer for characters */
extern BOOL PASCAL fFontAvailable;	/* extra "ffont" drawing available ? */

/* name aliases for the actual characters */
#define	chTopSide1		(inch._chTopSide1)
#define	chBottomSide1		(inch._chBottomSide1)
#define	chLeftSide1		(inch._chLeftSide1)
#define	chRightSide1		(inch._chRightSide1)
#define	chTopLeftCorner1	(inch._chTopLeftCorner1)
#define	chTopRightCorner1	(inch._chTopRightCorner1)
#define	chBottomLeftCorner1	(inch._chBottomLeftCorner1)
#define	chBottomRightCorner1	(inch._chBottomRightCorner1)
#define chMiddleLeft1		(inch._chMiddleLeft1)
#define chMiddleRight1		(inch._chMiddleRight1)
#define	chTopSide2		(inch._chTopSide2)
#define	chBottomSide2		(inch._chBottomSide2)
#define	chTopLeftCorner2	(inch._chTopLeftCorner2)
#define	chTopRightCorner2	(inch._chTopRightCorner2)
#define	chBottomLeftCorner2	(inch._chBottomLeftCorner2)
#define	chBottomRightCorner2	(inch._chBottomRightCorner2)
#define	chUpArrow		(inch._chUpArrow)
#define	chDownArrow		(inch._chDownArrow)
#define	chRightArrow		(inch._chRightArrow)
#define	chLeftArrow		(inch._chLeftArrow)
#define	chBullet		(inch._chBullet)
#define	chMiddleDot		(inch._chMiddleDot)
#define	chScrollbar		(inch._chScrollbar)
#define	chElevator		(inch._chElevator)
#define	chShadowInit		(inch._chShadowInit)

/* for overlapping windows */
#define	chClose			(inch._chClose)
#define	chZoomIn		(inch._chZoomIn)
#define	chZoomOut		(inch._chZoomOut)
#define	chUpDownArrow		(inch._chUpDownArrow)
#define	chLeftRightArrow	(inch._chLeftRightArrow)

/*****************************************************************************/
/* Screen Procedures */

typedef WORD FAR *	(FAR PASCAL *LPFN_DRV_ALLOC)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_DRV_FREE)(WORD FAR *);

WORD	FARPUBLIC ImodeGuessCurrent(void);			/*OPTIONAL*/
BOOL	FARPUBLIC FQueryInst(INST *, WORD);			/*OPTIONAL*/
BOOL	FARPUBLIC FAllocInstBuffers(INST *, LPFN_DRV_ALLOC, BOOL); /*OPTIONAL*/
VOID	FARPUBLIC FreeInstBuffers(INST *, LPFN_DRV_FREE);	/*OPTIONAL*/

BOOL	FARPUBLIC FAllocOverlapTable(INST *, LPFN_DRV_ALLOC);	/*OPTIONAL*/
VOID	FARPUBLIC FreeOverlapTable(LPFN_DRV_FREE);		/*OPTIONAL*/

BOOL	FARPUBLIC FInitScreen(INST *);				/*OPTIONAL*/
VOID	FARPUBLIC EndScreen(BOOL);				/*OPTIONAL*/

BOOL	FARPUBLIC FGetColorPalette(WORD, WORD *, WORD *);	/*OPTIONAL*/
VOID	FARPUBLIC SetColorPalette(WORD, WORD, WORD *);		/*OPTIONAL*/

VOID	FARPUBLIC MoveHwCursCsd(AX, AY, WORD);			/*OPTIONAL*/

BOOL	FARPUBLIC FQueryInft(INFT *, WORD);			/*OPTIONAL*/

WORD	FARPUBLIC CbSizeVids(void);				/*OPTIONAL*/
BOOL	FARPUBLIC FSaveVids(VIDS *, INST *);			/*OPTIONAL*/
BOOL	FARPUBLIC FRestoreVids(VIDS *);				/*OPTIONAL*/
VOID	FARPUBLIC SaveVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC RestoreVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC EnableVidsMonitor(BOOL);			/*OPTIONAL*/

VOID	FARPUBLIC GetCharMap(INFT *, BYTE, BYTE *);


WORD		FARPUBLIC MessageBox(char *, char *, char *, WORD);
VOID		FARPUBLIC SetDialogCaption(HANDLE, char *);
VOID		FARPUBLIC HiliteDialogAccel(void);

/* Message Box Definitions */

#ifndef NOMB
#define	IDDEFAULT		1
#define	IDCANCEL		2
#define	IDNO			3
#define	IDOK			IDDEFAULT
#define	IDYES			IDDEFAULT
#define	IDRETRY			IDDEFAULT
#define	IDABORT			IDDEFAULT
#ifdef	HELP_BUTTON
#define IDHELP			4
#endif	// HELP_BUTTON
#define	MB_OK			1
#define	MB_YESNOCANCEL		2
#define	MB_RETRYCANCEL		3
#define	MB_OKCANCEL		4
#define	MB_ABORT		5
#define MB_YESNO		6
#define MB_RETRY		7
#define	MB_TYPE			0x0f		/* message type */
#define MB_BEEP			0x10
#define MB_CAPTION		0x20		/* 1st param is caption */
#ifdef	HELP_BUTTON
#define MB_NOHELP		0x8000
#endif	// HELP_BUTTON
#endif /*!NOMB*/

/* for Special MessageBox */
extern BYTE FAR * PASCAL lpbWorkTemp;	/* App should never use directly */

#define	InitSpecialMessageBox(lpbBuff)	\
	{				\
	Assert(lpbWorkTemp == NULL);	\
	lpbWorkTemp = (lpbBuff);	\
	}

#define	EndSpecialMessageBox()		\
	{				\
	Assert(lpbWorkTemp != NULL);	\
	lpbWorkTemp = NULL;		\
	}



#ifndef NOWNDMACROS

#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT | (fBorder ? WS_BORDER : 0), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{((fBorder) ? ax+1 : ax), (fBorder ? ay+1 : ay), \
	 ((fBorder) ? ax+dax-1 : ax+dax), (fBorder ? ay+day-1 : ay+day)}, \
	(PLFN) InternalEditWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 (WORD) szBuf}}
/* InternalEditWndProc must be forward defined for CS compiler */
DWORD 		FARPUBLIC InternalEditWndProc(PWND, WORD, WORD, DWORD);

#endif /* !NOWNDMACROS */

/* for selection (SetTmcSel) */
#define	ichSelectEnd	(0x7fff)		/* select to end */


VOID		FARPUBLIC SetEditText(PWND, char *, BOOL);
VOID		FARPUBLIC SetEditWidth(PWND, WORD);	/* OPTIONAL */
WORD		FARPUBLIC GetEditText(PWND, char *, WORD);
DWORD		FARPUBLIC EditWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC DefaultEditMgrInit(VOID);	/* OPTIONAL */

#define EN_CHANGE			1
#define EN_CURSORMOVED			2


#ifndef NOMSG
/* Message structure */
typedef struct _msg
	{
	PWND	pwnd;
	WORD	message;
	WORD	wParam;
	DWORD	lParam;
	DWORD	time;
	} MSG;
typedef MSG *PMSG;
#ifndef DOS5
extern BOOL PASCAL fMessage;
#ifdef DUAL
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((DWORD) (DWORD FAR *) &semaMessage)
#endif /*DUAL*/
#else
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((DWORD) (DWORD FAR *) &semaMessage)
#endif
#endif /*!NOMSG*/


#ifndef NOWINMESSAGES
/* Window Messages */
#define	WM_NULL			0x0000
#define	WM_CREATE		0x0001
#define	WM_WANTFOCUS		0x0005
#define	WM_MAKEACTIVE		0x0006
#define	WM_SETFOCUS		0x0007
#define	WM_KILLFOCUS		0x0008
#define	WM_PAINT		0x000f
#define	WM_QUIT			0x0012

#define	WM_KEYFIRST		0x0100
#define WM_KEYLAST		0x0102

#define	WM_KEYDOWN		0x0100
#define	WM_KEYUP		0x0101
#define	WM_CHAR			0x0102

#define	WM_CUT			0x0103
#define	WM_PASTE		0x0104
#define	WM_COPY			0x0105
#define	WM_INSERT		0x0106

#define	WM_MENUIDLE		0x0110		/* Menu Idle */
#define	WM_COMMAND		0x0111
#define	WM_MENUSELECT		0x0112		/* selecting a menu item */
#define	WM_MENUSTART		0x0113		/* starting a menu action */
#define	WM_HSCROLL		0x0114
#define	WM_VSCROLL		0x0115
#define	WM_INITMENUPOPUP	0x0116
#define	WM_ALARM		0x0117

#define	WM_MOUSEFIRST		0x0200
#define	WM_LMOUSELAST		0x0203	/* last of Left mouse actions */
#define	WM_MOUSELAST		0x0206

#define	WM_MOUSEMOVE		0x0200	/* mouse related constants */
#define	WM_LBUTTONDOWN		0x0201
#define	WM_LBUTTONUP		0x0202
#define	WM_LBUTTONDBLCLK	0x0203
#define	WM_RBUTTONDOWN		0x0204
#define	WM_RBUTTONUP		0x0205
#define	WM_RBUTTONDBLCLK	0x0206

/* Edit Wnd Proc Messages */
#define EM_SETSEL		0x0300
#define EM_GETSEL		0x0301

/* Overlap Wnd Proc Messages */
#define WM_ACTIVATE	0x0320
#define WM_ZOOM		0x0321
#define WM_CLOSE	0x0322
#define WM_MOVE		0x0323
#define WM_SIZE		0x0324


/*WM-DIALOG is actually private (and LB_SETWIDTH)*/
#define WM_DIALOG		0x0380
/* Listbox Proc Messages */
#define WM_LISTBOX_COMMAND	WM_DIALOG
#define LB_RESETCONTENT		0x0340
#define LB_ADDSTRING		0x0341
#define LB_DELETESTRING		0x0342
#define LB_SETCURSEL		0x0343
#define LB_GETCURSEL		0x0344
#ifdef LISTBOX_HORIZ
#define LB_SETWIDTH		0x0345
#endif /*LISTBOX_HORIZ*/
#define LB_GETTEXT		0x0346
#define LB_GETCOUNT		0x0347
#define LB_REPLACESTRING	0x0348
#define LB_INSERTSTRING		0x0349

/* private window messages start here */
#define	WM_USER			0x0400
#endif

/* Window's aliases for KK_ states */
#define	KK_MENU			KK_ALT
#define	KK_CAPITAL		KK_CAPLOCK

/* HELP */
#define	VK_HELP_KEY		VK_F1

/* listbox notification codes */
#define LBN_SELCHANGE		0
#define LBN_DBLCLK		1
#define LBN_SELECT_DONE		2


/* List Box Selection Codes */
#define lbrCause		0xf
#define lbrNone			0
#define lbrMouse		1
#define lbrScroll		2
#define lbrKeys			3
#define lbrSpace		4
#define lbrOther		5
#define flbrReselect		0x10


/* help types/contexts */
#define	hemMenu			1
#define	hemMenuItem		2
#define	hemMbox			3
#define	hemDialog		4
#define	hemUserMin		0x10		/* For Application contexts */

/* help id's for message boxes */
#ifndef NOMB
#define	hidMboxOk		MB_OK
#define	hidMboxYesNoCancel	MB_YESNOCANCEL
#define	hidMboxRetryCancel	MB_RETRYCANCEL
#define	hidMboxOkCancel		MB_OKCANCEL
#define	hidMboxAbort		MB_ABORT
#define hidMboxYesNo		MB_YESNO
#define hidMboxRetry		MB_RETRY
#endif /*!NOMB*/

VOID		FARPUBLIC SetAlarm(PWND, WORD);
VOID		FARPUBLIC KillAlarm(void);
VOID		FARPUBLIC UngetMessage(PMSG);
BOOL		FARPUBLIC PeekMessage(PMSG);
PWND		FARPUBLIC GetFocus(void);
PWND		FARPUBLIC SetFocus(PWND);
VOID		FARPUBLIC FlushAbort(void);
PWND		FARPUBLIC SetCapture(PWND);
VOID 		FARPUBLIC ReleaseCapture(void);
DWORD		FARPUBLIC DispatchMessage(PMSG);
BOOL		FARPUBLIC PostMessage(PWND, WORD, WORD, DWORD);
DWORD		FARPUBLIC SendMessage(PWND, WORD, WORD, DWORD);
WORD		FARPUBLIC SetDoubleClickTime(WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SynthesizeShiftKeys(WORD, WORD);	/*OPTIONAL*/

#ifndef NOCOLOR

/*	* General colors */
#define	isaBackground		0

#define	isaHilite		1		/* hilite / inversion */
#define	isaGreyed		2		/* not currently used */
#define	isaEnabled		3
#define	isaDisabled		4
#define	isaAlert		5

/*	* Dialog elements :	*/
#define	isaDialogBox		6	/* the actual dialog box */
#define isaStatic		isaDialogBox	/* static text */
#define isaButton		isaDialogBox	/* radio/check buttons */
#define isaPushButton		7		/* push buttons */
#define isaButtonDown		8		/* pushed button */
#define isaListBox		9		/* listbox background */
#define isaEdit			isaDialogBox

/*	* Scroll Bars :		*/
#define isaScrollbar		10
#define isaElevator		11

/*	* Menus :		*/
#define isaMenuBox		12		/* box around pull downs */
#define	isaMenu			13		/* non-selected MENU */
#define isaMenuSelected		14		/* selected menu item */
#define	isaMenuHilite		15		/* hilited character */
/* hilited character under selection */
#define	isaMenuHiliteSel	16		/* for menu titles */
#define	isaItemHiliteSel	17		/* for menu items */

#define	isaDialogAccel		18		/* dialog accelerators */

/*	* Shadows :		*/
#define	isaShadow		19

/* User Colors :		*/
#define	isaUserMin		20
#define	isaUserMax		(isaUserMin+16)
#define isaMax			isaUserMax

#endif /*!NOCOLOR*/

#ifndef NOMENUS
/* hack for nameless unions in CC */
#ifdef CC
#define CC_USZ u
#define CC_URG u
#else
#define CC_USZ
#define CC_URG
#endif


typedef struct _mpvkeyid
	{
	WORD	vkey;
	WORD	idItem;
	} MPVKEYID;
#define VkeyOfVkKk(vk, kk)	((vk) | (kk))
typedef struct _menuitem
	{
	WORD	idItem;			/* id for menuitem */
	BITS	fEnabled:1;		/* TRUE => enabled, FALSE => greyed */
	BITS	fChecked:1;		/* TRUE => checked */
	BITS	fSeparator:1;		/* TRUE => separator */
	BITS	fHandle:1;		/* TRUE => use pszItem, else szItem */
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	bParamUser:8;		/* available for application use */
	union
		{
		char *szItem;
		char **pszItem;
		} CC_USZ;
	WORD	wParamUser;		/* available for application use */
	} MENUITEM;
typedef struct _menu
	{
	WORD	idMenu;
	BITS	rxTitle:8;
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	fHandle:1;
	BITS	fEnabled:1;		/* is menu 'enabled' (not greyed) */
	BITS	filler:2;
	WORD	cchTitle;
	char	*pchTitle;
	WORD	citem;
	WORD	cchitemMax;
	union
		{
		MENUITEM *rgmenuitem;
		MENUITEM **prgmenuitem;
		} CC_URG;
	WORD	wParamUser;		/* available for application use */
	} MENU;
typedef struct _menubar
	{
	WORD	cmenu;
	MENU	*rgmenu;
	MPVKEYID *rgmpvkeyid;
	} MENUBAR;

typedef MENU *PMENU;
typedef MENUITEM *PMENUITEM;
typedef MENUBAR *PMENUBAR;

/* menu item define macros :
	D => disabled
	H => string handle
	X => with index (otherwise default to 0)
*/

/* enabled simple item */
#define menuitem(mid, sz, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemD(mid, sz, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemDH(mid, psz, w) {(mid), FALSE, FALSE, FALSE, TRUE,\
	0, 0, {(char *)(psz)}, (WORD)(w)},
#define menuitemX(mid, sz, ich, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
#define menuitemDX(mid, sz, ich, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
/* separator */
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0},

#endif /*!NOMENUS*/

VOID		FARPUBLIC InitMenu(PWND, PMENUBAR);
BOOL		FARPUBLIC FEnableMenuBar(BOOL);
VOID		FARPUBLIC EnableMenu(WORD, BOOL);
VOID		FARPUBLIC EnableMenuItem(WORD, BOOL);
VOID		FARPUBLIC CheckMenuItem(WORD, BOOL);
BOOL		FARPUBLIC FMenuItemChecked(WORD);
PMENUITEM	FARPUBLIC FindMenuItem(WORD);
VOID		FARPUBLIC DrawMenubar(void);
VOID		FARPUBLIC OpenMenu(WORD);		/*OPTIONAL*/


#ifndef NOCOLOR
#define	DiMake(dm, isa)		((WORD) ((dm) | (isa)))

/*	-- non-special modes --	*/
#define	dmNormal		0
#define	DiNormal(isa)		((WORD) dmNormal | (isa))
#define	dmText			0x100
#define	dmTextOnly		dmText
#define	dmForeBack		0x200
#define	dmAttrOnly		dmForeBack
#define	dmFore			0x300
#define	dmBack			0x400
#define	dmTextFore		0x500
#define	dmTextBack		0x600

/*	-- special modes --	*/
#define	dmSpecialMin		0x700
#define	dmTextMapB		0x700
#define	dmTextMapF		0x800
#define	dmMapB			0x900
#define	dmMapF			0xA00

/* special FFONT control */
#define	fdmKeepFfont		0x8000

#endif /*!NOCOLOR*/

extern BYTE PASCAL fMonochrome;		/* TRUE => monochrome screen */
extern char PASCAL chShadow;		/* shadow character */
extern WORD PASCAL diShadow;		/* shadow draw mode, 0 => no shadow */
VOID		FARPUBLIC SetCursorBlock(BOOL);


#ifndef NOSUBSTYLES
/* Scroll bar constants */
#define	SBS_HORZ			0
#define	SBS_VERT			1
#endif /*!NOSTYLES*/


#ifndef NOSCROLL

/* Scroll Commands */
#define	SB_LINEUP		0
#define	SB_LINEDOWN		1
#define	SB_PAGEUP		2
#define	SB_PAGEDOWN		3
#define	SB_THUMBPOSITION	4
#define	SB_THUMBTRACK		5
#define	SB_TOP			6
#define	SB_BOTTOM		7
#define SB_ENDSCROLL		8
/* define SB_UPCLICK 15 (private message) */
#endif /*!NOSCROLL*/


#ifndef NOWNDMACROS

DWORD		FARPUBLIC ScrollBarWndProc(PWND, WORD, WORD, DWORD);

#ifdef CC
#ifndef cwExtraWnd
#define cwExtraWnd 5
#endif /*no extra size*/
#endif /*CC*/
#define wndScrollBar(id, fVert, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, ctickRep) { \
	id, WS_CHILD | WS_SCROLL | (fVert ? SBS_VERT : SBS_HORZ), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, {ax, ay, ax+dax, ay+day}, \
	(PLFN) ScrollBarWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{ctickRep, 0, 0, 1, 1}}

#endif /* !NOWNDMACROS */

short		FARPUBLIC SetScrollPos(PWND, short, BOOL);
short		FARPUBLIC GetScrollPos(PWND);
VOID		FARPUBLIC SetScrollRange(PWND, short, short, BOOL);


VOID		FARPUBLIC AddChild(PWND, PWND);
VOID		FARPUBLIC RemoveChild(PWND);
VOID		FARPUBLIC EnableWindow(PWND, BOOL);
VOID		FARPUBLIC GetClientRrc(PWND, RRC *);
VOID		FARPUBLIC SetWindowStyle(PWND, WORD);
VOID		FARPUBLIC SetWindowSize(PWND, BYTE, BYTE);
VOID		FARPUBLIC DrawWindow(PWND);
VOID		FARPUBLIC DrawBorder(PWND, BOX *, WORD, char *);
VOID		FARPUBLIC TextOut(PWND, RX, RY, char *, short, WORD);
VOID		FARPUBLIC CharOut(PWND, RX, RY, ACHAR, WORD);
VOID		FARPUBLIC FillRrc(PWND, PRRC, ACHAR, WORD);
VOID		FARPUBLIC BltRrc(PWND, RX, RY, BYTE, BYTE, RX, RY);
VOID		FARPUBLIC DrawBox(PWND, PRRC, BOX *, WORD);
VOID		FARPUBLIC SaveRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC RestoreRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC EnableCursor(PWND, BOOL);
VOID		FARPUBLIC MoveCursor(PWND, RX, RY);
VOID		FARPUBLIC MoveWindow(PWND, AX, AY);
BOOL		FARPUBLIC IntersectRect(PRRC, PRRC, PRRC);
VOID		FARPUBLIC UnionRect(PRRC, PRRC, PRRC);
BOOL		FARPUBLIC IsRectEmpty(PRRC);
VOID		FARPUBLIC SetRect(PRRC, RX, RY, RX, RY);
BOOL		FARPUBLIC PtInRect(PRRC, RX, RY);
WORD		FARPUBLIC CwSizeRrc(PRRC);
VOID		FARPUBLIC ShadowArc(PARC);
/*	* for overlap windows */
VOID		FARPUBLIC AddChildHead(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC AddChildTail(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC RethinkDisplay(void);			/*OPTIONAL*/
BOOL		FARPUBLIC FWindowToTop(PWND);            	/*OPTIONAL*/
VOID		FARPUBLIC RedrawDamagedRegions(void);		/*OPTIONAL*/
BOOL		FARPUBLIC FMoveSizeWithKeyboard(PWND, BOOL);	/*OPTIONAL*/
BOOL		FARPUBLIC FIsTopWindow(PWND);			/*OPTIONAL*/
PWND		FARPUBLIC PwndGetTopWindow(PWND);		/*OPTIONAL*/
VOID		FARPUBLIC DrawOverlapShadow(PWND);		/*OPTIONAL*/
/*	Listbox routines */
DWORD		FARPUBLIC ListBoxWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC InitListBox(PWND, PWFN);		/*OPTIONAL*/
VOID		FARPUBLIC InitListBoxOriented(PWND, PWFN, WORD *, WORD *);/*OPTIONAL*/
VOID		FARPUBLIC GetListBoxOrientation(PWND, WORD *, WORD *);/*OPTIONAL*/
#define FMoveOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,TRUE);
#define FSizeOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,FALSE);

#ifndef NORECT
#define CopyRect(prrcDest, prrcSrc) {*(prrcDest) = *(prrcSrc) }
#define SetRectEmpty(prrc) {*((long *) prrc) = 0; }
#endif /*!NORECT*/

#ifndef NOWNDMACROS

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0,

#define wndGenericCursor(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs) { \
	id, style, TRUE, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs,
		
#define endWndGeneric }

#define wndListBox(id,fBorder,fSorted,fEnabled,ax,ay,dax,day,pfnWndProc,pwndParent,pwndSibling,pwndChild,color,isaHilite,ctickRep) { \
	id, (WS_CHILD | WS_LISTBOX | WS_VSCROLL | \
             (fSorted ? LBS_SORT : 0) | (fBorder ? WS_BORDER : 0)), \
	TRUE, fEnabled, {ax, ay, ax+dax, ay+day},                   \
	{ (fBorder ? ax+1 : ax),                                    \
	  (fBorder ? ay+1 : ay),                                    \
	  ((TRUE)  ? ax+dax-1 : ax+dax),                      \
	  (fBorder ? ay+day-1 : ay+day)     }, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling,      \
	pwndChild, \
        (fBorder ? ax+2 : ax+1), 1 \
 	,{0,0,0,0,0,0,0,0,0,1,0,0,color,isaHilite,ctickRep,0} }

#define	SetWindowProc(pwnd, pfn) {(pwnd)->pfnWndProc = pfn;}
#define	GetWindowWord(pwnd, iw) ((pwnd)->rgwExtra[(iw)])
#define	SetWindowWord(pwnd, iw, w) {(pwnd)->rgwExtra[(iw)] = (w);}
#define	PwndParent(pwnd) ((pwnd)->pwndParent)
#define	PwndChild(pwnd) ((pwnd)->pwndChild)
#define	PwndSibling(pwnd) ((pwnd)->pwndSibling)

#endif /*NOWNDMACROS*/

#ifndef NODRAW
/* Window Drawing support */
#define	AxOfRx(pwnd,rx) ((pwnd)->arcClipping.axLeft+(rx))
#define	AyOfRy(pwnd,ry) ((pwnd)->arcClipping.ayTop+(ry))
#define	RxOfAx(pwnd,ax) ((ax)-(pwnd)->arcClipping.axLeft)
#define	RyOfAy(pwnd,ay) ((ay)-(pwnd)->arcClipping.ayTop)
#define CbSizeRrc(prrc) (CwSizeRrc(prrc) << 1)
#endif /*!NODRAW*/

#ifndef NOWINSTYLES
/* Window styles */
#define	WS_TILED		0x0000
#define	WS_CHILD		0x0000	/* note : no distinction */

#define	WS_BORDER		0x0100
#define	WS_VSCROLL		0x0200
#define	WS_HSCROLL		0x0400
#define WS_SUBSTYLE		0x003f

#define WS_OVERLAP		0x0040
#define WS_CLIPOUT		0x0080

#define WS_TYPE 		0x3800	/* type mask */
#define WS_EDIT			0x0800
#define WS_LISTBOX		0x1000
#define WS_BUTTON		0x1800
#define WS_STATIC		0x2000
#define WS_DIALOG		0x2800
#define WS_SCROLL		0x3000
#define WS_STATIC_NOACCEL	0x3800

#define LBS_SORT		0x0001
#endif /*!NOWINSTYLES*/

/* codes for listbox item indices */
#define	iszMin	((WORD)	0)
#define	iszNil	((WORD)	-1)		/* invalid isz */


/* System Specifics */
VOID		FARPUBLIC DoSound(WORD);
DWORD		FARPUBLIC ClockTicks(void);


extern BYTE PASCAL	fSingleFloppy;	/* TRUE => 1 floppy system */
extern BYTE PASCAL	fInt24Error;	/* Set if INT 24 error detected */

/* Sound Facilities */
#define	Beep()		DoSound(0)
#define	Click()		DoSound(1)

BOOL		FARPUBLIC FValidDrive(char);
#ifndef NOVIRTUALKEYCODES	
#define	VK_MIN		0x100

#define	VK_LBUTTON	0x101
#define	VK_RBUTTON	0x102
#define	VK_CANCEL	0x103
#define	VK_MBUTTON	0x104	/* NOT contiguous with L & RBUTTON */
#define	VK_BACK		0x108
#define	VK_TAB		0x109
#define	VK_CLEAR	0x10C
#define	VK_RETURN	0x10D
#define	VK_SHIFT	0x110
#define	VK_CONTROL	0x111
#define	VK_ALT		0x112
#define	VK_PAUSE	0x113
#define	VK_CAPLOCK	0x114

/* special VK_s for Kanji and Kana-Kanji conversion */
#define	VK_KANA		0x115
#define	VK_ROMAJI	0x116
#define	VK_ZENKAKU	0x117
#define	VK_HIRAGANA	0x118
#define	VK_KANJI	0x119
/* note: hole for 1A and 1B */
#define	VK_CONVERT	0x11C
#define	VK_NONCONVERT	0x11D
#define	VK_ACCEPT	0x11E
#define	VK_MODECHANGE	0x11F

#define	VK_ESCAPE	0x11B
#define	VK_SPACE	0x120

#define	VK_PRIOR	0x121
#define	VK_NEXT		0x122
#define	VK_END		0x123
#define	VK_HOME		0x124
#define	VK_LEFT		0x125
#define	VK_UP		0x126
#define	VK_RIGHT	0x127
#define	VK_DOWN		0x128

#define	VK_0		0x130
/* 1..8 */
#define	VK_9		0x139
#define	VK_A		0x141
/* B..Y */
#define	VK_Z		0x15A

#define	VK_SELECT	0x129
#define	VK_PRINT	0x12A
#define	VK_EXECUTE	0x12B
#define	VK_INSERT	0x12D
#define	VK_DELETE	0x12E
#define	VK_HELP		0x12F

#define	VK_NUMPAD0	0x160
#define	VK_NUMPAD1	0x161
#define	VK_NUMPAD2	0x162
#define	VK_NUMPAD3	0x163
#define	VK_NUMPAD4	0x164
#define	VK_NUMPAD5	0x165
#define	VK_NUMPAD6	0x166
#define	VK_NUMPAD7	0x167
#define	VK_NUMPAD8	0x168
#define	VK_NUMPAD9	0x169
#define	VK_MULTIPLY	0x16A
#define	VK_ADD		0x16B
#define	VK_SEPARATOR	0x16C
#define	VK_SUBTRACT	0x16D
#define	VK_DECIMAL	0x16E
#define	VK_DIVIDE	0x16F

#define	VK_F1		0x170
#define	VK_F2		0x171
#define	VK_F3		0x172
#define	VK_F4		0x173
#define	VK_F5		0x174
#define	VK_F6		0x175
#define	VK_F7		0x176
#define	VK_F8		0x177
#define	VK_F9		0x178
#define	VK_F10		0x179
#define	VK_F11		0x17A
#define	VK_F12		0x17B
#define	VK_F13		0x17C
#define	VK_F14		0x17D
#define	VK_F15		0x17E
#define	VK_F16		0x17F

#define VK_OAX		0x180

#define	VK_NUMLOCK	0x190
#define	VK_SCRLOCK	0x191

/* alternative names */
#define	VK_MENU		VK_ALT
#define	VK_CAPITAL	VK_CAPLOCK
#define	VK_OEM_NUMBER	VK_NUMLOCK
#define	VK_OEM_SCROLL	VK_SCRLOCK
#define	VK_SEPARATER	VK_SEPARATOR

#endif /*!NOVIRTUALKEYCODES*/	

BOOL		FARPUBLIC FIsDbcsChar(ACHAR);		/* OPTIONAL */
WORD		FARPUBLIC CchLenDbcs(char *);		/* OPTIONAL */
char *		FARPUBLIC PchNextDbcs(char *);		/* OPTIONAL */
char *		FARPUBLIC PchPrevDbcs(char *, char *);	/* OPTIONAL */


#define	SetSysColor(isa, coBack, coFore, fBlink, fHilite) \
	SetIsaColor(isa,				\
 	    (coFore) + ((fHilite) ? 8 : 0),	\
 	    (coBack) + ((fBlink) ? 8 : 0))

VOID		FARPUBLIC SetIsaColor(ISA, WORD, WORD);
VOID		FARPUBLIC GetIsaColor(ISA, WORD *, WORD *);
VOID		FARPUBLIC SetIsaRgca(ISA, BYTE *);
VOID		FARPUBLIC SetIsaFfont(ISA, WORD);		/*OPTIONAL*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\dlg.inc ===
;WARNING: This file contains some of the same constants as DLG.H
;WARNING: When making a change to one, make it to both!

isNothing	EQU	0ffffh

tmcMake 	EQU	(tmcUserMin+0)
tmcMakeExit	EQU	(tmcUserMin+1)
tmcSzFileName	EQU	(tmcUserMin+2)
tmcFileType	EQU	(tmcUserMin+3)
			; NOTE: next one must start at +6
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\cwindows.inc ===
;*
;*	CW : Character Windows
;*
;*	cwindows.inc : public include file for CW routines/structures
; Created Mon Aug 29 22:45:00 1988 */ 

pwndMsg		equ	[word ptr 00000h]
messageMsg	equ	[word ptr 00002h]
wParamMsg	equ	[word ptr 00004h]
lParamMsg	equ	[dword ptr 00006h]
LO_lParamMsg	equ	[word ptr 00006h]
HI_lParamMsg	equ	[word ptr 00008h]
timeMsg		equ	[dword ptr 0000Ah]
LO_timeMsg		equ	[word ptr 0000Ah]
HI_timeMsg		equ	[word ptr 0000Ch]
cbMsgMin	equ	0000Eh
WM_NULL		equ	00000h
WM_CREATE	equ	00001h
WM_WANTFOCUS	equ	00005h
WM_MAKEACTIVE	equ	00006h
WM_SETFOCUS	equ	00007h
WM_KILLFOCUS	equ	00008h
WM_PAINT	equ	0000Fh
WM_QUIT		equ	00012h
WM_KEYFIRST	equ	00100h
WM_KEYLAST	equ	00102h
WM_KEYDOWN	equ	00100h
WM_KEYUP	equ	00101h
WM_CHAR		equ	00102h
WM_CUT		equ	00103h
WM_PASTE	equ	00104h
WM_COPY		equ	00105h
WM_INSERT	equ	00106h
WM_MENUIDLE	equ	00110h
WM_COMMAND	equ	00111h
WM_MENUSELECT	equ	00112h
WM_MENUSTART	equ	00113h
WM_HSCROLL	equ	00114h
WM_VSCROLL	equ	00115h
WM_INITMENUPOPUP	equ	00116h
WM_ALARM	equ	00117h
WM_MOUSEFIRST	equ	00200h
WM_LMOUSELAST	equ	00203h
WM_MOUSELAST	equ	00206h
WM_MOUSEMOVE	equ	00200h
WM_LBUTTONDOWN	equ	00201h
WM_LBUTTONUP	equ	00202h
WM_LBUTTONDBLCLK	equ	00203h
WM_RBUTTONDOWN	equ	00204h
WM_RBUTTONUP	equ	00205h
WM_RBUTTONDBLCLK	equ	00206h
EM_SETSEL	equ	00300h
EM_GETSEL	equ	00301h
WM_ACTIVATE	equ	00320h
WM_ZOOM		equ	00321h
WM_CLOSE	equ	00322h
WM_MOVE		equ	00323h
WM_SIZE		equ	00324h
WM_DIALOG	equ	00380h
WM_LISTBOX_COMMAND	equ	WM_DIALOG
LB_RESETCONTENT	equ	00340h
LB_ADDSTRING	equ	00341h
LB_DELETESTRING	equ	00342h
LB_SETCURSEL	equ	00343h
LB_GETCURSEL	equ	00344h
LB_GETTEXT	equ	00346h
LB_GETCOUNT	equ	00347h
LB_REPLACESTRING	equ	00348h
LB_INSERTSTRING	equ	00349h
WM_USER		equ	00400h
LBN_SELCHANGE	equ	0
LBN_DBLCLK	equ	1
LBN_SELECT_DONE	equ	2
lbrCause	equ	0000Fh
lbrNone		equ	0
lbrMouse	equ	1
lbrScroll	equ	2
lbrKeys		equ	3
lbrSpace	equ	4
lbrOther	equ	5
flbrReselect	equ	00010h
hemMenu		equ	1
hemMenuItem	equ	2
hemMbox		equ	3
hemDialog	equ	4
hemUserMin	equ	00010h
isaBackground	equ	0
isaHilite	equ	1
isaGreyed	equ	2
isaEnabled	equ	3
isaDisabled	equ	4
isaAlert	equ	5
isaDialogBox	equ	6
isaStatic	equ	isaDialogBox
isaButton	equ	isaDialogBox
isaPushButton	equ	7
isaButtonDown	equ	8
isaListBox	equ	9
isaEdit		equ	isaDialogBox
isaScrollbar	equ	10
isaElevator	equ	11
isaMenuBox	equ	12
isaMenu		equ	13
isaMenuSelected	equ	14
isaMenuHilite	equ	15
isaMenuHiliteSel	equ	16
isaItemHiliteSel	equ	17
isaDialogAccel	equ	18
isaShadow	equ	19
isaUserMin	equ	20
isaUserMax	equ	(isaUserMin + 16)
isaMax		equ	isaUserMax
SBS_HORZ	equ	0
SBS_VERT	equ	1
SB_LINEUP	equ	0
SB_LINEDOWN	equ	1
SB_PAGEUP	equ	2
SB_PAGEDOWN	equ	3
SB_THUMBPOSITION	equ	4
SB_THUMBTRACK	equ	5
SB_TOP		equ	6
SB_BOTTOM	equ	7
SB_ENDSCROLL	equ	8
dmNormal	equ	0
dmText		equ	00100h
dmTextOnly	equ	dmText
dmForeBack	equ	00200h
dmAttrOnly	equ	dmForeBack
dmFore		equ	00300h
dmBack		equ	00400h
dmTextFore	equ	00500h
dmTextBack	equ	00600h
dmSpecialMin	equ	00700h
dmTextMapB	equ	00700h
dmTextMapF	equ	00800h
dmMapB		equ	00900h
dmMapF		equ	00A00h
fdmKeepFfont	equ	08000h
VK_MIN		equ	00100h
VK_LBUTTON	equ	00101h
VK_RBUTTON	equ	00102h
VK_CANCEL	equ	00103h
VK_MBUTTON	equ	00104h
VK_BACK		equ	00108h
VK_TAB		equ	00109h
VK_CLEAR	equ	0010Ch
VK_RETURN	equ	0010Dh
VK_SHIFT	equ	00110h
VK_CONTROL	equ	00111h
VK_ALT		equ	00112h
VK_PAUSE	equ	00113h
VK_CAPLOCK	equ	00114h
VK_KANA		equ	00115h
VK_ROMAJI	equ	00116h
VK_ZENKAKU	equ	00117h
VK_HIRAGANA	equ	00118h
VK_KANJI	equ	00119h
VK_CONVERT	equ	0011Ch
VK_NONCONVERT	equ	0011Dh
VK_ACCEPT	equ	0011Eh
VK_MODECHANGE	equ	0011Fh
VK_ESCAPE	equ	0011Bh
VK_SPACE	equ	00120h
VK_PRIOR	equ	00121h
VK_NEXT		equ	00122h
VK_END		equ	00123h
VK_HOME		equ	00124h
VK_LEFT		equ	00125h
VK_UP		equ	00126h
VK_RIGHT	equ	00127h
VK_DOWN		equ	00128h
VK_0		equ	00130h
VK_9		equ	00139h
VK_A		equ	00141h
VK_Z		equ	0015Ah
VK_SELECT	equ	00129h
VK_PRINT	equ	0012Ah
VK_EXECUTE	equ	0012Bh
VK_INSERT	equ	0012Dh
VK_DELETE	equ	0012Eh
VK_HELP		equ	0012Fh
VK_NUMPAD0	equ	00160h
VK_NUMPAD1	equ	00161h
VK_NUMPAD2	equ	00162h
VK_NUMPAD3	equ	00163h
VK_NUMPAD4	equ	00164h
VK_NUMPAD5	equ	00165h
VK_NUMPAD6	equ	00166h
VK_NUMPAD7	equ	00167h
VK_NUMPAD8	equ	00168h
VK_NUMPAD9	equ	00169h
VK_MULTIPLY	equ	0016Ah
VK_ADD		equ	0016Bh
VK_SEPARATOR	equ	0016Ch
VK_SUBTRACT	equ	0016Dh
VK_DECIMAL	equ	0016Eh
VK_DIVIDE	equ	0016Fh
VK_F1		equ	00170h
VK_F2		equ	00171h
VK_F3		equ	00172h
VK_F4		equ	00173h
VK_F5		equ	00174h
VK_F6		equ	00175h
VK_F7		equ	00176h
VK_F8		equ	00177h
VK_F9		equ	00178h
VK_F10		equ	00179h
VK_F11		equ	0017Ah
VK_F12		equ	0017Bh
VK_F13		equ	0017Ch
VK_F14		equ	0017Dh
VK_F15		equ	0017Eh
VK_F16		equ	0017Fh
VK_OAX		equ	00180h
VK_NUMLOCK	equ	00190h
VK_SCRLOCK	equ	00191h
VK_MENU		equ	VK_ALT
VK_CAPITAL	equ	VK_CAPLOCK
VK_OEM_NUMBER	equ	VK_NUMLOCK
VK_OEM_SCROLL	equ	VK_SCRLOCK
VK_SEPARATER	equ	VK_SEPARATOR
ichSelectEnd	equ	(07FFFh)
EN_CHANGE	equ	1
EN_CURSORMOVED	equ	2
fmemFixed	equ	1
fmemNear	equ	2
cbNearMemServiceMax	equ	128
indtNil		equ	0
indtKeyboard	equ	1
indtCharacterScreen	equ	2
indtGraphicScreen	equ	3
indtCharacterPrinter	equ	4
indtGraphicPrinter	equ	5
indtSystem	equ	6
indtSerialComm	equ	7

indtIndv	equ	[byte ptr 00000h]
fillerIndv	equ	[byte ptr 00001h]
rglpfnIndv	equ	[word ptr 00002h]
cpfnNeedMinIndv	equ	[word ptr 00004h]
cpfnNeedMacIndv	equ	[word ptr 00006h]
psLoadedIndv	equ	[word ptr 00008h]
cpfnLoadedIndv	equ	[word ptr 0000Ah]
cbIndvMin	equ	0000Ch

rgchMagicIndh	equ	[dword ptr 00000h]
LO_rgchMagicIndh	equ	[word ptr 00000h]
HI_rgchMagicIndh	equ	[word ptr 00002h]
dlfaTableIndh	equ	[dword ptr 00004h]
LO_dlfaTableIndh	equ	[word ptr 00004h]
HI_dlfaTableIndh	equ	[word ptr 00006h]
cbIndhMin	equ	00008h

indtInds	equ	[byte ptr 00000h]
floadInds	equ	[byte ptr 00001h]
cbCodeInds	equ	[word ptr 00002h]
dlfaCodeInds	equ	[dword ptr 00004h]
LO_dlfaCodeInds	equ	[word ptr 00004h]
HI_dlfaCodeInds	equ	[word ptr 00006h]
cbIndsMin	equ	00008h

rgchMagicIndt	equ	[dword ptr 00000h]
LO_rgchMagicIndt	equ	[word ptr 00000h]
HI_rgchMagicIndt	equ	[word ptr 00002h]
cindsIndt	equ	[word ptr 00004h]
rgindsIndt	equ	[00006h]
cbIndtMin	equ	0000Eh
floadFixed	equ	1
floadRealMode	equ	00010h
floadProtMode	equ	00020h
floadAnyMode	equ	(floadRealMode or floadProtMode)
floadStandard	equ	00080h

sdGlisInos	equ	[word ptr 00000h]
sdLoisInos	equ	[word ptr 00002h]
cpfnInos	equ	[word ptr 00004h]
lpfnDosGetVersionInos	equ	[dword ptr 00006h]
OFF_lpfnDosGetVersionInos	equ	[word ptr 00006h]
SEG_lpfnDosGetVersionInos	equ	[word ptr 00008h]
lpfnDosGetEnvInos	equ	[dword ptr 0000Ah]
OFF_lpfnDosGetEnvInos	equ	[word ptr 0000Ah]
SEG_lpfnDosGetEnvInos	equ	[word ptr 0000Ch]
lpfnDosDevConfigInos	equ	[dword ptr 0000Eh]
OFF_lpfnDosDevConfigInos	equ	[word ptr 0000Eh]
SEG_lpfnDosDevConfigInos	equ	[word ptr 00010h]
lpfnDosGetCtryInfoInos	equ	[dword ptr 00012h]
OFF_lpfnDosGetCtryInfoInos	equ	[word ptr 00012h]
SEG_lpfnDosGetCtryInfoInos	equ	[word ptr 00014h]
lpfnDosGetDBCSEvInos	equ	[dword ptr 00016h]
OFF_lpfnDosGetDBCSEvInos	equ	[word ptr 00016h]
SEG_lpfnDosGetDBCSEvInos	equ	[word ptr 00018h]
lpfnDosGetInfoSegInos	equ	[dword ptr 0001Ah]
OFF_lpfnDosGetInfoSegInos	equ	[word ptr 0001Ah]
SEG_lpfnDosGetInfoSegInos	equ	[word ptr 0001Ch]
lpfnDosDevIOCtlInos	equ	[dword ptr 0001Eh]
OFF_lpfnDosDevIOCtlInos	equ	[word ptr 0001Eh]
SEG_lpfnDosDevIOCtlInos	equ	[word ptr 00020h]
lpfnDosPortAccessInos	equ	[dword ptr 00022h]
OFF_lpfnDosPortAccessInos	equ	[word ptr 00022h]
SEG_lpfnDosPortAccessInos	equ	[word ptr 00024h]
lpfnDosGetModHandleInos	equ	[dword ptr 00026h]
OFF_lpfnDosGetModHandleInos	equ	[word ptr 00026h]
SEG_lpfnDosGetModHandleInos	equ	[word ptr 00028h]
lpfnDosLoadModuleInos	equ	[dword ptr 0002Ah]
OFF_lpfnDosLoadModuleInos	equ	[word ptr 0002Ah]
SEG_lpfnDosLoadModuleInos	equ	[word ptr 0002Ch]
lpfnDosGetProcAddrInos	equ	[dword ptr 0002Eh]
OFF_lpfnDosGetProcAddrInos	equ	[word ptr 0002Eh]
SEG_lpfnDosGetProcAddrInos	equ	[word ptr 00030h]
lpfnDosCreateThreadInos	equ	[dword ptr 00032h]
OFF_lpfnDosCreateThreadInos	equ	[word ptr 00032h]
SEG_lpfnDosCreateThreadInos	equ	[word ptr 00034h]
lpfnDosSetPrtyInos	equ	[dword ptr 00036h]
OFF_lpfnDosSetPrtyInos	equ	[word ptr 00036h]
SEG_lpfnDosSetPrtyInos	equ	[word ptr 00038h]
lpfnDosExitInos	equ	[dword ptr 0003Ah]
OFF_lpfnDosExitInos	equ	[word ptr 0003Ah]
SEG_lpfnDosExitInos	equ	[word ptr 0003Ch]
lpfnDosOpenInos	equ	[dword ptr 0003Eh]
OFF_lpfnDosOpenInos	equ	[word ptr 0003Eh]
SEG_lpfnDosOpenInos	equ	[word ptr 00040h]
lpfnDosCloseInos	equ	[dword ptr 00042h]
OFF_lpfnDosCloseInos	equ	[word ptr 00042h]
SEG_lpfnDosCloseInos	equ	[word ptr 00044h]
lpfnDosReadInos	equ	[dword ptr 00046h]
OFF_lpfnDosReadInos	equ	[word ptr 00046h]
SEG_lpfnDosReadInos	equ	[word ptr 00048h]
lpfnDosWriteInos	equ	[dword ptr 0004Ah]
OFF_lpfnDosWriteInos	equ	[word ptr 0004Ah]
SEG_lpfnDosWriteInos	equ	[word ptr 0004Ch]
lpfnDosMonOpenInos	equ	[dword ptr 0004Eh]
OFF_lpfnDosMonOpenInos	equ	[word ptr 0004Eh]
SEG_lpfnDosMonOpenInos	equ	[word ptr 00050h]
lpfnDosMonCloseInos	equ	[dword ptr 00052h]
OFF_lpfnDosMonCloseInos	equ	[word ptr 00052h]
SEG_lpfnDosMonCloseInos	equ	[word ptr 00054h]
lpfnDosMonRegInos	equ	[dword ptr 00056h]
OFF_lpfnDosMonRegInos	equ	[word ptr 00056h]
SEG_lpfnDosMonRegInos	equ	[word ptr 00058h]
lpfnDosMonReadInos	equ	[dword ptr 0005Ah]
OFF_lpfnDosMonReadInos	equ	[word ptr 0005Ah]
SEG_lpfnDosMonReadInos	equ	[word ptr 0005Ch]
lpfnDosMonWriteInos	equ	[dword ptr 0005Eh]
OFF_lpfnDosMonWriteInos	equ	[word ptr 0005Eh]
SEG_lpfnDosMonWriteInos	equ	[word ptr 00060h]
lpfnDosAllocSegInos	equ	[dword ptr 00062h]
OFF_lpfnDosAllocSegInos	equ	[word ptr 00062h]
SEG_lpfnDosAllocSegInos	equ	[word ptr 00064h]
lpfnDosReAllocSegInos	equ	[dword ptr 00066h]
OFF_lpfnDosReAllocSegInos	equ	[word ptr 00066h]
SEG_lpfnDosReAllocSegInos	equ	[word ptr 00068h]
lpfnDosFreeSegInos	equ	[dword ptr 0006Ah]
OFF_lpfnDosFreeSegInos	equ	[word ptr 0006Ah]
SEG_lpfnDosFreeSegInos	equ	[word ptr 0006Ch]
lpfnVioGetBufInos	equ	[dword ptr 0006Eh]
OFF_lpfnVioGetBufInos	equ	[word ptr 0006Eh]
SEG_lpfnVioGetBufInos	equ	[word ptr 00070h]
lpfnVioShowBufInos	equ	[dword ptr 00072h]
OFF_lpfnVioShowBufInos	equ	[word ptr 00072h]
SEG_lpfnVioShowBufInos	equ	[word ptr 00074h]
lpfnVioGetConfigInos	equ	[dword ptr 00076h]
OFF_lpfnVioGetConfigInos	equ	[word ptr 00076h]
SEG_lpfnVioGetConfigInos	equ	[word ptr 00078h]
lpfnVioGetModeInos	equ	[dword ptr 0007Ah]
OFF_lpfnVioGetModeInos	equ	[word ptr 0007Ah]
SEG_lpfnVioGetModeInos	equ	[word ptr 0007Ch]
lpfnVioSetModeInos	equ	[dword ptr 0007Eh]
OFF_lpfnVioSetModeInos	equ	[word ptr 0007Eh]
SEG_lpfnVioSetModeInos	equ	[word ptr 00080h]
lpfnVioGetStateInos	equ	[dword ptr 00082h]
OFF_lpfnVioGetStateInos	equ	[word ptr 00082h]
SEG_lpfnVioGetStateInos	equ	[word ptr 00084h]
lpfnVioSetStateInos	equ	[dword ptr 00086h]
OFF_lpfnVioSetStateInos	equ	[word ptr 00086h]
SEG_lpfnVioSetStateInos	equ	[word ptr 00088h]
lpfnVioGetCurTypeInos	equ	[dword ptr 0008Ah]
OFF_lpfnVioGetCurTypeInos	equ	[word ptr 0008Ah]
SEG_lpfnVioGetCurTypeInos	equ	[word ptr 0008Ch]
lpfnVioSetCurTypeInos	equ	[dword ptr 0008Eh]
OFF_lpfnVioSetCurTypeInos	equ	[word ptr 0008Eh]
SEG_lpfnVioSetCurTypeInos	equ	[word ptr 00090h]
lpfnVioGetCurPosInos	equ	[dword ptr 00092h]
OFF_lpfnVioGetCurPosInos	equ	[word ptr 00092h]
SEG_lpfnVioGetCurPosInos	equ	[word ptr 00094h]
lpfnVioSetCurPosInos	equ	[dword ptr 00096h]
OFF_lpfnVioSetCurPosInos	equ	[word ptr 00096h]
SEG_lpfnVioSetCurPosInos	equ	[word ptr 00098h]
lpfnVioGetFontInos	equ	[dword ptr 0009Ah]
OFF_lpfnVioGetFontInos	equ	[word ptr 0009Ah]
SEG_lpfnVioGetFontInos	equ	[word ptr 0009Ch]
lpfnVioSetFontInos	equ	[dword ptr 0009Eh]
OFF_lpfnVioSetFontInos	equ	[word ptr 0009Eh]
SEG_lpfnVioSetFontInos	equ	[word ptr 000A0h]
lpfnVioGetCPInos	equ	[dword ptr 000A2h]
OFF_lpfnVioGetCPInos	equ	[word ptr 000A2h]
SEG_lpfnVioGetCPInos	equ	[word ptr 000A4h]
lpfnVioSetCPInos	equ	[dword ptr 000A6h]
OFF_lpfnVioSetCPInos	equ	[word ptr 000A6h]
SEG_lpfnVioSetCPInos	equ	[word ptr 000A8h]
lpfnVioScrollUpInos	equ	[dword ptr 000AAh]
OFF_lpfnVioScrollUpInos	equ	[word ptr 000AAh]
SEG_lpfnVioScrollUpInos	equ	[word ptr 000ACh]
lpfnKbdOpenInos	equ	[dword ptr 000AEh]
OFF_lpfnKbdOpenInos	equ	[word ptr 000AEh]
SEG_lpfnKbdOpenInos	equ	[word ptr 000B0h]
lpfnKbdCloseInos	equ	[dword ptr 000B2h]
OFF_lpfnKbdCloseInos	equ	[word ptr 000B2h]
SEG_lpfnKbdCloseInos	equ	[word ptr 000B4h]
lpfnKbdCharInInos	equ	[dword ptr 000B6h]
OFF_lpfnKbdCharInInos	equ	[word ptr 000B6h]
SEG_lpfnKbdCharInInos	equ	[word ptr 000B8h]
lpfnKbdGetStatusInos	equ	[dword ptr 000BAh]
OFF_lpfnKbdGetStatusInos	equ	[word ptr 000BAh]
SEG_lpfnKbdGetStatusInos	equ	[word ptr 000BCh]
lpfnKbdSetStatusInos	equ	[dword ptr 000BEh]
OFF_lpfnKbdSetStatusInos	equ	[word ptr 000BEh]
SEG_lpfnKbdSetStatusInos	equ	[word ptr 000C0h]
lpfnDosBeepInos	equ	[dword ptr 000C2h]
OFF_lpfnDosBeepInos	equ	[word ptr 000C2h]
SEG_lpfnDosBeepInos	equ	[word ptr 000C4h]
lpfnVioGetPhysBufInos	equ	[dword ptr 000C6h]
OFF_lpfnVioGetPhysBufInos	equ	[word ptr 000C6h]
SEG_lpfnVioGetPhysBufInos	equ	[word ptr 000C8h]
lpfnCwBeginIOInos	equ	[dword ptr 000CAh]
OFF_lpfnCwBeginIOInos	equ	[word ptr 000CAh]
SEG_lpfnCwBeginIOInos	equ	[word ptr 000CCh]
lpfnCwEndIOInos	equ	[dword ptr 000CEh]
OFF_lpfnCwEndIOInos	equ	[word ptr 000CEh]
SEG_lpfnCwEndIOInos	equ	[word ptr 000D0h]
cbInosMin	equ	000D2h

cpfnIncs	equ	[word ptr 00000h]
cbIncsMin	equ	00002h

lpwDataInsh	equ	[dword ptr 00000h]
LO_lpwDataInsh	equ	[word ptr 00000h]
HI_lpwDataInsh	equ	[word ptr 00002h]
pinosInsh	equ	[word ptr 00004h]
pincsInsh	equ	[word ptr 00006h]
cpfnInsh	equ	[word ptr 00008h]
cbInshMin	equ	0000Ah

dxCharInft	equ	[byte ptr 00000h]
dyCharInft	equ	[byte ptr 00001h]
dyBaseLineInft	equ	[byte ptr 00002h]
ifontInft	equ	[byte ptr 00003h]
cbInftMin	equ	00004h
finstText	equ	1
finstGraphics	equ	2
finstMonochrome	equ	4
finstAlternate	equ	8
finstFont	equ	00010h
finstCgaSnow	equ	00020h
finstDisableMouse	equ	01000h
finstFastScroll	equ	02000h
finstQuestionable	equ	04000h
finstAvailable	equ	08000h

finstInst	equ	[word ptr 00000h]
axMacInst	equ	[byte ptr 00002h]
ayMacInst	equ	[byte ptr 00003h]
coMacInst	equ	[byte ptr 00004h]
covMacInst	equ	[byte ptr 00005h]
coiMacInst	equ	[word ptr 00006h]
imodeInst	equ	[word ptr 00008h]
inftInst	equ	[dword ptr 0000Ah]
LO_inftInst	equ	[word ptr 0000Ah]
HI_inftInst	equ	[word ptr 0000Ch]
ffontSupportedInst	equ	[word ptr 0000Eh]
psPrimInst	equ	[word ptr 00010h]
psSecInst	equ	[word ptr 00012h]
cwExtraInst	equ	[word ptr 00014h]
psExtraInst	equ	[word ptr 00016h]
bits0Inst	equ	[word ptr 00018h]
bits0recInst	record	fillerInst:15,fAllocPrimInst:1
wDriver1Inst	equ	[word ptr 0001Ah]
reserved2Inst	equ	[0001Ch]
cbInstMin	equ	0002Ah
imodeUnknown	equ	0FFFFh

_chTopLeftCorner1Inch	equ	[byte ptr 00000h]
_chTopRightCorner1Inch	equ	[byte ptr 00001h]
_chBottomLeftCorner1Inch	equ	[byte ptr 00002h]
_chBottomRightCorner1Inch	equ	[byte ptr 00003h]
_chTopSide1Inch	equ	[byte ptr 00004h]
_chBottomSide1Inch	equ	[byte ptr 00005h]
_chLeftSide1Inch	equ	[byte ptr 00006h]
_chRightSide1Inch	equ	[byte ptr 00007h]
_chMiddleLeft1Inch	equ	[byte ptr 00008h]
_chMiddleRight1Inch	equ	[byte ptr 00009h]
_chTopLeftCorner2Inch	equ	[byte ptr 0000Ah]
_chTopRightCorner2Inch	equ	[byte ptr 0000Bh]
_chBottomLeftCorner2Inch	equ	[byte ptr 0000Ch]
_chBottomRightCorner2Inch	equ	[byte ptr 0000Dh]
_chTopSide2Inch	equ	[byte ptr 0000Eh]
_chBottomSide2Inch	equ	[byte ptr 0000Fh]
_chLeftSide2Inch	equ	[byte ptr 00010h]
_chRightSide2Inch	equ	[byte ptr 00011h]
_chUpArrowInch	equ	[byte ptr 00012h]
_chDownArrowInch	equ	[byte ptr 00013h]
_chLeftArrowInch	equ	[byte ptr 00014h]
_chRightArrowInch	equ	[byte ptr 00015h]
_chBulletInch	equ	[byte ptr 00016h]
_chMiddleDotInch	equ	[byte ptr 00017h]
_chScrollbarInch	equ	[byte ptr 00018h]
_chElevatorInch	equ	[byte ptr 00019h]
_chShadowInitInch	equ	[byte ptr 0001Ah]
_chCloseInch	equ	[byte ptr 0001Bh]
_chZoomInInch	equ	[byte ptr 0001Ch]
_chZoomOutInch	equ	[byte ptr 0001Dh]
_chUpDownArrowInch	equ	[byte ptr 0001Eh]
_chLeftRightArrowInch	equ	[byte ptr 0001Fh]
reservedInch	equ	[00020h]
cbInchMin	equ	00040h
ffontNormal	equ	00000h
ffontUnderline	equ	00001h
ffontDoubleUnderline	equ	00002h
ffontOrUnderline	equ	00003h
ffontStrikeThrough	equ	00004h
ffontBold	equ	00008h
ffontSubscript	equ	00010h
ffontSuperscript	equ	00020h
ffontMiniCap	equ	00030h
ffontItalic	equ	00040h
ffontOrCharacter	equ	00080h
ffontReservedBits	equ	00F00h
ffontExtraMask	equ	0F000h
ffontOrUnderlineSupport	equ	01000h
fvidsChAttr	equ	1

modeVids	equ	[byte ptr 00000h]
pageVids	equ	[byte ptr 00001h]
fvidsVids	equ	[word ptr 00002h]
cwVidDataVids	equ	[word ptr 00004h]
cwExtraVids	equ	[word ptr 00006h]
rgwExtraVids	equ	[word ptr 00008h]
cbVidsMin	equ	0000Ah

lpfnImodeGuessCurrentCsdInsj	equ	[dword ptr 00000h]
OFF_lpfnImodeGuessCurrentCsdInsj	equ	[word ptr 00000h]
SEG_lpfnImodeGuessCurrentCsdInsj	equ	[word ptr 00002h]
lpfnFQueryInstCsdInsj	equ	[dword ptr 00004h]
OFF_lpfnFQueryInstCsdInsj	equ	[word ptr 00004h]
SEG_lpfnFQueryInstCsdInsj	equ	[word ptr 00006h]
lpfnFInitCsdInsj	equ	[dword ptr 00008h]
OFF_lpfnFInitCsdInsj	equ	[word ptr 00008h]
SEG_lpfnFInitCsdInsj	equ	[word ptr 0000Ah]
lpfnTermCsdInsj	equ	[dword ptr 0000Ch]
OFF_lpfnTermCsdInsj	equ	[word ptr 0000Ch]
SEG_lpfnTermCsdInsj	equ	[word ptr 0000Eh]
lpfnMoveHwCursCsdInsj	equ	[dword ptr 00010h]
OFF_lpfnMoveHwCursCsdInsj	equ	[word ptr 00010h]
SEG_lpfnMoveHwCursCsdInsj	equ	[word ptr 00012h]
lpfnFQueryInftCsdInsj	equ	[dword ptr 00014h]
OFF_lpfnFQueryInftCsdInsj	equ	[word ptr 00014h]
SEG_lpfnFQueryInftCsdInsj	equ	[word ptr 00016h]
lpfnFGetColorPaletteCsdInsj	equ	[dword ptr 00018h]
OFF_lpfnFGetColorPaletteCsdInsj	equ	[word ptr 00018h]
SEG_lpfnFGetColorPaletteCsdInsj	equ	[word ptr 0001Ah]
lpfnSetColorPaletteCsdInsj	equ	[dword ptr 0001Ch]
OFF_lpfnSetColorPaletteCsdInsj	equ	[word ptr 0001Ch]
SEG_lpfnSetColorPaletteCsdInsj	equ	[word ptr 0001Eh]
lpfnPrepUpdateCsdInsj	equ	[dword ptr 00020h]
OFF_lpfnPrepUpdateCsdInsj	equ	[word ptr 00020h]
SEG_lpfnPrepUpdateCsdInsj	equ	[word ptr 00022h]
lpfnDoUpdateCsdInsj	equ	[dword ptr 00024h]
OFF_lpfnDoUpdateCsdInsj	equ	[word ptr 00024h]
SEG_lpfnDoUpdateCsdInsj	equ	[word ptr 00026h]
lpfnDoneUpdateCsdInsj	equ	[dword ptr 00028h]
OFF_lpfnDoneUpdateCsdInsj	equ	[word ptr 00028h]
SEG_lpfnDoneUpdateCsdInsj	equ	[word ptr 0002Ah]
lpfnSpecialUpdateCsdInsj	equ	[dword ptr 0002Ch]
OFF_lpfnSpecialUpdateCsdInsj	equ	[word ptr 0002Ch]
SEG_lpfnSpecialUpdateCsdInsj	equ	[word ptr 0002Eh]
lpfnCbSizeVidsCsdInsj	equ	[dword ptr 00030h]
OFF_lpfnCbSizeVidsCsdInsj	equ	[word ptr 00030h]
SEG_lpfnCbSizeVidsCsdInsj	equ	[word ptr 00032h]
lpfnFSaveVidsCsdInsj	equ	[dword ptr 00034h]
OFF_lpfnFSaveVidsCsdInsj	equ	[word ptr 00034h]
SEG_lpfnFSaveVidsCsdInsj	equ	[word ptr 00036h]
lpfnFRestoreVidsCsdInsj	equ	[dword ptr 00038h]
OFF_lpfnFRestoreVidsCsdInsj	equ	[word ptr 00038h]
SEG_lpfnFRestoreVidsCsdInsj	equ	[word ptr 0003Ah]
lpfnSaveVidDataCsdInsj	equ	[dword ptr 0003Ch]
OFF_lpfnSaveVidDataCsdInsj	equ	[word ptr 0003Ch]
SEG_lpfnSaveVidDataCsdInsj	equ	[word ptr 0003Eh]
lpfnRestoreVidDataCsdInsj	equ	[dword ptr 00040h]
OFF_lpfnRestoreVidDataCsdInsj	equ	[word ptr 00040h]
SEG_lpfnRestoreVidDataCsdInsj	equ	[word ptr 00042h]
lpfnEnableVidsMonitorCsdInsj	equ	[dword ptr 00044h]
OFF_lpfnEnableVidsMonitorCsdInsj	equ	[word ptr 00044h]
SEG_lpfnEnableVidsMonitorCsdInsj	equ	[word ptr 00046h]
lpfnBltArcCsdInsj	equ	[dword ptr 00048h]
OFF_lpfnBltArcCsdInsj	equ	[word ptr 00048h]
SEG_lpfnBltArcCsdInsj	equ	[word ptr 0004Ah]
lpfnGetCharMapCsdInsj	equ	[dword ptr 0004Ch]
OFF_lpfnGetCharMapCsdInsj	equ	[word ptr 0004Ch]
SEG_lpfnGetCharMapCsdInsj	equ	[word ptr 0004Eh]
cbInsjMin	equ	00050h
cpfnCsdMin	equ	20
KK_EXTENDED	equ	08000h
KK_CAPLOCK	equ	04000h
KK_NUMLOCK	equ	02000h
KK_SCRLOCK	equ	01000h
KK_ALT		equ	00800h
KK_CONTROL	equ	00400h
KK_SHIFT	equ	00200h
KK_VK		equ	001FFh
KK_SC		equ	000FFh

lpfnKeyboardMessageInkb	equ	[dword ptr 00000h]
OFF_lpfnKeyboardMessageInkb	equ	[word ptr 00000h]
SEG_lpfnKeyboardMessageInkb	equ	[word ptr 00002h]
lpfnFTestKeyboardEmptyInkb	equ	[dword ptr 00004h]
OFF_lpfnFTestKeyboardEmptyInkb	equ	[word ptr 00004h]
SEG_lpfnFTestKeyboardEmptyInkb	equ	[word ptr 00006h]
lpfnSpecialAbortInkb	equ	[dword ptr 00008h]
OFF_lpfnSpecialAbortInkb	equ	[word ptr 00008h]
SEG_lpfnSpecialAbortInkb	equ	[word ptr 0000Ah]
fAbortInkb	equ	[word ptr 0000Ch]
fPollKeyboardInkb	equ	[word ptr 0000Eh]
fKeyIsUpInkb	equ	[byte ptr 00010h]
fKeyWasUpInkb	equ	[byte ptr 00011h]
wRateKeyRepeatInkb	equ	[word ptr 00012h]
fNormalKeyboardInkb	equ	[word ptr 00014h]
fNonAltKeyHitInkb	equ	[byte ptr 00016h]
fDisableExtendedInkb	equ	[word ptr 00018h]
cbInkbMin	equ	0001Ah

pfnEnableKeyboardKbdInkj	equ	[dword ptr 00000h]
OFF_pfnEnableKeyboardKbdInkj	equ	[word ptr 00000h]
SEG_pfnEnableKeyboardKbdInkj	equ	[word ptr 00002h]
pfnPollKeyboardKbdInkj	equ	[dword ptr 00004h]
OFF_pfnPollKeyboardKbdInkj	equ	[word ptr 00004h]
SEG_pfnPollKeyboardKbdInkj	equ	[word ptr 00006h]
pfnFlushKeyRgchKbdInkj	equ	[dword ptr 00008h]
OFF_pfnFlushKeyRgchKbdInkj	equ	[word ptr 00008h]
SEG_pfnFlushKeyRgchKbdInkj	equ	[word ptr 0000Ah]
pfnMkGetShiftStatesKbdInkj	equ	[dword ptr 0000Ch]
OFF_pfnMkGetShiftStatesKbdInkj	equ	[word ptr 0000Ch]
SEG_pfnMkGetShiftStatesKbdInkj	equ	[word ptr 0000Eh]
pfnSetShiftKkKbdInkj	equ	[dword ptr 00010h]
OFF_pfnSetShiftKkKbdInkj	equ	[word ptr 00010h]
SEG_pfnSetShiftKkKbdInkj	equ	[word ptr 00012h]
pfnChAlternateKeytopKbdInkj	equ	[dword ptr 00014h]
OFF_pfnChAlternateKeytopKbdInkj	equ	[word ptr 00014h]
SEG_pfnChAlternateKeytopKbdInkj	equ	[word ptr 00016h]
cbInkjMin	equ	00018h
cpfnKbdMin	equ	6

lpfnDoSoundSydInyj	equ	[dword ptr 00000h]
OFF_lpfnDoSoundSydInyj	equ	[word ptr 00000h]
SEG_lpfnDoSoundSydInyj	equ	[word ptr 00002h]
lpfnLGetTimeSydInyj	equ	[dword ptr 00004h]
OFF_lpfnLGetTimeSydInyj	equ	[word ptr 00004h]
SEG_lpfnLGetTimeSydInyj	equ	[word ptr 00006h]
cbInyjMin	equ	00008h
cpfnSydMin	equ	2

colHotMcb	equ	[word ptr 00000h]
rowHotMcb	equ	[word ptr 00002h]
rgwAndMaskGfxMcb	equ	[00004h]
rgwXorMaskGfxMcb	equ	[00024h]
wAndMaskTextMcb	equ	[word ptr 00044h]
wXorMaskTextMcb	equ	[word ptr 00046h]
cbMcbMin	equ	00048h

leftXMcob	equ	[word ptr 00000h]
upperYMcob	equ	[word ptr 00002h]
rightXMcob	equ	[word ptr 00004h]
lowerYMcob	equ	[word ptr 00006h]
cbMcobMin	equ	00008h
MK_LBUTTON	equ	00001h
MK_RBUTTON	equ	00002h
MK_SHIFT	equ	00004h
MK_CONTROL	equ	00008h
MK_MBUTTON	equ	00010h
MK_NONCLIENT	equ	00060h
MK_NONCLIENT_X	equ	00020h
MK_NONCLIENT_Y	equ	00040h
MK_MENU		equ	08000h
rerrOk		equ	0
rerrBadFile	equ	2
rerrBadPath	equ	3
rerrNoMemory	equ	8
rerrBadFormat	equ	11
rerrBadRead	equ	30
rerrBadVersion	equ	90
rerrBadMemReq	equ	91

xGpt		equ	[word ptr 00000h]
yGpt		equ	[word ptr 00002h]
cbGptMin	equ	00004h

xLeftRect	equ	[word ptr 00000h]
yTopRect	equ	[word ptr 00002h]
xRightRect	equ	[word ptr 00004h]
yBottomRect	equ	[word ptr 00006h]
cbRectMin	equ	00008h

cbPolygon	equ	[word ptr 00000h]
rectBoundPolygon	equ	[00002h]
rggptPolygon	equ	[dword ptr 0000Ah]
LO_rggptPolygon	equ	[word ptr 0000Ah]
HI_rggptPolygon	equ	[word ptr 0000Ch]
cbPolygonMin	equ	0000Eh
cpenMax		equ	41
icoMax		equ	41

fingdIngd	equ	[word ptr 00000h]
reserved2Ingd	equ	[word ptr 00002h]
fingpSupportedIngd	equ	[word ptr 00004h]
dimHIngd	equ	[word ptr 00006h]
dimVIngd	equ	[word ptr 00008h]
dxScreenIngd	equ	[word ptr 0000Ah]
dyScreenIngd	equ	[word ptr 0000Ch]
dimPenHIngd	equ	[word ptr 0000Eh]
dimPenVIngd	equ	[word ptr 00010h]
cpenIngd	equ	[byte ptr 00012h]
icoAvailMacIngd	equ	[byte ptr 00013h]
icoPrefMacIngd	equ	[byte ptr 00014h]
ipaLineMacIngd	equ	[byte ptr 00015h]
ipaAreaMacIngd	equ	[byte ptr 00016h]
ccoplnIngd	equ	[byte ptr 00017h]
rgcoAvailIngd	equ	[00018h]
rgcoPrefIngd	equ	[0006Ah]
rgpaLineIngd	equ	[000BCh]
rgpaAreaIngd	equ	[000C1h]
szNameIngd	equ	[000D1h]
cbIngdMin	equ	000FAh
fingdRstrVctr	equ	00004h
fingdRasterFonts	equ	00040h
fingdMultiColor	equ	00100h
fingdVirtualPen	equ	00200h
fingdFilm	equ	00400h
fingdVarPenSize	equ	01000h
fingdNotAvailable	equ	08000h
fingpSetAreaPat	equ	00001h
fingpSetLinePat	equ	00002h
fingpSetLineWeight	equ	00004h
fingpSetColor	equ	00008h
fingpText	equ	00010h
fingpRectangle	equ	00020h
fingpArc	equ	00040h
fingpPolygon	equ	00080h
fingpBitBlt	equ	00100h

pfnFInitGraphicsIndj	equ	[dword ptr 00000h]
OFF_pfnFInitGraphicsIndj	equ	[word ptr 00000h]
SEG_pfnFInitGraphicsIndj	equ	[word ptr 00002h]
pfnTermGraphicsIndj	equ	[dword ptr 00004h]
OFF_pfnTermGraphicsIndj	equ	[word ptr 00004h]
SEG_pfnTermGraphicsIndj	equ	[word ptr 00006h]
pfnMoveIndj	equ	[dword ptr 00008h]
OFF_pfnMoveIndj	equ	[word ptr 00008h]
SEG_pfnMoveIndj	equ	[word ptr 0000Ah]
pfnDrawIndj	equ	[dword ptr 0000Ch]
OFF_pfnDrawIndj	equ	[word ptr 0000Ch]
SEG_pfnDrawIndj	equ	[word ptr 0000Eh]
pfnSetAreaPatIndj	equ	[dword ptr 00010h]
OFF_pfnSetAreaPatIndj	equ	[word ptr 00010h]
SEG_pfnSetAreaPatIndj	equ	[word ptr 00012h]
pfnSetLinePatIndj	equ	[dword ptr 00014h]
OFF_pfnSetLinePatIndj	equ	[word ptr 00014h]
SEG_pfnSetLinePatIndj	equ	[word ptr 00016h]
pfnSetLineWeightIndj	equ	[dword ptr 00018h]
OFF_pfnSetLineWeightIndj	equ	[word ptr 00018h]
SEG_pfnSetLineWeightIndj	equ	[word ptr 0001Ah]
pfnSetColorIndj	equ	[dword ptr 0001Ch]
OFF_pfnSetColorIndj	equ	[word ptr 0001Ch]
SEG_pfnSetColorIndj	equ	[word ptr 0001Eh]
pfnTextIndj	equ	[dword ptr 00020h]
OFF_pfnTextIndj	equ	[word ptr 00020h]
SEG_pfnTextIndj	equ	[word ptr 00022h]
pfnRectangleIndj	equ	[dword ptr 00024h]
OFF_pfnRectangleIndj	equ	[word ptr 00024h]
SEG_pfnRectangleIndj	equ	[word ptr 00026h]
pfnArcIndj	equ	[dword ptr 00028h]
OFF_pfnArcIndj	equ	[word ptr 00028h]
SEG_pfnArcIndj	equ	[word ptr 0002Ah]
pfnPolygonIndj	equ	[dword ptr 0002Ch]
OFF_pfnPolygonIndj	equ	[word ptr 0002Ch]
SEG_pfnPolygonIndj	equ	[word ptr 0002Eh]
pfnBitBltIndj	equ	[dword ptr 00030h]
OFF_pfnBitBltIndj	equ	[word ptr 00030h]
SEG_pfnBitBltIndj	equ	[word ptr 00032h]
cbIndjMin	equ	00034h
cpfnGxdMin	equ	13
cpfnGsdMin	equ	cpfnGxdMin
cpfnGpdMin	equ	cpfnGxdMin
IFNDEF NOPROCS 
externFP	FEnableMouse
externFP	EnableKeyboard
externFP	PollKeyboard
externFP	SetShiftKk
externFP	DisableExtendedKeyboard
externFP	GetCharMap
externFP	MessageBox
externFP	SetDialogCaption
externFP	HiliteDialogAccel
externFP	SetEditText
externFP	GetEditText
externFP	EditWndProc
externFP	SetAlarm
externFP	KillAlarm
externFP	UngetMessage
externFP	PeekMessage
externFP	GetFocus
externFP	SetFocus
externFP	FlushAbort
externFP	SetCapture
externFP	ReleaseCapture
externFP	DispatchMessage
externFP	PostMessage
externFP	SendMessage
externFP	InitMenu
externFP	FEnableMenuBar
externFP	EnableMenu
externFP	EnableMenuItem
externFP	CheckMenuItem
externFP	FMenuItemChecked
externFP	FindMenuItem
externFP	DrawMenubar
externFP	SetCursorBlock
externFP	ScrollBarWndProc
externFP	SetScrollPos
externFP	GetScrollPos
externFP	SetScrollRange
externFP	AddChild
externFP	RemoveChild
externFP	EnableWindow
externFP	GetClientRrc
externFP	SetWindowStyle
externFP	SetWindowSize
externFP	DrawWindow
externFP	DrawBorder
externFP	TextOut
externFP	CharOut
externFP	FillRrc
externFP	BltRrc
externFP	DrawBox
externFP	SaveRrc
externFP	RestoreRrc
externFP	EnableCursor
externFP	MoveCursor
externFP	MoveWindow
externFP	IntersectRect
externFP	UnionRect
externFP	IsRectEmpty
externFP	SetRect
externFP	PtInRect
externFP	CwSizeRrc
externFP	ShadowArc
externFP	ListBoxWndProc
externFP	DoSound
externFP	ClockTicks
externFP	FValidDrive
externFP	SetIsaColor
externFP	GetIsaColor
externFP	SetIsaRgca
externFP	TmcDoDlg
externFP	HcabAlloc
externFP	FreeCab
externFP	FreeCabData
externFP	SzToCab
externFP	SzFromCab
externFP	EnableTmc
externFP	FEnabledTmc
externFP	SetTmcVal
externFP	GetTmcVal
externFP	SetTmcSel
externFP	GetTmcText
externFP	SetTmcText
externFP	SetFocusTmc
externFP	RedisplayListBox
externFP	RedisplayTmc
externFP	SetDefaultTmc
externFP	InitCab
externFP	ReinitCab
externFP	PwndOfListbox
ENDIF ;!NOPROCS
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\editaux.h ===
ushort WND_GetpExtra ();
ushort WND_Getpef ();
ushort WND_GetcLines ();
ushort WND_GetcColumns ();
ushort WND_GetStyle ();
ushort WND_GetrcCur_obleft ();
ushort WND_GetrcCur_olntop ();
void WND_SetStyle (ushort);
PWND WND_GetpParent ();
ushort WND_GetattrCur ();
void WND_SetattrCur (ushort);
ushort WND_GetfEnabled ();
PWND GetFocus ();
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\editaux.inc ===
externP WND_GetpExtra
externP WND_Getpef
externP WND_GetcLines
externP WND_GetcColumns
externP WND_GetStyle
externP WND_GetrcCur_obleft
externP WND_GetrcCur_olntop
externP WND_SetStyle
externP WND_GetpParent
externP WND_GetattrCur
externP WND_SetattrCur
externP WND_GetfEnabled
externP GetFocus
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\edityp.h ===
/* SCCSWHAT( "%W% %E% %U%	%Q%" ) */

/*** ld - line buffer */
typedef struct ld {
	ushort flags;
	ushort cb;	/* count of bytes in buffer */
	ushort cbMax;	/* max buffer length */
	char *prgch;	/* pointer to buffer */
	} ld; 

/*** ip - insert point */
typedef struct ip {	/* insert point */
	short ob;	/* offset to current column position */
	short oln;	/* offset to current line position */
	} ip;

/*** pd - program descripter */
typedef struct pd {
	ushort olntop;	/* offset within progrm display at top of screen */
	short obleft;	/* offset within list buffer of left most character */
	ushort oln;	/* current ld line offset within program */
	} pd;

/*** ef - Edit Field ***/
struct ef {
	ushort	hBuffer;
	pd	pdCur;
	ip	ipCur;
	ip	ipAnchor;
	ld	*pldCur;
	PWND	pwndScrollV;
	PWND	pwndScrollH;
	ushort	attrCur;
	uchar	Style;
	bool	fSelection;
};

struct LineAttr {
	ushort	attr;
	ushort	cb;
};

typedef struct LineAttr LineAttr;

extern bool pascal fPasteOk;
extern bool pascal fInsertMode;
extern ld pascal ldEMScratch;

extern bool pascal emFlags;
#define EMF_IN_EDITMGR 0x01

/* styles */
#define ES_MULTILINE	0x0001
#define ES_NOREDRAW	0x0002
#define ES_NOSELECT	0x0004
#define EF_MOVECURSOR	0x0008

/* control messages: */
#define EM_SELCHARS	WM_USER+0
#define EM_REPLACESEL	WM_USER+1
#define EM_GETWORD	WM_USER+2
#define EM_GETLINESEL	WM_USER+3
#define WM_UNDO 	WM_USER+4
#define WM_CLEAR	WM_USER+5
#define WM_SETTEXT	WM_USER+6
#define WM_GETTEXT	WM_USER+7
#define WM_SEARCHFIND	WM_USER+8
#define WM_SEARCHCHANGE WM_USER+9
#define WM_SETBOOKMARK	WM_USER+10
#define WM_GOTOBOOKMARK WM_USER+11
#define WM_SETREDRAW	WM_USER+12
#define WM_SEARCHNEXT	WM_USER+13
#define WM_MATCHBRACE	WM_USER+14
#define WM_FLUSHFOCUS	WM_USER+15
#define EM_MOVECURSOR	WM_USER+16

/* ldCur.flags values */
#define LD_fDirty			0x0001

#define isaEditWindow		(isaUserMin + 0)
#define isaCurStmt		(isaUserMin + 1)
#define isaBreakpoint		(isaUserMin + 2)
#define isaCurBreakpoint	(isaUserMin + 3)
#define isaStatusLine		(isaUserMin + 4)
#define isaStatusAlert		(isaUserMin + 5)
#define isaStatusLock		(isaUserMin + 6)

#define isaDebugWindow		(isaUserMin + 7)
#define isaHelpWindow		(isaUserMin + 8)
#define isaIncludeFileHilite	(isaUserMin + 9)
#define isaListBoxHilite	(isaUserMin + 10)
#define isaWatchpointHilite	(isaUserMin + 11)

#define isaBold 		(isaUserMin + 12)
#define isaItalic		(isaUserMin + 13)
#define isaUnderline		(isaUserMin + 14)

#define isaHelp 		isaDialogBox
#define isaSyntaxHelp		isaHelpWindow
#define isaWatchWindow		isaDebugWindow

#define pefExtra		rgwExtra[1]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\edityp.inc ===
; /* SCCSWHAT( "%W% %E% %U%	%Q%" ) */
;File: edityp.inc - Defines which apply to TextWin's edit manager
;NOTE: When making changes to this file, be sure to make equivalent
;      changes to file edityp.h.

TWIN_EDIT_INC = -1

;      changes to file edit.h.
; Single line descriptor. All editing is done on this structure and then
; transfered to buffer.
LD	STRUC
	LD_flags	dw	0h
	LD_cb		dw	00h	;number of bytes in line buffer
	LD_cbMax	dw	0100h	;max. of bytes (size) allowed in buffer
	LD_prgch   	dw      0h	;pointer to line buffer
LD	ENDS

; Insertion point. Currency structure for current edit field
IP	STRUC
	IP_ob	dw	0	;offset for left edge of buffer
	IP_oln	dw	0	;offset within file 
IP	ENDS

; Program descripter. Currency for program (current buffer). This is used
; with the text manager to control what part of the current buffer is in
; view and what buffer line is in the line descripter
PD	STRUC
	pd_olntop	dw	0	;offset within file for top of screen
	pd_obleft	dw	0	;offset to left edge of screen
	pd_oln		dw	0	;line offset that is in ldCur
PD	ENDS

; General edit field structure. This is passed into EditMgr. Between calls
; to the edit manager it contains all state information about a particular
; edit field.
EF	STRUC
	EF_hBuffer	dw	0
	EF_pdCur	db	size pd dup(?)
	EF_ipCur	db	size ip dup(?)
	EF_ipAnchor	db	size ip dup(?)
	EF_pldCur	dw	?
	EF_pwndScrollV	dw	0
	EF_pwndScrollH	dw	0
	EF_attrCur	dw	0
	EF_Style	db	0
	EF_fSelection	db	0
EF	ENDS

EF_pdCur_olnTop		equ	word ptr EF_pdCur.PD_olnTop
EF_pdCur_obleft		equ	word ptr EF_pdCur.PD_obleft
EF_pdCur_oln		equ	word ptr EF_pdCur.PD_oln
EF_ipCur_ob		equ	word ptr EF_ipCur.IP_ob
EF_ipCur_oln		equ	word ptr EF_ipCur.IP_oln
EF_ipAnchor_ob		equ	word ptr EF_ipAnchor.IP_ob
EF_ipAnchor_oln		equ	word ptr EF_ipAnchor.IP_oln

LINEATTR STRUC
LA_attr	dw	?
LA_cb	dw	?
LINEATTR ENDS

;styles:
ES_MULTILINE    equ	0001H
ES_NOREDRAW	equ	0002H
ES_NOSELECT	equ	0004H
EF_MOVECURSOR	equ	0008H

;control messages:
EM_SELCHARS	equ	WM_USER+0
EM_REPLACESEL	equ	WM_USER+1
EM_GETWORD	equ	WM_USER+2
EM_GETLINESEL	equ	WM_USER+3
WM_UNDO 	equ	WM_USER+4
WM_CLEAR	equ	WM_USER+5
WM_SETTEXT	equ	WM_USER+6
WM_GETTEXT	equ	WM_USER+7
WM_SEARCHFIND	equ	WM_USER+8
WM_SEARCHCHANGE equ	WM_USER+9
WM_SETBOOKMARK	equ	WM_USER+10
WM_GOTOBOOKMARK equ	WM_USER+11
WM_SETREDRAW	equ	WM_USER+12
WM_SEARCHNEXT	equ	WM_USER+13
WM_MATCHBRACE	equ	WM_USER+14
WM_FLUSHFOCUS	equ	WM_USER+15
EM_MOVECURSOR	equ	WM_USER+16

isaEditWindow		=	(isaUserMin + 0)
isaCurStmt		=	(isaUserMin + 1)
isaBreakpoint		=	(isaUserMin + 2)
isaCurBreakpoint	=	(isaUserMin + 3)
isaStatusLine		=	(isaUserMin + 4)
isaStatusAlert		=	(isaUserMin + 5)
isaStatusLock		=	(isaUserMin + 6)

isaDebugWindow		=	(isaUserMin + 7)
isaHelpWindow		=	(isaUserMin + 8)
isaIncludeFileHilite	=	(isaUserMin + 9)
isaListBoxHilite	=	(isaUserMin + 10)
isaWatchpointHilite	=	(isaUserMin + 11)

isaBold 		=	(isaUserMin + 12)
isaItalic		=	(isaUserMin + 13)
isaUnderline		=	(isaUserMin + 14)

isaHelp 		=	isaDialogBox
isaSyntaxHelp		=	isaHelpWindow
isaWatchWindow		=	isaDebugWindow

pefExtra		equ	(rgwExtra+2)

; ldCur.flags values
LD_fDirty			EQU	0001H

; emFlags values
EMF_IN_EDITMGR			EQU	01H

ifndef EDITMGR_ASM
sBegin	DATA
	extrn	tabStops:word
	extrn	emFlags:byte	;modified by EMF_xxx
sEnd	DATA
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\version.inc ===
LIBC	macro name
	extrn	_&name:far
	endm

MEM_MGR	macro name
	endm

TEXT_MGR macro name
	endm

APPL	macro name
	endm

TWIN	macro name
	extrn	name:near
	endm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\windows.inc ===
CC = 1

include cw\cwindows.inc
include cw\cowdef.inc
include cw\cowproc.inc
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\version.h ===
#define MEM_MGR far pascal
#define LIBC far cdecl
#define APPL near pascal
#define TEXT_MGR far pascal
#define COW far pascal
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\standard.h ===
/* standard.h - included in every C module			*/
/*																	*/
/* defines things that every C module is likely		*/
/* to want defined											*/

typedef unsigned short	ushort;
typedef unsigned long	ulong;
typedef unsigned char	uchar;
typedef ushort		word;
typedef ulong		dword;
typedef uchar		byte;
typedef uchar		bool;
typedef word		boolean;

#define NULL		0
#define FALSE		0
#define TRUE		1
#define UNDEFINED	0xffff
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\help.h ===
struct tsnFile
    {
    int		wMagic;		/* identifies file as a help file	*/
    int		wAppl;		/* Application specific word		*/
    int		wSignature;	/* signature of app that uses it -	*/
				/* quickbasic, works, windows		*/
    int		cid;		/* count of topics in file		*/
    int		cwmp;		/* count of words in mapping section	*/
    int		cbm;		/* count of bitmaps			*/
    int		cbkeys;		/* count of text in keyphrase section	*/
    int		cbCookies;	/* count of bytes in magic cookie section*/
    };

#define CTOPIC_LEVELS_MAX 5
struct tsnTopic
    {
    unsigned short int	cLevels;
    unsigned short int	rgCLn[CTOPIC_LEVELS_MAX];
    };

struct tsnCookies
    {
    unsigned char	cRunspace;
    unsigned char	cKeybase;
    unsigned char	cKeybase2;
    unsigned char	cbKeys;
    unsigned char	cDefinition;
    unsigned char	cTopic;
    };

/* a help file is the above structure, followed by these sections:	*/
/*	(sorted) topic position array - array of double word file pos's	*/
/*	(sorted) mapping array - cwmp words				*/
/*	key phrase table - each phrase is separated by a null		*/
/*	bitmap size array - one double word per bitmap			*/
/*	magic cookie section.  application dependant.			*/
/*	bitmaps - indexed by bitmap size array				*/
/*	(sorted) compressed topics					*/

/*---------- Other Cruft -----------------------------------------------*/

#define cbRunMin    4           /* minimum length to get compression    */

#define wMagicHELP 	((int)0111213)	/* HELP file magic word         */

#define wSignatureBasic	0x4251	/* `QB' */

#define C_MIN					0x81
#define C_KEYPHRASE0			0x81		/* 1st keyphrase cookie						*/
#define C_KEYPHRASE1			0x82		/* 2nd keyphrase cookie						*/
#define C_KEYPHRASE2			0x83		/* 2nd keyphrase cookie						*/
#define C_KEYPHRASE_SPACE0	0x84		/* 1st keyphrase + space cookie			*/
#define C_KEYPHRASE_SPACE1	0x85		/* 2nd keyphrase + space cookie			*/
#define C_KEYPHRASE_SPACE2	0x86		/* 2nd keyphrase + space cookie			*/
#define C_RUNSPACE			0x87		/* Cookie for runs of spaces 				*/
#define C_RUN					0x88		/* Cookie for runs of non-space			*/
#define C_QUOTE				0x89		/* Cookie to quote non-cookies			*/
#define C_CONTEXT				0x8a		/* Context										*/
#define C_CONTEXT_SPACE		0x8b		/* Context + SPACE							*/
#define C_MAX					0x8b
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\hdcw\cw\windows.h ===
#define CC
#define IBM_COLORS
#define HELP_BUTTON

#define cwExtraWnd	2

#include <cw\cwindows.h>
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\excontxt.asm ===
page	49,132
	TITLE	EXCONTXT - context-related executors
;***
;excontxt.asm - context-related executors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;
;Special Information regarding [re]initialization:
;     - This module contains the fundamental entry point to which
;	1-time initialization branches.
;     - When UserInterface() is called, this represents a major transfer
;	of control; the User Interface takes over. It saves away the
;	keyboard interrupt handler that the runtime installed at
;	1-time initialization, and restores it prior to returning here.
;	Within the User Interface (UI), ES is no longer preserved, and
;	one may not assume that SI or DI represent anything in particular.
;     - Some executors in this module will behave differently in our
;	full shell version than in the "Runtime Module" version, i.e.,
;	the version which can just binary load QBI programs and run them.
;	Executors which terminate execution are at the head of this list
;	rather than returning to the shell, in the Runtime Module version,
;	these will cause QBI to terminate and exit to DOS.
;     - Note that anyone that changes grs.fDirect sets up a 'critical
;	section' situation: if a runtime error occurs after grs.fDirect
;	has been changed, and grs.oTxCur is not pointing to some exBol/Bos
;	opcode in the text table owned by txdCur, runtime error handling
;	will go out to lunch.
;     - The way we allow for RUN <filename> and CHAIN to load a file and
;	get it scanned is to have them call LoadFile, then put an actual
;	executor address in the direct mode buffer, set a bit in debugFlags,
;	and just dispatch. We know that the following BOS/BOL/EOT will cause
;	UserInterface() to regain control; UserInterface() will see the
;	debugFlags bit set, and cause the direct mode buffer to b