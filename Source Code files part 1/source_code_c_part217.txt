 goto Exit;
    }
    if (!FusionpSkipBigPathRoot(&arg1[0], &BigPathRootLength))
    {
        ::ReportFailure("FusionpSkipBigPathRoot\n");
        goto Exit;
    }
    arg1.resize(1 + ::wcslen(&arg1[0]));

    NonwildcardLength = wcscspn(&arg1[BigPathRootLength], L"*?");
    LastPathElementLength = StringReverseComplementSpan(&arg1[BigPathRootLength], &arg1[arg1.size() - 1], L"\\/");
    AllButLastPathElementlength = arg1.size() - 1 - BigPathRootLength - LastPathElementLength;
    //AllButLastPathElementlength -= (AllButLastPathElementlength != 0);

    //::printf("%ls\n", &arg1[0]);
    //::printf("BigPathRootLength           %Id\n", BigPathRootLength);
    //::printf("NonwildcardLength           %Id\n", NonwildcardLength);
    //::printf("LastPathElementLength       %Id\n", LastPathElementLength);
    //::printf("AllButLastPathElementlength %Id\n", AllButLastPathElementlength);

    if (NonwildcardLength + BigPathRootLength == arg1.size() - 1)
    {
        //::printf("arg1 contains no wildcards\n");
        //::TerminateProcess(GetCurrentProcess(), __LINE__);
        if (!DeleteFileW(&arg1[0]))
        {
            ::ReportFailure("DeleteFileW(%ls)\n", &arg1[0]);
            goto Exit;
        }
        ::printf("DeleteFileW(%ls)\n", &arg1[0]);
        goto Success;
    }
    if (NonwildcardLength < AllButLastPathElementlength)
    {
        ::SetLastError(0);
        ::ReportFailure("wildcards in nonleaf\n");
        goto Exit;
    }
    //::TerminateProcess(GetCurrentProcess(), __LINE__);
    if (!FindFileHandle.Win32FindFirstFile(&arg1[0], &wfd))
    {
        ::ReportFailure("FindFirstFileW(%ls)\n", &arg1[0]);
        goto Exit;
    }
    do
    {
        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            continue;
        }
        arg1.resize(AllButLastPathElementlength + BigPathRootLength);
        //arg1.push_back('\\');
        arg1.insert(arg1.end(), wfd.cFileName, wfd.cFileName + ::wcslen(wfd.cFileName) + 1);
        if (!DeleteFileW(&arg1[0]))
        {
            ::ReportFailure("DeleteFileW(%ls)\n", &arg1[0]);
            continue;
        }
        ::printf("DeleteFileW(%ls)\n", &arg1[0]);
    } while(::FindNextFileW(FindFileHandle, &wfd));

Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\delayload_tool\1delayload_tool.cpp ===
#include "stdinc.h"
static const char File[] = __FILE__;
#include "handle.h"
#include "mystring.h"
#include <functional>
#include <set>
#include "rpc.h"

// std::binary_search lamely only returns a bool, not an iterator
// it is a simple layer over std::lower_bound
template<class Iterator_t, class T> inline
Iterator_t BinarySearch(Iterator_t First, Iterator_t Last, const T& t)
{
    Iterator_t Iterator = std::lower_bound(First, Last, t);
    if (Iterator != Last
        && !(t < *Iterator) // this is a way to check for equality actually
        )
        return Iterator;
    return Last;
}

//
// This is just like remove_copy_if, but it is missing an exclamation point
//
template<class InputIterator_t, class OutputIterator_t, class Predicate_t> inline
OutputIterator_t CopyIf(InputIterator_t First, InputIterator_t Last, OutputIterator_t Out, Predicate_t Predicate)
{
    for (; First != Last; ++First)
        if (/*!*/Predicate(*First))
	        *Out++ = *First;
    return (Out);
}

//
// get msvcrt.dll wildcard processing on the command line
//
extern "C" { int _dowildcard = 1; }

typedef std::vector<String_t> StringVector_t;
typedef std::deque<String_t> StringDeque_t;
typedef StringVector_t::iterator StringVectorIterator_t;
typedef StringVector_t::const_iterator StringVectorConstIterator_t;

typedef std::set<String_t> StringSet_t;
typedef StringSet_t::iterator StringSetIterator_t;
typedef StringSet_t::const_iterator StringSetConstIterator_t;

template <typename T, size_t N>
class FixedSizeArray_t : public std::vector<T>
{
public:
    ~FixedSizeArray_t() { }
    FixedSizeArray_t() { reserve(N); }
};

class FileSystemPath_t
{
public:
    void Realize(String_t & str);
    FileSystemPath_t * m_pParent;
    String_t           m_str;
};

void FileSystemPath_t::Realize(String_t & str)
{
    if (m_pParent != NULL)
    {
        m_pParent->RealizePath(str);
        str += L"\\";
    }
    str += m_str;
}

typedef std::deque<FileSystemPath_t> FileSystemPathsDeque_t;

void IfFailedThrow(HRESULT hr)
{
    if (SUCCEEDED(hr))
        return;
    throw hr;
}

void
CollectFilePathsRecursivelyHelper(
    const String_t& directory,
    FileSystemPathsDeque_t& paths,
    WIN32_FIND_DATAW& wfd
    )
{
    CFindFile FindFile;
    HRESULT hr;

    IfFailedThrow(hr = FindFile.HrCreate((directory + L"\\*).c_str(), &wfd));
    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
            continue;
        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
        }
        else
        {
        }
    } while (::FindNextFileW(FindFile, &wfd));
}

void
CollectFilePathsRecursively(
    const String_t         & directory,
    FileSystemPathsDeque_t & paths
    )
{
    WIN32_FIND_DATAW wfd;

    CollectFilePathsRecursivelyHelper(directory, paths, wfd);
}

class DelayloadTool_t
{
private:
    typedef DelayloadTool_t This_t;
    DelayloadTool_t(const DelayloadTool_t&);
    void operator=(const DelayloadTool_t&);
public:

    typedef String_t File_t;

    ~DelayloadTool_t() { }
    Print_t Print;

    DelayloadTool_t() :
        Argv0base_cstr(L"")
        {
        }

    static bool IsPathSeperator(wchar_t ch)
    {
        return (ch == '\\' || ch == '/');
    }

    static bool IsAbsolutePath(const String_t& s)
    {
        return (s.length() > 2
            && (s[1] == ':' || (IsPathSeperator(s[0] && IsPathSeperator(s[1])))));
    }

    //
    // This transform lets LoadLibrary's search be more like CreateFile's search.
    //
    static String_t PrependDotSlashToRelativePath(const String_t& Path)
    {
        if (!IsAbsolutePath(Path))
            return L".\\" + Path;
        else
            return Path;
    }

    String_t					   Argv0;
    String_t					   Argv0base;
    PCWSTR						   Argv0base_cstr;

    typedef std::vector<File_t> Files_t;
    typedef std::set<ResourceIdTuple_t> Tuples_t;

	Files_t		    Files;
    Tuples_t        Tuples;
    bool            ShouldPrint;
};

typedef String_t::const_iterator StringConstIterator_t;

void DelayloadToolAssertFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "ASSERTION FAILURE: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

void DelayloadToolInternalErrorCheckFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "INTERNAL ERROR: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

String_t NumberToString(ULONG Number, PCWSTR Format = L"0x%lx")
{
    // the size needed is really dependent on Format..
    WCHAR   NumberAsString[BITS_OF(Number) + 5];

    _snwprintf(NumberAsString, NUMBER_OF(NumberAsString), Format, Number);
    NumberAsString[NUMBER_OF(NumberAsString) - 1] = 0;

    return NumberAsString;
}

String_t GetLastErrorString()
{
    PWSTR s = NULL;
    DWORD Error = GetLastError();
    String_t ErrorString = NumberToString(Error, L"%lu");
    PWSTR FormatMessageAllocatedBuffer = NULL;

    if (!FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        0,
        reinterpret_cast<PWSTR>(&FormatMessageAllocatedBuffer),
        100,
        NULL
        )
        || FormatMessageAllocatedBuffer == NULL
        )
    {
        goto Exit;
    }
    if (FormatMessageAllocatedBuffer[0] == 0)
    {
        goto Exit;
    }

    //
    // Error messages often end with vertical whitespce, remove it.
    //
    s = FormatMessageAllocatedBuffer + StringLength(FormatMessageAllocatedBuffer) - 1;
    while (s != FormatMessageAllocatedBuffer && (*s == '\n' || *s == '\r'))
        *s-- = 0;
    ErrorString = ErrorString + L" (" + FormatMessageAllocatedBuffer + L")";
Exit:
    LocalFree(FormatMessageAllocatedBuffer);
    return ErrorString;
}

bool GetFileSize(PCWSTR Path, __int64& Size)
{
    CFindFile FindFile;
    WIN32_FIND_DATAW wfd;
    LARGE_INTEGER liSize;

    if (!FindFile.Win32Create(Path, &wfd))
        return false;

    liSize.HighPart = wfd.nFileSizeHigh;
    liSize.LowPart = wfd.nFileSizeLow;
    Size = liSize.QuadPart;

    return true;
}

String_t RemoveOptionChar(const String_t& s)
{
    if (s.Length() != 0)
    {
        if (s[0] == '-')
            return s.substr(1);
        else if (s[0] == '/')
            return s.substr(1);
        else if (s[0] == ':') // hacky..
            return s.substr(1);
        else if (s[0] == '=') // hacky..
            return s.substr(1);
    }
    return s;
}

//
// String_t has specialized find_first_not_of that uses integral positions,
// and globally there is only find_first_of. Here we provide the expected
// iterator-based find_first_not_of, based on the std::string code.
//
// Find the first occurence in [first1, last1) of an element in [first2, last).
//
// eg:
//   find_first_not_of("abc":"12;3", ":;");
//                      ^
//   find_first_not_of(":12;3", ":;");
//                       ^
//   find_first_not_of("3", ":;");
//                      ^
//
template <typename Iterator>
Iterator FindFirstNotOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    if (first2 == last2)
        return last1;
    for ( ; first1 != last1 ; ++first1)
    {
        if (std::find(first2, last2, *first1) == last2)
        {
            break;
        }
    }
    return first1;
}

//
// consistent style..
//
template <typename Iterator>
Iterator FindFirstOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    return std::find_first_of(first1, last1, first2, last2);
}

template <typename String_t>
void SplitString(const String_t& String, const String_t& Delim, std::vector<String_t>& Fields)
{
    String_t::const_iterator FieldBegin;
    String_t::const_iterator FieldEnd = String.begin();

    while ((FieldBegin = FindFirstNotOf(FieldEnd, String.end(), Delim.begin(), Delim.end())) != String.end())
    {
        FieldEnd = FindFirstOf(FieldBegin, String.end(), Delim.begin(), Delim.end());
        Fields.push_back(String_t(FieldBegin, FieldEnd));
    }
}

void __cdecl Error(const wchar_t* s, ...)
{
	printf("%s\n", s);
	exit(EXIT_FAILURE);
}

int DelayloadTool_t::Main(const StringVector_t& args)
{
    StringVectorConstIterator_t i;
    Operation_t Operation = NULL;

    for (i = args.begin() ; i != args.end() ; ++i)
    {
        String_t s;
        String_t t;
        bool PrintAll = false;
        bool PrintNone = false;
        bool PrintValue = true;
        bool PrintUnequal = false;

        s = *i;
        s = RemoveOptionChar(s);

        if (s == L"Sxid12Tool1")
        {
            StringVector_t restArgs(i + 1, args.end());
            return Sxid12Tool1(restArgs);
        }
        else if (GetFileAttributesW(s) != 0xFFFFFFFF)
        {
            goto FileLabel;
        }
        else if (s.Starts(t = L"Query"))
        {
            Operation = &This_t::Query;
        }
        else if (s.Starts(t = L"FindDuplicates"))
        {
            Operation = &This_t::FindDuplicates;
        }
        else if (s.Starts(t = L"Explode"))
        {
            Operation = &This_t::Explode;
        }
        else if (s.Starts(t = L"Diff"))
        {
            Operation = &This_t::FindDuplicates;
            Print.LeftOnly = true;
            Print.RightOnly = true;
            Print.Equal = true;
            Print.UnequalContents = true;
            Print.UnequalSize = true;
        }
        else if (s.Starts(t = L"Delete"))
            Operation = &This_t::Delete;
        else if (s.Starts(t = L"Dump"))
            Operation = &This_t::Dump;
        else if (s.Starts(t = L"FindAndDeleteDuplicates"))
            Operation = &This_t::FindAndDeleteDuplicates;
        else if (s.Starts(t = L"NoPrint"))
        {
            PrintValue = !PrintValue;
            goto PrintCommonLabel;
        }
        else if (s.Starts(t = L"Print"))
        {
PrintCommonLabel:
            s = RemoveOptionChar(s.substr(t.Length()));
            bool* Member = NULL;
            if (s == (t = L"UnequalSize"))
                Member = &this->Print.UnequalSize;
            else if (s == (t = L"UnequalContents"))
                Member = &this->Print.UnequalContents;
            else if (s == (t = L"UnequalSize"))
                Member = &this->Print.UnequalSize;
            else if (s == (t = L"Keep"))
                Member = &this->Print.Keep;
            else if (s == (t = L"Delete"))
                Member = &this->Print.Delete;
            else if (s == (t = L"Success"))
                Member = &this->Print.Success;
            else if (s == (t = L"Unchanged"))
                Member = &this->Print.Unchanged;
            else if (s == (t = L"Equal"))
                Member = &this->Print.Equal;
            else if (s == (t = L"LeftOnly"))
                Member = &this->Print.LeftOnly;
            else if (s == (t = L"RightOnly"))
                Member = &this->Print.RightOnly;
            else if (s == L"All")
            {
                PrintAll = true;
                Print.SetAll(true);
            }
            else if (s == L"None")
            {
                PrintNone = true;
                Print.SetAll(false);
            }
            else if (s == L"Unequal")
            {
                PrintUnequal = true;
                this->Print.UnequalContents = true;
                this->Print.UnequalSize = true;
            }
            if (PrintAll || PrintNone || PrintUnequal)
            {
                // nothing
            }
            else if (Member == NULL)
            {
                printf("%ls : WARNING: unknown print option \"%ls\" ignored\n", Argv0base_cstr, static_cast<PCWSTR>(s));
                continue;
            }
            else
            {
                bool knownValue = true;
                s = RemoveOptionChar(s.substr(t.Length()));
                if (s != L"")
                {
                    //
                    // This doesn't work because of the equality comparisons above. They need
                    // ignore whatever follows the colon.
                    //
                    if (s == L"No" || s == L"False")
                        PrintValue = !PrintValue;
                    else if (s == L"Yes" || s == L"True")
                    {
                        /* nothing */
                    }
                    else
                    {
                        knownValue = false;
                        printf("%ls : WARNING: unknown print option \"%ls\" ignored\n", Argv0base_cstr, static_cast<PCWSTR>(s));
                        continue;
                    }
                }
                if (knownValue)
                    *Member = PrintValue;
            }
            continue;
        }
        else if (s.Starts(t = L"File"))
        {
FileLabel:
            s = RemoveOptionChar(s.substr(t.Length()));
            Files.push_back(s);
            continue;
        }
        else
        {
            Files.push_back(s);
            continue;
        }
        s = RemoveOptionChar(s.substr(t.Length()));
        SplitResourceTupleString(s, Tuples);
    }
    //std::sort(Tuples.begin(), Tuples.end());
    if (Operation == NULL)
    {
        printf("Usage...\n");
        return EXIT_FAILURE;
    }
    (this->*Operation)();
    return EXIT_SUCCESS;
}

extern "C"
{
	void __cdecl mainCRTStartup(void);
	void __cdecl wmainCRTStartup(void);
}

int __cdecl main(int argc, char** argv)
{
	wmainCRTStartup();
	return 0;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    DelayloadTool_t tool;
    StringVector_t args;
    args.reserve(argc);
    tool.Argv0 = argv[0];
    String_t::size_type p = tool.Argv0.find_last_of(L"\\/");
    if (p != tool.Argv0.npos)
        tool.Argv0base = tool.Argv0.substr(1 + p);
    else
        tool.Argv0base = tool.Argv0;
    p = tool.Argv0base.find_last_of(L".");
    if (p != tool.Argv0base.npos)
        tool.Argv0base = tool.Argv0base.substr(0, p);
    tool.Argv0base_cstr = tool.Argv0base.c_str();
    std::copy(argv + 1, argv + argc, std::back_inserter(args));
    int ret = tool.Main(args);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fre_or_chk\fre_or_chk.c ===
/*
Copyright (c) Microsoft Corporation

This program prints "fre" or "chk", based on the build of Windows it is run on.
*/
#include "windows.h"
#include <stdio.h>

int __cdecl main()
{
    printf("%s\n", GetSystemMetrics(SM_DEBUG) ? "chk" : "fre");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fusionmanifestvalidator\helpers.h ===
// helpers.h
//
#pragma once

BOOL
Validating(
    PCWSTR     SourceManName,
    PCWSTR     SchemaName
    );

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase()
        : m_cRef(0),
          m_hFile(INVALID_HANDLE_VALUE),
          m_bSeenFirstCharacter(false)
    { }

    virtual ~CFileStreamBase();

    bool OpenForRead(PCWSTR pszPath);

    bool Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    HANDLE              m_hFile;
    bool                m_bSeenFirstCharacter;

private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fuslogvw\cdlids.h ===
#define IDD_CDLLOGVIEW            1500
#define IDC_CB_VIEWLOG            1501
#define IDC_CB_REFRESH            1502
#define IDC_CB_DELETE             1503
#define IDC_CB_DELETE_ALL         1504
#define IDC_LV_LOGMESSAGES        1505
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fusionmanifestvalidator\filestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include "helpers.h"
#include <windows.h>
#include "atlbase.h"
#include "atlconv.h"

#define IS_NT() ((GetVersion() & 0x80000000) == 0)

BOOL
MySetFilePointerEx(
  HANDLE         File,                    // handle to file
  LARGE_INTEGER  DistanceToMove,  // bytes to move pointer
  PLARGE_INTEGER NewFilePointer, // new file pointer
  DWORD          MoveMethod               // starting point
)
{
    LONG DistanceToMoveLow  = static_cast<LONG>(DistanceToMove.LowPart);
    LONG DistanceToMoveHigh = DistanceToMove.HighPart;
    DWORD NewPositionLow = SetFilePointer(File, DistanceToMoveLow, &DistanceToMoveHigh, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER)
    {
        if (GetLastError() != NO_ERROR)
            return FALSE;
    }
    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMoveHigh;
    }
    return TRUE;
}

CFileStreamBase::~CFileStreamBase()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();
        ::CloseHandle(m_hFile);
        ::SetLastError(dwLastError);
    }
}

bool
CFileStreamBase::OpenForRead(PCWSTR pszPath)
{
    USES_CONVERSION;

    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile =
        IS_NT() ? CreateFileW(pszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)
                : CreateFileA(W2A(pszPath), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if (!::CloseHandle(m_hFile))
        {
            return false;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return true;
}

ULONG
CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

ULONG
CFileStreamBase::Release()
{
    return ::InterlockedDecrement(&m_cRef);
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID* ppvObj
    )
{
    HRESULT hr = NOERROR;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        *ppvObj = static_cast<IStream *>(this);
    else
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!m_bSeenFirstCharacter)
    {
#ifdef AWFUL_SPACE_HACK
        while (true)
        {
            CHAR ch;
            ReadFile(m_hFile, &ch, 1, &cbRead, NULL);
            if ((ch != '\n') && (ch != '\r') && (ch != ' ') && (ch != '\t')) {
                m_bSeenFirstCharacter = true;
                LARGE_INTEGER li;
                li.QuadPart = -1;
                ::MySetFilePointerEx(m_hFile, li, NULL, FILE_CURRENT);
                break;
            }
        }
#endif
    }

    if (!::ReadFile(m_hFile, pv, cb, &cbRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    DWORD dwWin32Origin = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::MySetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if (!Close())
        hr = HRESULT_FROM_WIN32 (GetLastError());

    return hr ;
}

HRESULT
CFileStreamBase::Revert()
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Clone(
    IStream** ppIStream
   )
{
    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fusionmanifestvalidator\stdinc.h ===
// stdinc.h
//
#if defined(_WIN64)
#define UNICODE
#define _UNICODE
#endif
#define __USE_MSXML2_NAMESPACE__
#include <utility>
#pragma warning(disable:4663) /* C++ language change */
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4189) /* local variable is initialized but not referenced */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#include "windows.h"
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <stdio.h>
#include "wincrypt.h"
#include "objbase.h"
#include "msxml.h"
#include "msxml2.h"
#include "imagehlp.h"
#include "atlbase.h"
#include "comdef.h"
#include "comutil.h"
#include "tchar.h"
typedef CONST VOID* PCVOID;
#define QUIET_MODE  0x001
#define NORM_MODE   0x002
#include "share.h"
using std::string;
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include "helpers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fusionmanifestvalidator\xmlchk.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xmlchk.cpp

Abstract:

    Use msxml.dll to see if an .xml file conforms to a schema.

Author:

    Ted Padua (TedP)

Revision History:

    Jay Krell (JayKrell) April 2001 partial cleanup
                         many leaks added in attempt to stop it from crashing
                         crash doesn't repro consistently, but there's always a few
                         in a world build

                         June 2001 let it run on Win9x and Win2000

--*/
#include "stdinc.h"
#include "helpers.h"
#define XMLCHK_FLAG_SILENT      (0x00000001)
ULONG g_nrunFlags = 0; //global run flag - determines if should run in silent mode = 0x01
IClassFactory* g_XmlDomClassFactory;
IClassFactory* g_XmlSchemaCacheClassFactory;
__declspec(thread) long line = __LINE__;
__declspec(thread) ULONG lastError;
#if defined(_WIN64)
#define IsAtLeastXp() (TRUE)
#define g_IsNt (TRUE)
#else
DWORD g_Version;
BOOL  g_IsNt;
#define IsAtLeastXp() (g_IsNt && g_Version >= 0x0501)
#endif

// Globals indicating what we're currently doing.
// L"" is different than the default constructed, because it can be derefed
::ATL::CComBSTR szwcharSchemaTmp = L"";
::ATL::CComBSTR szwcharManTmp = L"";
bool g_fInBuildProcess = false;

// string to put in front of all error messages so that BUILD can find them.
const char ErrMsgPrefix[] = "NMAKE : U1234: 'FUSION_MANIFEST_VALIDATOR' ";

void ConvertNewlinesToSpaces(char* s)
{
    while (*s)
    {
        if (isspace(*s))
            *s = ' ';
        s += 1;
    }
}

void Error(PCSTR szPrintFormatString, ...)
{
    char StartBuffer[256];
    char *buffer = StartBuffer;
    int iAvailable = 256;

    if (g_fInBuildProcess)
        return;        

    while (buffer)
    {
        va_list args;
        int iUsed;
        va_start(args, szPrintFormatString);
        buffer[iAvailable - 1] = buffer[iAvailable - 2] = '\0';
        iUsed = _vsnprintf(buffer, iAvailable, szPrintFormatString, args);
        va_end(args);

        //
        // Used all the characters, or we stomped the canary?
        //
        if ((iUsed >= iAvailable) || (buffer[iAvailable - 1] != '\0'))
        {
            if (buffer != StartBuffer)
            {
                delete [] buffer;
            }
            iAvailable *= 2;
            buffer = new char[iAvailable];
            continue;
        }
        else
        {
            buffer[iUsed] = '\0';
            break;
        }
    }

    if (buffer)
    {
        ConvertNewlinesToSpaces(buffer);
    }
    
    printf("%s line=%ld, %s\n", ErrMsgPrefix, line, buffer);
    if (buffer && (buffer != StartBuffer))
        delete [] buffer;
}

void PrintOutMode(PCSTR szPrintFormatString, ...)
{
    if (g_fInBuildProcess)
        return;

    if ((g_nrunFlags & XMLCHK_FLAG_SILENT) == 0)
    {
        va_list args;
        va_start(args, szPrintFormatString);
        vprintf(szPrintFormatString, args);
        va_end(args);
    }
}

void PrintErrorDuringBuildProcess(IXMLDOMParseError* pError)
{
    HRESULT hr = S_OK;
    ::ATL::CComBSTR bstrError;
    long lErrorCode = 0;
    long lErrorLine = 0;

    if (FAILED(hr = pError->get_errorCode(&lErrorCode)))
        goto FailedGettingDetails;

    if (FAILED(hr = pError->get_line(&lErrorLine)))
        goto FailedGettingDetails;

    if (FAILED(hr = pError->get_reason(&bstrError)))
        goto FailedGettingDetails;

    //
    // Now print in a way that build is likely to pick up
    //
    printf(
        "%s : %ls(%ld) - %ls (Error 0x%08lx)\r\n",
        ErrMsgPrefix,
        static_cast<PCWSTR>(szwcharManTmp),
        lErrorLine,
        static_cast<PCWSTR>(bstrError),
        lErrorCode);

    return;

FailedGettingDetails:
    printf("%s : %ls had an error, but the error data was unavailable (Error 0x%08lx).\r\n",
        ErrMsgPrefix,
        static_cast<PCWSTR>(szwcharManTmp),
        hr);

    return;
        
}


void PrintError(IXMLDOMParseError *pError)
{
    ::ATL::CComBSTR   bstrError;
    ::ATL::CComBSTR   bstrURL;
    ::ATL::CComBSTR   bstrText;
    long            errCode = 0;
    long            errLine = 0;
    long            errPos = 0;
    HRESULT         hr = S_OK;
    long            line = __LINE__;
    try
    {
        line = __LINE__;
        hr = pError->get_reason(&bstrError);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_url(&bstrURL);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_errorCode(&errCode);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_srcText(&bstrText);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_line(&errLine);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_linepos(&errPos);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;

        PrintOutMode("\nError Info:\n");
        if (bstrError != NULL)
            PrintOutMode("\tDescription: %ls\n", static_cast<PCWSTR>(bstrError));

        if (bstrURL != NULL)
            PrintOutMode("\tURL: %ls\n", static_cast<PCWSTR>(bstrURL));

        //if (errCode > 0)
        PrintOutMode("\tCode=%X", errCode);

        if (errLine > 0)
            PrintOutMode(" on Line:%ld, ", errLine);

        if (errPos > 0)
            PrintOutMode("\tPos:%ld\n", errPos);

        line = __LINE__;
        if (errLine > 0 && bstrText != NULL)
        {
            PrintOutMode("\tLine %ld: ", errLine);

            long lLen = ::SysStringLen(bstrText);
            for (int i = 0; i < lLen; i++)
            {
                if (bstrText[i] == '\t')
                    PrintOutMode(" ");
                else
                    PrintOutMode("%lc", bstrText[i]);
            }
            PrintOutMode("\n");

            if (errPos > 0 || lLen > 0)
            {
                PrintOutMode("\tPos  %ld: ", errPos);
                for (int i = 1; i < errPos; i++)
                {
                    PrintOutMode("-");
                }
                PrintOutMode("^\n");
            }
        }
        line = __LINE__;
    }
    catch(HRESULT hr2)
    {
        Error("Failed getting error #1 information hr=%lx, line=%ld\n", static_cast<unsigned long>(hr2), line);
    }
}


//tedp
// Load an msxml version.  If we don't get v3, we fall to v2, then to v1.  v1 is pretty darn useless,
// however, so it'd be nice if we didn't have to.

bool
InitializeMSXML3()
{
    static HMODULE hMsXml3 = NULL;
    typedef HRESULT (__stdcall * PFN_DLL_GET_CLASS_OBJECT)(REFCLSID, REFIID, LPVOID*);
    PFN_DLL_GET_CLASS_OBJECT pfnGetClassObject = NULL;
    ::ATL::CComPtr<IClassFactory> pFactory;
    HRESULT hr = S_OK;
    ::ATL::CComPtr<IClassFactory> pSchemaCacheFactory;

    line = __LINE__;
    if (hMsXml3 == NULL)
    {
        hMsXml3 = LoadLibrary(TEXT("msxml3.dll"));
        if (hMsXml3 == NULL)
        {
            line = __LINE__;
            if (IsAtLeastXp())
                PrintOutMode("Unable to load msxml3, trying msxml2\n");
            line = __LINE__;
            if (IsAtLeastXp())
                hMsXml3 = LoadLibrary(TEXT("msxml2.dll"));
            line = __LINE__;
            if (hMsXml3 == NULL)
            {
                line = __LINE__;
                if (IsAtLeastXp())
                    PrintOutMode("Unable to load msxml2\n");
                line = __LINE__;
            }
        }
    }

    line = __LINE__;
    if (hMsXml3 == NULL)
    {
        if (IsAtLeastXp())
            Error("LoadLibrary(msxml) lastError=%lu\n", GetLastError());
        return false;
    }

    line = __LINE__;
    pfnGetClassObject = reinterpret_cast<PFN_DLL_GET_CLASS_OBJECT>(GetProcAddress(hMsXml3, "DllGetClassObject"));
    if (!pfnGetClassObject)
    {
        line = __LINE__;
        Error("GetProcAddress(msxml, DllGetClassObject) lastError=%lu\n", GetLastError());
        return false;
    }

    line = __LINE__;
    hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument30), __uuidof(pFactory), (void**)&pFactory);
    if (FAILED(hr))
    {
        PrintOutMode("Can't load version 3.0, trying 2.6\n");

        hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument26), __uuidof(pFactory), (void**)&pFactory);
        if (FAILED(hr))
        {
            PrintOutMode("Can't load version 2.6\n");
        }
    }
    pFactory->LockServer(TRUE); // possibly the right fix for the crash
    static_cast<IUnknown*>(pFactory)->AddRef(); // jaykrell hack to try to avoid crash
    static_cast<IUnknown*>(pFactory)->AddRef(); // jaykrell hack to try to avoid crash

    line = __LINE__;
    if (FAILED(hr))
    {
        Error("msxml.DllGetClassObject(DOMDocument) hr=%lx\n", hr);
        return false;
    }

    g_XmlDomClassFactory = pFactory;

    hr = pfnGetClassObject(__uuidof(MSXML2::XMLSchemaCache30), __uuidof(pFactory), (void**)&pSchemaCacheFactory);
    if (FAILED(hr))
    {
        PrintOutMode("Can't load SchemaCache version 3.0, trying 2.6\n");

        hr = pfnGetClassObject(__uuidof(MSXML2::XMLSchemaCache26), __uuidof(pFactory), (void**)&pSchemaCacheFactory);
        if (FAILED(hr))
        {
            PrintOutMode("Can't load SchemaCache version 2.6\n");
        }
    }
    pSchemaCacheFactory->LockServer(TRUE); // possibly the right fix for the crash
    static_cast<IUnknown*>(pSchemaCacheFactory)->AddRef(); // jaykrell hack to try to avoid crash
    static_cast<IUnknown*>(pSchemaCacheFactory)->AddRef(); // jaykrell hack to try to avoid crash

    if (FAILED(hr))
    {
        Error("msxml.DllGetClassObject(SchemaCache) hr=%lx\n", hr);
        return false;
    }

    g_XmlSchemaCacheClassFactory = pSchemaCacheFactory;

    return true;
}

BOOL
Validating(
    PCWSTR      SourceManName,
    PCWSTR      SchemaName
   )
{
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    short sResult = FALSE;
    VARIANT_BOOL vb = VARIANT_FALSE;
    ::ATL::CComPtr<IXMLDOMParseError> pParseError;
    ::ATL::CComPtr<IXMLDOMParseError> pParseError2;
    ::ATL::CComPtr<IXMLDOMDocument> document;
    ::ATL::CComPtr<MSXML2::IXMLDOMDocument2> spXMLDOMDoc2;
    ::ATL::CComPtr<MSXML2::IXMLDOMSchemaCollection> spIXMLDOMSchemaCollection;
    try
    {
        hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(document), (void**)&document);
        if (FAILED(hr))
        {
            Error("msxml.CreateInstance(document) hr=%lx\n", hr);
            throw hr;
        }
        if (document != NULL)
        {
            static_cast<IUnknown*>(document)->AddRef(); // jaykrell hack to try to avoid crash
            static_cast<IUnknown*>(document)->AddRef(); // jaykrell hack to try to avoid crash
        }

        //
        // If they're willing to deal with bad XML, then so be it.
        //

        // First pass - validating the manifest itself alone
        PrintOutMode("Validating the manifest as XML file...\n");
        hr = document->put_async(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        hr = document->put_validateOnParse(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        hr = document->put_resolveExternals(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        CFileStreamBase* fsbase = new CFileStreamBase; // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        ::ATL::CComPtr<IStream> istream = fsbase;

        if (!fsbase->OpenForRead(SourceManName))
        {
            lastError = GetLastError();
            hr = HRESULT_FROM_WIN32(lastError);
            Error("OpenForRead(%ls) lastError=%lu\n", SourceManName, lastError);
            throw hr;
        }

        hr = document->load(::ATL::CComVariant(istream), &vb);
        if (FAILED(hr) || vb == VARIANT_FALSE)
        {
            if (vb == VARIANT_FALSE)
            PrintOutMode("Well Formed XML Validation: FAILED\n");
            {
                HRESULT loc_hr = document->get_parseError(&pParseError);
                if (pParseError != NULL)
                {
                    static_cast<IUnknown*>(pParseError)->AddRef(); // jaykrell hack to try to avoid crash
                    static_cast<IUnknown*>(pParseError)->AddRef(); // jaykrell hack to try to avoid crash
                }
                if (g_fInBuildProcess)
                    PrintErrorDuringBuildProcess(pParseError);
                else
                    PrintError(pParseError);
            }
            throw hr;
        }
        else
            PrintOutMode("Well Formed XML Validation: Passed\n");

        // Second pass - validating manifest against schema
        PrintOutMode("\nNow validating manifest against XML Schema file...\n");

        // CreateInstance creates you an instance of the object you requested above, and puts
        // the pointer in the out param.  Think of this like CoCreateInstance, but knowing who
        // is going
        hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(spXMLDOMDoc2), (void**)&spXMLDOMDoc2);
        if (FAILED(hr))
        {
             PrintOutMode("Failed creating IXMLDOMDoc2...\n");
            throw hr;
        }
        static_cast<IUnknown*>(spXMLDOMDoc2)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spXMLDOMDoc2)->AddRef(); // jaykrell hack to try to avoid crash

         hr = spXMLDOMDoc2->put_async(VARIANT_FALSE);
         if (FAILED(hr))
            throw hr;

         hr = spXMLDOMDoc2->put_validateOnParse(VARIANT_TRUE); //changed - was FALSE
         if (FAILED(hr))
            throw hr;

         hr = spXMLDOMDoc2->put_resolveExternals(VARIANT_FALSE);
         if (FAILED(hr))
            throw hr;

         hr = g_XmlSchemaCacheClassFactory->CreateInstance(NULL, __uuidof(spIXMLDOMSchemaCollection), (void**)&spIXMLDOMSchemaCollection);
         if (FAILED(hr))
         {
             PrintOutMode("Failed creating IXMLDOMSchemaCollection...\n");
             throw hr;
         }
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash

         if ((FAILED(hr) || !spIXMLDOMSchemaCollection))
            throw hr;

           
        hr = spIXMLDOMSchemaCollection->add(
            ::ATL::CComBSTR(L"urn:schemas-microsoft-com:asm.v1"),
            ::ATL::CComVariant(SchemaName));

        if(FAILED(hr))
        {
            PrintOutMode("BAD SCHEMA file.\n");
            throw hr;
        }

        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        // ownership of the idispatch/variant-by-value is not clear
        ::ATL::CComVariant varValue(::ATL::CComQIPtr<IDispatch>(spIXMLDOMSchemaCollection).Detach());
        hr = spXMLDOMDoc2->putref_schemas(varValue);

        // The document will load only if a valid schema is
        // attached to the xml file.
        // jaykrell leak here because ownership isn't clear
        hr = spXMLDOMDoc2->load(::ATL::CComVariant(::ATL::CComBSTR(SourceManName).Copy()), &sResult);

        if (FAILED(hr) || sResult == VARIANT_FALSE)
        {
            PrintOutMode("Manifest Schema Validation: FAILED\n");
            if (sResult == VARIANT_FALSE)
            {
                HRESULT loc_hr = spXMLDOMDoc2->get_parseError(&pParseError2);
                if (pParseError2 != NULL)
                {
                    static_cast<IUnknown*>(pParseError2)->AddRef(); // jaykrell hack to try to avoid crash
                    static_cast<IUnknown*>(pParseError2)->AddRef(); // jaykrell hack to try to avoid crash
                }
                if (g_fInBuildProcess)
                    PrintErrorDuringBuildProcess(pParseError2);
                else
                    PrintError(pParseError2);
                bResult = FALSE;
            }
            else
            {
                throw hr;
            }
        }
        else
        {
            PrintOutMode("Manifest Schema Validation: Passed\n");
            bResult = TRUE;
        }
   }
   catch(HRESULT hr)
   {
        bResult = FALSE;
        if (E_NOINTERFACE == hr)
        {
            Error("*** Error *** No such interface supported! \n");
        }
        else
        {
            ::ATL::CComPtr<IErrorInfo> pErrorInfo;
            HRESULT loc_hr = GetErrorInfo(0, &pErrorInfo);
            if (pErrorInfo != NULL)
            {
                static_cast<IUnknown*>(pErrorInfo)->AddRef(); // jaykrell hack to try to avoid crash
                static_cast<IUnknown*>(pErrorInfo)->AddRef(); // jaykrell hack to try to avoid crash
            }
            
            if ((S_OK == loc_hr) && pErrorInfo != NULL)
            {
                ::ATL::CComQIPtr<IXMLError> pXmlError(pErrorInfo);
                XML_ERROR xError;
                ::ATL::CComBSTR errSource;
                ::ATL::CComBSTR errDescr;
                pErrorInfo->GetDescription(&errDescr);
                pErrorInfo->GetSource(&errSource);

                Error("*** ERROR *** generated by %ls\n", static_cast<PCWSTR>(errSource));
                Error("*** ERROR *** description: %ls\n", static_cast<PCWSTR>(errDescr));
                if (pXmlError)
                {
                    pXmlError->GetErrorInfo(&xError);
                    Error("*** ERROR *** document line %d, text '%.*ls'\n", xError._nLine, xError._pchBuf, xError._cchBuf);
                }                
            }
            else
            {
                if (hr == CO_E_CLASSSTRING)
                {
                    Error("*** Error *** hr returned: CO_E_CLASSSTRING, value %x\n", hr);
                    Error("              msg: The registered CLSID for the ProgID is invalid.\n");
                }
                else
                {
                    Error("*** Error *** Cannot obtain additional error info hr=%lx!\n", static_cast<unsigned long>(hr));
                }
            }
        }
    }
    return bResult;
}

BOOL IsValidCommandLineArgs(int argc, wchar_t** argv, ::ATL::CComBSTR& szwcharSchemaTmp, ::ATL::CComBSTR& szwcharManTmp)
{
    // check commandline args a little
    int nOnlyAllowFirstTimeReadFlag = 0; //Manifest = 0x01 Schema = 0x02 Quiet = 0x04
    if((4 >= argc) && (3 <= argc))
    {
        //now check actual values

        for (int i = 1; i < argc; i++)
        {
            if (argv[i][0] == L'/')
            {
                switch (argv[i][1])
                {
                case L'?': return FALSE; break;
                case L'q': case L'Q':
                    if(0x04 & nOnlyAllowFirstTimeReadFlag)
                        return FALSE;
                    else
                        g_nrunFlags |= XMLCHK_FLAG_SILENT;

                    nOnlyAllowFirstTimeReadFlag = 0x04;
                    break;
                case L'm': case L'M':
                    if (argv[i][2] == L':')
                        {
                        if(0x01 & nOnlyAllowFirstTimeReadFlag)
                            return FALSE;
                        else
                            szwcharManTmp = &argv[i][3];

                        nOnlyAllowFirstTimeReadFlag = 0x01;
                        break;
                        }
                    else
                        {
                        return FALSE;
                        }
                case L's': case L'S':
                    if (argv[i][2] == L':')
                        {
                        if(0x02 & nOnlyAllowFirstTimeReadFlag)
                            return FALSE;
                        else
                            szwcharSchemaTmp = &argv[i][3];

                        nOnlyAllowFirstTimeReadFlag = 0x02;
                        break;
                    }
                    else
                    {
                        return FALSE;
                    }
                case L'B': case L'b':
                    g_fInBuildProcess = true;
                    break;

                default:
                    return FALSE;
                }
            }
            else
                return FALSE;

        }
        if ((0 == szwcharSchemaTmp[0]) ||
            (0 == szwcharManTmp[0]))
        {
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void PrintUsage()
{
    printf("\n");
    printf("Validates Fusion Win32 Manifest files using a schema.");
    printf("\n");
    printf("Usage:");
    printf("    FusionManifestValidator /S:[drive:][path]schema_filename /M:[drive:][path]xml_manifest_filename [/Q]\n\n");
    printf("    /S:   Specify schema filename used to validate manifest\n");
    printf("    /M:   Specify manifest filename to validate\n");
    printf("    /Q    Quiet mode - suppresses output to console\n");
    printf("     \n");
    printf("          The tool without /Q displays details of first encountered error\n");
    printf("          (if errors are present in manifest), and displays Pass or Fail\n");
    printf("          of the validation result. The application returns 0 for Pass,\n");
    printf("          1 for Fail, and returns 2 for bad command line argument.\n");
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    int iValidationResult = 0;

#if !defined(_WIN64)
    g_Version = GetVersion();
    g_IsNt = ((g_Version & 0x80000000) == 0);
    g_Version = ((g_Version >> 8) & 0xFF) | ((g_Version & 0xFF) << 8);
    //printf("%x\n", g_Version);
#endif

    // Start COM
    CoInitialize(NULL);

    if (!IsValidCommandLineArgs(argc, argv, szwcharSchemaTmp, szwcharManTmp))
    {
        PrintUsage();
        iValidationResult = 2;  //return error value 2 for CommandLine Arg error
    }
    else
    {
        PrintOutMode("Schema is: %ls\n", static_cast<PCWSTR>(szwcharSchemaTmp));
        PrintOutMode("Manifest is: %ls\n\n", static_cast<PCWSTR>(szwcharManTmp));
        if (InitializeMSXML3())
        {
            BOOL bResult = Validating(szwcharManTmp, szwcharSchemaTmp);
            if (bResult)
                PrintOutMode("\nOverall Validation PASSED.\n");
            else
            {
                Error("Overall Validation FAILED, CommandLine=%ls.\n", GetCommandLineW());
                iValidationResult = 1; //return error value 1 for Validation routine error
            }
        }
        else
        {
            //
            // If running on less than Windows XP, just claim success.
            //
            if (IsAtLeastXp())
            {
                Error("Unable to load MSXML3\n");
                iValidationResult = 3;
            }
            else
                PrintOutMode("\nMsXml3 not always available downlevel, just claim overall Validation PASSED.\n");
        }
    }
    // Stop COM
    CoUninitialize();
    // TerminateProcess(GetCurrentProcess(), iValidationResult);
    return iValidationResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\genlib\genmisc.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    genmisc.c

Abstract:

    thunk generation tool stuff

Author:

    ??-???-?? Unknown

Revision History:

  January 2002 JayKrell
    integrated /private/winfuse_longhorn/base/tools to /lab01_n/base/win32/fusion/tools
    some -W4 cleanup

--*/

#pragma warning(disable:4057)   /* char vs. unsigned char mixup */
#pragma warning(disable:4100)   /* unreferenced formal parameter */
#pragma warning(disable:4115)   /* named type definition in parentheses */
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4201)   /* nameless struct/union */
#pragma warning(disable:4214)   /* bit field types other than int */
#pragma warning(disable:4267)   /* conversion from 'size_t' to 'int', possible loss of data */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

BOOLEAN bDebug = FALSE;
BOOLEAN bExitClean= TRUE;

char szNULL[]="";
char szVARGS[]="...";
char szCONST[] = "const";
char szVOLATILE[] = "volatile";
char szREGISTER[] = "register";
char szEXTERN[] = "extern";
char sz_CDECL[] = "__cdecl";
char szCDECL[] = "_cdecl";
char szSTDCALL[] = "__stdcall";
char sz__FASTCALL[] = "__fastcall";
char szUNALIGNED[] = "__unaligned";
char szTYPEDEF[] = "typedef";
char szCHAR[] = "char";
char szINT[] = "int";
char szLONG[] = "long";
char szSHORT[] = "short";
char szDOUBLE[] = "double";
char szENUM[] = "enum";
char szFLOAT[] = "float";
char szSTRUCT[] = "struct";
char szUNION[] = "union";
char szVOID[] = "void";
char szINT64[] = "_int64";
char sz_INT64[] = "__int64";
char sz__PTR64[] = "__ptr64";
char szFUNC[] = "()";
char szSIGNED[] = "signed";
char szUNSIGNED[] = "unsigned";
char szSTATIC[] = "static";
char szIN[] = "__in";
char szOUT[] = "__out";
char szINOUT[] = "__in __out";
char szGUID[] = "GUID";
char sz__W64[] = "__w64";

char szPragma[] = "#pragma";
char szPack[] = "pack";
char szPush[] = "push";
char szPop[] = "pop";

char szFUNCTIONS[]  = "Functions";
char szSTRUCTURES[] = "Structures";
char szTYPEDEFS[]   = "TypeDefs";
char szUNSIGNEDCHAR[] = "unsigned char";
char szUNSIGNEDSHORT[] = "unsigned short";
char szUNSIGNEDLONG[] = "unsigned long";


DEFBASICTYPES DefaultBasicTypes[] = {
      { "unsigned int" },
      { "int" },
      { "short int" },
      { "unsigned short int" },
      { "long int" },
      { "unsigned long int" },
      { "char" },
      { "unsigned char" },
      { szINT64 },
      { sz_INT64 },
      { szGUID    },
      { szDOUBLE  },
      { szFLOAT   },
      { szENUM    },
      { szSTRUCT  },
      { szUNION   },
      { szVOID    },
      { szFUNC    }
     };

CHAR szVTBL[] = "VTBL";

#define NUMDEFBASICTYPES sizeof(DefaultBasicTypes)/sizeof(DEFBASICTYPES);

// List mapping TokenTypes to human-readable strings.  TK_NONE, TK_IDENTIFIER,
// TK_NUMBER, and TK_STRING must be special-cased.
char *TokenString[] = {
    "",             // TK_NONE
    "",             // TK_IDENTIFIER
    "",             // TK_NUMBER
    "+",            // TK_PLUS
    "-",            // TK_MINUS
    "*",            // TK_STAR
    "/",            // TK_DIVIDE
    "[",            // TK_LSQUARE
    "]",            // TK_RSQUARE
    "{",            // TK_LBRACE
    "}",            // TK_RBRACE
    "(",            // TK_LPAREN
    ")",            // TK_RPAREN
    "...",          // TK_VARGS
    "const",        // TK_CONST
    "volatile",     // TK_VOLATILE
    "register",     // TK_REGISTER
    "extern",       // TK_EXTERN
    "__cdecl",      // TK_CDECL
    "__stdcall",    // TK_STDCALL
    "typedef",      // TK_TYPEDEF
    "static",       // TK_STATIC
    ",",            // TK_COMMA
    ";",            // TK_SEMI
    "struct",       // TK_STRUCT
    "union",        // TK_UNION
    "enum",         // TK_ENUM
    "__inline",     // TK_INLINE
    ":",            // TK_COLON
    "=",            // TK_ASSIGN
    ".",            // TK_DOT
    "<<",           // TK_LSHIFT
    ">>",           // TK_RSHIFT
    "<",            // TK_LESS
    ">",            // TK_GREATER
    "__unaligned",  // TK_UNALIGNED
    "__declspec",   // TK_DECLSPEC
    "__restrict",   // TK_RESTRICT  (MIPS-only keyword - a pointer modifier)
    "__fastcall",   // TK_FASTCALL
    "__in",         // TK_IN
    "__out",        // TK_OUT
    "__in __out",   // TK_INOUT
    "&",            // TK_BITWISE_AND
    "|",            // TK_BITWISE_OR
    "&&",           // TK_LOGICAL_AND
    "||",           // TK_LOGICAL_OR
    "%",            // TK_MOD
    "^",            // TK_XOR
    "!",            // TK_NOT
    "~",            // TK_TILDE
    "",             // TK_STRING
    "sizeof",       // TK_SIZEOF
    "template",     // TK_TEMPLATE
    "__w64",        // TK___W64
    ""              // TK_EOS
};


// List of keyword names.  When an identifier is recognized, it is
// compared against this list, and if it matches, TK_IDENTIFIER is
// replaced by the appropriate keyword token id.
//
// NOTE: This must remain in sorted order.
TOKENMATCH KeywordList[] = {
    { TK_CDECL,     "__cdecl"     },
    { TK_DECLSPEC,  "__declspec"  },
    { TK_FASTCALL,  "__fastcall"  },
    { TK_INLINE,    "__forceinline" },
    { TK_IN,        "__in"        },
    { TK_INLINE,    "__inline"    },
    { TK_OUT,       "__out"       },
    { TK_RESTRICT,  "__restrict"  },
    { TK_STDCALL,   "__stdcall"   },
    { TK_UNALIGNED, "__unaligned" },
    { TK___W64,     "__w64"       },
    { TK_CDECL,     "_cdecl"      },
    { TK_FASTCALL,  "_fastcall"   },
    { TK_INLINE,    "_inline"     },
    { TK_STRUCT,    "class"       },
    { TK_CONST,     "const"       },
    { TK_ENUM,      "enum"        },
    { TK_EXTERN,    "extern"      },
    { TK_INLINE,    "inline"      },
    { TK_REGISTER,  "register"    },
    { TK_SIZEOF,    "sizeof"      },
    { TK_STATIC,    "static"      },
    { TK_STRUCT,    "struct"      },
    { TK_TEMPLATE,  "template"    },
    { TK_TYPEDEF,   "typedef"     },
    { TK_UNION,     "union"       },
    { TK_VOLATILE,  "volatile"    },
    { TK_NONE,      NULL          }
};


LIST_ENTRY OpenFileHead= {&OpenFileHead, &OpenFileHead};

typedef struct _OpenFileEntry {
    LIST_ENTRY FileEntry;
    HANDLE hFile;
    FILE *fp;
    char FileName[MAX_PATH+1];
} OPENFILEENTRY, *POPENFILEENTRY;

TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
int CurrentTokenIndex;

void
CheckForKeyword(
    PTOKEN Token
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    )
/*++

Routine Description:

    Called if user hits Ctrl+C or Ctrl+Break.  Closes all open files,
    allowing for a graceful exit.

Arguments:

    dwCtrlType -- ????

Return Value:

    ????

--*/
{
    CloseOpenFileList(TRUE);
    return FALSE;
}


BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Records that a file has been opened.  If an error occurs within
    the app, files in this list will be closed.

Arguments:

    FileName    -- name of open file
    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    TRUE if file added to the list, FALSE if failure (probably out of memory)

--*/
{
    POPENFILEENTRY pofe;

    pofe = GenHeapAlloc(sizeof(OPENFILEENTRY));
    if (!pofe) {
        ErrMsg("AddOpenWriteFile: insuf memory: %s\n", strerror(errno));
        return FALSE;
    }
    pofe->fp = fp;
    pofe->hFile = hFile;
    strcpy(pofe->FileName, FileName);

    InsertHeadList(&OpenFileHead, &pofe->FileEntry);
    return TRUE;
}


void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Deletes a file from the open file list.  Note that the file is not
    closed, the caller must do that.

Arguments:

    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if ((fp && pofe->fp == fp) || (hFile && pofe->hFile == hFile)) {
            RemoveEntryList(&pofe->FileEntry);
            GenHeapFree(pofe);
            return;
        }

        Next= Next->Flink;
    }
}



void
CloseOpenFileList(
    BOOL DeleteFiles
    )
/*++

Routine Description:

    Closes all open files and optionally deletes the files themselves.

Arguments:

    DeleteFiles -- TRUE if open files are to be deleted.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if (pofe->fp) {
            fclose(pofe->fp);
        } else if (pofe->hFile) {
            CloseHandle(pofe->hFile);
        }

        if (DeleteFiles && bExitClean) {
            DeleteFile(pofe->FileName);
        }

        // cheat, skip mem cleanup since we know we are exiting
        // GenHeapFree(pofe);

        Next= Next->Flink;
    }
}





void
DumpKnownTypes(
     PKNOWNTYPES pKnownTypes,
     FILE *fp
     )
/*++

Routine Description:

    Outputs the contents of a PKNOWNTYPES in a semi-readable format.

Arguments:

    pKnownTypes -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pKnownTypes->Flags,
                pKnownTypes->IndLevel,
                pKnownTypes->RetIndLevel,
                pKnownTypes->Size,
                pKnownTypes->BasicType,
                pKnownTypes->BaseName ? pKnownTypes->BaseName : szNULL,
                pKnownTypes->FuncRet ? pKnownTypes->FuncRet : szNULL,
                pKnownTypes->FuncMod ? pKnownTypes->FuncMod : szNULL,
                pKnownTypes->TypeName
                );

}


void
DumpTypesInfo(
    PTYPESINFO pTypesInfo,
    FILE *fp
    )
/*++

Routine Description:

    Outputs the contents of a PTYPESINFO in a semi-readable format.

Arguments:

    pTypesInfo  -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pTypesInfo->Flags,
                pTypesInfo->IndLevel,
                pTypesInfo->RetIndLevel,
                pTypesInfo->Size,
                pTypesInfo->BasicType,
                pTypesInfo->BaseName ? pTypesInfo->BaseName : szNULL,
                pTypesInfo->FuncRet  ? pTypesInfo->FuncRet : szNULL,
                pTypesInfo->FuncMod  ? pTypesInfo->FuncMod : szNULL,
                pTypesInfo->TypeName
                );
}




void
FreeTypesList(
    PRBTREE ptree
    )
/*++

Routine Description:

    Frees an entire red-black tree.

Arguments:

    ptree   -- tree to free.

Return Value:

    None.

--*/
{
    PKNOWNTYPES pNext, pNode;

    pNode = ptree->pLastNodeInserted;
    while (pNode) {
        pNext = pNode->Next;
        GenHeapFree(pNode);
        pNode = pNext;
    }
    RBInitTree(ptree);
}




PKNOWNTYPES
GetBasicType(
    char *sTypeName,
    PRBTREE TypeDefsList,
    PRBTREE StructsList
    )
/*++

Routine Description:

    Determines the basic type of a typedef.

Arguments:

    sTypeName       -- type name to look up
    TypeDefsList    -- list of typedefs
    StructsList     -- list of structs

Return Value:

    Ptr to the KNOWNTYPES for the basic type, or NULL if no basic type
    found.

--*/
{
    PKNOWNTYPES pkt, pktLast;

    //
    // go down the typedef list
    //
    pktLast = NULL;
    for (pkt = GetNameFromTypesList(TypeDefsList, sTypeName);
                                      (pkt != NULL) && (pkt != pktLast); ) {
        pktLast = pkt;
        pkt = GetNameFromTypesList(TypeDefsList, pktLast->BaseName);
    }

    //
    // see what the the final typedef stands for
    //
    if (pktLast == NULL) {
        pkt = GetNameFromTypesList(StructsList, sTypeName);
    } else {
        if (strcmp(pktLast->BasicType, szSTRUCT)) {
            pkt = pktLast;
        } else {
                                // if base type a struct get its definition
            pkt = GetNameFromTypesList(StructsList, pktLast->BaseName);
        }
    }

    return pkt;
}


PDEFBASICTYPES
GetDefBasicType(
    char *pBasicType
    )
/*++

Routine Description:

    Determines if a typename is a basic type, and if so, which one.

Arguments:

    pBasicType      -- typename to examine

Return Value:

    Ptr to the basic type info if pBasicType is a basic type.
    NULL if the type is not a default basic type (int, sort, struct, etc.)

--*/
{
    PDEFBASICTYPES pDefBasicTypes = DefaultBasicTypes;
    int i = NUMDEFBASICTYPES;

    do {
        if (!strcmp(pDefBasicTypes->BasicType, pBasicType)) {
            return pDefBasicTypes;
        }
        pDefBasicTypes++;
    } while (--i);

    return NULL;
}


PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pKnownTypes,
     char *pTypeName
     )
/*++

Routine Description:

    Searches a type list for a type name.

Arguments:

    pKnownType  -- type list to search
    pTypeName   -- type name to look for

Return Value:

    Ptr to the type info if pTypeName is in the list.
    NULL if the type was not found.

--*/
{
   //
   // Find the entry in the Red/Black tree
   //
   return RBFind(pKnownTypes, pTypeName);
}



PVOID
TypesListMalloc(
    ULONG Len
    )
/*++

Routine Description:

    Default memory allocator used to allocate a new KNOWNTYPES.
    It can be overridden by setting fpTypesListMalloc.

Arguments:

    Len     -- number of bytes of memory to allocate.

Return Value:

    Ptr to the memory or NULL of out-of-memory.

--*/
{
    return GenHeapAlloc(Len);
}

PVOID (*fpTypesListMalloc)(ULONG Len) = TypesListMalloc;

VOID
ReplaceInfoInKnownTypes(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
{

    BYTE *pNames;
    int Len;
    int SizeBasicType, SizeBaseName, SizeMembers, SizeFuncMod, SizeFuncRet;
    int SizeTypeName, SizeBaseType, SizeMethods, SizeIMethods, SizeFileName;

    SizeBasicType = strlen(pTypesInfo->BasicType) + 1;
    SizeBaseName = strlen(pTypesInfo->BaseName) + 1;
    SizeFuncRet = strlen(pTypesInfo->FuncRet) + 1;
    SizeFuncMod = strlen(pTypesInfo->FuncMod) + 1;
    SizeTypeName = strlen(pTypesInfo->TypeName) + 1;
    SizeMembers = pTypesInfo->dwMemberSize;
    SizeBaseType = strlen(pTypesInfo->BaseType) + 1;
    SizeFileName = strlen(pTypesInfo->FileName) + 1;
    SizeMethods = SizeOfMultiSz(pTypesInfo->Methods);
    SizeIMethods = SizeOfMultiSz(pTypesInfo->IMethods);

    // The extra sizeof(DWORD) allows the Members[] array to be DWORD-aligned
    Len = SizeBasicType + SizeBaseName + SizeMembers + SizeFuncMod +
        SizeFuncRet + SizeTypeName + SizeBaseType + SizeFileName + SizeMethods + SizeIMethods + sizeof(DWORD_PTR);

    pNames = (*fpTypesListMalloc)(Len);
    if (!pNames) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        ExitErrMsg(FALSE, "Out of memory!\n");
    }

    memset(pNames, 0, Len);

    pKnownTypes->Flags        = pTypesInfo->Flags;
    pKnownTypes->IndLevel     = pTypesInfo->IndLevel;
    pKnownTypes->RetIndLevel  = pTypesInfo->RetIndLevel;
    pKnownTypes->Size         = pTypesInfo->Size;
    pKnownTypes->iPackSize    = pTypesInfo->iPackSize;
    pKnownTypes->gGuid        = pTypesInfo->gGuid;
    pKnownTypes->dwVTBLSize   = pTypesInfo->dwVTBLSize;
    pKnownTypes->dwVTBLOffset = pTypesInfo->dwVTBLOffset;
    pKnownTypes->TypeId       = pTypesInfo->TypeId;
    pKnownTypes->LineNumber   = pTypesInfo->LineNumber;
    pKnownTypes->dwCurrentPacking = pTypesInfo->dwCurrentPacking;
    pKnownTypes->dwScopeLevel = pTypesInfo->dwScopeLevel;
    pKnownTypes->dwArrayElements = pTypesInfo->dwArrayElements;
    pKnownTypes->dwBaseSize   = pTypesInfo->dwBaseSize;
    pKnownTypes->pTypedefBase = pTypesInfo->pTypedefBase;
    Len = 0;

    pKnownTypes->BasicType = pNames + Len;
    strcpy(pKnownTypes->BasicType, pTypesInfo->BasicType);
    Len += SizeBasicType;

    pKnownTypes->BaseName = pNames + Len;
    strcpy(pKnownTypes->BaseName, pTypesInfo->BaseName);
    Len += SizeBaseName;

    pKnownTypes->FuncRet = pNames + Len;
    strcpy(pKnownTypes->FuncRet, pTypesInfo->FuncRet);
    Len += SizeFuncRet;

    pKnownTypes->FuncMod = pNames + Len;
    strcpy(pKnownTypes->FuncMod, pTypesInfo->FuncMod);
    Len += SizeFuncMod;

    if (SizeFileName > 0) {
        pKnownTypes->FileName = pNames + Len;
        strcpy(pKnownTypes->FileName, pTypesInfo->FileName);
        Len += SizeFileName;
    }
    else pKnownTypes->FileName = NULL;

    // Ensure that Members[] is DWORD-aligned, so the structures within the
    // Members[] are aligned.
    Len = (Len+sizeof(DWORD_PTR)) & ~(sizeof(DWORD_PTR)-1);

    if (SizeMembers == 0) {
        pKnownTypes->Members = NULL;
        pKnownTypes->pmeminfo = NULL;
        pKnownTypes->pfuncinfo = NULL;
    }
    else {
        pKnownTypes->Members = pNames + Len;
        memcpy(pKnownTypes->Members, pTypesInfo->Members, SizeMembers);

        //
        // Fix up pointers within the Members data, so they point into the
        // pKnownTypes data instead of the pTypesInfo.
        //
        pKnownTypes->pfuncinfo = RelocateTypesInfo(pKnownTypes->Members,
            pTypesInfo);

        if (pTypesInfo->TypeKind == TypeKindStruct) {
            pKnownTypes->pmeminfo = (PMEMBERINFO)pKnownTypes->Members;
        }
        Len += SizeMembers;
    }

    if (SizeMethods == 0) pKnownTypes->Methods = NULL;
    else {
        pKnownTypes->Methods = pNames + Len;
        memcpy(pKnownTypes->Methods, pTypesInfo->Methods, SizeMethods);
        Len += SizeMethods;
    }

    if (SizeIMethods == 0) pKnownTypes->IMethods = NULL;
    else {
        pKnownTypes->IMethods = pNames + Len;
        memcpy(pKnownTypes->IMethods, pTypesInfo->IMethods, SizeIMethods);
        Len += SizeIMethods;
    }

    pKnownTypes->BaseType = pNames + Len;
    strcpy(pKnownTypes->BaseType, pTypesInfo->BaseType);
    Len += SizeBaseType;

    pKnownTypes->TypeName = pNames + Len;
    strcpy(pKnownTypes->TypeName, pTypesInfo->TypeName);
    Len += SizeTypeName;

}

PKNOWNTYPES
AddToTypesList(
   PRBTREE pTree,
   PTYPESINFO pTypesInfo
   )
/*++

Routine Description:

    Adds a PTYPESINFO to the list of known types.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pTree       -- types list to add the new type to
    pTypesInfo  -- the type to add.

Return Value:

    Ptr to the new PKNOWNTYPES, or NULL if out-of-memory.

--*/
{
    PKNOWNTYPES pKnownTypes;

    pKnownTypes = (*fpTypesListMalloc)(sizeof(KNOWNTYPES));
    if (!pKnownTypes) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        return pKnownTypes;
    }

    memset(pKnownTypes, 0, sizeof(KNOWNTYPES));

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    RBInsert(pTree, pKnownTypes);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }

    return pKnownTypes;
}


void
ReplaceInTypesList(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Replaces an existing PKNOWNTYPES with a new PTYPESINFO.  The old data
    is overwritten with new data, so pointers to the old PKNOWNTYPES will
    still be valid.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pKnownTypes -- type to overwrite
    pTypesInfo  -- the type to add.

Return Value:

    None.

--*/
{

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }
}


PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    )
/*++

Routine Description:

    Adjusts pointers within the Members[] array which point back into
    the Members[].  After a TYPESINFO is copied, the destination TYPESINFO
    or KNOWNTYPES Members[] array must be relocated.

Arguments:

    dest        -- start of the destination Members[] data
    src         -- the source TYPESINFO from which the Members[] was copied

Return Value:

    Address for first pfuncinfo within dest, NULL if dest does not contain
    funcinfos.  Destination Members[] data is relocated no matter what.

--*/
{
    INT_PTR iPtrFix;
    PMEMBERINFO pmeminfo;
    PFUNCINFO pfuncinfo;
    PFUNCINFO pfuncinfoRet = NULL;

    iPtrFix = (INT_PTR)(dest - src->Members);
    if (src->TypeKind == TypeKindStruct) {

        pmeminfo = (PMEMBERINFO)dest;

        while (pmeminfo != NULL) {
            if (pmeminfo->pmeminfoNext != NULL) {
                pmeminfo->pmeminfoNext = (PMEMBERINFO)
                                    ((char *)pmeminfo->pmeminfoNext + iPtrFix);
            }
            if (pmeminfo->sName != NULL) {
                if (pmeminfo->sName < src->Members || pmeminfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pmeminfo->sName += iPtrFix;
            }
            if (pmeminfo->sType != NULL) {
                if (pmeminfo->sType < src->Members || pmeminfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pmeminfo->sType += iPtrFix;
            }
            pmeminfo = pmeminfo->pmeminfoNext;
        }
    } else if (src->TypeKind == TypeKindFunc) {

        //
        // Make pfuncinfo point into the 'dest' array by fixing up the
        // source pointer.
        //
        pfuncinfo = (PFUNCINFO)((INT_PTR)src->pfuncinfo + iPtrFix);
        if ((char *)pfuncinfo < dest || (char *)pfuncinfo > dest+FUNCMEMBERSIZE) {
            ExitErrMsg(FALSE, "RelocateTypesInfo: pfuncinfo bad\n");
        }
        pfuncinfoRet = pfuncinfo;

        while (pfuncinfo != NULL) {
            if (pfuncinfo->pfuncinfoNext) {
                pfuncinfo->pfuncinfoNext = (PFUNCINFO)
                                    ((char *)pfuncinfo->pfuncinfoNext + iPtrFix);
            }
            if (pfuncinfo->sName != NULL) {
                if (pfuncinfo->sName < src->Members || pfuncinfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pfuncinfo->sName += iPtrFix;
            }
            if (pfuncinfo->sType != NULL) {
                if (pfuncinfo->sType < src->Members || pfuncinfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pfuncinfo->sType += iPtrFix;
            }
            pfuncinfo = pfuncinfo->pfuncinfoNext;
        }
    }

    return pfuncinfoRet;
}


BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO  pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Parses the Tokens[] and recognizes the following syntaxes:
        BasicType
        DerivedType
        unsigned|signed <int type>
        unsigned|signed
        unsigned|signed short|long int
        short|long int

Arguments:

    pTypesList      -- list of known types
    pTypesInfo      -- [OPTIONAL OUT] info about the type that was recognized
    ppKnownTypes    -- [OPTIONAL OUT] KNOWNTYPES info about the type

Return Value:

    TRUE - type was recognized.  pTypeInfo and ppKnownTypes are set,
           CurrentToken() points to token following the type.
    FALSE - type not recognized.

--*/
{
    PKNOWNTYPES pkt;
    char TypeName[MAX_PATH];
    char *SizeMod = NULL;
    char *SignMod = NULL;

    if (pTypesInfo) {
        memset(pTypesInfo, 0, sizeof(TYPESINFO));
    }

    switch (CurrentToken()->TokenType) {
    case TK_STRUCT:
    case TK_UNION:
    case TK_ENUM:
        ConsumeToken();
        break;

    case TK_VARGS:
        pkt = GetNameFromTypesList(pTypesList, szVARGS);
        ConsumeToken();
        goto PKTExit;

    default:
        break;
    }


    //
    // Process 'long', 'short', 'signed' and 'unsigned' modifiers
    //
    while (CurrentToken()->TokenType == TK_IDENTIFIER) {
        if (strcmp(CurrentToken()->Name, szLONG) == 0) {
            SizeMod = szLONG;
        } else if (strcmp(CurrentToken()->Name, szSHORT) == 0) {
            SizeMod = szSHORT;
        } else if (strcmp(CurrentToken()->Name, szUNSIGNED) == 0) {
            SignMod = szUNSIGNED;
        } else if (strcmp(CurrentToken()->Name, szSIGNED) == 0) {
            SignMod = NULL;
        } else {
            break;
        }
        ConsumeToken();
    }

    //
    // Convert the modifier list into a standardized type string and
    // look it up.
    //
    TypeName[0] = '\0';
    if (SignMod) {
        strcpy(TypeName, SignMod);
    }
    if (SizeMod) {
        if (TypeName[0]) {
            strcat(TypeName, " ");
        }
        strcat(TypeName, SizeMod);
    }

    //
    // Append the type name to the optional list of type modifiers
    //
    if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        if (TypeName[0] == '\0') {
            return FALSE;   // no qualifiers, so not a type
        }
        //
        // Append the implict 'int' on the end of the type qualifiers
        //
        strcat(TypeName, " ");
        strcat(TypeName, szINT);
    } else {
        char *Name = CurrentToken()->Name;

        if (strcmp(Name, szVOID) == 0 ||
            strcmp(Name, szINT) == 0 ||
            strcmp(Name, szINT64) == 0 ||
            strcmp(Name, sz_INT64) == 0 ||
            strcmp(Name, szCHAR) == 0 ||
            strcmp(Name, szFLOAT) == 0 ||
            strcmp(Name, szDOUBLE) == 0) {

            // Append the intrinsic type to the list of type modifiers
            if (TypeName[0]) {
                strcat(TypeName, " ");
            }
            strcat(TypeName, Name);

            //
            // Don't worry about explicitly disallowing things like
            // 'unsigned double' or 'short char'.  They won't be
            // in the pTypesList, so the parse will fail.
            //

            ConsumeToken();

        } else if (TypeName[0]) {
            //
            // The identifier is not an intrinsic type, and type modifiers
            // were seen.  The identifier is a variable name, not part of the
            // type name.  The type name is implicitly 'int'.
            //
            strcat(TypeName, " ");
            strcat(TypeName, szINT);

        } else {
            //
            // The identifier is not an intrinsic type, and no type
            // modifiers have been seen.  It is probably a typedef name.
            //
            strcpy(TypeName, Name);
            ConsumeToken();
        }
    }

    //
    // Look up the type name with all of its glorious modifiers
    //
    pkt = GetNameFromTypesList(pTypesList, TypeName);
    if (!pkt) {
        //
        // Type not found
        //
        return FALSE;
    }

PKTExit:
    if (pTypesInfo) {
        BUFALLOCINFO bufallocinfo;
        char *ps;
        PFUNCINFO pfuncinfoSrc = pkt->pfuncinfo;
        PMEMBERINFO pmeminfoSrc = pkt->pmeminfo;

        BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);

        pTypesInfo->Flags = pkt->Flags;
        pTypesInfo->IndLevel = pkt->IndLevel;
        pTypesInfo->Size = pkt->Size;
        pTypesInfo->iPackSize = pkt->iPackSize;
        strcpy(pTypesInfo->BasicType,pkt->BasicType);
        if (pkt->BaseName) {
            strcpy(pTypesInfo->BaseName,pkt->BaseName);
        }
        strcpy(pTypesInfo->TypeName,pkt->TypeName);
        if (pfuncinfoSrc) {
            PFUNCINFO pfuncinfoDest = NULL;

            pTypesInfo->pfuncinfo = BufPointer(&bufallocinfo);
            pTypesInfo->TypeKind = TypeKindFunc;

            while (pfuncinfoSrc) {
                pfuncinfoDest = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfoDest);
                if (!pfuncinfoDest) {
                    ExitErrMsg(FALSE, "ParseTypes - out of memory at line %d\n", __LINE__);
                }
                pfuncinfoDest->fIsPtr64 = pfuncinfoSrc->fIsPtr64;
                pfuncinfoDest->tkPreMod = pfuncinfoSrc->tkPreMod;
                pfuncinfoDest->tkSUE    = pfuncinfoSrc->tkSUE;
                pfuncinfoDest->tkPrePostMod = pfuncinfoSrc->tkPrePostMod;
                pfuncinfoDest->IndLevel = pfuncinfoSrc->IndLevel;
                pfuncinfoDest->tkPostMod = pfuncinfoSrc->tkPostMod;

                ps = BufPointer(&bufallocinfo);
                pfuncinfoDest->sType = ps;
                strcpy(ps, pfuncinfoSrc->sType);
                BufAllocate(&bufallocinfo, strlen(ps)+1);

                if (pfuncinfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pfuncinfoDest->sName = ps;
                    strcpy(ps, pfuncinfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pfuncinfoSrc = pfuncinfoSrc->pfuncinfoNext;
            }
        } else if (pmeminfoSrc) {
            PMEMBERINFO pmeminfoDest = NULL;

            pTypesInfo->TypeKind = TypeKindStruct;

            while (pmeminfoSrc) {
                pmeminfoDest = AllocMemInfoAndLink(&bufallocinfo, pmeminfoDest);
                pmeminfoDest->dwOffset = pmeminfoSrc->dwOffset;

                if (pmeminfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sName = ps;
                    strcpy(ps, pmeminfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                if (pmeminfoSrc->sType) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sType = ps;
                    strcpy(ps, pmeminfoSrc->sType);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pmeminfoSrc = pmeminfoSrc->pmeminfoNext;
            }
        }
        pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
    }

    if (ppKnownTypes) {
        *ppKnownTypes = pkt;
    }

    return TRUE;
}



void
__cdecl ErrMsg(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    fputs(ErrMsgPrefix, stderr);
    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);
}


void
__cdecl ExitErrMsg(
    BOOL bSysError,
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    bSysErr -- TRUE if the value of errno should be printed with the error
    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr, open files closed and
    deleted, process terminated.

--*/
{
    va_list pArg;
    if (bSysError) {
        fprintf(stderr, "%s System ERROR %s", ErrMsgPrefix, strerror(errno));
    } else {
        fprintf(stderr, "%s ERROR ", ErrMsgPrefix);
    }

    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);

    CloseOpenFileList(TRUE);

    //
    // Flush stdout and stderr buffers, so that the last few printfs
    // get sent back to BUILD before ExitProcess() destroys them.
    //
    fflush(stdout);
    fflush(stderr);

    ExitProcess(1);
}




void
__cdecl DbgPrintf(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays a message to stdout if bDebug is set.

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    if (!bDebug) {
        return;
    }

    va_start(pArg, pch);
    vfprintf(stdout, pch, pArg);
}




char *
ReadEntireFile(
    HANDLE hFile,
    DWORD *pBytesRead
    )
/*++

Routine Description:

    Allocates memory on the local heap and reads an entire file into it.

Arguments:

    hFile       -- file to read in
    bBytesRead  -- [OUT] number of bytes read from the file

Return Value:

    pointer to the memory allocated for the file, or NULL on error.

--*/
{
    DWORD  Bytes;
    char *pch = NULL;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff ||
        (Bytes = GetFileSize(hFile, NULL)) == 0xffffffff) {
        goto ErrorExit;
    }

    pch = GenHeapAlloc(Bytes);
    if (!pch) {
        return NULL;
    }

    if (!ReadFile(hFile, pch, Bytes, pBytesRead, NULL) ||
        *pBytesRead != Bytes) {
        DbgPrintf("BytesRead %d Bytes %d\n", *pBytesRead, Bytes);
        GenHeapFree(pch);
        pch = NULL;
    }

ErrorExit:
    if (!pch) {
        DbgPrintf("GetLastError %d\n", GetLastError());
    }

   return pch;
}


HANDLE
CreateTempFile(
    void
    )
/*++

Routine Description:

    Creates and opens a temporary file.  It will be deleted when it is
    closed.

Arguments:

    None.

Return Value:

    File handle, or INVALID_HANDLE_VALUE on error.

--*/
{
    DWORD dw;
    char PathName[MAX_PATH+1];
    char FileName[2*MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    dw = GetTempPath(MAX_PATH, PathName);
    if (!dw || dw > MAX_PATH) {
        strcpy(PathName, ".");
    }

    dw = GetTempFileName(PathName, "thk", 0, FileName);
    if (!dw) {
        strcpy(PathName, ".");
        dw = GetTempFileName(PathName, "thk", 0, FileName);
        if (!dw) {
            DbgPrintf("GetTempFileName %s GLE=%d\n", FileName, GetLastError());
        }
    }

    hFile = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_TEMPORARY |
                      FILE_FLAG_DELETE_ON_CLOSE |
                      FILE_FLAG_SEQUENTIAL_SCAN,
                      0
                      );

    if (hFile == INVALID_HANDLE_VALUE) {
        DbgPrintf("Create %s GLE=%d\n", FileName, GetLastError());
    }

    return hFile;
}



size_t
CopyToken(
    char *pDst,
    char *pSrc,
    size_t Size
    )
/*++

Routine Description:

    Copies a token (a separator-delimited string) from pSrc to pDst.

Arguments:

    pDst    -- destination to write the token to
    pSrc    -- source to copy token from
    Size    -- number of bytes available at pDst.

Return Value:

    Number of bytes copied from pSrc to pDst.

--*/
{
    size_t i = 0;

    while (!IsSeparator(*pSrc) && i < Size) {
        i++;
        *pDst++ = *pSrc++;
    }

    *pDst = '\0';

    return i;
}



char *
SkipKeyWord(
    char *pSrc,
    char *pKeyWord
    )
/*++

Routine Description:

    If the first word at pSrc matches the specified keyword, then skip
    over that keyword.

Arguments:

    pSrc        -- source string to examine
    pKeyWord    -- keyword to try and match

Return Value:

    pSrc unchanged if keyword not matched.  If keyword matched, returns
    ptr to text following the keyword after pSrc.

--*/
{
    int  LenKeyWord;
    char *pch;

    LenKeyWord = strlen(pKeyWord);
    pch = pSrc + LenKeyWord;

    if (!strncmp(pSrc, pKeyWord, LenKeyWord) && IsSeparator(*pch)) {
        pSrc = GetNextToken(pch - 1);
    }

    return pSrc;
}


BOOL
IsSeparator(
    char ch
    )
/*++

Routine Description:

    Determines if a character is a separator or not.
    over that keyword.

Arguments:

    ch      -- character to examine.

Return Value:

    TRUE if the character is a separator, FALSE if not.

--*/
{
   switch (ch) {
      case ' ':
      case '|':
      case '(':
      case ')':
      case '*':
      case ',':
      case '{':
      case '}':
      case ';':
      case '[':
      case ']':
      case '=':
      case '\n':
      case '\r':
      case ':':
      case '.':
      case '\0':
          return TRUE;
      }

    return FALSE;
}



/*
 *  GetNextToken
 */
char *
GetNextToken(
    char *pSrc
    )
/*++

Routine Description:

    Scans the input string and returns the next separator-delimited string.

Arguments:

    pSrc    -- input string

Return Value:

    Ptr to start of the next separator char which isn't a space.

--*/
{
    if (!*pSrc) {
        return pSrc;
    }

    if (!IsSeparator(*pSrc++)) {
        while (*pSrc && !IsSeparator(*pSrc)) {
            pSrc++;
        }
    }

    while (*pSrc && *pSrc == ' ') {
        pSrc++;
    }

    return pSrc;
}


void
DeleteAllocCvmHeap(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Cleans up the mapped shared memory.

Arguments:

    hCvmHeap    -- memory to clean up.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                        (PVOID *)&pcvmheap->uBaseAddress,
                        &pcvmheap->uRegionSize,
                        MEM_RELEASE);

    if (!NT_SUCCESS(Status)) {
        DbgPrintf("Error freeing CVM %x", Status);
    }
}


HANDLE
CreateAllocCvmHeap(
    ULONG_PTR uBaseAddress,
    ULONG_PTR uReserveSize,
    ULONG_PTR uRegionSize,
    ULONG_PTR uUncomitted,
    ULONG_PTR uUnReserved,
    ULONG_PTR uAvailable
    )
/*++

Routine Description:

    Allocates a region of memory and makes it into a heap.

Arguments:

    uBaseAddress    -- base address to allocate the heap at
    uReserveSize    -- number of bytes to reserve
    uRegionSize     -- size of the region
    uUncomitted     -- amount of uncommitted memory
    uUnReserved     -- amount of unreserved memory
    uAvailable      -- amount of available memory

Return Value:

    Handle to the heap, or NULL on error.

--*/
{
    CVMHEAPINFO *pcvmheap;
    NTSTATUS Status;

    pcvmheap = GenHeapAlloc(sizeof(CVMHEAPINFO));
    if (pcvmheap == NULL) {
        return NULL;
    }

    pcvmheap->uBaseAddress = uBaseAddress;
    pcvmheap->uReserveSize = uReserveSize;
    pcvmheap->uRegionSize = uRegionSize;
    pcvmheap->uUncomitted = uUncomitted;
    pcvmheap->uUnReserved = uUnReserved;
    pcvmheap->uAvailable = uAvailable;

    //
    // Reserve enuf contiguous address space, for expected needs
    //
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uBaseAddress,
                                         0,
                                         &pcvmheap->uReserveSize,
                                         MEM_RESERVE,
                                         PAGE_NOACCESS
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to reserve vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUnReserved = pcvmheap->uBaseAddress + pcvmheap->uReserveSize;


    //
    // Commit the first page, we will grow this a page at a time
    // as its needed.
    //
    pcvmheap->uAvailable = pcvmheap->uBaseAddress;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uAvailable,
                                         0,
                                         &pcvmheap->uRegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to commit vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUncomitted = pcvmheap->uBaseAddress + pcvmheap->uRegionSize;


            // paranoia!
    if (pcvmheap->uAvailable != pcvmheap->uBaseAddress) {
        ErrMsg(
               "commit pvAvailable(%x) != gBaseAddress(%x)\n",
               pcvmheap->uAvailable,
               pcvmheap->uBaseAddress
              );
        return NULL;
    }

    DbgPrintf("Ppm: BaseAddress %x\n", pcvmheap->uBaseAddress);

    return pcvmheap;
}


PVOID
GetCvmHeapBaseAddress(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the base address of a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Base address, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uBaseAddress;
}


PVOID
GetCvmHeapAvailable(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the number of bytes available in a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Bytes available, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uAvailable;
}


PVOID
AllocCvm(
    HANDLE hCvmHeap,
    ULONG_PTR Size
    )
/*++

Routine Description:

    Allocate memory from a heap.

Arguments:

    hCvmHeam        -- heap to allocate from
    Size            -- number of bytes to allocate

Return Value:

    Ptr to allocated memory, or NULL of insufficient memory.

--*/
{
    CVMHEAPINFO *pcvmheapinfo = (CVMHEAPINFO *)hCvmHeap;
    NTSTATUS Status;
    ULONG_PTR Available;
    ULONG_PTR AlignedSize;

    if (pcvmheapinfo == NULL) {
        return NULL;
    }

    //
    // Round the allocation up to the next-highest multiple of 8, so that
    // allocations are correctly aligned.
    //
    AlignedSize = (Size + 7) & ~7;

    Available = pcvmheapinfo->uAvailable;
    pcvmheapinfo->uAvailable += AlignedSize;

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUnReserved) {
        ErrMsg("AllocCvm: Allocation Size exceeds reserved size\n");
        return NULL;
    }

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUncomitted) {
        //
        // Commit enuf pages to exceed the requested allocation size
        //
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheapinfo->uUncomitted,
                                         0,
                                         &Size,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

        if (!NT_SUCCESS(Status)) {
            ErrMsg(
                   "Unable to commit vm %x %x %x\n",
                   pcvmheapinfo->uBaseAddress,
                   Size,
                   Status
                   );
            return NULL;
        }

        pcvmheapinfo->uUncomitted += Size;
    }

    return (PVOID)Available;
}



void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE ptkPrePostMod,
    PTOKENTYPE ptkPostMod
    )
/*++

Routine Description:

    Parse any indirection level specificiations ('*') taking into
    account const, volatile, and __ptr64 modifiers.  For example:
    void * const __ptr64 ** const * __ptr64 would be valid.

    NOTE: the pointer is a 64-bit pointer only if the last pointer
          declared is modified by __ptr64.

Arguments:

    pIndlevel       -- [OUT] indirection level (number of '*'s)
    pdwSize         -- [OUT] size of the type (4 or 8)
    pFlags          -- [OUT] BTI_ flags
    ptkPrePostMod   -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen before the first '*'
    ptkPostMod      -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen after the first '*'

Return Value:

    None.  May not consume any tokens if there are no levels of indirection.

--*/
{
    int IndLevel = 0;
    DWORD dwSize = 0;
    DWORD Flags = 0;
    BOOL fStopScanning = FALSE;
    TOKENTYPE tkPrePostMod = TK_NONE;
    TOKENTYPE tkPostMod = TK_NONE;

    do {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ////////////////////////////////////////////////////////////////////
            //The ref operator in C++ is equilivalent to * const in C
            //This implies that & should be treated as a * but add a postmod of const.
            /////////////////////////////////////////////////////////////////////
            tkPostMod = TK_CONST;
        case TK_STAR:
            IndLevel++;
            dwSize = SIZEOFPOINTER;
            Flags &= ~BTI_PTR64;
            ConsumeToken();
            break;

        case TK_CONST:
        case TK_VOLATILE:
            //
            // The caller may be interrested in whether the 'const' or
            // 'volatile' keywords are before or after the '*'
            //
            if (IndLevel) {
                tkPostMod = CurrentToken()->TokenType;
            } else {
                tkPrePostMod = CurrentToken()->TokenType;
            }
            ConsumeToken();
            break;

        case TK_IDENTIFIER:
            if (strcmp(CurrentToken()->Name, sz__PTR64) == 0) {
                dwSize = SIZEOFPOINTER64;
                Flags |= BTI_PTR64;
                ConsumeToken();
                break;
            }

        default:
            fStopScanning = TRUE;
            break;
        }
    } while (!fStopScanning);

    if (pIndLevel != NULL) {
        *pIndLevel += IndLevel;
    }
    if ((pdwSize != NULL) && (dwSize != 0)) {
        *pdwSize = dwSize;
    }
    if (pFlags != NULL) {
        *pFlags |= Flags;
    }
    if (ptkPostMod) {
        *ptkPostMod = tkPostMod;
    }
    if (ptkPrePostMod) {
        *ptkPrePostMod = tkPrePostMod;
    }
}



BOOL
IsTokenSeparator(
    void
    )
/*++

Routine Description:

    Determines if a token is a separator character or not.

Arguments:

    None.  Examines CurrentToken()->TokenType.

Return Value:

    TRUE if CurrentToken() is a separator, FALSE if not.

--*/
{
    switch (CurrentToken()->TokenType) {
    case TK_LPAREN:
    case TK_RPAREN:
    case TK_STAR:
    case TK_BITWISE_AND:
    case TK_COMMA:
    case TK_LBRACE:
    case TK_RBRACE:
    case TK_SEMI:
    case TK_LSQUARE:
    case TK_RSQUARE:
    case TK_COLON:
        return TRUE;

    default:
        return FALSE;
    }
}

VOID
ReleaseToken(
    PTOKEN Token
)
{

/*++

Routine Description:

        Releases any additional memory associated with a token.

Arguments:

        dest        - [IN] ptr to the token.

Return Value:

--*/

    if (Token->TokenType == TK_IDENTIFIER ||
        Token->TokenType == TK_STRING) {
        GenHeapFree(Token->Name);
    }
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ResetLexer(
    void
    )
/*++

Routine Description:

    Resets the lexer in preparation to analyze a new statement.

Arguments:

    None.

Return Value:

    None.  Lexer's state reset.

--*/
{
    int TokenCount;

    for (TokenCount = 0;
         TokenCount < MAX_TOKENS_IN_STATEMENT &&
         Tokens[TokenCount].TokenType != TK_EOS;
         ++TokenCount) {

         ReleaseToken(&Tokens[TokenCount]);
    }

    CurrentTokenIndex = 0;
}

__inline
VOID
InitializeToken(
    PTOKEN Token
    )
/*++

Routine Description:

    Initialize a token so the lexer can fill it in.

Arguments:

    Token       -- TOKEN to initialize

Return Value:

    None.

--*/
{
    // The number parser expects Value to be 0.
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ProcessEscapes(
    char *String
    )
/*++

Routine Description:

    Process escape characters, replacing them by the proper char.

Arguments:

    String  -- null-terminated string to process

Return Value:

    None.  Conversion is done in-place.

--*/
{
    char *pDest;
    char *pSrc;
    char c;
    int i;

    pSrc = pDest = String;
    while (*pSrc) {
        if (*pSrc != '\\') {
            *pDest = *pSrc;
            pSrc++;
            pDest++;
        } else {
            pSrc++;
            switch (*pSrc) {
            case 'n':
                c = '\n';
                break;

            case 't':
                c = '\t';
                break;

            case 'v':
                c = '\v';
                break;

            case 'b':
                c = '\b';
                break;

            case 'r':
                c = '\r';
                break;

            case 'f':
                c = '\f';
                break;

            case 'a':
                c = '\a';
                break;

            case '\\':
                c = '\\';
                break;

            case '?':
                c = '\?';
                break;

            case '\'':
                c = '\'';
                break;

            case '\"':
                c = '\"';
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                // Octal number
                c = 0;
                for (i=0; i<3;++i) {
                    c = (c * 8) + (*pSrc) - '0';
                    pSrc++;
                    if (*pSrc < '0' || *pSrc > '7') {
                        // hit end of number
                        break;
                    }
                }
                break;

            case 'x':
            case 'X':
                // Hex number
                pSrc++;
                c = 0;
                for (i=0; i<3;++i) {
                    char digit;

                    digit = *pSrc;
                    if (digit >= '0' && digit <= '9') {
                        digit -= '0';
                    } else if (digit >= 'a' && digit <= 'f') {
                        digit = digit - 'a' + 10;
                    } else if (digit >= 'A' && digit <= 'A') {
                        digit = digit - 'A' + 10;
                    } else {
                        // hit end of number
                        break;
                    }
                    c = (c * 16) + digit;
                    pSrc++;
                }
                break;

            default:
                // Parse error in the string literal.
                goto Exit;

            }
            *pDest = c;
            pDest++;
        }
    }
Exit:
    // Write the new null-terminator in
    *pDest = '\0';
}



char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    )
/*++

Routine Description:

    Performs lexical analysis on a single line of input.  The lexer
    may stop before consuming an entire line of input, so the caller
    must closely examine the return code before grabbing the next line.

    __inline functions are deleted by the lexer.  The lexer consumes input
    until it encounters a '{' (assumed to be the start of the function
    body), then consumes input until the matching '}' is found (assumed to
    be the end of the function body).

    "template" is deleted by the lexer and treated as if it was
    an "__inline" keyword... it consumes everything upto '{' then
    keeps consuming until a matching '}' is found.  That makes unknwn.h
    work.

    Lexer unwraps extern "C" {} blocks.

    'static' and '__unaligned' keywords are deleted by the lexer.

    Preprocessor directives are handled via a callout to
    HandlePreprocessorDirective().

Arguments:

    p                   -- ptr into the line of input
    fStopAtStatement    -- TRUE if caller wants lexer to stop at ';' at
                           file-scope.  FALSE if caller wants lexer to stop
                           at ')' at file-scope.
    pfLexDone           -- [OUT] lexer sets this to TRUE if the analysis
                           is complete.  Lexer sets this to FALSE if
                           it needs another line of input from the caller.

Return Value:

    ptr into the line of input where lexing left off, or NULL if entire
    line was consumed.

    CurrentTokenIndex is the index of the next element of the Tokens[]
    array that the lexer will fill in.

    Tokens[] is the array of tokens the lexer has generated.

--*/
{
    static int NestingLevel=0;      // level of nesting of braces and parens
    static BOOL fInlineSeen=FALSE;  // TRUE while deleting __inline functions
    static int ExternCLevel=0;      // tracks the number of extern "C" blocks
    static int InlineLevel=0;       // NestingLevel for the outermost __inline
    int Digit;                      // a digit in a numeric constant
    int NumberBase = 10;            // assume numbers are base-10
    PTOKEN Token;                   // ptr to current token being lexed

    //
    // Assume the lexical analysis is not done
    //
    *pfLexDone = FALSE;

    //
    // Pick up analysis where we left off...
    //
    Token = &Tokens[CurrentTokenIndex];
    InitializeToken(Token);

    //
    // Loop over all characters in the line, or until a complete lexical
    // unit is done (depends on fStopAtStatement).
    //
    while (*p) {
        switch (*p) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
        case '\v':
        case '\f':
        case '\b':
        case '\a':
        case '\\':  // line-continuation characters are ignored
            p++;
            continue;

        case '#':
            //
            // HandlePreprocessorDirective() is implemented in the
            // app which links to genmisc.c.
            //
            HandlePreprocessorDirective(p);
            CurrentTokenIndex = (int)(Token - Tokens);
            return NULL;

        case '+':
            Token->TokenType = TK_PLUS;
            break;

        case '-':
            Token->TokenType = TK_MINUS;
            break;

        case ':':
            Token->TokenType = TK_COLON;
            break;

        case '=':
            Token->TokenType = TK_ASSIGN;
            break;

        case ';':
            if (NestingLevel == 0 && fStopAtStatement) {
                //
                // Found a ';' at file-scope.  This token marks the
                // end of the C-language statement.
                //
                p++;
                if (*p == '\n') {
                    //
                    // ';' is at EOL - consume it now.
                    //
                    p++;
                }
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            }
            Token->TokenType = TK_SEMI;
            break;

        case '*':
            Token->TokenType = TK_STAR;
            break;

        case '/':
            Token->TokenType = TK_DIVIDE;
            break;

        case ',':
            Token->TokenType = TK_COMMA;
            break;

        case '<':
            if (p[1] == '<') {
                Token->TokenType = TK_LSHIFT;
                p++;
            } else {
                Token->TokenType = TK_LESS;
            }
            break;

        case '>':
            if (p[1] == '>') {
                Token->TokenType = TK_RSHIFT;
                p++;
            } else {
                Token->TokenType = TK_GREATER;
            }
            break;

        case '&':
            if (p[1] == '&') {
                Token->TokenType = TK_LOGICAL_AND;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_AND;
            }
            break;

        case '|':
            if (p[1] == '|') {
                Token->TokenType = TK_LOGICAL_OR;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_OR;
            }
            break;

        case '%':
            Token->TokenType = TK_MOD;
            break;

        case '^':
            Token->TokenType = TK_XOR;
            break;

        case '!':
            Token->TokenType = TK_NOT;
            break;

        case '~':
            Token->TokenType = TK_TILDE;
            break;

        case '[':
            Token->TokenType = TK_LSQUARE;
            break;

        case ']':
            Token->TokenType = TK_RSQUARE;
            break;

        case '(':
            NestingLevel++;
            Token->TokenType = TK_LPAREN;
            break;

        case ')':
            NestingLevel--;
            if (NestingLevel == 0 && !fStopAtStatement) {
                //
                // Found a ')' at file-scope, and we're lexing
                // the contents of an @-command in genthnk.
                // Time to stop lexing.
                //
                p++;
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            } else if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '(' and ')'\n");
            }
            Token->TokenType = TK_RPAREN;
            break;

        case '{':
            //check for a 'extern "C" {}' or 'extern "C++" {}'
            if (Token - Tokens >= 2 &&
                Token[-2].TokenType == TK_EXTERN &&
                Token[-1].TokenType == TK_STRING &&
                (strcmp(Token[- 1].Name, "C") == 0 || strcmp(Token[-1].Name, "C++") == 0)) {

                    if (NestingLevel == 0 && fInlineSeen) {
                        ExitErrMsg(FALSE, "Extern \"C\" blocks only supported at file scope\n");
                    }
                    ExternCLevel++;


                    //remove the last 2 tokens and skip this token
                    ReleaseToken(Token - 2);
                    ReleaseToken(Token - 1);
                    Token -= 2;
                    p++;
                    continue;
            }

            NestingLevel++;
            Token->TokenType = TK_LBRACE;
            break;

        case '.':
            if (p[1] == '.' && p[2] == '.') {
                Token->TokenType = TK_VARGS;
                p+=2;
            } else {
                Token->TokenType = TK_DOT;
            }
            break;

        case '}':
            if (NestingLevel == 0 && ExternCLevel > 0) {
                //omit this token since it is the end of an extern "C" block
                ExternCLevel--;
                p++;
                continue;
            }
            NestingLevel--;
            if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '{' and '}'\n");
            }
            else if (NestingLevel == InlineLevel && fInlineSeen) {
                //
                // Found the closing '}' for the end of an inline
                // function.  Advance past the '}' and start lexing
                // again as if the __inline was never there.
                //
                fInlineSeen = FALSE;
                p++;
                continue;
            }
            else {
                Token->TokenType = TK_RBRACE;
            }
            break;

        case '0':
            if (p[1] == 'x' || p[1] == 'X') {
                //
                // Found '0x' prefix - the token is a hex constant
                //
                Token->TokenType = TK_NUMBER;

                for (p+=2; *p != '\0'; p++) {
                    if (isdigit(*p)) {
                        int i;
                        i = *p - '0';
                        Token->Value = Token->Value * 16 + i;
                        Token->dwValue = Token->dwValue * 16 + i;
                    } else {
                        char c = (char)toupper(*p);
                        if (c >= 'A' && c <= 'F') {
                            int i;
                            i = c - 'A' + 10;
                            Token->Value = Token->Value * 16 + i;
                            Token->dwValue = Token->dwValue * 16 + i;
                        } else if (c == 'L') {
                            //
                            // Numeric constant ending in 'L' is a long-integer
                            // type.
                            //
                            break;
                        } else if (isalpha(c)) {
                            DumpLexerOutput(0);
                            ExitErrMsg(FALSE, "Parse Error in hex constant.\n");
                        } else {
                            p--;
                            break;
                        }

                    }
                }
                break;
            } else if (isdigit(p[1])) {
                //
                // Found '0' followed by a valid number - the token is
                // an octal constant.
                //
                NumberBase = 8;

            }
            // fall into general number processing code

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            Token->TokenType = TK_NUMBER;

            for (; *p != '\0'; p++) {
                Digit = *p - '0';
                if (*p == 'l' || *p == 'L') {
                    //
                    // Numeric constant ending in 'l' is a long-integer
                    //
                    break;
                } else if (Digit < 0 || Digit >= NumberBase) {
                    p--;
                    break;
                }
                Token->Value = Token->Value * NumberBase + Digit;
                Token->dwValue = Token->dwValue * NumberBase + Digit;
            }
            break;

        case '\'':
            Token->TokenType = TK_NUMBER;
            p++;  //skip past beginning '
            for(; *p != '\''; p++) {
                if (*p == '\0') {
                   ExitErrMsg(FALSE, "\' without ending \'\n");
                }
                Token->Value = Token->Value << 8 | (UCHAR)*p;
                Token->dwValue = Token->dwValue << 8 | (UCHAR)*p;
            }
            break;

        case '"':
            // A string literal. ie. char *p = "foo";
            {
                char *strStart;

                Token->TokenType = TK_STRING;
                strStart = ++p; //skip begining quote

                //get a count of the number of characters
                while (*p != '\0' && *p != '"') p++;

                if ('\0' == *p || '\0' == *(p+1)) {
                    ExitErrMsg(FALSE, "String without ending quote\n");
                }
                p++; //skip past the ending quote

                Token->Name = GenHeapAlloc(p - strStart); //1+strlen
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }

                memcpy(Token->Name, strStart, p-strStart-1);
                Token->Name[p-strStart-1] = '\0';
                p--;
                ProcessEscapes(Token->Name);
            }
            break;

        default:
            if (*p == '_' || isalpha(*p)) {
                //
                // An identifier or keyword
                //
                char *IdStart = p;

                Token->TokenType = TK_IDENTIFIER;

                while (*p == '_' || isalpha(*p) || isdigit(*p)) {
                    p++;
                }
                Token->Name = GenHeapAlloc(p - IdStart + 1);
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }
                memcpy(Token->Name, IdStart, p-IdStart);
                Token->Name[p-IdStart] = '\0';

                CheckForKeyword(Token);
                if (Token->TokenType == TK_TEMPLATE) {
                    fInlineSeen = TRUE;
                    InlineLevel = NestingLevel; // want to get back to the same scope
                } else if (Token->TokenType == TK_INLINE) {
                    if (NestingLevel) {
                        //
                        // __inline keyword embedded inside {}.  It's
                        // technically an error but we want to allow it
                        // during inclusion of ntcb.h.
                        //
                        continue;
                    }
                    fInlineSeen = TRUE;
                    InlineLevel = 0;    // want to get back to file scope
                } else if (Token->TokenType == TK_STATIC ||
                           Token->TokenType == TK_UNALIGNED ||
                           Token->TokenType == TK_RESTRICT ||
                           Token->TokenType == TK___W64) {
                    // filter out 'static', '__restrict', '__unaligned' and '__w64'
                    // keywords
                    continue;
                }
                p--;
            } else if (fInlineSeen) {
                //
                // While processing __inline functions, the lexer is
                // going to encounter all sorts of weird characters
                // in __asm blocks, etc.  Just ignore them and keep
                // consuming input.
                //
                p++;
                continue;
            } else {
                ExitErrMsg(FALSE, "Lexer: unexpected char '%c' (0x%x) found\n", *p, *p);
            }
        } // switch

        p++;
        if (!fInlineSeen) {
            Token++;
            if (Token == &Tokens[MAX_TOKENS_IN_STATEMENT]) {
                ExitErrMsg(FALSE, "Lexer internal error - too many tokens in this statement.");
            }
            InitializeToken(Token);
        }
    } // while (*p)

    //
    // Hit end-of-line.  Indicate this to the caller
    //
    Token->TokenType = TK_EOS;
    CurrentTokenIndex = (int)(Token - Tokens);
    return NULL;
}


void
CheckForKeyword(
    PTOKEN Token
    )
/*++

Routine Description:

    Converts a TK_INDENTIFIER token into a C-language keyword token, if
    the identifier is in the KeywordList[].

Arguments:

    Token       -- Token to convert

Return Value:

    None.       Token->TokenType and Token->Name may be changed.

--*/
{
    int i;
    int r;

    for (i=0; KeywordList[i].MatchString; ++i) {
        r = strcmp(Token->Name, KeywordList[i].MatchString);
        if (r == 0) {
            GenHeapFree(Token->Name);
            Token->Name = NULL;
            Token->TokenType = KeywordList[i].Tk;
            return;
        } else if (r < 0) {
            return;
        }
    }
}

void
DumpLexerOutput(
    int FirstToken
    )
/*++

Routine Description:

    Debug routine to dump out the Token list as human-readable text.

Arguments:

    FirstToken      -- Index of the first token to list back.

Return Value:

    None.

--*/
{
    int i;

    for (i=0; i<FirstToken; ++i) {
        if (Tokens[i].TokenType == TK_EOS) {
            fprintf(stderr, "DumpLexerOutput: FirstToken %d is after EOS at %d\n", FirstToken, i);
            return;
        }
    }

    fprintf(stderr, "Lexer: ");
    for (i=FirstToken; Tokens[i].TokenType != TK_EOS; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_NUMBER:
            fprintf(stderr, "0x%X ", Tokens[i].Value);
            break;

        case TK_IDENTIFIER:
        case TK_STRING:
            fprintf(stderr, "%s ", Tokens[i].Name);
            break;

        case TK_NONE:
            fprintf(stderr, "<TK_NONE> ");
            break;

        default:
            fprintf(stderr, "%s ", TokenString[(int)Tokens[i].TokenType]);
            break;
        }
    }
    fprintf(stderr, "<EOS>\n");
}


BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    )
/*++

Routine Description:

    Convert a sequence of Tokens back into human-readable text.

Arguments:

    dest        -- ptr to destination buffer
    destlen     -- length of destination buffer
    StartToken  -- index of first token to list back
    EndToken    -- index of last token (this token is *not* listed back)

Return Value:

    TRUE if Unlex successful.  FALSE if failure (ie. buffer overflow).

--*/
{
    int i;
    int len;
    char buffer[16];
    char *src;

    if (bDebug) {
        for (i=0; i<StartToken; ++i) {
            if (Tokens[i].TokenType == TK_EOS) {
                ErrMsg("UnlexToText: StartToken %d is after EOS %d\n", StartToken, i);
                return FALSE;
            }
        }
    }

    for (i=StartToken; i<EndToken; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_EOS:
            return FALSE;

        case TK_NUMBER:
            sprintf(buffer, "%d", Tokens[i].Value);
            src = buffer;
            break;

        case TK_IDENTIFIER:
                case TK_STRING:
            src = Tokens[i].Name;
            break;

        case TK_NONE:
            src = "<TK_NONE>";
            break;

        default:
            src = TokenString[(int)Tokens[i].TokenType];
            break;
        }

        len = strlen(src);
        if (len+1 > destlen) {
            return FALSE;
        }
        strcpy(dest, src);
        dest += len;
        *dest = ' ';
        dest++;
        destlen -= len+1;
    }
    dest--;         // back up over the trailing ' '
    *dest = '\0';   // null-terminate

    return TRUE;
}


PVOID
GenHeapAlloc(
    INT_PTR Len
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Len);
}

void
GenHeapFree(
    PVOID pv
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, pv);
}


TOKENTYPE
ConsumeDirectionOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_IN or TK_OUT, if present in the lexer stream.  TK_IN
    followed by TK_OUT is converted to TK_INOUT.

Arguments:

    None.

Return Value:

    TK_IN, TK_OUT, TK_INOUT, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_IN:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_OUT) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    case TK_OUT:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_IN) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


TOKENTYPE
ConsumeConstVolatileOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_CONST or TK_VOLATILE, if present in the lexer stream.

Arguments:

    None.

Return Value:

    TK_CONST, TK_VOLATILE, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_CONST:
    case TK_VOLATILE:
        ConsumeToken();
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    )
/*++

Routine Description:

    Allocates a new MEMBERINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of MEMBERINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in MEMBERINFO struct (or NULL)

--*/
{
    PMEMBERINFO pmeminfoNext;

    pmeminfoNext = BufAllocate(pbufallocinfo, sizeof(MEMBERINFO));
    if (pmeminfoNext) {
        if (pmeminfo) {
            pmeminfo->pmeminfoNext = pmeminfoNext;
        }
        memset(pmeminfoNext, 0, sizeof(MEMBERINFO));
    }
    return pmeminfoNext;
}

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *bufallocinfo,
    PFUNCINFO pfuncinfo
    )
/*++

Routine Description:

    Allocates a new FUNCINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of FUNCINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in FUNCINFO struct (or NULL)

--*/
{
    PFUNCINFO pfuncinfoNext;

    pfuncinfoNext = BufAllocate(bufallocinfo, sizeof(FUNCINFO));
    if ((pfuncinfoNext != NULL) && (pfuncinfo != NULL)) {
        pfuncinfo->pfuncinfoNext = pfuncinfoNext;
        pfuncinfoNext->sName = NULL;
        pfuncinfoNext->sType = NULL;
    }
    return pfuncinfoNext;
}

DWORD
SizeOfMultiSz(
    char *c
    )
{
/*++

Routine Description:

        Determines the number of bytes used by double '\0' terminated list.

Arguments:

        c           - [IN] ptr to the double '\0' termined list.

Return Value:

        Bytes used.
--*/
    DWORD dwSize = 1;
    char cPrevChar = '\0'+1;
    do {
        dwSize++;
        cPrevChar = *c;
    } while(*++c != '\0' || cPrevChar != '\0');
    return dwSize;
}

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Concatinates two double '\0' terminated lists.
        New list is stored at dest.

Arguments:

        dest        - [IN/OUT] ptr to the head double '\0' terminated list.
        element     - [IN] ptr to the head double '\0' terminated list.
        dwMaxSize   - [IN] max size of the new list in bytes.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    //Find end of MultiSz
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = SizeOfMultiSz(source);
    if (dwLengthDest + dwLengthSource > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    return TRUE;
}

BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Adds a string to the end of a double '\0' terminated list.

Arguments:

        dest      - [IN/OUT] ptr to the double '\0' terminated list.
        source    - [IN] ptr to the string to add.
        dwMaxSize - [IN] max number of bytes that can be used by the list.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = strlen(source) + 1;
    if (dwLengthDest + dwLengthSource + 1 > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    *(dest + dwLengthDest + dwLengthSource) = '\0';
    return TRUE;
}

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    )
{
/*++

Routine Description:

        Determines if a string exists in a double '\0' terminated list.

Arguments:

        ppHead  - [IN] ptr to the double '\0' terminated list.
        element - [IN] ptr to the element to find.
Return Value:

        TRUE     - element is in the list.
        FALSE    - element is not in the list.
--*/
    do {
        if (strcmp(multisz, element) == 0) return TRUE;
        //skip to end of string
        while(*multisz++ != '\0');
    } while(*multisz != '\0');
    return FALSE;
}

BOOL
ConvertGuidCharToInt(
    const char *pString,
    DWORD *n,
    unsigned short number
    )
{
/*++

Routine Description:

        Internal route to be called only from ConvertStringToGuid.
        Converts segements of the GUID to numbers.

Arguments:

        pString  - [IN] ptr to the string segment to process.
        n        - [OUT] ptr to number representation of string segment.
        number   - [IN] size of string segment in characters.

Return Value:

        TRUE  - Success.
--*/
    unsigned short base = 16; //guid numbers are in hex
    *n = 0;

    while(number-- > 0) {
        int t;

        if (*pString >= '0' && *pString <= '9') {
            t = *pString++ - '0';
        }
        else if (*pString >= 'A' && *pString <= 'F') {
            t = (*pString++ - 'A') + 10;
        }
        else if (*pString >= 'a' && *pString <= 'f') {
            t = (*pString++ - 'a') + 10;
        }
        else return FALSE;

        *n = (*n * base) + t;
    }

    return TRUE;
}

BOOL
ConvertStringToGuid(
    const char *pString,
    GUID *pGuid
    )
{

/*++

Routine Description:

        Converts a string in the form found in _declspec(uuid(GUID)) to a GUID.
        Braces around guid are acceptable and are striped before processing.

Arguments:

        pString - [IN] ptr to the string that represents the guid.
        pGuid   - [OUT] ptr to the new guid.

Return Value:

        TRUE    - Success.
--*/

    DWORD t;
    unsigned int c;
    unsigned int guidlength = 36;
    char tString[37]; //guidlength + 1

    t = strlen(pString);
    if (guidlength + 2 == t) {
        //string is surounded with braces
        //check for braces and chop
        if (pString[0] != '{' || pString[guidlength + 1] != '}') return FALSE;
        memcpy(tString, pString + 1, guidlength);
        tString[guidlength] = '\0';
        pString = tString;
    }

    else if (t != guidlength) return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 8)) return FALSE;
    pString += 8;
    pGuid->Data1 = t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data2 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data3 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    for(c = 0; c < 8; c++) {
        if (!ConvertGuidCharToInt(pString, &t, 2)) return FALSE;
        pString += 2;
        pGuid->Data4[c] = (unsigned char)t;
        if (c == 1)
            if (*pString++ != '-') return FALSE;
    }

    return TRUE;
}

BOOL
IsDefinedPointerDependent(
    char *pName
    )
{
/*++

Routine Description:

        Determines if a typename is inharenty pointer size dependent.
        The user is expected to check pointers and derived types.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        TRUE    - Type is pointer size dependent.
--*/
    if (NULL == pName) return FALSE;
    if (strcmp(pName, "INT_PTR") == 0) return TRUE;
    if (strcmp(pName, "UINT_PTR") == 0) return TRUE;
    if (strcmp(pName, "HALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "UHALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "LONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "ULONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "__int64") == 0) return TRUE;
    if (strcmp(pName, "_int64") == 0) return TRUE;
    return FALSE;
}

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    )
/*++

Routine Description:

        Determines if a typename is inharenty a pointer to a pointer
        dependent type. The user is expected to check pointers to pointers and derived types.
        All of these types have an indirection level of 1.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        Pointer to the name of the indirection of this type.
--*/
{
   if (*pName != 'P') return NULL;
   if (strcmp(pName, "PINT_PTR") == 0) return "INT_PTR";
   if (strcmp(pName, "PUINT_PTR") == 0) return "UINT_PTR";
   if (strcmp(pName, "PHALF_PTR") == 0) return "HALF_PTR";
   if (strcmp(pName, "PUHALF_PTR") == 0) return "UHALF_PTR";
   if (strcmp(pName, "PLONG_PTR") == 0) return "LONG_PTR";
   if (strcmp(pName, "PULONG_PTR") == 0) return "ULONG_PTR";
   return NULL;
}

static HANDLE hFile = INVALID_HANDLE_VALUE;
static HANDLE hMapFile = NULL;
static void  *pvMappedBase = NULL;

BOOL
ClosePpmFile(
   BOOL bExitFailure
   )
{
/*++

Routine Description:

        Closes the opened ppm file.

Arguments:

        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - FALSE
        Success      - TRUE

--*/

   if (NULL != pvMappedBase) {
      if(!UnmapViewOfFile(pvMappedBase)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to unmap ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      pvMappedBase = NULL;
   }
   if (NULL != hMapFile) {
      if(!CloseHandle(hMapFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hMapFile = NULL;
   }
   if (INVALID_HANDLE_VALUE != hFile) {
      if(!CloseHandle(hFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hFile = INVALID_HANDLE_VALUE;
   }
   return TRUE;
}

PCVMHEAPHEADER
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   )
{

/*++

Routine Description:

       Opens a Ppm file and maps it.

Arguments:

        pName        - [IN] Name of the file to map.
        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - NULL
        Success      - Pointer to the VCVMHEAPHEADER

--*/
   void  *pvBaseAddress;
   DWORD  dwBytesRead;
   BOOL   fSuccess;
   ULONG Version;
   DWORD dwErrorNo;

   hFile = CreateFile(sPpmfile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to open %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   if (Version != VM_TOOL_VERSION) {
       //SetLastError(ERROR_BAD_DATABASE_VERSION);
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Ppm file file has version %x, expect %x\n", Version, VM_TOOL_VERSION);
   }

#if _WIN64
   // Read and skip the padding between the version and the base
   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

#endif


   fSuccess = ReadFile(hFile,
                       &pvBaseAddress,
                       sizeof(pvBaseAddress),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(pvBaseAddress)) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to read base address of ppm file %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
   if (!hMapFile) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmfile: Unable to map %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   pvMappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_READ, 0, 0, 0, pvBaseAddress);
   if (! pvMappedBase || pvMappedBase != pvBaseAddress) {
       // If the file can't be mapped at the expected base, we must fail
       // since the memory is chock full o' pointers.
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to map view of %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   NIL = &((PCVMHEAPHEADER)pvMappedBase)->NIL;
   return (PCVMHEAPHEADER)pvMappedBase;

fail:

   dwErrorNo = GetLastError();
   ClosePpmFile(FALSE);
   SetLastError(dwErrorNo);
   return NULL;

}

char szHOSTPTR32[] = "/* 64 bit ptr */ _int64";
char szHOSTPTR64[] = "/* 32 bit ptr */ _int32";

char *GetHostPointerName(BOOL bIsPtr64) {
   if (bIsPtr64)
      return szHOSTPTR32;
   else
      return szHOSTPTR64;
}

char szHOSTUSIZE8[] = "unsigned _int8";
char szHOSTUSIZE16[] = "unsigned _int16";
char szHOSTUSIZE32[] = "unsigned _int32";
char szHOSTUSIZE64[] = "unsigned _int64";
char szHOSTSIZE8[] = "_int8";
char szHOSTSIZE16[] = "_int16";
char szHOSTSIZE32[] = "_int32";
char szHOSTSIZE64[] = "_int64";
char szHOSTSIZEGUID[] = "struct _GUID";

char *GetHostBasicTypeName(PKNOWNTYPES pkt) {

   DWORD dwSize;

   if (pkt->Flags & BTI_ISARRAY)
      dwSize = pkt->dwBaseSize;
   else
      dwSize = pkt->Size;

   if (pkt->Flags & BTI_UNSIGNED) {
      switch(pkt->Size) {
         case 1:
             return szHOSTUSIZE8;
         case 2:
             return szHOSTUSIZE16;
         case 4:
             return szHOSTUSIZE32;
         case 8:
             return szHOSTUSIZE64;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
             return 0;
      }
   }
   else {
      switch(pkt->Size) {
         case 0:
             return szVOID;
         case 1:
             return szHOSTSIZE8;
         case 2:
             return szHOSTSIZE16;
         case 4:
             return szHOSTSIZE32;
         case 8:
             return szHOSTSIZE64;
         case 16:
             return szHOSTSIZEGUID;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
             return 0;
      }
   }
}

char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer) {
   if (pkt->IndLevel > 0) {
      strcpy(pBuffer, GetHostPointerName(pkt->Flags & BTI_PTR64));
   }
   else if(!(BTI_NOTDERIVED & pkt->Flags)) {
      if (strcmp(pkt->BaseName, "enum") == 0) {
         strcpy(pBuffer, szHOSTSIZE32);
      }
      else if (strcmp(pkt->BaseName, "union") == 0 ||
               strcmp(pkt->BaseName, "struct") == 0) {
         strcpy(pBuffer, pkt->BaseName);
         strcat(pBuffer, " NT32");
         strcat(pBuffer, pkt->TypeName);
      }
      else {
         strcpy(pBuffer, "NT32");
         strcat(pBuffer, pkt->TypeName);
      }
   }
   else {
      strcpy(pBuffer, GetHostBasicTypeName(pkt));
   }
   return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\genlib\gen.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    gen.h

Abstract:

    Types shared between the Wx86 tools

Author:

    ??-???-?? Unknown

Revision History:

  July 2001 JayKrell
    integrated from base\wow64\tools to /private/winfuse_longhorn/base/tools

  January 2002 JayKrell
    integrated /private/winfuse_longhorn/base/tools to /lab01_n/base/win32/fusion/tools
    some -W4 cleanup

--*/
#pragma warning(disable:4057)   /* char vs. unsigned char mixup */
#pragma warning(disable:4100)   /* unreferenced formal parameter */
#pragma warning(disable:4115)   /* named type definition in parentheses */
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4201)   /* nameless struct/union */
#pragma warning(disable:4214)   /* bit field types other than int */
#pragma warning(disable:4267)   /* conversion from 'size_t' to 'int', possible loss of data */

// Increment this number whenever the format of winincs.ppm changes
#define VM_TOOL_VERSION_BASE     0x80000006

// Make the 64-bit PPM file format incompatible to prevent badness
#if _WIN64
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE | 0x01000000)
#else
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE)
#endif

// Make the compiler more struct.
#pragma warning(3:4033)   // function must return a value
//#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect

extern const char *ErrMsgPrefix;    // string to put in front of all error
                                    // messages so that BUILD can find them.
                                    // This is something like:
                                    // "NMAKE :  U8600: 'GENTHNK' "

struct _KnownTypesInfo;

typedef enum _TokenType {
    TK_NONE,            // 0
    TK_IDENTIFIER,      // 1
    TK_NUMBER,          // 2
    TK_PLUS,            // 3
    TK_MINUS,           // 4
    TK_STAR,            // 5
    TK_DIVIDE,          // 6
    TK_LSQUARE,         // 7
    TK_RSQUARE,         // 8
    TK_LBRACE,          // 9
    TK_RBRACE,          // a
    TK_LPAREN,          // b
    TK_RPAREN,          // c
    TK_VARGS,           // d
    TK_CONST,           // e
    TK_VOLATILE,        // f
    TK_REGISTER,        // 10
    TK_EXTERN,          // 11
    TK_CDECL,           // 12
    TK_STDCALL,         // 13
    TK_TYPEDEF,         // 14
    TK_STATIC,          // 15
    TK_COMMA,           // 16
    TK_SEMI,            // 17
    TK_STRUCT,          // 18
    TK_UNION,           // 19
    TK_ENUM,            // 1a
    TK_INLINE,          // 1b
    TK_COLON,           // 1c
    TK_ASSIGN,          // 1d
    TK_DOT,             // 1e
    TK_LSHIFT,          // 1f
    TK_RSHIFT,          // 20
    TK_LESS,            // 21
    TK_GREATER,         // 22
    TK_UNALIGNED,       // 23
    TK_DECLSPEC,        // 24
    TK_RESTRICT,        // 25
    TK_FASTCALL,        // 26
    TK_IN,              // 27
    TK_OUT,             // 28
    TK_INOUT,           // 29
    TK_BITWISE_AND,     // 30
    TK_BITWISE_OR,      // 31
    TK_LOGICAL_AND,     // 32
    TK_LOGICAL_OR,      // 33
    TK_MOD,             // 34
    TK_XOR,             // 35
    TK_NOT,             // 36
    TK_TILDE,           // 37
    TK_STRING,          // 38
    TK_SIZEOF,          // 39
    TK_TEMPLATE,        // 40
    TK___W64,           // 41
    TK_EOS              // end-of-statement
} TOKENTYPE, *PTOKENTYPE;

typedef struct _cvmheapinfo {
    ULONG_PTR uBaseAddress;
    ULONG_PTR uReserveSize;
    ULONG_PTR uRegionSize;
    ULONG_PTR uUncomitted;
    ULONG_PTR uUnReserved;
    ULONG_PTR uAvailable;
} CVMHEAPINFO;

typedef struct _memberinfo {
    struct _memberinfo *pmeminfoNext;   // ptr to next member
    DWORD dwOffset;                     // offset in structure of member
    char *sName;                        // member name
    char *sType;                        // type name
    struct _KnownTypesInfo *pkt;        // Info for this type
    int IndLevel;                       // levels of indirection
    struct _KnownTypesInfo *pktCache;   // used by MemberTypes() in genthnk
    BOOL bIsBitfield;                   // Determines if this is a bitfield
    int BitsRequired;                   // Number of bits required for bitfield
    BOOL bIsPtr64;                      // Pointer is a 64 bit pointer
    BOOL bIsArray;                      // This member is an array
    int ArrayElements;                  // Number of elements in the array
} MEMBERINFO, *PMEMBERINFO;

typedef struct _funcinfo {
    struct _funcinfo *pfuncinfoNext;
    BOOL fIsPtr64;                  // TRUE if this is a __ptr64
    TOKENTYPE tkDirection;          // TK_IN, TK_OUT, TK_INOUT or TK_NONE
    TOKENTYPE tkPreMod;             // TK_CONST, TK_VOLATILE, or TK_NONE
    TOKENTYPE tkSUE;                // TK_STRUCT/UNION/ENUM, or TK_NONE
    char *sType;                    // name of the type
    struct _KnownTypesInfo *pkt;    // Info for this type
    TOKENTYPE tkPrePostMod;         // TK_CONST, TK_VOLATILE, or TK_NONE
    int IndLevel;                   // indirection level
    TOKENTYPE tkPostMod;            // TK_CONST, TK_VOLATILE, or TK_NONE
    char *sName;                    // name of the argment
} FUNCINFO, *PFUNCINFO;

#if _WIN64
  // The sizes must be bigger since the MEMBERINFO structs themselves are bigger
  #define FUNCMEMBERSIZE   (40*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  8192     // storage for names of methods
#else
  #define FUNCMEMBERSIZE   (20*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  4096     // storage for names of methods
#endif

typedef enum _TypeKind {
    TypeKindEmpty = 0,              // Members[] is unused
    TypeKindStruct,                 // TYPESINFO.Members is array of MEMBERINFO
    TypeKindFunc                    // TYPESINFO.Members is array of FUNCINFO
} TYPEKIND;

#define DIR_INOUT   0
#define DIR_IN      1
#define DIR_OUT     2

#define SIZEOFPOINTER   4   // standard size for 32 bit pointer
#define SIZEOFPOINTER64 8   // standard size for 64 bit pointer


// The colors
typedef enum {RED, BLACK} COL;

typedef struct _KnownTypesInfo {
     // elements used by the Red-Black tree code, along with TypeName
     struct _KnownTypesInfo *RBParent;
     struct _KnownTypesInfo *RBLeft;
     struct _KnownTypesInfo *RBRight;
     COL    RBColor;
     struct _KnownTypesInfo *Next;

     ULONG Flags;
     int   IndLevel;
     int   RetIndLevel;
     int   Size;
     int   iPackSize;
     char  *BasicType;
     char  *BaseName;
     char  *FuncRet;
     char  *FuncMod;
     char  *TypeName;
     char  *Methods;
     char  *IMethods;
     char  *BaseType;
     GUID  gGuid;
     DWORD dwVTBLSize;
     DWORD dwVTBLOffset;
     int   TypeId;
     int   LineNumber;
     DWORD dwScopeLevel;
     struct _KnownTypesInfo *pktBase;   // a cache, used by genthnk
     struct _KnownTypesInfo *pktRet;    // a cache, used by genthnk
     int   SizeMembers; // size of Members[], in bytes
     char  *Members;
     char  *FileName;
     PMEMBERINFO pmeminfo;
     PFUNCINFO   pfuncinfo;
     DWORD dwArrayElements;
     DWORD dwBaseSize;
     struct _KnownTypesInfo *pTypedefBase;
     DWORD dwCurrentPacking;
     char  Names[1];
} KNOWNTYPES, *PKNOWNTYPES;

typedef struct _RBTree {
     PKNOWNTYPES pRoot;
     PKNOWNTYPES pLastNodeInserted;
} RBTREE, *PRBTREE;

typedef struct _DefaultBasicTypes {
     char *BasicType;
}DEFBASICTYPES, *PDEFBASICTYPES;

typedef struct _TypesInfo {
     ULONG Flags;
     int  IndLevel;                 // indirection level
     int  Size;                     // size of the type in bytes
     int  iPackSize;                // packing size
     char BasicType[MAX_PATH];
     char BaseName[MAX_PATH];
     char FuncRet[MAX_PATH];
     char FuncMod[MAX_PATH];
     char TypeName[MAX_PATH];       // typedef or struc name
     TYPEKIND TypeKind;             // how to interpret Members[] data
     PFUNCINFO pfuncinfo;           // if TypeKind==TypeKindFunc, ptr to first FUNCINFO
     int   RetIndLevel;             // if TypeKind==TypeKindFunc, indlevel of return type for function
     DWORD dwMemberSize;            // #bytes used in Members array
     char Members[FUNCMEMBERSIZE];  // stores either MEMBERINFOs or FUNCINFOs
//   Added to support automatic retrival of COM objects
//   If a class or struct is found with virtual methods, an extra VTLB member
//   is created at the top.
//   Note: a class has a VTLB if virtual methods are found or base class
//   has virtual methods
//   A type is a COM object if it is IUnknown or it derives from a COM object
     GUID gGuid;                        // Guid for this object if
     DWORD dwVTBLSize;                  // Total size of the VTBL
     DWORD dwVTBLOffset;                // Offset of VTLB from parent
     char Methods[MEMBERMETHODSSIZE];   // Names of methods
     char IMethods[MEMBERMETHODSSIZE];  // Names of methods not inherited
     char BaseType[MAX_PATH];           // Name of the base class
//////////////////////////////////////////////////////////////////////
//   Added to support reordering of definations later
//////////////////////////////////////////////////////////////////////
     int TypeId;    //is actually a defination ID
     char FileName[MAX_PATH];
     int LineNumber;
     DWORD dwCurrentPacking;            // Packing level when structure defined
     DWORD dwScopeLevel;
     DWORD dwArrayElements;             // If this is an array, the number of elements
     DWORD dwBaseSize;                  // Base size before it is multiplied for the array
     PKNOWNTYPES pTypedefBase;
} TYPESINFO, *PTYPESINFO;

#define BTI_DLLEXPORT       1       // the function decl had __declspec(dllimport)
#define BTI_CONTAINSFUNCPTR 2       // the type contains a function pointer
#define BTI_PTR64           4       // the type is a __ptr64
#define BTI_HASGUID         8       // A guid has been found for this type
#define BTI_ISCOM           16      // This is a COM object
#define BTI_DISCARDABLE     32      // Type is overwriteable
#define BTI_VIRTUALONLY     64      // Contains only virtual methods
#define BTI_ANONYMOUS       128     // Type is anonymous
#define BTI_POINTERDEP      256     // Type is dependent on the standard pointer size
#define BTI_NOTDERIVED      512     // Type is not derived, but a placeholder
#define BTI_ISARRAY        1024     // Element is an array
#define BTI_UNSIGNED     2048       // Used only on default derived types
                                    // Signals that the type is unsigned
#define BTI_INT64DEP     4096       // this is a 8byte integer value that
                                    // might be union as well

// contiguous allocation in a buffer
typedef struct _bufallocinfo {
    BYTE *pb;           // ptr to buffer pool
    DWORD dwSize;       // size of buffer pool
    DWORD dwLen;        // current length of buffer pool
} BUFALLOCINFO;

typedef struct _TokenMatch {
    TOKENTYPE Tk;
    char *MatchString;
} TOKENMATCH, *PTOKENMATCH;


extern char *TokenString[];
extern TOKENMATCH KeywordList[];

typedef struct _Token {
    TOKENTYPE TokenType;
    union _TokenName {
        char *Name;     // filled in only for TokenType==TK_IDENTIFIER or TK_STRING
        long Value;     // filled in only for TokenType==TK_NUMBER
    };
    DWORD dwValue; //unsigned version of Value
} TOKEN, *PTOKEN;

#define MAX_CHARS_IN_LINE           4096
#define MAX_TOKENS_IN_STATEMENT     4096
extern TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
extern int CurrentTokenIndex;

void
ResetLexer(
    void
    );

char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    );

BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    );

void
DumpLexerOutput(
    int FirstToken
    );

void
HandlePreprocessorDirective(
    char *Line
    );

TOKENTYPE
ConsumeDirectionOpt(
    void
    );

TOKENTYPE
ConsumeConstVolatileOpt(
    void
    );

PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    );

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PFUNCINFO pfuncinfo
    );

DWORD
SizeOfMultiSz(
    char *c
    );

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );


BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    );

BOOL
ConvertStringToGuid(
    const char *pString,
    GUID *pGuid
    );

//
// Inline code

#define iswhitespace(c) ((c == ' ') || (c == '\t'))

//
// initialize BUFALLOCINFO structure
_inline void BufAllocInit(BUFALLOCINFO *pbufallocinfo,
                  BYTE *pb, DWORD dwSize, DWORD dwLen)
{
    pbufallocinfo->pb = pb;
    pbufallocinfo->dwSize = dwSize;
    pbufallocinfo->dwLen = dwLen;
}

//
// allocate memory from buffer
_inline void *BufAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    void *pv = NULL;
    DWORD dwNewLen;

    // Pad to quadword alignment, like malloc does, so RISC builds don't
    // take alignment faults.
    dwLen = (dwLen+7) & ~7;

    dwNewLen = pbufallocinfo->dwLen + dwLen;

    if (dwNewLen < pbufallocinfo->dwSize)
    {
        pv = &pbufallocinfo->pb[pbufallocinfo->dwLen];
        pbufallocinfo->dwLen = dwNewLen;
    }

    return(pv);
}

//
// determine if we could allocate from buffer pool
_inline BOOL BufCanAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    return( (pbufallocinfo->dwLen + dwLen) < pbufallocinfo->dwSize);
}

//
// get pointer to current free area
_inline void *BufPointer(BUFALLOCINFO *pbufallocinfo)
{
    return(&pbufallocinfo->pb[pbufallocinfo->dwLen]);
}

//
// get remaining space in buffer
_inline DWORD BufGetFreeSpace(BUFALLOCINFO *pbufallocinfo)
{
    return pbufallocinfo->dwSize - pbufallocinfo->dwLen;
}

_inline char *SkipWhiteSpace(char *s)
{
    while (iswhitespace(*s) && (*s != 0)) {
        s++;
        }
    return(s);
}

__inline void
ConsumeToken(
    void
    )
{
    if (Tokens[CurrentTokenIndex].TokenType != TK_EOS) {
        CurrentTokenIndex++;
    }
}

__inline PTOKEN
CurrentToken(
    void
    )
{
    return &Tokens[CurrentTokenIndex];
}


//
// function prototypes
char *SkipKeyWord(char *pSrc, char *pKeyWord);
BOOL IsSeparator(char ch);
BOOL IsTokenSeparator(void);
size_t  CopyToken(char *pDst, char *pSrc, size_t Size);
char *GetNextToken(char *pSrc);

void DumpKnownTypes(PKNOWNTYPES pKnownTypes, FILE *fp);
void DumpTypesInfo(PTYPESINFO pTypesInfo, FILE *fp);
void FreeTypesList(PRBTREE HeadList);

void __cdecl ErrMsg(char *pch, ...);
void __cdecl ExitErrMsg(BOOL bSysError, char *pch, ...);
void __cdecl DbgPrintf(char *pch, ...);

char *ReadEntireFile(HANDLE hFile, DWORD *pBytesRead);
HANDLE CreateTempFile(VOID);

BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    );

PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    );

void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE tkPrePostMod,
    PTOKENTYPE tkPostMod
);

PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pHeadList,
     char *pTypeName
     );

PDEFBASICTYPES
GetDefBasicType(
     char *pBasicType
     );

PKNOWNTYPES
AddToTypesList(
     PRBTREE pHeadList,
     PTYPESINFO pTypesInfo
     );

BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    );

void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    );

void
CloseOpenFileList(
    BOOL DeleteFiles
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    );




//
// global vars
extern char szVARGS[];
extern char szNULL[];
extern char szCONST[];
extern char szVOLATILE[];
extern char szREGISTER[];
extern char szEXTERN[];
extern char szCDECL[];
extern char sz_CDECL[];
extern char szSTDCALL[];
extern char sz__FASTCALL[];
extern char szUNALIGNED[];
extern char szTYPEDEF[];
extern char szCHAR[];
extern char szINT[];
extern char szLONG[];
extern char szSHORT[];
extern char szDOUBLE[];
extern char szENUM[];
extern char szFLOAT[];
extern char szSTRUCT[];
extern char szUNION[];
extern char szVOID[];
extern char szINT64[];
extern char sz_INT64[];
extern char szFUNC[];
extern char szSIGNED[];
extern char szUNSIGNED[];
extern char szFUNCTIONS[];
extern char szSTRUCTURES[];
extern char szTYPEDEFS[];
extern char szPragma[];
extern char szPack[];
extern char szPush[];
extern char szPop[];
extern char szSTATIC[];
extern char szUNSIGNEDCHAR[];
extern char szUNSIGNEDSHORT[];
extern char szUNSIGNEDLONG[];
extern CHAR szINOUT[];
extern CHAR szIN[];
extern CHAR szOUT[];
extern CHAR szVTBL[];
extern char szGUID[];


extern BOOLEAN bDebug;
extern BOOLEAN bExitClean;

extern PVOID (*fpTypesListMalloc)(ULONG Len);

PKNOWNTYPES GetBasicType(
            char *sTypeName,
            PRBTREE TypeDefsList,
            PRBTREE StructsList);
void ReplaceInTypesList(PKNOWNTYPES pKnownTypes, PTYPESINFO pTypesInfo);

HANDLE CreateAllocCvmHeap(ULONG_PTR uBaseAddress,
                          ULONG_PTR uReserveSize,
                          ULONG_PTR uRegionSize,
                          ULONG_PTR uUncomitted,
                          ULONG_PTR uUnReserved,
                          ULONG_PTR uAvailable);

PVOID GetCvmHeapBaseAddress(HANDLE hCvmHeap);
PVOID
AllocCvm(HANDLE hCvmHeap,
    ULONG_PTR Size
    );
void DeleteAllocCvmHeap(HANDLE hCvmHeap);

// This structure is the first thing allocated within the CvmHeap.  It contains
// the roots of all data stored within the heap.
typedef struct _CvmHeapHeader {
    ULONG Version;
    ULONG_PTR BaseAddress;
    RBTREE FuncsList;
    RBTREE StructsList;
    RBTREE TypeDefsList;
    KNOWNTYPES NIL;
} CVMHEAPHEADER, *PCVMHEAPHEADER;

PVOID GetCvmHeapAvailable(HANDLE hCvmHeap);

// from redblack.c:
VOID
RBInsert(
    PRBTREE proot,
    PKNOWNTYPES x
    );

PKNOWNTYPES
RBFind(
    PRBTREE proot,
    PVOID addr
    );

PKNOWNTYPES
RBDelete(
    PRBTREE proot,
    PKNOWNTYPES z
    );

VOID
RBInitTree(
    PRBTREE proot
    );

extern PKNOWNTYPES NIL;

//
// Use these allocators instead of malloc/free
//
PVOID GenHeapAlloc(INT_PTR Len);
void GenHeapFree(PVOID pv);

BOOL
IsDefinedPointerDependent(
    char *pName
    );

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    );

BOOL
ClosePpmFile(
   BOOL bExitFailure
   );

PCVMHEAPHEADER
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   );

char *GetHostPointerName(BOOL bIsPtr64);
char *GetHostBasicTypeName(PKNOWNTYPES pkt);
char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\genlib\redblack.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    redblack.c

Abstract:

    This module implements red/black trees.

Author:

    16-Jun-1995 t-orig

Revision History:

  July 2001 JayKrell
    integrated from base\wow64\tools to base\tools

  January 2002 JayKrell
    integrated /private/winfuse_longhorn/base/tools to /lab01_n/base/win32/fusion/tools
    some -W4 cleanup

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

PKNOWNTYPES NIL;

#define RIGHT(x)        x->RBRight
#define LEFT(x)         x->RBLeft
#define PARENT(x)       x->RBParent
#define COLOR(x)        x->RBColor
#define KEY(x)          x->TypeName

VOID
RBInitTree(
    PRBTREE ptree
    )
{
    ptree->pRoot = NIL;
    ptree->pLastNodeInserted = NULL;
}


PKNOWNTYPES
RBLeftRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the left at node x.


         x                     y
        / \                   / \
       A   y       ==>>      x   C
          / \               / \
         B   C             A   B

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = RIGHT(x);
    RIGHT(x) = LEFT(y);
    if (LEFT(y) != NIL){
        PARENT(LEFT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL){
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    LEFT(y) = x;
    PARENT(x) = y;
    return root;
}



PKNOWNTYPES
RBRightRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the right at node x.


         x                     y
        / \                   / \
       y   C       ==>>      A   x
      / \                       / \
     A   B                     B   C

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = LEFT(x);
    LEFT(x) = RIGHT(y);
    if (RIGHT(y) != NIL) {
        PARENT(RIGHT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL) {
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    RIGHT(y) = x;
    PARENT(x) = y;
    return root;
}




PKNOWNTYPES
RBTreeInsert(
    PKNOWNTYPES root,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Inserts a new node into a tree without preserving the red/black properties.
    Should ONLY be called by RBInsert!  This is just a simple binary tree
    insertion routine.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as the
    old root).


--*/
{
    PKNOWNTYPES x,y;
    int i = 0;

    y = NIL;
    x = root;

    LEFT(z) = RIGHT(z) = NIL;

    // Find a place to insert z by doing a simple binary search
    while (x!=NIL) {
        y = x;
        i = strcmp(KEY(z), KEY(x));
        if (i < 0){
            x = LEFT(x);
        } else {
            x = RIGHT(x);
        }
    }

    // Insert z into the tree
    PARENT(z)= y;

    if (y==NIL) {
        root = z;
    } else if (i<0) {
        LEFT(y) = z;
    } else {
        RIGHT(y) = z;
    }

    return root;
}


VOID
RBInsert(
    PRBTREE     ptree,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Inserts a node into a red/black tree while preserving the red/black
    properties.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES root = ptree->pRoot;
    PKNOWNTYPES y;

    // Make a linked-list of nodes for easy deletion
    x->Next = ptree->pLastNodeInserted;
    ptree->pLastNodeInserted = x;

    // Insert x into the tree without preserving the red/black properties
    root = RBTreeInsert (root, x);
    COLOR(x) = RED;

    // We can stop fixing the tree when either:
    // 1) We got to the root
    // 2) x has a BLACK parent (the tree obeys the red/black properties,
    //    because no RED parent has a RED child.
    while ((x != root) && (COLOR(PARENT(x)) == RED)) {
        if (PARENT(x) == LEFT(PARENT(PARENT(x)))) {
            // Parent of x is a left child with sibling y.
            y = RIGHT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == RIGHT (PARENT (x))) {
                // Here y is BLACK and x is a right child.  A left rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBLeftRotate (root, x);
            } else {
                // Here y is BLACK and x is a left child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a right rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBRightRotate (root, PARENT(PARENT(x)));
            }
        } else {
            // Parent of x is a right child with sibling y.
            y = LEFT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == LEFT (PARENT (x))) {
                // Here y is BLACK and x is a left child.  A right rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBRightRotate (root, x);
            } else {
                // Here y is BLACK and x is a right child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a left rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBLeftRotate (root, PARENT(PARENT(x)));
            }
        }
    } // end of while loop

    COLOR(root) = BLACK;
    ptree->pRoot= root;
}


PKNOWNTYPES
RBFind(
    PRBTREE ptree,
    char *Name
    )
/*++

Routine Description:

    Finds a node in the red black tree given a name

Arguments:

    root - The root of the red/black tree
    name - The name corresponding to the node to be searched for.

Return Value:

    return-value - The node in the tree (entry point of code containing name), or
        NULL if not found.


--*/
{
    int i;
    PKNOWNTYPES root = ptree->pRoot;

    while (root != NIL) {
        i = strcmp(Name, KEY(root));
        if (i < 0) {
            root = LEFT(root);
        } else if (i > 0) {
            root = RIGHT(root);
        } else {
            return root;
        }
    }
    return NULL;  // Range not found
}


PKNOWNTYPES
RBTreeSuccessor(
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Returns the successor of a node in a binary tree (the successor of x
    is defined to be the node which just follows x in an inorder
    traversal of the tree).

Arguments:

    x - The node whose successor is to be returned

Return Value:

    return-value - The successor of x

--*/

{
    PKNOWNTYPES y;

    // If x has a right child, the successor is the leftmost node to the
    // right of x.
    if (RIGHT(x) != NIL) {
        x = RIGHT(x);
        while (LEFT(x) != NIL) {
            x = LEFT(x);
        }
        return x;
    }

    // Else the successor is an ancestor with a left child on the path to x
    y = PARENT(x);
    while ((y != NIL) && (x == RIGHT(y))) {
        x = y;
        y = PARENT(y);
    }
    return y;
}



PKNOWNTYPES
RBDeleteFixup(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Fixes the red/black tree after a delete operation.  Should only be
    called by RBDelete

Arguments:

    root - The root of the red/black tree
    x - Either a child of x, or or a child or x's successor

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES w;

    // We stop when we either reached the root, or reached a red node (which
    // means that property 4 is no longer violated).
    while ((x!=root) && (COLOR(x)==BLACK)) {
        if (x == LEFT(PARENT(x))) {
            // x is a left child with sibling w
            w = RIGHT(PARENT(x));
            if (COLOR(w) == RED) {
                // If w is red it must have black children.  We can switch
                // the colors of w and its parent and perform a left
                // rotation to bring w to the top.  This brings us to one
                // of the other cases.
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBLeftRotate (root, PARENT(x));
                w = RIGHT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                // Here w is black and has two black children.  We can thus
                // change w's color to red and continue.
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(RIGHT(w)) == BLACK) {
                    // Here w is black, its left child is red, and its right child
                    // is black.  We switch the colors of w and its left child,
                    // and perform a left rotation at w which brings us to the next
                    // case.
                    COLOR(LEFT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBRightRotate (root, w);
                    w = RIGHT(PARENT(x));
                }
                // Here w is black and has a red right child.  We change w's
                // color to that of its parent, and make its parent and right
                // child black.  Then a left rotation brings w to the top.
                // Making x the root ensures that the while loop terminates.
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(RIGHT(w)) = BLACK;
                root = RBLeftRotate (root, PARENT(x));
                x = root;
            }
        } else {
            // The symmetric case:  x is a right child with sibling w.
            w = LEFT(PARENT(x));
            if (COLOR(w) == RED) {
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBRightRotate (root, PARENT(x));
                w = LEFT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(LEFT(w)) == BLACK) {
                    COLOR(RIGHT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBLeftRotate (root, w);
                    w = LEFT(PARENT(x));
                }
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(LEFT(w)) = BLACK;
                root = RBRightRotate (root, PARENT(x));
                x = root;
            }
        }
    } // end of while loop

    //printf ("Changing color at %i to BLACK\n", x->intelColor);
    COLOR(x) = BLACK;
    return root;
}




PKNOWNTYPES
RBDelete(
    PRBTREE ptree,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Deletes a node in a red/black tree while preserving the red/black
    properties.

Arguments:

    root - The root of the red/black tree
    z - The node to be deleted

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES x,y;
    PKNOWNTYPES root = ptree->pRoot;
    COL c;


    // It's easy to delete a node with at most one child:  we only need to
    // remove it and put the child in its place.  It z has at most one child,
    // we can just remove it.  Otherwise we'll replace it with its successor
    // (which is guaranteed to have at most one child, or else one of its
    // children would be the succecssor), and delete the successor.
    if ((LEFT(z) == NIL) || (RIGHT(z) == NIL)) {
        y = z;
    } else {
        y = RBTreeSuccessor(z);
    }

    // Recall that y has at most one child.  If y has one child, x is set to
    // it.  Else x will be set to NIL which is OK.  This way we don't have
    // to worry about this special case.
    if (LEFT(y) != NIL){
        x = LEFT(y);
    } else {
        x = RIGHT(y);
    }

    // Now we will remove y from the tree
    PARENT(x) = PARENT(y);

    if (PARENT(y) == NIL) {
        root = x;
    } else if (y == LEFT(PARENT(y))) {
        LEFT(PARENT(y)) = x;
    } else {
        RIGHT(PARENT(y)) = x;
    }

    if (PARENT(x) == z) {
        PARENT(x) = y;
    }

    c = COLOR(y);

    // Since each node has lots of fields (fields may also change during
    // the lifetime of this code), I found it safer to copy the
    // pointers as opposed to data.
    if (y!=z) { // Now swapping y and z, but remembering color of y
        PARENT(y) = PARENT(z);

        if (root == z) {
            root = y;
        } else if (z == RIGHT(PARENT(z))) {
            RIGHT(PARENT(z)) = y;
        } else {
            LEFT(PARENT(z)) = y;
        }

        LEFT(y) = LEFT(z);
        if (LEFT(y) != NIL) {
            PARENT(LEFT(y)) = y;
        }

        RIGHT(y) = RIGHT(z);
        if (RIGHT(y) != NIL) {
            PARENT(RIGHT(y)) = y;
        }

        COLOR(y) = COLOR(z);
    }


    // Need to fix the tree (fourth red/black property).
    if (c == BLACK) {
        root = RBDeleteFixup (root, x);
    }
    return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\getasmdir\getdir.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:
    create the assembly directory name with input as a manifest file
    
Author:
    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/
#include "windows.h"
#include "stdio.h"
#include "sxsapi.h"

EXTERN_C BOOL FusionpInitializeHeap(HINSTANCE hInstance);
extern BOOL SxspInitActCtxContributors();
extern BOOL SxspGenerateManifestPathOnAssemblyIdentity(PCWSTR str, PWSTR pszOut, ULONG *pCchstr, PASSEMBLY_IDENTITY *ppAssemblyIdentity);


void PrintUsage(PCWSTR exename)
{
    fprintf(stderr, "Generate Directory name under winsxs for assembly.\n\n");
    fprintf(stderr, "%S [-ManifestToAsmDir manifest_filename] [-ManifestToAsmID manifest_filename] [-AsmIdToAsmDir Textual_Assembly_Identity_string]\n");

    return;
}

BOOL GetAsmDir_Initialize()
{
    if (!FusionpInitializeHeap(NULL)){
        fprintf(stderr,"fusion heap could not be initialized\n");
        return FALSE;
    }

    if (!SxspInitActCtxContributors())
    {
        fprintf(stderr,"Sxs ActCtxContributors could not be initialized\n");
        return FALSE;
    }

    return TRUE;
}

#define GET_ASSEMBLY_DIR_FROM_MANIFEST                      1
#define GET_ASSEMBLY_IDENTITY_FROM_MANIFEST                 2
#define Get_ASSEMBLY_DIR_FROM_TEXTUAL_ASSEMBLY_IDENTITY     3

extern "C" { void (__cdecl * _aexit_rtn)(int); }
extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{

    DWORD op = 0;

    //
    // check the parameters 
    //
    if (argc != 3)
    {
        PrintUsage(argv[0]);
        return 1;
    }

    if (_wcsicmp(argv[1], L"-ManifestToAsmDir") == 0)
    {
        op = GET_ASSEMBLY_DIR_FROM_MANIFEST;
    }
    else if (_wcsicmp(argv[1], L"-ManifestToAsmID") == 0)
    {
        op = GET_ASSEMBLY_IDENTITY_FROM_MANIFEST;
    }
    else if (_wcsicmp(argv[1], L"-AsmIDToAsmDir") == 0)
    {
        op = Get_ASSEMBLY_DIR_FROM_TEXTUAL_ASSEMBLY_IDENTITY;
    }else
    {
        PrintUsage(argv[0]);
        return 1;
    }

    if (GetAsmDir_Initialize() == FALSE)
        return 1;

    if ((op == GET_ASSEMBLY_DIR_FROM_MANIFEST) || (op == GET_ASSEMBLY_IDENTITY_FROM_MANIFEST))
    {
        struct {
            SXS_MANIFEST_INFORMATION_BASIC mib;
            WCHAR buf1[1024];        
        } buff;

        if ( GetFileAttributesW(argv[2]) == (DWORD) (-1))
        {
            fprintf(stderr, " the manifest %S could not be found with current PATH setting\n", argv[2]);
            return 1;
        }
        if (!SxsQueryManifestInformation(0, argv[2], SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, sizeof(buff), &buff, NULL)) 
        {
            fprintf(stderr, "SxsQueryManifestInformation failed.\n");
            return 1;                
        }
        else
        {   if (op == GET_ASSEMBLY_DIR_FROM_MANIFEST)
                fprintf(stdout, "%S", buff.mib.lpShortName);
            else if (op == GET_ASSEMBLY_IDENTITY_FROM_MANIFEST)
                fprintf(stdout, "%S", buff.mib.lpIdentity);

            return 0;
        }
    }else if (op == Get_ASSEMBLY_DIR_FROM_TEXTUAL_ASSEMBLY_IDENTITY)
    {
        WCHAR buf[1024];
        ULONG ulBufSize = 1024;

        if (! SxspGenerateManifestPathOnAssemblyIdentity(argv[2], buf, &ulBufSize, NULL))
        {
            fprintf(stderr, "SxspGenerateManifestPathOnAssemblyIdentity failed.\n");
            return 1;
        }
        else
        {
            fprintf(stdout, "%S", buf);
            return 0;
        }        
    }

    
    return 1; // failed case
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\fuslogvw\fuslogvw.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       fuslogvw.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    25 Mar 97   t-alans (Alan Shi)   Created
//              12 Jan 00   AlanShi (Alan Shi)   Copied from cdllogvw
//              30 May 00   AlanShi (Alan Shi)   Modified to show date/time
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <commctrl.h>
#include "cdlids.h"
#include "wininet.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define URL_SEARCH_PATTERN             "?FusionBindError!name="
#define DELIMITER_CHAR                 '!'
#define MAX_CACHE_ENTRY_INFO_SIZE      2048
#define MAX_DATE_LEN                   64

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

const char   *ppszMonths[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

LRESULT CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
void ViewLogEntry(HWND hwnd);
void RefreshLogView(HWND hwnd);
void DeleteLogEntry(HWND hwnd);
void DeleteAllLogs(HWND hwnd);
void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf, int cchBuffer);
void InitListView(HWND hwndLV);
void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo);

HINSTANCE hInst;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR szCmdLine, int iCmdShow)
{
    hInst = hInstance;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_CDLLOGVIEW), NULL, DlgProc);

    return 0;
}

LRESULT CALLBACK DlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND                                 hwndLV;
    LPNMHDR                              pnmh = NULL;

    switch (iMsg) {
        case WM_INITDIALOG:
            hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
            InitListView(hwndLV);

            RefreshLogView(hwnd);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
                case IDC_CB_VIEWLOG:
                    ViewLogEntry(hwnd);
                    break;

                case IDC_CB_REFRESH:
                    RefreshLogView(hwnd);
                    break;

                case IDC_CB_DELETE:
                    DeleteLogEntry(hwnd);
                    break;

                case IDC_CB_DELETE_ALL:
                    DeleteAllLogs(hwnd);
                    break;
            }

            return TRUE;

        case WM_NOTIFY:
            if (wParam == IDC_LV_LOGMESSAGES) {
                pnmh = (LPNMHDR)lParam;

                if (pnmh->code == LVN_ITEMACTIVATE) {
                    // Double click (or otherwise activated)
                    ViewLogEntry(hwnd);
                }
            }

            return TRUE;
    }

    return FALSE;
}

void DeleteLogEntry(HWND hwnd)
{
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    HWND                            hwndLV;
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szBuf[INTERNET_MAX_URL_LENGTH];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szBuf, INTERNET_MAX_URL_LENGTH);

    //
    // Length of URL plus lenght of returned string must still fit in the
    // URL buffer
    //
    if (((NUMBER_OF(URL_SEARCH_PATTERN) - 1) + lstrlen(szBuf)) >= NUMBER_OF(szUrl))
    {
        return;
    }
    
    strncpy(szUrl, URL_SEARCH_PATTERN, NUMBER_OF(szUrl));
    strncat(szUrl, szBuf, NUMBER_OF(szUrl) - NUMBER_OF(URL_SEARCH_PATTERN));

    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if (DeleteUrlCacheEntry(szUrl)) {
        RefreshLogView(hwnd);
    }
    else {
        MessageBox(hwnd, "Error: Unable to delete cache file!",
                   "Log View Error", MB_OK | MB_ICONERROR);
    }
}

void DeleteAllLogs(HWND hwnd)
{
    HWND                            hwndLV;
    LVITEM                          lvitem;
    char                            szBuf[INTERNET_MAX_URL_LENGTH];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    int                             iCount;
    int                             i;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    memset(&lvitem, 0, sizeof(LVITEM));
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_TEXT;
    lvitem.cchTextMax = NUMBER_OF(szBuf);
    lvitem.pszText = szBuf;

    iCount = ListView_GetItemCount(hwndLV);
    for (i = 0; i < iCount; i++) {
        szBuf[0] = TEXT('\0');
        lvitem.iItem = i;

        if (ListView_GetItem(hwndLV, &lvitem)) {

            if ((NUMBER_OF(URL_SEARCH_PATTERN) + lstrlen(szUrl)) < NUMBER_OF(szUrl)) {
                return;
            }
            
            strncpy(szUrl, URL_SEARCH_PATTERN, NUMBER_OF(szUrl));
            strncat(szUrl, lvitem.pszText, NUMBER_OF(szUrl) - NUMBER_OF(URL_SEARCH_PATTERN));

            DeleteUrlCacheEntry(szUrl);
        }
    }

    RefreshLogView(hwnd);
}

void ViewLogEntry(HWND hwnd)
{
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    HWND                            hwndLV;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szBuf[INTERNET_MAX_URL_LENGTH];
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szBuf, INTERNET_MAX_URL_LENGTH);

    if ((NUMBER_OF(URL_SEARCH_PATTERN) + lstrlen(szUrl)) > NUMBER_OF(szUrl)) {
        return;
    }

    strncpy(szUrl, URL_SEARCH_PATTERN, NUMBER_OF(szUrl));
    strncat(szUrl, szBuf, NUMBER_OF(szUrl) - NUMBER_OF(URL_SEARCH_PATTERN));

    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if (GetUrlCacheEntryInfo(szUrl, pCacheEntryInfo, &dwBufferSize)) {
        if (pCacheEntryInfo->lpszLocalFileName != NULL) {
            if (ShellExecute(NULL, "open",  pCacheEntryInfo->lpszLocalFileName,
                             NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
                // ShellExecute returns <= 32 if error occured
                MessageBox(hwnd, "Error: Unable to open cache file!",
                            "Log View Error", MB_OK | MB_ICONERROR);
            }
        }
        else {
                MessageBox(hwnd, "Error: No file name available!",
                           "Log View Error", MB_OK | MB_ICONERROR);
        }
    }
}

void RefreshLogView(HWND hwnd)
{
    HANDLE                          hUrlCacheEnum;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    HWND                            hwndLV;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    ListView_DeleteAllItems(hwndLV);
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    hUrlCacheEnum = FindFirstUrlCacheEntry(URL_SEARCH_PATTERN, pCacheEntryInfo,
                                           &dwBufferSize);
    if (hUrlCacheEnum != NULL) {
        if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
            if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                AddLogItem(hwndLV, pCacheEntryInfo);
            }
        }

        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        while (FindNextUrlCacheEntry(hUrlCacheEnum, pCacheEntryInfo,
                                     &dwBufferSize)) {
            if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
                if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                    AddLogItem(hwndLV, pCacheEntryInfo);
                }
            }

            dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        }
    }
}

void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo)
{
    LVITEM                          lvitem;
    static char                     szBuf[MAX_DATE_LEN];

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;

    FormatDateBuffer(&pCacheEntryInfo->LastModifiedTime, szBuf, NUMBER_OF(szBuf));

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = pCacheEntryInfo->lpszSourceUrlName + lstrlen(URL_SEARCH_PATTERN);

    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText = szBuf;

    ListView_SetItem(hwndLV, &lvitem);
}

void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf, int chBuffer)
{
    SYSTEMTIME                    systime;
    FILETIME                      ftLocalLastMod;

    FileTimeToLocalFileTime(pftLastMod, &ftLocalLastMod);
    FileTimeToSystemTime(&ftLocalLastMod, &systime);

    wnsprintf(szBuf, chBuffer, "%s%d %s %d @ %s%d:%s%d:%s%d",
              PAD_DIGITS_FOR_STRING(systime.wDay), systime.wDay,
              ppszMonths[systime.wMonth - 1],
              systime.wYear,
              PAD_DIGITS_FOR_STRING(systime.wHour), systime.wHour,
              PAD_DIGITS_FOR_STRING(systime.wMinute), systime.wMinute,
              PAD_DIGITS_FOR_STRING(systime.wSecond), systime.wSecond);

}

void InitListView(HWND hwndLV)
{
    LVCOLUMN                lvcol;

    memset(&lvcol, 0, sizeof(LVCOLUMN));

    lvcol.mask = LVCF_TEXT | LVCF_WIDTH;

    lvcol.cx = 350;
    lvcol.pszText = TEXT("Description");

    ListView_InsertColumn(hwndLV, 0, &lvcol);

    lvcol.pszText = TEXT("Date/Time");
    lvcol.cx = 150;

    ListView_InsertColumn(hwndLV, 1, &lvcol);

}

int
_stdcall
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL),
                NULL,
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\getcd_bigpath\getcd.cpp ===
//
// Just print the result of GetCurrentDirectoryW.
//
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"getcd_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> cd;
    DWORD dw;

    cd.resize((1UL << 15) + 1);

    cd[0] = 0;
    dw = GetCurrentDirectoryW(static_cast<DWORD>(cd.size()), &cd[0]);
    if (dw >= cd.size())
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        dw = 0;
    }
    if (dw == 0)
    {
        ::ReportFailure("GetCurrentDirectoryW\n");
        goto Exit;
    }
    printf("%ls\n", &cd[0]);

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\genthnk\genthnk.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    genthnk.c

Abstract:

    This program generates thunks.

Author:

    08-Jul-1995 JonLe

Revision History:

  July 2001 JayKrell
    integrated from base\wow64\tools to base\tools
    merged in checked changes from base\mvdm\MeoWThunks\tools\genthnk
        -G to ignore functions with no prototype
        skip leading @ on exports
    let @Else work with @IfApiCode
    add -LessTrailingWhitespace option to aid formating
    let @Else work with a few @IfFoo forms
  August 2001 JayKrell
    fixed IfApiRet broken above
  January 2002 JayKrell
    integrated /private/winfuse_longhorn/base/tools to /lab01_n/base/win32/fusion/tools
    some -W4 cleanup

--*/

#pragma warning(disable:4057)   /* char vs. unsigned char mixup */
#pragma warning(disable:4100)   /* unreferenced formal parameter */
#pragma warning(disable:4115)   /* named type definition in parentheses */
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4201)   /* nameless struct/union */
#pragma warning(disable:4214)   /* bit field types other than int */
#pragma warning(disable:4267)   /* conversion from 'size_t' to 'int', possible loss of data */
#pragma warning(disable:4706)   /* assignment within conditional expression */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "imagehlp.h"
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "gen.h"

// bitfield values to indicate which platform an API should be switched in on.
#define API_NONE        0
#define API_WIN95       1
#define API_WIN98       2
#define API_NT4         4
#define API_NT5         8
#define API_WIN9x       (API_WIN95 | API_WIN98)
#define API_NTx         (API_NT4 | API_NT5)
#define API_ALL         (API_WIN9x | API_NTx)

#define API_SHIFT_WIN9x 0   // shift API bits right 0 to make Win9x leftmost
#define API_SHIFT_NTx   2   // shift API bits right 2 to make NTx leftmost

// This is the new VC6 import structure.  VC6 import lib spec is checked
// in as wx86\doc\vc6.doc.  Contact Dan Spalding or Kathleen Herold for
// more info.  Or look at sdktools\vctools\coff\deflib.h ImportHdr.
typedef struct ImgImportHdr {
    WORD    Sig1;       // always 0 (IMAGE_FILE_MACHINE_UNKNOWN)
    WORD    Sig2;       // always ffff (IMPORT_HDR_SIG2)
    WORD    Version;
    WORD    Machine;
    DWORD   TimeStamp;
    DWORD   SizeOfData; // count of bytes in strings that follow
    union {
        WORD Ordinal;
        WORD Hint;
    };

    WORD    Type : 2;   // IMPORT_TYPE
    WORD    NameType : 3; // IMPORT_NAME_TYPE
    WORD    Reserved : 11;// Reserved.  Must be 0.
} VC6_IMAGE_IMPORT_HEADER, *PVC6_IMAGE_IMPORT_HEADER;

enum IMPORT_TYPE
{
    IMPORT_CODE = 0,
    IMPORT_DATA = 1,
    IMPORT_CONST = 2,
};

enum IMPORT_NAME_TYPE
{
    IMPORT_ORDINAL,
    IMPORT_NAME,
    IMPORT_NAME_NO_PREFIX,
    IMPORT_NAME_UNDECORATE
};
// end of VC6 import structure


// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8600: 'GENTHNK' ";

// template sections types
char szIFUNC[]= "IFunc";
char szEFUNC[]= "EFunc";
char szEFAST[]= "EFast";
char szTYPES[]= "Types";
char szCODE[] = "Code";
char szFAILTYPES[] = "FailTypes";
char szMACROS[]="Macros";

// template properties
char szTEMPLENAME[]= "TemplateName";
char szMACRONAME[] = "MacroName";
char szTYPENAME[]  = "TypeName";
char szINDLEVEL[]  = "IndLevel";
char szDIRECTION[] = "Direction";
char szNUMARGS[]   = "NumArgs";
char szCGENBEG[]   = "Begin";       // default codeburst name
char szCGENEND[]   = "End";
char szUSE[]       = "Use";
char szALSO[]      = "Also";
char szNOTYPE[]    = "NoType";
char szCASE[]      = "Case";

// substitution macros
const
char szTEMPLATE[]="Template";
const
char szDLLNAME[]="DllName";
const
char szXPTNAME[]="XPTName";
const
char szDLLTARGET[]="DllTarget";
const
char szAPIFNRET[]="ApiFnRet";
const
char szAPIFNMOD[]="ApiFnMod";
const
char szAPINAME[]="ApiName";
const
char szAPINAMESKIP[]="ApiNameSkip";
const
char szAPIFORWARD[]="ApiForward";
const
char szAPINUM[]="ApiNum";
const
char szAPIUNKNOWN[]="ApiUnknown";
const
char szAPINODECL[]="ApiNoDecl";
const char szISAPIDECLARED[]="IsApiDeclared"; /* like previous, but a boolean expression */
const
char szFASTCALL[]="FastCall";
const
char szSLOWCALL[]="SlowCall";
const
char szFASTX2NMETH[]="FastX2NMethod";
const
char szSLOWX2NMETH[]="SlowX2NMethod";
const
char szFATX2NMETH[]="FatX2NMethod";
const
char szMETHODNUMBER[]="MethodNumber";
const
char szRETSIZE[]="RetSize";
const
char szUNALIGNEDTAG64[]="UnalignedTag64";
const
char szARGSIZE[]="ArgSize";
const
char szARGTYPE[]="ArgType";
const
char szARGHOSTTYPE[] = "ArgHostType";
const
char szARGTYPEIND[]="ArgTypeInd";
const
char szARGHOSTTYPEIND[]="ArgHostTypeInd";
const
char szARGNAME[]="ArgName";
const
char szARGNAMEHOSTCASTED[]="ArgHostName";
const
char szARGVAL[]="ArgVal";
const
char szFUNCARGNUM[]="FuncArgNum";
const
char szARGMOD[]="ArgMod";
const
char szARGPOSTMOD[]="ArgPostMod";
const
char szARGLIST[]="ArgList";
const
char szIFAPIRET[]="IfApiRet";
const char szDOESAPIRETURNVOID[] = "DoesApiReturnVoid"; /* like previous, but a boolean expression */
const
char szIFARGS[]="IfArgs";
const
char szARGMORE[]="ArgMore";
const
char szAPILIST[]="ApiList";
const
char szAPIMORE[]="ApiMore";
const
char szLISTCOL[]="ListCol";
const
char szARGLOCAL[]="ArgLocal";
const
char szARGOFF[]="ArgOff";
const
char szARGADDR[]="ArgAddr";
const
char szEXPORTLIST[]="ExportList";
const
char szEXPNAME[]= "ExpName";
const
char szIFEXPFORWARD[]= "IfExpForward";
const
char szADDRARGSLIST[]="AddrArgsList";
const
char szNARGTYPE[]="NArgType";
const
char szNARGNAME[]="NArgName";
const
char szIFRETTYPE[]="IfRetType";
const
char szIFORDINALS[]="IfOrdinals";
const
char szAPISTRINGS[]="ApiStrings";
const
char szDBGSINDEX[]="DbgsIndex";
const
char szDBGSLIST[]="DbgsList";
const
char szDBGSSTRINGS[]="DbgsStrings";
const
char szDBGSMORE[]="DbgsMore";
const
char szCPPEXPORT[]="CppExport";
const
char szCEXPORT[]="CExport";
const
char szCPPOUTPUT[]="CppOutput";
const
char szCOUTPUT[]="COutput";
const
char szAPIDECLSPEC[]="ApiDeclSpec";
const
char szIFAPICODE[]="IfApiCode";
const
char szRETTYPE[]="RetType";
const
char szMARG[]="MArg";
const
char szMEMBERTYPES[]="MemberTypes";
const
char szBTOTMEMBERTYPES[]="BtoTMemberTypes";
const
char szFORCETYPE[]="ForceType";
const
char szLOG[]="Log";
const
char szRTOLTYPES[]= "RtoLTypes";
const
char szIFNOTRETTYPE[]="IfNotRetType";
const
char szIFISMEMBER[]="IfIsMember";
const
char szIFNISMEMBER[]="IfNotIsMember";
const
char szIFISBITFIELD[]="IfIsBitfield";
const
char szIFNISBITFIELD[]="IfNotIsBitfield";
const
char szIFISARRAY[]="IfIsArray";
const
char szIFNISARRAY[]="IfNotIsArray";
const
char szARGARRAYELEMENTS[]="ArrayElements";
const
char szIFPOINTERTOPTRDEP[]="IfPointerToPtrDep";
const
char szIFNPOINTERTOPTRDEP[]="IfNotPointerToPtrDep";
const
char szISPOINTERTOPTRDEP[]="IsPointerToPtrDep";
const
char szIFPTRDEP[]="IfPtrDep";
const
char szIFNPTRDEP[]="IfNotPtrDep";
const
char szIFINT64DEPUNION[]="IfInt64DepUnion";
const
char szIFNINT64DEPUNION[]="IfNotInt64DepUnion";
const
char szNL[]="NL";
const
char szINDENT[]="Indent";
const
char szNOFORMAT[]="NoFormat";
const
char szALIGN[]="Align";
char szCOMMENT[]="Comment";
const
char szOFFSET[]="OffSet";
const
char szHOSTAPPEND[]="Host";
char szCARG[]="CArg";
char szCARGEXIST[]="CArgExist";
const
char szFORCASE[]="ForCase";
const
char szCNUMBER[]="CNumber";

const
char szISINTFORWARD[]="IsIntForward";
const
char szISNOTINTFORWARD[]="IsNotIntForward";

// if support
const
char szIF[]="If";
const
char szELSE[]="Else";
const
char szOR[]="Or";
const
char szAND[]="And";
const
char szNOT[]="Not";

const
char szARGUNIONULARGEINTEGER[]="PULARGE_INTEGER";
const
char szARGUNIONLARGEINTEGER[]="PLARGE_INTEGER";

BOOL g_fLessTrailingWhitespace;

extern char sz__PTR64[];

#define MAX_ALSO        80
#define MAX_CODEBURST   20
#define MAX_NOTYPE      32

typedef struct tagCODEBURST {
    char *Name;
} CODEBURST;

CODEBURST CodeBursts[MAX_CODEBURST];

typedef struct _Templates{
   LIST_ENTRY   TempleEntry;
   char *Name;
   int  IndLevel;
   TOKENTYPE tkDirection;
   PKNOWNTYPES pktType;
   char *Comment;
   char *CodeBurst[MAX_CODEBURST];
   char *NoTypes[MAX_NOTYPE];
   PLIST_ENTRY pCaseList;
   char Buffer[1];
}TEMPLES, *PTEMPLES;

typedef struct _CGenerate {
   LIST_ENTRY CGenerateEntry;
   FILE *fp;

   FILE *fpC;
   char *FileNameC;
   char *FileBaseNameC;

   FILE *fpCpp;
   char *FileNameCpp;
   char *FileBaseNameCpp;

   char TempleName[1];
}CGENERATE, *PCGENERATE;

FILE *fpLog;    // file pointer to optional log file for @Log() calls


//
// handy macro to knock out the hi bit in implib style ordinals
//
#define IMPORDINAL(o) ((o) & ~0x80000000)

//
// Structure definining the list of arguments for a function
//
typedef struct _ArgumentsList {
   LIST_ENTRY   ArgumentsEntry;     // ptr to prev and next arg
   PKNOWNTYPES  pKnownTypes;        // type of this arg
   PKNOWNTYPES  pStructType;        // cache used by MemberTypes()
   DWORD        ArgSize;            // size of this arg
   BOOL         IsPtr64;            // TRUE if this arg is __ptr64
   int          OffSet;             // offset from stack for this arg
   int          IndLevel;           // indirection level
   TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT
   TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    SUEOpt;             // TK_STRUCT/ENUM/UNION/NONE
   char         *Type;              // typename for this arg
   TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   char          *Name;              // argument name (may be a nonameX)
   char         *ArgLocal;          // name of local var containing copy of arg
   char         *HostCastedName;    // Contains full name of struct member with
                                    // host casts or NULL
   BOOL         fRequiresThunk;     // TRUE if arg type contains a nested
                                    //  function pointer (and hence needs
                                    //  special thunking)
   BOOL         fNoType;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   BOOL         fIsMember;          // This arg is actually a member of an array
   BOOL         bIsBitfield;        // Determines if this is a bitfield
   int          BitsRequired;       // Number of bits required for bitfield
   BOOL         bIsArray;           // This member is an array
   int          ArrayElements;      // Number of elements in the array
} ARGSLIST, *PARGSLIST;

//
// Structure containing the list of macro arguments
//
typedef struct _MacroArgsList {
    int  NumArgs;
    LPSTR ArgText[1];
} MACROARGSLIST, *PMACROARGSLIST;

typedef struct _MLListEntry {
   LIST_ENTRY ListEntry;
   PMACROARGSLIST pMArgs;
} MLLISTENTRY, *PMLLISTENTRY;

#define MAX_MACRO_STACK     20
PMACROARGSLIST MacroStack[MAX_MACRO_STACK];
int MacroStackTop;


//
// This defines the first method number that would not be supported as a
// fast or slow method call. If this is to be changed then FastN2X and SlowN2X
// worker routines need to be addeed in whole32.dll
#define MAXFASTN2XMETHODNUMBER  16

//
// This defines the maximum number of parameters that are allowed to be in a
// FastX2N or SlowX2N method call. To change it new code would have to be
// added to FastX2N and SlowX2N in whole32\methods.c to deal with the
// additional number of parameters.
#define MAXX2NPARAMETERS        10

typedef enum {
    UNKNOWNMETHOD = 0,
    FATX2NMETHOD = 1,
    FASTX2NMETHOD = 2,
    SLOWX2NMETHOD = 3
} METHODTYPE;

typedef struct _ExportDebugInfo {
   LIST_ENTRY  ExportsDbgEntry;
   LIST_ENTRY  ArgsListHead;
   struct _ExportDebugInfo  *IntForward;
   int         ArgsSize;
   ULONG       Function;
   char       *ExtForward;
   char       *ExportName;
   char       *CplusDecoration;
   ULONG       Ordinal;

   // 0 = known fn, -1 incomplete declaration, 1 no declaration
   char        UnKnownApi;
   BOOLEAN     Data;
   BOOLEAN     PrivateNamed;
   CHAR        FastCall;
   BYTE        ApiPlatform;     // the API_ bit collection
   METHODTYPE  X2NMethodType;
   ULONG       MethodNumber;
   char        Buffer[1];
}EXPORTSDEBUG, *PEXPORTSDEBUG;

typedef struct _DebugStringsList {
   LIST_ENTRY  DebugStringsEntry;
   char *Name;
   char *ArgFormat;
   char *RetFormat;
   char Buffer[1];
} DEBUGSTRINGS, *PDEBUGSTRINGS;

typedef struct _CGenerateState {
   PEXPORTSDEBUG  ExportsDbg;
   PDEBUGSTRINGS  DebugStrings;
   PCGENERATE     CGen;
   PTEMPLES       Temple;       // template for this func (may be IFunc or EFunc)
   PKNOWNTYPES    ApiTypes;
   int            ApiNum;
   PARGSLIST      pArgsList;
   int            ListCol;
   BOOLEAN        MoreApis;
   BOOLEAN        ExTemplate;   // true if Temp is an EFunc template with a 'Begin='
   PTEMPLES       TempleEx;     // EFunc for this API (if there is one)
   int            CodeBurstIndex;
   PTEMPLES       CurrentTemple; // This is the template that is currently being expanded.
   PMACROARGSLIST pMacroArgsList;
   PCHAR          *MemberNoType; // Additional set of notypes to applyPMACROARGSLIST pMacroArgsList;
   int            CaseNumber;  // Number of the current Case being expanded.
   PLIST_ENTRY    pCaseList;
   PMACROARGSLIST pCaseArgsList;
} CGENSTATE, *PCGENSTATE;

int BeginCBI;       // CodeBurstIndex for 'Begin='

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE TypeDefsList;
PRBTREE StructsList;

RBTREE FakeFuncsList;
LIST_ENTRY TypeTempleList;
LIST_ENTRY FailTempleList;
LIST_ENTRY IFuncTempleList;
LIST_ENTRY EFuncTempleList;
LIST_ENTRY EFastTempleList;
LIST_ENTRY CodeTempleList;
LIST_ENTRY CGenerateList;
LIST_ENTRY ExportsList;
LIST_ENTRY DebugStringsList;
LIST_ENTRY MacroList;
ULONG NumDebugStringsEntries;

BOOL MapViewDll(char *DllName);
char DllName[MAX_PATH+1]= "";
char ExplicitDllBaseName[MAX_PATH+1] = "UNSPECIFIED";
char *DllBaseName = ExplicitDllBaseName;
PVOID DllMappedBase = NULL;
ULONG_PTR DllRvaOffset;
PULONG DllFunctions = NULL;
PUSHORT DllNameOrdinals = NULL;
PULONG DllNameTable = NULL;
ULONG DllExportDirSize;
PIMAGE_EXPORT_DIRECTORY DllExportDir;

BOOL MapViewImplib(char *ImplibName);
char ImplibName[MAX_PATH+1]="";
char *ImplibBaseName = NULL;
PVOID ImplibMappedBase= NULL;
ULONG ImplibNumSymbols=0;
PULONG ImplibSymbolMembers=NULL;
PCHAR ImplibSymbolNames=NULL;
char szIMPPREFIX[]="__imp_";
char szIDATA5[]=".idata$5";
char szTEXT[]=".text";

char szINTFORWARD[]="_IntForward_";

char XptName[MAX_PATH+1]= "";
char *XptBaseName = NULL;

// these are used to report errors while parsing .tpl files
char *TemplateFileName;
int TemplateLine;

char iHandleCpp = 0; // if == 0, Don't use CPP macros,  and warn if CPP exports found
                     // if < 0, Don't use CPP macros, no warn if CPP exports found
                     // if > 0, Use CPP macros.

BOOL bIgnorePrototypeError;
BOOL bNoFuzzyLogic;
BOOL bUseExpListAndImplib;
BOOL bWarnAboutNestedFuncPtrs;
BOOL bUseDirection = TRUE;
BOOL bStripNewline = TRUE;

int OutputColumn = 0;
int IndentLevel = 0;
BOOL bFirstCharHit = FALSE;
#define INDENTSIZE 4

void SetInternalForwards(void);
BOOL ExtractXpt(char *XptName, char *DllName);
BOOL ExtractExports(void);
BOOL ExtractPpm(char *FileName);
BOOL ExtractTemples(char *FileName);
BOOL ExtractCGenerate(char *pNames);
BOOL ExtractImplib(char *LibName);


char *CopyField(char *pDst, char *pSrc, int Len, char Sep);
void DumpTemplate(PTEMPLES ptpl, FILE *fp);
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName);
char *CGenerate(char *pSrc, PCGENSTATE pCGenState);
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned);
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports);
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always);
void ProcessTemple(PCGENSTATE pCGenState);
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState);
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL);
char *MemberTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT);
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState);
char *IncludeRetType(char *pSrc, PCGENSTATE pCGenState);
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore);
BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug);
PEXPORTSDEBUG FindInExportsList(char *Name);
char *SkipSubExpression(char *pSrc, char **pSubExpression);
PKNOWNTYPES BuildFakeTypesInfo(PEXPORTSDEBUG pExportsDbg, PKNOWNTYPES pKnownTypes);
void WriteListColumn(PCGENSTATE pCGenState);
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len);
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead);
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult);
char *DoesApiReturnVoid(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult);
char *IfApiCode(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult);
char *IfRetType(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult);
char *IfArgs(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult);
void ApiStrings(PCGENSTATE pCGenState);
int GetFuncArgNum(PCGENSTATE pCGenState);
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName);
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState);
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState);
int GetRetSize(PCGENSTATE pCGenState);
int GetArgSize(PEXPORTSDEBUG ExportDebug);
char *GetOffSet(char *pSrc, char *Buffer);
char *LexMacroArgs(char *pch);
PLIST_ENTRY ListFromTempleType(char *TempleType);
void UseLogMacros(char *pLogName);
char *UpdateLog(char *pSrc, PCGENSTATE pCGenState);
BOOL IsPointerToPtrDep(PARGSLIST pArgsList);
char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState);
VOID SetArgListToTypeForArg(PARGSLIST pArgsList, PARGSLIST pArgsListOld, char * pTypeName);
void StripTrailingWhitespaceFromString(char * s);
char * SkipLeadingWhitespace(char * s);
BOOL IsWhitespaceCharacter(char c);

BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
     );

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     );



char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

PKNOWNTYPES
IsSameType(
     PKNOWNTYPES pktArgs,
     int IndLevel,
     TOKENTYPE tkArgDirection,
     char *tplTypeName,
     int tplIndLevel,
     TOKENTYPE tkTypeDirection,
     BOOL bScanBaseTypes
     );

char *
WriteArgAddr(
      char *pSrc,
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen
       );

BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    );


int
GetCodeBurstIndex(
    char *BurstName
    );

int
GetExistingCodeBurstIndex(
    char *BurstName
    );

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    );

BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    );

void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

char *
ExtractBoolean1(
    char *pSrc,
    PCGENSTATE pCGenState,
    BOOLEAN *result
    );

char *
ExtractBoolean2(
    char *pSrc,
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    );

void
WriteBoolean (
    char *pSrc,
    BOOL Value
    );


char *CPlatformSwitches[] = { "",
                              "(%s==0x0400)",
                              "(%s>0x0400)",
                              "(%s>=0x0400)" };
char *AsmPlatformSwitches[] = { "",
                                "(%s_ASM EQ 0400h)",
                                "(%s_ASM GT 0400h)",
                                "(%s_ASM GE 0400h)" };

BOOL
ExpandTemple(PTEMPLES ptpl,
             int CodeBurstIndex,
             PCGENSTATE pCGenState)
{

   PLIST_ENTRY pOldCaseList;
   PTEMPLES    pOldCurrentTemple;
   char *pSrc = ptpl->CodeBurst[CodeBurstIndex];

   if (NULL == pSrc) {
      return FALSE;
   }

   pSrc = ptpl->CodeBurst[CodeBurstIndex];

   while (*pSrc && !isgraph(*pSrc)) {
       pSrc++;
   }

   if ('\0' == *pSrc) {
       return FALSE;
   }

   //
   // Expand the type here

   pOldCurrentTemple = pCGenState->CurrentTemple;
   pOldCaseList = pCGenState->pCaseList;

   if(ptpl->pCaseList != NULL &&
      !IsListEmpty(ptpl->pCaseList)) {

       pCGenState->pCaseList = ptpl->pCaseList;
   }

   pCGenState->CurrentTemple = ptpl;
   CGenerate(pSrc, pCGenState);

   pCGenState->CurrentTemple = pOldCurrentTemple;
   pCGenState->pCaseList = pOldCaseList;

   return TRUE;

}

PVOID CheckHeapAlloc(SIZE_T Size) {
   PVOID pMem;

   pMem = GenHeapAlloc(Size);
   if(NULL == pMem) {
       DbgPrintf("Error: Out of Memory!\n");
       DebugBreak();
       ExitErrMsg(FALSE, "Error: Out of Memory!\n");
   }
   return pMem;
}

typedef struct _StringListEntry {
    LIST_ENTRY ListEntry;
    PSTR pStr;
} STRINGLISTENTRY, *PSTRINGLISTENTRY;

VOID
FreeMacroArgsList(PMACROARGSLIST pArgs) {
   SIZE_T c;
   for(c=0; c < (SIZE_T)pArgs->NumArgs; c++) {
      GenHeapFree(pArgs->ArgText[c]);
   }
   GenHeapFree(pArgs);
}

char *
CArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer,
    BOOL TestExistOnly
    )
{
    int i;
    int ArgNum;
    CHAR s[MAX_PATH];
    PCHAR pResult;
    PMACROARGSLIST pList = pCGenState->pCaseArgsList;
    PCHAR pCommandName = TestExistOnly ? szCARGEXIST : szCARG;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) %s unexpected: no case is currently being applied\n",
                   TemplateFileName, TemplateLine, pCommandName);
        return NULL;
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) %s Incorrect parameter %s\n",
                   TemplateFileName, TemplateLine, pCommandName, pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid %s parameter %s\n", TemplateFileName, TemplateLine,
                   pCommandName, s);
        return NULL;
    }

    if (TestExistOnly) {
       pResult = (ArgNum >= pList->NumArgs) ? "0" : "1";
    }
    else {
        if (ArgNum >= pList->NumArgs) {
            ExitErrMsg(FALSE, "%s(%d) Case only has %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
            return NULL;
        }
        pResult = pList->ArgText[ArgNum];
    }
    if (pBuffer != NULL) {
        *pBuffer = pResult;
    }
    else {
        CGenerate(pResult, pCGenState);
    }
    return pSrc;
}

char *ForCase(char *pSrc, PCGENSTATE pCGenState) {

   PMACROARGSLIST pCaseArgsListOld;
   PLIST_ENTRY pHead, pThis;
   char *pch;
   char *pExpression;
   int OldCaseNumber;

   // Are any cases available for application
   if (pCGenState->pCaseList == NULL ||
       (pCGenState->pCaseList != NULL && IsListEmpty(pCGenState->pCaseList))) {
      //Do nothing
      return SkipSubExpression(pSrc, NULL);
   }

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
      return pch;
   }
   pSrc = pch;

   pCaseArgsListOld = pCGenState->pCaseArgsList;
   pHead = pCGenState->pCaseList;
   pThis = pHead->Flink;
   OldCaseNumber = pCGenState->CaseNumber;
   pCGenState->CaseNumber = 0;
   do {
      pCGenState->pCaseArgsList = CONTAINING_RECORD(pThis,MLLISTENTRY,ListEntry)->pMArgs;
      CGenerate(pExpression, pCGenState);
      pThis = pThis->Flink;
      pCGenState->CaseNumber++;
   } while (pThis != pHead );
   pCGenState->CaseNumber = OldCaseNumber;
   pCGenState->pCaseArgsList = pCaseArgsListOld;

   return pSrc;
}

PCHAR
ParseMacroArgs(IN PCHAR pch,
               IN SIZE_T maxlen,
               OUT PMACROARGSLIST *ppMArgsList
               )
{
   PMACROARGSLIST pMArgsList = NULL;
   LIST_ENTRY ArgsList;
   PCHAR pl;
   int ArgCount=0;
   int ParenDepth=0;
   SIZE_T len = 0;

   if (maxlen == 0) {
      len = MAXUINT_PTR;
   }

   InitializeListHead(&ArgsList);

   if (*pch != '(') {
      ExitErrMsg(FALSE, "ParseMacroArgs: Expected to find ( for args list\n");
   }

   pch++;
   ParenDepth++;
   len++;

   while(ParenDepth > 0) {

      pl = pch;

      while(1) {
         if('\0' == *pl || len > maxlen) {
            ExitErrMsg(FALSE, "ParseMacroArgs: Unmatched paren for args list\n");
         }

         if (*pl == '(') {
            ParenDepth++;
         }

         else if (*pl == ')') {
            ParenDepth--;
         }

         if (ParenDepth == 0 ||
             (ParenDepth == 1 && *pl == ',')) {
            PSTRINGLISTENTRY pSl;
            pSl = CheckHeapAlloc(sizeof(STRINGLISTENTRY));
            pSl->pStr = CheckHeapAlloc(pl - pch + 1);
            memcpy(pSl->pStr, pch, pl - pch);
            pSl->pStr[pl - pch] = '\0';
            InsertTailList(&ArgsList, &(pSl->ListEntry));

            ArgCount++;
            pch = pl + 1;
            if (ParenDepth == 0) {
               // No more arguments
               goto Exit;
            }
            else {
               // Do next argument
               break;
            }
         }

         pl++;

      }

   }
Exit:
   pMArgsList = CheckHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
   pMArgsList->NumArgs = ArgCount;
   for(ArgCount = 0; ArgCount < pMArgsList->NumArgs; ArgCount++) {
      PSTRINGLISTENTRY pSl;

      pSl = CONTAINING_RECORD(ArgsList.Flink,STRINGLISTENTRY,ListEntry);
      RemoveHeadList(&ArgsList);

      pMArgsList->ArgText[ArgCount] = pSl->pStr;
      GenHeapFree(pSl);
   }

   *ppMArgsList = pMArgsList;
   return pch;
}

void ExtractServicesTab(char *pch);
/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
   int   i;
   DWORD dw;
   char *pch;
   CGENSTATE CGenState;
   PLIST_ENTRY Next;
   BOOL bUseServicesTab = FALSE;

   // init the lists
   InitializeListHead(&TypeTempleList);
   InitializeListHead(&FailTempleList);
   InitializeListHead(&CodeTempleList);
   InitializeListHead(&IFuncTempleList);
   InitializeListHead(&EFuncTempleList);
   InitializeListHead(&EFastTempleList);
   InitializeListHead(&CGenerateList);
   InitializeListHead(&ExportsList);
   InitializeListHead(&DebugStringsList);
   InitializeListHead(&MacroList);
   NumDebugStringsEntries = 0;
   BeginCBI = GetCodeBurstIndex(szCGENBEG);    // Preload 'Begin=' as a valid codeburst


   SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);


   /*try*/ {


       /*
        *  Get cmd line args.
        */
       i = 0;
       while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                if (_stricmp(pch, "LessTrailingWhitespace") == 0) {
                    g_fLessTrailingWhitespace = TRUE;
                }
                else
                switch (toupper(*pch)) {
                   case 'D':
                      bDebug = TRUE;
                      setvbuf(stderr, NULL, _IONBF, 0);
                      break;

                   case 'F':
                      bExitClean = FALSE;
                      break;

                   case 'T':  // template file name
                      if (!ExtractTemples(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractTemples failed %s\n", pch);
                          }

                      break;

                   case 'C':  //cgenerate "-cOutputFileName[,CppOutputFileName]:TemplateName"
                      if (!ExtractCGenerate(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractCGenerate failed %s\n", pch);
                          }

                      break;

                   case 'M':   // ppm file name (only 1 expected!)
                      if (FuncsList) {
                          ExitErrMsg(FALSE, "ExtractPpm only one Ppm file allowed %s\n", pch);
                          }

                      if (!ExtractPpm(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractPpm failed %s\n", pch);
                          }

                      break;
                   case 'S':   //use a services.tab instead of an exports list
                      bUseServicesTab = TRUE;
                      ExtractServicesTab(pch+1);
                      break;
                   case 'E':   // xpt list for exports "-eExportListName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(XptName) - 1,
                                           XptName,
                                           &XptBaseName
                                           );
                      if (!dw || dw >= sizeof(XptName) - 1) {
                          ExitErrMsg(FALSE, "Invalid XptName %s\n", pch);
                          }

                      break;

                   case 'X':  // Enable exports from implib, -eXptName assumed
                      bUseExpListAndImplib = TRUE;
                      break;

                   case 'I':   // implib file name "-iImplibName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(ImplibName) - 1,
                                           ImplibName,
                                           &ImplibBaseName
                                           );
                      if (!dw || dw >= sizeof(ImplibName) - 1) {
                          ExitErrMsg(FALSE, "Invalid Import Library Name %s\n", pch);
                          }
                      break;

                   case 'L':   // Disable fuzzy logic symbol name matching
                      bNoFuzzyLogic = TRUE;
                      break;

                   case 'W':   // warn about unthunked structures containing function ptrs
                      bWarnAboutNestedFuncPtrs = TRUE;
                      break;

                   case 'U':   // [U]se direction information (__in, __out)
                      bUseDirection = FALSE;    // turn it off
                      break;

                   case 'K':    // generate chec[K] file from @Log() macros
                      UseLogMacros(pch+1);
                      break;

                   case 'N':    // specify explicit DLL base name
                      strncpy(DllBaseName, pch+1, MAX_PATH);
                      break;

                   case 'G':    // ignore function prototype errors for debugging purpose only
                      bIgnorePrototypeError = TRUE;
                      break;

                   default:
                      ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                   }
                }
            else if (*pch) {

                dw = GetFullPathName(pch,
                                    sizeof(DllName) - 1,
                                    DllName,
                                    &DllBaseName
                                    );
                if (!dw || dw >= sizeof(DllName) - 1) {
                     ExitErrMsg(FALSE, "Invalid DllName %s\n", pch);
                     }

                }
            }

       if(!bUseServicesTab) {

         //
         // MapView of importlib and dll into memory and
         // set up global variables for easy access
         //

         if (ImplibName[0]) {
            if (!MapViewImplib(ImplibName)) {
                  ExitErrMsg(FALSE, "Couldn't open import lib '%s'\n", ImplibName);
            }
         }

         if (DllName[0]) {
            if (!MapViewDll(DllName)) {
               ExitErrMsg(FALSE, "Couldn't open DLL '%s'\n", DllName);
            }
         }



         //
         // Extract exports using dll and implib.
         //

         if (DllName[0] && (!XptName[0] || bUseExpListAndImplib)) {

           // Insist that we have both an implib and a dll.
           if ((DllName[0] && !ImplibName[0]) || (ImplibName[0] && !DllName[0])) {
                ExitErrMsg(FALSE, "DllName or ImplibName missing\n");
           }

           if (!ExtractExports()) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", DllName);
           }

         }

         //
         // Extract exports from the api list
         //

         if (XptName[0]) {
            if (!ExtractXpt(XptName, DllName)) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", XptName);
            }
         }
       }

       //
       // Set Internal forwards.
       //
       SetInternalForwards();


       Next = CGenerateList.Flink;
       while (Next != &CGenerateList) {

           memset(&CGenState, 0, sizeof(CGenState));

           CGenState.CGen = CONTAINING_RECORD(Next,CGENERATE,CGenerateEntry);

           ProcessTemple(&CGenState);

           DelOpenFile(CGenState.CGen->fp, NULL);
           fclose(CGenState.CGen->fp);

           Next= Next->Flink;
           }
       }
     /*except(EXCEPTION_EXECUTE_HANDLER) {
       ExitErrMsg(FALSE,
                  "ExceptionCode=%x\n",
                  GetExceptionCode()
                  );
       }*/

   CloseOpenFileList(FALSE);
   return 0;
}


int
GetCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, add it.

Arguments:

    BurstName   - name of codeburst to get/add.

Return Value:

    Index into template->CodeBursts[], or calls ExitErrMsg() on error.

--*/
{
    int i;
    int FirstFree = -1;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        } else {
            if (FirstFree == -1) {
                FirstFree = i;
            }
        }
    }

    if (FirstFree == -1) {
        if (TemplateFileName) {
            ExitErrMsg(FALSE,
                   "%s(%d) Cannot specify more than %d unique codeburst names (%s)",
                   TemplateFileName, TemplateLine,
                   MAX_CODEBURST, BurstName
                  );
        } else {
            ExitErrMsg(FALSE,
                   "Cannot specify more than %d unique codeburst names (%s)",
                   MAX_CODEBURST, BurstName
                  );
        }
    }

    i = strlen(BurstName)+1;

    CodeBursts[FirstFree].Name = GenHeapAlloc(i);
    if (!CodeBursts[FirstFree].Name) {
        ExitErrMsg(TRUE, "Out of memory in GetCodeBurstIndex");
    }
    memcpy(CodeBursts[FirstFree].Name, BurstName, i);

    return FirstFree;
}


int
GetExistingCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, call ExitErrMsg().

Arguments:

    BurstName   - name of codeburst to get.

Return Value:

    Index into template->CodeBursts[], or -1 on error.

--*/
{
    int i;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        }
    }

    return -1;
}


PKNOWNTYPES
GetApiTypes(
    PEXPORTSDEBUG ExportsDbg
    )
{
    PKNOWNTYPES ApiTypes;
    char *ExpName;
    char *pch;

    ExpName = ExportsDbg->IntForward ? ExportsDbg->IntForward->ExportName
                                     : ExportsDbg->ExportName;


    //
    // Look in the FakeFuncsLIst, and the FuncsList.
    //

    ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
    if (!ApiTypes) {
        ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
        }


    //
    // If export is a decorated name then lets see if we have
    // a func that matches the undecorated name
    //

    if (!ApiTypes) {
        pch = strchr(ExpName, '@');
        if (pch) {
            *pch = '\0';
            ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
            if (!ApiTypes) {
                ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
                }
            *pch = '@';
            }
        }

    if (!ApiTypes && ExportsDbg->Data) {
        ApiTypes = GetNameFromTypesList(TypeDefsList, "PVOID");
        }

    else
    {

        if (!ApiTypes || !ApiTypes->pfuncinfo) {
            ApiTypes = BuildFakeTypesInfo(ExportsDbg, ApiTypes);
            }

        if (!ApiTypes->pktRet) {
            // Get KnownTypes info for Return Type
            PKNOWNTYPES pkt;

            ResetLexer();
            LexMacroArgs(ApiTypes->FuncRet);
            ConsumeConstVolatileOpt();

            if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
                CurrentTokenIndex = 0;
                if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
                    ExitErrMsg(FALSE, "GetApiTypes: Undefined return type %s\n", ApiTypes->FuncRet);
                }
            }
            ApiTypes->pktRet = pkt;
        }
    }

    return ApiTypes;

}






/*
 * ProcessTemple
 */
void ProcessTemple(PCGENSTATE pCGenState)
{
    PLIST_ENTRY Next;
    PTEMPLES pTemple;
    PTEMPLES pTempleEx;

    pTemple = GetTemplate(&CodeTempleList, pCGenState->CGen->TempleName);
    if (pTemple) {
        fprintf(pCGenState->CGen->fp,
                "%s CodeTemplate:%s\n",
                pTemple->Comment,
                pTemple->Name
                );
        pCGenState->Temple = pTemple;
        ExpandTemple(pCGenState->Temple, pCGenState->CodeBurstIndex, pCGenState);
    } else if (pTemple = GetTemplate(&IFuncTempleList,
                                    pCGenState->CGen->TempleName
                                    )) {
        pCGenState->ApiNum = 0;
        Next = ExportsList.Flink;
        while (Next != &ExportsList) {
            BYTE ApiPlatform;

            pCGenState->ExportsDbg = CONTAINING_RECORD(Next,
                                                       EXPORTSDEBUG,
                                                       ExportsDbgEntry
                                                       );

            //
            // Switch this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            pCGenState->Temple = pTemple;
            PlatformSwitchStart(pCGenState, ApiPlatform);

            pCGenState->ApiTypes = GetApiTypes(pCGenState->ExportsDbg);

            //
            // Use exception template for this api if there is one
            //
            pTempleEx = GetTemplate(&EFuncTempleList,
                                    pCGenState->ExportsDbg->ExportName
                                    );
            pCGenState->TempleEx = pTempleEx;
            if (pTempleEx) {
                pCGenState->ExTemplate = TRUE;
            } else {
                pCGenState->ExTemplate = FALSE;
            }

            if (pTempleEx && (pTempleEx->CodeBurst[BeginCBI] || TempleHasNoCodeBursts(pTempleEx))) {

                pCGenState->Temple = pTempleEx;
                fprintf(pCGenState->CGen->fp,
                        "%s Func Template:%s\n",
                        pTempleEx->Comment,
                        pTempleEx->Name
                        );

                 if (TempleHasNoCodeBursts(pTempleEx)) {
                    // skip this API:  ex template, but not code at all
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Api %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
/*
                else if (bIgnorePrototypeError) {

                    fprintf(pCGenState->CGen->fp,
                             "%s Error:1 Ignoring Api %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
*/
            } else {
                // no ex template

                pCGenState->Temple = pTemple;

                if (pCGenState->ExportsDbg->Data) {
                    // DATA export - skip the API
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Data Export %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                } else if (!pCGenState->ApiTypes->pfuncinfo) {
                    // members unknown - skip the API
                    if (bIgnorePrototypeError)
                    {
                        fprintf(pCGenState->CGen->fp,
                                "%s Error:2 Ignoring Api %s\n",
                                pCGenState->Temple->Comment,
                                pCGenState->ExportsDbg->ExportName
                        );
                        goto SkipGen;
                    }
                    else {
                        ExitErrMsg(FALSE,
                                   "API %s has no function prototype - unable to generate code.",
                                   pCGenState->ExportsDbg->ExportName
                                  );
                    }
                } else if (!iHandleCpp && pCGenState->ExportsDbg->CplusDecoration) {
                    // CPP export and we aren't set up for CPP exports
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluding CPP Api: %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
            }

               //
               // skip this api if:
               // - external forward reference
               // - internal forward which does not define the fn
               //
               //
            if ( (pCGenState->ExportsDbg->ExtForward ||
                      (pCGenState->ExportsDbg->IntForward &&
                       pCGenState->ExportsDbg->IntForward != pCGenState->ExportsDbg))) {
               fprintf(pCGenState->CGen->fp,
                        "%s %s forwarded to %s\n",
                       pCGenState->Temple->Comment,
                       pCGenState->ExportsDbg->ExportName,
                       pCGenState->ExportsDbg->ExtForward
                          ? pCGenState->ExportsDbg->ExtForward
                          : pCGenState->ExportsDbg->IntForward->ExportName
                       );

               if (pTempleEx) {
                  fprintf(pCGenState->CGen->fp,
                          "%s WARNING: forwarded function has an exception template\n",
                          pCGenState->Temple->Comment,
                          pTempleEx->Name
                         );
               }

            } else {    // gen code for this api
                PLIST_ENTRY NextArg;
                PARGSLIST   pArgsList;

                BuildArgsList(pTempleEx,
                              pCGenState->ApiTypes->pfuncinfo,
                              &pCGenState->ExportsDbg->ArgsListHead
                              );

                if (GetArgSize(pCGenState->ExportsDbg) < 0) {
                    // members unknown - skip the API
                    if (bIgnorePrototypeError)
                    {
                        fprintf(pCGenState->CGen->fp,
                                "%s Error:3 Ignoring Api %s\n",
                                pCGenState->Temple->Comment,
                                pCGenState->ExportsDbg->ExportName
                        );
                        goto SkipGen;
                    }
                    else {
                        ExitErrMsg(FALSE,
                                   "API %s has no function prototype - unable to generate code.",
                                   pCGenState->ExportsDbg->ExportName
                                  );
                    }
                } else {

                    ExpandTemple(pCGenState->Temple, BeginCBI, pCGenState);

                    //
                    // Dump warnings about unthunked parameters which
                    // contain nested function pointers.
                    //
                    if (bWarnAboutNestedFuncPtrs && !pTempleEx) {
                        int ArgNum = 1;
                        NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;

                        while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                           pArgsList = CONTAINING_RECORD(NextArg,
                                                         ARGSLIST,
                                                         ArgumentsEntry
                                                         );
                           if (pArgsList->fRequiresThunk) {
                                //
                                // The argument contained a nested function
                                // pointer, and nothing thunked that
                                // function pointer.  Warn about a potential
                                // bug.
                                //
                                fprintf(pCGenState->CGen->fp,
                                    "// *** WARNING: Arg %d: type '%s' contains an unthunked function pointer ***\n",
                                    ArgNum,
                                    pArgsList->Type
                                    );
                            }
                            NextArg = NextArg->Flink;
                            ArgNum++;
                        }
                    }

                    //
                    // clean up pArgsList->LocalVar and ArgHostName
                    //
                    NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
                    while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                       pArgsList = CONTAINING_RECORD(NextArg,
                                                     ARGSLIST,
                                                     ArgumentsEntry
                                                     );
                       if (pArgsList->ArgLocal) {
                           GenHeapFree(pArgsList->ArgLocal);
                           pArgsList->ArgLocal = NULL;
                           }
                       if (pArgsList->HostCastedName) {
                          GenHeapFree(pArgsList->HostCastedName);
                          pArgsList->HostCastedName = NULL;
                       }

                       NextArg = NextArg->Flink;
                       }

                    pCGenState->ApiNum++;
                    }
                }

SkipGen:
            //
            // End switching this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            PlatformSwitchEnd(pCGenState, ApiPlatform);

            Next= Next->Flink;
        }
    } else {
        ExitErrMsg(FALSE,
                   "%s,%s:%s Template undefined\n",
                   pCGenState->CGen->FileNameC,
                   pCGenState->CGen->FileNameCpp ? pCGenState->CGen->FileNameCpp : "",
                   pCGenState->CGen->TempleName
                   );
    }
}


void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    BOOL fIsAsm;

    if (ApiPlatform == API_ALL) {
        return;
    }

    //
    // Switch this API in or out depending on the platform info
    //      00: don't emit anything
    //      01: emit "== 0x0400"
    //      10: emit "> 0x0400"
    //      11: emit ">= 0x0400"
    //
    if (!pCGenState->Temple || !pCGenState->Temple->Comment) {
        fIsAsm = FALSE;
    } else {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fIsAsm = TRUE;
        } else {
            fIsAsm = FALSE;
        }
    }

    if (fIsAsm) {
        fprintf(pCGenState->CGen->fp, "\nif ");
    } else {
        fprintf(pCGenState->CGen->fp, "\n#if ");
    }

    if (ApiPlatform & API_WIN9x) {
        BYTE Plat = (ApiPlatform & API_WIN9x) >> API_SHIFT_WIN9x;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINDOWS"
                );
    }

    if ((ApiPlatform & API_WIN9x) && (ApiPlatform & API_NTx)) {
        // API is on some flavor of Win9x and some NTx flavor
        fprintf(pCGenState->CGen->fp, (fIsAsm) ? " OR " : " || ");
    }

    if (ApiPlatform & API_NTx) {
        BYTE Plat = (ApiPlatform & API_NTx) >> API_SHIFT_NTx;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINNT"
                );
    }

    if (pCGenState->ListCol) {
        WriteListColumn(pCGenState);
    } else {
        fprintf(pCGenState->CGen->fp, "\n");
    }

}



void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
       fprintf(pCGenState->CGen->fp, "\n#else\n     {whInvalidCall, 0, 0},");
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

/*
 *  BuildArgsList
 *
 *
 */
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead)
{
    int  i;
    ULONG Size;
    int OffSet=0;
    int ArgOffSet;
    PKNOWNTYPES pkt;
    PARGSLIST pArgsList;
    int NoTypeCount;
    char *HostCastedName;

    if (!IsListEmpty(pListHead)) {
        return;
    }

    if (!pTempleEx) {
        NoTypeCount = 0;
    } else {
        //
        // There is an [EFunc] for this API.  Get the count of
        // NoType= entries for the EFunc.
        //
        for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {
            if (!pTempleEx->NoTypes[NoTypeCount]) {
                break;
            }
        }
    }

    while (funcinfo) {
        pkt = GetNameFromTypesList(TypeDefsList, funcinfo->sType);
        if (!pkt) {
            pkt = GetNameFromTypesList(StructsList, funcinfo->sType);
            if (!pkt) {
                ExitErrMsg(FALSE, "Unknown type %s\n", funcinfo->sType);
            }
        }

        //
        // Save the ArgOffSet, and add the args size to the cumulative
        // offset for the next argument.
        //
        // Round up the arg size to the next dword. Assumes intel stack
        // parameter passing conventions, and that all pointers are
        // sizeof(int *) except __ptr64 which are sizeof(PVOID64).
        //
        ArgOffSet = OffSet;

        Size = funcinfo->IndLevel +
                pkt->IndLevel ?
                funcinfo->fIsPtr64 ?
                  SIZEOFPOINTER64 : SIZEOFPOINTER : pkt->Size;

        OffSet += ((Size + 3) & ~3) >> 2;

        //
        // Create ARGSLIST entry, and add it to the list
        //
        pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
        if (!pArgsList) {
            ExitErrMsg(TRUE, "bal.\n");
        }
        memset(pArgsList, 0, sizeof(ARGSLIST));

        if(funcinfo->sName == NULL) {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, szHOSTAPPEND);
        }
        else {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND) + strlen(funcinfo->sName));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, funcinfo->sName);
           strcat(HostCastedName, szHOSTAPPEND);
        }

        pArgsList->pKnownTypes = pkt;
        pArgsList->OffSet      = ArgOffSet;
        pArgsList->IndLevel    = funcinfo->IndLevel;
        pArgsList->ArgSize     = Size;
        pArgsList->IsPtr64     = funcinfo->fIsPtr64;
        pArgsList->Mod         = funcinfo->tkPreMod;
        pArgsList->tkDirection = funcinfo->tkDirection;
        pArgsList->SUEOpt      = funcinfo->tkSUE;
        pArgsList->Type        = funcinfo->sType;
        pArgsList->PostMod     = funcinfo->tkPostMod;
        pArgsList->PrePostMod  = funcinfo->tkPrePostMod;
        pArgsList->Name        = funcinfo->sName;
        pArgsList->HostCastedName = HostCastedName;
        pArgsList->fIsMember   = FALSE;
        pArgsList->bIsBitfield = FALSE;
        pArgsList->BitsRequired= 0;
        pArgsList->bIsArray    = FALSE;
        pArgsList->ArrayElements=0;

        if (pkt->Flags & BTI_CONTAINSFUNCPTR) {
            //
            // This parameter type is either a function pointer, or
            // a type which contains an embedded function pointer.
            // Something is going to have to thunk it.
            //
            pArgsList->fRequiresThunk = TRUE;
        }

        if (pTempleEx) {
            //
            // There is an [EFunc] for this API.  See if this param
            // should have [Types] templates expanded or not.
            //
            for (i=0; i<NoTypeCount; ++i) {
                if (pTempleEx->NoTypes[i] &&
                    strcmp(pArgsList->Name, pTempleEx->NoTypes[i]) == 0) {
                    //
                    // This param is not supposed to have [Types] expanded
                    //
                    pArgsList->fNoType = TRUE;
                    pTempleEx->NoTypes[i] = NULL;
                }
            }
        }


        InsertTailList(pListHead, &pArgsList->ArgumentsEntry);

        //
        // and on to the next argument .....
        //
        funcinfo = funcinfo->pfuncinfoNext;
    }

    if (pTempleEx) {
        //
        // For error reporting, indicate any NoTypes= that did not match
        // a param name
        //
        for (i=0; i<NoTypeCount; ++i) {
            if (pTempleEx->NoTypes[i]) {
                ExitErrMsg(FALSE, "[EFunc] %s(%x) has a 'NoType=%s' which does not correspond to an argument name\n", pTempleEx->Name, pTempleEx, pTempleEx->NoTypes[i]);
            }
        }
    }

    return;
}


//
// return pointer to type of first argument
char *NArgType(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
    PARGSLIST pArgsList;
    PLIST_ENTRY Next;
    char *pch = s;
    CGENSTATE CGenState;
    int Len, i;
    char *pSrc;

    pSrc = *ppSrc;
    if (*pSrc != '(') {
        ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < iLen-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    *ppSrc = ++pSrc;
    Len = atoi(s);

    if (Len-- == 0) {
        ErrMsg("Invalid NArgType parameter %s\n", s);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
        return NULL;
    }


    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );

        return NULL;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    // check for void arg list
    pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
    if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
        return NULL;
    }

    CGenState = *pCGenState;

    for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
        Next= Next->Flink;
    }
    if (Next == &CGenState.ExportsDbg->ArgsListHead) {
        ErrMsg("NArgType parameter out of range %d\n", Len);
        fprintf(pCGenState->CGen->fp, "** ERROR ** NArgType parameter out of range %d\n", Len);
        return NULL;
    }

    CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

    //
    // Copy in the explicit struct/union/enum keyword, if present
    //
    strcat(pch, TokenString[CGenState.pArgsList->SUEOpt]);

    //
    // Copy in the actual typename
    //
    strcpy(pch, CGenState.pArgsList->Type);

    if (CGenState.pArgsList->PrePostMod != TK_NONE) {
        strcat(pch, " ");
        strcat(pch,  TokenString[CGenState.pArgsList->PrePostMod]);
    }
    pch = pch  + strlen(pch);
    if (CGenState.pArgsList->IndLevel) {
        *pch++ = ' ';
        for (i=0; i<CGenState.pArgsList->IndLevel; ++i) {
            *pch++ = '*';
        }
    }
    *pch = '\0';

    return(s);
}

//
// return pointer to name of first argument
char *NArgName(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch = s;
   CGENSTATE CGenState;
   int Len, i;
   char *pSrc;

   pSrc = *ppSrc;
   if (*pSrc != '(') {
       ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
       return(NULL);
       }

   pSrc++;
   i = 0;
   while ((*pSrc != ')') && (i < iLen-1)) {
       s[i++] = *pSrc++;
       }
   s[i] = 0;
   *ppSrc = ++pSrc;
   Len = atoi(s);

   if (Len-- == 0) {
       ErrMsg("Invalid NArgType parameter %s\n", s);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
       return(NULL);
       }

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return(NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return(NULL);
       }

   CGenState = *pCGenState;

   for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
       Next= Next->Flink;
       }
   if (Next == &CGenState.ExportsDbg->ArgsListHead) {
       ErrMsg("NArgName parameter out of range %d\n", Len);
       fprintf(pCGenState->CGen->fp, "** ERROR ** NArgName parameter out of range %d\n", Len);
       return(NULL);
       }

   CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

   strcpy(pch, CGenState.pArgsList->Name);

   return(s);
}

char *
MArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer
    )
/*++

Routine Description:

    Expand the n'th argument for the current macro

Arguments:

    pSrc        - pointer to character following 'MArg'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the macro argument

--*/
{
    int i;
    int ArgNum;
    PMACROARGSLIST pList = pCGenState->pMacroArgsList;
    char s[MAX_PATH];
    PMACROARGSLIST OldList;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) MArg unexpected: no macro is currently being expanded\n", TemplateFileName, TemplateLine);
        return NULL;
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) Incorrect MArg parameter %s\n", TemplateFileName, TemplateLine, pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid MArg parameter %s\n", TemplateFileName, TemplateLine, s);
        return NULL;
    }

    if (ArgNum >= pList->NumArgs) {
        ExitErrMsg(FALSE, "%s(%d) Macro only takes %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
        return NULL;
    }

    if (pBuffer == NULL) {
       OldList = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];
       CGenerate(pList->ArgText[ArgNum], pCGenState);
       MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = OldList;
    }
    else {
       *pBuffer = pList->ArgText[ArgNum];
    }
    return pSrc;
}

char *ArgType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
        int i;

        pch = Buffer;
        if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
            strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
            strcat(pch, " ");
            pch += strlen(pch);
        }
        strcpy(pch,  pCGenState->pArgsList->Type);
        if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
            strcat(pch, " ");
            strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
        }
        pch = pch+strlen(pch);
        if (pCGenState->pArgsList->IndLevel) {
            *pch++ = ' ';
            for (i=0; i<pCGenState->pArgsList->IndLevel; ++i) {
                *pch++ = '*';
            }
        }
        *pch = '\0';
        pch = Buffer;
        return pch;
   }
   else
      return NULL;
}

char *UnalignedTag64(char *Buffer, PCGENSTATE pCGenState) {

    //
    // PUT UNALIGNED TAg for interested type like KLPWST KHBITMAP all kernel mode shareable struct
    //

    char CurrArgType[256];
    if ( NULL == ArgType ( CurrArgType, pCGenState))
        return NULL;

    //
    // Now chek the name
    //

    if ( pCGenState->pArgsList->ArgSize == 8 ) {

         //
         // BUGBUG: check if you need special case for KLPWSTR and KHBITMAP
         //         if so put more generic form
         //(strncmp ( CurrAgrType, "KLPWSTR ",7) == 0) ||
         //(strncmp ( CurrAgrType, "KHBITMAP ",8) == 0)
         //

        strcpy (Buffer, "*(UNALIGNED ");
        strcat (Buffer, CurrArgType);
        if (strchr(CurrArgType, '*') == NULL )
            strcat ( Buffer, " ");
        strcat (Buffer, "*)&");
        return Buffer;
    }
    return NULL;

}


char *ArgHostType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
      pch = Buffer;
      /*if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
         strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
         strcat(pch, " ");
         pch += strlen(pch);
      }*/
      if (pCGenState->pArgsList->IndLevel > 0) {
         strcpy(pch, GetHostPointerName(pCGenState->pArgsList->IsPtr64));
         pch += strlen(pch);
      }
      else {
         char Buffer[MAX_PATH];
         strcpy(pch, GetHostTypeName(pCGenState->pArgsList->pKnownTypes, Buffer));
         pch += strlen(pch);
      }
      *pch = '\0';
      pch = Buffer;
      return pch;
   }
   else
      return NULL;
}

BOOL IsPointer(PCGENSTATE pCGenState) {
    return (pCGenState->pArgsList->IndLevel > 0) || (pCGenState->pArgsList->pKnownTypes->IndLevel > 0);
}

char *ArgTypeInd(char *Buffer, PCGENSTATE pCGenState, BOOL bHostName) {

   CGENSTATE GenStateOld;
   ARGSLIST ArgsListOld;
   KNOWNTYPES KnownTypes;
   PKNOWNTYPES pCurrent;
   int IndLevel;
   char *pch;

   //copy over the old structures before mangaling them
   GenStateOld = *pCGenState;
   ArgsListOld = *(pCGenState->pArgsList);
   KnownTypes = *(pCGenState->pArgsList->pKnownTypes);
   pCGenState->pArgsList->pKnownTypes = &KnownTypes;

   if (pCGenState->pArgsList->IndLevel > 0) {
      IndLevel = pCGenState->pArgsList->IndLevel - 1;
      goto success;
   }

   pCurrent = &KnownTypes;
   IndLevel = pCurrent->IndLevel;
   if (IndLevel == 0) {
      ErrMsg("ArgTypeInd: Tried to get name of type pointed to by %s\n",pCGenState->pArgsList->Name);
      ExitErrMsg(FALSE, "ArgTypeInd: %s is not a pointer!\n", pCGenState->pArgsList->Name);
   }

   while(1) {//chase all the way down to a struct/union/enum or a func_ptr
      PCHAR IndName;
      ASSERT(pCurrent != NULL);
      if (pCurrent->IndLevel == 1 && !bHostName && ((IndName = IsDefinedPtrToPtrDependent(pCurrent->TypeName)) != NULL)) {
          PKNOWNTYPES pkt;
          IndLevel--;
          pkt = GetNameFromTypesList(TypeDefsList, IndName);

          ASSERT(pkt != NULL);
          KnownTypes = *pkt;
          goto success;
      }
      else if (pCurrent->pTypedefBase != NULL) {
         pCurrent = pCurrent->pTypedefBase;
      }
      else {
         //hit a struct/union/enum or func_ptr
         KnownTypes = *pCurrent;
         pCGenState->pArgsList->pStructType = NULL;
         pCGenState->pArgsList->SUEOpt = TK_NONE;
         IndLevel--;

         if (pCurrent->Flags & BTI_NOTDERIVED) {
            pCGenState->pArgsList->SUEOpt = TK_NONE;
              goto success;
         }
         else if(strcmp("struct", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_STRUCT;
            goto success;
         }
         else if(strcmp("union", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_UNION;
            goto success;
         }
         else if(strcmp("enum", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_ENUM;
            goto success;
         }
         else {
            ExitErrMsg(FALSE, "ArgTypeInd: Can't determine what %s is.\n", pCGenState->pArgsList->Name);
         }
      }
   }

success:
   //fake out the typename and the indirection
   KnownTypes.IndLevel = 0;
   pCGenState->pArgsList->IndLevel = IndLevel;
   pCGenState->pArgsList->Type = KnownTypes.TypeName;
   //Print the mangled type, then restore the old type
   if (bHostName)
      pch = ArgHostType(Buffer, pCGenState);
   else
      pch = ArgType(Buffer, pCGenState);

   *pCGenState = GenStateOld;
   *(pCGenState->pArgsList) = ArgsListOld;

   return pch;
}

char *ApiName(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pTemp;
   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);

   // if ApiName has decoration then truncate it
   pTemp = strchr(Buffer, '@');
   if (pTemp) {
      *pTemp = '\0';
   }

   *pch = Buffer;
   return pSrc;
}

char *ApiNameSkip(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pNewSrc, *pTemp, *pEnd;
   int CharsToSkip;

   pNewSrc = ApiName(pSrc, pch, Buffer, pCGenState);

   pEnd = SkipSubExpression(pNewSrc, NULL);
   if (pNewSrc == pEnd)
      return pNewSrc;

   pTemp = pNewSrc+1;
   CharsToSkip = atoi(pTemp);
   while(**pch != '\0' && CharsToSkip > 0) {
      (*pch)++;
      CharsToSkip--;
   }

   return pEnd;

}

BOOL IsPointerToPtrDep(PARGSLIST pArgsList) {
   PKNOWNTYPES pCurrent;

   pCurrent = pArgsList->pKnownTypes;

   if (pArgsList->IndLevel + pCurrent->IndLevel < 1)
      ExitErrMsg(FALSE, "IsPointerToPtrDep: %s is not a pointer\n", pArgsList->Name);

   if (pArgsList->IndLevel + pCurrent->IndLevel > 1) {

      // Since pCurrent->IndLevel is acumulative, this can happen if and
      // only if this type or one of its base types is a pointer to
      // another pointer.  This case is defined to be pointer dependent.

      return TRUE;
   }

   // At this point, either pArgsList->IndLevel == 1 and pCurrent->IndLevel == 0
   // or pArgsList->IndLevel == 0 and pCurrent->IndLevel = 1.
   // First check if this type is defined to be a pointer to a pointer dependent type.
   // If not, defererence the pointer by walking through typedefs until pCurrent->IndLevel = 0
   // Note that multiple levels of pointers are no longer possible.

   if(IsDefinedPtrToPtrDependent(pCurrent->TypeName)) {
       return TRUE;
   }

   while(pCurrent->IndLevel != 0) {

      // Check if this type is one of the special types used
      // between sortpp and genthnk.

      if (pCurrent->Flags & BTI_NOTDERIVED)
     return FALSE;

      // Assert that this type is not a struct, union, or enum.
      // This shouldn't happen because sortpp should store
      // these with an indlevel of 0.

      ASSERT(strcmp(pCurrent->BaseName, "struct") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "union") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "enum") != 0);

      // Check if this type is a function pointer.  If it is,
      // return FALSE since they are arbitrarly defined to not
      // be pointer dependent.  This may be changed check if any
      // of the arguments to the function pointer are pointer dependent.

      if (strcmp(pCurrent->BaseName, "()") == 0)
     return FALSE;

      // Get the base typedef.
      pCurrent = pCurrent->pTypedefBase;
   }

   // Now that the pointer has been dereferenced, test if
   // this type is pointer dependent.

   return (pCurrent->Flags & BTI_POINTERDEP) != 0;
}

char *TestIfPointerToPtrDep(char *pSrc, PCGENSTATE pCGenState, PCHAR pch) {

    PCHAR pEnd;
    PMACROARGSLIST pMArgsList;
    ARGSLIST ArgsList;
    CHAR TypeName[MAX_PATH];
    SIZE_T BytesReturned;

    pEnd = SkipSubExpression(pSrc, NULL);
    if (pSrc == pEnd) {
       ExitErrMsg(FALSE, "TestIfPointerToPtrDep: exactly 1 argument is required.\n");
    }

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    SetArgListToTypeForArg(&ArgsList, &ArgsList, TypeName);

    if(IsPointerToPtrDep(&ArgsList)) {
        strcpy(pch, "1");
    }
    else {
        strcpy(pch, "0");
    }
    FreeMacroArgsList(pMArgsList);
    return pEnd;
}

BOOL IsPtrDep(PARGSLIST pArgsList) {
   //This is a pointer to something(ptr dep.)
   if (pArgsList->IndLevel > 0)
      return TRUE;
   return pArgsList->pKnownTypes->Flags & ( BTI_POINTERDEP | BTI_INT64DEP );
}
BOOL IsInt64DepUnion(PCGENSTATE pCGenState) {


   char Buff[256];

   Buff[0]=0;
   ArgTypeInd( Buff, pCGenState, FALSE);

   // make exception for union _ULARGE_INTEGER
   if (strncmp(Buff, "union _ULARGE_INTEGER", sizeof ("union _ULARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );
   if (strncmp(Buff, "union _LARGE_INTEGER", sizeof ("union _LARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );


   return FALSE; //pArgsList->pKnownTypes->Flags & BTI_INT64DEP;
}

void DoIndent(PCGENSTATE pCGenState) {
    int i;
    for(i=IndentLevel, OutputColumn = 1; i > 0; i--,OutputColumn++) {
        if (fputc(' ', pCGenState->CGen->fp) != ' ')
            ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
        OutputColumn++;
    }
}

char * CGeneratePrintChar(char *pch, PCGENSTATE pCGenState) {
   if (!bStripNewline) {
       if('\n' == *pch) {
            //bFirstCharHit = FALSE;
            OutputColumn = 0; //will be incremented to 1
       }
      goto PrintIt;
   }
   else {
      if (*pch == '\n')
         goto SkipIt;
      if (!bFirstCharHit) {
         if(!isspace(*pch)) {
            DoIndent(pCGenState);
            bFirstCharHit = TRUE;
            goto PrintIt;
         }
         else
            goto SkipIt;
      }
      else
         goto PrintIt;
   }
PrintIt:
   if (fputc(*pch, pCGenState->CGen->fp) != *pch)
      goto PrintError;
   OutputColumn++;
SkipIt:
   return pch + 1;
PrintError:
   ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
   return NULL;
}

char *CGenerate(char *pSrc, PCGENSTATE pCGenState) {
   return CGenerateEx(pSrc, pCGenState, NULL, 0, NULL);
}

/*
 *  CGenerate
 *
 */
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned)
{
   FILE **pfp = &pCGenState->CGen->fp;
   char *pch;
   size_t Len;
   char Buffer[MAX_PATH*4];
   char *BufferPos = NULL;

   if (OutBuffer != NULL) {
      BufferPos = OutBuffer;
      *BytesReturned = 0;
   }

   while (*pSrc) {

       if (OutBuffer != NULL && MaxLen == 0) {
          ExitErrMsg(FALSE, "Out of buffer space!\n");
       }

       if (*pSrc != '@') {
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }
       }
       else if (*(pSrc + 1) == '@') {
          pSrc++;
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }
       }
       else {
#define ELSE(f) \
           if ( *pSrc == '@' && \
                    !strncmp(pSrc+1, szELSE, sizeof(szELSE) - 1)) { \
                pSrc += sizeof(szELSE) - 1+1; \
                pSrc = WriteMore(pSrc, pCGenState, !(f)); \
            }

           pch = NULL;
           memset(Buffer, 0, sizeof(Buffer));
             pSrc++;    //skip the @ is the command name

             if(bStripNewline && !bFirstCharHit) {
                 OutputColumn = 1 + IndentLevel;
             }

           if (!strncmp(pSrc, szNL, sizeof(szNL) - 1)) {
               pSrc += sizeof(szNL) - 1;
               if (fputc('\n', *pfp) != '\n')
                  ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
               OutputColumn = 1;
               bFirstCharHit = FALSE;
           }
           else if (!strncmp(pSrc, szINDENT, sizeof(szINDENT) - 1)) {
               int OldIndent;
               pSrc += sizeof(szINDENT) - 1;
               OldIndent = IndentLevel;
               IndentLevel += INDENTSIZE;
               pSrc = WriteMore(pSrc, pCGenState, TRUE);
               IndentLevel = OldIndent;
           }
           else if (!strncmp(pSrc, szNOFORMAT, sizeof(szNOFORMAT) - 1)) {
              BOOL bOldStripNewline;
                 pSrc += sizeof(szNOFORMAT) - 1;
              bOldStripNewline = bStripNewline;
              bStripNewline = FALSE;
              pSrc = WriteMore(pSrc, pCGenState, TRUE);
              bStripNewline = bOldStripNewline;
           }
           else if (!strncmp(pSrc, szTEMPLATE, sizeof(szTEMPLATE) - 1)) {
               pSrc += sizeof(szTEMPLATE) - 1;
               pSrc = IncludeTemplate(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szAPILIST, sizeof(szAPILIST) - 1)) {
               pSrc += sizeof(szAPILIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szAPINAMESKIP, sizeof(szAPINAMESKIP) -1 )) {
               pSrc += sizeof(szAPINAMESKIP) - 1;
               pSrc = ApiNameSkip(pSrc, &pch, Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szAPINAME, sizeof(szAPINAME) - 1)) {
               pSrc += sizeof(szAPINAME) - 1;
               pSrc = ApiName(pSrc, &pch, Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szAPIFORWARD, sizeof(szAPIFORWARD) - 1)) {
               pSrc += sizeof(szAPIFORWARD) - 1;

               if (pCGenState->ExportsDbg->IntForward) {
                   strcpy(Buffer, szINTFORWARD);
                   strcpy(Buffer + sizeof(szINTFORWARD) - 1,
                          pCGenState->ExportsDbg->IntForward->ExportName
                          );
                   }
               else {
                   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);
                   }

               // if ApiName has decoration then truncate it
               pch = strchr(Buffer, '@');
               if (pch) {
                   *pch = '\0';
                   }

               pch = Buffer;

               }

           else if (!strncmp(pSrc, szAPINUM, sizeof(szAPINUM) - 1)) {
               _itoa(pCGenState->ApiNum, Buffer, 10);
               pch = Buffer;
               pSrc += sizeof(szAPINUM) - 1;
               }
           else if (!strncmp(pSrc, szAPIFNRET, sizeof(szAPIFNRET) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncRet;
                   }
               pSrc += sizeof(szAPIFNRET) - 1;
               }
           else if (!strncmp(pSrc, szAPIDECLSPEC, sizeof(szAPIDECLSPEC) - 1)) {
               BOOL b = pCGenState->ApiTypes && (pCGenState->ApiTypes->Flags & BTI_DLLEXPORT);

               pSrc += sizeof(szAPIDECLSPEC) - 1;
               pSrc = WriteMore(pSrc, pCGenState, b);
               }
           else if (!strncmp(pSrc, szAPIFNMOD, sizeof(szAPIFNMOD) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncMod;
                   }
               pSrc += sizeof(szAPIFNMOD) - 1;
               }
           else if (!strncmp(pSrc, szAPIMORE, sizeof(szAPIMORE) - 1)) {
               pSrc += sizeof(szAPIMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szIFAPIRET, sizeof(szIFAPIRET) - 1)) {
               BOOL fResult = FALSE;
               pSrc += sizeof(szIFAPIRET) - 1;
               pSrc = IfApiRet(pSrc, pCGenState, &fResult);
               ELSE(fResult);
               }
           else if (!strncmp(pSrc, szDOESAPIRETURNVOID, sizeof(szDOESAPIRETURNVOID) - 1)) {
               BOOL fResult = FALSE;
               pSrc += sizeof(szDOESAPIRETURNVOID) - 1;
               pSrc = DoesApiReturnVoid(pSrc, pCGenState, &fResult);
               WriteBoolean(Buffer, fResult);
               pch = Buffer;
           }
           else if (!strncmp(pSrc, szIFISMEMBER, sizeof(szIFISMEMBER) - 1)) {
               pSrc += sizeof(szIFISMEMBER) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->fIsMember);
           }
           else if (!strncmp(pSrc, szIFNISMEMBER, sizeof(szIFNISMEMBER) - 1)) {
              pSrc += sizeof(szIFNISMEMBER) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->fIsMember));
           }
           else if (!strncmp(pSrc, szIFISBITFIELD, sizeof(szIFISBITFIELD) - 1)) {
               pSrc += sizeof(szIFISBITFIELD) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsBitfield);
           }
           else if (!strncmp(pSrc, szIFNISBITFIELD, sizeof(szIFNISBITFIELD) - 1)) {
              pSrc += sizeof(szIFNISBITFIELD) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsBitfield));
           }
           else if (!strncmp(pSrc, szIFISARRAY, sizeof(szIFISARRAY) - 1)) {
               pSrc += sizeof(szIFISARRAY) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsArray);
           }
           else if (!strncmp(pSrc, szIFNISARRAY, sizeof(szIFNISARRAY) - 1)) {
              pSrc += sizeof(szIFNISARRAY) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsArray));
           }
           else if (!strncmp(pSrc, szARGARRAYELEMENTS, sizeof(szARGARRAYELEMENTS) - 1)) {
              pSrc += sizeof(szARGARRAYELEMENTS) - 1;
              _itoa((int)(pCGenState->pArgsList->ArrayElements), Buffer, 10);
              pch = Buffer;
           }
           else if (!strncmp(pSrc, szIFPOINTERTOPTRDEP, sizeof(szIFPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPOINTERTOPTRDEP, sizeof(szIFNPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szISPOINTERTOPTRDEP, sizeof(szISPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szISPOINTERTOPTRDEP) - 1;
              pch = Buffer;
              pSrc = TestIfPointerToPtrDep(pSrc, pCGenState, pch);
           }
           else if (!strncmp(pSrc, szIFPTRDEP, sizeof(szIFPTRDEP) -1 )) {
              pSrc += sizeof(szIFPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPTRDEP, sizeof(szIFNPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFINT64DEPUNION, sizeof(szIFINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsInt64DepUnion(pCGenState));
           }
           else if (!strncmp(pSrc, szIFNINT64DEPUNION, sizeof(szIFNINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFNINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsInt64DepUnion(pCGenState));
           }
           else if (!strncmp(pSrc, szIFAPICODE, sizeof(szIFAPICODE) -  1)) {
               BOOL fResult = FALSE;

               pSrc += sizeof(szIFAPICODE) - 1;
               pSrc = IfApiCode(pSrc, pCGenState, &fResult);
               ELSE(fResult);
               }
           else if (!strncmp(pSrc, szFASTCALL, sizeof(szFASTCALL) - 1)) {
               pSrc += sizeof(szFASTCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szSLOWCALL, sizeof(szSLOWCALL) - 1)) {
               pSrc += sizeof(szSLOWCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, !IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szFASTX2NMETH, sizeof(szFASTX2NMETH) - 1)) {
               pSrc += sizeof(szFASTX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FASTX2NMETHOD);
               }
           else if (!strncmp(pSrc, szSLOWX2NMETH, sizeof(szSLOWX2NMETH) - 1)) {
               pSrc += sizeof(szSLOWX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == SLOWX2NMETHOD);
               }
           else if (!strncmp(pSrc, szFATX2NMETH, sizeof(szFATX2NMETH) - 1)) {
               pSrc += sizeof(szFATX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FATX2NMETHOD);
               }
           else if (!strncmp(pSrc, szMETHODNUMBER, sizeof(szMETHODNUMBER) - 1)) {
               pSrc += sizeof(szMETHODNUMBER) - 1;
               _itoa(pCGenState->ExportsDbg->MethodNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szIFARGS, sizeof(szIFARGS) - 1)) {
               BOOL fResult = FALSE;
               pSrc += sizeof(szIFARGS) - 1;
               pSrc = IfArgs(pSrc, pCGenState, &fResult);
               ELSE(fResult);
               }
           else if (!strncmp(pSrc, szFUNCARGNUM, sizeof(szFUNCARGNUM) - 1)) {
               pSrc += sizeof(szFUNCARGNUM) - 1;
               _itoa(GetFuncArgNum(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szRETSIZE, sizeof(szRETSIZE) - 1)) {
               pSrc += sizeof(szRETSIZE) - 1;
               _itoa(GetRetSize(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGSIZE, sizeof(szARGSIZE) - 1)) {
               pSrc += sizeof(szARGSIZE) - 1;
               _itoa(GetArgSize(pCGenState->ExportsDbg), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szFORCASE, sizeof(szFORCASE) - 1)) {
               pSrc += sizeof(szFORCASE) - 1;
               pSrc = ForCase(pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szCARGEXIST, sizeof(szCARGEXIST) - 1)) {
               pSrc += sizeof(szCARGEXIST) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, TRUE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, TRUE);
               }
           }
           else if (!strncmp(pSrc, szCARG, sizeof(szCARG) - 1)) {
               pSrc += sizeof(szCARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, FALSE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, FALSE);
               }
           }
           else if (!strncmp(pSrc, szCNUMBER, sizeof(szCNUMBER) - 1)) {
               pSrc += sizeof(szCNUMBER) - 1;
               _itoa(pCGenState->CaseNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGLIST, sizeof(szARGLIST) - 1)) {
               pSrc += sizeof(szARGLIST) - 1;
               if (pCGenState->ApiTypes) {
                   pSrc = ListArgs(pSrc, pCGenState, TRUE);
                   }
               }
           else if (!strncmp(pSrc, szNARGTYPE, sizeof(szNARGTYPE) - 1)) {
               pSrc += sizeof(szNARGTYPE) - 1;
               pch = NArgType(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szNARGNAME, sizeof(szNARGNAME) - 1)) {
               pSrc += sizeof(szNARGNAME) - 1;
               pch = NArgName(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szMARG, sizeof(szMARG) - 1)) {
               pSrc += sizeof(szMARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = MArg(pSrc, pCGenState, &pch);
               }
               else {
                  pSrc = MArg(pSrc, pCGenState, NULL);
               }
           }
           else if (!strncmp(pSrc, szFORCETYPE, sizeof(szFORCETYPE) - 1)) {
               pSrc += sizeof(szFORCETYPE) - 1;
               pSrc = ForceTypeExpand( pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szMEMBERTYPES, sizeof(szMEMBERTYPES) - 1)) {
               pSrc += sizeof(szMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szBTOTMEMBERTYPES, sizeof(szBTOTMEMBERTYPES) - 1)) {
               pSrc += sizeof(szBTOTMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szLOG, sizeof(szLOG) - 1)) {
               pSrc += sizeof(szLOG) - 1;
               pSrc = UpdateLog(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFRETTYPE, sizeof(szIFRETTYPE) - 1)) {
               BOOL fResult = FALSE;
               pSrc += sizeof(szIFRETTYPE) - 1;
               pSrc = IfRetType(pSrc, pCGenState, &fResult);
               ELSE(fResult);
               }
           else if (!strncmp(pSrc, szIFNOTRETTYPE, sizeof(szIFNOTRETTYPE) - 1)) {
               pSrc += sizeof(szIFNOTRETTYPE) - 1;
               pSrc = IfNotRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szARGMOD, sizeof(szARGMOD) - 1)) {
               pSrc += sizeof(szARGMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->Mod];
                   }
               }
           else if (!strncmp(pSrc, szARGPOSTMOD, sizeof(szARGPOSTMOD) - 1)) {
               pSrc += sizeof(szARGPOSTMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->PostMod];
                   }
               }
           else if (!strncmp(pSrc, szARGTYPEIND, sizeof(szARGTYPEIND) - 1)) {
              pSrc += sizeof(szARGTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, FALSE);
           }
           else if (!strncmp(pSrc, szARGHOSTTYPEIND, sizeof(szARGHOSTTYPEIND) - 1)) {
              pSrc += sizeof(szARGHOSTTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, TRUE);
           }
           else if (!strncmp(pSrc, szARGHOSTTYPE, sizeof(szARGHOSTTYPE) -1 )) {
              pSrc += sizeof(szARGHOSTTYPE) - 1;
              pch = ArgHostType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGTYPE, sizeof(szARGTYPE) - 1)) {
              pSrc += sizeof(szARGTYPE) - 1;
              pch = ArgType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szUNALIGNEDTAG64, sizeof(szUNALIGNEDTAG64) - 1)) {
              pSrc += sizeof(szUNALIGNEDTAG64) - 1;
              pch = UnalignedTag64(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGNAME, sizeof(szARGNAME) - 1)) {
               if (pCGenState->pArgsList) {
                   pch = pCGenState->pArgsList->Name;
                   if (!pch) {
                       pch = "";
                   }
               }
               pSrc += sizeof(szARGNAME) - 1;
           }
           else if (!strncmp(pSrc, szARGNAMEHOSTCASTED, sizeof(szARGNAMEHOSTCASTED) - 1)) {
               if (pCGenState->pArgsList) {
                  pch = pCGenState->pArgsList->HostCastedName;
                  if (!pch) {
                     if (pCGenState->pArgsList->Name == NULL)
                        pch = "";
                     else
                        pch = pCGenState->pArgsList->Name;
                  }
               }
              pSrc += sizeof(szARGNAMEHOSTCASTED) - 1;
           }
           else if (!strncmp(pSrc, szARGVAL, sizeof(szARGVAL) - 1)) {
               if (pCGenState->pArgsList) {
                   strcpy(Buffer, pCGenState->pArgsList->Name);

                   // replace all occurrences of '->' by '__'
                   // and '.', '*', ')', and '(' by '_'
                   pch = Buffer;
                   while (*pch) {
                       if (*pch == '.' || *pch == ')' || *pch == '(' || *pch == '*')
                          *pch = '_';
                       else if (*pch == '-' && *(pch+1) == '>') {
                           *pch = '_';
                           *(pch+1) = '_';
                           pch++;
                       }
                       pch++;
                   }
                   pch = Buffer;
               } else {
                   pch = "";
               }
               pSrc += sizeof(szARGVAL) - 1;
               }
           else if (!strncmp(pSrc, szARGOFF, sizeof(szARGOFF) - 1)) {
               pSrc += sizeof(szARGOFF) - 1;
               if (pCGenState->pArgsList) {
                   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);
                   pch = Buffer;
                   }
               }
           else if (!strncmp(pSrc, szARGADDR, sizeof(szARGADDR) - 1)) {
               pSrc += sizeof(szARGADDR) - 1;
               if (pCGenState->pArgsList) {
                   if (pCGenState->pArgsList->ArgLocal) {
                       pch = Buffer;
                       *pch = '&';
                       strcpy(pch+1, pCGenState->pArgsList->ArgLocal);
                       pSrc = SkipSubExpression(pSrc, NULL);                       }
                   else {
                       pch = Buffer;
                       pSrc = WriteArgAddr(pSrc,
                                           pCGenState,
                                           pch,
                                           sizeof(Buffer)-1
                                           );
                       }
                   }
               }
           else if (!strncmp(pSrc, szADDRARGSLIST, sizeof(szADDRARGSLIST) - 1)) {
               pSrc += sizeof(szADDRARGSLIST) - 1;
               pch = GetAddrFirstArg(pCGenState, Buffer, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szARGLOCAL, sizeof(szARGLOCAL) - 1)) {
               pSrc += sizeof(szARGLOCAL) - 1;
               if (pCGenState->pArgsList) {
                   pch = Buffer;
                   if (!WriteArgLocal(pCGenState, pch, sizeof(Buffer)-1)) {
                      ExitErrMsg(FALSE, "CGenerate failed\n");
                      }
                   }
               }
           else if (!strncmp(pSrc, szARGMORE, sizeof(szARGMORE) - 1)) {
               pSrc += sizeof(szARGMORE) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->pArgsList &&
                                pCGenState->pArgsList->ArgumentsEntry.Flink
                                  != &pCGenState->ExportsDbg->ArgsListHead
                                );
               }
           else if (!strncmp(pSrc, szTYPES, sizeof(szTYPES) - 1)) {
               pSrc += sizeof(szTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szRTOLTYPES, sizeof(szRTOLTYPES) - 1)) {
               pSrc += sizeof(szRTOLTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szRETTYPE, sizeof(szRETTYPE) - 1)) {
               pSrc += sizeof(szRETTYPE) - 1;
               pSrc = IncludeRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szEXPORTLIST, sizeof(szEXPORTLIST) - 1)) {
               pSrc += sizeof(szEXPORTLIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szEXPNAME, sizeof(szEXPNAME) - 1)) {
               pSrc += sizeof(szEXPNAME) - 1;
               pch = pCGenState->ExportsDbg->ExportName;
               }
           else if (!strncmp(pSrc, szIFEXPFORWARD, sizeof(szIFEXPFORWARD) - 1)) {
               pSrc += sizeof(szIFEXPFORWARD) - 1;
               pch = GetAltExportName(Buffer,  pCGenState, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szIFORDINALS, sizeof(szIFORDINALS) - 1)) {
               pSrc += sizeof(szIFORDINALS) - 1;

               if (pCGenState->ExportsDbg &&
                   (pCGenState->ExportsDbg->Ordinal & 0x80000000))
                 {
                   pch = Buffer;
                   *pch = '@';
                   _itoa(IMPORDINAL(pCGenState->ExportsDbg->Ordinal),
                         pch + 1,
                         10
                         );
                   }
               }
           else if (!strncmp(pSrc, szLISTCOL, sizeof(szLISTCOL) - 1)) {
               pSrc += sizeof(szLISTCOL) - 1;
               pCGenState->ListCol = OutputColumn;
               }
           else if (!strncmp(pSrc, szDLLNAME, sizeof(szDLLNAME) - 1)) {
               Len = CopyToken(Buffer, DllBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLNAME) - 1;
               }
           else if (!strncmp(pSrc, szXPTNAME, sizeof(szXPTNAME) - 1)) {
               Len = CopyToken(Buffer, XptBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szXPTNAME) - 1;
               }
           else if (!strncmp(pSrc, szDLLTARGET, sizeof(szDLLTARGET) - 1)) {
               Len = CopyToken(Buffer, pCGenState->CGen->FileBaseNameC, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "Overflow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLTARGET) - 1;
               }
           else if (!strncmp(pSrc, szAPIUNKNOWN, sizeof(szAPIUNKNOWN) - 1)) {
               pSrc += sizeof(szAPIUNKNOWN) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi
                                );
               }
           else if (!strncmp(pSrc, szAPINODECL, sizeof(szAPINODECL) - 1)) {
               pSrc += sizeof(szAPINODECL) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi == 1
                                );
               }
           else if (!strncmp(pSrc, szISAPIDECLARED, sizeof(szISAPIDECLARED) - 1)) {
               pSrc += sizeof(szISAPIDECLARED) - 1;
               WriteBoolean(Buffer, pCGenState->ExportsDbg->UnKnownApi == 0);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szAPISTRINGS, sizeof(szAPISTRINGS) - 1)) {
               pSrc += sizeof(szAPISTRINGS) - 1;
               if (pCGenState->ApiTypes) {
                   ApiStrings(pCGenState);
                   }
               }
           else if (!strncmp(pSrc, szDBGSINDEX, sizeof(szDBGSINDEX) - 1)) {
               char *pExpression, *pFree;
               int Index;

               pSrc += sizeof(szDBGSINDEX) - 1;
               pch = pSrc;
               pSrc = SkipSubExpression(pch, &pFree);

               if (pSrc != pch) {
                   if (!pFree && pCGenState->pArgsList ) {
                       pExpression = pCGenState->pArgsList->Type;
                       }
                   else {
                       pExpression = pFree;
                       }

                   Index = GetFuncIndex(pCGenState, pExpression);
                   if (Index == -1) {
                       ExitErrMsg(FALSE, "DebugsIndex unknown! %s\n", pch);
                       }

                   _itoa(Index, Buffer, 10);
                   pch = Buffer;
                   if (pFree) {
                       GenHeapFree(pFree);
                       }
                   }
               else {
                   pch = NULL;
                   }

               }

           else if (!strncmp(pSrc, szDBGSLIST, sizeof(szDBGSLIST) - 1)) {
               pSrc += sizeof(szDBGSLIST) - 1;
               pSrc = ListDbgs(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSSTRINGS, sizeof(szDBGSSTRINGS) - 1)) {
               pSrc += sizeof(szDBGSSTRINGS) - 1;
               WriteDbgsStrings(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSMORE, sizeof(szDBGSMORE) - 1)) {
               pSrc += sizeof(szDBGSMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szOFFSET, sizeof(szOFFSET) - 1)) {
               pSrc += sizeof(szOFFSET) - 1;
               pSrc = GetOffSet(pSrc, Buffer);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szCPPEXPORT, sizeof(szCPPEXPORT) - 1)) {
               pSrc += sizeof(szCPPEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration
                                );
               }
           else if (!strncmp(pSrc, szCEXPORT, sizeof(szCEXPORT) - 1)) {
               pSrc += sizeof(szCEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                !(iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration)
                                );
               }
           else if (!strncmp(pSrc, szCPPOUTPUT, sizeof(szCPPOUTPUT) - 1)) {
               pSrc += sizeof(szCPPOUTPUT) - 1;
               if (pCGenState->CGen->FileNameCpp != NULL) {
                   pCGenState->CGen->fp = pCGenState->CGen->fpCpp;
                   }
               }
           else if (!strncmp(pSrc, szCOUTPUT, sizeof(szCOUTPUT) - 1)) {
               pSrc += sizeof(szCOUTPUT) - 1;
               pCGenState->CGen->fp = pCGenState->CGen->fpC;
               }
           else if (!strncmp(pSrc, szIF, sizeof(szIF) - 1)) {
               BOOLEAN result;

               pSrc += sizeof(szIF) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result);
               pSrc = WriteMore(pSrc, pCGenState, result );
               ELSE(result);
               }
           else if (!strncmp(pSrc, szELSE, sizeof(szELSE) - 1)) {
               ExitErrMsg ( FALSE, "@Else not immediately following @If" );
               }
           else if (!strncmp(pSrc, szOR, sizeof(szOR) - 1)) {
               BOOLEAN result1, result2;
               pSrc += sizeof(szOR) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 || result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szAND, sizeof(szAND) - 1)) {
               BOOLEAN result1, result2;
               pSrc += sizeof(szAND) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 && result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szNOT, sizeof(szNOT) - 1)) {
               BOOLEAN result1;
               pSrc += sizeof(szNOT) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result1);
               WriteBoolean ( Buffer, !result1);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szISINTFORWARD, sizeof(szISINTFORWARD) - 1)) {
               pSrc += sizeof(szISINTFORWARD) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->IntForward != NULL
                                );

               }
           else if (!strncmp(pSrc, szISNOTINTFORWARD, sizeof(szISNOTINTFORWARD) - 1)) {
               pSrc += sizeof(szISNOTINTFORWARD) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->IntForward == NULL
                                );
               }
           else {
                //
                // See if this is an '@macroname'
                //
                char MacroName[MAX_PATH];
                char *p = MacroName;
                char *pIn = pSrc;
                SIZE_T Bytes;

                while (isalnum(*pIn)) {
                    *p++ = *pIn++;
                }
                *p = '\0';
                if (ExpandMacro(MacroName, pCGenState, &pIn, BufferPos, MaxLen, &Bytes)) {
                   if (OutBuffer != NULL) {
                      Bytes--; // subtract off terminating zero.
                      BufferPos += Bytes;
                      MaxLen -= Bytes;
                      *BytesReturned += Bytes;
                   }
                   pSrc = pIn;
                } else {
                    ExitErrMsg(FALSE, "%s(%d) Unknown keyword '@%s'", TemplateFileName, TemplateLine, MacroName);
                }
            }

           if (pch) {
               if (OutBuffer != NULL) {
                  SIZE_T Bytes;
                  CGenerateEx(pch, pCGenState, BufferPos, MaxLen, &Bytes);
                  Bytes--; // subtract off terminating zero.
                  BufferPos += Bytes;
                  MaxLen -= Bytes;
                  *BytesReturned += Bytes;
               }
               else {
                  while (*pch)
                     pch = CGeneratePrintChar(pch, pCGenState);
               }
           }
      }

   }

   if (OutBuffer != NULL) {
      if(MaxLen == 0) {
         ExitErrMsg(FALSE, "Out of Buffer space!\n");
      }
      *BufferPos = '\0';
      *BytesReturned += 1;
   }

   return pSrc;
}


int GetMemberOffset(char *sTypeName, char *sMemberName)
{
    PKNOWNTYPES pkt = NULL;
    PMEMBERINFO pmi;
    int i;

    //
    // This is the same as running the lexer on a single identifier...
    //
    Tokens[0].TokenType = TK_IDENTIFIER;
    Tokens[0].Name = sTypeName;
    Tokens[1].TokenType = TK_EOS;

    CurrentTokenIndex = 0;
    if (ParseTypes(TypeDefsList, NULL, &pkt) && pkt != NULL) {
        pkt = GetBasicType(pkt->BaseName, TypeDefsList, StructsList);
    } else {
        CurrentTokenIndex = 0;
        ParseTypes(StructsList, NULL, &pkt);
    }

    if (pkt == NULL) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Type %s\n",
               sTypeName
               );
    }

    pmi = pkt->pmeminfo;
    while (pmi) {

        if (!pmi->sName) {
            //
            // Found a nameless member.  See if the member name we're
            // looking for is a member of this nameless member.
            //
            //  ie.  typedef struct { int bar; } FOO;
            //
            //       typedef struct TEST {
            //          union {
            //              int i;
            //              FOO;
            //          }
            //       } test;
            //
            // GetOffset(TEST, bar) will recurse when pmi points
            // at the memberinfo for the nameless member 'FOO'.
            //
            i = GetMemberOffset(pmi->sType, sMemberName);
            if (i != -1) {
                return i;
            }
        } else if (!strcmp(pmi->sName, sMemberName)) {
            return pmi->dwOffset;
        }
        pmi = pmi->pmeminfoNext;
    }
    return -1;
}


char *
GetOffSet(
    char *pSrc,
    char *Buffer
    )
{
    char *pOrg = pSrc;
    char *pch;
    int  Len;
    char TypeName[MAX_PATH];
    char MemberName[MAX_PATH];

    if (*pSrc != '(') {
        ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pSrc);
        return NULL;
        }

    while (IsSeparator(*pSrc)) {
        pSrc = GetNextToken(pSrc);
        if (!*pSrc || *pSrc == ')') {
            ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
            return NULL;
            }
        }

    pch = TypeName;
    Len = sizeof(TypeName)-1;
    while ((*pSrc != ',') && (*pSrc != 0)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", TypeName);
             return NULL;
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';


     while (IsSeparator(*pSrc)) {
         pSrc = GetNextToken(pSrc);
         if (!*pSrc || *pSrc == ')') {
             ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
             return NULL;
             }
         }

    pch = MemberName;
    Len = sizeof(MemberName)-1;
    while (!IsSeparator(*pSrc)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", MemberName);
             return NULL;
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';

    while (*pSrc && *pSrc++ != ')') {
         ;
         }

    Len = GetMemberOffset(TypeName, MemberName);
    if (Len < 0) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Member %s.%s\n",
               TypeName,
               MemberName
               );

        return NULL;
    }

    _ltoa(Len, Buffer, 16);
    return(pSrc);
}






/*
 *  GetRetSize
 *
 */
int GetRetSize(PCGENSTATE pCGenState)
{
    PKNOWNTYPES pkt;
    int RetSize;

    if (!pCGenState->ApiTypes) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** GetRetSize: No Api defined\n\n"
                );
        return -1;
    }

    // Get KnownTypes info for Return Type.  Can't use the ApiTypes->pktRet
    // cache as ParseIndirection() needs the state of the parse.
    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
       CurrentTokenIndex = 0;
       if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {

           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                   pCGenState->ApiTypes->FuncRet
                   );

           return -1;
        }
    }

   if (pCGenState->ApiTypes->RetIndLevel) {
      RetSize = SIZEOFPOINTER;
   } else {
      RetSize = pkt->Size;
   }

   return RetSize;
}

/*
 *  GetArgSize
 *
 */
int GetArgSize(PEXPORTSDEBUG ExportDebug)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   int Total = 0;
   int ArgSize;

   if (IsListEmpty(&ExportDebug->ArgsListHead)) {
       return -1;
       }

   if (ExportDebug->ArgsSize >= 0) {
       return ExportDebug->ArgsSize;
       }

   if (ExportDebug->IntForward && ExportDebug->IntForward->ArgsSize >= 0) {
       ExportDebug->ArgsSize = ExportDebug->IntForward->ArgsSize;
       return ExportDebug->ArgsSize;
       }

   Next = ExportDebug->ArgsListHead.Flink;

   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return 0;
       }

   do {
       pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       ArgSize = (pArgsList->ArgSize + 3) & ~3;
       Total += ArgSize;

       Next= Next->Flink;

     } while (Next != &ExportDebug->ArgsListHead);

   ExportDebug->ArgsSize = Total;

   if (ExportDebug->IntForward) {
       ExportDebug->IntForward->ArgsSize = Total;
       }

   return Total;
}


/*
 *  ApiStrings
 *
 */
void ApiStrings(PCGENSTATE pCGenState)
{
    FILE *fp = pCGenState->CGen->fp;
    PLIST_ENTRY Next;
    PARGSLIST pArgsList;
    PKNOWNTYPES pkt;
    int ArgSize;
    char *pRet;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    //
    // Write the ApiName <"ApiName", ">
    //
    fprintf(fp, "\"%s!%s\", \"", BaseName, pCGenState->ExportsDbg->ExportName);

    //
    // Write out the Args <Arg1 %x, ArgN %x>
    //
    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(fp,
                "\n\t*** ERROR ***\n*** ArgFormat Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );
        return;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    do {
        pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

        // check for void arg list
        if (!pArgsList->Name) {
            break;
        }

        fprintf(fp, "%s %s ",
                pArgsList->pKnownTypes->TypeName,
                pArgsList->Name
                );

        // check for vargs
        if (!strcmp(pArgsList->Name, szVARGS)) {
            break;
        }

        ArgSize = pArgsList->ArgSize;

        while (ArgSize > 0) {
           ArgSize -= sizeof(int);
           fprintf(fp,
                   "%s%s",
                   "%x",
                   ArgSize > 0 ? "." : ""
                   );
        }

        Next= Next->Flink;
        if (Next != &pCGenState->ExportsDbg->ArgsListHead) {
            fputc(',', fp);
        }

    } while (Next != &pCGenState->ExportsDbg->ArgsListHead);

    //
    // Write out Return Type <", "RetType %x">
    //
    pRet = pCGenState->ApiTypes->FuncRet;
    fprintf(fp, "\", \"%s ", pRet);

    ResetLexer();
    LexMacroArgs(pRet);
    ConsumeConstVolatileOpt();

       // Get Known Types for size of Return Type
    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {

            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                    pCGenState->ApiTypes->FuncRet
                    );
            return;
        }
    }

    ArgSize = pkt->Size;
    ParseIndirection(NULL, &ArgSize, NULL, NULL, NULL);

    while (ArgSize > 0) {
        ArgSize -= sizeof(int);
        fprintf(fp,
                "%s%s",
                "%x",
                ArgSize > 0 ? "." : ""
                );
    }

    fprintf(fp, "\"");
}






char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen)
{

     PLIST_ENTRY pFirstEntry;
     PARGSLIST pArgsList;

     if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
         return "NULL";
         }

     pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
     pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
     if (!pArgsList->Name) {
         return "NULL";
         }

     Buffer[0] = '&';
     BuffLen--;

     if ((int)strlen(pArgsList->Name) > BuffLen) {
         ExitErrMsg(TRUE, "gafa: Overflow %s\n", pArgsList->Name);
         }

     strcpy(&Buffer[1], pArgsList->Name);

     return Buffer;
}



/*
 *  IfArgs
 *
 */
char *IfArgs(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY pFirstEntry;
   PKNOWNTYPES pkt;

   *pfResult = TRUE;

      // skip empty list,
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       *pfResult = FALSE;
       }

      // check for void arg list
   else {
      pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
      pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
      if (!pArgsList->Name) {
          pkt = GetNameFromTypesList(TypeDefsList, pArgsList->Type);
          if (!pkt) {
              pkt = GetNameFromTypesList(StructsList, pArgsList->Type);
              }
          if (!pkt) {
              ExitErrMsg(FALSE,
                         "ifArgs: Unknown Type %s\n",
                         pArgsList->Type
                         );
              }

          if (!pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
              *pfResult = FALSE;
              }
          }
      }

   return WriteMore(pSrc,pCGenState, *pfResult);
}

/*
 *  DoesApiReturnVoid
 *
 */
char *DoesApiReturnVoid(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult)
{
    PKNOWNTYPES pkt;

    *pfResult = FALSE;

    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {
            *pfResult = TRUE;
        }
    }

    if (!*pfResult && CurrentToken()->TokenType != TK_STAR &&
        !pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
        *pfResult = TRUE;
    }

    return pSrc;
}


/*
 *  IfApiRet
 *
 */
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult)
{
    pSrc = DoesApiReturnVoid(pSrc, pCGenState, pfResult);
    *pfResult = !*pfResult;
    pSrc = WriteMore(pSrc, pCGenState, *pfResult);
    return pSrc;
}

char *
IfApiCode(
    char *pSrc,
    PCGENSTATE pCGenState,
    BOOL * pfResult
    )
/*++

Routine Description:

    Expands an EFunc's codeburst, if it exists.  ie. @IfApiCode(foo) will
    expand to the 'foo=' section of the current EFunc, if the current EFunc
    has a 'foo='.  Otherwise, there is no expansion.

Arguments:

    pSrc        - pointer to character following '@IfApiCode'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pch;
    char *pEnd;
    size_t  Len;
    int CodeBurstIndex;
    char CodeName[MAX_PATH];
    char *CodeBurst;

    *pfResult = FALSE;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    pch = pSrc+1;
    if (IsSeparator(*pch)) {
        return pSrc;
    }

    pSrc = pch;
    while (!IsSeparator(*pch)) {
        pch++;
    }
    Len = pch - pSrc;

    // Copy name to a buffer and null-terminate
    memcpy(CodeName, pSrc, Len);
    CodeName[Len] = '\0';

    CodeBurstIndex = GetExistingCodeBurstIndex(CodeName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", CodeName);
    }

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // There is an [Efunc] with a non-empty codeburst for this API.
            // Generate its codeburst.
            //
            *pfResult = TRUE;
            CGenerate(CodeBurst, pCGenState);
        }
    }

    return pEnd;
}


/*
 *  CheckFastCallArgs
 *
 */
BOOLEAN
FastCallArgs(
    PLIST_ENTRY ArgsListHead,
    int ArgLimit,
    BOOL fCheckTypes,
    BOOL fCheckFirstArgType
    )
{
   PARGSLIST pArgsList;
   PTEMPLES pTypeTemple;
   PKNOWNTYPES pktTemple;
   int NumArgs, ArgSize;
   PLIST_ENTRY Next, NextTemple;

   if (IsListEmpty(ArgsListHead)) {
       return FALSE;
       }


   Next = ArgsListHead->Flink;

   // check for void arg list, or vargs as first arg
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name) {
       return strcmp(pArgsList->Type, szVARGS) ? TRUE : FALSE;
       }

   NumArgs = 0;
   while (Next != ArgsListHead) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

       //
       // Cannot have more than 4 args
       //

       if (++NumArgs > ArgLimit) {
           return FALSE;
           }


       //
       // arg size must be dword or less
       //

       ArgSize = (pArgsList->ArgSize + 3) & ~3;

       if (ArgSize < 0 || ArgSize > 4) {
           return FALSE;
           }

       //
       // vargs of any indlevel aren't allowed
       //

       if (!strcmp(pArgsList->pKnownTypes->BaseName, szVARGS)) {
           return FALSE;
           }

       //
       // floats of Zero IndLevel aren't allowed
       //

       if (pArgsList->IndLevel == 0 &&
           !strcmp(pArgsList->pKnownTypes->BaseName, szFLOAT))
          {
           return FALSE;
           }


       //
       // type templates are not allowed except for the first arg in methods
       //

       if ((fCheckTypes) &&
           ((NumArgs != 1) ||
           ((NumArgs == 1) && fCheckFirstArgType))) {
           NextTemple = TypeTempleList.Flink;
           while (NextTemple != &TypeTempleList) {
               pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);


               //
               // get the Known types info for each type template.
               //

               pktTemple = pTypeTemple->pktType;
               if (!pktTemple) {

                   //
                   // Don't have the Known types info yet, fetch it
                   // and save it in the TypeTemplate
                   //

                   pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                                );
                   if (!pktTemple) {
                       pktTemple = GetNameFromTypesList(StructsList,
                                                        pTypeTemple->Name
                                                    );
                       }

                   pTypeTemple->pktType = pktTemple;
                   }

               if (!pktTemple) {
                   ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
                   }


               //
               // See if arg matches this type template
               //

               if (IsSameType(pArgsList->pKnownTypes,
                              pArgsList->IndLevel,
                              TK_NONE,
                              pTypeTemple->Name,
                              pTypeTemple->IndLevel + pktTemple->IndLevel,
                              TK_NONE,
                              TRUE
                              ))
                  {
                   return FALSE;
                  }

               NextTemple = NextTemple->Flink;
               }
           }
           Next= Next->Flink;
       }


   return TRUE;
}


BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
)
{
     if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

     //
     // If first time, determine if Api can be a fastcall.
     // tri state flag, where:
     //    -1 == Cannot be a fastcall
     //    0  == undetermined
     //    1  == Can be a fastcall
     //

     if (!pCGenState->ExportsDbg->FastCall) {
         int Size;

         pCGenState->ExportsDbg->FastCall = -1; // assume not a fastcall

         //
         // Fast call criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. 0 to 4 params
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         if (!pCGenState->ExTemplate && !pCGenState->ExportsDbg->CplusDecoration) {
             Size =  GetRetSize(pCGenState);
             if (Size >= 0 && Size <= 4 &&
                 !GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) &&
                 FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, 4, TRUE, TRUE))
                {
                 pCGenState->ExportsDbg->FastCall = 1;
                 }
             }
         }

     return pCGenState->ExportsDbg->FastCall == 1;
}

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     )
{
    int RetSize;

         //
         // Fast X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAXX2NPARAMETERS
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template, except for this pointer
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         //
         // Slow X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAX2NPARAMETERS
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Must not be in the EFastTemplate list
         // 7. Must not have a C++ linkage
         //

         // Fat X2N methods are neither Slow X2N methods or Fast X2N methods


    if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

    if (pCGenState->ExportsDbg->X2NMethodType == UNKNOWNMETHOD) {

        RetSize = GetRetSize(pCGenState);
        if (pCGenState->ExTemplate ||
            pCGenState->ExportsDbg->CplusDecoration ||
            GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) ||
            (RetSize > 4) || (RetSize < 0)) {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, TRUE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = FASTX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, FALSE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = SLOWX2NMETHOD;
            }
        else {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        }

    return(pCGenState->ExportsDbg->X2NMethodType);
}

/*
 *  IfRetType
 *
 */
char *IfRetType(char *pSrc, PCGENSTATE pCGenState, BOOL * pfResult)
{
   char *pch;

   *pfResult = FALSE;

   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       *pfResult = ( ! strncmp(pch, pCGenState->ApiTypes->FuncRet,
                                strlen( pCGenState->ApiTypes->FuncRet)));
   }
   pSrc = GetNextToken(pch);

   pch = WriteMore(pSrc ,pCGenState, *pfResult);

   return(pch);
}

/*
 *  IfNotRetType
 *
 */
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState)
{
   char *pch;
   BOOL bMore = FALSE;

   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       bMore = (strncmp( pch, pCGenState->ApiTypes->FuncRet, strlen( pCGenState->ApiTypes->FuncRet ) ) != 0);
   }
   pSrc = GetNextToken(pch);

   pch = WriteMore(pSrc ,pCGenState, bMore);

   return(pch);
}

BOOL
ExpandType(
   PCGENSTATE pCGenState,
   PKNOWNTYPES pkt,
   PLIST_ENTRY pTempleList,
   int CodeBurstIndex
   )
{

   PARGSLIST pArgsList;
   PKNOWNTYPES pktTemple;
   int tplIndLevel;
   PLIST_ENTRY NextTemple;
   PTEMPLES pTypeTemple;
   int i;

   pArgsList = pCGenState->pArgsList;

   i=2;
   while (i--) {
       NextTemple = pTempleList->Flink;
       while (NextTemple != pTempleList) {
           pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);

           tplIndLevel = pTypeTemple->IndLevel;
           pktTemple = pTypeTemple->pktType;
           if (!pktTemple) {
               pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                               );
               if (!pktTemple) {
                   pktTemple = GetNameFromTypesList(StructsList,
                                                    pTypeTemple->Name
                                                   );
               }
               pTypeTemple->pktType = pktTemple;
           }


           if (!pktTemple) {
               ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
           }

           tplIndLevel += pktTemple->IndLevel;

           if (IsSameType(pkt,
                          pArgsList->IndLevel,
                          pArgsList->tkDirection,
                          pTypeTemple->Name,
                          tplIndLevel,
                          pTypeTemple->tkDirection,
                          i == 0
                          )) {
                DbgPrintf("ttpl: MEMBER %s.%s Type=%s IndLevel=%d\n",
                          pCGenState->ApiTypes->FuncRet,
                          pTypeTemple->Name,
                          pTypeTemple->Name,
                          pTypeTemple->IndLevel
                         );

               if(ExpandTemple(pTypeTemple, CodeBurstIndex, pCGenState)){
                   return TRUE;
               }
           }

       NextTemple = NextTemple->Flink;
       }

   }

   return FALSE;

}

BOOL IsInNoType(PCHAR *NoTypes, PMEMBERINFO pmi) {
    SIZE_T NoTypeCount;
    if (NoTypes == NULL || pmi->sName == NULL) {
       return FALSE;
    }
    for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {
        if (!NoTypes[NoTypeCount]) {
            return FALSE;
        }
        else {
           if (strcmp(pmi->sName, NoTypes[NoTypeCount]) == 0) {
              return TRUE;
           }
        }
    }
    return FALSE;
}

SIZE_T CountNoTypes(PCHAR *NoTypes) {
   SIZE_T Count = 0;
   if (NoTypes == NULL) {
      return 0;
   }
   while(*NoTypes++ != NULL) {
      Count++;
   }
   return Count;
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT);

void ExpandMemberType( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{
    char *sName;
    char *sNameNew;
    char *sHostCastedName;
    int Len, HostCastedNameLen;
    PKNOWNTYPES pkt;
    BOOL bAddCast = TRUE;
    char Type[MAX_PATH];
    PARGSLIST pArgsListTemp;

    // Determine if this member should be expanded by checking for a NoType entry.
    if (pmi->sName != NULL) {
       if(IsInNoType(CGenState.CurrentTemple->NoTypes, pmi) ||
          IsInNoType(CGenState.MemberNoType, pmi)) {
          goto NextMember;
       }
    }

    // Get the pkt for the member type
    if ( pmi->pktCache )
    {
        pkt = pmi->pktCache;
    }
    else
    {
        ResetLexer();
        LexMacroArgs(pmi->sType);
        ConsumeConstVolatileOpt();

        if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE)
        {
            CurrentTokenIndex = 0;
            if ( ParseTypes( StructsList, NULL, &pkt ) == FALSE )
            {
                fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - unknown type\n", CGenState.Temple->Comment,
                    pszStructName, pmi->sType );

                goto NextMember;
            }
        }
        pmi->pktCache = pkt;
    }

    if ( pktStruct == pkt )
    {
        //
        // Rats!  The structure contains a member which is a pointer
        // with the same type as this structure.  ie.  this struct
        // is self-referential.  We can't expand it as the expansion
        // is recursive.
        //
        fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - self-referencing structure\n", CGenState.Temple->Comment,
            pszStructName, pmi->sType );

        goto NextMember;
    }

    // Build the new names.
    sName = pmi->sName;

    // This is a type without a name. No casting is needed.
    if (pktStruct->Flags & BTI_ANONYMOUS) {

       if (sName == NULL) {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + 1);
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcpy(sNameNew, pszStructName);
       }

       else {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sNameNew, pszStructName);
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);
       }

    }
    else {

       pArgsListTemp = CGenState.pArgsList;
       CGenState.pArgsList = pArgsListOld;
       if (IsPointer(&CGenState)) {
           ArgTypeInd(Type, &CGenState, TRUE);
           strcat(Type, " *");
       }
       else {
           ArgHostType(Type, &CGenState);
       }

       if (CGenState.pArgsList->bIsBitfield ||
               (CGenState.pArgsList->IndLevel == 0 &&
                CGenState.pArgsList->pKnownTypes->IndLevel == 0 &&
                  (strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "struct") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "enum") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "union") == 0)
                  )

           ) {
           bAddCast = FALSE;
       }
       else {
           bAddCast = TRUE;
       }

       CGenState.pArgsList = pArgsListTemp;

       HostCastedNameLen = strlen(pszHostCastedStructName) + strlen(Type) + 8;

       Len = strlen(pszStructName) + 1;

       if (sName != NULL) {
          HostCastedNameLen += strlen(pMemReference) + strlen(sName);
          Len += strlen(pMemReference) + strlen(sName);

       }

       if (Len >= MAX_PATH || HostCastedNameLen >= MAX_PATH) {
           fprintf( fpLog,
                    "%s *** WARNING *** Member %s->%s skipped - name is too long\n",
                    CGenState.Temple->Comment,
                    pszStructName,
                    pmi->sType
                  );
           goto NextMember;

       }

       sHostCastedName = CheckHeapAlloc(HostCastedNameLen);
       sHostCastedName[0] = '\0';

       if (bAddCast) {
           strcpy(sHostCastedName, "((");
           strcat(sHostCastedName, Type);
           strcat(sHostCastedName, ")(");
           strcat(sHostCastedName, pszHostCastedStructName);
           strcat(sHostCastedName, "))");
       }
       else {
           strcat(sHostCastedName, pszHostCastedStructName);
       }

       if(sName != NULL) {
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
       }

       sNameNew = CheckHeapAlloc(Len);
       strcpy(sNameNew, pszStructName);

       if(sName != NULL) {
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);
       }

    }

    pArgsList->pKnownTypes = pkt;
    pArgsList->ArgSize = pkt->Size;
    pArgsList->IsPtr64 = pmi->bIsPtr64;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = pmi->IndLevel;
    // pArgsList->tkDirection is same as the original arg
    pArgsList->Type = pmi->sType;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = sNameNew;
    pArgsList->ArgLocal = sNameNew;
    pArgsList->HostCastedName = sHostCastedName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = pmi->bIsBitfield;
    pArgsList->BitsRequired= pmi->BitsRequired;
    pArgsList->bIsArray    = pmi->bIsArray;
    pArgsList->ArrayElements=pmi->ArrayElements;
    pArgsList->fRequiresThunk = ((pkt->Flags & BTI_CONTAINSFUNCPTR) != 0);

    if (sName != NULL) {
       CGenState.MemberNoType = NULL;
       ExpandType(&CGenState, pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);
    }
    else {

       // This field is a nameless field in a structure or union.
       // Example:
       //     struct foobar {
       //         int x;
       //     };
       //     struct foobar2 {
       //         struct foobar;
       //         int y;
       //     };
       // foobar2 will import all the fields of foobar.
       //
       // When walking down the structure, we want to continue expanding foobar when we reach the nameless field.

       SIZE_T NumNoTypes1, NumNoTypes2;
       PCHAR *NewNoTypes;

       NumNoTypes1 = CountNoTypes(CGenState.MemberNoType);
       NumNoTypes2 = CountNoTypes(CGenState.CurrentTemple->NoTypes);
       if (NumNoTypes1 + NumNoTypes2 + 1 > MAX_NOTYPE) {
          ExitErrMsg(FALSE, "ExpandMemberType: too many notypes.\n");
       }
       NewNoTypes = CheckHeapAlloc((NumNoTypes1 + NumNoTypes2 + 1)*sizeof(PCHAR));

       memcpy(NewNoTypes, CGenState.MemberNoType, NumNoTypes1 * sizeof(PCHAR));
       memcpy(NewNoTypes + NumNoTypes1, CGenState.CurrentTemple->NoTypes, NumNoTypes2 * sizeof(PCHAR));
       NewNoTypes[NumNoTypes1 + NumNoTypes2] = NULL;
       CGenState.MemberNoType = NewNoTypes;
       pMemberTypes( &CGenState, CodeBurstIndex, pMemReference, bBtoT);
       GenHeapFree(NewNoTypes);
    }

    GenHeapFree(sNameNew);
    GenHeapFree(sHostCastedName);

NextMember:;
}

void ExpandMemberTypesBackwards( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{
    if ( pmi->pmeminfoNext != NULL )
    {
        ExpandMemberTypesBackwards( pmi->pmeminfoNext, CGenState, CodeBurstIndex, pktStruct,
            pszStructName, pszHostCastedStructName, pArgsList, fpLog,
            pArgsListOld, pMemReference, bBtoT);
    }

    ExpandMemberType( pmi, CGenState, CodeBurstIndex, pktStruct,
        pszStructName, pszHostCastedStructName, pArgsList, fpLog,
        pArgsListOld, pMemReference, bBtoT);
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT)
{
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    ARGSLIST ArgsListOld;
    PMEMBERINFO pmi;

    pCGen = CheckHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);

    InitializeListHead(&pCGen->CGenerateEntry);

    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    pkt = pCGenState->pArgsList->pKnownTypes;
    while(pkt->pTypedefBase != NULL) {
       pkt = pkt->pTypedefBase;
    }
    pCGenState->pArgsList->pStructType = pkt;

    // Save the old ARGSLIST away
    ArgsListOld = *(pCGenState->pArgsList);

    // get a ptr to the member list for the struct
    pmi = pkt->pmeminfo;
    if ( !pmi )
    {
        ExitErrMsg(FALSE, "Type '%s' is not a struct", pCGenState->pArgsList->Type);
    }

    if(strcmp(pkt->BasicType, "union") == 0) {
        PMEMBERINFO pmiTemp;
        // check if any of the members of this union are in the notype list.
        for (pmiTemp = pkt->pmeminfo; pmiTemp != NULL; pmiTemp = pmiTemp->pmeminfoNext) {
           if (IsInNoType(pCGenState->MemberNoType, pmiTemp) ||
               IsInNoType(pCGenState->CurrentTemple->NoTypes, pmiTemp)) {
               //A member of the union is in the notype list, skip union.
               goto done;
           }
        }
    }

    // loop over each member variable within the type
    if ( bBtoT )
    {
        do
        {
            ExpandMemberType( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name,
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
            pmi = pmi->pmeminfoNext;
        }
        while ( pmi != NULL );
    }
    else
    {
        ExpandMemberTypesBackwards( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name,
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
    }

done:
    // Restore the old ARGSLIST
    *pCGenState->pArgsList = ArgsListOld;
    GenHeapFree(pCGen);
}

char* MemberTypes( char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT)
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    char MemReference[MAX_PATH];

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs < 1 || pMArgsList->NumArgs > 2) {
       ExitErrMsg(FALSE, "MemberTypes: 1 or 2 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    //handle optional member reference symbol
    if (pMArgsList->NumArgs == 2) {
       CGenerateEx(pMArgsList->ArgText[1], pCGenState, MemReference, MAX_PATH, &BytesReturned);
    }
    else {
       strcpy(MemReference, "->");
    }

    pMemberTypes(pCGenState, CodeBurstIndex, MemReference, bBtoT);
    FreeMacroArgsList(pMArgsList);
    return pEnd;
}

char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState)
{
    char *pEnd;
    char *pch;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    char BurstName[MAX_PATH];
    char ArgName[MAX_PATH];
    char ArgHostName[MAX_PATH];
    char TypeName[MAX_PATH];
    char Direction[MAX_PATH];
    int CodeBurstIndex;
    PARGSLIST pArgsList;
    ARGSLIST ArgsListOld;
    ARGSLIST ArgsListNew;
    TOKENTYPE tkDirection;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;
    BOOL bHasArgsList=FALSE;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 5) {
       ExitErrMsg(FALSE, "ForceTypeExpand: 5 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "mt: %s\n", pSrc);
    }

    CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[2], pCGenState, ArgHostName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[3], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[4], pCGenState, Direction, MAX_PATH, &BytesReturned);

    // Parse the direction
    if(strcmp(Direction, "IN OUT") == 0) {
       tkDirection = TK_INOUT;
    }
    else if (strcmp(Direction, "IN") == 0) {
       tkDirection = TK_IN;
    }
    else if (strcmp(Direction, "OUT") == 0) {
       tkDirection = TK_OUT;
    }
    else if (strcmp(Direction, "none") == 0) {
       tkDirection = TK_NONE;
    }
    else {
       ExitErrMsg(FALSE, "FORCETYPE: Unknown direction %s\n", Direction);
       return NULL;
    }

    InitializeListHead(&pCGen->CGenerateEntry);

    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    // Save the old ARGSLIST away
    pArgsList = pCGenState->pArgsList;
    if (pArgsList == NULL) {
       CGenState.pArgsList = &ArgsListNew;
       pArgsList = &ArgsListOld;
       *pArgsList = *(PARGSLIST)pCGenState->ExportsDbg->ArgsListHead.Flink;
    }
    else {
       ArgsListOld = *pArgsList;
       bHasArgsList = TRUE;
    }

    pArgsList->pKnownTypes = NULL;
    pArgsList->ArgSize = 0;
    pArgsList->IsPtr64 = FALSE;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = 0;
    pArgsList->tkDirection = tkDirection;
    pArgsList->Type = TypeName;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = ArgName;
    pArgsList->ArgLocal = ArgName;
    pArgsList->HostCastedName = ArgHostName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = FALSE;
    pArgsList->BitsRequired= FALSE;
    pArgsList->bIsArray    = FALSE;
    pArgsList->ArrayElements=0;
    pArgsList->fRequiresThunk = FALSE;

    SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
    ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);

    // Restore the old ARGSLIST
    if (bHasArgsList) {
        *pCGenState->pArgsList = ArgsListOld;
    }
    else {
         pCGenState->pArgsList = NULL;
    }
    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);
    return pEnd;
}

char *
IncludeRetType(
    char *pSrc,
    PCGENSTATE pCGenState
    )
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    int i;
    int tplIndLevel;
    PTEMPLES pTypeTemple;
    PKNOWNTYPES pktTemple;
    PLIST_ENTRY NextTemple;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    char *CodeBurst;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "it: %s\n", pSrc);
    }

    InitializeListHead(&pCGen->CGenerateEntry);

    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // The [EFunc] template for this API has a return-type codeburst.
            // That is expanded in lieu of a [Types] template.
            //
            CGenerate(CodeBurst, &CGenState);
            return pEnd;
        }
    }

    pkt = pCGenState->ApiTypes->pktRet;
    pkt = pCGenState->ApiTypes->pktRet;
    i=2;
    while (i--) {
        for (NextTemple = TypeTempleList.Flink ; NextTemple != &TypeTempleList ; NextTemple = NextTemple->Flink) {

            pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);
            tplIndLevel = pTypeTemple->IndLevel;
            pktTemple = pTypeTemple->pktType;
            if (!pktTemple) {
                pktTemple = GetNameFromTypesList(TypeDefsList,
                                                 pTypeTemple->Name
                                                );
                if (!pktTemple) {
                    pktTemple = GetNameFromTypesList(StructsList,
                                                     pTypeTemple->Name
                                                    );
                }
                pTypeTemple->pktType = pktTemple;
            }

            if (!pktTemple) {
                if (bIgnorePrototypeError) {
                    /*
                    fprintf(pCGenState->CGen->fp,
                            "%s Error:3 Ignoring type %s\n",
                            pCGenState->Temple->Comment,
                            pTypeTemple->Name
                            );
                    */
                    continue;
                }
                else {
                    ExitErrMsg(FALSE,
                               "Temple: Type not found %s\n",
                               pTypeTemple->Name
                               );
                }
            }

            tplIndLevel += pktTemple->IndLevel;

            if (IsSameType(pkt,
                           pCGenState->ApiTypes->RetIndLevel,
                           TK_NONE,
                           pTypeTemple->Name,
                           tplIndLevel,
                           TK_NONE,
                           i == 0
                           )) {
                 DbgPrintf("ttpl: RETURN %s.%s Type=%s IndLevel=%d\n",
                           CGenState.ApiTypes->FuncRet,
                           pTypeTemple->Name,
                           pTypeTemple->Name,
                           pTypeTemple->IndLevel
                          );

                if (pTypeTemple->CodeBurst[CodeBurstIndex]) {
                    pSrc = pTypeTemple->CodeBurst[CodeBurstIndex];
                    while (*pSrc && !isgraph(*pSrc)) {
                        pSrc++;
                    }
                    if (*pSrc) {
                        CGenerate(pSrc, &CGenState);
                    }
                }
                i = 0;
                break;  // break from while loop over all templates
            }
        }

    }

    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);

    return pEnd;
}

VOID
SetArgListToTypeForArg(
    PARGSLIST pArgsList,
    PARGSLIST pArgsListOld,
    char * pTypeName
    )
{
   int IndLevel = 0;
   char TypeNameCopy[MAX_PATH];
   PKNOWNTYPES pkt;
   char *p;
   BOOL bIsTypedef = TRUE;

   *pArgsList = *pArgsListOld;
   p = pTypeName;
   strcpy(TypeNameCopy, p);
   p = TypeNameCopy;

   while(*p != '\0') {
      if (*p == '*') {
         IndLevel++;
         *p = ' ';
      }
      p++;
   }

   ResetLexer();
   LexMacroArgs(TypeNameCopy);
   ConsumeConstVolatileOpt();

   if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        bIsTypedef = FALSE;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
            ExitErrMsg(FALSE, "SetArgListToType: %s is not a valid type\n", TypeNameCopy);
        }
   }

   pArgsList->pKnownTypes = pkt;
   pArgsList->pStructType = NULL;
   //DWORD        ArgSize;            // size of this arg (should be unchanged)
   pArgsList->IsPtr64 = (IndLevel == 0 && (pkt->Flags & BTI_PTR64));
   //BOOL         IsPtr64;            // TRUE if this arg is __ptr64 (should be unchanged)
   //int          OffSet;             // offset from stack for this arg(should be unchanged)
   pArgsList->IndLevel = IndLevel;
   //TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT(should be unchanged)
   //TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)(should be unchanged)

   if (!bIsTypedef) {
      if (strcmp(pkt->BasicType, szSTRUCT) == 0) {
         pArgsList->SUEOpt = TK_STRUCT;
      } else if (strcmp(pkt->BasicType, szUNION) == 0) {
         pArgsList->SUEOpt = TK_UNION;
      } else if (strcmp(pkt->BasicType, szENUM) == 0) {
         pArgsList->SUEOpt = TK_ENUM;
      } else {
         pArgsList->SUEOpt = TK_NONE;
      }
   }

  pArgsList->Type = pkt->TypeName;
   //TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   //TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   //char          *Name;              // argument name (may be a nonameX)
   //char         *ArgLocal;          // name of local var containing copy of arg
   //char         *HostCastedName;    // Contains full name of struct member with
                                    // host casts or NULL
  pArgsList->fRequiresThunk = pkt->Flags & BTI_CONTAINSFUNCPTR;
  pArgsList->fNoType = FALSE;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   //BOOL         fIsMember;          // This arg is actually a member of an array
   //BOOL         bIsBitfield;        // Determines if this is a bitfield
   //int          BitsRequired;       // Number of bits required for bitfield
   //BOOL         bIsArray;           // This member is an array
   //int          ArrayElements;      // Number of elements in the array

}



BOOL
ExpandTypesForApi(
    PLIST_ENTRY ArgsListHead,
    PCGENSTATE CGenState,
    PLIST_ENTRY pTypesList,
    int CodeBurstIndex,
    BOOL bExpandAll,
    BOOL bRtoL
    )
{
   PKNOWNTYPES pktArgs;
   PLIST_ENTRY NextArg;
   BOOL fKeepGoing = TRUE;

   //
   // For each argument process a type template if any.
   //

   if ( bRtoL )
   {
      NextArg = &CGenState->ExportsDbg->ArgsListHead;
      NextArg = NextArg->Blink;
   }
   else
   {
      NextArg = ArgsListHead;
   }

   do
   {
       CGenState->pArgsList = CONTAINING_RECORD(NextArg,ARGSLIST,ArgumentsEntry);

        if (CGenState->pArgsList->fNoType) {
            //
            // This arg is listed in this API's [EFunc] NoTypes list.
            // Do not expand [Types] templates for it.
            //
            goto NextArg;
        }


       ResetLexer();
       LexMacroArgs(CGenState->pArgsList->Type);
       ConsumeConstVolatileOpt();

        // Get KnownTypes info for Argument
        if (ParseTypes(TypeDefsList, NULL, &pktArgs) == FALSE) {
            CurrentTokenIndex = 0;
            if (ParseTypes(StructsList, NULL, &pktArgs) == FALSE ) {
                ErrMsg(
                      "Args: Type not found %s %s\n",
                       CGenState->pArgsList->Type,
                       CGenState->ApiTypes->TypeName
                       );
               return fKeepGoing;
            }
        }

        fKeepGoing = !ExpandType(CGenState, CGenState->pArgsList->pKnownTypes,
                                 pTypesList, CodeBurstIndex);
        fKeepGoing = fKeepGoing | bExpandAll;

NextArg:
      if ( bRtoL )
      {
         if ( NextArg == ArgsListHead )
         {
             break;
         }

         NextArg = NextArg->Blink;
      }
      else
      {
         NextArg = NextArg->Flink;

         if ( NextArg == &CGenState->ExportsDbg->ArgsListHead )
         {
            break;
         }
      }

   } while (fKeepGoing);

   return fKeepGoing;
}

/*
 *  IncludeTypes
 *
 */
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL)
{
   char *pEnd;
   char *pch;
   PCGENERATE pCGen;
   CGENSTATE CGenState;
   PARGSLIST pArgsList;
   PLIST_ENTRY NextArg;
   char BurstName[MAX_PATH];
   PMACROARGSLIST pMArgsList = NULL;
   SIZE_T BytesReturned;
   int CodeBurstIndex;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   //
   // Functions must have an argument list (at least void)
   //
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n IncludeTypes Missing argument List: %s\n",
               pCGenState->ApiTypes->TypeName
               );

       return pEnd;
       }


   //
   // If void arg list, nothing to do!
   //
   NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
   pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return pEnd;
       }

   ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

   if (pMArgsList->NumArgs < 1) {
      ExitErrMsg(FALSE, "IncludeTypes: CodeBurst name required\n");
   }

   CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
   CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
   if (CodeBurstIndex == -1) {
       ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
   }

   pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);

   pCGen->fp = pCGenState->CGen->fp;
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

   CGenState = *pCGenState;
   CGenState.CGen = pCGen;

   if (pMArgsList->NumArgs >= 2) {
      char ArgName[MAX_PATH];
      char TypeName[MAX_PATH];
      char CastedArgName[MAX_PATH];
      size_t ArgNameLen;
      size_t ArgTypeLen;
      char *p;
      BOOL bHasType = FALSE;

      //extract arg name to expand types for
      CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
      if (BytesReturned == 0) {
         ExitErrMsg(FALSE, "IncludeTypes: Empty arg name is not allowed.\n");
      }
      ArgNameLen = BytesReturned - 1;

      if (pMArgsList->NumArgs == 3) {

         //extract the type name
         CGenerateEx(pMArgsList->ArgText[2], pCGenState, TypeName, MAX_PATH, &BytesReturned);
         if (BytesReturned == 0) {
            ExitErrMsg(FALSE, "IncludeTypes: Empty type name is not allowed.\n");
         }

         ArgTypeLen = BytesReturned - 1;
         bHasType = TRUE;

         if (ArgTypeLen + ArgNameLen + 4 >= MAX_PATH) {
            ExitErrMsg(FALSE, "ArgType + ArgName is too long\n");
         }

         memcpy(CastedArgName, "((", 2);
         p = CastedArgName + 2;
         memcpy(p, TypeName, ArgTypeLen);
         p += ArgTypeLen;
         memcpy(p, ")", 1);
         p++;
         memcpy(p, ArgName, ArgNameLen);
         p += ArgNameLen;
         memcpy(p, ")", 2);

      }

      else {
         ExitErrMsg(FALSE, "IncludeTypes: Too many arguments\n");
      }

      //Find arg in the arglist.
      do {

        pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
        if (pArgsList->Name != NULL) {
           if (strcmp(pArgsList->Name, ArgName) == 0) {
              //Expand this argument

              if (bHasType) {
                 CGenState.pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
                 if(NULL == CGenState.pArgsList)
                    ExitErrMsg(FALSE, "IncludeTypes: out of memory.\n");
                 SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
                 CGenState.pArgsList->Name = CastedArgName;
              }
              else {
                 CGenState.pArgsList = pArgsList;
              }

              if (!ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &FailTempleList, CodeBurstIndex))
                 ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);

              if (bHasType) {
                 GenHeapFree(CGenState.pArgsList);
              }

              GenHeapFree(pCGen);
              FreeMacroArgsList(pMArgsList);
              return pEnd;
           }
        }

        NextArg = NextArg->Flink;
      } while (NextArg != &CGenState.ExportsDbg->ArgsListHead);
      ExitErrMsg(FALSE, "IncludeTypes: %s is not a known argument for %s\n", ArgName, pCGenState->ExportsDbg->ExportName);

   }
   else {
      if (ExpandTypesForApi(NextArg,
                            &CGenState,
                            &FailTempleList,
                            CodeBurstIndex,
                            FALSE,
                            bRtoL)) {

         ExpandTypesForApi(NextArg,
                            &CGenState,
                            &TypeTempleList,
                            CodeBurstIndex,
                            TRUE,
                            bRtoL);
      }
   }

   GenHeapFree(pCGen);
   FreeMacroArgsList(pMArgsList);
   return pEnd;
}




/*
 *   IsSameType
 *
 */
PKNOWNTYPES
IsSameType(
    PKNOWNTYPES pktArgs,
    int IndLevel,
    TOKENTYPE tkArgDirection,
    char *tplTypeName,
    int tplIndLevel,
    TOKENTYPE tkTypeDirection,
    BOOL bScanBaseTypes
    )
{

    if (*tplTypeName != '*' && strcmp(tplTypeName, "default") != 0 &&
        IndLevel + pktArgs->IndLevel != tplIndLevel) {
        //
        // Not a generic '*' or 'default' types template, and levels of indirection
        // don't match
        //
        return NULL;
    }

    if (!bUseDirection) {
        tkArgDirection = TK_NONE;
    }
    if (tkTypeDirection != TK_EOS && tkArgDirection != tkTypeDirection) {
        //
        // Direction-sensitivity enabled, type template isn't generic to
        // all directions, and IN, OUT, IN/OUT don't match
        //
        return NULL;
    }

    if (!strcmp(pktArgs->TypeName, tplTypeName)) {
        //
        // type names match
        //
        return pktArgs;
    }

    if (bScanBaseTypes) {
        PKNOWNTYPES pkt;

        if (strcmp(tplTypeName, "struct") == 0 &&
            strcmp(pktArgs->BasicType, "struct") == 0) {
            //
            // This matches a generic 'struct' template.
            //
            return pktArgs;
        }

        if (strcmp(tplTypeName, "union") == 0 &&
            strcmp(pktArgs->BasicType, "union") == 0) {
            //
            // This matches a generic 'union' template.
            //
            return pktArgs;
        }

        if (*tplTypeName == '*' && IndLevel+pktArgs->IndLevel) {
            //
            // The template is a generic pointer template, and the arg type
            // is a pointer to something.  Match.
            //
            return pktArgs;
        }

        if (!strcmp(pktArgs->BaseName, pktArgs->TypeName)) {
           //
            // Base name of the arg type matches this arg type, no
            // possiblity of a match.
            //
            pkt = NULL;
            goto try_default;
        }

        //
        // Get the knowntype for basetype of the arg
        //
        if (pktArgs->pktBase) {
            // the knowntype is already cached
            pkt = pktArgs->pktBase;
        } else {
            pkt = GetNameFromTypesList(TypeDefsList, pktArgs->BaseName);
            if (!pkt) {
                pkt = GetNameFromTypesList(StructsList, pktArgs->BaseName);
            }
            if (!pkt) {
                goto try_default;
            }
            pktArgs->pktBase = pkt;
        }

        IndLevel += pktArgs->IndLevel - pkt->IndLevel;

        pkt = IsSameType(pkt,
                         IndLevel,
                         tkArgDirection,
                         tplTypeName,
                         tplIndLevel,
                         tkTypeDirection,
                         TRUE
                         );

        if (NULL == pkt) {
try_default:
            // The default type template matches everything
            if (strcmp(tplTypeName, "default") == 0) {
               //printf("Applying default template to %s\n", pktArgs->TypeName);
               return pktArgs;
            }
        }

        return pkt;

    }

    return NULL;
}



/*
 * GetAltExportName
 *
 * Fetches the forward name if one exists, returns NULL if none.
 *
 */
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len)
{
   PEXPORTSDEBUG pExportDebug;
   int i;

   pExportDebug = pCGenState->ExportsDbg;

   if (pExportDebug->ExtForward) {
       i = _snprintf(Buffer, Len, "=%s", pExportDebug->ExtForward);
       }
   else if (pExportDebug->IntForward) {
       if (bNoFuzzyLogic && !strchr(pExportDebug->IntForward->ExportName, '@')) {

           i = _snprintf(Buffer, Len, "=%s%s@%d",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName,
                         GetArgSize(pExportDebug)
                         );
           }
       else {
           i = _snprintf(Buffer, Len, "=%s%s",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName
                         );
           }
       }
   else if (bNoFuzzyLogic &&
            !strchr(pExportDebug->ExportName, '@') &&
            !strstr(pCGenState->ApiTypes->FuncMod, "cdecl"))
      {
       i = _snprintf(Buffer, Len, "=%s@%d",
                     pExportDebug->ExportName,
                     GetArgSize(pExportDebug)
                     );
       }
   else {
       return NULL;
       }


   if (i < 0) {
       ExitErrMsg(FALSE,
                  "GetAltExportName: Overflow %s\n",
                  pExportDebug->ExportName
                  );
       }

   return Buffer;

}



/*
 *  IncludeTemplate
 *
 */
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState)
{
   char *pEnd;
   char *pch;
   size_t  Len;
   PCGENERATE pCGen;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   pch = pSrc + 1;
   if (IsSeparator(*pch)) {
       return pSrc;
       }

   pSrc = pch;
   while (!IsSeparator(*pch)) {
      pch++;
      }
   Len = pch - pSrc;

   pCGen = GenHeapAlloc(Len + 1 + sizeof(CGENERATE));
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);
   pCGen->fp = pCGenState->CGen->fp;
   pCGen->fpC = pCGenState->CGen->fpC;
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   memcpy(pCGen->TempleName, pSrc, Len);
   *(pCGen->TempleName + Len) = '\0';

   memset(&CGenState, 0, sizeof(CGENSTATE));
   CGenState.CGen = pCGen;

   CGenState.ExportsDbg = pCGenState->ExportsDbg;
   CGenState.DebugStrings = pCGenState->DebugStrings;
   CGenState.ApiTypes = pCGenState->ApiTypes;
   CGenState.ApiNum = pCGenState->ApiNum;
   CGenState.pArgsList = pCGenState->pArgsList;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.MoreApis = pCGenState->MoreApis;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   ProcessTemple(&CGenState);

   GenHeapFree(pCGen);
   return pEnd;
}



/*
 *  WriteMore
 */
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore)
{
   char *pch;
   char *pExpression = 0;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, bMore ? &pExpression : NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pSrc = pch;

   if (!bMore || !pExpression) {
       return pSrc;
       }

   CGenState = *pCGenState;
   CGenerate(pExpression, &CGenState);

   GenHeapFree(pExpression);
   return pSrc;
}




/*
 *  WriteArgLocal
 */
BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pch;
   int i, Len;

   if (pCGenState->pArgsList->ArgLocal) {
       ErrMsg("Type Template error multiple ArgLocals\n");
       return FALSE;
       }

   // format the local var name
   Len = _snprintf(Buffer, BuffLen, "%s", pCGenState->pArgsList->Name);
   if (Len <= 0) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   // alloc space for the local var name, and stash it away
   pCGenState->pArgsList->ArgLocal = GenHeapAlloc(Len + 1);
   if (!pCGenState->pArgsList->ArgLocal) {
        ErrMsg("GenHeapAlloc(ArgLocal) %s\n", pCGenState->pArgsList->Name);
        return FALSE;
        }
   strcpy(pCGenState->pArgsList->ArgLocal, Buffer);

   //
   // format the declarator statement: "ArgType IndLevel *ArgName"
   //

   pch = Buffer;
   i = strlen(pCGenState->pArgsList->Type) +
       strlen(TokenString[pCGenState->pArgsList->SUEOpt]) + 1;
   if (i >= BuffLen) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
       strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
       strcat(pch, " ");
       strcat(pch, pCGenState->pArgsList->Type);
   } else {
       strcpy(pch, pCGenState->pArgsList->Type);
   }
   if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
       strcat(pch, " ");
       strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
   }
   i = strlen(pch);
   Len = BuffLen - i - 1;
   pch += i;

   i = pCGenState->pArgsList->IndLevel;
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

    if (i) {
        *pch++ = ' ';
        while (i) {
            *pch++ = '*';
            i--;
        }
    }
   *pch++ = ' ';

   i = strlen(pCGenState->pArgsList->ArgLocal);
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   strcpy(pch, pCGenState->pArgsList->ArgLocal);

   //
   // Record that some kind of exception template has been used
   // during generation of this argument.
   //
   pCGenState->pArgsList->fRequiresThunk = FALSE;

   return TRUE;
}




/*
 *  WriteArgAddr
 */
char *
WriteArgAddr(
       char *pSrc,
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pEnd;
   char *pch;
   size_t Len;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   Len = --pch - ++pSrc;

   if (Len + 32 >= (size_t)BuffLen) {
       ExitErrMsg(FALSE,
                  "WriteArgAddr buffer overflow %s\n",
                  pSrc
                  );
       }

   while (pSrc < pch) {
      *Buffer++ = *pSrc++;
      }

   *Buffer++ = ' ';
   *Buffer++ = '+';
   *Buffer++ = ' ';

   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);

   return pEnd;
}



BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    )
/*++

Routine Description:

    Determines if a template has no codebursts at all or not.

Arguments:

    pTemple     - template to examine

Return Value:

    TRUE if template has no codebursts, FALSE if there is at least one.

--*/
{
    int i;

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (pTemple->CodeBurst[i]) {
            return FALSE;
        }
    }

    return TRUE;
}


/*
 *  ListApis
 */
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;
   PTEMPLES pTemple;
   BYTE ApiPlatform;
   BOOL ExcludedApi;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.MoreApis = TRUE;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   Next = ExportsList.Flink;
   while (Next != &ExportsList) {
       CGenState.ExportsDbg = CONTAINING_RECORD(Next,
                                                EXPORTSDEBUG,
                                                ExportsDbgEntry
                                                );

       Next= Next->Flink;
       if (Next == &ExportsList) {
           CGenState.MoreApis = FALSE;
           }

       //
       // Switch this API in or out depending on the platform info
       //
       ApiPlatform = CGenState.ExportsDbg->ApiPlatform;
       PlatformSwitchStart(&CGenState, ApiPlatform);

       CGenState.ApiTypes = GetApiTypes(CGenState.ExportsDbg);

       pTemple = GetTemplate(&EFuncTempleList,
                             CGenState.ExportsDbg->ExportName
                             );



       ExcludedApi = FALSE;

           // skip this api if ex template, but no code
       if (!bExports && pTemple && TempleHasNoCodeBursts(pTemple)) {
      ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Api %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          //
          // skip this api if:
          // - external forward reference
          // - internal forward which does not define the function.
          //   (exportname != forwardname)
          //
       else if (!bExports &&
                (CGenState.ExportsDbg->ExtForward ||
                 (CGenState.ExportsDbg->IntForward &&
                  CGenState.ExportsDbg->IntForward != CGenState.ExportsDbg)))
          {
            ExcludedApi = TRUE;
            fprintf(pCGenState->CGen->fp,
                     "%s %s forwarded to %s\n",
                    CGenState.Temple->Comment,
                    CGenState.ExportsDbg->ExportName,
                    CGenState.ExportsDbg->ExtForward
                       ? CGenState.ExportsDbg->ExtForward
                       : CGenState.ExportsDbg->IntForward->ExportName
                    );

            }


          // skip this api if DATA and no ex template
       else if (!pTemple && CGenState.ExportsDbg->Data) {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Data Export %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          // skip this api if CPP export and we aren't setup for CPP exports,
       else if (!pTemple && !iHandleCpp && CGenState.ExportsDbg->CplusDecoration)
         {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluding CPP Api: %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

           // skip this api if members are unknown
       else if (!CGenState.ApiTypes->pfuncinfo) {
           ExcludedApi = TRUE;
                    // members unknown - skip the API
                    if (bIgnorePrototypeError)
                    {
                        fprintf(pCGenState->CGen->fp,
                                "%s Error:4 Ignoring Api %s\n",
                                 CGenState.Temple->Comment,
                                 CGenState.ExportsDbg->ExportName
                        );

                    }
                    else {
                        ExitErrMsg(FALSE,
                                   "API %s has no function prototype - unable to generate code.",
                                   CGenState.ExportsDbg->ExportName
                                   );
                    }
           }

           // gen code for this api
       else {

           if (pTemple) {
               CGenState.ExTemplate= TRUE;
               }
           else {
               CGenState.ExTemplate= FALSE;
               }

           BuildArgsList(pTemple,
                         CGenState.ApiTypes->pfuncinfo,
                         &CGenState.ExportsDbg->ArgsListHead
                         );


           if (GetArgSize(CGenState.ExportsDbg) < 0) {
          ExcludedApi = TRUE;
                    // members unknown - skip the API
                    if (bIgnorePrototypeError)
                    {
                        fprintf(pCGenState->CGen->fp,
                                "%s Error:5 Ignoring Api %s\n",
                                CGenState.Temple->Comment,
                                CGenState.ExportsDbg->ExportName
                        );

                    }
                    else {
                        ExitErrMsg(FALSE,
                                   "API %s has no function prototype - unable to generate code.",
                                   CGenState.ExportsDbg->ExportName
                                   );
                    }
               }
           else {
               CGenerate(pExpression, &CGenState);

               if (bExports) {
                    //
                    // we're generating the .DEF file.   Mark some APIs
                    // as private so the linker doesn't warn us.
                    //
                    if (strcmp(CGenState.ExportsDbg->ExportName,
                               "DllGetClassObject") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllCanUnloadNow") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServer") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServerEx") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllInstall") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllUnregisterServer") == 0) {

                        fprintf(pCGenState->CGen->fp, " PRIVATE");
                    }

               }
               CGenState.ApiNum++;
               }
           }

       if (bExports)
    PlatformSwitchEnd(&CGenState, ApiPlatform);
       else{
    if (ExcludedApi)
      PlatformSwitchEnd(&CGenState, ApiPlatform);
    else
      PlatformSwitchEndTable(&CGenState, ApiPlatform);
       }

       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


PKNOWNTYPES
BuildFakeTypesInfo(
    PEXPORTSDEBUG pExportsDbg,
    PKNOWNTYPES pKnownTypes
    )
{
   TYPESINFO ti;
   int ArgsSize, i;
   size_t Len;
   PFUNCINFO funcinfo;
   char *pch;

   memset(&ti, 0, sizeof(TYPESINFO));
   strcpy(ti.TypeName, pExportsDbg->ExportName);

   if (pKnownTypes) {
       strcpy(ti.BasicType, pKnownTypes->BasicType);
       strcpy(ti.BaseName, pKnownTypes->BaseName);
       strcpy(ti.FuncRet, pKnownTypes->FuncRet);
       strcpy(ti.FuncMod, pKnownTypes->FuncMod);

       pExportsDbg->UnKnownApi = -1; // incomplete fn declaration

       /*
        *  WARNING:
        *  The type is added to the FakeFuncsList with args
        *  info from the dll symbols. The type is NOT removed
        *  from the FuncsList.
        */

       }
   else {
       strcpy(ti.BasicType, szFUNC);
       strcpy(ti.FuncRet, szINT);

       pExportsDbg->UnKnownApi = 1;  // missing fn declaration
       }

   ArgsSize = pExportsDbg->ArgsSize;

   if (!ArgsSize) {
       ti.TypeKind = TypeKindFunc;
       ti.dwMemberSize = sizeof(FUNCINFO) + strlen(szVOID) + 1;
       ti.pfuncinfo = (PFUNCINFO)ti.Members;
       pch = ti.Members + sizeof(FUNCINFO);
       strcpy(pch, szVOID);
       ti.pfuncinfo->sType = pch;
       }
   else if (ArgsSize < 0) {
       ;
       }
   else {
       ti.TypeKind = TypeKindFunc;
       pch = ti.Members + sizeof(FUNCINFO);
       Len = sizeof(ti.Members) - 1 - sizeof(FUNCINFO);
       funcinfo = (PFUNCINFO)ti.Members;
       ti.pfuncinfo = funcinfo;
       while (ArgsSize && Len) {
           ti.dwMemberSize+=sizeof(FUNCINFO);
           i = _snprintf(pch, Len, "Fake%x", ArgsSize);
           if (i < 0) {
               return NULL;
               }
           i++;
           Len -= i;
           funcinfo->sName = pch;
           pch += i;
           ti.dwMemberSize+=i;
           strcpy(pch, szINT);
           funcinfo->sType = pch;
           i = strlen(szINT) + 1;
           pch += i;
           ti.dwMemberSize+=i;
           ArgsSize -= sizeof(int);

           if (ArgsSize) {
               PFUNCINFO funcinfoNext;
               INT_PTR Realignment;

               //
               // Allocate space for another FUNCINFO, ensuring that
               // it is DWORD-aligned.
               //
               Len -= sizeof(FUNCINFO);
               Realignment = 4 - ((INT_PTR)pch & 3);
               Len -= Realignment;
               funcinfoNext = (PFUNCINFO)(pch + Realignment);
               pch += sizeof(FUNCINFO)+Realignment;
               ti.dwMemberSize += (DWORD)Realignment;
               if ((INT_PTR)Len < 0) {
                   return NULL;
                   }
               funcinfo->pfuncinfoNext = funcinfoNext;
               funcinfo = funcinfoNext;
               }
           }
       }

   return AddToTypesList(&FakeFuncsList, &ti);
}

/*
 *  GetFuncArgNum
 */
int GetFuncArgNum(PCGENSTATE pCGenState)
{
   PARGSLIST pArgsList;
   PKNOWNTYPES pkt;
   int NumArgs;
   PFUNCINFO funcinfo;

   pArgsList = pCGenState->pArgsList;

   if (!pArgsList) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum Missing argument List\n\n"
               );

       return -1;
       }

   pkt = pArgsList->pKnownTypes;
   while (!pkt->Members || !pkt->pfuncinfo) {
       if (pkt->pktBase) {
           // the knowntype is already cached
           pkt = pkt->pktBase;
       } else {
           PKNOWNTYPES pktOrg = pkt;
           pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
           if (!pkt) {
               if (pArgsList->pKnownTypes) {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERROR ***\n*** GetFuncArgNum BaseType Not found:<%s:%s>\n\n",
                           pArgsList->pKnownTypes->TypeName,
                           pArgsList->pKnownTypes->BasicType
                           );
               } else {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERRR ***\n*** GetFuncArgNum BaseType Not found: no KnownTypes\n\n"
                          );
                   }
               return -1;
               }
            pktOrg->pktBase = pkt;
       }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }

   funcinfo = pkt->pfuncinfo;
   if (!pkt->Members || !funcinfo) {
       fprintf(pCGenState->CGen->fp,
               "/*** WARN gfan No Members:<%s:%s> ***/ ",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );

       return 0;
   }

   //
   //  "..." vargs is nonsense can't do it!
   //
   if (strcmp(funcinfo->sType, szVARGS) == 0) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum variable Args:<%s:%s>\n\n",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );
       return -1;
   }

   //
   //  void arg list, Zero Args
   //
   if (strcmp(funcinfo->sType, szVOID) == 0) {
       return 0;
   }

   NumArgs = 0;
   do {
       NumArgs++;
       funcinfo = funcinfo->pfuncinfoNext;
   } while(funcinfo);

   return NumArgs;
}



/*
 *  GetFuncIndex
 */
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName)
{
   PKNOWNTYPES pkt, pktFunc;
   int  Len, LenExpr, LenArgs, LenRet;
   char *pch;
   char Args[1024];
   PFUNCINFO funcinfo;
   PDEBUGSTRINGS DebugStrings;

   if (!FuncTypeName || !*FuncTypeName) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex TypeName Not specified\n\n"
               );
       return -1;
       }

   pkt = GetNameFromTypesList(TypeDefsList, FuncTypeName);
   if (!pkt) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex Type Not found:<%s>\n\n",
               FuncTypeName
               );
       return -1;
       }

   pktFunc = pkt;
   while (!pkt->Members || !pkt->pfuncinfo) {
       // NOTE: we cannot look at pkt->pktBase as it may point to a struct
       //       knowntype instead of a typedef
       pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
       if (!pkt) {
           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetFuncIndex BaseType Not found:<%s:%s>\n\n",
                   FuncTypeName,
                   pktFunc->BaseName
                   );
           return -1;
           }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }


   LenArgs = 1;
   Args[0] = '\0';

   funcinfo = pkt->pfuncinfo;
   if (pkt->Members && funcinfo) {

        //
        //  "..." vargs is nonsense can't do it!
        //
        if (strcmp(funcinfo->sType, szVARGS) == 0) {
            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetFuncIndex variable Args:<%s:%s>\n\n",
                    FuncTypeName,
                    pkt->BasicType
                    );
            return -1;
        }

        //
        //  void arg list means no args
        //
        if (strcmp(funcinfo->sType, szVOID) != 0) {
            pch = Args;
            do {
                //
                // Copy in the typename
                //
                Len = strlen(funcinfo->sType);
                LenArgs += Len;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                strcpy(pch, funcinfo->sType);
                pch += Len;

                //
                // Copy in the levels of indirection
                //
                LenArgs += funcinfo->IndLevel;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                for (Len = 0; Len<funcinfo->IndLevel; ++Len) {
                    *pch++ = '*';
                }

                //
                // Copy in the argument name, if present
                //
                if (funcinfo->sName) {
                    Len = strlen(funcinfo->sName) + 1;
                    LenArgs += Len;
                    if (LenArgs >= sizeof(Args)-3) {
                        break;
                    }
                    *pch = ' ';
                    strcpy(pch+1, funcinfo->sName);
                    pch += Len;
                }

                //
                // Copy in the printf-style formatting for this argument
                //
                LenArgs += 3;
                *pch++ = ' ';
                *pch++ = '%';
                *pch++ = 'x';
                funcinfo = funcinfo->pfuncinfoNext;
                if (funcinfo) {
                    LenArgs+=2;
                    *pch++ = ',';
                    *pch++ = ' ';
                }
            } while (funcinfo);

           if (LenArgs >= sizeof(Args)-5) {
               ExitErrMsg(FALSE,
                          "GetFuncIndex overflow %s.%s\n",
                          FuncTypeName,
                          pkt->Members
                          );
               }
           }

           //
           // Null-terminate the Args[] string.
           //
           Args[LenArgs-1] = '\0';
       }



   LenExpr = strlen(FuncTypeName) + 1;
   LenRet = strlen(pkt->FuncRet) + 4;

   DebugStrings = GenHeapAlloc(LenExpr + LenRet + LenArgs + sizeof(DEBUGSTRINGS));
   if (!DebugStrings) {
       ExitErrMsg(TRUE,
                  "GetFuncIndex: GenHeapAlloc(DebugStrings) %s.%s\n",
                  FuncTypeName,
                  pkt->Members
                  );
       }

   Len = 0;
   DebugStrings->Name = DebugStrings->Buffer;
   strcpy(DebugStrings->Name, FuncTypeName);
   Len += LenExpr;

   DebugStrings->ArgFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->ArgFormat, Args);
   Len += LenArgs;

   DebugStrings->RetFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->RetFormat, pkt->FuncRet);
   strcat(DebugStrings->RetFormat, " %x");
   Len += LenRet;

   InsertTailList(&DebugStringsList, &DebugStrings->DebugStringsEntry);

   return NumDebugStringsEntries++;
}




/*
 *  WriteDbgsStrings
 *
 */
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState)
{
    DEBUGSTRINGS DebugStrings;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    if (!pCGenState->DebugStrings) {
        pCGenState->DebugStrings = &DebugStrings;
        DebugStrings.Name =
        DebugStrings.ArgFormat =
        DebugStrings.RetFormat = "";
        }

    fprintf(pCGenState->CGen->fp,
            "\"%s!%s\",\"%s\",\"%s\"",
            BaseName,
            pCGenState->DebugStrings->Name,
            pCGenState->DebugStrings->ArgFormat,
            pCGenState->DebugStrings->RetFormat
            );
}


/*
 *  ListDbgs
 */
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.ListCol = pCGenState->ListCol;

   if (!IsListEmpty(&DebugStringsList)) {
       Next = DebugStringsList.Flink;
       while (Next != &DebugStringsList) {
           CGenState.DebugStrings = CONTAINING_RECORD(Next,
                                                      DEBUGSTRINGS,
                                                      DebugStringsEntry
                                                      );

           Next= Next->Flink;
           CGenState.MoreApis = (Next != &DebugStringsList) ? TRUE : FALSE;
           CGenerate(pExpression, &CGenState);
           if (CGenState.ListCol) {
               WriteListColumn(&CGenState);
               }
           }
       }
   else {
       CGenState.MoreApis = FALSE;
       CGenerate(pExpression, &CGenState);
       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


/*
 *  ListArgs
 */
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch;
   char *pExpression;
   CGENSTATE CGenState;

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** ListArgs Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return SkipSubExpression(pSrc, NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

   // check for void arg list
   if (!Always) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
       if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
           return SkipSubExpression(pSrc, NULL);
           }
       }

   CGenState = *pCGenState;
   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   do {
       CGenState.pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       CGenerate(pExpression, &CGenState);

       if (!g_fLessTrailingWhitespace || Next->Flink != &CGenState.ExportsDbg->ArgsListHead)
           if (CGenState.ListCol) {
              WriteListColumn(&CGenState);
              }

       Next= Next->Flink;

     } while (Next != &CGenState.ExportsDbg->ArgsListHead);


   GenHeapFree(pExpression);
   return pSrc;
}



/*
 *  WriteListColumn
 */
void WriteListColumn(PCGENSTATE pCGenState)
{
    int Len;
    FILE *fp = pCGenState->CGen->fp;

    OutputColumn = pCGenState->ListCol;
    Len =  OutputColumn - 1;

    if (fputc('\n', fp) != '\n') {
        ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
        return;
        }
    while (Len--) {
        if (fputc(' ', fp) != ' ') {
            ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
            }
        }


}




/*
 *  SkipSubExpression
 *
 */
char *SkipSubExpression(char *pSrc, char **pSubExpression)
{
   char *pOrg = pSrc;
   char *pSave;
   int  Len = 0;
   int ParenLevel;

   if ((*pSrc != '(') && (*pSrc != ',')) {
       return pOrg;
       }

   pSrc++;

   pSave = pSrc;
   ParenLevel = 1;
   Len = 0;

   while (*pSrc) {
       if (*pSrc == '(') {
           ParenLevel++;
           }
       else if (*pSrc == ')') {
           ParenLevel--;
           }

       pSrc++;

       if (!ParenLevel) {
           break;
           }

       Len++;
       }


   if (pSubExpression) {
       if (Len) {
           *pSubExpression = GenHeapAlloc(Len + 1);
           if (!*pSubExpression) {
               ExitErrMsg(TRUE, "GenHeapAlloc(SubExpression) %s\n", pOrg);
               }
           if (Len) {
               memcpy(*pSubExpression, pSave, Len);
               }
           *(*pSubExpression + Len) = '\0';
           }
       else {
           *pSubExpression = NULL;
           }
       }

   return pSrc;
}






/*
 *  GetTemplate
 */
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName)
{
   PTEMPLES ptpl;
   PLIST_ENTRY Next;

   Next = pHeadList->Flink;
   while (Next != pHeadList) {
      ptpl = CONTAINING_RECORD(Next, TEMPLES, TempleEntry);
      if (!strcmp(ptpl->Name, TempleName)) {
          return ptpl;
          }
      Next= Next->Flink;
      }

   return NULL;
}


void
UseLogMacros(char *LogName)
{
    DWORD Len;
    char FullLogName[MAX_PATH+1];
    char *LogBaseName;

    Len = GetFullPathName(LogName,
                          sizeof(FullLogName) - 1,
                          FullLogName,
                          &LogBaseName
                          );
    if (Len == 0 || Len >= sizeof(FullLogName) - 1) {
        ExitErrMsg(TRUE, "Could not fully-qualify log filename '%s'\n", LogName);
    }

    fpLog = fopen(FullLogName, "w");
    if (!fpLog) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FullLogName);
    }
    if (!AddOpenFile(FullLogName, fpLog, NULL)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }
}


char *
UpdateLog(
    char *pSrc,
    PCGENSTATE pCGenState
    )
{
    FILE *fpOld;
    BOOL bMore;

    if (fpLog) {
        fpOld = pCGenState->CGen->fp;
        pCGenState->CGen->fp = fpLog;
        bMore = TRUE;
    } else {
        fpOld = NULL;
        bMore = FALSE;
    }

    pSrc = WriteMore(pSrc,pCGenState,bMore);

    if (bMore) {
        pCGenState->CGen->fp = fpOld;
        fprintf(fpLog, "\n");
    }

    return pSrc;
}



/*
 *  ExtractCGenerate
 */
BOOL ExtractCGenerate(char *pNames)
{
   FILE *fp=NULL, *fpCpp=NULL;
   size_t Len;
   DWORD SizeFileName, SizeTempleName;
   DWORD SizeFileNameCpp = 0;
   char *pch;
   char *pchColon, *pchComma;
   PCGENERATE pCGen;
   char *OutputBaseNameCpp = 0;
   char FullOutputNameCpp[MAX_PATH+1];
   char *OutputBaseName;
   char FullOutputName[MAX_PATH+1];
   char OutputName[MAX_PATH+1];
   char OutputNameCpp[MAX_PATH+1];
   char TempleName[MAX_PATH];



   DbgPrintf("CGenerate: %s\n", pNames);

   pchComma = strchr(pNames, ',');
   pchColon = strchr(pNames, ':');

   if (pchComma != NULL) {
       pch = pchComma;
       }
   else {
       pch = pchColon;
       }
   Len = pch - pNames;
   if (!pch || !Len || Len >= sizeof(OutputName) - 1) {
       return FALSE;
       }
   strncpy(OutputName, pNames, Len);
   *(OutputName + Len) = '\0';

   //
   // Extract the CPP filename, and initialize iHandleCPP
   //

   OutputNameCpp[0] = '\0';
   if (pchComma) {
       size_t LenCpp;

       LenCpp = pchColon - ++pchComma;
       if (LenCpp >= sizeof(OutputNameCpp) - 1) {
           return(FALSE);
           }

       if (LenCpp) {
           iHandleCpp = 1;      // use CPP macros
           strncpy(OutputNameCpp, pchComma, LenCpp);
           *(OutputNameCpp + LenCpp) = '\0';
           }
       else {
           iHandleCpp = -1;     // ignore CPP macros, and don't warn
           }

       Len += LenCpp + 1;

       }

   pNames += Len;
   if (*pNames != ':') {  // no template name!
       return FALSE;
       }

   Len = GetFullPathName(OutputName,
                         sizeof(FullOutputName) - 1,
                         FullOutputName,
                         &OutputBaseName
                         );
   if (Len >= sizeof(FullOutputName) - 1) {
       return FALSE;
       }

   SizeFileName = Len + 1;

   fp = fopen(FullOutputName, "w");
   if (!fp) {
       ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputName);
       }
   if (!AddOpenFile(FullOutputName, fp, NULL)) {
       ExitErrMsg(FALSE, "AddOpenFile failed\n");
       }
   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExtractCGenerate: fseek to 0 failed\n");
   }


   //
   // Open the CPP file name
   //

   //if (iHandleCpp > 0) {
   if (OutputNameCpp[0]) {

       Len = GetFullPathName(OutputNameCpp,
                             sizeof(FullOutputNameCpp) - 1,
                             FullOutputNameCpp,
                             &OutputBaseNameCpp
                             );
       if (!Len || (Len >= sizeof(FullOutputNameCpp) - 1)) {
           return FALSE;
           }

       SizeFileNameCpp = Len + 1;

       fpCpp = fopen(FullOutputNameCpp, "w");
       if (!fpCpp) {
           ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputNameCpp);
           }
       if (!AddOpenFile(FullOutputNameCpp, fpCpp, NULL)) {
           ExitErrMsg(FALSE, "AddOpenFile failed\n");
           }

       if (fseek(fpCpp, 0, SEEK_SET)) {
           ExitErrMsg(TRUE, "ExtractCGenerate fseek #2 to 0 failed\n");
       }

       }

   pch = GetNextToken(pNames);
   if (pch == pNames || !*pch) {
       return FALSE;
       }

   Len = CopyToken(TempleName, pch, sizeof(TempleName) - 1);
   if (!Len || Len >= sizeof(TempleName) - 1) {
       return FALSE;
       }

   SizeTempleName = Len + 1;

   Len = sizeof(CGENERATE) + 1;
   Len += SizeFileName + SizeTempleName + SizeFileNameCpp;
   pCGen = GenHeapAlloc(Len);
   if (!pCGen) {
       ExitErrMsg(TRUE, "GenHeapAlloc(CGENERATE)");
       }
   memset(pCGen, 0, Len);

   if (bDebug) {
       setvbuf(fp, NULL, _IONBF, 0);
       }

   pCGen->fp = fp;
   pCGen->fpC = fp;
   strcpy(pCGen->TempleName, TempleName);
   pCGen->FileNameC = pCGen->TempleName + SizeTempleName;
   pCGen->FileBaseNameC = pCGen->FileNameC;
   pCGen->FileBaseNameC += OutputBaseName - FullOutputName;
   strcpy(pCGen->FileNameC, FullOutputName);


   //
   // Save the CPP filename, and file handle.
   //

   if (iHandleCpp > 0 && OutputNameCpp[0]) {
       if (bDebug) {
           setvbuf(fpCpp, NULL, _IONBF, 0);
           }
       pCGen->fpCpp = fpCpp;
       pCGen->FileNameCpp = pCGen->FileNameC + SizeFileName;
       pCGen->FileBaseNameCpp = pCGen->FileNameCpp;
       pCGen->FileBaseNameCpp += OutputBaseNameCpp - FullOutputNameCpp;
       strcpy(pCGen->FileNameCpp, FullOutputNameCpp);
       }

   InsertTailList(&CGenerateList, &pCGen->CGenerateEntry);

   return TRUE;
}



/*
 *  ExtractTemples
 *
 */
BOOL ExtractTemples(char *FileName)
{
    FILE *fp;
    int  FileSize;
    BOOL bRet = FALSE;
    char *pSrc;
    char *pch;
    size_t  Len;
    int  CGenLen;
    LPSTR pCCode[MAX_CODEBURST];
    char Comment[MAX_PATH];
    char IndLevel[MAX_PATH];
    char TempleType[MAX_PATH];
    char TempleName[MAX_PATH];
    char CodeBurstName[MAX_PATH];
    LPSTR Also[MAX_ALSO];
    int AlsoCount;
    LPSTR NoType[MAX_NOTYPE];
    int NoTypeCount;
    PLIST_ENTRY pCaseList;
    char Line[1024];
    int  CodeBurstIndex;
    TOKENTYPE tkDirection;
    PTEMPLES tpl;
    BOOL fFreeCCode = TRUE;
    int i;


    DbgPrintf("Template: %s\n", FileName);

    fp = fopen(FileName, "r");
    if (!fp) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FileName);
    }
    if (fseek(fp, 0, SEEK_END)) {
        ExitErrMsg(TRUE, "fseek to EOF failed\n");
    }
    FileSize = ftell(fp);
    if (fseek(fp, 0, SEEK_SET)) {
        ExitErrMsg(TRUE, "fseek to 0 failed\n");
    }

    // Record the filename/line number information for error messages
    TemplateFileName = FileName;
    TemplateLine = 1;

    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ExitErrMsg(TRUE, "Failed to get Types from %s\n", FileName);

        } else if (feof(fp)) {
            ExitErrMsg(TRUE, "Premature EOF %s\n", FileName);
        }
    }

    // reset the TempleType:  no [TempleType] is active
    *TempleType = '\0';

    // reset all variables used within a [TempleType]
    CGenLen = 0;
    *IndLevel = 0;
    *TempleName = '\0';
    strcpy(Comment, "//");
    memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
    tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
    AlsoCount=0;
    NoTypeCount=0;
    pCaseList = NULL;

    // loop over all lines in the template file
    do {
        pSrc = Line;

        // skip whitespace at the start of the line
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }

        // if at end-of-line or encountered ';'  (comment-to-EOL), go to
        // next line.
        if (!*pSrc || *pSrc == ';') {
            goto GetNextLine;
        }

        if (*pSrc == '[') {
            // encountered new [TempleType].  If there was a previous template,
            // add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            strcpy(Comment, "//");
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;

            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // set up the new TempleType
            pSrc++;
            Len = CopyToken(TempleType, pSrc, sizeof(TempleType) - 1);
            if (Len >= sizeof(TempleType) - 1) {
                goto ETPLExit;
            }
            pch = pSrc + Len;
            if (*pch != ']') {
                *TempleType = '\0';
            }
            goto GetNextLine;
        }

        // if no active [TempleType], ignore the line
        if (!*TempleType) {
            goto GetNextLine;
        }

        // a [TempleType] is active.  Scan for known property names
        if ( ((pch = SkipKeyWord(pSrc, szTEMPLENAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szMACRONAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szTYPENAME)) != pSrc)
             && *pch == '=') {

            // found:       TemplateName=
            //           or MacroName=
            //           or TypeName=
            // They all mean the same thing.

            // If a template is outstanding, add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;
            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // copy in the new TemplateName
            pch = GetNextToken(pch);
            Len = sizeof(TempleName) - 1;
            pSrc = TempleName;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }
            if (Len == 0) {
                // name too long
                goto ETPLExit;
            }
            *pSrc = '\0';

        } else if ((pch = SkipKeyWord(pSrc, szCOMMENT)) != pSrc &&
                   *pch == '=') {

            // found:   Comment=
            pch = GetNextToken(pch);
            Len = sizeof(Comment) - 1;
            pSrc = Comment;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }

            *pSrc = '\0';

        } else if ( ((pch = SkipKeyWord(pSrc, szINDLEVEL)) != pSrc ||
                     (pch = SkipKeyWord(pSrc, szNUMARGS)) != pSrc)
                    && *pch == '=') {

            // Found:       IndLevel=
            //           or NumArgs=
            // They mean the same thing
            pch = GetNextToken(pch);
            if (IsSeparator(*pch)) {
                goto ETPLExit;
            }
            pSrc = pch;
            Len = CopyToken(IndLevel, pSrc, sizeof(IndLevel) - 1);
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szDIRECTION)) != pSrc &&
                *pch == '=') {
            pch++;
            // Found:   Direction=
            if (strncmp(pch, "IN OUT", 6) == 0) {
                tkDirection = TK_INOUT;
                pch += 6;
            } else if (strncmp(pch, "IN", 2) == 0) {
                tkDirection = TK_IN;
                pch += 2;
            } else if (strncmp(pch, "OUT", 3) == 0) {
                tkDirection = TK_OUT;
                pch += 3;
            } else if (strncmp(pch, "none", 4) == 0) {
                // this allows a type template to explicitly catch
                // all pointer types which have no IN/OUT modifiers.
                tkDirection = TK_NONE;
                pch+=4;
            } else {
                goto ETPLExit;
            }

        } else if ((pch = SkipKeyWord(pSrc, szUSE)) != pSrc &&
                *pch == '=') {
            PLIST_ENTRY pHeadList;
            char buffer[MAX_PATH];

            // Found: Use=
            pch++;
            pHeadList = ListFromTempleType(TempleType);
            if (!pHeadList) {
                ExitErrMsg(FALSE, "%s(%d) Use= can only be used after a [Temple]\n", TemplateFileName, TemplateLine);
            }
            Len = CopyToken(buffer, pch, sizeof(buffer));
            tpl = GetTemplate(pHeadList, buffer);
            if (!tpl) {
                ExitErrMsg(FALSE, "%s(%d) Use=%s: Template not found\n", TemplateFileName, TemplateLine, pch);
            }

            // copy the template back to our locals
            strcpy(Comment, tpl->Comment);
            sprintf(IndLevel, "%d", tpl->IndLevel);
            tkDirection = tpl->tkDirection;
            memcpy(pCCode, tpl->CodeBurst, sizeof(LPSTR)*MAX_CODEBURST);
            fFreeCCode = FALSE; // Don't GenHeapFree() the pCCode array
                                // after adding this temple.
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szNOTYPE)) != pSrc &&
                *pch == '=') {
            char *t;

            if (AlsoCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both NoType= and Also= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the NoType= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (NoTypeCount == MAX_NOTYPE) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d NoType= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            NoType[NoTypeCount++] = t;

            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szCASE)) != pSrc &&
                *pch == '=') {
            char *t;
            PMACROARGSLIST pMArgsList = NULL;
            PMLLISTENTRY pMLListEntry = NULL;

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Case=
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            if (pCaseList == NULL) {
               pCaseList = CheckHeapAlloc(sizeof(LIST_ENTRY));
               InitializeListHead(pCaseList);
            }

            ParseMacroArgs(pch, Len, &pMArgsList);
            pMLListEntry = CheckHeapAlloc(sizeof(MLLISTENTRY));
            if (NULL == pMLListEntry) {
               ExitErrMsg(FALSE, "Out of memory\n");
            }
            pMLListEntry->pMArgs = pMArgsList;
            InsertTailList(pCaseList, &(pMLListEntry->ListEntry));
            pch += Len;


        } else if ((pch = SkipKeyWord(pSrc, szALSO)) != pSrc &&
                *pch == '=') {
            char *t;

            if (NoTypeCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both Also= and NoType= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Also= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (AlsoCount == MAX_ALSO) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d Also= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            Also[AlsoCount++] = t;

            pch += Len;

        } else {

GetNextCodeBurst:
            // grab the name, and if the next thing isn't '=', error out.
            pch = GetNextToken(pSrc);
            if (*pch != '=') {
                goto ETPLExit;
            }
            Len = CopyToken(CodeBurstName, pSrc, pch-pSrc);
            pch += Len;

            // convert the name into an index
            CodeBurstIndex = GetCodeBurstIndex(CodeBurstName);
            if (pCCode[CodeBurstIndex]) {
                // Two codebursts with the same name in this template
                goto ETPLExit;
            }

            pCCode[CodeBurstIndex] = GenHeapAlloc(FileSize*2 + 1);
            CGenLen = 0;

            pSrc = pCCode[CodeBurstIndex];
            while (fgets(pSrc, FileSize*2 - CGenLen, fp)) {
                char buffer[MAX_PATH];
                int len;

                TemplateLine++;

                len = CopyToken(buffer, pSrc, sizeof(buffer));
                pch = pSrc;
                if (len && pSrc[len] == '=') {
                    // The line starts with some keyword and is followed by
                    // an '=' sign.
                    if (strcmp(buffer, szCGENEND) == 0 ||
                        strcmp(buffer, "CGenEnd") == 0) {

                        // The string is 'End=' or 'CGenEnd='.  The CodeBurst
                        // is done.
                        *pSrc = '\0';
                        CGenLen++;
                        pch += len+1;
                        break;
                    }

                    // See if it is the start of a new CodeBurst:
                    CodeBurstIndex = GetExistingCodeBurstIndex(buffer);
                    if (CodeBurstIndex != -1) {
                        strcpy(Line, pSrc);
                        *pSrc = '\0';
                        CGenLen++;
                        pSrc = Line;
                        goto GetNextCodeBurst;
                    }
                }

                Len = strlen(pSrc);
                CGenLen += Len;
                pSrc += Len;

            }

            if (!CGenLen) {
                GenHeapFree(pCCode[CodeBurstIndex]);
                pCCode[CodeBurstIndex] = NULL;
            }
        }

        while (*pch && *pch != ';' && IsSeparator(*pch)) {
            pch++;
        }
        if (*pch) {
            if (*pch == ';') {
                // comment to end-of-line
                goto GetNextLine;
            }
            goto ETPLExit;
        }

GetNextLine:
        TemplateLine++;
    } while (fgets(Line, sizeof(Line) - 1, fp));

    // If there is an outstanding template when EOF is hit, add it now.
    if (*TempleName &&
        !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {

        ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
    }


    if (!feof(fp) && ferror(fp)) {
        ExitErrMsg(TRUE, "%s(%d) Read error: %s\n", TemplateFileName, TemplateLine, TempleName);
    }

    bRet = TRUE;

ETPLExit:
    if (!bRet) {
        ErrMsg("%s(%d) ETPL: Invalid Line <%s>\n%s\n", TemplateFileName, TemplateLine, pSrc, Line);
    }

    if (fFreeCCode) {
        for (i=0; i < MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                GenHeapFree(pCCode[i]);
            }
        }
    }
    for (i=0; i<AlsoCount; ++i) {
        GenHeapFree(Also[i]);
    }
    for (i=0; i<NoTypeCount; ++i) {
        GenHeapFree(NoType[i]);
    }

    fclose(fp);

    TemplateFileName = NULL;

    return bRet;
}



PEXPORTSDEBUG
FindInExportsList(char *Name)
{
    PLIST_ENTRY pNext;
    PEXPORTSDEBUG pexportsdbg;

    pNext = ExportsList.Flink;
    while (pNext != &ExportsList) {
        pexportsdbg = CONTAINING_RECORD(pNext, EXPORTSDEBUG, ExportsDbgEntry);
        if (!strcmp(Name, pexportsdbg->ExportName)) {
            return pexportsdbg;
        }
        pNext = pNext->Flink;
    }
    return NULL;
}




PLIST_ENTRY
ListFromTempleType(
    char *TempleType
    )
{
    if (!TempleType || !*TempleType) {
        return NULL;
    }

    if (!strcmp(TempleType, szIFUNC)) {
        return &IFuncTempleList;
    } else if (!strcmp(TempleType, szEFUNC)) {
        return &EFuncTempleList;
    } else if (!strcmp(TempleType, szTYPES)) {
        return &TypeTempleList;
    } else if (!strcmp(TempleType, szCODE)) {
        return &CodeTempleList;
    } else if (!strcmp(TempleType, szEFAST)) {
        return &EFastTempleList;
    } else if (!strcmp(TempleType, szMACROS)) {
        return &MacroList;
    } else if (!strcmp(TempleType, szFAILTYPES)) {
        return &FailTempleList;
    }
    return NULL;
}

/*
 *  AddTemple
 *
 *  worker function for ExtractTemple, to verify and store template.
 */

#pragma optimize("", off)
BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    )
{
    PLIST_ENTRY pHeadList = NULL;
    PTEMPLES ptpl;
    char *pch;
    int SizeCGen, SizeTempleName, SizeComment, SizeNoType;
    int Len;
    int i;
    int AlsoIndex;

    if (!*TempleName) {
        return FALSE;
    }

    pHeadList = ListFromTempleType(TempleType);
    if (!pHeadList) {
        return FALSE;
    }

    SizeCGen = 0;
    for (i=0; i<MAX_CODEBURST; ++i) {
         SizeCGen++;
         if (pCCode[i]) {
            SizeCGen += strlen(pCCode[i]);
         }
    }

    AlsoIndex=0;

    for (;;) {
        if (pHeadList != &TypeTempleList && GetTemplate(pHeadList, TempleName)) {
            ExitErrMsg(FALSE, "Multiple templates are not allowed.  TemplateName=%s, Type=%s\n", TempleName, TempleType);
        }

        SizeTempleName = strlen(TempleName) + 1;
        SizeComment = strlen(Comment) + 1;
        SizeNoType = 0;
        for (i=0; i<NoTypeCount; ++i) {
            SizeNoType += strlen(NoType[i])+1;
        }


        Len = SizeCGen + SizeTempleName + SizeComment + SizeNoType;
        Len +=  sizeof(TEMPLES);

        ptpl = GenHeapAlloc(Len);
        if (!ptpl) {
            ExitErrMsg(TRUE, "GenHeapAlloc(TEMPLE)");
            }

        memset(ptpl, 0, Len);
        ptpl->IndLevel = strtoul(IndLevel, &pch, 10);
        ptpl->tkDirection = tkDirection;

        Len = 0;
        ptpl->Name = ptpl->Buffer;
        strcpy(ptpl->Name, TempleName);
        Len += SizeTempleName;

        ptpl->Comment = ptpl->Buffer + Len;
        strcpy(ptpl->Comment, Comment);
        Len += SizeComment;

        for (i=0; i<MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                //
                // Copy the code for this codeburst name
                //
                ptpl->CodeBurst[i] = ptpl->Buffer + Len;
                Len++;

                strcpy(ptpl->CodeBurst[i], pCCode[i]);
                Len += strlen(pCCode[i]);

                if (g_fLessTrailingWhitespace)
                    StripTrailingWhitespaceFromString(ptpl->CodeBurst[i]);
            }
        }

        for (i=0; i<NoTypeCount; ++i) {
            ptpl->NoTypes[i] = ptpl->Buffer + Len;
            Len++;
            strcpy(ptpl->NoTypes[i], NoType[i]);
            Len += strlen(NoType[i]);
        }

        ptpl->pCaseList = pCaseList;

        InsertTailList(pHeadList, &ptpl->TempleEntry);

        if (bDebug && Len >= SizeCGen+SizeTempleName+SizeComment+SizeNoType) {
            ExitErrMsg(FALSE, "Buffer overrun in AddTemple!  Heap is trashed! ptpl=%x\n", ptpl);
        }

        if (bDebug) {
            DumpTemplate(ptpl, stdout);
            }

        if (AlsoIndex == AlsoCount) {
            break;
        }
        // there are Also= lines, add those template, too
        strcpy(TempleName, Also[AlsoIndex]);
        AlsoIndex++;
    }

   return TRUE;
}
#pragma optimize("", on)


/*
 *
 */
void DumpTemplate(PTEMPLES ptpl, FILE *fp)
{
     int i;

     fprintf(fp,"Temple: %d Name<%s>\n",
                 ptpl->IndLevel,
                 ptpl->Name
                 );

     for (i=0; i<MAX_CODEBURST; ++i) {
         if (CodeBursts[i].Name) {
             fprintf(fp,"%s(%d) Temple: %s<%s>\n", TemplateFileName, TemplateLine, CodeBursts[i].Name, ptpl->CodeBurst[i]);
         }
     }
}


ULONG
EndianSwitch(
    PULONG pul
    )
{
    ULONG NewValue;
    PBYTE pbValue = (PBYTE)pul;
    PBYTE pbNewValue = (PBYTE) &NewValue;

    *pbNewValue++ = *(pbValue + 3);
    *pbNewValue++ = *(pbValue + 2);
    *pbNewValue++ = *(pbValue + 1);
    *pbNewValue   = *pbValue;

    return NewValue;
}


/*  MapViewDll
 *
 *  Creates a Mapped view of a Dll and intializes
 *  Dll global variables for easy access to the Export Directory
 *
 *  DllMappedBase
 *  DllRvaOffset
 *  DllExportDir
 *  DllExportDirSize
 *  DllFunctions
 *  DllNameOrdinals
 *  DllNameTable
 *
 *
 */
BOOL MapViewDll(char *DllName)
{
    ULONG_PTR RvaOffset;
    HANDLE hFile;
    HANDLE hMapFile;
    PVOID  MappedBase;
    PIMAGE_EXPORT_DIRECTORY ExportDir;
    ULONG ExportDirSize;

    //
    // open and map the file to get the exports info
    //

    hFile = CreateFile(DllName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewDll CreateFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewDll CreateFileMapping(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    MappedBase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewDll MapViewOfFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           TRUE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL\n");
        return FALSE;
        }

    //
    // Initialize the global variables.
    //

    RvaOffset = (ULONG_PTR)ExportDir - (ULONG_PTR)MappedBase;

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           FALSE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL on the second call\n");
        return FALSE;
    }


    DllExportDirSize = ExportDirSize;
    DllMappedBase = MappedBase;
    DllRvaOffset = RvaOffset;
    DllExportDir = ExportDir;

    DllFunctions = (PULONG)((ULONG_PTR)ExportDir +
                            (ULONG_PTR)ExportDir->AddressOfFunctions - RvaOffset
                            );


    DllNameTable  = (PULONG)((ULONG_PTR)ExportDir +
                          (ULONG_PTR)ExportDir->AddressOfNames - RvaOffset
                          );

    DllNameOrdinals = (PUSHORT)((ULONG_PTR)ExportDir +
                             (ULONG_PTR)ExportDir->AddressOfNameOrdinals - RvaOffset
                             );

    fprintf(stdout,
            "Name %s Base %x Ver %x.%x NumberOfFunctions %x NumberOfNames %x\n",
            (PCHAR)((ULONG_PTR)ExportDir + (ULONG_PTR)ExportDir->Name - RvaOffset),
            ExportDir->Base,
            (ULONG)ExportDir->MajorVersion,
            (ULONG)ExportDir->MinorVersion,
            ExportDir->NumberOfFunctions,
            ExportDir->NumberOfNames
            );


    return TRUE;

}


ULONG
DllOrdinalByName(
    char *ExportName
    )
{
    PULONG pNames;
    ULONG NumNames;
    PUSHORT pNameOrdinals;
    char *Name;

    pNames  = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    NumNames = DllExportDir->NumberOfNames;
    while (NumNames--) {
        Name = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);

        if (!strcmp(Name, ExportName)) {
            return *pNameOrdinals + DllExportDir->Base;
            }

        pNames++;
        pNameOrdinals++;
        }


   return 0;
}





/*  MapViewImplib
 *
 *  Creates a Mapped view of an import library and intializes
 *  ImpLib global variables for access to symbols in the first
 *  special linker member.
 *
 *  ImplibMappedBase
 *  ImplibNumSymbols
 *  ImplibSymbolMembers
 *  ImplibSymbolNames
 *
 */

BOOL MapViewImplib(char *LibName)
{
    HANDLE hFile;
    HANDLE hMapFile;
    PBYTE  MappedBase;
    PBYTE  VirtualOffset;
    ULONG  MemberSize;
    PIMAGE_ARCHIVE_MEMBER_HEADER ArchiveMemberHeader;


    //
    // open and map the file.
    //

    hFile = CreateFile(LibName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewImplib CreateFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewImplib CreateFileMapping(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    MappedBase = (PBYTE)MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewImplib MapViewOfFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }


    //
    // Verify the file is an archive
    //

    if (memcmp(MappedBase, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE)) {
        ErrMsg("MapViewImplib IMAGE_ARCHIVE_START_SIZE invalid(%s)\n", LibName);
        return FALSE;
        }

    VirtualOffset = MappedBase + IMAGE_ARCHIVE_START_SIZE;

    ArchiveMemberHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER) VirtualOffset;
    if (sscanf((char *) ArchiveMemberHeader->Size, "%ld", &MemberSize) != 1) {
        ErrMsg("MapViewImplib ArchiveMemberHeader->Size '%s' corrupt\n", (char *) ArchiveMemberHeader->Size);
        return FALSE;
    }


    //
    // Verify first special linker member exists (name == "\\")
    //

    if (memcmp(ArchiveMemberHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(ArchiveMemberHeader->Name))) {
        ErrMsg("MapViewImplib first special linker member missing (%s)\n", LibName);
        return FALSE;
        }

    //
    // First Linker Member format (Big endian!)
    //  NumberOfSymbols, 4 bytes
    //  Offsets,         4 bytes * NumSymbols
    //  StringTable      NumSymbols == NumStrings
    //

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImplibNumSymbols = EndianSwitch((PULONG)VirtualOffset);


    VirtualOffset += 4;
    ImplibSymbolMembers = (PULONG)VirtualOffset;

    VirtualOffset +=  ImplibNumSymbols * sizeof(ULONG);
    ImplibSymbolNames = (PCHAR)VirtualOffset;

    ImplibMappedBase = MappedBase;

    fprintf(stdout, "Implib: %s Base %p\n", LibName, ImplibMappedBase);


    return TRUE;

}


BOOL
ExtractMember(
    ULONG MemberOffset,
    PULONG Ordinal,
    BOOLEAN *Data
    )
{
    PIMAGE_FILE_HEADER ImageFileHeader;
    PBYTE VirtualOffset;
    BOOL Idata5Found, TextFound;

    VirtualOffset = (PBYTE)ImplibMappedBase + MemberOffset;

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImageFileHeader = (PIMAGE_FILE_HEADER) VirtualOffset;

    *Ordinal = 0;
    Idata5Found = FALSE;
    TextFound = FALSE;

    if (ImageFileHeader->Machine == 0 &&
        ImageFileHeader->NumberOfSections == 0xffff) {
        //
        // VC6 format import lib found.
        //
        PVC6_IMAGE_IMPORT_HEADER pHdr;

        pHdr = (PVC6_IMAGE_IMPORT_HEADER)ImageFileHeader;
        if (pHdr->NameType == IMPORT_ORDINAL) {
            //
            // pHdr->wOrdinal specifies the ordinal for this import.
            //
            *Ordinal = 0x80000000 | (ULONG)pHdr->Ordinal;
        }
        if (pHdr->Type == IMPORT_DATA) {
            //
            // This is a data import
            //
            *Data = TRUE;
        }
        Idata5Found = TRUE;
    } else {
        //
        // Pre-VC6 import lib.
        //
        ULONG NumSections;
        ULONG UNALIGNED *RawDataPointer;
        IMAGE_SECTION_HEADER UNALIGNED *ImageSectionHeader;

        NumSections = ImageFileHeader->NumberOfSections;

        //
        // Carefull, librarian doesn't align the Image section header according
        // to normal rules for images.
        //

        VirtualOffset += sizeof(IMAGE_FILE_HEADER) + ImageFileHeader->SizeOfOptionalHeader;
        ImageSectionHeader = (IMAGE_SECTION_HEADER UNALIGNED *)VirtualOffset;

        while (NumSections--) {

            //
            // Implib provides .idata5, and .idata4 (duplicate) which
            // contains the ordinal number with the hi bit set if it
            // was specified in the module definition file. Otherwise
            // the ordinal number is not specified in the implib.
            //

            if (!Idata5Found &&
                !strncmp(ImageSectionHeader->Name, szIDATA5, sizeof(szIDATA5)-1)) {

                //
                // Carefull, librarian doesn't align the begining of raw data
                // according to normal rules for images.
                //

                RawDataPointer = (ULONG UNALIGNED *)((PBYTE)ImageFileHeader + ImageSectionHeader->PointerToRawData);
                if (*RawDataPointer & 0x80000000) {
                    *Ordinal = *RawDataPointer;
                }
                Idata5Found = TRUE;

            } else if (!TextFound &&
                 !strncmp(ImageSectionHeader->Name, szTEXT, sizeof(szTEXT)-1)) {
                TextFound = TRUE;
            }

            ImageSectionHeader++;
        }

        *Data = (!TextFound) ? TRUE : FALSE;  // if no text section, must be data export
    }
    return Idata5Found;
}






BOOL
InitExportDebug(
    PEXPORTSDEBUG ExportDebug,
    char *SymbolName,
    ULONG SymbolMember
    )
{
    ULONG_PTR Forward;
    ULONG OrdinalIndex;
    char *pch = SymbolName; // we assume __implib_ prefix not present

    //
    // C fn begins with "_"
    // C++ fn begins with "?"
    // Data export begins with  "??_C" in real symbols,
    // but in implib looks a C function
    //

    if (*pch == '?') {
        ExportDebug->CplusDecoration = pch;
        DbgPrintf("C++ export %s\n", SymbolName);
        }
    else {
        ExportDebug->CplusDecoration = NULL;
        }

    //
    //  Copy out the ExportName.
    //

    if (*pch == '_' || *pch == '?' || *pch == '@') {
        pch++;                          // skip lead char (underscor, qmark)
    }
    strcpy(ExportDebug->ExportName, pch);
    pch = strchr(ExportDebug->ExportName, '@');
    if (SymbolName[0] == '?' && SymbolName[1] == '?') {
        //
        // Found a "real" C++ name: a mangled version of
        // "classname::membername".  Use the fully-mangled function name,
        // instead of the name with the leading '?' stripped, and don't
        // truncate after the '@'.
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }
    if (pch && ExportDebug->CplusDecoration && pch[1] != '@') {
        //
        // This export is '?membername@classname@@...'.  Don't truncate!
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }

    if (pch && !bNoFuzzyLogic) {   // truncate the symbol from ExportName
        *pch = '\0';
        }

    //
    // Get the decoration, for synthetic args
    // cdecl has no decoration
    // stdcall has total arg size
    //

    if (pch && !ExportDebug->CplusDecoration) {
        ExportDebug->ArgsSize = strtol(pch + 1, NULL, 10);
        }
    else {
        ExportDebug->ArgsSize = -1;
        }


    //
    // Fetch the ordinal from the implib. In an Implib the ordinal
    // only appears if an ordinal is specifed in the def file.
    //

    if (!ExtractMember(SymbolMember, &ExportDebug->Ordinal, &ExportDebug->Data)) {
        ErrMsg("InitExportDebug: %s Member not found\n", SymbolName);
        return FALSE;
        }

    if (ExportDebug->Data) {
        DbgPrintf("DATA export %s\n", SymbolName);
        }

    //
    // If we don't yet have an ordinal, search the ExportNameTable
    // for the Ordinal number. Note that Ordinals which *must* appear
    // in generated def files have the hi-bit set!
    //

    if (!ExportDebug->Ordinal) {
        ExportDebug->Ordinal = DllOrdinalByName(ExportDebug->ExportName);
        if (!ExportDebug->Ordinal) {
            ErrMsg("InitExportDebug: %s Ordinal not found\n", SymbolName);
            return FALSE;
            }
        }


    //
    // Look up function using ordinal as index to function table.
    //

    OrdinalIndex = IMPORDINAL(ExportDebug->Ordinal) - DllExportDir->Base;
    ExportDebug->Function = *(DllFunctions + OrdinalIndex);


    //
    // Check for references forwarded externally, we only need
    // external forwards which are really internal forwards.
    //
    // e.g rpcrt4.dll has following def file entries:
    //
    // I_RpcBindingInqDynamicEndpoint=RPCRT4.I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // Our thunk dll will use the following:
    //
    // I_RpcBindingInqDynamicEndpoint=I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // It is important to strip the "rpcrt4." as this adds an extra
    // loader reference to rpcrt4.dll.
    //
    //
    ExportDebug->ExtForward = NULL;

    Forward = (ULONG_PTR)DllExportDir + ExportDebug->Function - DllRvaOffset;
    if (Forward > (ULONG_PTR)DllExportDir &&
        Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
       {
        char *pSrc;

        pSrc = (char *) Forward;
        pch = DllBaseName;

        while (*pSrc && *pSrc != '.' && toupper(*pSrc) == toupper(*pch)) {
            pSrc++;
            pch++;
            }

        if (*pSrc == *pch) {
            ExportDebug->ExtForward = pSrc + 1;
            }
        }



    DbgPrintf("%4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
              ExportDebug->ArgsSize,
              ExportDebug->Ordinal,
              IMPORDINAL(ExportDebug->Ordinal),
              ExportDebug->Function,
              ExportDebug->ExportName,
              ExportDebug->ExtForward ? ExportDebug->ExtForward : ""
              );

   return TRUE;
}




/*
 *  SetInternalForwards
 *
 *
 *
 */
void
SetInternalForwards(void)
{
   PLIST_ENTRY NextExport;
   PEXPORTSDEBUG ExportDebug;


   //
   // check each export in the list for multiple exports to same function.
   // For each set of internal forwards identify which export defines the api,
   // and save this in the IntForward field.
   //

   NextExport= ExportsList.Flink;
   while (NextExport != &ExportsList) {
        ExportDebug = CONTAINING_RECORD(NextExport,
                                       EXPORTSDEBUG,
                                       ExportsDbgEntry
                                       );

        if (ExportDebug->Function &&
           !ExportDebug->ExtForward &&
           !ExportDebug->IntForward)
         {
            PLIST_ENTRY Next;
            PEXPORTSDEBUG pexdbg;
            PEXPORTSDEBUG KnownApi =NULL;
            int ArgSize = ExportDebug->ArgsSize;

            //
            // Walk the rest of the list to find first duplicate function
            //

            Next = NextExport->Flink;
            while (Next != &ExportsList) {
                pexdbg = CONTAINING_RECORD(Next,
                                           EXPORTSDEBUG,
                                           ExportsDbgEntry
                                           );

                if (pexdbg->Function == ExportDebug->Function) {
                    if (pexdbg->ArgsSize >= 0) {
                        ArgSize = pexdbg->ArgsSize;
                        }
                    break;
                    }

                 Next = Next->Flink;

                }


            if (Next != &ExportsList) {

                //
                // We found one dup function. Temporarily link together this set
                // of dup functions using the IntForward field, and determine
                // the first KnownApi.
                //

                if (GetNameFromTypesList(FuncsList, ExportDebug->ExportName)) {
                    KnownApi = ExportDebug;
                    }


                do {

                    pexdbg = CONTAINING_RECORD(Next,
                                               EXPORTSDEBUG,
                                               ExportsDbgEntry
                                               );


                    if (pexdbg->Function == ExportDebug->Function) {
                        pexdbg->IntForward = ExportDebug->IntForward;
                        ExportDebug->IntForward = pexdbg;
                        if (pexdbg->ArgsSize >= 0) {
                            ArgSize = pexdbg->ArgsSize;
                            }

                        if (!KnownApi &&
                            GetNameFromTypesList(FuncsList, pexdbg->ExportName))
                          {
                            KnownApi = pexdbg;
                            }
                        }

                    Next = Next->Flink;

                } while (Next != &ExportsList);



                //
                // If we found multiple entries, walk the temp links, and insert
                // the KnownApi, which is used to define the api. If we didn't
                // find a known api, use ExportDebug, and hope for the best
                // (since its not known).
                //

                if (!KnownApi) {
                    KnownApi = ExportDebug;
                    }

                pexdbg = ExportDebug;

                while (pexdbg) {
                    PEXPORTSDEBUG NextForward;

                    NextForward = pexdbg->IntForward;
                    pexdbg->IntForward = KnownApi;
                    pexdbg->ArgsSize =  ArgSize;

                    DbgPrintf("IntForward: %s to %s\n",
                              pexdbg->ExportName,
                              KnownApi->ExportName
                              );

                    pexdbg = NextForward;

                    }
                }
            }

         NextExport = NextExport->Flink;

         }

}




/*
 *  ExtractExports -
 *
 *  reads the exports debug info from a dll,
 *  and builds the exports list.
 *
 */
BOOL ExtractExports(void)
{
    ULONG  NumNames;
    PULONG pNames;
    PUSHORT pNameOrdinals;
    PULONG ImpSymbolMember;
    PCHAR  ImpSymbolName;
    EXPORTSDEBUG ExportDebug;
    char ExportName[MAX_PATH+1];

    //
    // For each "__imp_" in the implib, gather name, symbol and ordinal
    // and determine its forward status. This will pick up all exports
    // except those which are marked "PRIVATE".
    //

    NumNames   = ImplibNumSymbols;
    ImpSymbolMember = ImplibSymbolMembers;
    ImpSymbolName   = ImplibSymbolNames;

    while (NumNames--) {

         if (!strncmp(szIMPPREFIX, ImpSymbolName, sizeof(szIMPPREFIX) - 1)) {
             memset(&ExportDebug, 0, sizeof(ExportDebug));
             ExportDebug.ApiPlatform = API_ALL;
             ExportDebug.ExportName = ExportName;
             if (!InitExportDebug(&ExportDebug,
                                  ImpSymbolName + sizeof(szIMPPREFIX) - 1,
                                  EndianSwitch(ImpSymbolMember)
                                  ))
                {
                 return FALSE;
                 }

             if (!AddToExportsList(&ExportDebug)) {
                 return FALSE;
                 }

             }

         ImpSymbolMember++;
         ImpSymbolName += strlen(ImpSymbolName) + 1;
         }


    //
    // Search the Export name table for exports which haven't been added yet.
    // These are "PRIVATE" exports with names. We will still be missing
    // exports which are "PRIVATE NONAME", and we won't have symbolic info
    // for the private named exports.
    //

    NumNames = DllExportDir->NumberOfNames;
    pNames   = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    while (NumNames--) {

       memset(&ExportDebug, 0, sizeof(ExportDebug));

       ExportDebug.Ordinal = *pNameOrdinals + DllExportDir->Base;
       ExportDebug.Ordinal |= 0x80000000;
       ExportDebug.Function = *(DllFunctions + *pNameOrdinals);
       ExportDebug.ExportName = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);
       ExportDebug.ApiPlatform = API_ALL;

       if (!FindInExportsList(ExportDebug.ExportName)) {
           ULONG_PTR Forward;
           char *pch;

           //
           // Check for references forwarded externally, we only need
           // external forwards which are really internal forwards.
           //

           ExportDebug.ExtForward = NULL;

           Forward = (ULONG_PTR)DllExportDir + ExportDebug.Function - DllRvaOffset;
           if (Forward > (ULONG_PTR)DllExportDir &&
               Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
              {
               char *pSrc;

               pSrc = (char *)Forward;
               pch = DllBaseName;

               while (*pSrc && *pSrc != '.' && *pSrc == *pch) {
                   pSrc++;
                   pch++;
                   }

               if (*pSrc == '.' && *pSrc == *pch) {
                   ExportDebug.ExtForward = pSrc + 1;
                   }
               }


           //
           // Check for decorations embedded in the exportname
           //

           pch = strchr(ExportDebug.ExportName, '@');
           if (pch++ && *pch != '@') {
               ExportDebug.ArgsSize = strtol(pch, NULL, 10);
               }
           else {
               ExportDebug.ArgsSize = -1;
               }

           ExportDebug.PrivateNamed = TRUE;

           DbgPrintf("Private Named Export: %4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
                     ExportDebug.ArgsSize,
                     ExportDebug.Ordinal,
                     IMPORDINAL(ExportDebug.Ordinal),
                     ExportDebug.Function,
                     ExportDebug.ExportName,
                     ExportDebug.ExtForward ? ExportDebug.ExtForward : ""
                     );

           if (!AddToExportsList(&ExportDebug)) {
               return FALSE;
               }
           }


       // advance to next name\ordinal
       pNames++;
       pNameOrdinals++;

       }





    return TRUE;
}

/*
    ExtractServicesTab-

    Used as a replacement to ExtractXpt.  Extracts file list from a services.tab
    file as used in the ntos project.

*/

void ExtractServicesTab(char *pch)
{
   FILE *fp;
   char pTemp;
   EXPORTSDEBUG ExportDebug;
   char Line[MAX_PATH];
   char ExportName[MAX_PATH];
   char *ApiName;
   char *Prepend;
   char *FileName;
   size_t len, PrependLen;

   //extract filename and optional prepend name
   FileName = pch;
   while(*pch != ':' && *pch != '\0')
      pch++;

   pTemp = *pch;
   *pch = '\0';

   if (pTemp == ':') {
      pch++;
      Prepend = pch;
      while(*pch != '\0') {
         pch++;
      }
      PrependLen = pch-Prepend;
   }
   else {
      Prepend = pch;
      PrependLen = 0;
   }
   if (PrependLen > MAX_PATH - 1) {
      ExitErrMsg(FALSE, "ExSt: Text to prepend to functions names is too long\n");
   }
   memcpy(ExportName, Prepend, PrependLen);

   DbgPrintf("ExST: %s,%s\n", FileName, Prepend);

   fp = fopen(FileName, "r");
   if (!fp) {
       ExitErrMsg(TRUE, "ExST: fopen(%s) failed\n", FileName);
   }

   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExST: fseek to 0 failed\n");
   }
   if (!fgets(Line, sizeof(Line) - 1, fp)) {
       if (ferror(fp)) {
           ExitErrMsg(FALSE, "ExST: Failed to get Defs from %s\n", FileName);
       } else if (feof(fp)) {
           ExitErrMsg(FALSE, "ExST: Premature EOF %s\n", FileName);
       }
   }

   do {
       // skip leading spaces
       pch = Line;
       while (*pch && isspace(*pch)) {
           pch++;
       }
       if (*pch == '\0')
          continue;

       // Grab the function name
       ApiName = pch;
       while(*pch != ',' && *pch != '\0')
          pch++;

       len = pch - ApiName;
       if (len + PrependLen + 1 > sizeof(ExportName)) {
           ErrMsg("ExST: ExportName Buffer overflow\n");
       }

       //Copy everything over
       memcpy(ExportName + PrependLen, ApiName, len);
       ExportName[PrependLen + len] = '\0';

       if (FindInExportsList(ExportName)) {
           //
           // Name is already in the Exports list.  Ignore the second
           // one.
           //
           DbgPrintf("Warning:  API %s was listed more than once in the services.tab.  Ignoring subsequent copies.\n", ExportName);
           continue;
       }

       memset(&ExportDebug, 0, sizeof(ExportDebug));
       ExportDebug.ExportName = ExportName;
       ExportDebug.MethodNumber = 3;
       ExportDebug.ApiPlatform = API_ALL;
       ExportDebug.Ordinal = 0;
       ExportDebug.ArgsSize = -1;

       if (!AddToExportsList(&ExportDebug)) {
           ExitErrMsg(FALSE, "ExST: Invalid Line %s\n", Line);
       }


   } while (fgets(Line, sizeof(Line) - 1, fp));


   if (!feof(fp) && ferror(fp)) {
       ExitErrMsg(FALSE, "ExST: File Read error: %s\n", FileName);
   }

   fclose(fp);

   return;


}

/*
 *  ExtractXpt-
 *
 *  reads the exports from a ".xpt" file and builds the exports list.
 *  An ".xpt" file is simply a list of all of the exports.
 *
 */
BOOL ExtractXpt(char *XptListName, char *DllName)
{
    FILE *fp=NULL;
    BOOL bRet = FALSE;
    char *pch;
    char *pSrc=NULL;

    EXPORTSDEBUG ExportDebug;
    ULONG MethodNumber = 3;
    char Line[MAX_PATH];
    char ExportName[MAX_PATH];
    char ApiName[MAX_PATH];
    char Platform[MAX_PATH];
    BYTE ApiPlatform;
    size_t len;


    DbgPrintf("ExXpt: %s\n", XptListName);

    fp = fopen(XptListName, "r");
    if (!fp) {
        ErrMsg("ExXpt: fopen(%s) failed\n", XptListName);
        goto ExSrcExit;
    }

    if (fseek(fp, 0, SEEK_SET)) {
        ErrMsg("ExXpt: fseek failed.\n");
        goto ExSrcExit;
    }
    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ErrMsg("ExXpt: Failed to get Defs from %s\n", XptListName);
            goto ExSrcExit;
        } else if (feof(fp)) {
            ErrMsg("ExXpt: Premature EOF %s\n", XptListName);
            goto ExSrcExit;
        }
    }

    do {
        // skip leading spaces
        pSrc = Line;
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (!*pSrc) {
            // line was blank.  Reset OLE method stuff for start of new
            // interface then get the next line.
            MethodNumber = 3;
            continue;
        }

        if (*pSrc == ';') {
            // line starts with comment.  If the comment indicates the
            // ole method number, grab that, then ignore the rest of the line.
            pSrc++;
            if (*pSrc++ == '*') {
                MethodNumber = atoi(pSrc);
            }
            continue;
        }

        // Grab the exported function name
        len = CopyToken(ApiName, pSrc, sizeof(ApiName)-1);
        if (len >= sizeof(ApiName) -1) {
            ErrMsg("ExXpt: ExportName Buffer overflow\n");
        }
        pSrc += len;

        if (FindInExportsList(ApiName)) {
            //
            // Name is already in the Exports list.  Ignore the second
            // one.
            //
            DbgPrintf("Warning:  API %s was listed more than once in the .xpt.  Ignoring subsequent copies.\n", ApiName);
            continue;
        }

        // skip over any whitespace after the export name
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (*pSrc == '\0' || *pSrc == ';') {
            // nothing else interresting on the line.  This API is supported
            // on all platoforms.
            ApiPlatform = API_ALL;
        } else {
            // next non-whitespace is not a comment.  This API has an explicit
            // list of supported platforms.
            ApiPlatform = API_NONE;

            do {
                len = CopyToken(Platform, pSrc, sizeof(Platform)-1);
                if (_stricmp(Platform, "win95") == 0) {
                    ApiPlatform |= API_WIN95;
                } else if (_stricmp(Platform, "win98") == 0) {
                    ApiPlatform |= API_WIN98;
                } else if (_stricmp(Platform, "nt4") == 0) {
                    ApiPlatform |= API_NT4;
                } else if (_stricmp(Platform, "nt5") == 0) {
                    ApiPlatform |= API_NT5;
                } else if (_stricmp(Platform, "ntx") == 0) {
                    ApiPlatform |= API_NTx;
                } else if (_stricmp(Platform, "win9x") == 0) {
                    ApiPlatform |= API_WIN9x;
                } else {
                    ExitErrMsg(FALSE, "Error: %s(%d) Unknown platform name '%s'.\n", TemplateFileName, TemplateLine, Platform);
                }
                pSrc += len;
                while (*pSrc && isspace(*pSrc)) {
                    pSrc++;
                }
            } while (*pSrc && *pSrc != ';');

            DbgPrintf("API %s has Platform %x\n", ExportName, ApiPlatform);
        }

        memset(&ExportDebug, 0, sizeof(ExportDebug));
        ExportDebug.ExportName = ExportName;
        ExportDebug.MethodNumber = MethodNumber++;
        ExportDebug.ApiPlatform = ApiPlatform;

        //
        // Look up the export in the implib
        //

        if (ImplibMappedBase) {
            int    Len;
            ULONG  SymbolMember=0;
            ULONG  ImpNumSymbols   = ImplibNumSymbols;
            PULONG ImpSymbolMember = ImplibSymbolMembers;
            PCHAR  ImpSymbolName   = ImplibSymbolNames;

            while (ImpNumSymbols--) {

                Len = strlen(ApiName);
                pch = ImpSymbolName + 1 + Len;
                if (!strncmp(ApiName, ImpSymbolName + 1, Len) &&
                    (!*pch  || *pch == '@')) {
                    SymbolMember = EndianSwitch(ImpSymbolMember);
                    break;
                }

                ImpSymbolMember++;
                ImpSymbolName += strlen(ImpSymbolName) + 1;
            }

            if (SymbolMember) {
                if (!InitExportDebug(&ExportDebug, ImpSymbolName, SymbolMember)) {
                    goto ExSrcExit;
                }
            } else {

                //
                // The export was not found in the implib, and for
                // flexibility we don't required it to be in implib.
                // fill up what we know.
                //

                ExportDebug.Ordinal = 0;
                ExportDebug.ArgsSize = -1;
                strcpy(ExportName, ApiName);
            }

        } else {

            // most info is unknown!

            ExportDebug.Ordinal = 0;
            ExportDebug.ArgsSize = -1;
            strcpy(ExportName, ApiName);
        }

        if (!AddToExportsList(&ExportDebug)) {
            goto ExSrcExit;
        }


    } while (fgets(Line, sizeof(Line) - 1, fp));


    if (!feof(fp) && ferror(fp)) {
        ErrMsg("ExXpt: File Read error: %s\n", XptListName);
        goto ExSrcExit;
    }

    bRet = TRUE;

ExSrcExit:
    if (!bRet) {
        ErrMsg("ExXpt: Invalid Line <%s>\n%s\n", pSrc, Line);
    }

    if (fp) {
        fclose(fp);
    }

    return bRet;
}



BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug)
{
   PEXPORTSDEBUG pexdbg;
   int Len;
   int SizeExportName;

   SizeExportName = strlen(pExportsDebug->ExportName) + 1;

   Len = sizeof(EXPORTSDEBUG) + SizeExportName + 1;

   pexdbg = GenHeapAlloc(Len);
   if (!pexdbg) {
       ExitErrMsg(TRUE, "GenHeapAlloc(EXPORTSDEBUG)");
   }
   memset(pexdbg, 0, Len);
   *pexdbg = *pExportsDebug;

   pexdbg->ExportName = pexdbg->Buffer;
   strcpy(pexdbg->ExportName, pExportsDebug->ExportName);

   InitializeListHead(&pexdbg->ArgsListHead);

   InsertTailList(&ExportsList, &pexdbg->ExportsDbgEntry);

   return TRUE;
}


/*
 *  ExtractPpm.  The on-disk .PPM file is opened as read-only, but
 *               the pages are copy-on-write to the pagefile, so genthnk
 *               can make changes to the in-memory version which go away
 *               when it exits.
 *
 */
BOOL ExtractPpm(char *PpmName)
{
   HANDLE hFile;
   HANDLE hMapFile = NULL;
   PVOID  pvBaseAddress;
   ULONG  Version;
   PVOID  MappedBase;
   ULONG  BytesRead;
   BOOL   bSuccess;
   PCVMHEAPHEADER pHeader;


   DbgPrintf("PpmName: %s\n", PpmName);

   hFile = CreateFile(PpmName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       hFile = NULL;
       ErrMsg("ExtractPpm CreateFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   if (Version != VM_TOOL_VERSION) {
      ErrMsg("ExtractPpm: .PPM version %x does not match genthnk version %x\n",
             Version, VM_TOOL_VERSION);
      return FALSE;
      }

#if _WIN64
   // Read and ignore the 4-byte padding between the Version and the Base
   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }
#endif

   bSuccess = ReadFile(hFile,
                       &pvBaseAddress,
               sizeof(ULONG_PTR),
                       &BytesRead,
                       NULL
                       );

   if (!bSuccess || BytesRead != sizeof(ULONG_PTR)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,NULL);
   if (!hMapFile) {
       ErrMsg("ExtractPpm CreateFileMapping(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   MappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_COPY, 0, 0, 0, pvBaseAddress);
   if (!MappedBase || MappedBase != pvBaseAddress) {
       ErrMsg("ExtractPpm MapViewOfFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   pHeader = (PCVMHEAPHEADER)pvBaseAddress;

   FuncsList = &pHeader->FuncsList;
   StructsList = &pHeader->StructsList;
   TypeDefsList = &pHeader->TypeDefsList;
   NIL = &pHeader->NIL;

   // This must be done after NIL is initialized.
   RBInitTree(&FakeFuncsList);

   return TRUE;

}

void
HandlePreprocessorDirective(
    char *p
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed: '%s'\n", p);
}

char *
LexMacroArgs(
    char *pch
    )
{
    BOOL fLexDone;
    char *pchNew;

    ResetLexer();
    pchNew = LexOneLine(pch, FALSE, &fLexDone);
    CurrentTokenIndex = 0;

    if (fLexDone) {
        return pchNew;
    } else {
        return pch;
    }
}

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    )
/*++

Routine Description:

    Expands an @MacroName(arg1, arg2, ...).

Arguments:

    MacroName   - name of macro to expand
    pCGenState  - current code-gen state
    ppIn        - pointer to pointer to character following '@MacroName'

Return Value:

    TRUE if macro expanded OK, FALSE if not.  *ppIn will be updated to
    point to the character following the end of the macro.

--*/
{
    PTEMPLES pMacroTemple = 0;
    PLIST_ENTRY NextMacro;
    char *pIn;
    PMACROARGSLIST NewMacroArgsList;
    int ArgCount;

    NextMacro = MacroList.Flink;
    while (NextMacro != &MacroList) {
        pMacroTemple = CONTAINING_RECORD(NextMacro, TEMPLES, TempleEntry);

        if (strcmp(MacroName, pMacroTemple->Name) == 0) {
            //
            // Found a macro by that name
            //
            break;
        }
        NextMacro = NextMacro->Flink;
    }

    if (NextMacro == &MacroList) {
        //
        // No macro by that name.
        //
        return FALSE;
    }

    pIn = *ppIn;

    ArgCount = pMacroTemple->IndLevel;
    NewMacroArgsList = GenHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
    if (!NewMacroArgsList) {
        ExitErrMsg(TRUE, "ExpandMacro out of memory");
    }
    NewMacroArgsList->NumArgs = ArgCount;

    if (!ArgCount) {
        //
        // This macro doesn't expect arguments
        //
    } else {
        //
        //
        // This macro expects arguments.  Parse the arguments.
        //

        pIn = ParseMacroArgs(pIn, 0, &NewMacroArgsList);

        if (NewMacroArgsList->NumArgs != ArgCount) {
            ExitErrMsg(FALSE, "Macro %s expects %d arguments\n", MacroName, ArgCount);
        }

    }

    // swap out the currently active macro (if any) and swap in the new macro
    MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
    pCGenState->pMacroArgsList = NewMacroArgsList;

    // generate code for the Begin=/End= section of the macro
    if (!pMacroTemple->CodeBurst[BeginCBI]) {
        ExitErrMsg(FALSE, "%s(%d) Macro %s has no Begin= section: %s\n", TemplateFileName, TemplateLine, MacroName, *ppIn);
    }
    CGenerateEx(pMacroTemple->CodeBurst[BeginCBI], pCGenState, OutBuffer, MaxLen, BytesReturned);

    // swap the previously active macro back in
    pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];

    FreeMacroArgsList(NewMacroArgsList);

    *ppIn = pIn;

    return TRUE;
}


void
WriteBoolean (
    char *pSrc,
    BOOL Value
    )
{
    if (pSrc){
        if ( Value ){
            *pSrc++ = '1';
        }
        else{
            *pSrc++ = '0';
        }
        *pSrc = '\0';
    }
}

char *
ExtractBoolean (
    char *expression,
    BOOLEAN *result
    )
{
    char thischar = 0;

    expression = SkipLeadingWhitespace(expression);

    *result = FALSE;
    thischar = *expression;

    if ( thischar != '\0') {
        char nextchar =*(expression+1);
        if ( nextchar != '\0' && nextchar != ')' && nextchar != ',' && !IsWhitespaceCharacter(nextchar)) {
            ExitErrMsg(FALSE,"%s(%d): Invalid Expression \"%s\"", __FILE__, __LINE__, expression);
            return expression;
        }
    }

    if (thischar == '0') {
        *result = FALSE;
        return expression+1;
    }
    else if (thischar == '1') {
        *result = TRUE;
        return expression+1;
    }
    else{
        ExitErrMsg(FALSE,"%s(%d): Invalid Expression \"%s\"", __FILE__, __LINE__, expression);
        return expression;
    }
}

char *
ExtractBoolean1(
    char *pSrc,
    PCGENSTATE pCGenState,
    BOOLEAN *result
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    char *pExpression;
    char *pch;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;

    *result = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        ExtractBoolean ( Buffer, result );

        GenHeapFree(pExpression);
    }

    return pSrc;
}

char *
ExtractBoolean2(
    char *pSrc,
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    char *pExpression;
    char *pch;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;

    *result1 = FALSE;
    *result2 = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        pch = Buffer;
        pch = ExtractBoolean ( Buffer, result1 );
        if ( *pch == ',') {
            pch++;
        }
        else {
            ExitErrMsg(FALSE,"%s(%d): Invalid Expression \"%s\"", __FILE__, __LINE__, Buffer);
        }
        ExtractBoolean ( pch, result2 );

        GenHeapFree(pExpression);
    }
    return pSrc;
}

void RestoreTrailingWhitespaceToString(char * s, char * originalEnd)
{
    *(s + strlen(s)) = ' ';
}

void StripTrailingWhitespaceFromString(char * s)
{
    char * t;
    char * w = 0;

    if (s == NULL || *s == 0)
        return;

    t = s + strlen(s) - 1;
    while (t != s && strchr(" \t\r\n", *t) != NULL && (w = t))
    {
        --t;
    }
    if (w)
        *w = 0;
}

char * SkipLeadingWhitespace(char * s)
{
    return s + strspn(s, " \t\r\n");
}

BOOL IsWhitespaceCharacter(char c)
{
    return (strchr(" \t\r\n", c) != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\idlxml\cpp.cpp ===
// Copyright (c) Microsoft Corporation

#define SORTPP_PASS
#define GUID_DEFINED
#define IN __in
#define OUT __out

#include "h.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\getpdbname\getpdbname.c ===
/*
This program prints the name of the .pdb corresponding to an image (.dll/.exe/etc.).
foo.dll does not always map to foo.exe.

for example:
getpdbname %windir%\system32\msvcrt.dll %windir%\system32\ntoskrnl.exe %windir%\syswow64\kernel32.dll
  D:\WINDOWS\system32\msvcrt.dll MicrosoftWindowsCPlusPlusRuntime-7010-msvcrt.pdb
  D:\WINDOWS\system32\ntoskrnl.exe ntkrnlmp.pdb
  D:\WINDOWS\syswow64\kernel32.dll wkernel32.pdb
*/
#include "lib.h"

void Main(int argc, char ** argv)
{
    PDB_INFO_EX PdbInfo = { 0 };
    HRESULT hr = 0;
    FILE * rf;
    char textFromFile[MAX_PATH];

    rf = NULL;

    while (*++argv)
    {
        if ( '@' == argv[0][0] )
        {   
            rf = fopen( &(argv[0][1]), "rt" ); 
            if ( !rf )
            {
                printf( "Error opening file %s\n", &(argv[0][1]) );
                continue;
            }
        }
        else
        {
            rf = NULL;
        }

        if (rf && EOF == fscanf( rf, "%s", &textFromFile ) )
        {
            // apparently an empty file
            continue;
        }
        
        do
        {
            if (FAILED(hr = GetPdbInfoEx(&PdbInfo, (rf != NULL) ? textFromFile : *argv)))
            {
                printf("%s(%s) error 0x%lx|%lu|%s\n",
                    __FUNCTION__,
                    rf?textFromFile:*argv,
                    hr,
                    HRESULT_CODE(hr),
                    GetErrorStringA(HRESULT_CODE(hr))
                    );
                continue;
            }
            printf("%s %s\n", PdbInfo.ImageFilePathA, PdbInfo.PdbFilePathA);
            ClosePdbInfoEx(&PdbInfo);
        }
        while( rf && EOF != fscanf( rf, "%s", &textFromFile ) );
        
        if ( rf )
        {
            fclose( rf );
        }
    }
}

int __cdecl main(int argc, char ** argv)
{
    Main(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\getpdbname\lib.c ===
#pragma warning(disable:4201) /* anonymous unions */
#pragma warning(disable:4115) /* named type definition in parentheses */
#pragma warning(disable:4100) /* unreferenced formal parameter */
#pragma warning(disable:4100) /* unreferenced formal parameter */
#pragma warning(disable:4706) /* assignment within conditional expression */
#include <stdio.h>
#include "windows.h"
#include "winerror.h"
#include "imagehlp.h"
#include "lib.h"

int FindCharInString(PCSTR StringToSearch, int CharToFind)
{
    int i = 0;
    int UpperCharToFind = 0;
    int LowerCharToFind = 0;

    UpperCharToFind = TO_UPPER(CharToFind);
    LowerCharToFind = TO_LOWER(CharToFind);
    for (i = 0 ; StringToSearch[i]; ++i)
        if (StringToSearch[i] == LowerCharToFind
            || StringToSearch[i] == UpperCharToFind
            )
            return i;
    return -1;
}

int FindCharInStringW(PCWSTR StringToSearch, int CharToFind)
{
    int i = 0;
    int UpperCharToFind = 0;
    int LowerCharToFind = 0;

    UpperCharToFind = TO_UPPER(CharToFind);
    LowerCharToFind = TO_LOWER(CharToFind);
    for (i = 0 ; StringToSearch[i]; ++i)
        if (StringToSearch[i] == LowerCharToFind
            || StringToSearch[i] == UpperCharToFind
            )
            return i;
    return -1;
}

void RemoveTrailingCharacters(char * s, PCSTR CharsToRemove)
{
    char * t;

    t = 0;
    for (t = s + StringLength(s) ; t != s && FindCharInString(CharsToRemove, *(t - 1)) >= 0 ; --t)
    {
        *(t - 1) = 0;
    }
}

void RemoveTrailingCharactersW(wchar_t * s, PCWSTR CharsToRemove)
{
    wchar_t * t;

    t = 0;
    for (t = s + StringLengthW(s) ; t != s && FindCharInStringW(CharsToRemove, *(t - 1)) >= 0 ; --t)
    {
        *(t - 1) = 0;
    }
}

extern const CHAR Whitespace[] = " \t\r\n";
extern const WCHAR WhitespaceW[] = L" \t\r\n";

void RemoveTrailingWhitespace(char * s)
{
    RemoveTrailingCharacters(s, Whitespace);
}

void RemoveTrailingWhitespaceW(wchar_t * s)
{
    RemoveTrailingCharactersW(s, WhitespaceW);
}

void RemoveTrailingSlashes(char * s)
{
    RemoveTrailingCharacters(s, "\\/");
}

PCSTR GetErrorStringA(int Error)
{
    static char Buffer[1U << 15];

    Buffer[0] = 0;
    FormatMessageA(
        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        Error,
        0,
        Buffer,
        NUMBER_OF(Buffer),
        NULL);
    RemoveTrailingWhitespace(Buffer);

    return Buffer;
}

PCSTR GetLastPathElement(PCSTR s)
{
    if (!s || !*s)
        return s;
    else
    {
        char * base0;
        char * base1;

        base0 = strrchr(s, '\\');
        base1 = strrchr(s, '/');

        if (base0 == NULL && base1 != NULL)
            return base1 + 1;
        if (base1 == NULL && base0 != NULL)
            return base0 + 1;
        // return beginning of string if no more slashes
        if (base1 == NULL && base0 == NULL)
            return s;
        return 1 + MAX(base0, base1);
    }
}

BOOL MyIsHandleValid(HANDLE Handle)
{
    return (Handle != NULL && Handle != INVALID_HANDLE_VALUE);
}

void MyCloseHandle(HANDLE * Handle)
{
    HANDLE Local;
    
    Local = *Handle;
    *Handle = NULL;
    if (MyIsHandleValid(Local))
        CloseHandle(Local);
}

void MyUnmapViewOfFile(PVOID * Handle)
{
    PVOID Local = 0;
    
    Local = *Handle;
    *Handle = NULL;
    if (MyIsHandleValid(Local))
        UnmapViewOfFile(Local);
}

HRESULT OpenFileForRead(PCSTR Path, HANDLE * FileHandle)
{
    HRESULT hr = 0;

    *FileHandle = 0;
    *FileHandle = CreateFileA(Path, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (*FileHandle == INVALID_HANDLE_VALUE)
    {
        *FileHandle = 0;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    hr = NOERROR;
Exit:
    if (FAILED(hr))
    {
        MyCloseHandle(FileHandle);
    }
    return hr;
}

HRESULT GetFileSize64(HANDLE FileHandle, __int64 * Out)
{
    DWORD FileSizeLow = 0;
    DWORD FileSizeHigh = 0;
    LARGE_INTEGER FileSize = {0};
    DWORD LastError = 0;
    HRESULT hr = 0;
    
    *Out = 0;
    FileSizeLow = GetFileSize(FileHandle, &FileSizeHigh);
    if (FileSizeLow == (~(DWORD)(0)) && (LastError = GetLastError()) != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(LastError);
        goto Exit;
    }
    FileSize.LowPart = FileSizeLow;
    FileSize.HighPart = FileSizeHigh;
    *Out = FileSize.QuadPart;
    hr = NOERROR;
Exit:
    return hr;
}

HRESULT MapEntireFileForRead(HANDLE FileHandle, HANDLE * FileMapping, PBYTE * ViewOfFile)
{
    HRESULT hr = 0;
    HANDLE LocalFileMapping = 0;

    if (FileMapping == NULL)
        FileMapping = &LocalFileMapping;

    *FileMapping = 0;
    *ViewOfFile = 0;
    if (!(*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READONLY, 0, 0, 0)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (!(*ViewOfFile = (PBYTE)MapViewOfFile(*FileMapping, FILE_MAP_READ, 0, 0, 0)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    hr = NOERROR;
Exit:
    if (FAILED(hr))
    {
        MyCloseHandle(FileMapping);
        MyUnmapViewOfFile((PVOID*)ViewOfFile);
    }
    MyCloseHandle(&LocalFileMapping);
    return hr;
}

HRESULT
OpenAndMapEntireFileForRead(
    PMEMORY_MAPPED_FILE MemoryMappedFile,
    PCSTR FilePath
    )
{
    HRESULT hr = 0;

    if (FAILED(hr = OpenFileForRead(FilePath, &MemoryMappedFile->FileHandle)))
        goto Exit;
    if (FAILED(hr = GetFileSize64(MemoryMappedFile->FileHandle, &MemoryMappedFile->FileSize)))
        goto Exit;
    if (FAILED(hr = MapEntireFileForRead(MemoryMappedFile->FileHandle, &MemoryMappedFile->FileMappingHandle, &MemoryMappedFile->MappedViewBase)))
        goto Exit;
    MemoryMappedFile->FilePathA = FilePath;
    hr = NOERROR;
Exit:
    if (FAILED(hr))
        CloseMemoryMappedFile(MemoryMappedFile);
    return hr;
}

void CloseMemoryMappedFile(PMEMORY_MAPPED_FILE MemoryMappedFile)
{
    MyCloseHandle(&MemoryMappedFile->FileHandle);
    MyCloseHandle(&MemoryMappedFile->FileMappingHandle);
    MyUnmapViewOfFile((PVOID*)&MemoryMappedFile->MappedViewBase);
    MemoryMappedFile->FileSize = 0;
    MemoryMappedFile->FilePathA = NULL;
    MemoryMappedFile->FilePathW = NULL;
}

void ClosePdbInfoEx(PPDB_INFO_EX PdbInfo)
{
    CloseMemoryMappedFile(&PdbInfo->MemoryMappedFile);
    ZeroMemory(PdbInfo, sizeof(*PdbInfo));
}

HRESULT GetPdbInfoEx(PPDB_INFO_EX PdbInfoEx, PCSTR ImageFilePath)
{
    HRESULT hr = 0;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories = 0;
    PIMAGE_DEBUG_DIRECTORY Debug = 0;
    ULONG NumberOfDebugDirectories = 0;
    PPDB_INFO PdbInfo = 0;
    PBYTE MappedViewBase = 0;
    BOOL Found = 0;

    if (FAILED(hr = OpenAndMapEntireFileForRead(&PdbInfoEx->MemoryMappedFile, ImageFilePath)))
        goto Exit;

    MappedViewBase = PdbInfoEx->MemoryMappedFile.MappedViewBase;

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(MappedViewBase, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &NumberOfDebugDirectories);
    NumberOfDebugDirectories /= sizeof(*DebugDirectories);
    if (DebugDirectories == NULL || NumberOfDebugDirectories == 0)
    {
        fprintf(stderr, "%s(%s): no debug directory\n", __FUNCTION__, ImageFilePath);
        hr = E_FAIL;
        goto Exit;
    }

    Found = FALSE;
    for ( Debug = DebugDirectories;
          !Found && NumberOfDebugDirectories != 0;
          (--NumberOfDebugDirectories, ++Debug)
        )
    {
        switch (Debug->Type)
        {
        default:
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            PdbInfo = (PPDB_INFO)(MappedViewBase + Debug->PointerToRawData);

            if (memcmp(&PdbInfo->TypeSignature, "NB10", 4) == 0)
            {
                Found = TRUE;
                PdbInfoEx->PdbFilePathA = PdbInfo->u.NB10.PdbFilePath;
            }
            else if (memcmp(&PdbInfo->TypeSignature, "RSDS", 4) == 0)
            {
                Found = TRUE;
                PdbInfoEx->PdbFilePathA = PdbInfo->u.RSDS.PdbFilePath;
            }
            else
            {
                fprintf(stderr, "%s(%s): unknown codeview signature %.4s\n", __FUNCTION__, ImageFilePath, PdbInfo->TypeSignature);
                // keep looping, maybe there's more
                //hr = E_FAIL;
                //goto Exit;
            }
            break;
        }
    }
    if (!Found)
    {
        fprintf(stderr, "%s(%s): no codeview information found\n", __FUNCTION__, ImageFilePath);
        hr = E_FAIL;
        goto Exit;
    }
    PdbInfoEx->PdbInfo = PdbInfo;
    PdbInfoEx->ImageFilePathA = ImageFilePath;
    hr = NOERROR;
Exit:
    if (FAILED(hr))
        ClosePdbInfoEx(PdbInfoEx);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\getpdbname\lib.h ===
#pragma once
#pragma warning(disable:4201) /* anonymous unions */
#pragma warning(disable:4115) /* named type definition in parentheses */
#pragma warning(disable:4100) /* unreferenced formal parameter */
#pragma warning(disable:4100) /* unreferenced formal parameter */
#pragma warning(disable:4706) /* assignment within conditional expression */

#if defined (__cplusplus)
extern "C"
{
#endif
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "winerror.h"
#include "imagehlp.h"
//#include "dbghelp.h"
#include <stdio.h>

#undef MAX
#undef MIN
#define MIN(x,y) ((x)<(y)?(x):(y))
#define MAX(x,y) ((x)>(y)?(x):(y))

void RemoveTrailingWhitespace(CHAR * s);
void RemoveTrailingSlashes(CHAR * s);
void RemoveTrailingCharacters(CHAR * s, PCSTR CharsToRemove);
#define StringLength(s) ((int)strlen(s))
#define StringLengthW(s) ((int)wcslen(s))
int FindCharInString(PCSTR StringToSearch, int CharToFind);
int FindCharInStringW(PCWSTR StringToSearch, int CharToFind);
#define IS_UPPER(x)  ( (x) >= 'A' && (x) <= 'Z' )
#define IS_LOWER(x)  ( (x) >= 'a' && (x) <= 'z' )
#define TO_UPPER(x) (IS_LOWER(x) ? ((x) & ~0x20) : (x))
#define TO_LOWER(x) (IS_UPPER(x) ? ((x) |  0x20) : (x))
extern const CHAR WhiteSpace[];

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

PCSTR GetErrorStringA(int Error);
PCSTR GetLastPathElement(PCSTR s);

void CloseMemoryMappedFile(struct _MEMORY_MAPPED_FILE * MemoryMappedFile);

BOOL MyIsHandleValid(HANDLE Handle);
void MyCloseHandle(HANDLE * Handle);
void MyUnmapViewOfFile(PVOID * Handle);

HRESULT OpenFileForRead(PCSTR Path, HANDLE * FileHandle);
HRESULT GetFileSize64(HANDLE FileHandle, __int64 * Out);
HRESULT MapEntireFileForRead(HANDLE FileHandle, HANDLE * FileMapping OPTIONAL, PBYTE * ViewOfFile);

typedef struct _MEMORY_MAPPED_FILE {
    PCSTR   FilePathA;
    PCWSTR  FilePathW;
    HANDLE  FileHandle;
    HANDLE  FileMappingHandle;
    __int64 FileSize;
    PBYTE   MappedViewBase;
} MEMORY_MAPPED_FILE, *PMEMORY_MAPPED_FILE;

HRESULT
OpenAndMapEntireFileForRead(
    PMEMORY_MAPPED_FILE MemoryMappedFile,
    PCSTR FilePath
    );
void CloseMemoryMappedFile(PMEMORY_MAPPED_FILE MemoryMappedFile);

typedef struct _PDB_INFO {
    BYTE TypeSignature[4]; /* "NBxx" for VC<7, usually NB10, "RSDS" for VC7 */
    union
    {
        struct
        {
            unsigned long Offset;           /* always zero */
            unsigned long Signature;
            unsigned long Age;
            CHAR PdbFilePath[1];
        } NB10;
        struct
        {
            GUID Guid;
            unsigned long Age;
            CHAR PdbFilePath[1];
        } RSDS;
    } u;
} PDB_INFO, *PPDB_INFO;

typedef struct _PDB_INFO_EX {
    PCSTR    ImageFilePathA;
    PCWSTR   ImageFilePathW;
    PCSTR    PdbFilePathA;
    PCWSTR   PdbFilePathW;
    PPDB_INFO  PdbInfo;
    MEMORY_MAPPED_FILE MemoryMappedFile;
} PDB_INFO_EX, *PPDB_INFO_EX;

HRESULT GetPdbInfoEx(struct _PDB_INFO_EX * PdbInfo, PCSTR ImageFilePath);
void    ClosePdbInfoEx(struct _PDB_INFO_EX * PdbInfo);


#if defined (__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\idlxml\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

{}.cpp{$(O)\}.pp:
 $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

# keep comments in when preprocessing
!ifdef PASS0ONLY
C_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS) -C
CXX_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS) -C

# restore some suffixes for pass0, and add .ppm
.SUFFIXES: .cpp .pp .ppm
!endif

$(O)\cpp.pp: $(O)\idl.h

{$(O)\}.pp{$(O)\}.ppm:
    idlclean $< $<.tmp2
    perl < $<.tmp2 > $<.tmp3 <<
        $$file = join("", <>);
        #
        # modify a string in commctrl.h that looks like it has a comment
        # be sure to do slashslash comments first due to some "confusing"
        # text around IInternetSecurityMgrSite
        #
        $$file =~ s/":\/\/"/"xxx"/gms;
        $$file =~ s/\/\/.*?$$/ /gms;
        $$file =~ s/\/\*.*?\*\//\n/gs;
        $$file =~ s/\WIN\W/ __in /g;
        $$file =~ s/\WOUT\W/ __out /g;
        print $$file;
<<KEEP
    sortpp $(SORTPP_FLAGS) -m$@ $<.tmp3

$(O)\this_is_supposed_to_be.xml : $(O)\$(TARGETNAME).$(TARGETEXT) $(PPMFILE)
    $(O)\$(TARGETNAME).$(TARGETEXT) $(PPMFILE) > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\idlxml\h.h ===
// Copyright (c) Microsoft Corporation

// sortpp does not understand __declspec(deprecated).
// Just change it to something else arbitrary.
#define deprecated dllimport

#include <stddef.h>
#include "windows.h"
#undef C_ASSERT
#define C_ASSERT(x) /* nothing */
#include "ole2.h"
#include "commctrl.h"
#include "imagehlp.h"
#include "setupapi.h"
#include "wincrypt.h"
#include "idl.h"

class CFooBase
{
};

class
__declspec(uuid("70b1fef5-1e18-4ff5-b350-6306ffee155b"))
CFoo : public CFooBase
{
public:
	PVOID Bar(int i);
};

#ifdef SORTPP_PASS
//Restore IN, OUT
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#define IN __in
#define OUT __out
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\manbuilder.cpp ===
#include "stdinc.h"
#include "stdio.h"
#include "objbase.h"
#include "prettyformat.h"
#include "user32detours.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof(*x))
//
// Options:
//
// -manifest <filename>     - Uses filename as the output/input manifest
// -useexisting             - Assumes filename is already there, and that
//                              it potentially contains some data already
//                              that should be updated/appended to
// -rebuildexisting         - Manifest exists, but remove everything except
//                              the file name and hash information (if present)
// -checkregistry           - Indicates that the registry should be searched
//                              for other file entries in 'manifest'
// -dlls [dll [[dll] ...]]  - List of DLLs (patterns) that should go into the manifest
//                              if not already present
// -tlb <typelibname>       - Type library to pull extra data out of
//

#define STR_NOLOGO                      L"-nologo"
#define MS_LOGO                         L"Microsoft (R) Manifest Builder version 1.0.0.0\r\nCopyright (c) Microsoft Corporation 2001. All rights reserved.\r\n\r\n"
#define STR_FILE_TAG_NAME               L"file"
#define STR_ASSEMBLY_MANIFEST_NAMESPACE L"urn:schemas-microsoft-com:asm.v1"
#define STR_FILESEARCH_PATTERN          L"/asmns:assembly/asmns:file"
#define STR_COMCLASS_TAG                L"comClass"
#define STR_COMCLASS_CLSID              L"clsid"
#define STR_COMCLASS_TLBID              L"tlbid"
#define STR_COMCLASS_PROGID             L"progid"
#define STR_COMCLASS_THREADING          L"threadingModel"
#define STR_COMCLASS_DESC               L"description"
#define STR_ASM_NS                      L"asmns"
#define SELECTION_NAMESPACES            (L"xmlns:" STR_ASM_NS L"='" STR_ASSEMBLY_MANIFEST_NAMESPACE L"'")
#define STR_MS_COMMENT_COPYRIGHT        L"Copyright (C) Microsoft Corp. All Rights Reserved"

class __declspec(uuid("00020424-0000-0000-C000-000000000046")) CPSOAInterface;

class IMetaDataFileElement
{
public:
    virtual bool CompleteElement(CSmartPointer<IXMLDOMElement> ptElement) = 0;
};


class CComClassInformation : public IMetaDataFileElement
{
public:
    CLSID m_ObjectIdent;
    CLSID m_TlbIdent;
    CString m_Description;
    CString m_Name;
    CString m_DllName;
    CString m_ThreadingModel;

    CString m_VersionIndependentProgId;
    CSimpleList<CString> m_ProgIdListing;

    CComClassInformation() {
        ZeroMemory(&m_ObjectIdent, sizeof(m_ObjectIdent));
        ZeroMemory(&m_TlbIdent, sizeof(m_TlbIdent));
    }

    virtual bool AddProgId(const CString& ProgId)
    {
        for (SIZE_T i = 0; i < m_ProgIdListing.Size(); i++) {
            if (m_ProgIdListing[i] == ProgId)
                return true;
        }

        m_ProgIdListing.Append(ProgId);
        return true;
    }

    virtual bool CompleteElement(CSmartPointer<IXMLDOMElement> ptClsidElement)
    {
        HRESULT hr;

        hr = ptClsidElement->setAttribute(
            CString(L"clsid"), 
            _variant_t(StringFromCLSID(m_ObjectIdent)));

        if (FAILED(hr))
            return false;

        if (m_TlbIdent != GUID_NULL)
        {
            hr = ptClsidElement->setAttribute(
                CString(L"tlbid"), 
                _variant_t(StringFromCLSID(m_TlbIdent)));

            if (FAILED(hr))
                return false;
        }
        
        hr = ptClsidElement->setAttribute(CString(L"description"), _variant_t(m_Description));
        
        if (m_ThreadingModel.length() != 0)
        {
            hr = ptClsidElement->setAttribute(CString(L"threadingModel"), _variant_t(m_ThreadingModel));
            if (FAILED(hr))
                return false;
        }
        
        if (m_VersionIndependentProgId.length() != 0)
        {
            hr = ptClsidElement->setAttribute(CString(L"progid"), _variant_t(m_VersionIndependentProgId));
            if (FAILED(hr))
                return false;
        }
        
        for (SIZE_T pi = 0; pi < m_ProgIdListing.Size(); pi++)
        {
            CSmartPointer<IXMLDOMNode> ptCreatedNode;
            CSmartPointer<IXMLDOMDocument> ptDocument;
            VARIANT vt;

            vt.vt = VT_INT;
            vt.intVal = NODE_ELEMENT;

            if (FAILED(hr = ptClsidElement->get_ownerDocument(&ptDocument)))
                return false;

            if (FAILED(ptDocument->createNode(
                    vt, 
                    _bstr_t(L"progid"),
                    _bstr_t(STR_ASSEMBLY_MANIFEST_NAMESPACE), 
                    &ptCreatedNode)))
                return false;
            
            if (FAILED(ptCreatedNode->put_text(m_ProgIdListing[pi])))
                return false;

            if (FAILED(ptClsidElement->appendChild(ptCreatedNode, NULL)))
                return false;
        }

        return hr == S_OK;
    }
};

class CTlbInformation : public IMetaDataFileElement
{
public:
    GUID m_Ident;
    DWORD m_Version[2];
    DWORD m_dwFlags;
    CString m_HelpDirectory;
    CString m_ResourceIdent;
    CString m_SourceFile;

    CTlbInformation() {
        m_dwFlags = m_Version[0] = m_Version[1] = 0;
        ZeroMemory(&m_Ident, sizeof(m_Ident));
    }

    virtual bool 
    CompleteElement(CSmartPointer<IXMLDOMElement> ptTlbElement)
    {
        if (FAILED(ptTlbElement->setAttribute(
                _bstr_t(L"tlbid"), 
                _variant_t(StringFromCLSID(this->m_Ident)))))
            return false;
        
        if (m_ResourceIdent.length() != 0)
        {
            if (FAILED(ptTlbElement->setAttribute(_bstr_t(L"resourceid"), _variant_t(m_ResourceIdent))))
                return false;
        }

        if (FAILED(ptTlbElement->setAttribute(_bstr_t(L"version"), _variant_t(FormatVersion(m_Version[0], m_Version[1])))))
            return false;

        if (FAILED(ptTlbElement->setAttribute(_bstr_t(L"helpdir"), _variant_t(m_HelpDirectory))))
            return false;

        return true;
    }


};

//
// This is the assembly!comInterfaceProxyStub element member.
//
class CComInterfaceProxyStub : public IMetaDataFileElement
{
public:
    IID m_InterfaceId;
    GUID m_TlbId;
    CLSID m_StubClsid;    
    CString m_Name;
    int m_iMethods;

    CComInterfaceProxyStub() { 
        ZeroMemory(&m_InterfaceId, sizeof(m_InterfaceId));
        ZeroMemory(&m_TlbId, sizeof(m_TlbId));
        ZeroMemory(&m_StubClsid, sizeof(m_StubClsid));
        m_iMethods = 0;
    }

    virtual bool 
    CompleteElement(CSmartPointer<IXMLDOMElement> ptProxyStub)
    {
        if (m_InterfaceId != GUID_NULL)
            if (FAILED(ptProxyStub->setAttribute(_bstr_t(L"iid"), _variant_t(StringFromCLSID(m_InterfaceId)))))
                return false;

        if (m_TlbId != GUID_NULL)
            if (FAILED(ptProxyStub->setAttribute(_bstr_t(L"tlbid"), _variant_t(StringFromCLSID(m_TlbId)))))
                return false;

        if (m_Name.length() != 0)
            if (FAILED(ptProxyStub->setAttribute(_bstr_t(L"name"), _variant_t(m_Name))))
                return false;

        if (m_iMethods)
            if (FAILED((ptProxyStub->setAttribute(_bstr_t(L"numMethods"), _variant_t((LONGLONG)m_iMethods)))))
                return false;

        if (m_StubClsid != GUID_NULL)
            if (FAILED(ptProxyStub->setAttribute(_bstr_t(L"proxyStubClsid32"), _variant_t(StringFromCLSID(m_StubClsid)))))
                return false;

        return true;

        // Punting on base interface
    }
};

class CInterfaceInformation
{
public:
    bool m_fUsed;
    IID m_InterfaceIID;
    CString m_Name;

    CInterfaceInformation() : m_fUsed(false) { }
};

class CWindowClass : IMetaDataFileElement
{
public:
    CString m_WindowClass;
    CString m_SourceDll;

    virtual bool CompleteElement(CSmartPointer<IXMLDOMElement> ptWindowClassElement)
    {
        return SUCCEEDED(ptWindowClassElement->put_text(this->m_WindowClass));
    }
        
};

class CDllInformation
{
public:
    CString m_DllName;
    CSimpleList<CComInterfaceProxyStub*> m_IfaceProxies;
    CSimpleList<CInterfaceInformation*> m_pInterfaces;

    HRESULT PopulateFileElement(CSmartPointer<IXMLDOMElement> ptElement);
};


class CManBuilder
{
public:
    CManBuilder();
    ~CManBuilder() { }

    bool Initialize(SIZE_T argc, WCHAR** argv);
    bool Run();

protected:

    CComClassInformation* FindClassInfoForClsid(CLSID id);

    enum { 
        HK_REDIR_HKLM,
        HK_REDIR_HKCU,
        HK_REDIR_HKCR,
        HK_REDIR_HKCC,
        HK_REDIR_HKU,
        HK_REDIR_HKPD,
        HK_REDIR_BASE_KEY,
        HK_REDIR_COUNT
    };

    enum ErrorLevel {
        ePlProgress = 0x01,
        ePlWarning  = 0x02,
        ePlError    = 0x04,
        ePlSpew     = 0x08
    };

    ErrorLevel m_plPrintLevel;
    bool m_fAddCopyrightData;

    bool DispUsage();
    bool Display(ErrorLevel pl, PCWSTR Format, ...);

    bool ProcessDllEntry(CSmartPointer<IXMLDOMElement> ptFileTargetElement);

    bool FindFileDataFor(
        const CString& FileName,
        CSmartPointer<IXMLDOMElement> ptDocumentRoot,
        CSmartPointer<IXMLDOMElement> &ptFileNode,
        bool fAddIfNotPresent = false);

    CString m_ManifestFilename;
    CString m_TlbBaseName;
    CString m_strRegistryRootKey;
    CSimpleList<CString> m_Parameters;
    CSimpleList<CString> m_IdentityBlob;
    CSimpleList<CString> m_InputDllListing;


    CSimpleList<CComClassInformation*> m_ComClassData;
    CSimpleList<CTlbInformation*> m_TlbInfo;
    CSimpleList<CInterfaceInformation> m_FoundInterfaces;
    CSimpleList<CComInterfaceProxyStub*> m_ExternalProxies;
    CSimpleList<CWindowClass*> m_WindowClasses;

    bool m_fUseRegistryData, m_fTestCreation;

    CSimpleMap<CString, CDllInformation> m_DllInformation;

    bool ConstructEmptyAssemblyManifest(CSmartPointer<IXMLDOMDocument2> ptDocument);
    void PrintXML(CSmartPointer<IDispatch> ptUnk);
    void DisplayErrorInfo(CSmartPointer<ISupportErrorInfo> iErrorInfo);
    bool UpdateManifestWithData(CSmartPointer<IXMLDOMDocument> ptDocument);
    bool RegServerDll(CString ptFileElement);
    bool GatherRegistryData();
    bool EasyGetRegValue(HKEY hkRoot, PCWSTR pcwszSubKeyName, PCWSTR pcwszValueName, CString &OutValue, bool &fFound);
    void DisplayParams();
    bool FindWindowClasses();

    //
    // Look up what DLL owns this clsid
    //
    CString FindOwningClsid(CString& clsid);
    bool AddInterface(CDllInformation &dll, CSmartPointer<ITypeInfo> ptTypeInfo);
};

CComClassInformation* 
CManBuilder::FindClassInfoForClsid(CLSID id)
{
    for (SIZE_T c = 0; c < this->m_ComClassData.Size(); c++)
    {
        if (m_ComClassData[c]->m_ObjectIdent == id)
            return m_ComClassData[c];
    }

    return NULL;
}



bool
CManBuilder::FindWindowClasses()
{
    HMODULE hmUser32 = NULL;
    UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    
    if (GetModuleHandleW(L"user32.dll") == 0)
    {
        hmUser32 = LoadLibraryW(L"user32.dll");
    }
    
    //
    // For this DLL, run through all its objects and see
    // if they can be activated..
    //
    for (SIZE_T c = 0; c < m_InputDllListing.Size(); c++)
    {        
/*
// no need to do this again, all entries in the list has already been registered.
//

        CString &dll = m_InputDllListing[c];
        HMODULE hmThisDll = NULL;

        hmThisDll = LoadLibraryW(dll);

        if (hmThisDll == NULL)
        {
            Display(ePlProgress, L"Unable to loadlibrary %ls - can't sniff window classes.\r\n",
                static_cast<PCWSTR>(dll));
        }
        else
        {
            FreeLibrary(hmThisDll);
        }
*/
        CSimpleList<CString> Classes;
        User32Trampolines::GetRedirectedStrings(Classes);
        User32Trampolines::ClearRedirections();

        for (SIZE_T i = 0; i < Classes.Size(); i++)
        {
            CWindowClass *pClass = new CWindowClass;
            PCWSTR pcwsz = wcsrchr(m_InputDllListing[c], L'\\');
            if (pcwsz)            
                pClass->m_SourceDll = pcwsz + wcsspn(pcwsz, L"\\//");            
            else            
                pClass->m_SourceDll = m_InputDllListing[c];
            
            pClass->m_WindowClass = Classes[i];

            this->m_WindowClasses.Append(pClass);
        }
        
    }

    if (hmUser32) FreeLibrary(hmUser32);

    SetErrorMode(uiErrorMode);

    return true;
}


bool
CManBuilder::EasyGetRegValue(
    HKEY hkRoot,
    PCWSTR pcwszSubKeyName,
    PCWSTR pcwszValueName,
    CString &OutValue,
    bool &fFound
)
{
    OutValue = L"";
    HKEY hkSubKey = NULL;
    bool fProblems = false;
    ULONG ulError;

    fFound = false;

    if (0 == (ulError = RegOpenKeyW(hkRoot, pcwszSubKeyName, &hkSubKey)))
    {
        PBYTE pbData = NULL;
        DWORD cbdwData = 0;
        DWORD dwType;

        while (true)
        {
            DWORD dwErr = RegQueryValueExW(hkSubKey, pcwszValueName, NULL, &dwType, pbData, &cbdwData);

            if ((dwErr == ERROR_SUCCESS) && (pbData != NULL))
            {
                OutValue = (PWSTR)pbData;
                fFound = true;
                break;
            }
            else if ((dwErr == ERROR_MORE_DATA) || ((dwErr == ERROR_SUCCESS) && (pbData == NULL)))
            {
                if (pbData) 
                {
                    delete[] pbData;
                }

                pbData = new BYTE[cbdwData+1];
                continue;
            }
            else if ((dwErr == ERROR_FILE_NOT_FOUND) || (dwErr == ERROR_PATH_NOT_FOUND))
            {
                break;
            }
            else
            {
                fProblems = true;
                break;
            }
        }

        if (pbData)
        {
            delete[] pbData;
            pbData = NULL;
        }

        RegCloseKey(hkSubKey);
    }

    return !fProblems;
}



bool
CManBuilder::GatherRegistryData()
{
    CSimpleList<CString> FoundFiles;

    //
    // Look at HKEY_CLASSES_ROOT\CLSID - it contains the list of clsids that we should
    // be adding to the manifest.
    //
    CString     PathBuilder;
    WCHAR       wchKeyName[MAX_PATH];
    DWORD       dwIndex = 0;
    ULONG       ulError;
    DWORD       cbDataLength;
    HKEY        hkIterationKey;

    ulError = RegOpenKeyExW(HKEY_CLASSES_ROOT, L"CLSID", 0, KEY_ENUMERATE_SUB_KEYS, &hkIterationKey);

    while (ulError == ERROR_SUCCESS) 
    {
        HKEY        hkThisClass = NULL;
        CString     WorkerValue;
        bool        fPresent, fOk, fCreatedInfo = false;
        CComClassInformation *pThisClass;
        CLSID       FoundClsid;
    
        ulError = RegEnumKeyExW(hkIterationKey, dwIndex++, wchKeyName, &(cbDataLength = sizeof(wchKeyName)), NULL, NULL, NULL, NULL);
        if (ulError != ERROR_SUCCESS)
            break;

        //
        // Conversion to a clsid failed?  Hmm, but continue.
        //
        if (FAILED(CLSIDFromString(wchKeyName, &FoundClsid)))
            continue;

        //
        // Find the existing class data to match up with.  Otherwise, create a new
        // entity and add it to the list.
        //
        pThisClass = FindClassInfoForClsid(FoundClsid);
        if (pThisClass == NULL) {
            pThisClass = new CComClassInformation();
            pThisClass->m_ObjectIdent = FoundClsid;
            fCreatedInfo = true;
        }

        //
        // Description of the class
        //
        fOk = EasyGetRegValue(hkIterationKey, wchKeyName, NULL, WorkerValue, fPresent);
        if (fOk && fPresent)
        {
            pThisClass->m_Description = WorkerValue;
        }

        //
        // Now that we've got this subkey, let's go open it and do a little inspection on it.
        //
        ulError = RegOpenKeyExW(hkIterationKey, wchKeyName, 0, KEY_READ, &hkThisClass);
        if (ulError == ERROR_SUCCESS)
        {
            //
            // Get the version-independent prog id for this class
            //
            fOk = EasyGetRegValue(hkThisClass, L"VersionIndependentProgID", NULL, WorkerValue, fPresent);
            if (fOk && fPresent)
            {
                pThisClass->m_VersionIndependentProgId = WorkerValue;
            }

            //
            // Get the non-independent one
            //
            fOk = EasyGetRegValue(hkThisClass, L"ProgID", NULL, WorkerValue, fPresent);
            if (fOk && fPresent)
            {
                pThisClass->AddProgId(WorkerValue);
            }

            //
            // Get ourselves a threading model
            //
            fOk = EasyGetRegValue(hkThisClass, L"InprocServer32", L"ThreadingModel", WorkerValue, fPresent);
            if (fOk && fPresent)
            {
                pThisClass->m_ThreadingModel = WorkerValue;
            }

            //
            // And find the class's registered inproc server
            //
            fOk = EasyGetRegValue(hkThisClass, L"InprocServer32", NULL, WorkerValue, fPresent);
            if (fOk && fPresent)
            {
                //
                // Fix up this path - we need just the file name bit, we don't care about the
                // remainder of the path.
                //
                PWSTR pwszLastSlash = wcsrchr(WorkerValue, L'\\');
                if (pwszLastSlash == NULL)
                    pwszLastSlash = wcsrchr(WorkerValue, L'/');

                pThisClass->m_DllName = (pwszLastSlash ? pwszLastSlash + 1 : WorkerValue);
            }

            RegCloseKey(hkThisClass);
            hkThisClass = NULL;
        }

        //
        // Found something in the registry that wasn't a creatable class, really..
        //
        if (fCreatedInfo) {
            if (pThisClass->m_DllName.length() != 0)
                m_ComClassData.Append(pThisClass);
            else
                delete pThisClass;
        }

    }

    RegCloseKey(hkIterationKey);   


#if 0
    while (true)
    {
        DWORD cbKeyNameLength = sizeof(wchKeyName);
        ULONG ulError;
        CString Found_Clsid, ProgId;

        ulError = RegEnumKeyExW(User32Trampolines::RemapRegKey(HKEY_CLASSES_ROOT), dwIndex++, wchKeyName, &cbKeyNameLength, 0, 0, 0, 0);

        if (ulError == ERROR_SUCCESS)
        {
            //
            // Examine this key.  Form up the path to it as {keyname}\Clsid.  We know that this
            // is a version-independent key if {keyname}\curver is present.  (The version-dependent 
            // value should go in the comclsid's <comClass> tag, while the independent goes under
            // the <comClass> as a child node.
            //
            // Not if it's one of the well-known values, though.
            //
            if ((lstrcmpiW(wchKeyName, L"CLSID") == 0) ||
                (lstrcmpiW(wchKeyName, L"Interface") == 0) ||
                (lstrcmpiW(wchKeyName, L"TypeLib") == 0))
                    continue;

            CString ProgIdPath = wchKeyName + CString(L"\\Clsid");
            CString ClsidFound;
            bool fFound = false;
            CComClassInformation *pCInfo = NULL;

            EasyGetRegValue(User32Trampolines::RemapRegKey(HKEY_CLASSES_ROOT), ProgIdPath, NULL, ClsidFound, fFound);

            if (fFound)
            {
                CLSID id;
                CLSIDFromString(ClsidFound, &id);
                
                if ((pCInfo = FindClassInfoForClsid(id)) != NULL)
                {
                    pCInfo->m_ProgIdListing.Append(CString(wchKeyName));
                }
            }


        }
        else
        {
            if (ulError != ERROR_NO_MORE_ITEMS)
                Display(ePlError, L"Error 0x%08lx (%l) enumerating redirected HKEY_CLASSES_ROOT.\r\n",
                    ulError, ulError);
            break;
        }
    }
    
#endif

    //
    // And let's go look at all the interfaces that were in the tlb
    //
    this->m_DllInformation.GetKeys(FoundFiles);
    for (SIZE_T c = 0; c < FoundFiles.Size(); c++)
    {
        CDllInformation &minfo = this->m_DllInformation[FoundFiles[c]];

        for (SIZE_T f = 0; f < minfo.m_pInterfaces.Size(); f++)
        {
            CInterfaceInformation* pInfo = minfo.m_pInterfaces[f];
            CComClassInformation* pComClass = NULL;

            //
            // Already found this one a home?
            //
            if (pInfo->m_fUsed) continue;

            Display(ePlSpew, L"Looking for pstub %ls (%ls)\r\n",
                static_cast<PCWSTR>(StringFromCLSID(pInfo->m_InterfaceIID)),
                static_cast<PCWSTR>(pInfo->m_Name));

            //
            // First check.  Is there a COM class with this IID?
            //
            if ((pComClass = this->FindClassInfoForClsid(pInfo->m_InterfaceIID)) != NULL)
            {
                //
                // Great.  Add an entry for the proxy stub interface to the file tag containing
                // the clsid.
                //
                pInfo->m_fUsed = true;
                CComInterfaceProxyStub *pstub = new CComInterfaceProxyStub;

                pstub->m_InterfaceId = pInfo->m_InterfaceIID;
                pstub->m_StubClsid = pComClass->m_ObjectIdent;
                pstub->m_Name = pComClass->m_Name;
                pstub->m_TlbId = pComClass->m_TlbIdent;

                Display(ePlSpew, L"- Matched to COM class %ls (IID matches guid)\r\n",
                    static_cast<PCWSTR>(pstub->m_Name));

                minfo.m_IfaceProxies.Append(pstub);
            }
            //
            // Otherwise, look in the registry and try to map back to a proxy stub
            // clsid.
            //
            else 
            {
                CString RegPath = L"Interface\\" + StringFromCLSID(pInfo->m_InterfaceIID);
                CString FoundClsid;
                CString FoundTlbIdent;
                bool fFoundClsid, fFoundTlbIdent;

                this->EasyGetRegValue(HKEY_CLASSES_ROOT, RegPath + L"\\ProxyStubClsid32", NULL, FoundClsid, fFoundClsid);
                this->EasyGetRegValue(HKEY_CLASSES_ROOT, RegPath + L"\\TypeLib", NULL, FoundTlbIdent, fFoundTlbIdent);

                if (fFoundClsid)
                {
                    CLSID clsid;
                    CLSIDFromString(FoundClsid, &clsid);

                    //
                    // Now go look and see if we own this clsid.
                    //
                    if ((pComClass = FindClassInfoForClsid(clsid)) != NULL)
                    {
                        pInfo->m_fUsed = true;
                        CComInterfaceProxyStub *pStub = new CComInterfaceProxyStub;
                        pStub->m_InterfaceId = pInfo->m_InterfaceIID;
                        pStub->m_StubClsid = pComClass->m_ObjectIdent;
                        pStub->m_Name = pComClass->m_Name;
                        pStub->m_TlbId = pComClass->m_TlbIdent;

                        m_DllInformation[pComClass->m_DllName].m_IfaceProxies.Append(pStub);
                    }
                    else if (clsid == __uuidof(CPSOAInterface))
                    {
                        CComInterfaceProxyStub *pStub = new CComInterfaceProxyStub;
                        SIZE_T c = 0;

                        pStub->m_InterfaceId = pInfo->m_InterfaceIID;
                        pStub->m_StubClsid = __uuidof(CPSOAInterface);
                        pStub->m_Name = L"Oleaut32 PSOAInterface";
                        pStub->m_iMethods = 0;
                        if (fFoundTlbIdent)
                            CLSIDFromString(FoundTlbIdent, &pStub->m_TlbId);

                        // This sucks, but it's necessary.
                        for (c = 0; c < this->m_ExternalProxies.Size(); c++)
                        {
                            if (this->m_ExternalProxies[c]->m_InterfaceId == pInfo->m_InterfaceIID)
                                break;
                        }

                        if (c == this->m_ExternalProxies.Size())
                        {
                            this->m_ExternalProxies.Append(pStub);
                            pStub = NULL;
                        }

                        if (pStub != NULL)
                        {
                            delete pStub;
                            pStub = NULL;
                        }
                    }
                    
                }
              
            }

        }
    }

    return true;
}


void
CManBuilder::DisplayErrorInfo(
    CSmartPointer<ISupportErrorInfo> iErrorInfo
)
{
    if (iErrorInfo == NULL)
    {
        Display(ePlError, L"No more error information available.\n");
    }
    else
    {
        CSmartPointer<IErrorInfo> iInfo;
        BSTR bst;
     
        GetErrorInfo(0, &iInfo);
        if ((iInfo != NULL) && SUCCEEDED(iInfo->GetDescription(&bst)))
        {
            Display(ePlError, L"Error: %ls\r\n", static_cast<PCWSTR>(bst));
            if (bst)
            {
                SysFreeString(bst);
                bst = NULL;
            }
        }
    }
}



void
CManBuilder::PrintXML(
    CSmartPointer<IDispatch> ptDispatch
)
{
    if (0)
    {
        CSmartPointer<IXMLDOMDocument2> ptDoc;
        if ((ptDoc = ptDispatch) != NULL)
            PrettyFormatXmlDocument(ptDoc);
    }

    OLECHAR *wchGetXML = L"xml";
    DISPID dispid;

    if (ptDispatch != NULL)
    {
        _variant_t vresult;
        HRESULT hr;
        DISPPARAMS dp = { NULL, NULL, 0, 0 };
        EXCEPINFO ei = { 0 };
        
        if (FAILED(ptDispatch->GetIDsOfNames(
            IID_NULL,
            &wchGetXML,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid))) return;

        hr = ptDispatch->Invoke(
            dispid, 
            IID_NULL, 
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_PROPERTYGET,
            &dp,
            &vresult,
            &ei,
            NULL);

        if (SUCCEEDED(hr))
        {
            Display(
                ePlSpew,
                L"XML:\r\n%ls\r\n", 
                static_cast<PCWSTR>((_bstr_t)vresult));
        }
    }
}

bool
SplitIdentityItem(
    const PCWSTR pcwszIdentityString,
    CString& ValueName,
    CString& ValueValue
)
{
    ValueName = ValueValue = L"";
    PWSTR pwszClone = new WCHAR[lstrlenW(pcwszIdentityString) + 1];
    PWSTR pwszEquals, pwszValue;

    wcscpy(pwszClone, pcwszIdentityString);
    pwszEquals = wcschr(pwszClone, L'=');
    pwszValue = CharNextW(pwszEquals);

    if (pwszEquals == NULL) return false;

    *pwszEquals = UNICODE_NULL;

    ValueName = pwszClone;
    ValueValue = pwszValue;

    return true;
}

bool 
CManBuilder::ConstructEmptyAssemblyManifest(
    CSmartPointer<IXMLDOMDocument2> ptDocument
)
{
    //
    // Remove /everything/ from the document.
    //
    CSmartPointer<IXMLDOMProcessingInstruction> Processing;
    CSmartPointer<IXMLDOMNode> AssemblyRootNode;
    CSmartPointer<IXMLDOMElement> AssemblyRootElement;
    VARIANT vt;
    HRESULT hr;

    // Create a processing instruction - <?xml version="1.0"?>
    hr = ptDocument->createProcessingInstruction(
        _bstr_t(L"xml"),
        _bstr_t(L"version='1.0' encoding='UTF-8' standalone='yes'"),
        &Processing);

    if (FAILED(hr))
        return false;

    // And add it
    if (FAILED(ptDocument->appendChild(Processing, NULL)))
        return false;

    //
    // If we're supposed to be injecting the MS copyright, do so
    //
    if (m_fAddCopyrightData)
    {
        CSmartPointer<IXMLDOMComment> CopyrightComment;

        hr = ptDocument->createComment(STR_MS_COMMENT_COPYRIGHT, &CopyrightComment);
        if (FAILED(hr))
            return false;

        if (FAILED(hr = ptDocument->appendChild(CopyrightComment, NULL)))
            return false;
    }
    
    //
    // Create the <assembly> root element.
    //
    vt.vt = VT_INT;
    vt.intVal = NODE_ELEMENT;
    if (FAILED(ptDocument->createNode(
        vt,
        _bstr_t(L"assembly"),
        _bstr_t(STR_ASSEMBLY_MANIFEST_NAMESPACE),
        &AssemblyRootNode)))
            return false;
            
    if ((AssemblyRootElement = AssemblyRootNode) == NULL)
        return false;

    if (FAILED(AssemblyRootElement->setAttribute(CString(L"manifestVersion"), _variant_t(L"1.0"))))
        return false;

    if (FAILED(ptDocument->putref_documentElement(AssemblyRootElement)))
        return false;

    //
    // Construct the identity tag if possible
    //
    if (this->m_IdentityBlob.Size())
    {
        CSmartPointer<IXMLDOMNode> ptIdentityNode;
        CSmartPointer<IXMLDOMElement> ptIdentity;
        CSmartPointer<IXMLDOMElement> ptDocRoot;

        hr = ptDocument->createNode(
            vt, 
            _bstr_t(L"assemblyIdentity"), 
            _bstr_t(STR_ASSEMBLY_MANIFEST_NAMESPACE),
            &ptIdentityNode);

        if (FAILED(hr) || ((ptIdentity = ptIdentityNode) == NULL))
        {
            Display(ePlError, L"Can't create assemblyIdentity node!\r\n");
            DisplayErrorInfo(ptDocument);
        }
        else
        {
            //
            // For each identity pair that was passed in, decide on
            // the name and the value components.
            //
            CString strName, strValue;

            for (SIZE_T sz = 0; sz < m_IdentityBlob.Size(); sz++)
            {
                if (!SplitIdentityItem(m_IdentityBlob[sz], strName, strValue))
                {
                    Display(ePlError, L"Unable to interpret identity pair '%ls'\r\n",
                        static_cast<PCWSTR>(m_IdentityBlob[sz]));
                }
                else if (FAILED(hr = ptIdentity->setAttribute(strName, _variant_t(strValue))))
                {
                    Display(ePlError, L"Unable to set attribute pair %ls = '%ls'\r\n",
                        static_cast<PCWSTR>(strName),
                        static_cast<PCWSTR>(strValue));
                    DisplayErrorInfo(ptIdentity);
                }
            }
        }

        hr = ptDocument->get_documentElement(&ptDocRoot);
        hr = ptDocRoot->appendChild(ptIdentityNode, NULL);
    }

    PrintXML(ptDocument);

    return true;
}


CString
FormatVersion(DWORD dwMaj, DWORD dwMin)
{
    WCHAR wchBuffer[200];
    _snwprintf(wchBuffer, 200, L"%d.%d", dwMaj, dwMin);
    return CString(wchBuffer);
}


CString
StringFromCLSID(REFCLSID rclsid)
{
    PWSTR pwsz = NULL;
    HRESULT hr;
    CString rvalue = L"(unknown)";
    
    hr = StringFromCLSID(rclsid, &pwsz);
    if (pwsz)
    {
        rvalue = pwsz;
        CoTaskMemFree(pwsz);
        pwsz = NULL;
    }
    return rvalue;
}

BOOL CALLBACK 
EnumTypeLibsFunc(
    HMODULE hModule, 
    LPCWSTR lpType,
    LPWSTR lpName, 
    LONG_PTR lp
)
{
    static WCHAR wchBuiltFilePath[MAX_PATH*2];    
    CString tgt;

    if ((UINT)lpName < 0xFFFF)
    {
        wsprintfW(wchBuiltFilePath, L"%d", (UINT)lpName);
        tgt = wchBuiltFilePath;
    }
    else
    {
        tgt = lpName;
    }

    ((CSimpleList<CString>*)lp)->Append(tgt);
    
    return TRUE;
}



bool
CManBuilder::ProcessDllEntry(
    CSmartPointer<IXMLDOMElement> ptFileElement
)
{
    _variant_t vtFileName;

    CSimpleList<CString> ResourceIdentList;
    HMODULE hmDll = NULL;
    CString dll;

    if (FAILED(ptFileElement->getAttribute(_bstr_t(L"name"), &vtFileName)))
        return false;

    // instead using the pure dll filename, find the real path of this file, 
    dll = static_cast<_bstr_t>(vtFileName);
    SIZE_T len = (static_cast<_bstr_t>(vtFileName)).length();
    for (SIZE_T c = 0; c < m_InputDllListing.Size(); c++)
    {                
        if (m_InputDllListing[c].length()>= len)
        {        
            PCWSTR pstr = wcsstr(m_InputDllListing[c], (PWSTR)(static_cast<_bstr_t>(vtFileName)));
            if ((pstr != NULL) && (wcslen(pstr) == len))
            {
                dll = m_InputDllListing[c];
                break;
            }
        }
    }
   
    //
    // Gather all the resource idents of TYPELIB resources
    //
    hmDll = LoadLibraryExW(dll, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hmDll == NULL)
    {
        ResourceIdentList.Append(CString(L""));
        Display(ePlWarning, L"Warning - %ls can not been loaded, ResourceIdentList is appended with an empty string.\n", 
                static_cast<PCWSTR>(dll));
    }
    else
    {
        EnumResourceNamesW(
            hmDll,
            L"TYPELIB",
            EnumTypeLibsFunc,
            (LONG_PTR)&ResourceIdentList);
    }

    //
    // If there were no resource idents, then just do a single pass
    //
    
    for (SIZE_T sz = 0; sz < ResourceIdentList.Size(); sz++)
    {
        CSmartPointer<ITypeLib> ptTypeLibrary;
        CString strGuidString;
        CString strLoadTypeLibParam;
        UINT uiTypeInfoCount;
        TLIBATTR *pLibAttr;
        CTlbInformation* tlbInfo;
        bool fSetResourceIdent = false;
        CDllInformation &dllInfo = this->m_DllInformation[CString(vtFileName)];

        tlbInfo = new CTlbInformation();
        
        //
        // The "blank" string is a placeholder so that we know that the file in question
        // may not be a loadable dll.
        //
        if (ResourceIdentList[sz].length() == 0)
        {
            strLoadTypeLibParam = static_cast<_bstr_t>(vtFileName);
        }
        //
        // Otherwise, the ResourceIdentList contains the resourceID of the typelibrary
        // in question.
        //
        else
        {
            strLoadTypeLibParam = dll + CString(L"\\") + ResourceIdentList[sz];
            tlbInfo->m_ResourceIdent = ResourceIdentList[sz];
        }

        tlbInfo->m_SourceFile = dll;

        if (FAILED(LoadTypeLibEx(strLoadTypeLibParam, REGKIND_NONE, &ptTypeLibrary)))
            continue;

        //
        // Now look through the tlb and see what there is to see..  Assume all CoClasses found
        // in the typelib are implemented for this dll.
        //
        uiTypeInfoCount = ptTypeLibrary->GetTypeInfoCount();

        if (FAILED(ptTypeLibrary->GetLibAttr(&pLibAttr)))
            continue;

        Display(ePlProgress, L"Found type library in file %ls, guid %ls (contains %d types)\n",
            static_cast<PCWSTR>(_bstr_t(vtFileName)),
            static_cast<PCWSTR>(StringFromCLSID(pLibAttr->guid)),
            uiTypeInfoCount);

        tlbInfo->m_Ident = pLibAttr->guid;
        tlbInfo->m_Version[0] = pLibAttr->wMajorVerNum;
        tlbInfo->m_Version[1] = pLibAttr->wMinorVerNum;
        m_TlbInfo.Append(tlbInfo);

        for (UINT ui = 0; ui < uiTypeInfoCount; ui++)
        {
            CSmartPointer<ITypeInfo> ptTypeInfo;
            BSTR rawbstTypeName;
            BSTR rawbstDocumentation;
            CString strTypeName;
            CString strDocumentation;
            TYPEKIND tk;
            TYPEATTR *pTypeAttr = NULL;


            if (FAILED(ptTypeLibrary->GetTypeInfoType(ui, &tk)))
                continue;

            if (FAILED(ptTypeLibrary->GetTypeInfo(ui, &ptTypeInfo)))
                continue;

            if (FAILED(ptTypeInfo->GetTypeAttr(&pTypeAttr)))
                continue;

            // 
            // Get a little documentation
            //
            if (SUCCEEDED(ptTypeLibrary->GetDocumentation(
                    ui,
                    &rawbstTypeName,
                    &rawbstDocumentation,
                    NULL,
                    NULL)))
            {
                if (rawbstTypeName != NULL)
                {
                    strTypeName = _bstr_t(rawbstTypeName, FALSE);
                    rawbstTypeName = NULL;
                }

                if (rawbstDocumentation != NULL)
                {
                    strDocumentation = _bstr_t(rawbstDocumentation, FALSE);
                    rawbstDocumentation = NULL;
                }
            }

            if (pTypeAttr->wTypeFlags & TYPEFLAG_FDUAL)
            {
                if (tk == TKIND_DISPATCH)
                {
                    CSmartPointer<ITypeInfo> ptDispInfo;
                    HREFTYPE hrTypeInfo;

                    if (SUCCEEDED(ptTypeInfo->GetRefTypeOfImplType((UINT)-1, &hrTypeInfo)))
                        if (SUCCEEDED(ptTypeInfo->GetRefTypeInfo(hrTypeInfo, &ptDispInfo)))
                            this->AddInterface(dllInfo, ptDispInfo);
                }
                else if (tk == TKIND_INTERFACE)
                {
                    this->AddInterface(dllInfo, ptTypeInfo);
                }
            }

            if (tk == TKIND_COCLASS)
            {
                CComClassInformation *pClassInfo = NULL;
                bool fCreated = false;

                pClassInfo = FindClassInfoForClsid(pTypeAttr->guid);

                if (pClassInfo == NULL)
                {
                    pClassInfo = new CComClassInformation;
                    m_ComClassData.Append(pClassInfo);
                }
                
                pClassInfo->m_Description = strDocumentation;
                pClassInfo->m_ObjectIdent = pTypeAttr->guid;
                pClassInfo->m_Name = strTypeName;
                pClassInfo->m_TlbIdent = pLibAttr->guid;
            }
            else if (tk == TKIND_INTERFACE)
            {
                this->AddInterface(dllInfo, ptTypeInfo);
            }

            if (pTypeAttr != NULL)
            {
                ptTypeInfo->ReleaseTypeAttr(pTypeAttr);
                pTypeAttr = NULL;
            }
            
        }
    }

    if (hmDll)
    {
        FreeLibrary(hmDll);
        hmDll = NULL;
    }

    return true;
    
}

bool 
CManBuilder::AddInterface(
    CDllInformation &dll,
    CSmartPointer<ITypeInfo> ptTypeInfo 
)
{
    CInterfaceInformation *pInterface = NULL;
    TYPEATTR *pTypeAttr = NULL;
    BSTR bstName = NULL, bstDocumentation = NULL;
    bool fRVal = false;

    if (SUCCEEDED(ptTypeInfo->GetTypeAttr(&pTypeAttr)))
    {
        if (SUCCEEDED(ptTypeInfo->GetDocumentation(MEMBERID_NIL, &bstName, &bstDocumentation, NULL, NULL)))
        {
            pInterface = new CInterfaceInformation;
            pInterface->m_InterfaceIID = pTypeAttr->guid;
            pInterface->m_Name = bstName;
            
            dll.m_pInterfaces.Append(pInterface);

            Display(ePlSpew, L"Found interface %ls '%ls'\r\n",
                static_cast<PCWSTR>(StringFromCLSID(pTypeAttr->guid)),
                bstName);

            fRVal = true;
        }
    }

    if (bstName) ::SysFreeString(bstName);
    if (bstDocumentation) ::SysFreeString(bstDocumentation);
    if (pTypeAttr) ptTypeInfo->ReleaseTypeAttr(pTypeAttr);

    return fRVal;
}




bool
CManBuilder::FindFileDataFor(
    const CString & FileName, 
    CSmartPointer < IXMLDOMElement > ptDocumentRoot, 
    CSmartPointer < IXMLDOMElement > & ptFileElementFound, 
    bool fAddIfNotPresent
)
{
    HRESULT hr;
    CSmartPointer<IXMLDOMNode> ptFoundNode;
/*
    const _bstr_t bstSearchPattern = 
        _bstr_t(L"/" STR_ASM_NS L":assembly/" STR_ASM_NS L":file[@name = '")
        + _bstr_t(FileName) 
        + _bstr_t(L"']");
*/
    CString StrippedName;
    PCWSTR pcwsz;

    //
    // If the file name contains a slash of some sort, we need to get
    // just the file name and not the path.
    //
    pcwsz = wcsrchr(FileName, L'\\');
    if (pcwsz)
    {
        StrippedName = pcwsz + wcsspn(pcwsz, L"\\");
    }
    else
    {
        StrippedName = FileName;
    }
    
    _bstr_t bstSearchPattern = 
        _bstr_t(L"/" STR_ASM_NS L":assembly/" STR_ASM_NS L":file[@name = '")
        + _bstr_t(StrippedName) 
        + _bstr_t(L"']");


    if (ptFileElementFound != NULL)
        ptFileElementFound.Release();

    //
    // Use single-select, since there should only be one entry that matches the
    // above pattern anyhow.
    //
    if (SUCCEEDED(hr = ptDocumentRoot->selectSingleNode(bstSearchPattern, &ptFoundNode)))
    {
        //
        // Convert from an IXMLDOMNode to an IXMLDOMElement
        //
        if ((ptFileElementFound = ptFoundNode) != NULL)
        {
            return true;
        }
    }
    else
    {
        DisplayErrorInfo(ptDocumentRoot);
    }

    if (fAddIfNotPresent)
    {
        //
        // Create a new file node and insert it as the child of the document
        // root.  Print the XML just so we can see what it current is...
        //
        CSmartPointer<IXMLDOMDocument> ptDocument;
        CSmartPointer<IXMLDOMNode> ptCreatedNode;
        CSmartPointer<IXMLDOMElement> ptCreatedFileTag;
        CSmartPointer<IXMLDOMNode> ptNodeInDocument;

        VARIANT vt;
        vt.vt = VT_INT;
        vt.intVal = NODE_ELEMENT;

        if (FAILED(ptDocumentRoot->get_ownerDocument(&ptDocument)))
            return false;

        //
        // Create the file element (element = 'tag')
        //
        if (FAILED(ptDocument->createNode(
                    vt,
                    _bstr_t(STR_FILE_TAG_NAME),
                    _bstr_t(STR_ASSEMBLY_MANIFEST_NAMESPACE),
                    &ptCreatedNode)))
            return false;

        //
        // Convert the 'node' (base xml type) to an 'element' (tag)
        //
        if ((ptCreatedFileTag = ptCreatedNode) == NULL)
        {
            return false;
        }

        if (FAILED(ptCreatedFileTag->setAttribute(
            _bstr_t(L"name"),
            _variant_t(_bstr_t(StrippedName)))))
        {
            return false;
        }

        if (FAILED(ptDocumentRoot->appendChild(ptCreatedNode, &ptNodeInDocument)))
            return false;

        return ((ptFileElementFound = ptNodeInDocument) != NULL);
    }
    

    return true;
}



CManBuilder::CManBuilder() : m_fAddCopyrightData(false), m_fUseRegistryData(false), m_fTestCreation(false), m_plPrintLevel(ePlProgress)
{
}


bool
CManBuilder::Display(ErrorLevel pl, PCWSTR format, ...)
{
    if ((pl & m_plPrintLevel) == 0)
        return true;

    va_list va;
    va_start(va, format);
    vwprintf(format, va);
    va_end(va);

    return true;
}



bool
CManBuilder::RegServerDll(
    CString strDllName
)
{
    UINT uiMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    bool fReturnValue = true;

    HMODULE hmModule = LoadLibraryW(strDllName);
    if (hmModule != NULL)
    {
        typedef HRESULT (STDAPICALLTYPE *tpfnRegisterServer)();
        tpfnRegisterServer pfnRegisterServer;
        pfnRegisterServer = (tpfnRegisterServer)GetProcAddress(hmModule, "DllRegisterServer");
        if (pfnRegisterServer != NULL)
        {
            pfnRegisterServer();
        }
        FreeLibrary(hmModule);
    }else
    {
        Display(ePlError, L"%ls could not be loaded, can not call DllRegisterServer.\n", (PCWSTR)strDllName);
        fReturnValue = false;
    }

    SetErrorMode(uiMode);   

    return fReturnValue;
}



bool
CManBuilder::Run()
{
    bool fOk = true;
    CSmartPointer<IXMLDOMDocument2> ptDocument;
    CSmartPointer<ITypeLib2> ptBaseTypeLibrary;
    CSmartPointer<IXMLDOMElement> ptDocumentRoot;
    CSmartPointer<IXMLDOMNodeList> ptFileElements;
    
    HRESULT hr;

    //
    // Create the XML document.  Assume the user has MSXML 3 or better.
    //
    if (FAILED(hr = ptDocument.CreateInstance(CLSID_DOMDocument30)))
    {        
        Display(ePlError, L"Unable to create instance of XML DOM, can't continue\n");
        return false;
    }

    hr = ptDocument->setProperty(_bstr_t(L"SelectionLanguage"), _variant_t(_bstr_t(L"XPath")));
    hr = ptDocument->setProperty(_bstr_t(L"SelectionNamespaces"), _variant_t(_bstr_t(SELECTION_NAMESPACES)));

    ConstructEmptyAssemblyManifest(ptDocument);

    //
    // Get the document element - the <assembly> tag.
    //
    if (FAILED(ptDocument->get_documentElement(&ptDocumentRoot)))
    {
        Display(ePlError, L"Unable to get the document base element for this XML file.  Bad XML?\n");
        return false;
    }

    User32Trampolines::Initialize();

    //
    // Ensure there's file tags for the listed files on the -dlls parameter.
    // If an entry is missing, add it.
    //
    for (SIZE_T sz = 0; sz < m_InputDllListing.Size(); sz++)
    {
        CSmartPointer<IXMLDOMElement> SingleFileNode;
        this->FindFileDataFor(m_InputDllListing[sz], ptDocumentRoot, SingleFileNode, true);
        if (m_fUseRegistryData)
        {
            if ( false == RegServerDll(m_InputDllListing[sz]))
            {
                Display(ePlError, L"%ls could not be Registered.\n", (PCWSTR)m_InputDllListing[sz]);
                return false;
            }
        }
    }

    //
    // First pass is to load all the files in the manifest, then go and
    // think that they might contain type information.
    //
    if (SUCCEEDED(ptDocumentRoot->selectNodes(_bstr_t(STR_FILESEARCH_PATTERN), &ptFileElements)))
    {
        CSmartPointer<IXMLDOMNode> ptSingleFileNode;
        while (SUCCEEDED(ptFileElements->nextNode(&ptSingleFileNode)))
        {
            if (ptSingleFileNode == NULL)
                break;

            //
            // This will load the TLB from the DLL, and do all the Right Things
            // in terms of getting the TLB information into the right file nodes
            // (assuming they're not already in those file nodes..)
            //
            ProcessDllEntry(ptSingleFileNode);

            //
            // The one above will get released, but the one for the nextNode
            // iteration is outside of the scope and should be nuked - do
            // that here before the next loop.
            //
            ptSingleFileNode.Release();
        }
    }

    //
    // Were we to look at the registry data?  Fine, then let's go and look it all up.
    //
    if (this->m_fUseRegistryData)
    {
        GatherRegistryData();
    }

    //
    // Now let's determine what DLLs actually expose the com classes we found.  It is
    // an error to expose a com class via a tlb that's not actually available from one
    // of the DLLs listed.
    //
    {
        SIZE_T iComClass = 0;
        typedef HRESULT (__stdcall *pfnDllGetClassObject)(REFCLSID, REFIID, LPVOID*);
        UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        class CDllPairing
        {
        public:
            CString DllName;
            pfnDllGetClassObject pfnDGCO;
            HMODULE hmModule;

            CDllPairing() : hmModule(NULL), pfnDGCO(NULL) { }
            ~CDllPairing() { if (hmModule) { FreeLibrary(hmModule); hmModule = NULL; } }
        };

        SIZE_T cDllCount = this->m_DllInformation.Size();
        CDllPairing *Dlls = new CDllPairing[cDllCount];
        CDllPairing *pHere = Dlls;

        for (m_DllInformation.Reset(); m_DllInformation.More(); m_DllInformation.Next())
        {
            pHere->DllName = m_DllInformation.CurrentKey();
            pHere->hmModule = LoadLibraryW(pHere->DllName);

            if (pHere->hmModule != NULL)
            {
                pHere->pfnDGCO = (pfnDllGetClassObject)GetProcAddress(pHere->hmModule, "DllGetClassObject");
            }

            pHere++;            
        }

        for (iComClass = 0; iComClass < this->m_ComClassData.Size(); iComClass++)
        {
            CComClassInformation *pComClass = m_ComClassData[iComClass];
            //
            // Somehow we've already found this out?
            //
            if (pComClass->m_DllName.length() != 0)
                continue;

            //
            // Ask all the DLLs for the class
            //
            for (SIZE_T idx = 0; idx < cDllCount; idx++)
            {
                CSmartPointer<IUnknown> punk;
                HRESULT hres;

                if (Dlls[idx].pfnDGCO == NULL)
                    continue;

                hres = Dlls[idx].pfnDGCO(pComClass->m_ObjectIdent, IID_IUnknown, (LPVOID*)&punk);

                if (hres != CLASS_E_CLASSNOTAVAILABLE)
                    pComClass->m_DllName = Dlls[idx].DllName;
                
                if (punk != NULL)
                    punk->Release();
            }
        }

        delete[] Dlls;

        SetErrorMode(uiErrorMode);
    }


    //
    // Do the "loadlibrary implies registering classes" thing
    //
    FindWindowClasses();

    //
    // Now take all the com class information and put it in files.
    //
    UpdateManifestWithData(ptDocument);
    
    //
    // And save it out to an xml file
    //
    if (FAILED(PrettyFormatXmlDocument(ptDocument)))
        Display(ePlProgress, L"Could not pretty-format the document - the manifest will not be easily human-readable.\r\n");

    //
    // Dump current XML for fun
    //
    PrintXML(ptDocument);

    if (FAILED(ptDocument->save(_variant_t(this->m_ManifestFilename))))
    {
        DisplayErrorInfo(ptDocument);
        fOk = false;
    }

    //
    // Are we on a sxs-aware platform?
    //
    if (m_fTestCreation)
    {
        HANDLE (WINAPI *pfnCreateActCtxW)(PCACTCTXW);
        VOID (WINAPI *pfnReleaseActCtx)(HANDLE);
        HANDLE hContext = INVALID_HANDLE_VALUE;
        HMODULE hmKernel32 = NULL;

        ACTCTXW actctxw = { sizeof(actctxw) };
        actctxw.lpSource = this->m_ManifestFilename;

        hmKernel32 = GetModuleHandleW(L"kernel32.dll");
        
        if (hmKernel32 != NULL)
        {
            pfnCreateActCtxW = (HANDLE (WINAPI*)(PCACTCTXW))GetProcAddress(hmKernel32, "CreateActCtxW");
            pfnReleaseActCtx = (VOID (WINAPI*)(HANDLE))GetProcAddress(hmKernel32, "ReleaseActCtx");

            if ((pfnCreateActCtxW != NULL) && (pfnReleaseActCtx != NULL))
            {
                hContext = pfnCreateActCtxW(&actctxw);

                if (hContext != INVALID_HANDLE_VALUE)
                {
                    pfnReleaseActCtx(hContext);
                    Display(ePlProgress, L"Created valid assembly manifest.\r\n");
                }
                else
                {
                    Display(ePlWarning, L"Warning - this manifest needs more work to be a valid component.\r\n");
                }
            }
            else
            {
                Display(ePlWarning, L"Warning - can't test this manifest, this system does not support CreateActCtxW\r\n");
            }
        }
        else
        {
            Display(ePlWarning, L"Warning - unable to test manifest, kernel32.dll module not found.\r\n");
        }
    }

    User32Trampolines::Stop();

    return fOk;
}



bool
CManBuilder::UpdateManifestWithData(
    CSmartPointer<IXMLDOMDocument> ptDocument
)
{
    CSimpleList<CString> FoundFiles;
    this->m_DllInformation.GetKeys(FoundFiles);
    const _bstr_t bstNamespace = STR_ASSEMBLY_MANIFEST_NAMESPACE;
    HRESULT hr;
    SIZE_T idx;
    CSmartPointer<IXMLDOMElement> ptDocumentRoot;
    VARIANT vt;

    hr = ptDocument->get_documentElement(&ptDocumentRoot);
    if (FAILED(hr))
    {
        Display(ePlError, L"Failed getting document root element!\r\n");
        DisplayErrorInfo(ptDocument);
        return false;
    }

    for (idx = 0; idx < this->m_WindowClasses.Size(); idx++)
    {
        CWindowClass *ptInfo = this->m_WindowClasses[idx];
        CSmartPointer<IXMLDOMElement> ptFileElement;
        CSmartPointer<IXMLDOMNode> ptWindowClassNode;
        vt.vt = VT_INT;
        vt.intVal = NODE_ELEMENT;

        hr = ptDocument->createNode(vt, _bstr_t(L"windowClass"), bstNamespace, &ptWindowClassNode);
        if (FAILED(hr))
        {
            continue;
        }

        if (ptInfo->CompleteElement(ptWindowClassNode) &&
             this->FindFileDataFor(ptInfo->m_SourceDll, ptDocumentRoot, ptFileElement, true))
        {
            hr = ptFileElement->appendChild(ptWindowClassNode, NULL);
        }
    }

    
    for (idx = 0; idx < this->m_ComClassData.Size(); idx++)
    {
        CComClassInformation *ptInfo = this->m_ComClassData[idx];
        CSmartPointer<IXMLDOMElement> ptFileElement;
        CSmartPointer<IXMLDOMNode> ptComNodeNode;
        vt.vt = VT_INT;
        vt.intVal = NODE_ELEMENT;

        if (ptInfo->m_DllName.length() == 0)
        {
            Display(ePlWarning, L"Com clsid %ls (%ls) not associated with a DLL, it will not be listed in the manifest\r\n",
                static_cast<PCWSTR>(StringFromCLSID(ptInfo->m_ObjectIdent)),
                static_cast<PCWSTR>(ptInfo->m_Name));
            continue;
        }

        hr = ptDocument->createNode(vt, _bstr_t(L"comClass"), bstNamespace, &ptComNodeNode);
        if (FAILED(hr))
        {
            continue;
        }

        if (ptInfo->CompleteElement(ptComNodeNode) &&
             this->FindFileDataFor(ptInfo->m_DllName, ptDocumentRoot, ptFileElement, true))
        {
            hr = ptFileElement->appendChild(ptComNodeNode, NULL);
        }
    }

    for (idx = 0; idx < this->m_TlbInfo.Size(); idx++)
    {
        CTlbInformation *ptInfo = this->m_TlbInfo[idx];
        CSmartPointer<IXMLDOMElement> ptFileElement;
        CSmartPointer<IXMLDOMNode> ptTlbNode;
        vt.vt = VT_INT;
        vt.intVal = NODE_ELEMENT;

        hr = ptDocument->createNode(vt, _bstr_t(L"typelib"), bstNamespace, &ptTlbNode);
        if (FAILED(hr))
        {
            continue;
        }

        if (ptInfo->CompleteElement(ptTlbNode) &&
             this->FindFileDataFor(ptInfo->m_SourceFile, ptDocumentRoot, ptFileElement, true))
        {
            hr = ptFileElement->appendChild(ptTlbNode, NULL);
        }
    }


    for (SIZE_T sz = 0; sz < FoundFiles.Size(); sz++)
    {
        CSmartPointer<IXMLDOMElement> ptFileElement;
        SIZE_T c;

        CString &szFoundFilename = FoundFiles[sz];
        CDllInformation &DllInfo = m_DllInformation[szFoundFilename];

        // File node for this map entry not there?  Insert it.
        if (!this->FindFileDataFor(szFoundFilename, ptDocumentRoot, ptFileElement, true))
            continue;

        //
        // Finally, proxy/stub interface implementors
        //
        for (c = 0; c < DllInfo.m_IfaceProxies.Size(); c++)
        {
            CSmartPointer<IXMLDOMNode> ptCreatedNode;
            CComInterfaceProxyStub *pIfaceInfo = DllInfo.m_IfaceProxies[c];
            VARIANT vt;

            vt.vt = VT_INT;
            vt.intVal = NODE_ELEMENT;

            if (FAILED(ptDocument->createNode(vt, _bstr_t(L"comInterfaceProxyStub"), bstNamespace, &ptCreatedNode)))
                continue;

            if (pIfaceInfo->CompleteElement(ptCreatedNode))
            {
                if (FAILED(ptFileElement->appendChild(ptCreatedNode, NULL)))
                {
                    DisplayErrorInfo(ptFileElement);
                }
            }
            
        }
    }

    //
    // For all the external proxies...
    //
    for (SIZE_T sz = 0; sz < m_ExternalProxies.Size(); sz++)
    {
        CSmartPointer<IXMLDOMNode> ptExtInterface;
        VARIANT vt;

        vt.vt = VT_INT;
        vt.intVal = NODE_ELEMENT;

        if (FAILED(ptDocument->createNode(vt, _bstr_t(L"comInterfaceExternalProxyStub"), bstNamespace, &ptExtInterface)))
        {
            DisplayErrorInfo(ptDocument);
            continue;
        }

        m_ExternalProxies[sz]->CompleteElement(ptExtInterface);
        if (FAILED(ptDocumentRoot->appendChild(ptExtInterface, NULL)))
        {
            DisplayErrorInfo(ptDocumentRoot);
            continue;
        }
    }

    return true;
    
}


void
CManBuilder::DisplayParams()
{
    static PCWSTR pcwszHelpText =
        L"Side-by-Side component manifest building tool\r\n"
        L"\r\n"
        L"Parameters:\r\n"
        L"\r\n"
        L"-dlls [dll1] [[dll2] ...]     List of DLLs to include in the component\r\n"
        L"     Include multiple files (-dlls foo.dll bar.dll) to create a manifest with\r\n"
        L"     multiple members\r\n"
        L"-manifest <manifestname>      File to output generated manifest to\r\n"
        L"-verbose                      Print lots of extra debugging spew during run\r\n"
        L"-silent                       Print minimal output, error only\r\n"
        L"-nologo                       Don't display copyright banner\r\n"
        L"-test                         Verify created manifest's structure\r\n"
        L"-captureregistry              Simulate regsvr32 of the DLL in question, and use\r\n"
        L"                              information gathered from HKEY_CLASSES_ROOT\r\n"
        L"-identity [identstring]       Use the text in identstring to build the\r\n"
        L"                              assembly's identity.  See below for format\r\n"
        L"\r\n"
        L"Minimally, you should provide -manifest.\r\n"
        L"\r\n"
        L"[identstring] should be composed of name=value pairs, just like those\r\n"
        L"present in a normal component.  For example - the Microsoft Common Controls\r\n"
        L"version 6.0.0.0 assembly for x86 could be built as follows:\r\n"
        L"\r\n"
        L"-identity type='win32' name='Microsoft.Windows.Common-Controls'\r\n"
        L"     version='6.0.0.0' processorArchitecture='x86'\r\n"
        L"     publicKeyToken='6595b64144ccf1df'\r\n"
        L"\r\n";

    Display(ePlSpew, pcwszHelpText);
}


bool
CManBuilder::Initialize(
    SIZE_T argc,
    WCHAR** argv
)
{
    bool fNoLogo = false;
    bool fParamsOk = true;
    SIZE_T i;

    m_Parameters.EnsureSize(argc);
    
    for (i = 0; i < argc; i++)
    {
        if (lstrcmpiW(argv[i], STR_NOLOGO) == 0) 
            fNoLogo = true;
        else
            m_Parameters[m_Parameters.Size()] = argv[i];
    }

    if (!fNoLogo) 
    {
        this->Display(ePlProgress, MS_LOGO);
    }

    for (i = 0; fParamsOk && (i < m_Parameters.Size()); i++)
    {
        if (CString(L"-manifest") == m_Parameters[i])
        {
            if ((i + 1) < m_Parameters.Size())
                m_ManifestFilename = m_Parameters[++i];
            else
                fParamsOk = false;
        }
        else if (CString(L"-?") == m_Parameters[i])
        {
            this->m_plPrintLevel = (ErrorLevel)0xf;
            DisplayParams();
            return false;
        }
        else if (CString(L"-dlls") == m_Parameters[i])
        {
            while (++i < m_Parameters.Size())
            {
                CString param = m_Parameters[i];
                
                if (((PCWSTR)param)[0] == L'-')
                    break;                

                m_InputDllListing.Append(param); // keep the path info
            }
            --i;
        }
        else if (CString(L"-identity") == m_Parameters[i])
        {
            while (++i < m_Parameters.Size())
            {
                CString param = m_Parameters[i];
                if ((static_cast<PCWSTR>(param))[0] == L'-')
                    break;
                m_IdentityBlob.Append(param);
            }
            --i;
        }
        else if (CString(L"-silent") == m_Parameters[i])
        {
            this->m_plPrintLevel = ePlError;
        }
        else if (CString(L"-mscopyright") == m_Parameters[i])
        {
            m_fAddCopyrightData = true;
        }
        else if (CString(L"-captureregistry") == m_Parameters[i])
        {
            m_fUseRegistryData = true;
        }
        else if (CString(L"-test") == m_Parameters[i])
        {
            this->m_fTestCreation = true;
        }
        else if (CString(L"-verbose") == m_Parameters[i])
        {
            this->m_plPrintLevel = (ErrorLevel)0xf;
        }
    }

    //
    // Bad parameters?
    //
    if (
        (m_ManifestFilename.length() == 0))
    {
        this->m_plPrintLevel = (ErrorLevel)0xf;
        DisplayParams();
        return false;
    }

    return fParamsOk;

}

CString
CreateStringGuid()
{
    GUID uuid;
    CoCreateGuid(&uuid);
    return StringFromCLSID(uuid);
}

int __cdecl wmain(int argc, WCHAR** argv)
{
    CManBuilder builder;

    CoInitialize(NULL);

    if (builder.Initialize(argc, argv))
    {
        builder.Run();
    }

    return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\prettyformat.h ===
#include "stdinc.h"

void 
PrettyFormatXmlNodes(
    CSmartPointer<IXMLDOMDocument2> Document, 
    CSmartPointer<IXMLDOMNode> &CurrentNode, 
    int iLevel);
    
void 
PrettyFormatXmlChildren(
    CSmartPointer<IXMLDOMDocument2> Document, 
    CSmartPointer<IXMLDOMNode> &CurrentNode, 
    CSmartPointer<IXMLDOMNode> &LastNode, 
    CString bStrText, 
    int iLevel);
    
HRESULT 
PrettyFormatXmlDocument(
    CSmartPointer<IXMLDOMDocument2> Document
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\prettyformat.cpp ===
#include "stdinc.h"
#include "prettyformat.h"

#define XML_LINEBREAK   (L"\r\n")
#define NUMBER_OF(x)    (sizeof(x)/sizeof(*x))
#define XML_SPACE       L"  "

CString
Padding(int level)
{
    CString strRetVal;
    static const CString Indentations[] = {
        CString(L""),
        CString(XML_SPACE),
        CString(XML_SPACE XML_SPACE),
        CString(XML_SPACE XML_SPACE XML_SPACE),
        CString(XML_SPACE XML_SPACE XML_SPACE XML_SPACE),
        CString(XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE),
        CString(XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE),
        CString(XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE XML_SPACE)
    };

    if ( level < NUMBER_OF(Indentations) )
        return Indentations[level];
    else while ( level-- )
    {
        strRetVal += L"  ";
    }
    return strRetVal;
}

HRESULT
PrettyFormatXmlDocument2(CSmartPointer<IXMLDOMNode> RootNode, int iLevel)
{
    VARIANT_BOOL vtHasChildren;
    HRESULT hr;
    CSmartPointer<IXMLDOMDocument> ptDocument;
    static CString bstLineBreak = L"\r\n";

    hr = RootNode->hasChildNodes(&vtHasChildren);
    hr = RootNode->get_ownerDocument(&ptDocument);

    if ( vtHasChildren == VARIANT_FALSE )
    {
        //
        // End of recursion.
        //
    }
    else
    {
        //
        // For each child of this, append a \r\n combination text node.
        //
        CSmartPointer<IXMLDOMNode> Child;
        hr = RootNode->get_firstChild(&Child);
        bool fAppendLastBreaker = false;

        while ( Child != NULL )
        {
            DOMNodeType nt;
            CSmartPointer<IXMLDOMNode> nextChild;

            hr = Child->get_nodeType(&nt);

            //
            // We only pretty-format element nodes.
            //
            if ( nt == NODE_ELEMENT )
            {
                CSmartPointer<IXMLDOMText> txt;
                VARIANT vt;

                vt.vt = VT_UNKNOWN;
                vt.punkVal = Child;

                //
                // We need to append a \r\n to the list of siblings as well.
                //
                fAppendLastBreaker = true;

                //
                // Insert \r\n before the child, but only if the child is 
                // not a text node.
                //
                hr = ptDocument->createTextNode(bstLineBreak + Padding(iLevel + 1), &txt);
                hr = RootNode->insertBefore(txt, vt, NULL);

                hr = PrettyFormatXmlDocument2(Child, iLevel + 1);
            }

            if (FAILED(hr = Child->get_nextSibling(&nextChild)))
                break;
            Child = nextChild;
        }

        //
        // Also append a \r\n to the list of children, to break up
        // the </close></close2> tags.
        //
        if ( fAppendLastBreaker )
        {
            CSmartPointer<IXMLDOMText> LastBreaker;
            hr = ptDocument->createTextNode(bstLineBreak + Padding(iLevel), &LastBreaker);
            hr = RootNode->appendChild(LastBreaker, NULL);
        }
    }

    return hr;
}


HRESULT PrettyFormatXmlDocument(CSmartPointer<IXMLDOMDocument2> Document)
{
    HRESULT hr = S_OK;
    CSmartPointer<IXMLDOMElement> rootElement;

    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        return E_FAIL;
    }

    hr = PrettyFormatXmlDocument2(rootElement, 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\stdinc.h ===
#pragma once
#include "windows.h"
#include "oleauto.h"
#include "stdlib.h"
#include "stdio.h"
#include "comip.h"
#include "msxml2.h"
#include <time.h>

typedef _bstr_t CString;

#define LIST_GROW_CHUNKS (10)

template<typename T>
class CSimpleList
{
public:
    T* m_pItems;
    SIZE_T m_ItemCount;
    SIZE_T m_HighWaterMark;

    CSimpleList() : m_pItems(NULL), m_ItemCount(0), m_HighWaterMark(0) {
    }
    
    ~CSimpleList() {
        if ( m_pItems )
        {
            delete[] m_pItems;
            m_pItems = NULL;
        }
    }
    
    SIZE_T RoundSize( SIZE_T c )
    {
        return ( ( c / LIST_GROW_CHUNKS ) + 1 ) * LIST_GROW_CHUNKS;
    }

    bool Contains( const T &t )
    {
        if ( this->Size() == 0 ) return false;
    
        for ( SIZE_T c = 0; c < this->Size(); c++ )
            if ((*this)[c] == t) break;

        return ( c != this->Size() );
    }

    void EnsureSize( SIZE_T count )
    {
        if ( count > m_ItemCount )
        {
            count = RoundSize(count);

            T* pItems = new T[count];
            for ( SIZE_T i = 0; i < m_HighWaterMark; i++ ) {
                pItems[i] = m_pItems[i];
            }
            if ( m_pItems ) delete[] m_pItems;
            m_pItems = pItems;
            m_ItemCount = count;
        }
    }

    void Clear()
    {
        if ( m_pItems )
        {
            delete[] m_pItems;
            m_pItems = NULL;
            m_ItemCount = 0;
            m_HighWaterMark = 0;
        }
    }

    T& operator[](SIZE_T i) {
        EnsureSize(i+1);
        if ( (i+1) > m_HighWaterMark ) 
            m_HighWaterMark = i + 1;
        return m_pItems[i];
    }

    const T& operator[](SIZE_T i) const {
        if ( m_ItemCount <= m_HighWaterMark ) throw new OutOfRangeException(this, i);
        return m_pItems[i];
    }

    SIZE_T MaxSize() const { return m_ItemCount; }
    SIZE_T Size() const { return m_HighWaterMark; }
    void Append(T t) { (*this)[Size()] = t; }

    class OutOfRangeException
    {
        OutOfRangeException(const OutOfRangeException&);
        OutOfRangeException& operator=(const OutOfRangeException&);
    public:
        OutOfRangeException( const CSimpleList* ref, int i ) : List(ref), Index(i) { }
        const CSimpleList* List;
        int Index;
    };
};

template<typename Key, typename Value>
class CSimpleMap
{
    class CSimpleBucket
    {
    public:
        Key m_Key;
        Value m_Value;
        CSimpleBucket(const Key key, const Value val) : m_Key(key), m_Value(val) { }
        CSimpleBucket(const Key k) : m_Key(k) { }
        CSimpleBucket() { }
    };

    CSimpleList<CSimpleBucket> m_Buckets;
    SIZE_T m_LastPosition;
    SIZE_T m_CurrentIndex;
    
public:

    CSimpleMap() : m_LastPosition(0), m_CurrentIndex(0) { }

    Value& operator[](const Key k) {
        if ( Contains(k) )
            return m_Buckets[m_LastPosition].m_Value;
        else
        {
            CSimpleBucket bkt(k);
            m_Buckets.Append(bkt);
            return (*this)[k];
        }
    }

    class OutOfBoundsException
    {
    public:
    };
    
    class KeyNotFoundException
    {
    public:
        KeyNotFoundException(const Key k) : m_Key(k) { }
        KeyNotFoundException();

        Key m_Key;
    };

    bool Contains(const Key k)
    {
        for ( SIZE_T sz = 0; sz < m_Buckets.Size(); sz++ )
        {   
            if ( m_Buckets[sz].m_Key == k )
            {
                this->m_LastPosition = sz;
                return true;
            }
        }

        return false;
    }

    void GetKeys( CSimpleList<Key> &KeyList )
    {   
        for ( SIZE_T sz = 0; sz < m_Buckets.Size(); sz++ )
        {
            KeyList.Append(m_Buckets[sz].m_Key);
        }
    }

    void Reset()
    {

        m_CurrentIndex = 0;
    }

    bool More() const
    {
        return ( m_CurrentIndex < m_Buckets.Size() );
    }

    void Next()
    {
        m_CurrentIndex++;
    }

    const Key& CurrentKey() const {
        if ( !More() ) throw OutOfBoundsException();
        return m_Buckets[m_CurrentIndex].m_Key;
    }

    const Value& CurrentValue() const {
        if ( !More() ) throw OutOfBoundsException();
        return m_Buckets[m_CurrentIndex].m_Value;
    }

    Value& CurrentValue() {
        if ( !More() ) throw OutOfBoundsException();
        return m_Buckets[m_CurrentIndex].m_Value;
    }

    void Clear()
    {
        m_Buckets.Clear();
    }

    SIZE_T Size() { return m_Buckets.Size(); }
};

template<typename T> class CSmartPointer : public _com_ptr_t<_com_IIID<T, &__uuidof(T)> >
{
public:
    template<class Q>
    CSmartPointer<T>& operator=(CSmartPointer<Q>& right)
    {
        right.QueryInterface(this->GetIID(), &(*this));
        return *this;
    }

    template<class Q>
    CSmartPointer( CSmartPointer<Q> thing )
    {
        (*this) = thing;
    }
    CSmartPointer() { }
};

CString
StringFromCLSID(REFCLSID rclsid);

CString
FormatVersion(DWORD dwMaj, DWORD dwMin);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\user32detours.h ===
#pragma once

namespace User32Trampolines
{
    ATOM WINAPI InternalRegisterClassW(CONST WNDCLASSW *lpWndClass);
    ATOM WINAPI InternalRegisterClassA(CONST WNDCLASSA *lpWndClass);
    ATOM WINAPI InternalRegisterClassExW(CONST WNDCLASSEXW *);
    ATOM WINAPI InternalRegisterClassExA(CONST WNDCLASSEXA *);

    BOOL Initialize();
    void ClearRedirections();
    BOOL Stop();
    BOOL GetRedirectedStrings(CSimpleList<CString> &Strings);

    HKEY RemapRegKey(HKEY);
    LONG APIENTRY InternalRegCreateKeyA(HKEY, PSTR, PHKEY);
    LONG APIENTRY InternalRegCreateKeyExA(HKEY, PCSTR, DWORD, PCSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD);
    LONG APIENTRY InternalRegSetValueA(HKEY, PCSTR, DWORD, PCSTR, DWORD);
    LONG APIENTRY InternalRegSetValueExA(HKEY, PCSTR, DWORD, DWORD, CONST BYTE*, DWORD);
    LONG APIENTRY InternalRegOpenKeyA (HKEY, PCSTR, PHKEY);
    LONG APIENTRY InternalRegOpenKeyExA (HKEY hKey, LPCSTR, DWORD, REGSAM, PHKEY);
    LONG APIENTRY InternalRegQueryValueExA(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
    LONG APIENTRY InternalRegQueryValueA(HKEY, LPCSTR, LPSTR, PLONG);

    LONG APIENTRY InternalRegCreateKeyW(HKEY, PWSTR, PHKEY);
    LONG APIENTRY InternalRegCreateKeyExW(HKEY, PCWSTR, DWORD, PCWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD);
    LONG APIENTRY InternalRegSetValueW(HKEY, PCWSTR, DWORD, PCWSTR, DWORD);
    LONG APIENTRY InternalRegSetValueExW(HKEY, PCWSTR, DWORD, DWORD, CONST BYTE*, DWORD);
    LONG APIENTRY InternalRegOpenKeyW(HKEY, PCWSTR, PHKEY);
    LONG APIENTRY InternalRegOpenKeyExW(HKEY hKey, LPCWSTR, DWORD, REGSAM, PHKEY);
    LONG APIENTRY InternalRegQueryValueExW(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
    LONG APIENTRY InternalRegQueryValueW(HKEY, LPCWSTR, LPWSTR, PLONG);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\idlxml\idltoxml.cpp ===
/*++

  Copyright (c) Microsoft Corporation
  
    Module Name:
    
      idltoxml.cpp
      
        Abstract:
        
          From a .ppm that included .idl, generate .xml.
          Based on base\wow64\tools\gennt32t.cpp.
          The .tpl language doesn't seem to provide for enumerating types, and the .ppm
          files are pretty easy to read directly and apply arbitrary/flexible C/C++ logic to.
          Writing .tpl is actually a significant extra learning curve beyond reading .ppm files.
          
            Author:
            
              Jay Krell (JayKrell) August 2001
              
                Revision History:
                
--*/

#include "windows.h"
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

extern "C" {
    
#include "gen.h"
    
// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'IDLTOXML' ";

void
    HandlePreprocessorDirective(
    char *
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed by gennt32t.\n");
}
    
}

const char g_Indent[] = "                                                                  ";

PRBTREE Functions = NULL;
PRBTREE Structures = NULL;
PRBTREE Typedefs = NULL;
PKNOWNTYPES NIL = NULL;

void ExtractCVMHeader(PCVMHEAPHEADER Header)
{
    Functions	= &Header->FuncsList;
    Typedefs	= &Header->TypeDefsList;
    Structures  = &Header->StructsList;
    NIL         = &Header->NIL; 
}

void GuidToString(GUID g, char * s)
{
    sprintf(
        s, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        g.Data1, g.Data2, g.Data3, g.Data4[0], g.Data4[1], g.Data4[2],
        g.Data4[3], g.Data4[4], g.Data4[5], g.Data4[6], g.Data4[7]);
    
}

void IdlToXml(int /*argc*/, char** argv)
{
    const char * Indent = &g_Indent[NUMBER_OF(g_Indent) - 1];
    ExtractCVMHeader(MapPpmFile(argv[1], TRUE));
    PKNOWNTYPES Type = NULL;
    
    for(Type = Structures->pLastNodeInserted; Type != NULL; Type = Type->Next)
    {
        char GuidAsString[64];
        
        //printf("%s\n", Type->TypeName);
        
        if ((Type->Flags & BTI_ISCOM) == 0
            || (Type->Flags & BTI_HASGUID) == 0)
            continue;
        
        //
        // skip anything out of publics (hacky..)
        //
        if (strstr(Type->FileName, "\\public\\") != NULL
            || strstr(Type->FileName, "\\PUBLIC\\") != NULL
            || strstr(Type->FileName, "\\Public\\") != NULL
            )
        {
            continue;
        }
        
        //printf("%s\n", Type->FileName);
        
        GuidToString(Type->gGuid, GuidAsString);
        
        printf("%sinterface\n%s__declspec(uuid(\"%s\"))\n%s%s : %s\n",
            Indent, Indent,
            GuidAsString,
            Indent,
            Type->TypeName, Type->BaseType
            );
        printf("%s{\n", Indent);
        Indent -= 4;
        
        //
        // IMethods is a multisz thingy, and then we find those strings in the list of functions.
        //
        // hackety hack..maybe this is what the sortpp author intended,
        // the information is clearly determined during parse, but then not really put in the .ppm
        // sortpp does generate the declarations of the proxies if they are missing, so maybe
        // this is the intended usage..
        for ( char * imeth = Type->IMethods ; *imeth ; imeth += 1 + strlen(imeth) )
        {
            char ProxyFunctionName[MAX_PATH];
            sprintf(ProxyFunctionName, "%s_%s_Proxy", Type->TypeName, imeth);
            PKNOWNTYPES ProxyFunction = GetNameFromTypesList(Functions, ProxyFunctionName);
            if (ProxyFunction == NULL)
            {
                printf("error MemberFunction == NULL (%s, %s)\n", Type->TypeName, imeth);
                continue;
            }
            PCSTR FuncMod = ProxyFunction->FuncMod;
            if (FuncMod == NULL)
                FuncMod = "";
            if (strcmp(FuncMod, "__stdcall") == 0)
                FuncMod = "";
            printf("%s%s%s%s%s%s(\n%s",
                Indent, ProxyFunction->FuncRet,
                (FuncMod[0] != 0) ? " " : "",
                (FuncMod[0] != 0) ? FuncMod : " ",
                (FuncMod[0] != 0) ? " " : "",
                imeth,
                Indent - 4
                );
            Indent -= 4;
            PFUNCINFO Parameter = ProxyFunction->pfuncinfo;
            if (Parameter != NULL)
            {
                // skip the this pointer
                bool comma = false;
                for (Parameter = Parameter->pfuncinfoNext; Parameter != NULL ; Parameter = Parameter->pfuncinfoNext )
                {
                    if (comma)
                    {
                        printf(",\n%s", Indent);
                    }
                    comma = true;
                    switch (Parameter->tkDirection)
                    {
                    default:
                    case TK_NONE:
                        break;
                    case TK_IN:
                        printf("[in] ");
                        break;
                    case TK_OUT:
                        printf("[out] ");
                        break;
                    case TK_INOUT:
                        printf("[in][out] ");
                        break;
                    }
                    //
                    // This seems to be a bug in sortpp, it only has the notion of there being
                    // up to occurences of "const" or "volatile", but any number of stars?
                    // C/C++ and perhaps are .idl more general than that.
                    //
                    switch (Parameter->tkPreMod)
                    {
                    default:
                    case TK_NONE:
                        break;
                    case TK_CONST:
                        printf("const ");
                        break;
                    case TK_VOLATILE:
                        printf("volatile ");
                        break;
                    }
                    printf(" %s ", Parameter->sType);
                    for (int IndLevel = Parameter->IndLevel ; IndLevel != 0 ; --IndLevel)
                    {
                        printf(" * ");
                    }
                    switch (Parameter->tkPostMod)
                    {
                    default:
                    case TK_NONE:
                        break;
                    case TK_CONST:
                        printf("const ");
                        break;
                    case TK_VOLATILE:
                        printf("volatile ");
                        break;
                    }
                    printf(Parameter->sName);
                }
            }
            printf("\n%s);\n", Indent);
            Indent += 4;
        }
        Indent += 4;
        printf("%s};\n\n", Indent);
    }
}

int __cdecl main(int argc, char** argv)
{
    IdlToXml(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\user32detours.cpp ===
#include "stdinc.h"
#include "detours.h"
#include "user32detours.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof(*x))

namespace User32Trampolines
{
    bool fInitialized = false;
    CSimpleMap<CString, bool> m_ItemMap;

    HKEY g_hkLocalMachine = NULL;
    HKEY g_hkClasses = NULL;
    HKEY g_hkCurrentUser = NULL;
    HKEY g_hkRedirectionRoot = NULL;
    HKEY g_hkUsers = NULL;
    GUID g_uuidRedirection;

    HKEY RemapRegKey(HKEY);

    extern "C" {
        DETOUR_TRAMPOLINE(
            ATOM WINAPI Real_RegisterClassW(CONST WNDCLASSW *lpWndClass),
            RegisterClassW);
        
        DETOUR_TRAMPOLINE(
            ATOM WINAPI Real_RegisterClassA(CONST WNDCLASSA *lpWndClass),
            RegisterClassA);
        
        DETOUR_TRAMPOLINE(
            ATOM WINAPI Real_RegisterClassExW(CONST WNDCLASSEXW *),
            RegisterClassExW);
        
        DETOUR_TRAMPOLINE(
            ATOM WINAPI Real_RegisterClassExA(CONST WNDCLASSEXA *),
            RegisterClassExA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegOpenKeyW ( IN HKEY hKey, IN LPCWSTR lpSubKey, OUT PHKEY phkResult ),
            RegOpenKeyW);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegOpenKeyA ( IN HKEY hKey, IN LPCSTR lpSubKey, OUT PHKEY phkResult ),
            RegOpenKeyA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegOpenKeyExW ( IN HKEY hKey, IN LPCWSTR lpSubKey, DWORD, REGSAM, PHKEY),
            RegOpenKeyExW);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegOpenKeyExA ( IN HKEY hKey, IN LPCSTR lpSubKey, DWORD, REGSAM, PHKEY),
            RegOpenKeyExA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegSetValueExA (HKEY,LPCSTR,DWORD,DWORD,CONST BYTE*,DWORD),
            RegSetValueExA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegSetValueExW (HKEY,LPCWSTR,DWORD,DWORD,CONST BYTE*,DWORD),
            RegSetValueExW);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD),
            RegSetValueW);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD),
            RegSetValueA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegQueryValueExA(HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD),
            RegQueryValueExA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD),
            RegQueryValueExW);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG),
            RegQueryValueA);
        
        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG),
            RegQueryValueW);

        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegCreateKeyW(HKEY, PWSTR, PHKEY),
            RegCreateKeyW);

        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegCreateKeyA(HKEY, PSTR, PHKEY),
            RegCreateKeyA);

        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegCreateKeyExW(HKEY, PCWSTR, DWORD, PCWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD),
            RegCreateKeyExW);

        DETOUR_TRAMPOLINE(
            LONG APIENTRY Real_RegCreateKeyExA(HKEY, PCSTR, DWORD, PCSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD),
            RegCreateKeyExA);
    }
    
};

//
// Remap from a well-known registry value to our internal ones.
//
HKEY
User32Trampolines::RemapRegKey(HKEY hKey)
{
    if (hKey == HKEY_CLASSES_ROOT) return User32Trampolines::g_hkClasses;
    else if (hKey == HKEY_CURRENT_USER) return User32Trampolines::g_hkCurrentUser;
    else if (hKey == HKEY_LOCAL_MACHINE) return User32Trampolines::g_hkLocalMachine;
    else if (hKey == HKEY_USERS) return User32Trampolines::g_hkUsers;
    else return hKey;
}

LONG APIENTRY
User32Trampolines::InternalRegSetValueA (
                                 IN HKEY hKey,
                                 IN PCSTR lpSubKey,
                                 IN DWORD dwType,
                                 IN PCSTR lpData,
                                 IN DWORD cbData
                                 )
{
    hKey = User32Trampolines::RemapRegKey(hKey);
    return Real_RegSetValueA(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG APIENTRY
User32Trampolines::InternalRegSetValueW (
                                 IN HKEY hKey,
                                 IN PCWSTR lpSubKey,
                                 IN DWORD dwType,
                                 IN PCWSTR lpData,
                                 IN DWORD cbData
                                 )
{
    hKey = User32Trampolines::RemapRegKey(hKey);
    return Real_RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG
APIENTRY
User32Trampolines::InternalRegSetValueExA (
   IN HKEY hKey,
   IN LPCSTR lpValueName,
   IN DWORD Reserved,
   IN DWORD dwType,
   IN CONST BYTE* lpData,
   IN DWORD cbData
   )
{
    //
    // Always translate on a set.
    //
    hKey = User32Trampolines::RemapRegKey(hKey);
    return Real_RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}


LONG
APIENTRY
User32Trampolines::InternalRegSetValueExW (
   IN HKEY hKey,
   IN LPCWSTR lpValueName,
   IN DWORD Reserved,
   IN DWORD dwType,
   IN CONST BYTE* lpData,
   IN DWORD cbData
   )
{
    hKey = User32Trampolines::RemapRegKey(hKey);
    return Real_RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}


LONG APIENTRY User32Trampolines::InternalRegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    //
    // Opening a key remaps the hKey to our set of values if possible first.  If that
    // fails, then try the unremapped version to read from the 'real' registry.
    //
    ULONG ulResult;

    ulResult = Real_RegOpenKeyA(RemapRegKey(hKey), lpSubKey, phkResult);
    if (ulResult != 0)
    {
        ulResult = Real_RegOpenKeyA(hKey, lpSubKey, phkResult);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{ 
    //
    // Opening a key remaps the hKey to our set of values if possible first.  If that
    // fails, then try the unremapped version to read from the 'real' registry.
    //
    ULONG ulResult;

    ulResult = Real_RegOpenKeyW(RemapRegKey(hKey), lpSubKey, phkResult);
    if (ulResult != 0)
    {
        ulResult = Real_RegOpenKeyW(hKey, lpSubKey, phkResult);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegCreateKeyA(HKEY hk, PSTR ps, PHKEY phk)
{
    return Real_RegCreateKeyA(RemapRegKey(hk), ps, phk);
}

LONG APIENTRY User32Trampolines::InternalRegCreateKeyExA(HKEY a, PCSTR b, DWORD c, PCSTR d, DWORD e, REGSAM f, LPSECURITY_ATTRIBUTES g, PHKEY h, PDWORD i)
{
    return Real_RegCreateKeyExA(RemapRegKey(a), b, c, d, e, f, g, h, i);
}

LONG APIENTRY User32Trampolines::InternalRegCreateKeyW(HKEY hk, PWSTR ps, PHKEY phk)
{
    return Real_RegCreateKeyW(RemapRegKey(hk), ps, phk);
}

LONG APIENTRY User32Trampolines::InternalRegCreateKeyExW(HKEY a, PCWSTR b, DWORD c, PCWSTR d, DWORD e, REGSAM f, LPSECURITY_ATTRIBUTES g, PHKEY h, PDWORD i)
{
    return Real_RegCreateKeyExW(RemapRegKey(a), b, c, d, e, f, g, h, i);
}

LONG APIENTRY User32Trampolines::InternalRegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{ 
    //
    // Opening a key remaps the hKey to our set of values if possible first.  If that
    // fails, then try the unremapped version to read from the 'real' registry.
    //
    ULONG ulResult;

    ulResult = Real_RegOpenKeyExA(RemapRegKey(hKey), lpSubKey, ulOptions, samDesired, phkResult);
    if (ulResult != 0)
    {
        ulResult = Real_RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegOpenKeyExW (
                                                IN HKEY hKey,
                                                IN LPCWSTR lpSubKey,
                                                IN DWORD ulOptions,
                                                IN REGSAM samDesired,
                                                OUT PHKEY phkResult
                                                )
{ 
    //
    // Opening a key remaps the hKey to our set of values if possible first.  If that
    // fails, then try the unremapped version to read from the 'real' registry.
    //
    ULONG ulResult;

    ulResult = Real_RegOpenKeyExW(RemapRegKey(hKey), lpSubKey, ulOptions, samDesired, phkResult);
    if (ulResult != 0)
    {
        ulResult = Real_RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegQueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpValue,
    PLONG pcbData)
{
    ULONG ulResult;

    ulResult = Real_RegQueryValueA(RemapRegKey(hKey), lpSubKey, lpValue, pcbData);
    if (ulResult != 0)
    {
        ulResult = Real_RegQueryValueA(hKey, lpSubKey, lpValue, pcbData);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegQueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG pcbData)
{
    ULONG ulResult;

    ulResult = Real_RegQueryValueW(RemapRegKey(hKey), lpSubKey, lpValue, pcbData);
    if (ulResult != 0)
    {
        ulResult = Real_RegQueryValueW(hKey, lpSubKey, lpValue, pcbData);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegQueryValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD pdwData
    )
{
    ULONG ulResult;

    ulResult = Real_RegQueryValueExA(RemapRegKey(hKey), lpValueName, lpReserved, lpType, lpData, pdwData);
    if (ulResult != 0)
    {
        ulResult = Real_RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, pdwData);
    }
    return ulResult;
}

LONG APIENTRY User32Trampolines::InternalRegQueryValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD pdwData
    )
{
    ULONG ulResult;

    ulResult = Real_RegQueryValueExW(RemapRegKey(hKey), lpValueName, lpReserved, lpType, lpData, pdwData);
    if (ulResult != 0)
    {
        ulResult = Real_RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, pdwData);
    }
    return ulResult;
}



BOOL
User32Trampolines::GetRedirectedStrings(CSimpleList<CString>& Strings)
{
    CSimpleList<CString> FoundStrings;
    m_ItemMap.GetKeys(FoundStrings);
    
    for ( SIZE_T sz = 0; sz < FoundStrings.Size(); sz++ )
    {
        SIZE_T c = 0;
        
        for ( c = 0; c < Strings.Size(); c++ )
        {
            if ( lstrcmpiW(Strings[c], FoundStrings[sz]) == 0 )
                break;
        }
        
        //
        // Not found?
        //
        if ( c == Strings.Size() )
            Strings.Append(FoundStrings[sz]);
    }
    
    return TRUE;
}


void
User32Trampolines::ClearRedirections()
{
    m_ItemMap.Clear();
}


BOOL
User32Trampolines::Initialize()    
{
    if ( fInitialized )
        return TRUE;

    fInitialized = TRUE;

    //
    // Set up registry redirection before actually doing redirection.  Generate
    // a virtual-root that all calls will be rerouted to first.  Do this by
    // generating a GUIDized path off of HKCU.
    //
    LPOLESTR pstrGuid;
    WCHAR wchRegPath[MAX_PATH];
    ULONG ulResult;
    HKEY hkDump;

    if (FAILED(CoCreateGuid(&g_uuidRedirection)))
        return FALSE;

    StringFromCLSID(g_uuidRedirection, &pstrGuid);
    _snwprintf(wchRegPath, MAX_PATH, L"ManBuilderRedirect\\%ls", pstrGuid);

    //
    // Create root key.  For purposes of argument, we'll allow all access to all
    // subchildren, no matter what.  If we were a real app, we'd take into account
    // propagating security down the heirarchy, but for now, we don't really care.
    //
    ulResult = ::RegCreateKeyExW(
        HKEY_CURRENT_USER, 
        wchRegPath, 
        0, 
        NULL, 
        0, 
        KEY_ALL_ACCESS, 
        NULL, 
        &User32Trampolines::g_hkRedirectionRoot, 
        NULL);
    
    if (ulResult != 0) return FALSE;

    //
    // Generate all the pseudo-roots for the various keys
    //
    struct {
        HKEY* phkTarget;
        PCWSTR pcwszKeyName;
    } s_KeyRedirections[] = {
        { &User32Trampolines::g_hkClasses, L"HKEY_CLASSES_ROOT" },
        { &User32Trampolines::g_hkCurrentUser, L"HKEY_CURRENT_USER" },
        { &User32Trampolines::g_hkLocalMachine, L"HKEY_LOCAL_MACHINE" },
        { &User32Trampolines::g_hkUsers, L"HKEY_USERS" }
    };

    for (ULONG ul = 0; ul < NUMBER_OF(s_KeyRedirections); ul++)
    {
        ulResult = RegCreateKeyExW(
            g_hkRedirectionRoot,
            s_KeyRedirections[ul].pcwszKeyName,
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            s_KeyRedirections[ul].phkTarget,
            NULL);

        if (ulResult != 0) return FALSE;
    }

    //
    // Let's also create (but close) the following 'special' keys for COM:
    // - CLSID
    // - Interface
    //
    ulResult = RegCreateKeyExW(User32Trampolines::g_hkClasses, L"CLSID", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkDump, NULL);
    if (ulResult != 0)
        RegCloseKey(hkDump);

    ulResult = RegCreateKeyExW(User32Trampolines::g_hkClasses, L"Interface", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkDump, NULL);
    if (ulResult != 0)
        RegCloseKey(hkDump);

    ulResult = RegCreateKeyExW(User32Trampolines::g_hkClasses, L"TypeLib", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkDump, NULL);
    if (ulResult != 0)
        RegCloseKey(hkDump);



#define MAP(f) { (PBYTE)Real_##f, (PBYTE)Internal##f }
    
    PBYTE Remapping[][2] = {
        MAP(RegisterClassW),
            MAP(RegisterClassExW),
            MAP(RegisterClassA),
            MAP(RegisterClassExA),
            MAP(RegOpenKeyW),
            MAP(RegOpenKeyA),
            MAP(RegOpenKeyExW),
            MAP(RegOpenKeyExA),
            MAP(RegSetValueExA),
            MAP(RegSetValueExW),
            MAP(RegSetValueA),
            MAP(RegSetValueW),
            MAP(RegQueryValueExA),
            MAP(RegQueryValueExW),
            MAP(RegQueryValueW),
            MAP(RegQueryValueA),
            MAP(RegCreateKeyA),
            MAP(RegCreateKeyW),
            MAP(RegCreateKeyExA),
            MAP(RegCreateKeyExW)
    };
    
    //
    // All redirections
    //
    for (int i = 0; i < NUMBER_OF(Remapping); i++)
    {
        DetourFunctionWithTrampoline(Remapping[i][0], Remapping[i][1]);
    }

    return TRUE;
}

ATOM WINAPI
User32Trampolines::InternalRegisterClassA(CONST WNDCLASSA * lpWndClass)
{
    m_ItemMap[CString(lpWndClass->lpszClassName)] = true;
    return Real_RegisterClassA(lpWndClass);
}

ATOM WINAPI
User32Trampolines::InternalRegisterClassW(CONST WNDCLASSW * lpWndClass)
{
    m_ItemMap[CString(lpWndClass->lpszClassName)] = true;
    return Real_RegisterClassW(lpWndClass);
}

ATOM WINAPI
User32Trampolines::InternalRegisterClassExA(CONST WNDCLASSEXA * lpWndClass)
{
    m_ItemMap[CString(lpWndClass->lpszClassName)] = true;
    return Real_RegisterClassExA(lpWndClass);
}

ATOM WINAPI
User32Trampolines::InternalRegisterClassExW(CONST WNDCLASSEXW * lpWndClass)
{
    m_ItemMap[CString(lpWndClass->lpszClassName)] = true;
    return Real_RegisterClassExW(lpWndClass);
}

namespace User32Trampolines {

    void RegDestroyKeyTree(HKEY hk, PWSTR pwszBuffer)
    {
        bool fCreatedBuffer = false;
        PWSTR strKeyName;
        
        if (pwszBuffer == NULL)
        {
            fCreatedBuffer = true;
            pwszBuffer = new WCHAR[MAX_PATH];
        }
        
        pwszBuffer[0] = UNICODE_NULL;
        
        while (1)
        {
            HKEY hkSub;
            
            if (ERROR_SUCCESS == RegEnumKeyW(hk, 0, pwszBuffer, MAX_PATH))
            {
                if ((strKeyName = new WCHAR[lstrlenW(pwszBuffer) + 1]) == NULL)
                    break;

                lstrcpyW(strKeyName, pwszBuffer);

                if (ERROR_SUCCESS == RegOpenKeyW(hk, pwszBuffer, &hkSub))
                {
                    RegDestroyKeyTree(hkSub, pwszBuffer);
                }

                RegDeleteKeyW(hk, strKeyName);

                delete[] strKeyName;
            } 
            else 
            {
                break;
            }
        }
        
        if (fCreatedBuffer && pwszBuffer)
        {
            delete [] pwszBuffer;
            pwszBuffer = NULL;
            fCreatedBuffer = false;
        }
    }

    BOOL Stop()
    {
        PHKEY hkToClose[] = {
            &g_hkClasses,
            &g_hkLocalMachine,
            &g_hkUsers,
            &g_hkCurrentUser,
        };

        PBYTE Remapping[][2] = {
            MAP(RegisterClassW),
                MAP(RegisterClassExW),
                MAP(RegisterClassA),
                MAP(RegisterClassExA),
                MAP(RegOpenKeyW),
                MAP(RegOpenKeyA),
                MAP(RegOpenKeyExW),
                MAP(RegOpenKeyExA),
                MAP(RegSetValueExA),
                MAP(RegSetValueExW),
                MAP(RegSetValueA),
                MAP(RegSetValueW),
                MAP(RegQueryValueExA),
                MAP(RegQueryValueExW),
                MAP(RegQueryValueW),
                MAP(RegQueryValueA),
                MAP(RegCreateKeyA),
                MAP(RegCreateKeyW),
                MAP(RegCreateKeyExA),
                MAP(RegCreateKeyExW)
        };

        int i;

        //
        // Close open keys
        //
        for (i = 0; i < NUMBER_OF(hkToClose); i++)
        {
            if (*hkToClose[i] != NULL)
            {
                RegCloseKey(*hkToClose[i]);
                *hkToClose[i] = NULL;
            }
        }

        //
        // Undo detours
        //  
        for (int i = 0; i < NUMBER_OF(Remapping); i++)
        {
            DetourRemove(Remapping[i][0], Remapping[i][1]);
        }

        LPOLESTR psz;
        WCHAR wchKeyNameBuffer[MAX_PATH];
        if (SUCCEEDED(StringFromCLSID(User32Trampolines::g_uuidRedirection, &psz)))
        {
            _snwprintf(wchKeyNameBuffer, MAX_PATH, L"ManBuilderRedirect\\%ls", psz);

            // Destroy the tree pointed at
            RegDestroyKeyTree(User32Trampolines::g_hkRedirectionRoot, NULL);

            // Close our handle
            RegCloseKey(User32Trampolines::g_hkRedirectionRoot);

            // And try to delete the key
            RegDeleteKeyW(HKEY_CURRENT_USER, wchKeyNameBuffer);

            // And maybe delete the parent key
            RegDeleteKeyW(HKEY_CURRENT_USER, L"ManBuilderRedirect");

            // Free guid string memory, too
            CoTaskMemFree(psz);
        }

        return TRUE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\merge_placefiles\strtok_r.h ===
/* reentrant strtok */

#pragma once

#if defined(__cplusplus)
extern "C"
{
#endif

char * __cdecl strtok_r (
	char * string,
	const char * control,
	char ** nextoken
	);

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\merge_placefiles\strtok_r.c ===
#define NULL 0
#pragma warning(disable:4057)

/* reentrant strtok, copied/pasted from crt */
char * __cdecl strtok_r (
	char * string,
	const char * control,
	char ** nextoken
	)
{
	unsigned char *str;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

	/* Clear control map */
	for (count = 0; count < 32; count++)
		map[count] = 0;

	/* Set bits in delimiter table */
	do {
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
	} while (*ctrl++);

	/* Initialize str. If string is NULL, set str to the saved
	 * pointer (i.e., continue breaking tokens out of the string
	 * from the last strtok call) */
	if (string)
		str = string;
	else
		str = *nextoken;

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets str to point to the terminal
	 * null (*str == '\0') */
	while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
		str++;

	string = str;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *str ; str++ )
		if ( map[*str >> 3] & (1 << (*str & 7)) ) {
			*str++ = '\0';
			break;
		}

	/* Update nextoken */
	*nextoken = str;

	/* Determine if a token has been found. */
	if ( string == str )
		return NULL;
	else
		return string;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\manbuilder\detours\include\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.4. (Build 45)
//
//  Copyright 1995-2001, Microsoft Corporation
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

//////////////////////////////////////////////////////////////////////////////
//
#ifdef IMAGEAPI // defined by IMAGEHLP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
                                       IN HANDLE hFile,
                                       IN PSTR ImageName,
                                       IN PSTR ModuleName,
                                       IN DWORD BaseOfDll,
                                       IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
                                          IN DWORD dwAddr,
                                          OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
                                           IN LPSTR Name,
                                           OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
                                   IN LPSTR pszDllPath,
                                   IN LPSTR pszSymbolPath);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                   hProcess;
    HMODULE                  hImageHlp;
    PF_ImagehlpApiVersionEx  pfImagehlpApiVersionEx;
    PF_SymInitialize         pfSymInitialize;
    PF_SymSetOptions         pfSymSetOptions;
    PF_SymGetOptions         pfSymGetOptions;
    PF_SymLoadModule         pfSymLoadModule;
    PF_SymGetModuleInfo      pfSymGetModuleInfo;
    PF_SymGetSymFromName     pfSymGetSymFromName;
    PF_BindImage             pfBindImage;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

//////////////////////////////////////////////////////////////////////////////
//
class CDetourEnableWriteOnCodePage
{
public:
    CDetourEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
    {
        m_pbCode = pbCode;
        m_cbCode = cbCode;
        m_dwOldPerm = 0;
        m_hProcess = GetCurrentProcess();

        if (m_pbCode && m_cbCode) {
            if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
                return;
            }
            if (!VirtualProtect(pbCode,
                                cbCode,
                                PAGE_EXECUTE_READWRITE,
                                &m_dwOldPerm)) {
                return;
            }
        }
    }

    ~CDetourEnableWriteOnCodePage()
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            DWORD dwTemp = 0;
            if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
                return;
            }
            if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
                return;
            }
        }
    }

    BOOL SetPermission(DWORD dwPerms)
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            m_dwOldPerm = dwPerms;
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsValid(VOID)
    {
        return m_pbCode && m_cbCode && m_dwOldPerm;
    }

private:
    HANDLE  m_hProcess;
    PBYTE   m_pbCode;
    LONG    m_cbCode;
    DWORD   m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
inline PBYTE DetourGenMovEax(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB8;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBB;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEcx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB9;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBA;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBE;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBF;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBD;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBC;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPush(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0x68;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPushad(PBYTE pbCode)
{
    *pbCode++ = 0x60;
    return pbCode;
}

inline PBYTE DetourGenPopad(PBYTE pbCode)
{
    *pbCode++ = 0x61;
    return pbCode;
}

inline PBYTE DetourGenJmp(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE9;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenCall(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE8;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenBreak(PBYTE pbCode)
{
    *pbCode++ = 0xcc;
    return pbCode;
}

inline PBYTE DetourGenRet(PBYTE pbCode)
{
    *pbCode++ = 0xc3;
    return pbCode;
}

inline PBYTE DetourGenNop(PBYTE pbCode)
{
    *pbCode++ = 0x90;
    return pbCode;
}
#endif DETOURS_INTERAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\mkdir_bigpath\mkdir.cpp ===
//
// Simple wrapper around GetFullPathname and CreateDirectory that converts to \\? form,
// and creates multiple levels.
//
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"mkdir_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096] = { 0 };
    WCHAR rgchWin32Error[4096] = { 0 };

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        _snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error) - 1, L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    PWSTR p = NULL;
    SIZE_T i = 0;

    if (argc != 2)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <directory-to-create>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1 + (1UL << 15));
    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
    {
        ::ReportFailure("FusionpConvertToBigPath\n");
        goto Exit;
    }

    if (!FusionpSkipBigPathRoot(&arg1[0], &i))
    {
        ::ReportFailure("FusionpSkipBigPathRoot\n");
        goto Exit;
    }
    p = &arg1[i];
    //printf("%ls\n", &arg1[0]);
    while (*p != 0)
    {
        p += wcscspn(p, L"\\/");
        *p = 0;
        if (!CreateDirectoryW(&arg1[0], NULL))
        {
            if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
            {
                ::ReportFailure("CreateDirectoryW\n");
                goto Exit;
            }
            ULONG FileAttributes;
            FileAttributes = GetFileAttributesW(&arg1[0]);
            if (FileAttributes != 0xffffff && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                ::FusionpSetLastWin32Error(ERROR_ALREADY_EXISTS);
                ::ReportFailure("FileInsteadOfDirectoryAlreadyExists\n");
                goto Exit;
            }
        }
        printf("%ls\n", &arg1[0]);
        *p = '\\';
        p += wcsspn(p, L"\\/");
    }

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\cabinet.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cabinet.cpp

Abstract:

    cabinet management Function calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

#include "msmgen.h"
#include "util.h"

extern BOOL __stdcall SxspDeleteDirectory(const CBaseStringBuffer &rdir);


#include <fci.h>
#include <fdi.h>

#include "msmfci.h"
#include "msmfdi.h"

ERF	erf;
//
// FCI
//
HRESULT InitializeCabinetForWrite()
{
	HFCI			hfci;

	CCAB			cab_parameters;
	client_state	cs;    
    HRESULT         hr = S_OK;    

    // Initialise our internal state
	cs.total_compressed_size = 0;
	cs.total_uncompressed_size = 0;

	set_cab_parameters(&cab_parameters);

	hfci = FCICreate(
		&erf,
		file_placed,
		fci_mem_alloc,
		fci_mem_free,
        fci_open,
        fci_read,
        fci_write,
        fci_close,
        fci_seek,
        fci_delete,
		get_temp_file,
        &cab_parameters,
        &cs
	);

	if (hfci == NULL)
	{
		printf("CAB: FCICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper));

        SETFAIL_AND_EXIT;
	}else
    {
        g_MsmInfo.m_hfci = hfci;
        hfci= NULL;
    }

Exit:    
    return hr;
}

HRESULT AddFileToCabinetW(PCWSTR full_filename, SIZE_T CchFullFileName, PCWSTR relative_filename, SIZE_T CchRelativePath)
{
    HRESULT hr = S_OK;
    CHAR pszpath[MAX_PATH];
    CHAR pszfilename[MAX_PATH];

    WideCharToMultiByte(
        CP_ACP, 0, full_filename, (int)CchFullFileName,
        pszpath, MAX_PATH, NULL, NULL);
    pszpath[CchFullFileName] = '\0';

    WideCharToMultiByte(
        CP_ACP, 0, relative_filename, (int)CchRelativePath,
        pszfilename, MAX_PATH, NULL, NULL);
    pszfilename[CchRelativePath] = '\0';

	if (FALSE == FCIAddFile(
		    g_MsmInfo.m_hfci,
		    pszpath,                /* filename to add : fully qualified filename */
		    pszfilename,            /* file name in cabinet file : relative filepath */
		    FALSE,                  /* file is not executable */
		    get_next_cabinet,
		    progress,
		    get_open_info,
            COMPRESSION_TYPE))	
    {
        fprintf(stderr, "adding file %s to the cabinet failed\n", pszpath);
        SETFAIL_AND_EXIT;
    }

Exit:    
    return hr;
}

HRESULT AddFileToCabinetA(PCSTR full_filename, SIZE_T CchFullFileName, PCSTR relative_filename, SIZE_T CchRelativePath)
{
    HRESULT hr = S_OK;
    WCHAR szFullFilename[MAX_PATH]; 
    WCHAR szRelativeFilename[MAX_PATH];

    swprintf(szFullFilename, L"%S", full_filename);
    swprintf(szRelativeFilename, L"%S", relative_filename);

    IFFAILED_EXIT(AddFileToCabinetW(szFullFilename, CchFullFileName, szRelativeFilename, CchRelativePath));

Exit:
    return hr;
}
HRESULT CloseCabinet()
{
    HRESULT hr = S_OK; 
    CurrentAssemblyReset;

	if (FALSE == FCIFlushCabinet(
		    g_MsmInfo.m_hfci,
		    FALSE,
		    get_next_cabinet,
		    progress))
    {
        fprintf(stderr, "Flush Cabinet failed\n");
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (FCIDestroy(g_MsmInfo.m_hfci) != TRUE)
    { 
        SETFAIL_AND_EXIT;	
    }
    else
        g_MsmInfo.m_hfci = NULL;

Exit:    
	return hr;
}

//
// FDI
//
HRESULT MoveFilesInCabinetA(char * sourceCabinet)
{
    HRESULT         hr = S_OK;
	HFDI	        hfdi = NULL;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR         hf = -1;
    DWORD           num;      
extern char dest_dir[MAX_PATH];

	hfdi = FDICreate(
		fdi_mem_alloc,
		fdi_mem_free,
		fdi_file_open,
		fdi_file_read,
		fdi_file_write,
		fdi_file_close,
		fdi_file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		printf("FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		SETFAIL_AND_EXIT;
	}


	hf = fdi_file_open(
		sourceCabinet,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		printf("Unable to open '%s' for input\n", sourceCabinet);
		SETFAIL_AND_EXIT;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * It is not a cabinet!, BUT it must be since it is named as MergeModule.cab in a msm
		 */		

		printf(
			"FDIIsCabinet() failed: '%s' is not a cabinet\n",
			sourceCabinet
		);

        SETFAIL_AND_EXIT;
	}
	else
	{
		_close((int)hf);
#ifdef MSMGEN_TEST
		printf(
			"Information on cabinet file '%s'\n"
			"   Total length of cabinet file : %d\n"
			"   Number of folders in cabinet : %d\n"
			"   Number of files in cabinet   : %d\n"
			"   Cabinet set ID               : %d\n"
			"   Cabinet number in set        : %d\n"
			"   RESERVE area in cabinet?     : %s\n"
			"   Chained to prev cabinet?     : %s\n"
			"   Chained to next cabinet?     : %s\n"
			"\n",
			sourceCabinet,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? "yes" : "no",
			fdici.hasprev == TRUE ? "yes" : "no",
			fdici.hasnext == TRUE ? "yes" : "no"
		);
#endif
        if ((fdici.fReserve == TRUE)|| (fdici.hasprev == TRUE) || (fdici.hasnext == TRUE))
        {
            printf("ERROR file format : MSI 1.5 support one and only one cabinet in MergeModule.cab!\n");
            SETFAIL_AND_EXIT;
        }
	}

    //
    // create a temporary directory for use
    //
    num = ExpandEnvironmentStringsA(MSM_TEMP_CABIN_DIRECTORY_A, dest_dir, NUMBER_OF(dest_dir));
    if ( (num == 0) || (num > NUMBER_OF(dest_dir)))
        SETFAIL_AND_EXIT;

    DWORD dwAttribs = GetFileAttributesA(dest_dir);
    if (dwAttribs != (DWORD)(-1))
    {
        if ((dwAttribs &  FILE_ATTRIBUTE_DIRECTORY) == 0 )        
            SETFAIL_AND_EXIT;

        CStringBuffer sb; 
        WCHAR wdir[MAX_PATH];

        num = ExpandEnvironmentStringsW(MSM_TEMP_CABIN_DIRECTORY_W, wdir, NUMBER_OF(wdir));
        if ( (num == 0) || (num > NUMBER_OF(wdir)))
            SETFAIL_AND_EXIT;

        IFFALSE_EXIT(sb.Win32Assign(wdir, wcslen(wdir)));
        IFFALSE_EXIT(SxspDeleteDirectory(sb));
    }

    IFFALSE_EXIT(CreateDirectoryA(dest_dir, NULL));
    char * p = NULL;
    char sourceDir[MAX_PATH];

    p = strrchr(sourceCabinet, '\\');
    ASSERT_NTC(p != NULL);
    p ++; // skip "\"
    strncpy(sourceDir, sourceCabinet, p - sourceCabinet);
    sourceDir[p - sourceCabinet] = '\0';

	if (TRUE != FDICopy(
		hfdi,
		p,
		sourceDir,
		0,
		fdi_notification_function,
		NULL,
		NULL))
	{
		printf(
			"FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		printf(
			"FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return FALSE;
	}
    hfdi = NULL;

Exit:
    if (hfdi != NULL)
	    (void) FDIDestroy(hfdi);
    if ( hf != -1)
        _close((int)hf);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\mjgcopy\mjgcopy.cpp ===
#include "stdinc.h" // actually from dll\whistler directory
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>
#pragma warning(disable: 4663)
#pragma warning(pop)
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmname.h"
#include "util.h"
#include "filestream.cpp"
#include "sxsapi.h"
#include "fusiontrace.h"
#include "cresourcestream.cpp"
#include "cmemorystream.cpp"
#include "wintrust.h"
#include "softpub.h"
#include "perfclocking.h"
#include "strongname.h"
#include "fusionversion.h"
#include "fusionhash.h"
#include "fusiondeque.h"
#undef NUMBER_OF
#include "..\getpdbname\lib.h"
#include "..\getpdbname\lib.c"
#include "setfilepointerex.c"
#include "getfilesizeex.c"

BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }

void ReportFailure(const char szFormat[], ...);
void TraceFailureContext(const char szFormat[], ...);

PCWSTR g_pszImage = L"mjgcopy";

CRITICAL_SECTION g_cs;

ULONGLONG g_FilesCopied = 0;
ULONGLONG g_BytesCopied = 0;
ULONGLONG g_FilesLinked = 0;
ULONGLONG g_DirectoriesCopied = 0;
ULONGLONG g_CopiesSkipped = 0;
ULONGLONG g_LinksSkipped = 0;
ULONGLONG g_FileCopiesProcessed = 0;
ULONGLONG g_FileLinksProcessed = 0;
ULONGLONG g_DirScansProcessed = 0;

ULONGLONG g_BytesToCopy = 0;

bool g_fAnnounceDirectories = true;
bool g_fAnnounceCopies = false;
bool g_fAnnounceDeletes = true;
bool g_fAnnounceLinks = true;
bool g_fAnnounceSkips = false;
bool g_fSilent = false;
bool g_fShowProgress = true;

HANDLE g_hIoCompletionPort = NULL;
HANDLE g_hWorkItemDoneEvent = INVALID_HANDLE_VALUE;

DWORD g_dwDestinationSectorsPerCluster = 0;
DWORD g_dwDestinationBytesPerSector = 0;
DWORD g_dwDestinationNumberOfFreeClusters = 0;
DWORD g_dwDestinationTotalNumberOfClusters = 0;

ULONG g_nThreads = 3;

HANDLE g_rghThreads[32];

class CFileCopy;
class CFileLink;
class CDir;

#define MAX_RETRIES (5)
#define WAIT_NOTIFY_COUNTER (50)

// BOOL ScanAndCopyDir(PCWSTR szSource, PCWSTR szDest);
BOOL BuildDirList(const CBaseStringBuffer &rbuffSource, const CBaseStringBuffer &rbuffDestination);
BOOL MakeDirectoryStructure();
BOOL QueueDirScans();
BOOL QueueFileCopies();
BOOL QueueFileLinks();
DWORD WINAPI WorkerThreadProc(LPVOID pvParameter);
void ComputeTimeDeltas(const SYSTEMTIME &rstStart, const SYSTEMTIME &rstEnd, SYSTEMTIME &rstDelta);
BOOL ProcessFileCopy(CFileCopy *pFileCopy, bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer);
BOOL ProcessFileLink(CFileLink *pFileLink, bool &rfReQueue);
BOOL ProcessDirScan(CDir *pDir, bool &rfReQueue);
BOOL ResumeWorkerThreads();
BOOL SuspendWorkerThreads();
BOOL
WaitForWorkersToComplete(
    ULONGLONG &rullCounter,
    ULONGLONG ullLimit,
    PCSTR pszOperationName
    );

BOOL
MyCopyFile(
    BYTE *pBuffer,
    DWORD cbBuffer,
    PCWSTR lpExistingFileName,
    PCWSTR lpNewFileName,
    BOOL fFailIfExists,
    HANDLE &rhNewFileHandle,
    bool &rfRequeue
    );

class CEntry
{
private:
    CEntry(const CEntry&); // deliberately not implemented
    void operator=(const CEntry&); // deliberately not implemented
public:
    CEntry() : m_cRetries(0) { }
    ~CEntry() { }

    virtual BOOL BaseDoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer)
    {
        LARGE_INTEGER liStart, liEnd;
        ASSERT_NTC(!rfReQueue);
        ::QueryPerformanceCounter(&liStart);
        BOOL fResult = this->DoYourThing(rfReQueue, pBuffer, cbBuffer);
        if (rfReQueue)
        {
            // Why would we retry if there wasn't a failure?
            ASSERT_NTC(!fResult);
            m_cRetries++;
            if (m_cRetries <= MAX_RETRIES)
                fResult = TRUE;
        }

        if (!fResult)
            TraceFailureContext("executing work item %p\n", this);

        CSxsPreserveLastError ple;
        ::QueryPerformanceCounter(&liEnd);
        ple.Restore();

        m_ullStart = static_cast<ULONGLONG>(liStart.QuadPart);
        m_ullEnd = static_cast<ULONGLONG>(liEnd.QuadPart);

        return fResult;
    }

    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pbBuffer, DWORD cbBuffer) = 0;

    ULONGLONG m_ullStart, m_ullEnd;
    ULONG m_cRetries;
};

class CDir : public CEntry
{
private:
    CDir(const CDir&); // deliberately not implemented
    void operator=(const CDir&); // deliberately not implemented
public:
    CDir() { };
    ~CDir() { };

    BOOL Initialize(const CBaseStringBuffer &rbuffSource, const CBaseStringBuffer &rbuffDestination)
    {
        BOOL fSuccess = FALSE;

        if (!m_buffSource.Win32Assign(rbuffSource))
        {
            TraceFailureContext("initializing CDir instance %p with source \"%ls\"\n", this, static_cast<PCWSTR>(rbuffSource));
            goto Exit;
        }

        if (!m_buffDestination.Win32Assign(rbuffDestination))
        {
            TraceFailureContext("initializing CDir instance %p with destination \"%ls\"\n", this, static_cast<PCWSTR>(rbuffDestination));
            goto Exit;
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *, DWORD) { return ::ProcessDirScan(this, rfReQueue); }

    CStringBuffer m_buffSource;
    CStringBuffer m_buffDestination;
    CDequeLinkage m_linkage;
};

class CFileBase : public CEntry
{
private:
    CFileBase(const CFileBase&); // deliberately not implemented
    void operator=(const CFileBase&); // deliberately not implemented
public:
    CFileBase() : m_fDone(false) { }
    ~CFileBase() { }

    BOOL Initialize(
        CDir *pDir,
        PCWSTR pszFilename,
        FILETIME ftSourceCreationTime,
        FILETIME ftSourceLastAccessTime,
        FILETIME ftSourceLastWriteTime,
        ULONGLONG ullFileIndex,
        ULONGLONG cbSize
        )
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(m_buffFilename.Win32Assign(pszFilename, wcslen(pszFilename)));

        m_ftSourceCreationTime = ftSourceCreationTime;
        m_ftSourceLastAccessTime = ftSourceLastAccessTime;
        m_ftSourceLastWriteTime = ftSourceLastWriteTime;

        m_ullFileIndex = ullFileIndex;
        m_cbSize = cbSize;
        m_pDir = pDir;

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL GetSource(CBaseStringBuffer &rbuff)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(rbuff.Win32Assign(m_pDir->m_buffSource));
        IFW32FALSE_EXIT(rbuff.Win32Append(m_buffFilename));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL GetDestination(CBaseStringBuffer &rbuff)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(rbuff.Win32Assign(m_pDir->m_buffDestination));
        IFW32FALSE_EXIT(rbuff.Win32Append(m_buffFilename));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    CStringBuffer m_buffFilename;
    FILETIME m_ftSourceCreationTime;
    FILETIME m_ftSourceLastAccessTime;
    FILETIME m_ftSourceLastWriteTime;
    ULONGLONG m_ullFileIndex;
    ULONGLONG m_cbSize;
    CDir *m_pDir;
    bool m_fSkipped; // used to avoid skewed statistics about number of bytes copied/sec etc.
    bool m_fDone;

    CDequeLinkage m_linkage;
};

class CFileCopy : public CFileBase
{
public:
    CFileCopy() { }
    ~CFileCopy() { }
    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer) { return ::ProcessFileCopy(this, rfReQueue, pBuffer, cbBuffer); }

    static int __cdecl QSortBySize(const void *param1, const void *param2)
    {
        CFileCopy **pp1 = (CFileCopy **) param1;
        CFileCopy **pp2 = (CFileCopy **) param2;
        CFileCopy *p1 = *pp1;
        CFileCopy *p2 = *pp2;
        int iRet = 0;

        if (p1->m_fSkipped)
        {
            if (p2->m_fSkipped)
            {
                if (p1->m_cbSize < p2->m_cbSize)
                    iRet = 1;
                else if (p1->m_cbSize > p2->m_cbSize)
                    iRet = -1;
                else
                {
                    if (p1->m_ullFileIndex < p2->m_ullFileIndex)
                        iRet = -1;
                    else
                        iRet = 1;
                }
            }
            else
                iRet = -1;
        }
        else
        {
            if (p2->m_fSkipped)
                iRet = 1;
            else
            {
                if (p1->m_cbSize < p2->m_cbSize)
                    iRet = 1;
                else if (p1->m_cbSize > p2->m_cbSize)
                    iRet = -1;
                else
                {
                    if (p1->m_ullFileIndex < p2->m_ullFileIndex)
                        iRet = -1;
                    else
                        iRet = 1;
                }
            }
        }

        return iRet;
    }

private:
    CFileCopy(const CFileCopy &r);
    void operator =(const CFileCopy &r);
};

class CFileLink : public CFileBase
{
public:
    CFileLink() { }
    ~CFileLink() { }
    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer) { return ::ProcessFileLink(this, rfReQueue); }

    BOOL GetSource(CBaseStringBuffer &rbuff);

private:
    CFileLink(const CFileLink &r);
    void operator =(const CFileLink &r);
};


CDeque<CDir, offsetof(CDir, m_linkage)> *g_pDirs = NULL;
CDir **g_prgpDirs = NULL;

CDeque<CFileCopy, offsetof(CFileCopy, m_linkage)> *g_pFileCopies = NULL;
CFileCopy **g_prgpFileCopies = NULL;

CDeque<CFileLink, offsetof(CFileLink, m_linkage)> *g_pFileLinks = NULL;
CFileLink **g_prgpFileLinks = NULL;

class CFileIdHashHelper : public CHashTableHelper<ULONGLONG, ULONGLONG, PCWSTR, CStringBuffer>
{
private:
    CFileIdHashHelper(const CFileIdHashHelper&); // deliberately not implemented
    void operator=(const CFileIdHashHelper&); // deliberately not implemented
public:
    static BOOL HashKey(ULONGLONG keyin, ULONG &rulPseudoKey) { rulPseudoKey = static_cast<ULONG>(keyin); return TRUE; }
    static BOOL CompareKey(ULONGLONG keyin, const ULONGLONG &rtkeystored, bool &rfMatch) { rfMatch = keyin == rtkeystored; return TRUE; }
    static VOID PreInitializeKey(ULONGLONG &rtkeystored) { rtkeystored = 0; }
    static VOID PreInitializeValue(CFileCopy *&rtvaluestored) { rtvaluestored = NULL; }
    static BOOL InitializeKey(ULONGLONG keyin, ULONGLONG &rtkeystored) { rtkeystored = keyin; return TRUE; }
    static BOOL InitializeValue(CFileCopy *vin, CFileCopy *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(CFileCopy *vin, CFileCopy *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeKey(ULONGLONG &rtkeystored) { }
    static VOID FinalizeValue(CFileCopy *&rvstored) { rvstored = NULL; }
};

class CFileIdHashTable : public CHashTable<ULONGLONG, ULONGLONG, CFileCopy *, CFileCopy *, CFileIdHashHelper>
{
private:
    CFileIdHashTable(const CFileIdHashTable&); // deliberately not implemented
    void operator=(const CFileIdHashTable&); // deliberately not implemented
public:
    CFileIdHashTable() { }
    ~CFileIdHashTable() { }
};

CFileIdHashTable *g_pFiles = NULL;

FILE *g_pLogFile = NULL;

BOOL
CFileLink::GetSource(CBaseStringBuffer &rbuff)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer *pbuff = NULL;
    CFileCopy **ppFileCopy = NULL;

    if (!g_pFiles->Find(m_ullFileIndex, ppFileCopy))
    {
        ::ReportFailure("Finding file index %I64u in the file table failed.");
        goto Exit;
    }

    IFW32FALSE_EXIT((*ppFileCopy)->GetDestination(rbuff));

    FN_EPILOG
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;

    SYSTEMTIME stStart, stAfterScan, stAfterDirCreation, stAfterCopies, stAfterLinks, stEnd;
    ULONG i;
    CStringBuffer buffSource;
    CStringBuffer buffDestination;
    int iSource = 0;
    int iDestination = 0;
    SYSTEMTIME stAfterScanDelta, stAfterDirCreationDelta, stAfterCopiesDelta, stAfterLinksDelta, stEndDelta;
    ULONGLONG ullTemp;
    int iArg;
//    DWORD dwRetVal;

    WCHAR rgwchSourceVolumePath[MAX_PATH];
    WCHAR rgwchSourceVolumeName[MAX_PATH];
    DWORD dwSourceVolumeSerialNumber;
    DWORD dwSourceMaximumComponentLength;
    DWORD dwSourceFileSystemFlags;
    WCHAR rgwchSourceFileSystemNameBuffer[MAX_PATH];
    WCHAR rgwchSourceRemoteName[MAX_PATH];
    DWORD dwSourceRemoteNameLength = NUMBER_OF(rgwchSourceRemoteName);
    UINT uiSourceDriveType;

    WCHAR rgwchDestinationVolumePath[MAX_PATH];
    WCHAR rgwchDestinationVolumeName[MAX_PATH];
    DWORD dwDestinationVolumeSerialNumber;
    DWORD dwDestinationMaximumComponentLength;
    DWORD dwDestinationFileSystemFlags;
    WCHAR rgwchDestinationFileSystemNameBuffer[MAX_PATH];
    WCHAR rgwchDestinationRemoteName[MAX_PATH];
    DWORD dwDestinationRemoteNameLength = NUMBER_OF(rgwchDestinationRemoteName);
    UINT uiDestinationDriveType;

    if (!::FusionpInitializeHeap(NULL))
    {
        TraceFailureContext("initializing the heap.\n");
        goto Exit;
    }

    iArg = 1;

    while (iArg < argc)
    {
        PCWSTR arg = argv[iArg];

        // Let's see if we see some switches...
        if ((arg[0] == L'-') || (arg[0] == L'/'))
        {
            arg++;

            if ((_wcsicmp(arg, L"threads") == 0) ||
                (_wcsicmp(arg, L"t") == 0))
            {
                PWSTR pszDummy;

                iArg++;
                if (iArg >= argc)
                    break;

                g_nThreads = wcstol(argv[iArg], &pszDummy, 10);

                if (g_nThreads < 1)
                    g_nThreads = 1;

                if (g_nThreads > RTL_NUMBER_OF(g_rghThreads))
                    g_nThreads = RTL_NUMBER_OF(g_rghThreads);

                for (i=0; i<g_nThreads; i++)
                    g_rghThreads[i] = NULL;

                iArg++;

                continue;
            }
            else if ((_wcsicmp(arg, L"quiet") == 0) ||
                     (_wcsicmp(arg, L"q") == 0))
            {
                g_fSilent = true;
                iArg++;
                continue;
            }
            else if (_wcsicmp(arg, L"logfile") == 0)
            {
                iArg++;
                if (iArg >= argc)
                    break;

                g_pLogFile = ::_wfopen(argv[iArg], L"w+");
                if (g_pLogFile == NULL)
                {
                    ::perror("Error opening logfile");
                    goto Exit;
                }
                iArg++;
            }

        }

        // This must be it!  We hope; there should be two things left
        if ((iArg + 2) != argc)
            break;

        iSource = iArg;
        iDestination = iArg + 1;
        break;
    }

    if (iSource == 0)
    {
        fprintf(stderr,
            "%ls: usage:\n"
            "    %ls [-threads n] [-quiet] <source> <dest>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    // Abuse these buffers for debugging purposes...
    {
        HANDLE h;

        if (!::GetLogicalDriveStringsW(NUMBER_OF(rgwchSourceVolumePath), rgwchSourceVolumePath))
        {
            ::ReportFailure("GetLogicalDriveStringsW failed.");
            goto Exit;
        }

        h = ::FindFirstVolumeW(rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath));
        if (h == INVALID_HANDLE_VALUE)
        {
            ::ReportFailure("FindFirstVolumeW failed.");
            goto Exit;
        }

        for (;;)
        {
            DWORD cchReturnLength;

            if (!::GetVolumePathNamesForVolumeNameW(rgwchSourceVolumePath, rgwchDestinationVolumePath, NUMBER_OF(rgwchDestinationVolumePath), &cchReturnLength))
            {
                ::ReportFailure("GetVolumePathNamesForVolumeNameW failed.");
                goto Exit;
            }

            if (!::FindNextVolumeW(h, rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath)))
            {
                const DWORD dwLastError = ::GetLastError();
                if (dwLastError != ERROR_NO_MORE_FILES)
                {
                    ::ReportFailure("FindNextVolumeW failed.");
                    goto Exit;
                }

                break;
            }
        }

        ::FindVolumeClose(h);
    }

    if (!::GetVolumePathNameW(argv[iSource], rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath)))
    {
        ::ReportFailure("GetVolumePathName(L\"%ls\", ...) failed.", argv[iSource]);
        goto Exit;
    }

    uiSourceDriveType = ::GetDriveTypeW(rgwchSourceVolumePath);

    if (!::GetVolumePathNameW(argv[iDestination], rgwchDestinationVolumePath, NUMBER_OF(rgwchDestinationVolumePath)))
    {
        ::ReportFailure("GetVolumePathName(L\"%ls\", ...) failed.", argv[iDestination]);
        goto Exit;
    }

    uiDestinationDriveType = ::GetDriveTypeW(rgwchDestinationVolumePath);

    if (!::GetVolumeInformationW(
                rgwchSourceVolumePath,
                rgwchSourceVolumeName,
                NUMBER_OF(rgwchSourceVolumeName),
                &dwSourceVolumeSerialNumber,
                &dwSourceMaximumComponentLength,
                &dwSourceFileSystemFlags,
                rgwchSourceFileSystemNameBuffer,
                NUMBER_OF(rgwchSourceFileSystemNameBuffer)))
    {
        ::ReportFailure("GetVolumeInformation(L\"%ls\", ...) failed.", rgwchSourceVolumePath);
        goto Exit;
    }

    if (!::GetVolumeInformationW(
                rgwchDestinationVolumePath,
                rgwchDestinationVolumeName,
                NUMBER_OF(rgwchDestinationVolumeName),
                &dwDestinationVolumeSerialNumber,
                &dwDestinationMaximumComponentLength,
                &dwDestinationFileSystemFlags,
                rgwchDestinationFileSystemNameBuffer,
                NUMBER_OF(rgwchDestinationFileSystemNameBuffer)))
    {
        ::ReportFailure("GetVolumeInformation(L\"%ls\", ...) failed.", rgwchDestinationVolumePath);
        goto Exit;
    }

    if (!::GetDiskFreeSpaceW(
            rgwchDestinationVolumePath,
            &g_dwDestinationSectorsPerCluster,
            &g_dwDestinationBytesPerSector,
            &g_dwDestinationNumberOfFreeClusters,
            &g_dwDestinationTotalNumberOfClusters))
    {
        ::ReportFailure("GetDiskFreeSpaceW(L\"%ls\", ...) failed.", rgwchDestinationVolumePath);
        goto Exit;
    }

    if (!::FusionpInitializeCriticalSection(&g_cs))
        goto Exit;

    g_pFiles = new CFileIdHashTable;
    g_pDirs = new CDeque<CDir, offsetof(CDir, m_linkage)>;
    g_pFileCopies = new CDeque<CFileCopy, offsetof(CFileCopy, m_linkage)>;
    g_pFileLinks = new CDeque<CFileLink, offsetof(CFileLink, m_linkage)>;

    g_pszImage = wcsrchr(argv[0], L'\\');
    if (g_pszImage == NULL)
        g_pszImage = argv[0];
    else
        g_pszImage++;

    g_hIoCompletionPort = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, g_nThreads);
    if (g_hIoCompletionPort == NULL)
    {
        ::ReportFailure("Creating I/O Completion Port with %lu concurrent threads failed.", g_nThreads);
        goto Exit;
    }

    g_hWorkItemDoneEvent = ::CreateEventW(NULL, FALSE, FALSE, NULL);
    if (g_hWorkItemDoneEvent == NULL)
    {
        ::ReportFailure("Creating the file copied event failed.");
        goto Exit;
    }
 
    for (i=0; i<g_nThreads; i++)
    {
        g_rghThreads[i] = ::CreateThread(NULL, 0, &WorkerThreadProc, NULL, CREATE_SUSPENDED, NULL);
        if (g_rghThreads[i] == NULL)
        {
            ::ReportFailure("Creating worker thread number %lu failed.", i);
            goto Exit;
        }
    }

    ::GetSystemTime(&stStart);

    if (!buffSource.Win32Assign(argv[iSource], wcslen(argv[iSource])))
        goto Exit;

    if (!buffDestination.Win32Assign(argv[iDestination], wcslen(argv[iDestination])))
        goto Exit;

    if (!::BuildDirList(buffSource, buffDestination))
        goto Exit;

    if (!g_fSilent)
        printf("%ls: Found %Iu directories.\n", g_pszImage, g_pDirs->GetEntryCount());

    if (!::QueueDirScans())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_DirScansProcessed, g_pDirs->GetEntryCount(), "Directory scans"))
        goto Exit;

    ::GetSystemTime(&stAfterScan);

    if (!g_fSilent)
    {
        printf("%ls: Copying %Iu files (%I64u bytes)\n", g_pszImage, g_pFileCopies->GetEntryCount(), g_BytesToCopy);
        printf("%ls: Linking %Iu files\n", g_pszImage, g_pFileLinks->GetEntryCount());
    }

    if (!::MakeDirectoryStructure())
        goto Exit;

    if (!g_fSilent)
        printf("%ls: Created %Iu directories.\n", g_pszImage, g_pDirs->GetEntryCount());

    ::GetSystemTime(&stAfterDirCreation);

    if (!::QueueFileCopies())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_FileCopiesProcessed, g_pFileCopies->GetEntryCount(), "File copies"))
        goto Exit;

    ::GetSystemTime(&stAfterCopies);

    ::qsort(g_prgpFileCopies, g_pFileCopies->GetEntryCount(), sizeof(CFileCopy *), &CFileCopy::QSortBySize);

    if (g_pLogFile != NULL)
    {
        LARGE_INTEGER liFreq;
        ULONGLONG ullFreqDiv100;
        CStringBuffer buffDestination;

        ::QueryPerformanceFrequency(&liFreq);

        ullFreqDiv100 = (liFreq.QuadPart / 100);

        for (i=0; i<g_pFileCopies->GetEntryCount(); i++)
        {
            ULONGLONG diff = g_prgpFileCopies[i]->m_ullEnd - g_prgpFileCopies[i]->m_ullStart;
            diff = diff / ullFreqDiv100;
            if (!g_prgpFileCopies[i]->GetDestination(buffDestination))
                goto Exit;
            fprintf(g_pLogFile, "%ls,%Iu,%Iu\n", static_cast<PCWSTR>(buffDestination), diff, g_prgpFileCopies[i]->m_cbSize);
        }
    }

    if (!::QueueFileLinks())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_FileLinksProcessed, g_pFileLinks->GetEntryCount(), "File links"))
        goto Exit;

    ::GetSystemTime(&stAfterLinks);

    ::GetSystemTime(&stEnd);

    ::ComputeTimeDeltas(stStart, stAfterScan, stAfterScanDelta);
    ::ComputeTimeDeltas(stAfterScan, stAfterDirCreation, stAfterDirCreationDelta);
    ::ComputeTimeDeltas(stAfterDirCreation, stAfterCopies, stAfterCopiesDelta);
    ::ComputeTimeDeltas(stAfterCopies, stAfterLinks, stAfterLinksDelta);
    ::ComputeTimeDeltas(stStart, stEnd, stEndDelta);
    
    printf(
        "%ls: Statistics:\n"
        "   Directories Copied: %I64u\n"
        "         Files Copied: %I64u\n"
        "         Bytes Copied: %I64u\n"
        "         Files Linked: %I64u\n"
        "       Copies Skipped: %I64u\n"
        "        Links Skipped: %I64u\n",
        g_pszImage,
        g_DirectoriesCopied,
        g_FilesCopied,
        g_BytesCopied,
        g_FilesLinked,
        g_CopiesSkipped,
        g_LinksSkipped);

    printf(
        "   Times:\n"
        "      Scan:               %u:%02u:%02u.%03u\n"
        "      Directory Creation: %u:%02u:%02u.%03u\n"
        "      Copying Files:      %u:%02u:%02u.%03u\n"
        "      Linking Files:      %u:%02u:%02u.%03u\n"
        "      Total:              %u:%02u:%02u.%03u\n",
        stAfterScanDelta.wHour, stAfterScanDelta.wMinute, stAfterScanDelta.wSecond, stAfterScanDelta.wMilliseconds,
        stAfterDirCreationDelta.wHour, stAfterDirCreationDelta.wMinute, stAfterDirCreationDelta.wSecond, stAfterDirCreationDelta.wMilliseconds,
        stAfterCopiesDelta.wHour, stAfterCopiesDelta.wMinute, stAfterCopiesDelta.wSecond, stAfterCopiesDelta.wMilliseconds,
        stAfterLinksDelta.wHour, stAfterLinksDelta.wMinute, stAfterLinksDelta.wSecond, stAfterLinksDelta.wMilliseconds,
        stEndDelta.wHour, stEndDelta.wMinute, stEndDelta.wSecond, stEndDelta.wMilliseconds
        );

    ullTemp = (((((stAfterCopiesDelta.wHour * 60) + stAfterCopiesDelta.wMinute) * 60) + stAfterCopiesDelta.wSecond) * 1000) + stAfterCopiesDelta.wMilliseconds;

    if (ullTemp != 0)
    {
        ULONGLONG ullFilesPerMS = ((g_FilesCopied * 1000000ui64) / ullTemp);
        ULONGLONG ullBytesPerMS = ((g_BytesCopied * 1000000ui64) / ullTemp);

        printf(
            "   Files copied per second: %I64u.%03u\n"
            "   Bytes copied per second: %I64u.%03u\n",
            static_cast<ULONGLONG>(ullFilesPerMS / 1000ui64), static_cast<ULONG>(ullFilesPerMS % 1000ui64),
            static_cast<ULONGLONG>(ullBytesPerMS / 1000ui64), static_cast<ULONG>(ullBytesPerMS % 1000ui64));
    }

    ullTemp = (((stAfterLinksDelta.wHour * 60) + stAfterLinksDelta.wMinute) * 60) + stAfterLinksDelta.wSecond;

    if (ullTemp != 0)
    {
        printf(
            "   Files linked per second: %I64u\n",
            static_cast<ULONGLONG>(g_FilesLinked / ullTemp));
    }

    ullTemp = (((stEndDelta.wHour * 60) + stEndDelta.wMinute) * 60) + stEndDelta.wSecond;

    if (ullTemp != 0)
    {
        printf(
            "   Overall files per second: %I64u\n",
            static_cast<ULONGLONG>((g_FilesCopied + g_CopiesSkipped + g_FilesLinked + g_LinksSkipped + g_pDirs->GetEntryCount()) / ullTemp));
    }

    iReturnStatus = EXIT_SUCCESS;

Exit:
    // Wake the children; process termination doesn't seem to work if we don't.
    ::ResumeWorkerThreads();

    if (g_pLogFile != NULL)
    {
        fflush(g_pLogFile);
        fclose(g_pLogFile);
    }

    return iReturnStatus;
}

BOOL
ResumeWorkerThreads()
{
    BOOL fSuccess = FALSE;
    ULONG i;

    for (i=0; i<g_nThreads; i++)
    {
        if ((g_rghThreads[i] != NULL) && (g_rghThreads[i] != INVALID_HANDLE_VALUE))
        {
            if (::ResumeThread(g_rghThreads[i]) == -1)
            {
                ::ReportFailure("Failed to resume worker thread %lu.", i + 1);
                goto Exit;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SuspendWorkerThreads()
{
    BOOL fSuccess = FALSE;
    ULONG i;

    for (i=0; i<g_nThreads; i++)
    {
        if (::SuspendThread(g_rghThreads[i]) == -1)
        {
            ::ReportFailure("Failed to suspend worker thread %lu.", i + 1);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WaitForWorkersToComplete(
    ULONGLONG &rullCounter,
    ULONGLONG ullLimit,
    PCSTR pszOperationName
    )
{
    BOOL fSuccess = FALSE;
    ULONGLONG i;
	ULONGLONG ullCounterNextNotify = rullCounter + WAIT_NOTIFY_COUNTER;
	ULONGLONG ullCounter;

    if (!::ResumeWorkerThreads())
        goto Exit;

    i = 0;
    while (rullCounter < ullLimit)
    {
        // Don't wake more than every tenth of a second...
        ::Sleep(100);

        DWORD dwWFSO = ::WaitForSingleObject(g_hWorkItemDoneEvent, INFINITE);

        if (dwWFSO == WAIT_FAILED)
        {
            ::ReportFailure("Waiting for work item done event (%p) failed.", g_hWorkItemDoneEvent);
            goto Exit;
        }

        i++;

		ullCounter = rullCounter;
		if (ullCounter >= ullCounterNextNotify)
		{
			ullCounterNextNotify = ullCounter + WAIT_NOTIFY_COUNTER;
            if (!g_fSilent)
                printf("%ls: %s processed (%I64u total): %I64u\n", g_pszImage, pszOperationName, ullLimit, ullCounter);
        }
    }

    if (!::SuspendWorkerThreads())
        goto Exit;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


void
ComputeTimeDeltas(
    const SYSTEMTIME &rstStart,
    const SYSTEMTIME &rstEnd,
    SYSTEMTIME &rstDelta
    )
{
    FILETIME ftStart, ftEnd;
    ULARGE_INTEGER uliStart, uliEnd;
    ULONGLONG ullDiff, ullTemp;
    ULONG ulHours, ulMinutes, ulSeconds, ulMilliseconds;

    ::SystemTimeToFileTime(&rstStart, &ftStart);
    ::SystemTimeToFileTime(&rstEnd, &ftEnd);

    uliStart.LowPart = ftStart.dwLowDateTime;
    uliStart.HighPart = ftStart.dwHighDateTime;

    uliEnd.LowPart = ftEnd.dwLowDateTime;
    uliEnd.HighPart = ftEnd.dwHighDateTime;

    ullDiff = (uliEnd.QuadPart - uliStart.QuadPart);

    ulHours = (ULONG) (ullDiff / (10000000ui64 * 60 * 60));

    ullTemp = ullDiff - ((ULONGLONG) ulHours) * (10000000ui64 * 60 * 60);

    ulMinutes = (ULONG) (ullTemp / (10000000ui64 * 60));

    ullTemp -= ((ULONGLONG) ulMinutes) * (10000000ui64 * 60);

    ulSeconds = (ULONG) (ullTemp / 10000000ui64);

    ullTemp -= ((ULONGLONG) ulSeconds) * 10000000ui64;

    ulMilliseconds = (ULONG) (ullTemp / 10000ui64);

    rstDelta.wYear = 0;
    rstDelta.wMonth = 0;
    rstDelta.wDayOfWeek = 0;
    rstDelta.wDay = 0;
    rstDelta.wHour = (WORD) ulHours;
    rstDelta.wMinute = (WORD) ulMinutes;
    rstDelta.wSecond = (WORD) ulSeconds;
    rstDelta.wMilliseconds = (WORD) ulMilliseconds;
}

BOOL
BuildDirList(
    const CBaseStringBuffer &rbuffSource,
    const CBaseStringBuffer &rbuffDestination
    )
{
    PCWSTR szSrc = rbuffSource;
    BOOL fSuccess = FALSE;
    DWORD dwFileAttributes;
    CStringBuffer buffSrc;
    CStringBuffer buffSrcWildcard;
    CStringBuffer buffDst;
    WIN32_FIND_DATAW wfd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SIZE_T cchSrc, cchDst;
    CDir *pDir = NULL;

    dwFileAttributes = ::GetFileAttributesW(rbuffSource);
    if (dwFileAttributes == ((DWORD) -1))
    {
        ::ReportFailure("GetFileAttributesW() on the source \"%ls\" failed.", szSrc);
        goto Exit;
    }

    if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        ::ReportFailure("Source directory \"%ls\" is not a directory!");
        goto Exit;
    }

    if (!buffSrc.Win32Assign(rbuffSource))
        goto Exit;

    if (!buffSrc.Win32EnsureTrailingPathSeparator())
        goto Exit;

    if (!buffDst.Win32Assign(rbuffDestination))
        goto Exit;

    if (!buffDst.Win32EnsureTrailingPathSeparator())
        goto Exit;

    cchSrc = buffSrc.Cch();
    cchDst = buffDst.Cch();

    pDir = new CDir;
    if (pDir == NULL)
    {
        ::SetLastError(ERROR_OUTOFMEMORY);
        ::ReportFailure("Failed to allocate new CDir object.");
        goto Exit;
    }

    if (!pDir->Initialize(buffSrc, buffDst))
        goto Exit;

    g_pDirs->AddToTail(pDir);
    pDir = NULL;

    if ((g_pDirs->GetEntryCount() % 50) == 0)
    {
        if (!g_fSilent)
            printf("%ls: Found %Iu directories...\n", g_pszImage, g_pDirs->GetEntryCount());
    }

    if (!buffSrcWildcard.Win32Assign(buffSrc))
        goto Exit;

    if (!buffSrcWildcard.Win32Append(L"*", 1))
        goto Exit;

    if ((hFind = ::FindFirstFileExW(
                        buffSrcWildcard, 
                        FindExInfoStandard,
                        &wfd,
                        FindExSearchLimitToDirectories,
                        NULL,
                        0)) == INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_NO_MORE_FILES)
        {
            ::ReportFailure("FindFirstFileW(L\"%ls\", ...) failed.", static_cast<PCWSTR>(buffSrcWildcard));
            goto Exit;
        }
    }

    for (;;)
    {
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (wcscmp(wfd.cFileName, L".") != 0) &&
            (wcscmp(wfd.cFileName, L"..") != 0))
        {
            buffSrc.Left(cchSrc);
            buffDst.Left(cchDst);

            if (!buffSrc.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!buffDst.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!::BuildDirList(buffSrc, buffDst))
                goto Exit;
        }

        if (!::FindNextFileW(hFind, &wfd))
        {
            if (::GetLastError() == ERROR_NO_MORE_FILES)
                break;

            ::ReportFailure("FindNextFileW(%p, %p) failed.", hFind, &wfd);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::FindClose(hFind);
        ple.Restore();
    }

    if (pDir != NULL)
        delete pDir;

    return fSuccess;
}

BOOL
BuildDirFileList(
    CSxsLockCriticalSection &rlcs,
    CDir *pDir
    )
{
    PCWSTR szSrc = pDir->m_buffSource;
    BOOL fSuccess = FALSE;
    DWORD dwFileAttributes;
    CStringBuffer buffSrc;
    CStringBuffer buffSrcWildcard;
    CStringBuffer buffDst;
    WIN32_FIND_DATAW wfd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SIZE_T cchSrc, cchDst;
    CFileLink *pFileLink = NULL;
    CFileCopy *pFileCopy = NULL;

    dwFileAttributes = ::GetFileAttributesW(pDir->m_buffSource);
    if (dwFileAttributes == ((DWORD) -1))
    {
        ::ReportFailure("GetFileAttributesW() on the source \"%ls\" failed.", szSrc);
        goto Exit;
    }

    if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        ::ReportFailure("Source directory \"%ls\" is not a directory!", szSrc);
        goto Exit;
    }

    if (!buffSrc.Win32Assign(pDir->m_buffSource))
        goto Exit;

    if (!buffSrc.Win32EnsureTrailingPathSeparator())
        goto Exit;

    if (!buffDst.Win32Assign(pDir->m_buffDestination))
        goto Exit;

    if (!buffDst.Win32EnsureTrailingPathSeparator())
        goto Exit;

    cchSrc = buffSrc.Cch();
    cchDst = buffDst.Cch();

    if (!buffSrcWildcard.Win32Assign(buffSrc))
        goto Exit;

    if (!buffSrcWildcard.Win32Append(L"*", 1))
        goto Exit;

    if ((hFind = ::FindFirstFileW(buffSrcWildcard, &wfd)) == INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();

        if (::GetLastError() != ERROR_NO_MORE_FILES)
        {
            ::ReportFailure("FindFirstFileW(L\"%ls\", ...) failed.", static_cast<PCWSTR>(buffSrcWildcard));
            goto Exit;
        }
    }

    for (;;)
    {
        if ((wcscmp(wfd.cFileName, L".") != 0) && (wcscmp(wfd.cFileName, L"..") != 0))
        {
            buffSrc.Left(cchSrc);
            buffDst.Left(cchDst);

            if (!buffSrc.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!buffDst.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            dwFileAttributes = ::GetFileAttributesW(buffSrc);
            if (dwFileAttributes == ((DWORD) -1))
            {
                ::ReportFailure("GetFileAttribuesW(L\"%ls\") failed.", static_cast<PCWSTR>(buffSrc));
                goto Exit;
            }

            if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                BY_HANDLE_FILE_INFORMATION bhfi;
                ULONGLONG ullFileIndex;
                ULONGLONG ullFileSize;
                CFileCopy **ppFileCopy = NULL;

                hFile = ::CreateFileW(buffSrc, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    ::ReportFailure("CreateFileW(L\"%ls\", ...) failed.", static_cast<PCWSTR>(buffSrc));
                    goto Exit;
                }

                if (!::GetFileInformationByHandle(hFile, &bhfi))
                {
                    ::ReportFailure("Failed to GetFileInformationByHandle(%p, ...) on file \"%ls\".", hFile, static_cast<PCWSTR>(buffSrc));
                    goto Exit;
                }

                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

                ullFileIndex = (((ULONGLONG) bhfi.nFileIndexHigh) << 32) | ((ULONGLONG) bhfi.nFileIndexLow);
                ullFileSize = (((ULONGLONG) bhfi.nFileSizeHigh) << 32) | ((ULONGLONG) bhfi.nFileSizeLow);

                g_BytesToCopy += ullFileSize;

                if (!rlcs.Lock())
                {
                    ::ReportFailure("Failed to lock global critical section.");
                    goto Exit;
                }

                if (!g_pFiles->Find(ullFileIndex, ppFileCopy))
                {
                    ::ReportFailure("Finding file index %I64u in file table failed.", ullFileIndex);
                    goto Exit;
                }

                if (ppFileCopy != NULL)
                {
                    pFileLink = new CFileLink;
                    if (pFileLink == NULL)
                    {
                        ::SetLastError(ERROR_OUTOFMEMORY);
                        goto Exit;
                    }

                    if (!pFileLink->Initialize(
                        pDir,
                        wfd.cFileName,
                        bhfi.ftCreationTime,
                        bhfi.ftLastAccessTime,
                        bhfi.ftLastWriteTime,
                        ullFileIndex,
                        ullFileSize))
                        goto Exit;

                    g_pFileLinks->AddToTail(pFileLink);
                    pFileLink = NULL;
                }
                else
                {
                    pFileCopy = new CFileCopy;
                    if (pFileCopy == NULL)
                    {
                        ::SetLastError(ERROR_OUTOFMEMORY);
                        ::ReportFailure("Allocating new CFileCopy object failed.");
                        goto Exit;
                    }

                    if (!pFileCopy->Initialize(
                        pDir,
                        wfd.cFileName,
                        bhfi.ftCreationTime,
                        bhfi.ftLastAccessTime,
                        bhfi.ftLastWriteTime,
                        ullFileIndex,
                        ullFileSize))
                        goto Exit;

                    if (!g_pFiles->Insert(ullFileIndex, pFileCopy))
                        goto Exit;

                    g_pFileCopies->AddToTail(pFileCopy);
                    pFileCopy = NULL;
                }

                rlcs.Unlock();
            }
        }

        if (!::FindNextFileW(hFind, &wfd))
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError == ERROR_NO_MORE_FILES)
                break;

            ::ReportFailure("FindNextFileW() call failed.");
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::FindClose(hFind);
        ple.Restore();
    }

    if (pFileLink != NULL)
        delete pFileLink;

    if (pFileCopy != NULL)
        delete pFileCopy;

    return fSuccess;
}

BOOL
MakeDirectoryStructure()
{
    BOOL fSuccess = FALSE;

    CDequeIterator<CDir, offsetof(CDir, m_linkage)> dirIter;

    dirIter.Rebind(g_pDirs);
    
    for (dirIter.Reset(); dirIter.More(); dirIter.Next())
    {
        if (!::CreateDirectoryW(dirIter->m_buffDestination, NULL))
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError != ERROR_ALREADY_EXISTS)
            {
                ::ReportFailure("Unable to create directory \"%ls\".", static_cast<PCWSTR>(dirIter->m_buffDestination));
                goto Exit;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

void
ReportFailure(
    const char szFormat[],
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    rgchBuffer[0] = 0;
    rgchWin32Error[0] = 0;

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer), szFormat, ap);
    rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        _snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }
    rgchWin32Error[NUMBER_OF(rgchWin32Error) - 1] = 0;

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

void
TraceFailureContext(
    const char szFormat[],
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    rgchBuffer[0] = 0;
    rgchWin32Error[0] = 0;

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer), szFormat, ap);
    rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        _snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    rgchWin32Error[NUMBER_OF(rgchWin32Error) - 1] = 0;
    RemoveTrailingWhitespaceW(rgchWin32Error);

    fprintf(stderr, "%ls (0x%lx) while %s\n", rgchWin32Error, dwLastError, rgchBuffer);
}

DWORD
WINAPI
WorkerThreadProc(
    LPVOID pvParameter
    )
{
    ULONG nThread = (ULONG)(ULONG_PTR)pvParameter;
    DWORD dwReturnValue = 0;
    BYTE *pBuffer = NULL;
    DWORD cbBuffer;

    cbBuffer = 8192 * 32;
    pBuffer = (BYTE *) ::VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, PAGE_READWRITE);
    if (pBuffer == NULL)
    {
        ReportFailure("VirtualAlloc() for thread %lu failed.", nThread);
        goto Exit;
    }

    for (;;)
    {
        DWORD nBytes = 0;
        ULONG_PTR ulpCompletionKey = 0;
        LPOVERLAPPED lpo = NULL;
        CEntry *pEntry = NULL;
        bool fReQueue = false;

        if (!::GetQueuedCompletionStatus(g_hIoCompletionPort, &nBytes, &ulpCompletionKey, &lpo, INFINITE))
        {
            ReportFailure("Thread %lu failed call to GetQueuedCompletionStatus(%p, ...).", nThread, g_hIoCompletionPort);
            dwReturnValue = ::GetLastError();
            goto Exit;
        }

        pEntry = (CEntry *) lpo;

DoItAgain:
        if (!pEntry->BaseDoYourThing(fReQueue, pBuffer, cbBuffer))
            goto Exit;

        if (fReQueue)
        {
            if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, NULL, lpo))
            {
                ReportFailure("Thread %lu failed to requeue item; retrying directly.", nThread);
                goto DoItAgain;
            }
        }

        ::SetEvent(g_hWorkItemDoneEvent);
    }

Exit:
    // Heavy handed but what else can we do?
    ::ExitProcess(dwReturnValue);
    return dwReturnValue;
}

BOOL
QueueDirScans()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;

    g_prgpDirs = new (CDir *[g_pDirs->GetEntryCount()]);

    CDequeIterator<CDir, offsetof(CDir, m_linkage)> dirIter;

    dirIter.Rebind(g_pDirs);

    for (dirIter.Reset(), i=0; dirIter.More(); dirIter.Next(), i++)
    {
        g_prgpDirs[i] = dirIter;

        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) dirIter.Current()))
        {
            ReportFailure("Failed to queue dir scan.");
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
QueueFileCopies()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;
    FN_TRACE_WIN32(fSuccess);

    CDequeIterator<CFileCopy, offsetof(CFileCopy, m_linkage)> fileIter;

    g_prgpFileCopies = new (CFileCopy *[g_pFileCopies->GetEntryCount()]);
    if (g_prgpFileCopies == NULL)
    {
        ReportFailure("Failed to allocate file copy list.");
        goto Exit;
    }

    fileIter.Rebind(g_pFileCopies);
    i=0;
    
    for (fileIter.Reset(); fileIter.More(); fileIter.Next())
    {
        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) fileIter.Current()))
        {
            ReportFailure("Failed to queue file copy.");
            goto Exit;
        }
        g_prgpFileCopies[i++] = fileIter;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
QueueFileLinks()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;

    CDequeIterator<CFileLink, offsetof(CFileLink, m_linkage)> fileIter;

    g_prgpFileLinks = new (CFileLink *[g_pFileLinks->GetEntryCount()]);
    if (g_prgpFileLinks == NULL)
    {
        ReportFailure("Failed to allocate file link list.");
        goto Exit;
    }

    fileIter.Rebind(g_pFileLinks);
    i=0;
    
    for (fileIter.Reset(); fileIter.More(); fileIter.Next())
    {
        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) fileIter.Current()))
        {
            ReportFailure("Failed to queue file link.");
            goto Exit;
        }
        g_prgpFileLinks[i++] = fileIter;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ProcessDirScan(
    CDir *pDir,
    bool &rfReQueue
    )
{
    BOOL fSuccess = FALSE;
    CSxsLockCriticalSection l(g_cs);

    rfReQueue = false;

    if (!::BuildDirFileList(l, pDir))
        goto Exit;

    if (!l.Lock())
    {
        ReportFailure("Failed to lock global critical section.");
        goto Exit;
    }

    g_DirScansProcessed++;

    l.Unlock();

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ProcessFileCopy(
    CFileCopy *pFile,
    bool &rfReQueue,
    BYTE *pBuffer,
    DWORD cbBuffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSxsLockCriticalSection l(g_cs);
    bool fDoCopy = true;
    DWORD dwFileAttributes;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CStringBuffer buffSource, buffDestination;

    rfReQueue = false;

    // If we're about to copy it, it's worth taking a look at the target to see if it's more-or-less
    // out of date.
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    IFW32FALSE_EXIT(pFile->GetSource(buffSource));
    IFW32FALSE_EXIT(pFile->GetDestination(buffDestination));

    if (!::GetFileAttributesExW(buffDestination, GetFileExInfoStandard, &wfad))
    {
        const DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            ::ReportFailure("Error opening target file \"%ls\".", static_cast<PCWSTR>(buffDestination));
            goto Exit;
        }

        wfad.dwFileAttributes = ((DWORD) -1);
    }
    else
    {
        ULONGLONG cbFileSize = (wfad.nFileSizeHigh << 32) | wfad.nFileSizeLow;

        ASSERT_NTC(cbFileSize >= wfad.nFileSizeLow);

        if ((cbFileSize == pFile->m_cbSize) &&
            (wfad.ftCreationTime == pFile->m_ftSourceCreationTime))
        {
            pFile->m_fSkipped = true;
            fDoCopy = false;
        }
    }

    if (fDoCopy)
    {
        bool fSetTimestamp = true;
        bool fClearedReadOnly = false;

        // Destructively clear the read-only bit if th destination file exists and is read-only.
        dwFileAttributes = wfad.dwFileAttributes;

        // We already filtered out all other reasons for failure other than FILE_NOT_FOUND.
        if (dwFileAttributes != ((DWORD) -1))
        {
            if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                // If it's readonly, clear that bit as well as all the others that
                // are illegal to set via SetFileAttributes()
                dwFileAttributes &=
                    ~(FILE_ATTRIBUTE_READONLY |
                      FILE_ATTRIBUTE_COMPRESSED |
                      FILE_ATTRIBUTE_DEVICE |
                      FILE_ATTRIBUTE_DIRECTORY |
                      FILE_ATTRIBUTE_ENCRYPTED |
                      FILE_ATTRIBUTE_REPARSE_POINT |
                      FILE_ATTRIBUTE_SPARSE_FILE);

                if (!::SetFileAttributesW(buffDestination, dwFileAttributes))
                {
                    ::ReportFailure("Error setting file attributes for target file \"%ls\" to 0x%08lx to allow overwrite.", static_cast<PCWSTR>(buffDestination), dwFileAttributes);
                    goto Exit;
                }
            }
        }

        if (g_fAnnounceCopies)
            printf("Copying \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination));

        // Hey, it's not there.  Let's copy it and put the entry in the table.
        if (!::MyCopyFile(pBuffer, cbBuffer, buffSource, buffDestination, FALSE, hFile, rfReQueue))
        {
            ::ReportFailure("Failed to copy \"%ls\" to \"%ls\".  %srequeuing.", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination),
                rfReQueue ? "" : "not ");
            goto Exit;
        }

        if (fSetTimestamp)
        {
            if (!::SetFileTime(hFile, &pFile->m_ftSourceCreationTime, &pFile->m_ftSourceLastAccessTime, &pFile->m_ftSourceLastWriteTime))
            {
                ::ReportFailure("Failed call to SetFileTime on file \"%ls\".", static_cast<PCWSTR>(buffDestination));
                goto Exit;
            }

            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section.");
            goto Exit;
        }

        g_FilesCopied++;
        g_FileCopiesProcessed++;
        g_BytesCopied += pFile->m_cbSize;

        l.Unlock();
    }
    else
    {
        if (g_fAnnounceSkips)
            ::printf("Skipping copy from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination));

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section.");
            goto Exit;
        }

        g_CopiesSkipped++;
        g_FileCopiesProcessed++;

        l.Unlock();
    }

    fSuccess = TRUE;
Exit:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hFile);
        ple.Restore();
    }

    if (::GetLastError() == ERROR_TOO_MANY_OPEN_FILES)
    {
        rfReQueue = true;
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
ProcessFileLink(
    CFileLink *pFile,
    bool &rfReQueue
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSxsLockCriticalSection l(g_cs);
    bool fDoLink = true;
    CStringBuffer buffSource, buffDestination;
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    rfReQueue = false;

    IFW32FALSE_EXIT(pFile->GetSource(buffSource));
    IFW32FALSE_EXIT(pFile->GetDestination(buffDestination));

    // CreateHardLinkW() doesn't deal with replace-existing like copyfile, so we'll see if a
    // file by that name is already present and if so, delete it.
    if (!::GetFileAttributesExW(buffDestination, GetFileExInfoStandard, &wfad))
    {
        // It failed.  But did it fail for the right reason?
        DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            ::ReportFailure("Error probing destination for \"%ls\".", static_cast<PCWSTR>(buffDestination));
            goto Exit;
        }
    }
    else
    {
        ULONGLONG cbFileSize = (wfad.nFileSizeHigh << 32) | wfad.nFileSizeLow;

        ASSERT_NTC(cbFileSize >= wfad.nFileSizeLow);

        if ((pFile->m_cbSize == cbFileSize) &&
            (pFile->m_ftSourceCreationTime == wfad.ftCreationTime))
        {
            fDoLink = false;
            pFile->m_fSkipped = true;
        }
        else
        {
            if (g_fAnnounceDeletes)
                ::printf("Deleting file \"%ls\" in preparation for hard link creation\n", static_cast<PCWSTR>(buffDestination));

            if (!::DeleteFileW(buffDestination))
            {
                ::ReportFailure("Error deleting destination \"%ls\" in preparation for hard link creation.", static_cast<PCWSTR>(buffDestination));
                goto Exit;
            }
        }
    }

    if (fDoLink)
    {
        if (g_fAnnounceLinks)
            ::printf("Creating hard link from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));

        // Hey, it's already there.  Let's link it.
        if (!::CreateHardLinkW(buffDestination, buffSource, NULL))
        {
            ::ReportFailure("Error creating hard link from \"%ls\" to \"%ls\".", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));
            goto Exit;
        }

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section.");
            goto Exit;
        }

        g_FilesLinked++;
        g_FileLinksProcessed++;

        l.Unlock();
    }
    else
    {
        if (g_fAnnounceSkips)
            ::printf("Skipping hard link creation from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section.");
            goto Exit;
        }

        g_LinksSkipped++;
        g_FileLinksProcessed++;

        l.Unlock();
    }

    fSuccess = TRUE;
Exit:
    if (::GetLastError() == ERROR_TOO_MANY_OPEN_FILES)
    {
        rfReQueue = true;
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
MyCopyFile(
    BYTE *pBuffer,
    DWORD cbBuffer,
    PCWSTR lpExistingFileName,
    PCWSTR lpNewFileName,
    BOOL fFailIfExists,
    HANDLE &rhFile,
    bool &rfRequeue
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LARGE_INTEGER liFileSize;

    rhFile = INVALID_HANDLE_VALUE;

    HANDLE hIn = INVALID_HANDLE_VALUE, hOut = INVALID_HANDLE_VALUE;

    hIn = ::CreateFileW(lpExistingFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hIn == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to open input file \"%ls\".", lpExistingFileName);
        // we'll assume that we should requeue failures that have to do with the input file.
        rfRequeue = true;
        goto Exit;
    }

    hOut = ::CreateFileW(lpNewFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_NO_BUFFERING, NULL);
    if (hOut == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to open output file \"%ls\".", lpNewFileName);
        goto Exit;
    }

    liFileSize.QuadPart = 0;

    // let the games begin...

    for (;;)
    {
        DWORD dwBytesRead, dwBytesWritten;
        DWORD dwBytesToWrite = 0;

        if (!::ReadFile(hIn, pBuffer, cbBuffer, &dwBytesRead, NULL))
        {
            ::ReportFailure("Error reading from file \"%ls\".", lpExistingFileName);
            // we'll assume that we should requeue failures that have to do with the input file.
            rfRequeue = true;
            goto Exit;
        }

        if (dwBytesRead == 0)
            break;

        liFileSize.QuadPart += dwBytesRead;

        if (dwBytesRead != cbBuffer)
        {
            // We have to round to the cluster size for the write...
            dwBytesToWrite = dwBytesRead + (g_dwDestinationBytesPerSector - 1);
            dwBytesToWrite -= (dwBytesToWrite % g_dwDestinationBytesPerSector);
        }
        else
            dwBytesToWrite = dwBytesRead;

        if (!::WriteFile(hOut, pBuffer, dwBytesToWrite, &dwBytesWritten, NULL))
        {
            ::ReportFailure("Error writing to file \"%ls\".", lpNewFileName);
            // we'll assume that we should requeue failures that have to do with the input file.
            rfRequeue = true;
            goto Exit;
        }
    }

    // If the file size wasn't a multiple of the sector size, we need to open the
    // file without the unbuffered flag so that we can set its size to the exact
    // correct byte count.
    if ((liFileSize.QuadPart % g_dwDestinationBytesPerSector) != 0)
    {
        ::CloseHandle(hOut);
        hOut = INVALID_HANDLE_VALUE;

        hOut = ::CreateFileW(lpNewFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (hOut == INVALID_HANDLE_VALUE)
        {
            ::ReportFailure("Unable to reopen output file \"%ls\".", lpNewFileName);
            goto Exit;
        }

        // Truncate the file appropriately
        if (!::FusionpSetFilePointerEx(hOut, liFileSize, NULL, FILE_BEGIN))
        {
            ::ReportFailure("Error setting file pointer on file \"%ls\".", lpNewFileName);
            goto Exit;
        }

        if (!::SetEndOfFile(hOut))
        {
            ::ReportFailure("Error setting end of file on file \"%ls\".", lpNewFileName);
            goto Exit;
        }
    }

    ::CloseHandle(hIn);
    hIn = INVALID_HANDLE_VALUE;

    // Pass the handle back out and set it to INVALID_HANDLE_VALUE so that we don't
    // try to close it in the exit path.
    rhFile = hOut;
    hOut = INVALID_HANDLE_VALUE;

    fSuccess = TRUE;
Exit:
    if (hIn != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hIn);
        ple.Restore();
    }

    if (hOut != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hOut);
        ple.Restore();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\common.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    common.cpp

Abstract:

    Common Function calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/
#include "msmgen.h"
#include "msidefs.h"
#include "objbase.h"
#include "fusionhandle.h"

#include "coguid.h"

inline BOOL IsDotOrDotDot(PCWSTR str)
{
    return ((str[0] == L'.') && ((str[1] == L'\0') || ((str[1] == L'.') && (str[2] == L'\0'))));
}

//
// simple function, check the ext of the filename 
//
BOOL IsIDTFile(PCWSTR pwzStr)
{
    PWSTR p = wcsrchr(pwzStr, L'.');
    if ( p )
    {
        if ( _wcsicmp(p, IDT_EXT) == 0) // idt files
            return TRUE;
    }
    
    return FALSE;
}

//
//Function:
// 
//  get moduleID from the msm file, if not present, generate a new one and write related entried into the Database
//
HRESULT SetModuleID()
{
    HRESULT hr = S_OK;
    WCHAR tmp[MAX_PATH];
    LPOLESTR tmpstr = NULL;
    DWORD cch = NUMBER_OF(tmp);
    UINT datatype;
    PMSIHANDLE hSummaryInfo = NULL;
        
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiGetSummaryInformation(g_MsmInfo.m_hdb, NULL, 3, &hSummaryInfo));    
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiSummaryInfoGetPropertyW(hSummaryInfo, PID_REVNUMBER, &datatype, 0,0, tmp, &cch));

    //
    // because msm has existed before, it should has a module ID, otherwise, it should generate a new one
    //
    if (cch == 0) 
    {
        if (IsEqualGUID(g_MsmInfo.m_guidModuleID, GUID_NULL)) //otherwise, user has input a guid
        {
            IFFAILED_EXIT(::CoCreateGuid(&g_MsmInfo.m_guidModuleID));
        }
        IFFAILED_EXIT(StringFromCLSID(g_MsmInfo.m_guidModuleID, &tmpstr));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER, VT_LPSTR, 0,0, tmpstr));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiSummaryInfoSetProperty(hSummaryInfo, PID_PAGECOUNT, VT_I4, 150, 0, 0));
    }
    else 
    {
        //
        // get ModuleID from msm and save it into the global structure
        //
        IFFAILED_EXIT(CLSIDFromString(LPOLESTR(tmp), &g_MsmInfo.m_guidModuleID));
    }
    
    IFFAILED_EXIT(GetMsiGUIDStrFromGUID(MSIGUIDSTR_WITH_PREPEND_DOT, g_MsmInfo.m_guidModuleID, g_MsmInfo.m_sbModuleGuidStr));

Exit:
    MsiSummaryInfoPersist(hSummaryInfo);
    CoTaskMemFree(tmpstr);
    return hr;
}

//
// Purpose: 
//      make sure the tables we want to use is avaiable, if not, import the tables 
// Input Param:
//      Fully qulified msm filename
//
HRESULT OpenMsmFileForMsmGen(PCWSTR msmfile)
{
    HRESULT hr = S_OK;
    BOOL fUsingExistedMsm = FALSE;    

    if (g_MsmInfo.m_hdb == NULL)
    {
        if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_NEW) 
        {
            ASSERT_NTC(g_MsmInfo.m_sbMsmTemplateFile.IsEmpty() == FALSE);
            IFFALSE_EXIT(CopyFileW(g_MsmInfo.m_sbMsmTemplateFile, msmfile, FALSE));    
            IFFALSE_EXIT(SetFileAttributesW(msmfile, FILE_ATTRIBUTE_NORMAL));
        } else // get it from the msm file, which must has a moduleID
        {  
            //
            // make sure that the file exist
            //
            if (GetFileAttributesW(msmfile) == (DWORD)-1) 
                SET_HRERR_AND_EXIT(ERROR_INVALID_PARAMETER);        
        }

        //
        // open database for revise
        //
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(msmfile, (LPCWSTR)(MSIDBOPEN_DIRECT), &g_MsmInfo.m_hdb));
    }

Exit:
    return hr;
}

HRESULT ImportTableIfNonPresent(MSIHANDLE * pdbHandle, PCWSTR sbMsmTablePath, PCWSTR idt)
{
    CSmallStringBuffer sbTableName;
    HRESULT hr = S_OK;

    IFFAILED_EXIT(sbTableName.Win32Assign(idt, wcslen(idt)));
    IFFALSE_EXIT(sbTableName.Win32RemoveLastPathElement());

    //
    // check whether the table exist in the Database
    //
    MSICONDITION err = MsiDatabaseIsTablePersistent(g_MsmInfo.m_hdb, sbTableName);
    if (( err == MSICONDITION_ERROR) || (err == MSICONDITION_FALSE))
    {
        SETFAIL_AND_EXIT;
    }
    else if (err == MSICONDITION_NONE) // non-exist
    {
        //import the table
        IFFAILED_EXIT(MsiDatabaseImportW(*pdbHandle, sbMsmTablePath, idt));
    }

Exit:
    return hr;      
}
//
// Fucntion:
//     - make sure the msm has all tables msmgen needed
//
HRESULT PrepareMsm()
{

    if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_NEW)
        return S_OK;
    else 
    { 
        HRESULT hr = S_OK;
        PMSIHANDLE phdb = NULL; 
        CStringBuffer sb;
       
        IFFALSE_EXIT(sb.Win32Assign(g_MsmInfo.m_sbMsmTemplateFile));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(sb, (LPCWSTR)MSIDBOPEN_READONLY, &phdb));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiDatabaseMergeW(g_MsmInfo.m_hdb, phdb, NULL));
Exit:
        return hr;
    }
}

// 
// make msi-specified guid string ready : uppercase and replace "-" with "_"
//
HRESULT GetMsiGUIDStrFromGUID(DWORD dwFlags, GUID & guid, CSmallStringBuffer & str)
{
    HRESULT hr = S_OK;
    LPOLESTR tmpstr = NULL;
    WCHAR tmpbuf[MAX_PATH];

    IFFAILED_EXIT(StringFromCLSID(guid, &tmpstr));
    wcscpy(tmpbuf, tmpstr);
    for (DWORD i=0; i < wcslen(tmpbuf); i++)
    {
        if (tmpbuf[i] == L'-')
            tmpbuf[i] = L'_';
        else
            tmpbuf[i]= towupper(tmpbuf[i]);
    }

    if (dwFlags & MSIGUIDSTR_WITH_PREPEND_DOT)
    {
        tmpbuf[0] = L'.';
        IFFALSE_EXIT(str.Win32Assign(tmpbuf, wcslen(tmpbuf) - 1 ));  // has prepend "."
    }else
        IFFALSE_EXIT(str.Win32Assign(tmpbuf + 1 , wcslen(tmpbuf) - 2 ));  // get rid of "{" and "}"

Exit:
    return hr;
}

//
//  this function has to be called after the assembly name is known because we need query ComponentTable for MSMGEN_OPR_REGEN
//  use the input one, other get it from the componentTables
//
// the input keyPath could be NULL for policy assembly or assembly-without-data files
//
HRESULT SetComponentId(PCWSTR componentIdentifier, PCWSTR keyPath)
{ 
    HRESULT hr = S_OK;
    BOOL fExist = FALSE;
    CStringBuffer str;
    LPOLESTR tmpstr = NULL;
    //
    // prepare component ID if not input-specified
    //
    if ((g_MsmInfo.m_enumGenMode == MSMGEN_OPR_ADD) || (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_NEW))        
    {
        if (curAsmInfo.m_sbComponentID.IsEmpty())
        {
            goto generate_new_componentID_and_insert;
        }
        else 
        {
            goto insert_into_table;
        }
    }
    else if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_REGEN)
    {        
        MSIHANDLE * hRecord = NULL;
        IFFAILED_EXIT(ExecuteQuerySQL(L"Component", L"Component", componentIdentifier, fExist, NULL));

        if (fExist == FALSE) 
        {
            if (curAsmInfo.m_sbComponentID.IsEmpty())
            {
                // SET_HRERR_AND_EXIT(ERROR_INTERNAL_ERROR);            
                goto generate_new_componentID_and_insert;
            }
            else
            {
                goto insert_into_table;
            }
        }
        else
        {
            if (! curAsmInfo.m_sbComponentID.IsEmpty() )
            {
                // change the componentID, using the user-input one
                IFFAILED_EXIT(ExecuteUpdateSQL(L"Component", L"Component", componentIdentifier, 
                    L"ComponentId", curAsmInfo.m_sbComponentID));
            }

            hr = S_OK;
            goto Exit;           
        }
    }

generate_new_componentID_and_insert:

    GUID tmpguid;    
    
    IFFAILED_EXIT(::CoCreateGuid(&tmpguid));
    IFFAILED_EXIT(StringFromCLSID(tmpguid, &tmpstr));
    IFFALSE_EXIT(curAsmInfo.m_sbComponentID.Win32Assign(tmpstr, wcslen(tmpstr)));

insert_into_table:    
    IFFALSE_EXIT(str.Win32Assign(SYSTEM_FOLDER, NUMBER_OF(SYSTEM_FOLDER)-1));
    IFFALSE_EXIT(str.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    IFFAILED_EXIT(ExecuteInsertTableSQL(
                 OPT_COMPONENT, 
                 NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT, 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentID),
                 MAKE_PCWSTR(str),
                 MAKE_PCWSTR(keyPath)));
Exit:
    CoTaskMemFree(tmpstr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\db.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    db.cpp

Abstract:

    Database calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/
#include "msmgen.h"
#include "msidefs.h"
#include "Msiquery.h"

#include "objbase.h"
#include "coguid.h"

#define NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY   6
#define NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS           5
#define NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB            3

static PWSTR s_InsertTableSQL[] = 
{
        L"INSERT INTO Directory (Directory, Directory_Parent, DefaultDir) VALUES (?, ?, ?)",
        L"INSERT INTO Component (Component, ComponentId, Directory_, KeyPath, Attributes, Condition) VALUES (?, ?, ?, ?, 0, '')",
        L"INSERT INTO File (File, Component_, FileName, Sequence, FileSize, Version, Language, Attributes) VALUES (?, ?, ?, ?, '0', '1.0.0.0', '0', 0)",
        L"INSERT INTO MsiAssembly (Component_, Feature_, File_Manifest, File_Application, Attributes) VALUES (?, ?, ?, '', 1)",
        L"INSERT INTO MsiAssemblyName (Component_, Name, Value) VALUES (?, ?, ?)",
        L"INSERT INTO ModuleSignature (ModuleID, Version, Language) VALUES (?, ?, 0)",
        L"INSERT INTO ModuleComponents (Component, ModuleID, Language) VALUES (?, ?, 0)",
        L"INSERT INTO Property (Property, Value) VALUES (?, ?)",
        L"INSERT INTO ProgId (ProgId, Class_, Description, ProgId_Parent, Icon_, IconIndex) VALUES (?, ?, ?, NULL, NULL, NULL)",
        L"INSERT INTO Class (CLSID, Component_, ProgId_Default, Description, Feature_, Context, AppId_, FileTypeMask, Icon_, IconIndex, DefInprocHandler, Argument, Attributes)"
                        L"VALUES (?, ?, ?, ?, ?, 'InprocServer32', NULL, NULL, NULL, NULL, NULL, NULL, 0)",
        L"INSERT INTO TypeLib (LibID, Component_, Version, Feature_, Language, Description, Directory_, Cost)"
                        L"VALUES (?, ?, ?, ?, 0, NULL, NULL, 0)"
};

HRESULT ExecuteDeleteFromSQL(PCWSTR szTablename, PCWSTR szId, PCWSTR szValue)
{
    HRESULT hr = S_OK;
    WCHAR pwszSQL[MAX_PATH];    
    PMSIHANDLE hView = NULL;

    swprintf(pwszSQL, L"DELETE FROM `%s` WHERE `%s`='%s'", szTablename, szId, szValue);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));

Exit:
    return hr;

}
    
DWORD g_FileSequenceNumber = 0;

HRESULT ExecuteDropTableSQL(PCWSTR pszTableName)
{
    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSICONDITION con;

    con = MsiDatabaseIsTablePersistent(g_MsmInfo.m_hdb, pszTableName);
    if (con == MSICONDITION_NONE)
    {
        hr = S_OK; // the table does not exist in DB, so do not need to drop the table at all
        goto Exit; 
    }
    else if (con != MSICONDITION_TRUE)
        SETFAIL_AND_EXIT;

    //
    // drop the table
    //

    swprintf(pwszSQL, L"DROP TABLE `%s`", pszTableName);    

    //
    // ignore the error for drop table because this table maybe non-exist at all
    //
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));
Exit:
    return hr;
}

HRESULT ExecuteInsertTableSQL(DWORD tableIndex, UINT cRecords, ...)
{
    PMSIHANDLE          hView;
    PMSIHANDLE          hRecord = NULL;   
    PCWSTR              pwszRecord = NULL;
    va_list             ap;
    HRESULT             hr = S_OK;    
    PWSTR               pwszSQL = NULL;

    pwszSQL = s_InsertTableSQL[tableIndex];

    //
    // create records 
    //
    switch (tableIndex){
        case OPT_FILE:
            hRecord = ::MsiCreateRecord(cRecords + 1);
            break;            
        case OPT_DIRECTORY:
        case OPT_COMPONENT:        
        case OPT_MSIASSEMBLY:
        case OPT_MSIASSEMBLYNAME:
        case OPT_MODULESIGNATURE:
        case OPT_MODULECOMPONENTS:
        case OPT_PROPERTY:
        case OPT_PROGID:
        case OPT_CLASS:
        case OPT_TYPELIB:        
            hRecord = ::MsiCreateRecord(cRecords);
            break;
        default:
            SETFAIL_AND_EXIT;
    }

    if (hRecord == NULL)
        SETFAIL_AND_EXIT;

    //
    // get parameters
    //
    va_start(ap, cRecords);

    for (DWORD i=0; i<cRecords; i++)
    {
        pwszRecord = va_arg(ap, PCWSTR);
        if ((tableIndex == OPT_TYPELIB) && (i == 2)) // set version for typelib
        {
            UINT x = _wtoi(pwszRecord);
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetInteger(hRecord, i+1, x));
        }
        else
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStringW(hRecord, i+1, pwszRecord));
    }

    //
    // for fileTable, add a sequence number here
    //
    if (tableIndex == OPT_FILE)
    {
        g_FileSequenceNumber ++;
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetInteger(hRecord, cRecords + 1 , g_FileSequenceNumber));
    }

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));

Exit:
    va_end(ap);
    return hr;
}

//
// check a table with a name-value pair of its identifier
//
HRESULT ExecuteQuerySQL(PCWSTR szTableName, PCWSTR szKeyName, PCWSTR szKeyValue, BOOL & fExist, MSIHANDLE * hOutRecord)
{

    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSIHANDLE hRecord;
    MSIHANDLE * phRecord = hOutRecord;

    if (phRecord == NULL)
        phRecord = &hRecord;

    fExist = FALSE;
    swprintf(pwszSQL, L"SELECT * FROM `%s` WHERE `%s`='%s'", szTableName, szKeyName, szKeyValue);    

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));
    UINT err = ::MsiViewFetch(hView, phRecord);
    if ((err == ERROR_NO_MORE_ITEMS) || ((err == ERROR_SUCCESS) && (phRecord == NULL)))
        fExist = FALSE;
    else if (err != ERROR_SUCCESS)
        SET_HRERR_AND_EXIT(err);
    else
        fExist = TRUE;
Exit:        
    if (phRecord == &hRecord)
        MsiCloseHandle(hRecord);

    return hr;
}

HRESULT ExecuteUpdateSQL(PCWSTR szTableName, PCWSTR KeyName, PCWSTR KeyValue, PCWSTR ColumnName, PCWSTR NewValue)
{
    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSIHANDLE * hRecord = NULL;
    BOOL fExist = FALSE;

    swprintf(pwszSQL, L"UPDATE '%s' SET `%s` = '%s' WHERE '%s'='%s'", 
        szTableName, ColumnName, NewValue, KeyName, KeyValue);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));

Exit:
    return hr;
}

HRESULT GetShortLongFileNamePair(PCWSTR fullpath, SIZE_T cch, CStringBuffer & namepair)
{
    WCHAR shortname[MAX_PATH];
    HRESULT hr = S_OK;
    PWSTR p = NULL; 
    DWORD ret = GetShortPathNameW(
        fullpath, 
        shortname,
        NUMBER_OF(shortname));
    if ( ret == 0 )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }
    if (ret > NUMBER_OF(shortname))
    {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }
    p = wcsrchr(shortname, L'\\');
    p ++ ;

    IFFALSE_EXIT(namepair.Win32Assign(p, wcslen(p)));
    IFFALSE_EXIT(namepair.Win32Append(L"|", 1));

    p = wcsrchr(fullpath, L'\\');
    p++;
    IFFALSE_EXIT(namepair.Win32Append(p, wcslen(p)));

Exit:
    return hr;
}


//
// Function:
//      - Directory Table could be set without open the manifest
//      - write 2 entry to Directory Table for downlevel
//      - only write the record when they are not exist in the DB
//
HRESULT SetDirectoryTable()
{
    HRESULT hr = S_OK;
    BOOL fExist;
    CStringBuffer sbSystemFolder;

    IFFAILED_EXIT(ExecuteQuerySQL(L"Directory", L"Directory", L"TARGETDIR", fExist, NULL));
    if (!fExist)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(        
            OPT_DIRECTORY,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
            MAKE_PCWSTR(L"TARGETDIR"),          // the re-cast is necessary for va_list
            MAKE_PCWSTR(L""),
            MAKE_PCWSTR(L"SourceDir")));
    }

    // for downlevel installation : copy files into SystemFolders
    IFFALSE_EXIT(sbSystemFolder.Win32Assign(SYSTEM_FOLDER, NUMBER_OF(SYSTEM_FOLDER)-1));
    IFFALSE_EXIT(sbSystemFolder.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    IFFAILED_EXIT(ExecuteQuerySQL(L"Directory", L"Directory", sbSystemFolder, fExist, NULL));
    if (!fExist)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(
            OPT_DIRECTORY,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
            MAKE_PCWSTR(sbSystemFolder),          // the re-cast is necessary for va_list
            MAKE_PCWSTR(L"TARGETDIR"),
            MAKE_PCWSTR(L"System:.")));
    }

Exit:
    return hr;
}

//
// Function:
//      - add manifest and catalog into the cabinet 
//      - add manifest and catalog into FileTable 
//
// because this function used ComponentIdentifier, it has to wait until ComponentIdentifier is set
// and it is set to be the name of the assembly
//
HRESULT SetManifestAndCatalog()
{
    HRESULT hr = S_OK;
    CStringBuffer sbBakFileName;
    CStringBuffer sbNamePair;

    CurrentAssemblyReset;
    //
    // add manifest into FileTable and Cabinet
    //    
    IFFALSE_EXIT(sbBakFileName.Win32Assign(curAsmInfo.m_sbManifestFileName));    
    IFFALSE_EXIT(curAsmInfo.m_sbManifestFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(sbBakFileName));
    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), sbNamePair));
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbManifestFileName),   // sfp.manifest.123434545
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(sbNamePair)));                          // sfp.manifest
    
    // add manifest to the cabinet 
    IFFAILED_EXIT(AddFileToCabinetW( curAsmInfo.m_sbAssemblyPath,        // fullpath : c:\tests\sfp\sfp.manifest
                                    curAsmInfo.m_sbAssemblyPath.Cch(),
                                    curAsmInfo.m_sbManifestFileName,    // identifier in FILE : sfp.manifest.1234234234234234
                                    curAsmInfo.m_sbManifestFileName.Cch()));
    //
    // add catalog into FileTable and Cabinet
    //           
    IFFALSE_EXIT(sbBakFileName.Win32ChangePathExtension(CATALOG_FILE_EXT, NUMBER_OF(CATALOG_FILE_EXT) -1, eAddIfNoExtension));    
    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(sbBakFileName));

    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), sbNamePair));
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbCatalogFileName),    // sfp.cat.123434345345
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(sbNamePair)));                          // sfp.cat

    // add catalog to the cabinet 
    IFFAILED_EXIT(AddFileToCabinetW(curAsmInfo.m_sbAssemblyPath,             // fullpath : c:\tests\sfp\sfp.cat
                                   curAsmInfo.m_sbAssemblyPath.Cch(),    
                                   curAsmInfo.m_sbCatalogFileName,            //
                                   curAsmInfo.m_sbCatalogFileName.Cch()));    

Exit:
    return hr;
}

//
//  Function:
//      Dump the cabinet File into a TemporaryFile
//  Param:
//      OUT WCHAR pszCabFile[] : store the temporary cabinet file
//      PMSIHANDLE hRecord: the record which contain the stream of a cabinet
//
HRESULT DumpCABFromMsm(char *pszFilename, DWORD cchFileName, PMSIHANDLE hRecord)
{
    HRESULT hr = S_OK;
    char buf[1024];    // !!!!fci and fdi are ansi apis    
    DWORD cbBuf;
    DWORD cbBytesWritten; 
    CStringBuffer sbFilename;   

    HANDLE hd = INVALID_HANDLE_VALUE;

    //
    // generate a filename for temporary cabinet
    // use the big buffer to generate a filename
    //    

    DWORD num = ExpandEnvironmentStringsA(MSM_TEMP_CABIN_FILE, pszFilename, cchFileName);
    if ((num == 0) || (num > cchFileName))
        SETFAIL_AND_EXIT;

    DWORD dwAttributes = GetFileAttributesA(pszFilename);
    if ( dwAttributes != (DWORD)(-1))
    {
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
            SET_HRERR_AND_EXIT(ERROR_INTERNAL_ERROR);
        
        //
        // delete the file before create it, if can not delete, then it is an error, 
        // stop right here
        //
        IFFALSE_EXIT(DeleteFileA(pszFilename)); 
    }

    hd = CreateFileA(pszFilename, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (hd == INVALID_HANDLE_VALUE)    
        SET_HRERR_AND_EXIT(::GetLastError());

    //
    // get the stream by reading out bytes from the record block by block
    //
   
    do {
        cbBuf = sizeof(buf); // using bytes, not cch
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordReadStream(hRecord, 2, buf, &cbBuf));
        if (cbBuf != 0)
        {
            cbBytesWritten = 0;
            IFFALSE_EXIT(WriteFile(hd, buf, cbBuf, &cbBytesWritten, NULL));
        }
    }while(cbBuf > 0 );

    IFFALSE_EXIT(CloseHandle(hd));
    hd = INVALID_HANDLE_VALUE;

Exit:
    if (hd != INVALID_HANDLE_VALUE)
        CloseHandle(hd);    

    return hr;
}


//
//  (0) ASSERT the database has opened and the cabient has created
//  (1) check whether this is a mergemodule.cab in _Stream table.
//  (2) if so, extract all files from this cab, 
//  (3) delete the entry from _StreamTable
//  (4) add all files into new cabinet
//
HRESULT PrepareMsmCabinet()
{    
    if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_NEW)
        return S_OK;

    HRESULT hr = S_OK;
    MSIHANDLE hRecord = NULL;
    BOOL fExist = FALSE;
    char szCabFile[MAX_PATH];    

    ASSERT_NTC(g_MsmInfo.m_hdb != NULL);
    ASSERT_NTC(g_MsmInfo.m_hfci != NULL);

    IFFAILED_EXIT(ExecuteQuerySQL(L"_Streams", L"Name", MERGEMODULE_CABINET_FILENAME, fExist, &hRecord));
    if (fExist)
    {
        if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_REGEN)
        {
            IFFAILED_EXIT(ExecuteDeleteFromSQL(L"_Streams", L"Name", MERGEMODULE_CABINET_FILENAME));
        }
        else 
        {
            ASSERT_NTC(g_MsmInfo.m_enumGenMode == MSMGEN_OPR_ADD);
            
            IFFAILED_EXIT(DumpCABFromMsm(szCabFile, sizeof(szCabFile), hRecord));            
            IFFAILED_EXIT(MoveFilesInCabinetA(szCabFile));
            IFFAILED_EXIT(ExecuteDeleteFromSQL(L"_Streams", L"Name", MERGEMODULE_CABINET_FILENAME));
        }        
    }


Exit:
    if (GetFileAttributes(szCabFile) != -1)
        DeleteFileA(szCabFile);
    return hr;
}

HRESULT PrepareDatabase()
{
    HRESULT hr = S_OK;

    //
    // open the msm, make it ready for READ_WRITE
    //
    IFFAILED_EXIT(OpenMsmFileForMsmGen(g_MsmInfo.m_sbMsmFileName));

    //
    // the database has opened
    //
    IFFAILED_EXIT(PrepareMsmCabinet());


    //
    // get moduleID or generate a new one
    //
    IFFAILED_EXIT(SetModuleID());

    // 
    // for "-op regen", 
    // (0) for whatever case, we keep the directory table because it is manifest-independent
    // (1) if component is specified on the command line, we delete most tables except Directory Table;
    // (2) Otherwise, we use the old componentID table, so we delete all tables except Component-related Tables, which include 
    // Component Table, ModuleComponent Table, ModuleSignature Table;
    // (3) THERE IS A BIG ASSUMPTION FOR (2): ASSEMBLYNAME IN THE MANIFEST IS NOT CHANGED!
    //
    // (4) all the tables used by msm would be get imported from msmgen Template file in HRESULT PrepareMsm() call;
    //
    if (g_MsmInfo.m_enumGenMode == MSMGEN_OPR_REGEN)        
    {        

        IFFAILED_EXIT(ExecuteDropTableSQL(L"File"));
        IFFAILED_EXIT(ExecuteDropTableSQL(L"MsiAssembly"));
        IFFAILED_EXIT(ExecuteDropTableSQL(L"MsiAssemblyName"));
        IFFAILED_EXIT(ExecuteDropTableSQL(L"Class"));
        IFFAILED_EXIT(ExecuteDropTableSQL(L"TypeLib"));        
        IFFAILED_EXIT(ExecuteDropTableSQL(L"ProgId"));
        if (curAsmInfo.m_sbComponentID.IsEmpty() == FALSE)
        {
            IFFAILED_EXIT(ExecuteDropTableSQL(L"Component"));
            IFFAILED_EXIT(ExecuteDropTableSQL(L"ModuleComponent"));
            IFFAILED_EXIT(ExecuteDropTableSQL(L"ModuleSignature"));            
        }
    } 
    
    //
    // if it is a user msm, make sure it has all the tables needed for msmgen
    //
    IFFAILED_EXIT(PrepareMsm());    
    
Exit:    
    return hr;
}

//
// if not specified by the user, ue the same basename as the manifest.
// in any case, extand it to be a fully-qualified path name for this msm
//
HRESULT SetMsmOutputFileName(PCWSTR pszManifestFileName)
{
    HRESULT hr = S_OK;
    WCHAR tmpbuf[MAX_PATH];

    PARAMETER_CHECK_NTC(pszManifestFileName != NULL);

    if (g_MsmInfo.m_sbMsmFileName.IsEmpty() == TRUE)
    {
        // set .msm filename
        UINT iRet = GetFullPathNameW(pszManifestFileName, NUMBER_OF(tmpbuf), tmpbuf, NULL);
        if ((iRet == 0) || (iRet > NUMBER_OF(tmpbuf)))
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }
                    
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(tmpbuf, wcslen(tmpbuf)));
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32ChangePathExtension(MSM_FILE_EXT, NUMBER_OF(MSM_FILE_EXT) -1, eAddIfNoExtension));
    }else{
        // get fullpath name
        UINT iRet = GetFullPathNameW(g_MsmInfo.m_sbMsmFileName, NUMBER_OF(tmpbuf), tmpbuf, NULL);
        if ((iRet == 0) || (iRet > NUMBER_OF(tmpbuf)))
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }
                    
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(tmpbuf, wcslen(tmpbuf)));
    }

    //
    // Set Cabinet FilePath
    //
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32Assign(g_MsmInfo.m_sbMsmFileName));
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32RemoveLastPathElement());
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32EnsureTrailingPathSeparator());
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32Append(MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1));

Exit:
    return hr;
}

//
// Functions:
//      (1)get the template msm file
//      (2)get the msm output file
//      (3)set static contents for some tables 
//
HRESULT PrepareMsmOutputFiles(PCWSTR pszManifestFilename)
{    
    HRESULT hr = S_OK;

    CurrentAssemblyReset;

    if (g_MsmInfo.m_sbMsmTemplateFile.IsEmpty() == TRUE)
    {
        //
        // get template file from current directory
        // 
        WCHAR path[MAX_PATH];
        DWORD dwRet;
        dwRet = GetModuleFileNameW(NULL, path, NUMBER_OF(path));
    
        if ((dwRet == 0) || (dwRet >= NUMBER_OF(path)))
            SET_HRERR_AND_EXIT(::GetLastError());

        IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(path, wcslen(path)));
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32ChangePathExtension(L"msm", 3,  eErrorIfNoExtension));        
    }

    if (::GetFileAttributesW(g_MsmInfo.m_sbMsmTemplateFile) == (DWORD) -1)
    {
        fprintf(stderr, "the specified Msm TemplateFile %S does not exist!\n", g_MsmInfo.m_sbMsmTemplateFile);
        SET_HRERR_AND_EXIT(::GetLastError());
    }

    IFFAILED_EXIT(SetMsmOutputFileName(pszManifestFilename));

    //
    // initialize the cabinet before the database is initialized because it may needed in 
    // the mode of "MSMGEN_OPR_ADD"
    //  
    IFFAILED_EXIT(InitializeCabinetForWrite());

    //
    // prepare the msm files for open    
    //    
    IFFAILED_EXIT(PrepareDatabase());

    //
    // set entries to Directory for downlevel support
    //
    IFFAILED_EXIT(SetDirectoryTable());


Exit:    
    return hr;
}

HRESULT PropagateXMLDOMNode(IXMLDOMNode*  node, ELEMENT_ALLOWED_ATTRIBUTE rgAllowedAttribute[], DWORD num)
{
    HRESULT hr = S_OK;
    IXMLDOMNamedNodeMap* pattrs = NULL;
    IXMLDOMNode* pChild = NULL;
    CStringBuffer tmp;
    DWORD j;
     
    CurrentAssemblyReset;
    
    for ( j = 0 ; j < num; j++)    
        rgAllowedAttribute[j].m_fValued = FALSE;
    
    // 
    // write MSIAssemblyName table
    //
    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name;
            pChild->get_nodeName(&name);
            for ( j = 0; j < num; j++)
            {
                if((rgAllowedAttribute[j].m_fValued == FALSE) && (wcscmp(rgAllowedAttribute[j].m_name, name) == 0))
                {
                    VARIANT value;
                    pChild->get_nodeValue(&value);
                    if (value.vt != VT_BSTR)
                    {
                        hr = E_FAIL;
                        break;
                    }

                    if ( ! rgAllowedAttribute[j].m_value->Win32Assign(V_BSTR(&value), wcslen(V_BSTR(&value))))                    
                        hr = HRESULT_FROM_WIN32(::GetLastError());

                    VariantClear(&value);
                    if ( !SUCCEEDED(hr))
                        break;

                    hr = S_OK;
                    if (rgAllowedAttribute[j].m_callbackFunc != NULL)
                        hr = rgAllowedAttribute[j].m_callbackFunc(
                                        rgAllowedAttribute[j].m_name,
                                        *(rgAllowedAttribute[j].m_value));

                    if ( !SUCCEEDED(hr))
                        break;
                    
                    rgAllowedAttribute[j].m_fValued = TRUE;                    
                }
            }

            //
            // cleaning work
            //
            SysFreeString(name);
            pChild->Release();
            pChild = NULL;

            if (!SUCCEEDED(hr))
            {
                pattrs->Release();
                pattrs = NULL;

                goto Exit;
            }
            pattrs->nextNode(&pChild);
        }

        pattrs->Release();
        pattrs = NULL;
    }
Exit:
    SAFE_RELEASE_COMPOINTER(pattrs);
    SAFE_RELEASE_COMPOINTER(pChild);

    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_file(IXMLDOMNode*  node)
{
    IXMLDOMNamedNodeMap* pattrs = NULL;
    IXMLDOMNode* pChild = NULL;    
    BOOL fFoundFileName = FALSE;
    HRESULT hr = S_OK;
    CStringBuffer tmpStr;
    CStringBuffer ShortLongPair;
    DWORD CchFullpathFilename;

    CurrentAssemblyReset;
    IFFALSE_EXIT(tmpStr.Win32Assign(curAsmInfo.m_sbAssemblyPath));

    //
    // get the filename from node
    //
    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name = NULL;
            pChild->get_nodeName(&name);
            if (wcscmp(name, L"name") == 0) 
            {
                VARIANT value;
                pChild->get_nodeValue(&value);
                if (value.vt != VT_BSTR)
                {
                    VariantClear(&value);
                    hr = E_FAIL;
                    break;
                }

                if ( !curAsmInfo.m_sbAssemblyPath.Win32Append(V_BSTR(&value), wcslen(V_BSTR(&value))))
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                VariantClear(&value);
                fFoundFileName = TRUE;                 
            }

            ::SysFreeString(name);
            pChild->Release();
            pChild = NULL;

            if (!SUCCEEDED(hr)){
                pattrs->Release();
                pattrs = NULL;

                goto Exit;
            }

            if ( fFoundFileName )
                break;

            pattrs->nextNode(&pChild);
        }
        if (pattrs)
        {
            pattrs->Release();
            pattrs = NULL;
        }
    }

    if ( !fFoundFileName)
        SETFAIL_AND_EXIT;

    CchFullpathFilename = curAsmInfo.m_sbAssemblyPath.GetCchAsDWORD();
    //
    // get fully qualified filename
    //
    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), ShortLongPair));

    //
    // check the existence of the file
    //
    if ( GetFileAttributesW(curAsmInfo.m_sbAssemblyPath) == DWORD(-1))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    //
    // get FileIdentifier for this file    
    //    
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    //
    // add the file to FileTable
    //    
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath),    // a.dll.12223423423423412343
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),      
        MAKE_PCWSTR(ShortLongPair)));                                         // a.dll | a.dll
    
    //
    // add this file to the cabinet
    //
    IFFAILED_EXIT(AddFileToCabinetW(
        curAsmInfo.m_sbAssemblyPath, CchFullpathFilename,
        curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch() - curAsmInfo.m_CchAssemblyPath)); 

    //
    // set Component Table with ComponentID, componentIdentifier, keypath: 
    //
    if (curAsmInfo.m_fComponentTableSet == FALSE)
    {
        IFFAILED_EXIT(SetComponentId(curAsmInfo.m_sbComponentIdentifier, curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath));
        curAsmInfo.m_fComponentTableSet = TRUE;
    }

Exit:    
    if (pattrs)
        pattrs->Release();

    if(pChild)
        pChild->Release();


    return hr;
}

BOOL IsValidAttributes(const ELEMENT_ALLOWED_ATTRIBUTE attribs[], DWORD num)
{
    for (DWORD i=0; i< num; i++)
    {
        if (attribs[i].m_fRequired && ! attribs[i].m_fValued)
        {
            ::SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    return TRUE;
}

HRESULT GetPrimAssemblyName(PCWSTR pwszAssemblyName, PWSTR pwszPrimAssemblyName, DWORD & cch)
{
    HRESULT hr = S_OK;
    DWORD i = 0, num = wcslen(pwszAssemblyName);

    if (cch < num)    
    {
        cch = num;
        SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(pwszPrimAssemblyName, pwszAssemblyName);

    while ( i < num)
    {
        if (pwszPrimAssemblyName[i] == L'-')
        {
            pwszPrimAssemblyName[i] = L'_';
        }
        i++;
    }

Exit:
    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_assemblyIdentity(IXMLDOMNode*  node)
{    
    //
    // we only are interested in the assemblyIdentity of the component, that is,
    // <assemblyIdentity .... /> at the head of manifest, ignore <assemblyIdentity ..../> of
    // dependency
    //
    if (curAsmInfo.m_sbComponentIdentifier.IsEmpty() == FALSE)
    {
        return S_OK;
    }
    
    HRESULT hr = S_OK;    
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_assemblyIdentity_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY] = 
    {
        {L"name", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
        {L"language", FALSE, NULL, FALSE, &rg_StringBuffer[1]},
        {L"version", TRUE, NULL, FALSE, &rg_StringBuffer[2]},
        {L"processorArchitecture", TRUE, NULL, FALSE, &rg_StringBuffer[3]},
        {L"publicKeyToken", FALSE, NULL, FALSE, &rg_StringBuffer[4]},
        {L"type", TRUE, NULL, FALSE, &rg_StringBuffer[5]}
    };
    

    CStringBuffer tmp;    
    WCHAR tmpbuf[MAX_PATH];
    DWORD num = NUMBER_OF(tmpbuf);
    
    CurrentAssemblyReset; 
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_assemblyIdentity_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY));
    IFFALSE_EXIT(IsValidAttributes(rg_assemblyIdentity_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY));

    IFFAILED_EXIT(GetPrimAssemblyName(*rg_assemblyIdentity_AllowedAttributes[MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_NAME].m_value, tmpbuf, num));

    //
    // Set module identifier
    //
    IFFALSE_EXIT(g_MsmInfo.m_sbModuleIdentifier.Win32Assign(tmpbuf, wcslen(tmpbuf)));
    IFFALSE_EXIT(g_MsmInfo.m_sbModuleIdentifier.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    //
    // set componentIdentifier and add entries to table which depends on componentIdentifier
    //    
    IFFALSE_EXIT(curAsmInfo.m_sbComponentIdentifier.Win32Assign(tmpbuf, wcslen(tmpbuf)));
    IFFALSE_EXIT(curAsmInfo.m_sbComponentIdentifier.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    //
    // insert manifest & catalog into File Table, cabinet,
    //
    IFFAILED_EXIT(SetManifestAndCatalog());

    //
    // write MsiAssemblyName table
    //
    for (DWORD i = 0; i < NUMBER_OF(rg_assemblyIdentity_AllowedAttributes); i++)
    {
        if (rg_assemblyIdentity_AllowedAttributes[i].m_fValued)
        {
            IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MSIASSEMBLYNAME, 
                            NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLYNAME, 
                            MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
                            MAKE_PCWSTR(rg_assemblyIdentity_AllowedAttributes[i].m_name), 
                            MAKE_PCWSTR(*rg_assemblyIdentity_AllowedAttributes[i].m_value)));
        }
    }

    //
    // write MsiAssebly Table
    //
    curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName);    
    IFFALSE_EXIT(curAsmInfo.m_sbManifestFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));
           
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_MSIASSEMBLY, 
        NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLY,
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
        MAKE_PCWSTR(GUID_NULL_IN_STRING),                                
        MAKE_PCWSTR(curAsmInfo.m_sbManifestFileName))); // sfp.manifest.12343454534534534

    //
    // write ModuleSiguature table using version
    //
    BOOL fExist; 
    IFFAILED_EXIT(ExecuteQuerySQL(L"ModuleSignature", L"ModuleID", g_MsmInfo.m_sbModuleIdentifier, fExist, NULL));
    if ( fExist == FALSE)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MODULESIGNATURE, 
            NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULESIGNATURE, 
            MAKE_PCWSTR(g_MsmInfo.m_sbModuleIdentifier), 
            MAKE_PCWSTR(*rg_assemblyIdentity_AllowedAttributes[MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_VERSION].m_value)));
    }else
    {
        // updateRecord

    }
    
    //
    // write ModuleComponent table using version
    //

    IFFAILED_EXIT(ExecuteQuerySQL(L"ModuleComponents", L"Component", curAsmInfo.m_sbComponentIdentifier, fExist, NULL));
    if ( fExist == FALSE)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MODULECOMPONENTS, 
            NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULECOMPONENTS,
            MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
            MAKE_PCWSTR(g_MsmInfo.m_sbModuleIdentifier)));
    }else
    {
        // updateRecord
    }

Exit:
    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_comClass(IXMLDOMNode*  node)
{
    HRESULT hr = S_OK;

    // About this array : 
    //      0, 2 would be stored in class table
    //      1 would be stored in progid table
    //      3 would be ignored and Typelib Table would be created when "<typelib  />" is encounter
    //      4 would be ignored
    //
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_comClass_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS] = {
            {L"clsid", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
            {L"description", FALSE, NULL, FALSE, &rg_StringBuffer[1]},
            {L"progid", FALSE, NULL, FALSE, &rg_StringBuffer[2]},           
            {L"tlbid", FALSE, NULL, FALSE, &rg_StringBuffer[3]},
            {L"threadingModel", FALSE, NULL, FALSE, &rg_StringBuffer[4]}
    };
    
    CurrentAssemblyReset;
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_comClass_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS));
    IFFALSE_EXIT(IsValidAttributes(rg_comClass_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS));

    //
    // if the progId is not NULL, Insert an entry to ProgID Table
    //
    if (rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_fValued)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL( 
            OPT_PROGID,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_PROGID,
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_value),
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_CLSID].m_value),
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION].m_value)));
    }

    //
    // insert one entry to ClassTable 
    //
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_CLASS,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_CLASS,
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_CLSID].m_value),        
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_value),
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION].m_value),
        MAKE_PCWSTR(GUID_NULL_IN_STRING)));

Exit:
    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_typelib(IXMLDOMNode*  node)
{

    HRESULT hr = S_OK;

    //
    // all of three attributes are required for "<typelib .... />" element
    //
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_typelib_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB] = {
        {L"tlbid", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
        {L"version", TRUE, NULL, FALSE, &rg_StringBuffer[1]},
        {L"helpdir", TRUE, NULL, FALSE, &rg_StringBuffer[2]}
    };
    
    CurrentAssemblyReset;
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_typelib_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB));
    IFFALSE_EXIT(IsValidAttributes(rg_typelib_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB));

    //
    // insert one entry to class table
    //
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_TYPELIB,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_TYPELIB,
        MAKE_PCWSTR(*rg_typelib_AllowedAttributes[MSMGEN_TYPELIB_ATTRIBUTE_TLBID].m_value),
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(*rg_typelib_AllowedAttributes[MSMGEN_TYPELIB_ATTRIBUTE_VERSION].m_value),
        MAKE_PCWSTR(GUID_NULL_IN_STRING)));

Exit:
    return hr;
}

HRESULT InsertCabinetIntoMsm()
{    
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRec = NULL;

    CurrentAssemblyReset;

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewA(g_MsmInfo.m_hdb, "INSERT INTO `_Streams` (`Name`, `Data`) VALUES (?, ?)", &hView));        
    
    hRec = ::MsiCreateRecord(2);
    if (NULL == hRec)
        SETFAIL_AND_EXIT;
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStringW(hRec, 1, MERGEMODULE_CABINET_FILENAME));    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStreamW(hRec, 2, g_MsmInfo.m_sbCabinet));
        
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRec));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewClose(hView));

Exit:    
	return hr;
}

//
// each entry in Component Table always need a KeyPath, which is a datafile
// for some assembly, which has no datafile or policy assembly, we have to add an entry to ComponentTable at the end 
// of the generation
//
HRESULT CheckComponentTable()
{
    HRESULT hr = S_OK;

    if (curAsmInfo.m_fComponentTableSet == FALSE)
    {
        IFFAILED_EXIT(SetComponentId(curAsmInfo.m_sbComponentIdentifier, NULL));
        curAsmInfo.m_fComponentTableSet = TRUE;
    }
Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\merge_placefiles\merge_placefiles.cpp ===
/*
This program merges binplace placefiles.
It reads in the files named on the command line, and
writes out a merged placefile to stdout.
*/

#include "yvals.h"
#pragma warning(disable:4100)
#pragma warning(disable:4663)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4127)
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <string.h>
#include <set>
#include "strtok_r.h"
#include "windows.h"

const char comment_char = ';';
const char comment_chars[] = { comment_char , 0 };
const char horizontal_whitespace_chars[] = { ' ', '\t', 0 };
const char destination_delim = ':';
const char destination_delims[] = { destination_delim, 0 };

class String_t : public std::string
{
	typedef std::string Base;
public:
	String_t(const std::string & s) : Base(s) { }
	String_t() { }
	~String_t() { }
	String_t(const String_t & s) : Base(s) { }
	String_t(const char * s) : Base(s) { }

	bool operator<( const String_t & s) const
	{
		return _stricmp(c_str(), s.c_str()) < 0;
	}

	bool operator==( const String_t & s) const
	{
		return _stricmp(c_str(), s.c_str()) == 0;
	}
};

class File_t : public std::map<String_t, std::set<String_t> >
{
public:
	void Read( const char * filename );
};

class CMutableString
{
public:
	CMutableString() { }

	CMutableString(const char * s)
	{
		size_t len = strlen(s);
		this->chars.resize(len + 1);
		strcpy(&this->chars[0], s);
	}

	size_t length() const { return ::strlen(&chars[0]); }

	void operator=(const CMutableString & t)
	{
		if (&t == this)
			return;
		this->chars = t.chars;
	}

	void operator=(const char * s)
	{
		//
		// s may point into chars, and resize may realloc, so use a temp
		//
		CMutableString temp(s);
		std::swap(this->chars, temp.chars);
	}

	operator char * () { return &chars[0]; }

	std::vector<char> chars;
};

class CStringTokenizer
{
public:
	CStringTokenizer() : state(0) { }
	~CStringTokenizer() { }

	char * operator()(char * string, const char * delims)
	{
		return strtok_r(string, delims, &state);
	}

	char * state;
};

void TrimHorizontalWhitespaceFromEnds(char * & s)
{
	s += strspn(s, horizontal_whitespace_chars);
	char * q = s + strlen(s);
	while (q != s && strchr(horizontal_whitespace_chars, *q) != NULL)
	{
		*q = 0;
		q -= 1;
	}
}
void File_t::Read(const char * filename)
{
	String_t line;
	std::ifstream file;
	CMutableString mutable_line;
	char * p = 0;

	file.open(filename, std::ios_base::in);
	while (std::getline(file, line))
	{
		mutable_line = line.c_str();
		p = mutable_line;
		p += strspn(p, horizontal_whitespace_chars);
		if (p[0] == 0)
			continue;
		if (strchr(comment_chars, p[0]) != NULL)
			continue;
		char * comment = strchr(p, comment_char);
		if (comment != NULL)
			*comment = 0;
		mutable_line = p;
		p = mutable_line;

		const char * image_name = p;
		p += strcspn(p, horizontal_whitespace_chars);
		*p = 0;
		const String_t image_name_string = image_name;
		p += 1;
		p += strspn(p, horizontal_whitespace_chars);
		char * destinations = p;

		TrimHorizontalWhitespaceFromEnds(destinations);

		CStringTokenizer tokenize;
		for ( char * destination = tokenize(destinations, destination_delims) ; 
				destination != NULL ;
				destination = tokenize(NULL, destination_delims)
				)
		{
			(*this)[image_name_string].insert(destination);
			//printf("%s -> %s\n", image_name, destination);
		}
	}
}

void MergePlacefiles(int nfiles, char ** filenames)
{
	File_t accum;
	if (nfiles == 0)
		return;
	for ( int i = 0  ; i < nfiles - 1; ++i )
	{
		accum.Read(filenames[i]);
	}
	DeleteFileA(filenames[nfiles - 1]);
	FILE * fout = fopen(filenames[nfiles - 1], "w");
	if (fout == NULL)
	{
		fprintf(stderr, "Error fopen(%s)\n", filenames[nfiles - 1]);
		exit(-1);
	}
	for (
		File_t::const_iterator it = accum.begin();
		it != accum.end();
		++it
		)
	{
		fprintf(fout, "%s ", it->first.c_str());
		bool first = true;
		for (
			std::set<String_t>::const_iterator it2 = it->second.begin();
			it2 != it->second.end();
			++it2
			)
		{
			if (!first)
				fprintf(fout, ":");
			fprintf(fout, "%s", it2->c_str());
			first = false;
		}
		fprintf(fout, "\n");
	}
	fclose(fout);
}

int __cdecl main(int argc, char ** argv)
{
	MergePlacefiles(argc - 1 , argv + 1);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\mergemod.h ===
/*****************************************************************************\
                                                                             
 mergemod.h - - Interface for MergeMod COM object                            
                                                                             
 Version 1.5                                                                 
                                                                             
 NOTES:  All strings are of type BSTR. For [in] strings, LPCWSTR may be      
 safely used instead, the object will not try to free this memory.           
 All [out] BSTR values must be released by the client.                       
                                                                             
 Copyright (c) 1998-2000, Microsoft Corp.      All rights reserved.          
                                                                             
\*****************************************************************************/

#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mergemod_h__
#define __mergemod_h__

#ifndef _WIN32_MSM
#define _WIN32_MSM   100
#endif // !_WIN32_MSM

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumMsmString_FWD_DEFINED__
#define __IEnumMsmString_FWD_DEFINED__
typedef interface IEnumMsmString IEnumMsmString;
#endif 	/* __IEnumMsmString_FWD_DEFINED__ */


#ifndef __IMsmStrings_FWD_DEFINED__
#define __IMsmStrings_FWD_DEFINED__
typedef interface IMsmStrings IMsmStrings;
#endif 	/* __IMsmStrings_FWD_DEFINED__ */


#ifndef __IMsmError_FWD_DEFINED__
#define __IMsmError_FWD_DEFINED__
typedef interface IMsmError IMsmError;
#endif 	/* __IMsmError_FWD_DEFINED__ */


#ifndef __IEnumMsmError_FWD_DEFINED__
#define __IEnumMsmError_FWD_DEFINED__
typedef interface IEnumMsmError IEnumMsmError;
#endif 	/* __IEnumMsmError_FWD_DEFINED__ */


#ifndef __IMsmErrors_FWD_DEFINED__
#define __IMsmErrors_FWD_DEFINED__
typedef interface IMsmErrors IMsmErrors;
#endif 	/* __IMsmErrors_FWD_DEFINED__ */


#ifndef __IMsmDependency_FWD_DEFINED__
#define __IMsmDependency_FWD_DEFINED__
typedef interface IMsmDependency IMsmDependency;
#endif 	/* __IMsmDependency_FWD_DEFINED__ */


#ifndef __IEnumMsmDependency_FWD_DEFINED__
#define __IEnumMsmDependency_FWD_DEFINED__
typedef interface IEnumMsmDependency IEnumMsmDependency;
#endif 	/* __IEnumMsmDependency_FWD_DEFINED__ */


#ifndef __IMsmDependencies_FWD_DEFINED__
#define __IMsmDependencies_FWD_DEFINED__
typedef interface IMsmDependencies IMsmDependencies;
#endif 	/* __IMsmDependencies_FWD_DEFINED__ */


#ifndef __IMsmMerge_FWD_DEFINED__
#define __IMsmMerge_FWD_DEFINED__
typedef interface IMsmMerge IMsmMerge;
#endif 	/* __IMsmMerge_FWD_DEFINED__ */


#ifndef __IMsmGetFiles_FWD_DEFINED__
#define __IMsmGetFiles_FWD_DEFINED__
typedef interface IMsmGetFiles IMsmGetFiles;
#endif 	/* __IMsmGetFiles_FWD_DEFINED__ */


#ifndef __IMsmStrings_FWD_DEFINED__
#define __IMsmStrings_FWD_DEFINED__
typedef interface IMsmStrings IMsmStrings;
#endif 	/* __IMsmStrings_FWD_DEFINED__ */


#ifndef __IMsmError_FWD_DEFINED__
#define __IMsmError_FWD_DEFINED__
typedef interface IMsmError IMsmError;
#endif 	/* __IMsmError_FWD_DEFINED__ */


#ifndef __IMsmErrors_FWD_DEFINED__
#define __IMsmErrors_FWD_DEFINED__
typedef interface IMsmErrors IMsmErrors;
#endif 	/* __IMsmErrors_FWD_DEFINED__ */


#ifndef __IMsmDependency_FWD_DEFINED__
#define __IMsmDependency_FWD_DEFINED__
typedef interface IMsmDependency IMsmDependency;
#endif 	/* __IMsmDependency_FWD_DEFINED__ */


#ifndef __IMsmDependencies_FWD_DEFINED__
#define __IMsmDependencies_FWD_DEFINED__
typedef interface IMsmDependencies IMsmDependencies;
#endif 	/* __IMsmDependencies_FWD_DEFINED__ */


#ifndef __IMsmGetFiles_FWD_DEFINED__
#define __IMsmGetFiles_FWD_DEFINED__
typedef interface IMsmGetFiles IMsmGetFiles;
#endif 	/* __IMsmGetFiles_FWD_DEFINED__ */

#if (_WIN32_MSM >= 150)

#ifndef __IMsmConfigurableItem_FWD_DEFINED__
#define __IMsmConfigurableItem_FWD_DEFINED__
typedef interface IMsmConfigurableItem IMsmConfigurableItem;
#endif 	/* __IMsmConfigurableItem_FWD_DEFINED__ */


#ifndef __IEnumMsmConfigurableItem_FWD_DEFINED__
#define __IEnumMsmConfigurableItem_FWD_DEFINED__
typedef interface IEnumMsmConfigurableItem IEnumMsmConfigurableItem;
#endif 	/* __IEnumMsmConfigurableItem_FWD_DEFINED__ */


#ifndef __IMsmConfigurableItems_FWD_DEFINED__
#define __IMsmConfigurableItems_FWD_DEFINED__
typedef interface IMsmConfigurableItems IMsmConfigurableItems;
#endif 	/* __IMsmConfigurableItems_FWD_DEFINED__ */

#ifndef __IMsmMerge2_FWD_DEFINED__
#define __IMsmMerge2_FWD_DEFINED__
typedef interface IMsmMerge2 IMsmMerge2;
#endif 	/* __IMsmMerge2_FWD_DEFINED__ */

#ifndef __IMsmConfigureModule_FWD_DEFINED__
#define __IMsmConfigureModule_FWD_DEFINED__
typedef interface IMsmConfigureModule IMsmConfigureModule;
#endif 	/* __IMsmConfigureModule_FWD_DEFINED__ */

#ifndef __MsmMerge2_FWD_DEFINED__
#define __MsmMerge2_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsmMerge2 MsmMerge2;
#else
typedef struct MsmMerge2 MsmMerge2;
#endif /* __cplusplus */

#endif 	/* __MsmMerge2_FWD_DEFINED__ */


#endif /* _WIN32_MSM */

#ifndef __MsmMerge_FWD_DEFINED__
#define __MsmMerge_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsmMerge MsmMerge;
#else
typedef struct MsmMerge MsmMerge;
#endif /* __cplusplus */

#endif 	/* __MsmMerge_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

// --------------------------------------------------------------------------
// MergeMod Interface IDs
// --------------------------------------------------------------------------
/* [local] */ 


#ifndef __FORWARD_IID_IMSMMERGETYPELIB
#define __FORWARD_IID_IMSMMERGETYPELIB
const IID IID_IEnumMsmString = {0x0ADDA826,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmStrings = {0x0ADDA827,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmError = {0x0ADDA828,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IEnumMsmError = {0x0ADDA829,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmErrors = {0x0ADDA82A,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmDependency = {0x0ADDA82B,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IEnumMsmDependency = {0x0ADDA82C,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmDependencies = {0x0ADDA82D,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmMerge = {0x0ADDA82E,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const IID IID_IMsmGetFiles = {0x7041ae26, 0x2d78, 0x11d2, { 0x88, 0x8a, 0x0, 0xa0, 0xc9, 0x81, 0xb0, 0x15 } };

const IID LIBID_MsmMergeTypeLib = {0x0ADDA82F,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};
const CLSID CLSID_MsmMerge = {0x0ADDA830,0x2C26,0x11D2,{0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6}};

#if (_WIN32_MSM >= 150)
const IID IID_IMsmMerge2 = {0x351A72AB, 0x21CB, 0x47AB, {0xB7, 0xAA, 0xC4, 0xD7, 0xB0, 0x2E, 0xA3, 0x05 } };
const IID IID_IMsmConfigurableItem = {0x4D6E6284, 0xD21D, 0x401E, {0x84, 0xF6, 0x90, 0x9E, 0x00, 0xB5, 0x0F, 0x71 } };
const IID IID_IEnumMsmConfigurableItem = {0x832C6969, 0x4826, 0x4C24, {0xA3, 0x97, 0xB7, 0x00, 0x2D, 0x81, 0x96, 0xE6 } };
const IID IID_IMsmConfigurableItems = {0x55BF723C, 0x9A0D, 0x463E, {0xB4, 0x2B, 0xB4, 0xFB, 0xC7, 0xBE, 0x3C, 0x7C } };
const IID IID_IMsmConfigureModule = {0xAC013209, 0x18A7, 0x4851, {0x8A, 0x21, 0x23, 0x53, 0x44, 0x3D, 0x70, 0xA0 } };
const CLSID CLSID_MsmMerge2 = {0xF94985D5,0x29F9,0x4743,{ 0x98,0x05,0x99,0xBC,0x3F,0x35,0xB6,0x78}};
#endif

// --------------------------------------------------------------------------
// MergeMod error types, returned from IMsmError::get_Type
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */ 
enum msmErrorType
    {	
	msmErrorLanguageUnsupported	= 1,
	msmErrorLanguageFailed          = 2,
	msmErrorExclusion	            = 3,
	msmErrorTableMerge	            = 4,
	msmErrorResequenceMerge	        = 5,
	msmErrorFileCreate	            = 6,
	msmErrorDirCreate	            = 7,
	msmErrorFeatureRequired	        = 8,

#if (_WIN32_MSM >= 150)
	msmErrorBadNullSubstitution     = 9,
	msmErrorBadSubstitutionType     = 10,
	msmErrorMissingConfigItem       = 11,
	msmErrorBadNullResponse         = 12,
	msmErrorDataRequestFailed       = 13    
#endif

	}	
	msmErrorType;

#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// MergeMod formats for ModuleConfiguration items.
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */ 
enum msmConfigurableItemFormat
    {
	msmConfigurableItemText = 0,
	msmConfigurableItemKey = 1,
	msmConfigurableItemInteger = 2,
	msmConfigurableItemBitfield = 3
    }
    msmConfigurableItemFormat;


// --------------------------------------------------------------------------
// MergeMod options for ModuleConfiguration items.
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */   
enum msmConfigurableItemOptions
    {	
	msmConfigurableOptionKeyNoOrphan	= 1,
	msmConfigurableOptionNonNullable	= 2
    } 	
    msmConfigurableItemOptions;


#endif


#endif // __FORWARD_IID_IMSMMERGETYPELIB

extern RPC_IF_HANDLE __MIDL_itf_mergemod_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mergemod_0000_v0_0_s_ifspec;


// --------------------------------------------------------------------------
// IEnumMsmString - enumeration of BSTR
// --------------------------------------------------------------------------

#ifndef __IEnumMsmString_INTERFACE_DEFINED__
#define __IEnumMsmString_INTERFACE_DEFINED__


EXTERN_C const IID IID_IEnumMsmString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA826-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmString __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmString __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings);
        
        END_INTERFACE
    } IEnumMsmStringVtbl;

    interface IEnumMsmString
    {
        CONST_VTBL struct IEnumMsmStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmString_Next(This,cFetch,rgbstrStrings,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgbstrStrings,pcFetched)

#define IEnumMsmString_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmString_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmString_Clone(This,pemsmStrings)	\
    (This)->lpVtbl -> Clone(This,pemsmStrings)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmString_Next_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmString_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Skip_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmString_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Reset_Proxy( 
    IEnumMsmString __RPC_FAR * This);


void __RPC_STUB IEnumMsmString_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Clone_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings);


void __RPC_STUB IEnumMsmString_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMsmString_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmStrings - a collection of MergeMod BSTR
// --------------------------------------------------------------------------

#ifndef __IMsmStrings_INTERFACE_DEFINED__
#define __IMsmStrings_INTERFACE_DEFINED__


EXTERN_C const IID IID_IMsmStrings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA827-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmStrings : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ BSTR __RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmStringsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmStrings __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmStrings __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmStrings __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ BSTR __RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmStrings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmStrings __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmStringsVtbl;

    interface IMsmStrings
    {
        CONST_VTBL struct IMsmStringsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmStrings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmStrings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmStrings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmStrings_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmStrings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmStrings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmStrings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmStrings_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmStrings_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmStrings_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get_Item_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ BSTR __RPC_FAR *Return);


void __RPC_STUB IMsmStrings_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get_Count_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmStrings_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get__NewEnum_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmStrings_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmStrings_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmError - interface for retrieving details on a single merge error
// --------------------------------------------------------------------------

#ifndef __IMsmError_INTERFACE_DEFINED__
#define __IMsmError_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA828-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ short __RPC_FAR *ErrorLanguage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabaseTable( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabaseKeys( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleTable( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleKeys( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *ErrorLanguage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DatabaseTable )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DatabaseKeys )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleTable )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleKeys )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);
        
        END_INTERFACE
    } IMsmErrorVtbl;

    interface IMsmError
    {
        CONST_VTBL struct IMsmErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmError_get_Type(This,ErrorType)	\
    (This)->lpVtbl -> get_Type(This,ErrorType)

#define IMsmError_get_Path(This,ErrorPath)	\
    (This)->lpVtbl -> get_Path(This,ErrorPath)

#define IMsmError_get_Language(This,ErrorLanguage)	\
    (This)->lpVtbl -> get_Language(This,ErrorLanguage)

#define IMsmError_get_DatabaseTable(This,ErrorTable)	\
    (This)->lpVtbl -> get_DatabaseTable(This,ErrorTable)

#define IMsmError_get_DatabaseKeys(This,ErrorKeys)	\
    (This)->lpVtbl -> get_DatabaseKeys(This,ErrorKeys)

#define IMsmError_get_ModuleTable(This,ErrorTable)	\
    (This)->lpVtbl -> get_ModuleTable(This,ErrorTable)

#define IMsmError_get_ModuleKeys(This,ErrorKeys)	\
    (This)->lpVtbl -> get_ModuleKeys(This,ErrorKeys)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Type_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType);


void __RPC_STUB IMsmError_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Path_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorPath);


void __RPC_STUB IMsmError_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Language_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *ErrorLanguage);


void __RPC_STUB IMsmError_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_DatabaseTable_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);


void __RPC_STUB IMsmError_get_DatabaseTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_DatabaseKeys_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);


void __RPC_STUB IMsmError_get_DatabaseKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_ModuleTable_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);


void __RPC_STUB IMsmError_get_ModuleTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_ModuleKeys_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);


void __RPC_STUB IMsmError_get_ModuleKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmError_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmError - enumeration of IMsmError interfaces
// --------------------------------------------------------------------------

#ifndef __IEnumMsmError_INTERFACE_DEFINED__
#define __IEnumMsmError_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumMsmError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA829-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmError __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors);
        
        END_INTERFACE
    } IEnumMsmErrorVtbl;

    interface IEnumMsmError
    {
        CONST_VTBL struct IEnumMsmErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmError_Next(This,cFetch,rgmsmErrors,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmErrors,pcFetched)

#define IEnumMsmError_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmError_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmError_Clone(This,pemsmErrors)	\
    (This)->lpVtbl -> Clone(This,pemsmErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmError_Next_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmError_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Skip_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmError_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Reset_Proxy( 
    IEnumMsmError __RPC_FAR * This);


void __RPC_STUB IEnumMsmError_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Clone_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors);


void __RPC_STUB IEnumMsmError_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IEnumMsmError_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmErrors - collection of IMsmError interfaces
// --------------------------------------------------------------------------

#ifndef __IMsmErrors_INTERFACE_DEFINED__
#define __IMsmErrors_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmErrors;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82A-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmErrors : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmErrorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmErrors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmErrors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmErrors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmErrors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmErrors __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmErrorsVtbl;

    interface IMsmErrors
    {
        CONST_VTBL struct IMsmErrorsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmErrors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmErrors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmErrors_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmErrors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmErrors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmErrors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmErrors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmErrors_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmErrors_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmErrors_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get_Item_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmErrors_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get_Count_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmErrors_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get__NewEnum_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmErrors_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmErrors_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmDependency - interface for retrieving details on a single module 
//   dependency.
// --------------------------------------------------------------------------

#ifndef __IMsmDependency_INTERFACE_DEFINED__
#define __IMsmDependency_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmDependency;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82B-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmDependency : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Module( 
            /* [retval][out] */ BSTR __RPC_FAR *Module) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ short __RPC_FAR *Language) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *Version) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmDependencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmDependency __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmDependency __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Module )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Module);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *Language);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Version);
        
        END_INTERFACE
    } IMsmDependencyVtbl;

    interface IMsmDependency
    {
        CONST_VTBL struct IMsmDependencyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmDependency_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmDependency_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmDependency_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmDependency_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmDependency_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmDependency_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmDependency_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmDependency_get_Module(This,Module)	\
    (This)->lpVtbl -> get_Module(This,Module)

#define IMsmDependency_get_Language(This,Language)	\
    (This)->lpVtbl -> get_Language(This,Language)

#define IMsmDependency_get_Version(This,Version)	\
    (This)->lpVtbl -> get_Version(This,Version)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Module_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Module);


void __RPC_STUB IMsmDependency_get_Module_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Language_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *Language);


void __RPC_STUB IMsmDependency_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Version_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Version);


void __RPC_STUB IMsmDependency_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmDependency_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmDependency - enumeration of IMsmDependency interfaces
// --------------------------------------------------------------------------

#ifndef __IEnumMsmDependency_INTERFACE_DEFINED__
#define __IEnumMsmDependency_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumMsmDependency;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82C-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmDependency : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmDependencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies);
        
        END_INTERFACE
    } IEnumMsmDependencyVtbl;

    interface IEnumMsmDependency
    {
        CONST_VTBL struct IEnumMsmDependencyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmDependency_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmDependency_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmDependency_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmDependency_Next(This,cFetch,rgmsmDependencies,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmDependencies,pcFetched)

#define IEnumMsmDependency_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmDependency_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmDependency_Clone(This,pemsmDependencies)	\
    (This)->lpVtbl -> Clone(This,pemsmDependencies)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Next_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmDependency_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Skip_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmDependency_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Reset_Proxy( 
    IEnumMsmDependency __RPC_FAR * This);


void __RPC_STUB IEnumMsmDependency_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Clone_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies);


void __RPC_STUB IEnumMsmDependency_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IEnumMsmDependency_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmDependencies - collection of IMsmDependency interfaces
// --------------------------------------------------------------------------

#ifndef __IMsmDependencies_INTERFACE_DEFINED__
#define __IMsmDependencies_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmDependencies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82D-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmDependencies : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmDependenciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmDependencies __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmDependencies __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmDependencies __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmDependencies __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmDependencies __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmDependenciesVtbl;

    interface IMsmDependencies
    {
        CONST_VTBL struct IMsmDependenciesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmDependencies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmDependencies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmDependencies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmDependencies_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmDependencies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmDependencies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmDependencies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmDependencies_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmDependencies_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmDependencies_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get_Item_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmDependencies_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get_Count_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmDependencies_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get__NewEnum_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmDependencies_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmDependencies_INTERFACE_DEFINED__ */


// the following interfaces are available only on MergeMod v1.5 or later
#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// IMsmConfigurableItem - object describing the properties of a single
// configurable item.
// --------------------------------------------------------------------------


#ifndef __IMsmConfigurableItem_INTERFACE_DEFINED__
#define __IMsmConfigurableItem_INTERFACE_DEFINED__


EXTERN_C const IID IID_IMsmConfigurableItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D6E6284-D21D-401E-84F6-909E00B50F71")
    IMsmConfigurableItem : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Format( 
            /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *Type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Context( 
            /* [retval][out] */ BSTR __RPC_FAR *Context) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultValue( 
            /* [retval][out] */ BSTR __RPC_FAR *DefaultValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *Attributes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *DisplayName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *Description) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HelpLocation( 
            /* [retval][out] */ BSTR __RPC_FAR *HelpLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HelpKeyword( 
            /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigurableItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigurableItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Format )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Context )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Context);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultValue )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *DefaultValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Attributes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *DisplayName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Description);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpLocation )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *HelpLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpKeyword )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword);
        
        END_INTERFACE
    } IMsmConfigurableItemVtbl;

    interface IMsmConfigurableItem
    {
        CONST_VTBL struct IMsmConfigurableItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigurableItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigurableItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigurableItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigurableItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigurableItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigurableItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigurableItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigurableItem_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMsmConfigurableItem_get_Format(This,Format)	\
    (This)->lpVtbl -> get_Format(This,Format)

#define IMsmConfigurableItem_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IMsmConfigurableItem_get_Context(This,Context)	\
    (This)->lpVtbl -> get_Context(This,Context)

#define IMsmConfigurableItem_get_DefaultValue(This,DefaultValue)	\
    (This)->lpVtbl -> get_DefaultValue(This,DefaultValue)

#define IMsmConfigurableItem_get_Attributes(This,Attributes)	\
    (This)->lpVtbl -> get_Attributes(This,Attributes)

#define IMsmConfigurableItem_get_DisplayName(This,DisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,DisplayName)

#define IMsmConfigurableItem_get_Description(This,Description)	\
    (This)->lpVtbl -> get_Description(This,Description)

#define IMsmConfigurableItem_get_HelpLocation(This,HelpLocation)	\
    (This)->lpVtbl -> get_HelpLocation(This,HelpLocation)

#define IMsmConfigurableItem_get_HelpKeyword(This,HelpKeyword)	\
    (This)->lpVtbl -> get_HelpKeyword(This,HelpKeyword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Name_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IMsmConfigurableItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Format_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format);


void __RPC_STUB IMsmConfigurableItem_get_Format_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Type_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Type);


void __RPC_STUB IMsmConfigurableItem_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Context_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Context);


void __RPC_STUB IMsmConfigurableItem_get_Context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_DefaultValue_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *DefaultValue);


void __RPC_STUB IMsmConfigurableItem_get_DefaultValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Attributes_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Attributes);


void __RPC_STUB IMsmConfigurableItem_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_DisplayName_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *DisplayName);


void __RPC_STUB IMsmConfigurableItem_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Description_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Description);


void __RPC_STUB IMsmConfigurableItem_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_HelpLocation_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *HelpLocation);


void __RPC_STUB IMsmConfigurableItem_get_HelpLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_HelpKeyword_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword);


void __RPC_STUB IMsmConfigurableItem_get_HelpKeyword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigurableItem_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmConfigurableItem - enumerator for configurable items
// --------------------------------------------------------------------------

#ifndef __IEnumMsmConfigurableItem_INTERFACE_DEFINED__
#define __IEnumMsmConfigurableItem_INTERFACE_DEFINED__


EXTERN_C const IID IID_IEnumMsmConfigurableItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("832C6969-4826-4C24-A397-B7002D8196E6")
    IEnumMsmConfigurableItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmConfigurableItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem);
        
        END_INTERFACE
    } IEnumMsmConfigurableItemVtbl;

    interface IEnumMsmConfigurableItem
    {
        CONST_VTBL struct IEnumMsmConfigurableItemVtbl __RPC_FAR *lpVtbl;
    };

    
#ifdef COBJMACROS


#define IEnumMsmConfigurableItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmConfigurableItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmConfigurableItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmConfigurableItem_Next(This,cFetch,rgmsmItems,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmItems,pcFetched)

#define IEnumMsmConfigurableItem_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmConfigurableItem_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmConfigurableItem_Clone(This,pemsmConfigurableItem)	\
    (This)->lpVtbl -> Clone(This,pemsmConfigurableItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Next_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmConfigurableItem_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Skip_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmConfigurableItem_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Reset_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This);


void __RPC_STUB IEnumMsmConfigurableItem_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Clone_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem);


void __RPC_STUB IEnumMsmConfigurableItem_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMsmConfigurableItem_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmConfigurableItems - collection of configurable items
// --------------------------------------------------------------------------


#ifndef __IMsmConfigurableItems_INTERFACE_DEFINED__
#define __IMsmConfigurableItems_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmConfigurableItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55BF723C-9A0D-463E-B42B-B4FBC7BE3C7C")
    IMsmConfigurableItems : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigurableItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigurableItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigurableItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmConfigurableItemsVtbl;

    interface IMsmConfigurableItems
    {
        CONST_VTBL struct IMsmConfigurableItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigurableItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigurableItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigurableItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigurableItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigurableItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigurableItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigurableItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigurableItems_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmConfigurableItems_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmConfigurableItems_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get_Item_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmConfigurableItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get_Count_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmConfigurableItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get__NewEnum_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmConfigurableItems_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigurableItems_INTERFACE_DEFINED__ */



// --------------------------------------------------------------------------
// IMsmConfigureModule - callback interface called by the MergeMod object. 
// Allows the client to provide merge configuration information during the
// merge process.
// --------------------------------------------------------------------------

#ifndef __IMsmConfigureModule_INTERFACE_DEFINED__
#define __IMsmConfigureModule_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmConfigureModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC013209-18A7-4851-8A21-2353443D70A0")
    IMsmConfigureModule : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvideTextData( 
            /* [in] */ const BSTR Name,
            /* [retval][out] */ BSTR __RPC_FAR *ConfigData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvideIntegerData( 
            /* [in] */ const BSTR Name,
            /* [retval][out] */ long __RPC_FAR *ConfigData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigureModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigureModule __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigureModule __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProvideTextData )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ const BSTR Name,
            /* [retval][out] */ BSTR __RPC_FAR *ConfigData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProvideIntegerData )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ const BSTR Name,
            /* [retval][out] */ long __RPC_FAR *ConfigData);
        
        END_INTERFACE
    } IMsmConfigureModuleVtbl;

    interface IMsmConfigureModule
    {
        CONST_VTBL struct IMsmConfigureModuleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigureModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigureModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigureModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigureModule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigureModule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigureModule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigureModule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigureModule_ProvideTextData(This,Name,ConfigData)	\
    (This)->lpVtbl -> ProvideTextData(This,Name,ConfigData)

#define IMsmConfigureModule_ProvideIntegerData(This,Name,ConfigData)	\
    (This)->lpVtbl -> ProvideIntegerData(This,Name,ConfigData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmConfigureModule_ProvideTextData_Proxy( 
    IMsmConfigureModule __RPC_FAR * This,
    /* [in] */ const BSTR Name,
    /* [retval][out] */ BSTR __RPC_FAR *ConfigData);


void __RPC_STUB IMsmConfigureModule_ProvideTextData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmConfigureModule_ProvideIntegerData_Proxy( 
    IMsmConfigureModule __RPC_FAR * This,
    /* [in] */ const BSTR Name,
    /* [retval][out] */ long __RPC_FAR *ConfigData);


void __RPC_STUB IMsmConfigureModule_ProvideIntegerData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigureModule_INTERFACE_DEFINED__ */


#endif // _MSM_WIN32 >= 150

// --------------------------------------------------------------------------
// IMsmMerge - primary interface to the MergeMod object. Allows the client
// to open and close databases, perform merges, retrieve the results
// of a merge, control the creation of a debug-level log, and extract the
// files from a module to disk.
// --------------------------------------------------------------------------

#ifndef __IMsmMerge_INTERFACE_DEFINED__
#define __IMsmMerge_INTERFACE_DEFINED__

EXTERN_C const IID IID_IMsmMerge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82E-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmMerge : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenDatabase( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenModule( 
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseDatabase( 
            /* [in] */ const VARIANT_BOOL Commit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseModule( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenLog( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseLog( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ const BSTR Message) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ const BSTR Feature) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractCAB( 
            /* [in] */ const BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFiles( 
            /* [in] */ const BSTR Path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmMergeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmMerge __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmMerge __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmMerge __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDatabase )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenModule )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDatabase )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const VARIANT_BOOL Commit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseModule )( 
            IMsmMerge __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenLog )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseLog )( 
            IMsmMerge __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Message);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            IMsmMerge __RPC_FAR * This,
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dependencies )( 
            IMsmMerge __RPC_FAR * This,
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Feature);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractCAB )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFiles )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        END_INTERFACE
    } IMsmMergeVtbl;

    interface IMsmMerge
    {
        CONST_VTBL struct IMsmMergeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmMerge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmMerge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmMerge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmMerge_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmMerge_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmMerge_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmMerge_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmMerge_OpenDatabase(This,Path)	\
    (This)->lpVtbl -> OpenDatabase(This,Path)

#define IMsmMerge_OpenModule(This,Path,Language)	\
    (This)->lpVtbl -> OpenModule(This,Path,Language)

#define IMsmMerge_CloseDatabase(This,Commit)	\
    (This)->lpVtbl -> CloseDatabase(This,Commit)

#define IMsmMerge_CloseModule(This)	\
    (This)->lpVtbl -> CloseModule(This)

#define IMsmMerge_OpenLog(This,Path)	\
    (This)->lpVtbl -> OpenLog(This,Path)

#define IMsmMerge_CloseLog(This)	\
    (This)->lpVtbl -> CloseLog(This)

#define IMsmMerge_Log(This,Message)	\
    (This)->lpVtbl -> Log(This,Message)

#define IMsmMerge_get_Errors(This,Errors)	\
    (This)->lpVtbl -> get_Errors(This,Errors)

#define IMsmMerge_get_Dependencies(This,Dependencies)	\
    (This)->lpVtbl -> get_Dependencies(This,Dependencies)

#define IMsmMerge_Merge(This,Feature,RedirectDir)	\
    (This)->lpVtbl -> Merge(This,Feature,RedirectDir)

#define IMsmMerge_Connect(This,Feature)	\
    (This)->lpVtbl -> Connect(This,Feature)

#define IMsmMerge_ExtractCAB(This,FileName)	\
    (This)->lpVtbl -> ExtractCAB(This,FileName)

#define IMsmMerge_ExtractFiles(This,Path)	\
    (This)->lpVtbl -> ExtractFiles(This,Path)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenDatabase_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_OpenDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenModule_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ const short Language);


void __RPC_STUB IMsmMerge_OpenModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseDatabase_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const VARIANT_BOOL Commit);


void __RPC_STUB IMsmMerge_CloseDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseModule_Proxy( 
    IMsmMerge __RPC_FAR * This);


void __RPC_STUB IMsmMerge_CloseModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenLog_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_OpenLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseLog_Proxy( 
    IMsmMerge __RPC_FAR * This);


void __RPC_STUB IMsmMerge_CloseLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Log_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Message);


void __RPC_STUB IMsmMerge_Log_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge_get_Errors_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);


void __RPC_STUB IMsmMerge_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge_get_Dependencies_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);


void __RPC_STUB IMsmMerge_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Merge_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir);


void __RPC_STUB IMsmMerge_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Connect_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Feature);


void __RPC_STUB IMsmMerge_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_ExtractCAB_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR FileName);


void __RPC_STUB IMsmMerge_ExtractCAB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_ExtractFiles_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_ExtractFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmMerge_INTERFACE_DEFINED__ */

// --------------------------------------------------------------------------
// IMsmGetFiles - secondary interface to the MergeMod object, allows
// the client to retrieve the files needed in a particular language of the
// module. Requires certain actions be performed via the IMsmMerge interface
// before some calls on this interface will return valid results.
// --------------------------------------------------------------------------


#ifndef __IMsmGetFiles_INTERFACE_DEFINED__
#define __IMsmGetFiles_INTERFACE_DEFINED__


EXTERN_C const IID IID_IMsmGetFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7041AE26-2D78-11d2-888A-00A0C981B015")
    IMsmGetFiles : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleFiles( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmGetFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmGetFiles __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmGetFiles __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleFiles )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files);
        
        END_INTERFACE
    } IMsmGetFilesVtbl;

    interface IMsmGetFiles
    {
        CONST_VTBL struct IMsmGetFilesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmGetFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmGetFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmGetFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmGetFiles_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmGetFiles_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmGetFiles_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmGetFiles_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmGetFiles_get_ModuleFiles(This,Files)	\
    (This)->lpVtbl -> get_ModuleFiles(This,Files)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmGetFiles_get_ModuleFiles_Proxy( 
    IMsmGetFiles __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files);


void __RPC_STUB IMsmGetFiles_get_ModuleFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmGetFiles_INTERFACE_DEFINED__ */



// The following interface is available only on MergeMod v1.5 and later
#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// IMsmMerge2 - primary interface to the MsmMerge2 object. Allows the client
// to open and close databases, perform merges, retrieve the results
// of a merge, control the creation of a debug-level log, and extract the
// files from a module to disk. Extends the original object by adding
// LFN support and configurable module support.
// --------------------------------------------------------------------------

#ifndef __IMsmMerge2_INTERFACE_DEFINED__
#define __IMsmMerge2_INTERFACE_DEFINED__




EXTERN_C const IID IID_IMsmMerge2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("351A72AB-21CB-47AB-B7AA-C4D7B02EA305")
    IMsmMerge2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenDatabase( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenModule( 
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseDatabase( 
            /* [in] */ const VARIANT_BOOL Commit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseModule( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenLog( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseLog( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ const BSTR Message) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ const BSTR Feature) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractCAB( 
            /* [in] */ const BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFiles( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MergeEx( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir,
            /* [in] */ IMsmConfigureModule __RPC_FAR *pConfiguration) = 0;
        
      
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFilesEx( 
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConfigurableItems( 
            /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *ConfigurableItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSourceImage( 
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleFiles( 
            /* [retval][out] */ IMsmStrings **Files) = 0;        
    };
    
#else 	/* C style interface */

    typedef struct IMsmMerge2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmMerge2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmMerge2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDatabase )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenModule )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDatabase )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const VARIANT_BOOL Commit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseModule )( 
            IMsmMerge2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenLog )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseLog )( 
            IMsmMerge2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Message);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dependencies )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractCAB )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFiles )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MergeEx )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir,
            /* [in] */ IMsmConfigureModule __RPC_FAR *pConfiguration);
   
      /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFilesEx )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConfigurableItems )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *ConfigurableItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSourceImage )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModuleFiles )( 
            IMsmMerge2 * This,
            /* [retval][out] */ IMsmStrings **Files);
        
        END_INTERFACE
    } IMsmMerge2Vtbl;

    interface IMsmMerge2
    {
        CONST_VTBL struct IMsmMerge2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmMerge2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmMerge2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmMerge2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmMerge2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmMerge2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmMerge2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmMerge2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmMerge2_OpenDatabase(This,Path)	\
    (This)->lpVtbl -> OpenDatabase(This,Path)

#define IMsmMerge2_OpenModule(This,Path,Language)	\
    (This)->lpVtbl -> OpenModule(This,Path,Language)

#define IMsmMerge2_CloseDatabase(This,Commit)	\
    (This)->lpVtbl -> CloseDatabase(This,Commit)

#define IMsmMerge2_CloseModule(This)	\
    (This)->lpVtbl -> CloseModule(This)

#define IMsmMerge2_OpenLog(This,Path)	\
    (This)->lpVtbl -> OpenLog(This,Path)

#define IMsmMerge2_CloseLog(This)	\
    (This)->lpVtbl -> CloseLog(This)

#define IMsmMerge2_Log(This,Message)	\
    (This)->lpVtbl -> Log(This,Message)

#define IMsmMerge2_get_Errors(This,Errors)	\
    (This)->lpVtbl -> get_Errors(This,Errors)

#define IMsmMerge2_get_Dependencies(This,Dependencies)	\
    (This)->lpVtbl -> get_Dependencies(This,Dependencies)

#define IMsmMerge2_Merge(This,Feature,RedirectDir)	\
    (This)->lpVtbl -> Merge(This,Feature,RedirectDir)

#define IMsmMerge2_Connect(This,Feature)	\
    (This)->lpVtbl -> Connect(This,Feature)

#define IMsmMerge2_ExtractCAB(This,FileName)	\
    (This)->lpVtbl -> ExtractCAB(This,FileName)

#define IMsmMerge2_ExtractFiles(This,Path)	\
    (This)->lpVtbl -> ExtractFiles(This,Path)

#define IMsmMerge2_MergeEx(This,Feature,RedirectDir,pConfiguration)	\
    (This)->lpVtbl -> MergeEx(This,Feature,RedirectDir,pConfiguration)

#define IMsmMerge2_ExtractFilesEx(This,Path,fLongFileNames,pFilePaths)	\
    (This)->lpVtbl -> ExtractFilesEx(This,Path,fLongFileNames,pFilePaths)

#define IMsmMerge2_get_ConfigurableItems(This,ConfigurableItems)	\
    (This)->lpVtbl -> get_ConfigurableItems(This,ConfigurableItems)

#define IMsmMerge2_CreateSourceImage(This,Path,fLongFileNames,pFilePaths)	\
    (This)->lpVtbl -> CreateSourceImage(This,Path,fLongFileNames,pFilePaths)

#define IMsmMerge2_get_ModuleFiles(This,Files)	\
    (This)->lpVtbl -> get_ModuleFiles(This,Files)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenDatabase_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_OpenDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenModule_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ const short Language);


void __RPC_STUB IMsmMerge2_OpenModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseDatabase_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const VARIANT_BOOL Commit);


void __RPC_STUB IMsmMerge2_CloseDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseModule_Proxy( 
    IMsmMerge2 __RPC_FAR * This);


void __RPC_STUB IMsmMerge2_CloseModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenLog_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_OpenLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseLog_Proxy( 
    IMsmMerge2 __RPC_FAR * This);


void __RPC_STUB IMsmMerge2_CloseLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Log_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Message);


void __RPC_STUB IMsmMerge2_Log_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_Errors_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);


void __RPC_STUB IMsmMerge2_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_Dependencies_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);


void __RPC_STUB IMsmMerge2_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Merge_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir);


void __RPC_STUB IMsmMerge2_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Connect_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature);


void __RPC_STUB IMsmMerge2_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractCAB_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR FileName);


void __RPC_STUB IMsmMerge2_ExtractCAB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractFiles_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_ExtractFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_MergeEx_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir,
    /* [in] */ IMsmConfigureModule __RPC_FAR *pConfiguration);


void __RPC_STUB IMsmMerge2_MergeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractFilesEx_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ VARIANT_BOOL fLongFileNames,
    /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);


void __RPC_STUB IMsmMerge2_ExtractFilesEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_ConfigurableItems_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *
ConfigurableItems);


void __RPC_STUB IMsmMerge2_get_ConfigurableItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE 
IMsmMerge2_CreateSourceImage_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ VARIANT_BOOL fLongFileNames,
    /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);


void __RPC_STUB IMsmMerge2_CreateSourceImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_ModuleFiles_Proxy( 
    IMsmMerge2 * This,
    /* [retval][out] */ IMsmStrings **Files);


void __RPC_STUB IMsmMerge2_get_ModuleFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmMerge2_INTERFACE_DEFINED__ */


#endif // _WIN32_MSM >= 150


// --------------------------------------------------------------------------
// TypeLib definitions
// --------------------------------------------------------------------------

#ifndef __MsmMergeTypeLib_LIBRARY_DEFINED__
#define __MsmMergeTypeLib_LIBRARY_DEFINED__

EXTERN_C const IID LIBID_MsmMergeTypeLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MsmMerge;

class DECLSPEC_UUID("0ADDA830-2C26-11D2-AD65-00A0C9AF11A6")
MsmMerge;
#endif

// the following class is available only on MergeMod v1.5 or later
#if (_WIN32_MSM >= 150)
EXTERN_C const CLSID CLSID_MsmMerge2;

#ifdef __cplusplus

class DECLSPEC_UUID("F94985D5-29F9-4743-9805-99BC3F35B678")
MsmMerge2;
#endif
#endif // _WIN32_MSM >= 150

#endif /* __MsmMergeTypeLib_LIBRARY_DEFINED__ */


// --------------------------------------------------------------------------
// Additional Prototypes for ALL interfaces
// --------------------------------------------------------------------------

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\msmfci.h ===
#include "stdinc.h"

#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>

int get_percentage(unsigned long a, unsigned long b);

/*
    In a merge module, there can only be one CAB file, and its name must be 'MergeModule.CABinet'
    Every call to this function must fail if iCab!=1
*/
#define CABINET_NUMBER      1


/*
 * When a CAB file reaches this size, a new CAB will be created
 * automatically.  This is useful for fitting CAB files onto disks.
 *
 * If you want to create just one huge CAB file with everything in
 * it, change this to a very very large number.
 */
#define MEDIA_SIZE			(LONG_MAX)

/*
 * When a folder has this much compressed data inside it,
 * automatically flush the folder.
 *
 * Flushing the folder hurts compression a little bit, but
 * helps random access significantly.
 */
#define FOLDER_THRESHOLD	(LONG_MAX)


/*
 * Compression type to use
 */

#define COMPRESSION_TYPE    tcompTYPE_MSZIP


/*
 * Our internal state
 *
 * The FCI APIs allow us to pass back a state pointer of our own
 */
typedef struct
{
    ULONG    total_compressed_size;      /* total compressed size so far */
	ULONG	total_uncompressed_size;	/* total uncompressed size so far */
} client_state;


//
// helper functions for FCI
//

/*
 * Memory allocation function
 */
FNFCIALLOC(fci_mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFCIFREE(fci_mem_free)
{
	free(memory);
}


/*
 * File i/o functions
 */
FNFCIOPEN(fci_open)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIREAD(fci_read)
{
    unsigned int result;

    result = (unsigned int)_read((int)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCIWRITE(fci_write)
{
    unsigned int result;

    result = (unsigned int) _write((int)hf, memory, (INT)cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCICLOSE(fci_close)
{
    int result;

    result = _close((int)hf);

    if (result != 0)
        *err = errno;

    return result;
}

FNFCISEEK(fci_seek)
{
    long result;

    result = _lseek((int)hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIDELETE(fci_delete)
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
FNFCIFILEPLACED(file_placed)
{
	return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
FNFCISTATUS(progress)
{
	client_state	*cs;

	cs = (client_state *) pv;

	if (typeStatus == statusFile)
	{
        /*
        cs->total_compressed_size += cb1;
		cs->total_uncompressed_size += cb2;
        */
		/*
		 * Compressing a block into a folder
		 *
		 * cb2 = uncompressed size of block
		 */       
	}
	else if (typeStatus == statusFolder)
	{
		int	percentage;

		/*
		 * Adding a folder to a cabinet
		 *
		 * cb1 = amount of folder copied to cabinet so far
		 * cb2 = total size of folder
		 */
		percentage = get_percentage(cb1, cb2);

	}

	return 0;
}


FNFCIGETNEXTCABINET(get_next_cabinet)
{
    if (pccab->iCab != CABINET_NUMBER)
    {
        return -1;
    }

	/*
	 * Cabinet counter has been incremented already by FCI
	 */

	/*
	 * Store next cabinet name
	 */
    WideCharToMultiByte(
        CP_ACP, 0, MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1 ,         
        pccab->szCab, sizeof(pccab->szCab), NULL, NULL);
	
	/*
	 * You could change the disk name here too, if you wanted
	 */

	return TRUE;
}


FNFCIGETOPENINFO(get_open_info)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle = INVALID_HANDLE_VALUE;
    DWORD                       attrs;
    INT_PTR                     hf;

    /*
     * Need a Win32 type handle to get file date/time
     * using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with
     * _open
     */
	handle = CreateFileA(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);
   
	if (handle == INVALID_HANDLE_VALUE)
	{
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
		CloseHandle(handle);
		return -1;
	}
   
	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime, 
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

    attrs = GetFileAttributesA(pszName);

    if (attrs == 0xFFFFFFFF)
    {
        /* failure */
        *pattribs = 0;
    }
    else
    {
        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *pattribs = (USHORT) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }

    CloseHandle(handle);


    /*
     * Return handle using _open
     */
	hf = _open( pszName, _O_RDONLY | _O_BINARY );

	if (hf == -1)
		return -1; // abort on error
   
	return hf;
}


void set_cab_parameters(PCCAB cab_parms)
{
	memset(cab_parms, 0, sizeof(CCAB));

	cab_parms->cb = MEDIA_SIZE;
	cab_parms->cbFolderThresh = FOLDER_THRESHOLD;

	/*
	 * Don't reserve space for any extensions
	 */
	cab_parms->cbReserveCFHeader = 0;
	cab_parms->cbReserveCFFolder = 0;
	cab_parms->cbReserveCFData   = 0;

	/*
	 * We use this to create the cabinet name
	 */
	cab_parms->iCab = CABINET_NUMBER;

	/*
	 * If you want to use disk names, use this to
	 * count disks
	 */
	cab_parms->iDisk = 0;

	/*
	 * Choose your own number
	 */
	cab_parms->setID = 1965;

	/*
	 * Only important if CABs are spanning multiple
	 * disks, in which case you will want to use a
	 * real disk name.
	 *
	 * Can be left as an empty string.
	 */
	strcpy(cab_parms->szDisk, "win32.fusion.tools");

	/* where to store the created CAB files */
    CSmallStringBuffer buf; 

    if (! buf.Win32Assign(g_MsmInfo.m_sbCabinet))
    {
        fprintf(stderr, "error happened in set_cab_parameters");
        goto Exit;
    }

    if (!buf.Win32RemoveLastPathElement())
    {
        goto Exit;
    }
    
    if ( ! buf.Win32EnsureTrailingPathSeparator())
    {
        fprintf(stderr, "error happened in set_cab_parameters");
        goto Exit;
    }


    WideCharToMultiByte(
        CP_ACP, 0, buf, buf.GetCchAsDWORD(), 
        cab_parms->szCabPath, sizeof(cab_parms->szCabPath), NULL, NULL);

	/* store name of first CAB file */	
    WideCharToMultiByte(
        CP_ACP, 0, MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1 ,         
        cab_parms->szCab, sizeof(cab_parms->szCab), NULL, NULL);
Exit:
    return;
}

int get_percentage(unsigned long a, unsigned long b)
{
	while (a > 10000000)
	{
		a >>= 3;
		b >>= 3;
	}

	if (b == 0)
		return 0;

	return ((a*100)/b);
}


char *return_fci_error_string(int err)
{
	switch (err)
	{
		case FCIERR_NONE:
			return "No error";

		case FCIERR_OPEN_SRC:
			return "Failure opening file to be stored in cabinet";
		
		case FCIERR_READ_SRC:
			return "Failure reading file to be stored in cabinet";
		
		case FCIERR_ALLOC_FAIL:
			return "Insufficient memory in FCI";

		case FCIERR_TEMP_FILE:
			return "Could not create a temporary file";

		case FCIERR_BAD_COMPR_TYPE:
			return "Unknown compression type";

		case FCIERR_CAB_FILE:
			return "Could not create cabinet file";

		case FCIERR_USER_ABORT:
			return "Client requested abort";

		case FCIERR_MCI_FAIL:
			return "Failure compressing data";

		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\msmfdi.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>

#include <fdi.h>

char dest_dir[MAX_PATH];

/*
 * Memory allocation function
 */
FNALLOC(fdi_mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(fdi_mem_free)
{
	free(pv);
}


FNOPEN(fdi_file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(fdi_file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(fdi_file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(fdi_file_close)
{
	return _close((int)hf);
}


FNSEEK(fdi_file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(fdi_notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
#ifdef MSMGEN_TEST
			printf(
				"fdintCABINET_INFO\n"
				"  next cabinet     = %s\n"
				"  next disk        = %s\n"
				"  cabinet path     = %s\n"
				"  cabinet set ID   = %d\n"
				"  cabinet # in set = %d (zero based)\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet
			);
#endif
			return 0;
		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			printf(
				"fdintPARTIAL_FILE\n"
				"   name of continued file            = %s\n"
				"   name of cabinet where file starts = %s\n"
				"   name of disk where file starts    = %s\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			INT_PTR handle;
			char	destination[MAX_PATH];

#ifdef MSMGEN_TEST
            printf(
				"fdintCOPY_FILE\n"
				"  file name in cabinet = %s\n"
				"  uncompressed file size = %d\n",
				pfdin->psz1,
				pfdin->cb
			);
#endif
			
			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1
			);

			handle = fdi_file_open(
				destination,
				_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
				_S_IREAD | _S_IWRITE 
			);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;            
            char    destination[256];

 			printf(
				"fdintCLOSE_FILE_INFO\n"
				"   file name in cabinet = %s\n"
				"\n",
				pfdin->psz1
			);

            sprintf(
                destination, 
                "%s%s",
                dest_dir,
                pfdin->psz1
            );

			fdi_file_close(pfdin->hf);


            /*
             * Set date/time
             *
             * Need Win32 type handle for to set date/time
             */
            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            /*
             * Mask out attribute bits other than readonly,
             * hidden, system, and archive, since the other
             * attribute bits are reserved for use by
             * the cabinet format.
             */         
            (void) SetFileAttributes(
                destination,
                pfdin->attribs
            );

            if (!SUCCEEDED(AddFileToCabinetA(destination, strlen(destination), //"%Temp%\\msm_temp_cabinet_dir\\a.manifest.12213232312312312
                pfdin->psz1, strlen(pfdin->psz1))))                           // a.manifest.12213232312312312
            {
                return -1; // abort
            }

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
			printf(
				"fdintNEXT_CABINET\n"
				"   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
				"   cabinet path name                         = %s\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
			return 0;
	}

	return 0;
}



char *return_fdi_error_string(INT  err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\msmgen.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    msmgen.cpp

Abstract:

    Main Function calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

// NTRAID#NTBUG9 - 589817 - 2002/03/26 - xiaoyuw:
// (1) the operation option, "mangroup" should get rid of the limitation about one manifest one msm, 
// (2) the implementation of "manlist", adding more than one assembly into one msm, should be in the pattern like
//      a. CreateMsmFromManifest(FirstManifestFileName);
//      b. for (i =1; i < n; i++)
//	          AddingManifestIntoExistingMsm(ithManifestFileName);
// (3) adding tracing info:
//      - to make msmgen.exe to be a better tool, TRACE_INFO should be added in a couple of places. using default logfile to record tracing info.
//      - adding tracing calls into macros such as IFFAILED_EXIT 
// (4) there is no parameter-checking in function definition.
// (5) rename variable to make more sense:
//      for example:
//          m_sbManifestFileName ==>  m_sbManifestFileNameNoPath
//          m_sbCatalogFileName ==> m_sbCatalogFileNameNoPath
// (6)get rid of IFFALSE__MARKERROR_EXIT, which is not used, and not a good-defined macros.
//      <#define IFFALSE__MARKERROR_EXIT(x) if (!(x)) { hr = E_FAIL; goto Exit; }
//      >#define IFFALSE__MARKERROR_EXIT(x) if (!(x)) { hr = HRESULT_FROM_WIN32(::GetLastError()); goto Exit; }

#include "msmgen.h"
#include "util.h"
#include "objbase.h"
#include "initguid.h"
#include "coguid.h"
#include <string.h>

#ifdef MSMGEN_TEST
#define _WIN32_MSM 150
#include "mergemod.h"
#endif

extern "C" { void (__cdecl * _aexit_rtn)(int); }

#define DEFAULT_MODULE_IDENTIFIER_PREFIX                            L"Module0"

#define MSMGEN_FROM_SINGLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE          0
#define MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE        1
#define MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE      2

#define MANLIST_COLUMN_DEFAULT_VALUE_ASSEMBLY_COMPONENT_ID          0
#define MANLIST_COLUMN_DEFAULT_VALUE_MODULE_ID                      1
#define MANLIST_COLUMN_DEFAULT_VALUE_MSM_TEMPLATE_FILE              2
#define MANLIST_COLUMN_DEFAULT_VALUE_MSM_OUTPUT_FILE                3

static const PCWSTR ManListColumnDefaultValueInManifestList[] = {
    L"new",
    L"new",
    L"default",
    L"default"
};

ASSEMBLY_INFO   curAsmInfo;
MSM_INFO        g_MsmInfo;
//
// function declaration
//
DECLARE_FUNCTION(_file);
DECLARE_FUNCTION(_assemblyIdentity);
DECLARE_FUNCTION(_comClass);
DECLARE_FUNCTION(_typelib);
//DECLARE_FUNCTION(_interface);
//DECLARE_FUNCTION(_windowClass);

static MSM_DOMNODE_WORKER s_msm_worker[]={
    DEFINE_ATTRIBUTE_MSM_INTERESTED(file),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(assemblyIdentity),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(comClass),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(typelib)
    //DEFINE_ATTRIBUTE_MSM_INTERESTED(interface);
    //DEFINE_ATTRIBUTE_MSM_INTERESTED(windowClass);
};

//
// Function:
//      -op : must has one of three ops:
//          -op new : CREATE_ALWAYS
//              generate a new msm based on a manifest
//          -op add : CREATE_OPEN_EXIST
//              (1) make more than one assembly in one msm, sharing the same moduleID
//              (2) when insert into some table, for example, Directory Table, no dup entries in the table before
//              (3) for some table, if the value of TableIdentifier has existed, it is an ERROR
//              (4) for add, if there is a cabinet in the msm already, we have to extract files from it and regenerate a 
//                  cabinet with the files of the added assembly. There are two ways to do this:
//                  i. extract files from old cabinet before generate the new msm, that is, in PrepareMsmgeneration
//                  ii. delay it until the new cabinet is tried to insert into _Stream table, that is, at the end of
//                      msmgen.
//                  the code would use (1) because if there is a MergeModule.cab in _Stream table, the work have to be done
//                  anyway. And (1) would save the work to merge the cabinet. The files would be extracted into a temporary 
//                  directory and be deleted after be added to the new cabinet;              
//
//          -op regen : CREATE_OPEN_EXIST
//              (1)generate msm for an assembly using the existing msm file
//              (2) the only thing reusable are moduleID and ComponentID. If they are not specified on the command line, 
//                  they would be fetched from the msm file.
//              (3) we do not want to reuse any tables because almost all tables except Directory Table are generated 
//                  based on manifest. If reuse them, it loose the meaning of "regeneration"
//              (4) so what we do is to fetch componentID and moduleID if not present on the command line and then replace
//                  the msm file with our msmgen template file
//
//      -compid: {ComponentGUID}, for -op new, -op add, if it is not present, generate a new one
//                             for -op regen, if it present, change the value in the component table, otherwise, keep the old one
//
//      -msm msmfilename:
//          if this option is not present, use manifestFileName.msm and store in the same directory
//          else if the msmfilename is a fully pathname, use it
//          else if the msmfilename is a relative pathname, reolve it and get a fully pathname

//      -msmid MergeModuleGuid:
//          for -add and -regen, it is ignored if present,
//          for -new, if this is not present, call CoCreateGuid to generate a new one
//
//      -manlist file.txt
//          a file with multiple manifest filename line by line          
//
//      -manfile fully-qaulified manifest filename: REQUIRED
//          fully qualified pathname of a manifest filename which msm is generated from
//      
void PrintUsage(WCHAR * exe)
{
    fprintf(stderr, "Usage: %S <options> full-pathname-of-manifest\n",exe);
    fprintf(stderr, "Generate .msm for an assembly\n");
    fprintf(stderr, "Options :\n");
    fprintf(stderr, "[-op (new|regen|add)]\n");
    fprintf(stderr, "\t\t:: new     generate a new msm from a assembly\n");
    fprintf(stderr, "\t\t:: regen   generate a msm from a assembly based on an old msm generated for this assembly\n");
    fprintf(stderr, "\t\t:: add     use the old msm for the content of the assembly\n");
    fprintf(stderr, "\t\t:: DefaultValue : new\n\n");
    fprintf(stderr, "[-msm msmFileName]\n");
    fprintf(stderr, "\t\t:: output msm filename\n");
    fprintf(stderr, "\t\t:: DefaultValue : use the basename of manifest file with .msm as the ext\n\n");
    fprintf(stderr, "[-compid               ComponentGuid]\n"); 
    fprintf(stderr, "\t\t:: Component ID for this Assembly\n"); 
    fprintf(stderr, "\t\t:: DefaultValue : call GUIDGen to get a new GUID\n\n");
    fprintf(stderr, "[-msmid                MergeModuleGuid]\n"); 
    fprintf(stderr, "\t\t:: module ID for this msm \n"); 
    fprintf(stderr, "\t\t:: DefaultValue : call GUIDGen to get a new GUID\n\n");
    fprintf(stderr, "(-manfile | -manlist | -mangroup)  filename\n");
    fprintf(stderr, "\t\t a manifest filename or a text file which contains manifest-filename line by line\n");
    fprintf(stderr, "\t\t About -manList:\n");
    fprintf(stderr, "\t\t (1)the format of manlist file would be:\n");
    fprintf(stderr, "\t\t\t Columns: ManifestFileName | ComponentID |\n");
    fprintf(stderr, "\t\t\t | ManifestFileName | ComponentID \n");   
    fprintf(stderr, "\t\t (2)if you want to reuse the ModuleID or ComponentID, you have to copy the ID from msm into this text file,");
    fprintf(stderr, "\t\t\t otherwise, put \"DefaultValue\" to the column and the program would generate new GUID would be generated if you want to reuse the ModuleID or ComponentID, you have to copy the ID from msm into this text file,");
    fprintf(stderr, "\t\t (3)the list in the manifest listfile must be unique!!!");
    fprintf(stderr, "\t\t About -mangroup:\n");
    fprintf(stderr, "\t\t (1)the format of manGroup file would be:\n");
    fprintf(stderr, "\t\t\t Columns: ManifestFileName | ComponentID | MergeModuleID |OutputMsmFileName| TemplateFileName |\n");
    fprintf(stderr, "\t\t\t | ManifestFileName | ComponentID \n");   
    fprintf(stderr, "\t\t (2)if you want to reuse the ModuleID or ComponentID, you have to copy the ID from msm into this text file,");
    fprintf(stderr, "\t\t\t otherwise, put \"DefaultValue\" to the column and the program would generate new GUID would be generated if you want to reuse the ModuleID or ComponentID, you have to copy the ID from msm into this text file,");
    fprintf(stderr, "\t\t (3)the list in the manifest listfile must be unique!!!");
    
    return; 
}

VOID InitCurrentAssemblyInfo()
{
    curAsmInfo.m_sbAssemblyPath.Left(0);
    curAsmInfo.m_sbManifestFileName.Left(0);
    curAsmInfo.m_sbCatalogFileName.Left(0);
    curAsmInfo.m_sbLangID.Left(0);
    curAsmInfo.m_sbComponentID.Left(0);
    curAsmInfo.m_sbComponentIdentifier.Left(0);    
    curAsmInfo.m_fComponentTableSet = FALSE;
    curAsmInfo.m_CchAssemblyPath = 0; 
    curAsmInfo.m_CchManifestFileName = 0;
    curAsmInfo.m_CchCatalogFileName = 0; 
}

VOID InitializeMsmInfo()
{
    g_MsmInfo.m_guidModuleID = GUID_NULL;
    g_MsmInfo.m_sbModuleGuidStr.Left(0);
    g_MsmInfo.m_hfci = NULL;
    g_MsmInfo.m_sbMsmFileName.Left(0);
    g_MsmInfo.m_hdb = NULL;
    g_MsmInfo.m_sbModuleIdentifier.Left(0);
    g_MsmInfo.m_sLanguageID = 0;
    g_MsmInfo.m_enumGenMode = MSMGEN_OPR_NEW;
    g_MsmInfo.m_sbCabinet.Left(0);

    //g_MsmInfo.m_sbMsmTemplateFile.Left(0);
}
//
// parse the command option
//
HRESULT ValidateMsmgenParameters(wchar_t * exe, wchar_t ** Options, SIZE_T CchOptions, 
        PWSTR * ppszManifestFileName, PWSTR * ppszManifestListFile,
        DWORD & dwManFlag)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    PWSTR pszMsmFileName = NULL;
    PWSTR pszManifestFileName = NULL;
    PWSTR pszManifestListFile = NULL;    

    ASSERT_NTC(ppszManifestFileName != NULL);
    ASSERT_NTC(ppszManifestListFile != NULL);

    *ppszManifestFileName = NULL;
    *ppszManifestListFile = NULL;
    dwManFlag = MSMGEN_FROM_SINGLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE;

    while ( i < CchOptions)
    {
        if (Options[i][0] != L'-') // must begin with "-"
            goto invalid_param;

        if (_wcsicmp(Options[i], L"-op") == 0 )
        {
            if (_wcsicmp(Options[i+1], L"new") == 0 )
            {
                g_MsmInfo.m_enumGenMode = MSMGEN_OPR_NEW;
            }
            else if (_wcsicmp(Options[i+1], L"add") == 0 )            
            {
                g_MsmInfo.m_enumGenMode = MSMGEN_OPR_ADD;
            }
            else if (_wcsicmp(Options[i+1], L"regen") == 0 )            
            {
                g_MsmInfo.m_enumGenMode = MSMGEN_OPR_REGEN;
            }
            else
                goto invalid_param;
        }
        else if (_wcsicmp(Options[i], L"-msm") == 0 )
        {            
            if (g_MsmInfo.m_sbMsmFileName.IsEmpty())
            {
                IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(Options[i+1], wcslen(Options[i+1])));
            }
            else
                goto invalid_param;
        }
        else if (_wcsicmp(Options[i], L"-template") == 0 )
        {            
            if (g_MsmInfo.m_sbMsmTemplateFile.IsEmpty())
            {
                IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(Options[i+1], wcslen(Options[i+1])));
            }
            else
                goto invalid_param;
        }
        else if (_wcsicmp(Options[i], L"-compid") == 0 )
        {
            // just want to reuse this buffer, bad design
            //
            // and HRESULT PrepareDatabase() depends on it too
            IFFALSE_EXIT(curAsmInfo.m_sbComponentID.Win32Assign(Options[i+1], wcslen(Options[i+1]))); 
        }
        else if (_wcsicmp(Options[i], L"-msmid") == 0 )
        {
            IFFAILED_EXIT(CLSIDFromString((LPOLESTR)(Options[i+1]), &g_MsmInfo.m_guidModuleID));            
        }
        else if (_wcsicmp(Options[i], L"-manlist") == 0 )
        {
            if (pszManifestListFile == NULL)
            {
                pszManifestListFile = Options[i+1];
                dwManFlag = MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE;
            }
            else
                goto invalid_param;
        }
        else if (_wcsicmp(Options[i], L"-mangroup") == 0 )
        {
            if (pszManifestListFile == NULL)
            {
                pszManifestListFile = Options[i+1];
                dwManFlag = MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE;
            }
            else
                goto invalid_param;
        }

        else if (_wcsicmp(Options[i], L"-manfile") == 0 )
        {
            if (pszManifestFileName == NULL)
            {
                pszManifestFileName = Options[i+1];                
            }
            else
                goto invalid_param;
        }
        else
            goto invalid_param;

        i++;    // skip the option
        i++;    // skip the value of the option
    }

    //
    // validate two-mode source manifest-files
    //
    if (((pszManifestFileName == NULL) && (pszManifestListFile == NULL)) || (pszManifestFileName && pszManifestListFile))
    {
        fprintf(stderr, "user has to provide a manifest filename or a text file with a list of manifest!\n\n");
        goto invalid_param;
    }

    if (pszManifestListFile != NULL)       
    {
        if ( curAsmInfo.m_sbComponentID.GetCchAsDWORD() != 0)
        {
            fprintf(stderr, "the listfile may has more than one manifest, ComponentID can not be specified in this case!\n\n");
            goto invalid_param;
        }
        
    }

    goto Exit;

invalid_param:        
    PrintUsage(exe);
    hr = E_INVALIDARG;

Exit:
    *ppszManifestFileName = pszManifestFileName;
    *ppszManifestListFile = pszManifestListFile;
    return hr;
}

HRESULT LoadManifestToDOMDocument(IXMLDOMDocument  *pDoc)
{
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr = S_OK;
    BSTR            bstr = NULL;

    CurrentAssemblyReset;

    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(curAsmInfo.m_sbManifestFileName));
    bstr = ::SysAllocString(curAsmInfo.m_sbAssemblyPath);

    IFFAILED_EXIT(pDoc->put_async(VARIANT_FALSE));

    // Load xml document from the given URL or file path
    VariantInit(&vURL);
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = bstr;
    IFFAILED_EXIT(pDoc->load(vURL, &vb));
Exit:
    ::SysFreeString(bstr);    
    return hr;

}
HRESULT PopulateDOMNodeForMsm(IXMLDOMNode * node)
{
    HRESULT hr = S_OK;
    BSTR nodeName = NULL;
    DOMNodeType nodetype;

    IFFAILED_EXIT(node->get_nodeType(&nodetype));
    if(nodetype == NODE_ELEMENT)
    {
        IFFAILED_EXIT(node->get_nodeName(&nodeName));
    
        for ( DWORD i = 0 ; i < NUMBER_OF(s_msm_worker); i++)
        {
            if (wcscmp(s_msm_worker[i].pwszNodeName, nodeName) == 0)
            {
                IFFAILED_EXIT(s_msm_worker[i].pfn(node));
                break;
            }
        }
    }

Exit:
    ::SysFreeString(nodeName);
    return hr;
}

HRESULT WalkDomTree(IXMLDOMNode * node)
{
    HRESULT hr = S_OK;
    IXMLDOMNode* pChild = NULL, *pNext = NULL;    

    IFFAILED_EXIT(PopulateDOMNodeForMsm(node));

    node->get_firstChild(&pChild);
    while (pChild)
    {
        IFFAILED_EXIT(WalkDomTree(pChild));
        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = NULL;
        pChild = pNext;
        pNext = NULL;
    }
Exit:
    if (pChild) 
        pChild->Release();

    if(pNext)
        pNext->Release();

    return hr;
}

void CleanupMsm()
{
    if ( g_MsmInfo.m_hfci != NULL)
    {
        FCIDestroy(g_MsmInfo.m_hfci);
        g_MsmInfo.m_hfci = NULL;
    }
    
    if ( g_MsmInfo.m_hdb!= NULL){
        MsiDatabaseCommit(g_MsmInfo.m_hdb);
        MsiCloseHandle(g_MsmInfo.m_hdb);
        g_MsmInfo.m_hdb = NULL;
    }
    return;
}

HRESULT EndMsmGeneration()
{
    HRESULT hr = S_OK; 

    IFFAILED_EXIT(CloseCabinet());   

    IFFAILED_EXIT(InsertCabinetIntoMsm());

    CleanupMsm();

Exit:
    return hr;
}

HRESULT SetCurrentAssemblyInfo(DWORD dwFlags, PCWSTR pszManifestFileName)
{
    WCHAR tmp[MAX_PATH];
    UINT iRet;    
    PWSTR p = NULL;
    HRESULT hr = S_OK;

    if (dwFlags == MSMGEN_FROM_SINGLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE)
    {
        //
        // componentID is provided from command options
        //

    }else 
    {
        //
        // component ID from a txt file
        //
        InitCurrentAssemblyInfo();
    }

    iRet = GetFullPathNameW(pszManifestFileName, NUMBER_OF(tmp), tmp, NULL);
    if ((iRet == 0 ) || (iRet > NUMBER_OF(tmp)))
    {
        SET_HRERR_AND_EXIT(::GetLastError());
    }
    if (::GetFileAttributesW(tmp) == DWORD (-1))
        SETFAIL_AND_EXIT;

    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Assign(tmp, wcslen(tmp)));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32GetLastPathElement(curAsmInfo.m_sbManifestFileName));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32RemoveLastPathElement());
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32EnsureTrailingPathSeparator()); // Path with a trailing slash is always ready to use

    curAsmInfo.m_CchAssemblyPath = curAsmInfo.m_sbAssemblyPath.GetCchAsDWORD(); 
    curAsmInfo.m_CchManifestFileName = curAsmInfo.m_sbManifestFileName.GetCchAsDWORD();

    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32Assign(curAsmInfo.m_sbManifestFileName));
    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32ChangePathExtension(CATALOG_FILE_EXT, NUMBER_OF(CATALOG_FILE_EXT) -1, eAddIfNoExtension));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(curAsmInfo.m_sbCatalogFileName));

    if (::GetFileAttributesW(curAsmInfo.m_sbAssemblyPath) == DWORD (-1))
        SETFAIL_AND_EXIT;


    curAsmInfo.m_CchCatalogFileName = curAsmInfo.m_sbCatalogFileName.GetCchAsDWORD();

    //
    // reset
    //
    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName);

Exit:
    return hr;
}

HRESULT Msmgen_SingleAssemblyToMsm(DWORD dwFlags, PCWSTR pszManifestFileName)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pDoc = NULL;
    IXMLDOMNode     *pNode = NULL;

    IFFAILED_EXIT(SetCurrentAssemblyInfo(dwFlags, pszManifestFileName));

    IFFAILED_EXIT(CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pDoc));   
    IFFAILED_EXIT(LoadManifestToDOMDocument(pDoc));  
    IFFAILED_EXIT(pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode));    
    IFFAILED_EXIT(WalkDomTree(pNode));

    IFFAILED_EXIT(CheckComponentTable());

Exit:
    SAFE_RELEASE_COMPOINTER(pDoc);
    SAFE_RELEASE_COMPOINTER(pNode);
    return hr;
}

const static WCHAR wchLineDividers[] = { L'\r', L'\n', 0xFEFF, 0 };
const static CHAR chLineDividers[] = { '\r', '\n', 0 };   

const static WCHAR wchLineItemDividers[] = {L' ', L','};
const static CHAR chLineItemDividers[] = {' ', ','};   

#define MSM_ITEM_IN_LINE 1
#define MSM_LINE_IN_FILE 2

static inline bool IsCharacterNulOrInSet(DWORD dwFlags, BOOL fUnicodeFile, PVOID pCursor, ULONGLONG ullCursorPos)
{
    ASSERT_NTC((dwFlags == MSM_ITEM_IN_LINE) || (dwFlags == MSM_LINE_IN_FILE));

    bool fRet = FALSE;
    if ( dwFlags ==  MSM_ITEM_IN_LINE) {
        if (fUnicodeFile)
        {
            WCHAR ch = (reinterpret_cast<PWSTR>(pCursor))[ullCursorPos];
            fRet =  (ch == 0 || wcschr(wchLineItemDividers, ch) != NULL);
        }
        else
        {
            CHAR ch = (reinterpret_cast<PSTR>(pCursor))[ullCursorPos];
            fRet = (ch == 0 || strchr(chLineItemDividers, ch) != NULL);
        }
    }
    else if (dwFlags ==  MSM_LINE_IN_FILE)
    {
        if (fUnicodeFile)
        {
            WCHAR ch = (reinterpret_cast<PWSTR>(pCursor))[ullCursorPos];
            fRet = (ch == 0 || wcschr(wchLineDividers, ch) != NULL);
        }
        else
        {
            CHAR ch = (reinterpret_cast<PSTR>(pCursor))[ullCursorPos];
            fRet = (ch == 0 || strchr(chLineDividers, ch) != NULL);
        }
    }

    return fRet;
}

#define SKIP_BREAKERS(_pStart, _Size, _curPos, _flags) do {while ((_curPos < _Size) && IsCharacterNulOrInSet(_flags, fUnicodeFile, _pStart, _curPos)) _curPos++ ; } while(0)
#define SKIP_LINE_BREAKERS(_pStart, _Size, _curPos) SKIP_BREAKERS(_pStart, _Size, _curPos, MSM_LINE_IN_FILE)
#define SKIP_ITEM_BREAKERS(_pStart, _Size, _curPos) SKIP_BREAKERS(_pStart, _Size, _curPos, MSM_ITEM_IN_LINE) 

#define FIND_NEXT_BREAKER(_pStart, _Size, _curPos, _flags) do { while ((_curPos < _Size) && !IsCharacterNulOrInSet(_flags, fUnicodeFile, _pStart, _curPos)) _curPos++; } while(0)
#define FIND_NEXT_LINE_BREAKERS(_pStart, _Size, _curPos) FIND_NEXT_BREAKER(_pStart, _Size, _curPos, MSM_LINE_IN_FILE) 
#define FIND_NEXT_ITEM_BREAKERS(_pStart, _Size, _curPos) FIND_NEXT_BREAKER(_pStart, _Size, _curPos, MSM_ITEM_IN_LINE) 

#define ENSURE_NOT_END(_curPos, _totalSize) do {if (_curPos > _totalSize) { SET_HRERR_AND_EXIT(ERROR_BAD_FORMAT); goto Exit;} } while(0)

#define SetPointerToCurrentPostion(_pStart, _curPos, _x) do { if (fUnicodeFile) { _x = (PWSTR)_pStart + _curPos;} else { _x = (PSTR)_pStart + _curPos;} } while(0)


HRESULT ParseManifestInfo(BOOL fUnicodeFile, PVOID pszLineStart, DWORD dwLineSize, DWORD dwFlags, CStringBuffer & manifestfile)
{

#define GetLineItemBorder(_pItemStart, _pItemEnd) do { \
        SKIP_ITEM_BREAKERS(pszLineStart, dwLineSize, dwCurPos); \
        ENSURE_NOT_END(dwCurPos, dwLineSize); \
        \
        SetPointerToCurrentPostion(pszLineStart, dwCurPos, _pItemStart); \
        \
        FIND_NEXT_ITEM_BREAKERS(pszLineStart, dwLineSize, dwCurPos);\
        ENSURE_NOT_END(dwCurPos, dwLineSize);\
        \
        SetPointerToCurrentPostion(pszLineStart ,dwCurPos - 1, _pItemEnd); \
    } while(0)

#define GetUnicodeString(__pStart, __pEnd, __buf)  \
    do { \
        if (fUnicodeFile) { \
            IFFALSE_EXIT(buf.Win32Assign((PWSTR)__pStart, (PWSTR)__pEnd - (PWSTR)__pStart + 1)); \
        } \
        else { \
            WCHAR tmp[MAX_PATH]; \
            if (MultiByteToWideChar(CP_ACP, 0, (PSTR)__pStart, (int)((PSTR)__pEnd - (PSTR)__pStart) + 1, tmp, NUMBER_OF(tmp)) == 0) { \
                SET_HRERR_AND_EXIT(::GetLastError()); \
            } \
            tmp[(PSTR)__pEnd - (PSTR)__pStart + 1] = L'\0'; \
            IFFALSE_EXIT(__buf.Win32Assign(tmp, wcslen(tmp))); \
        } \
    }while(0)

    HRESULT hr = S_OK;
    DWORD dwCurPos = 0;
    PVOID pszManifestNameStart, pszManifestNameEnd;
    PVOID pszAssemblyComponentIDStart, pszAssemblyComponentIDEnd;
    CStringBuffer buf;
    

    //
    // fetch Assembly manifest-filename and componentID
    //
    GetLineItemBorder(pszManifestNameStart, pszManifestNameEnd);
    GetLineItemBorder(pszAssemblyComponentIDStart, pszAssemblyComponentIDEnd);


    if (dwFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE)
    {
        //
        // the format must be 
        //  ManifestFileName | ComponentID | MergeModuleID | OutputMsmFile | MsmTemplateFile 
        // so, we need fetch MergeModuleID, MsmTemplateFile, and OutputMsmFile from the manList file

        //
        // initialize the msmInfo for current generation
        //
        InitializeMsmInfo();

        //
        // fetch MoudleID, templateFilename and output filename
        //
        PVOID pcwszModuleIDStart, pcwszModuleIDEnd;
        PVOID pcwszMsmOutputFilenameStart, pcwszMsmOutputFilenameEnd;                   

        GetLineItemBorder(pcwszModuleIDStart, pcwszModuleIDEnd);
        GetLineItemBorder(pcwszMsmOutputFilenameStart, pcwszMsmOutputFilenameEnd);        

        GetUnicodeString(pcwszModuleIDStart, pcwszModuleIDEnd, buf);
        if (_wcsicmp(buf, ManListColumnDefaultValueInManifestList[MANLIST_COLUMN_DEFAULT_VALUE_MODULE_ID]) != 0)
        {                
            IFFAILED_EXIT(CLSIDFromString((LPOLESTR)(PCWSTR)buf, &g_MsmInfo.m_guidModuleID));
        }
        
        GetUnicodeString(pcwszMsmOutputFilenameStart, pcwszMsmOutputFilenameEnd, buf);
        if (_wcsicmp(buf, ManListColumnDefaultValueInManifestList[MANLIST_COLUMN_DEFAULT_VALUE_MSM_OUTPUT_FILE]) != 0)
        {
            IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(buf));
        }
        
    }

    //
    // get ComponentID and manifest filename
    //        
    GetUnicodeString(pszAssemblyComponentIDStart, pszAssemblyComponentIDEnd, buf);
    if (_wcsicmp(buf, ManListColumnDefaultValueInManifestList[MANLIST_COLUMN_DEFAULT_VALUE_ASSEMBLY_COMPONENT_ID]) != 0)
    {
        IFFALSE_EXIT(curAsmInfo.m_sbComponentID.Win32Assign(buf));
    }

    GetUnicodeString(pszManifestNameStart, pszManifestNameEnd, manifestfile);

    // if the output msm file is more than one, we need do preparation work everytime before msm generation
    // prepare for current msm generation
    //
    if (dwFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE)
    {
        // set all variables ready        
        IFFAILED_EXIT(PrepareMsmOutputFiles(manifestfile));
    }

Exit:
    return hr;
}

HRESULT Msmgen_MultipleAssemblySources(DWORD dwFlags, PCWSTR pszManifestListFile)
{
    HRESULT             hr = S_OK;    
    CStringBuffer       buf;
    CFusionFile         File;
    CFileMapping        FileMapping;
    CMappedViewOfFile   MappedViewOfFile;
    PVOID               pCursor = NULL;
    BOOL                fUnicodeFile = FALSE;
    ULONGLONG           ullFileCharacters = 0, ullCursorPos = 0;

    PVOID               pszLineStart, pszLineEnd;
    DWORD               dwLineSize;


    if (!((dwFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE) || (dwFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE)))
    {
        SET_HRERR_AND_EXIT(ERROR_INVALID_PARAMETER);
    }

    IFFALSE_EXIT(File.Win32CreateFile(pszManifestListFile, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));
    IFFALSE_EXIT(File.Win32GetSize(ullFileCharacters));    
    IFFALSE_EXIT(FileMapping.Win32CreateFileMapping(File, PAGE_READONLY));
    IFFALSE_EXIT(MappedViewOfFile.Win32MapViewOfFile(FileMapping, FILE_MAP_READ));

    PBYTE pb = reinterpret_cast<BYTE*>(static_cast<VOID*>(MappedViewOfFile));
    if (((pb[0] == 0xFF) && (pb[1] == 0xFE)) || ((pb[1] == 0xFF) && (pb[0] == 0xFE)))
    {
        fUnicodeFile = TRUE;
        ASSERT_NTC(ullFileCharacters %2 == 0);
        ullFileCharacters = ullFileCharacters / sizeof(WCHAR);
    }

    pCursor = static_cast<VOID*>(MappedViewOfFile);
    
    for ( ullCursorPos = 0; ullCursorPos < ullFileCharacters; ++ullCursorPos )
    {        
        CStringBuffer manifestfile;

        SKIP_LINE_BREAKERS(pCursor, ullFileCharacters, ullCursorPos);

        //
        // at end of the file, quit quietly
        // 
        if (ullCursorPos == ullFileCharacters)
        {
            break;
        }

        SetPointerToCurrentPostion(pCursor, ullCursorPos, pszLineStart); 

        FIND_NEXT_LINE_BREAKERS(pCursor, ullFileCharacters, ullCursorPos);
        //ENSURE_NOT_END(ullCursorPos, ullFileCharacters);
        
        SetPointerToCurrentPostion(pCursor, ullCursorPos - 1, pszLineEnd); 

        dwLineSize  = (DWORD)(((ULONGLONG)pszLineEnd - (ULONGLONG)pszLineStart) / (fUnicodeFile ? sizeof(WCHAR) : sizeof(CHAR))) + 1;

        IFFAILED_EXIT(ParseManifestInfo(fUnicodeFile, pszLineStart, dwLineSize, dwFlags, manifestfile));
        
        // generate the msm file
        IFFAILED_EXIT(Msmgen_SingleAssemblyToMsm(dwFlags, manifestfile));

        //
        // close the msm for each msm right now.
        //
        if (dwFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE)
        {
            IFFAILED_EXIT(EndMsmGeneration());
        }
    }

Exit:
    return hr;
}

VOID MsmgenInitialize()
{
    InitializeMsmInfo();
    InitCurrentAssemblyInfo();
    return;
}

HRESULT GenerateMsm(wchar_t * exe, wchar_t ** Options, SIZE_T CchOptions)
{
    HRESULT hr = S_OK;    
    PWSTR pszManifestFileName= NULL; 
    PWSTR pszManifestListFile =NULL;
    DWORD dwGenFlags;

    //
    // initalize the global structure
    //
    MsmgenInitialize();  
    
    //
    // parse and validate parameters
    //
    IFFAILED_EXIT(ValidateMsmgenParameters(exe, Options, CchOptions, &pszManifestFileName, &pszManifestListFile, dwGenFlags));

    //
    // if the destination msm is one file, prepare it for msm generation here
    //
    if ((dwGenFlags == MSMGEN_FROM_SINGLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE) || (dwGenFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE))
    {                
        IFFAILED_EXIT(PrepareMsmOutputFiles(pszManifestFileName != NULL? pszManifestFileName : pszManifestListFile));
    }

    if (pszManifestFileName != NULL)
    {
        IFFAILED_EXIT(Msmgen_SingleAssemblyToMsm(dwGenFlags, pszManifestFileName));
    }
    else
    {
        ASSERT_NTC(pszManifestListFile != NULL);
        ASSERT_NTC((dwGenFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE) || (dwGenFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_MULTIPLE_MERGE_MODULE));

        IFFAILED_EXIT(Msmgen_MultipleAssemblySources(dwGenFlags, pszManifestListFile));
    }

    //
    // finish the construction of MSM : close the cabinet and files
    //
    if ((dwGenFlags == MSMGEN_FROM_SINGLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE) || (dwGenFlags == MSMGEN_FROM_MULTIPLE_ASSEMBLY_TO_SINGLE_MERGE_MODULE))
    {
        IFFAILED_EXIT(EndMsmGeneration());
    }

Exit:
    CleanupMsm(); // close it so that msi could use it

    return hr;
    }

#ifdef MSMGEN_TEST
//
// both input filename are fully-qualified filename
//
HRESULT MergeMsmIntoMsi(PCWSTR msmFilename, PCWSTR msiFilename, PCWSTR FeatureIdentifier)
{
    HRESULT hr = S_OK;
    IMsmMerge2 * pMsmMerge = NULL;
    CStringBuffer destPath;
    BSTR bstr = NULL;

    //get msi template
    
    IFFALSE_EXIT(CopyFileW(L"%ProgramFiles%\\msmgen\\templates\\msmgen.msi", msiFilename, FALSE));
    IFFALSE_EXIT(SetFileAttributesW(msiFilename, FILE_ATTRIBUTE_NORMAL));

    IFFAILED_EXIT(CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IMsmMerge2, (void**)&pMsmMerge));

    // 
    // open msi for merge
    //
    bstr = ::SysAllocString(msiFilename);
    IFFAILED_EXIT(pMsmMerge->OpenDatabase(bstr));
    ::SysFreeString(bstr);

    //
    // open msm for merge
    //
    bstr = ::SysAllocString(msmFilename);
    IFFAILED_EXIT(pMsmMerge->OpenModule(bstr, g_MsmInfo.m_sLanguageID));
    ::SysFreeString(bstr);

    //
    // merge the module into the database
    //
    bstr = ::SysAllocString(FeatureIdentifier);
    IFFAILED_EXIT(pMsmMerge->Merge(bstr, NULL));
    ::SysFreeString(bstr);

    //
    // extract files into the destination directory 
    //
    
    IFFALSE_EXIT(destPath.Win32Assign(msiFilename, wcslen(msiFilename)));
    IFFALSE_EXIT(destPath.Win32RemoveLastPathElement());
    IFFALSE_EXIT(destPath.Win32Append("\\", 1));

    bstr = ::SysAllocString(destPath);
    IFFAILED_EXIT(pMsmMerge->ExtractFilesEx(bstr, VARIANT_TRUE, NULL));
    ::SysFreeString(bstr);
    bstr = NULL;

Exit:

    //
    // clean up
    //
    if (pMsmMerge)
    {
        pMsmMerge->CloseModule();        
        pMsmMerge->CloseDatabase(SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE); // commit
        pMsmMerge->Release();
    }
    
    ::SysFreeString(bstr);

    return hr;
}
#endif

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    HRESULT         hr = S_OK;
    
    // parse args.
    if ((argc <= 2) ||  ((argc % 2) != 1))
    {
        PrintUsage(argv[0]);
        hr = E_INVALIDARG;
        goto Exit;
    }
    if (!FusionpInitializeHeap(NULL)){
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    ::CoInitialize(NULL);

    IFFAILED_EXIT(GenerateMsm(argv[0], argv + 1, argc - 1));

#ifdef MSMGEN_TEST
    //
    // generate msi by setting input-parameter to be the fullpath filename of manifest
    //
    WCHAR msifilename[] = L"w:\\tmp\\1.msi";
    WCHAR FeatureIdentifier[] = L"SxsMsmgen"; // for test purpose only
    WCHAR msmfilename[] = L"w:\\tmp\\1.msm";


    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(g_MsmInfo.m_sbMsmFileName));   
    IFFALSE_EXIT(CopyFileW(curAsmInfo.m_sbAssemblyPath, msmfilename, FALSE));
    IFFAILED_EXIT(MergeMsmIntoMsi(msmfilename, msifilename, FeatureIdentifier));

    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiInstallProduct(msifilename, NULL));

#endif

Exit:
    if (hr == S_OK)
        fprintf(stderr, "msm is generated successfully!");
    else
        fprintf(stderr, "msm is failed to be generated!");
    ::CoUninitialize();
    return (hr == S_OK) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\cabinet.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cabinet.cpp

Abstract:

    cabinet management Function calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

#include "msmgen.h"
#include "util.h"

extern BOOL __stdcall SxspDeleteDirectory(const CBaseStringBuffer &rdir);


#include <fci.h>
#include <fdi.h>

#include "msmfci.h"
#include "msmfdi.h"

ERF	erf;
//
// FCI
//
HRESULT InitializeCabinetForWrite()
{
	HFCI			hfci;

	CCAB			cab_parameters;
	client_state	cs;    
    HRESULT         hr = S_OK;    

    // Initialise our internal state
	cs.total_compressed_size = 0;
	cs.total_uncompressed_size = 0;

	set_cab_parameters(&cab_parameters);

	hfci = FCICreate(
		&erf,
		file_placed,
		fci_mem_alloc,
		fci_mem_free,
        fci_open,
        fci_read,
        fci_write,
        fci_close,
        fci_seek,
        fci_delete,
		get_temp_file,
        &cab_parameters,
        &cs
	);

	if (hfci == NULL)
	{
		printf("CAB: FCICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper));

        SETFAIL_AND_EXIT;
	}else
    {
        g_MsmInfo.m_hfci = hfci;
        hfci= NULL;
    }

Exit:    
    return hr;
}

HRESULT AddFileToCabinetW(PCWSTR full_filename, SIZE_T CchFullFileName, PCWSTR relative_filename, SIZE_T CchRelativePath)
{
    HRESULT hr = S_OK;
    CHAR pszpath[MAX_PATH];
    CHAR pszfilename[MAX_PATH];

    WideCharToMultiByte(
        CP_ACP, 0, full_filename, (int)CchFullFileName,
        pszpath, MAX_PATH, NULL, NULL);
    pszpath[CchFullFileName] = '\0';

    WideCharToMultiByte(
        CP_ACP, 0, relative_filename, (int)CchRelativePath,
        pszfilename, MAX_PATH, NULL, NULL);
    pszfilename[CchRelativePath] = '\0';

	if (FALSE == FCIAddFile(
		    g_MsmInfo.m_hfci,
		    pszpath,                /* filename to add : fully qualified filename */
		    pszfilename,            /* file name in cabinet file : relative filepath */
		    FALSE,                  /* file is not executable */
		    get_next_cabinet,
		    progress,
		    get_open_info,
            COMPRESSION_TYPE))	
    {
        fprintf(stderr, "adding file %s to the cabinet failed\n", pszpath);
        SETFAIL_AND_EXIT;
    }

Exit:    
    return hr;
}

HRESULT AddFileToCabinetA(PCSTR full_filename, SIZE_T CchFullFileName, PCSTR relative_filename, SIZE_T CchRelativePath)
{
    HRESULT hr = S_OK;
    WCHAR szFullFilename[MAX_PATH]; 
    WCHAR szRelativeFilename[MAX_PATH];

    swprintf(szFullFilename, L"%S", full_filename);
    swprintf(szRelativeFilename, L"%S", relative_filename);

    IFFAILED_EXIT(AddFileToCabinetW(szFullFilename, CchFullFileName, szRelativeFilename, CchRelativePath));

Exit:
    return hr;
}
HRESULT CloseCabinet()
{
    HRESULT hr = S_OK; 
    CurrentAssemblyRealign;

	if (FALSE == FCIFlushCabinet(
		    g_MsmInfo.m_hfci,
		    FALSE,
		    get_next_cabinet,
		    progress))
    {
        fprintf(stderr, "Flush Cabinet failed\n");
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (FCIDestroy(g_MsmInfo.m_hfci) != TRUE)
    { 
        SETFAIL_AND_EXIT;	
    }
    else
        g_MsmInfo.m_hfci = NULL;

Exit:    
	return hr;
}

//
// FDI
//
HRESULT MoveFilesInCabinetA(char * sourceCabinet)
{
    HRESULT         hr = S_OK;
	HFDI	        hfdi = NULL;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR         hf = -1;
    DWORD           num;      
extern char dest_dir[MAX_PATH];

	hfdi = FDICreate(
		fdi_mem_alloc,
		fdi_mem_free,
		fdi_file_open,
		fdi_file_read,
		fdi_file_write,
		fdi_file_close,
		fdi_file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		printf("FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		SETFAIL_AND_EXIT;
	}


	hf = fdi_file_open(
		sourceCabinet,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		printf("Unable to open '%s' for input\n", sourceCabinet);
		SETFAIL_AND_EXIT;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * It is not a cabinet!, BUT it must be since it is named as MergeModule.cab in a msm
		 */		

		printf(
			"FDIIsCabinet() failed: '%s' is not a cabinet\n",
			sourceCabinet
		);

        SETFAIL_AND_EXIT;
	}
	else
	{
		_close((int)hf);
#ifdef MSMGEN_TEST
		printf(
			"Information on cabinet file '%s'\n"
			"   Total length of cabinet file : %d\n"
			"   Number of folders in cabinet : %d\n"
			"   Number of files in cabinet   : %d\n"
			"   Cabinet set ID               : %d\n"
			"   Cabinet number in set        : %d\n"
			"   RESERVE area in cabinet?     : %s\n"
			"   Chained to prev cabinet?     : %s\n"
			"   Chained to next cabinet?     : %s\n"
			"\n",
			sourceCabinet,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? "yes" : "no",
			fdici.hasprev == TRUE ? "yes" : "no",
			fdici.hasnext == TRUE ? "yes" : "no"
		);
#endif
        if ((fdici.fReserve == TRUE)|| (fdici.hasprev == TRUE) || (fdici.hasnext == TRUE))
        {
            printf("ERROR file format : MSI 1.5 support one and only one cabinet in MergeModule.cab!\n");
            SETFAIL_AND_EXIT;
        }
	}

    //
    // create a temporary directory for use
    //
    num = ExpandEnvironmentStringsA(MSM_TEMP_CABIN_DIRECTORY_A, dest_dir, NUMBER_OF(dest_dir));
    if ( (num == 0) || (num > NUMBER_OF(dest_dir)))
        SETFAIL_AND_EXIT;

    DWORD dwAttribs = GetFileAttributesA(dest_dir);
    if (dwAttribs != (DWORD)(-1))
    {
        if ((dwAttribs &  FILE_ATTRIBUTE_DIRECTORY) == 0 )        
            SETFAIL_AND_EXIT;

        CStringBuffer sb; 
        WCHAR wdir[MAX_PATH];

        num = ExpandEnvironmentStringsW(MSM_TEMP_CABIN_DIRECTORY_W, wdir, NUMBER_OF(wdir));
        if ( (num == 0) || (num > NUMBER_OF(wdir)))
            SETFAIL_AND_EXIT;

        IFFALSE_EXIT(sb.Win32Assign(wdir, wcslen(wdir)));
        IFFALSE_EXIT(SxspDeleteDirectory(sb));
    }

    IFFALSE_EXIT(CreateDirectoryA(dest_dir, NULL));
    char * p = NULL;
    char sourceDir[MAX_PATH];

    p = strrchr(sourceCabinet, '\\');
    ASSERT_NTC(p != NULL);
    p ++; // skip "\"
    strncpy(sourceDir, sourceCabinet, p - sourceCabinet);
    sourceDir[p - sourceCabinet] = '\0';

	if (TRUE != FDICopy(
		hfdi,
		p,
		sourceDir,
		0,
		fdi_notification_function,
		NULL,
		NULL))
	{
		printf(
			"FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		printf(
			"FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return FALSE;
	}
    hfdi = NULL;

Exit:
    if (hfdi != NULL)
	    (void) FDIDestroy(hfdi);
    if ( hf != -1)
        _close((int)hf);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\msmfdi.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>

#include <fdi.h>

char dest_dir[MAX_PATH];

/*
 * Memory allocation function
 */
FNALLOC(fdi_mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(fdi_mem_free)
{
	free(pv);
}


FNOPEN(fdi_file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(fdi_file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(fdi_file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(fdi_file_close)
{
	return _close((int)hf);
}


FNSEEK(fdi_file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(fdi_notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
#ifdef MSMGEN_TEST
			printf(
				"fdintCABINET_INFO\n"
				"  next cabinet     = %s\n"
				"  next disk        = %s\n"
				"  cabinet path     = %s\n"
				"  cabinet set ID   = %d\n"
				"  cabinet # in set = %d (zero based)\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet
			);
#endif
			return 0;
		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			printf(
				"fdintPARTIAL_FILE\n"
				"   name of continued file            = %s\n"
				"   name of cabinet where file starts = %s\n"
				"   name of disk where file starts    = %s\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			INT_PTR handle;
			char	destination[MAX_PATH];

#ifdef MSMGEN_TEST
            printf(
				"fdintCOPY_FILE\n"
				"  file name in cabinet = %s\n"
				"  uncompressed file size = %d\n",
				pfdin->psz1,
				pfdin->cb
			);
#endif
			
			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1
			);

			handle = fdi_file_open(
				destination,
				_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
				_S_IREAD | _S_IWRITE 
			);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;            
            char    destination[256];

 			printf(
				"fdintCLOSE_FILE_INFO\n"
				"   file name in cabinet = %s\n"
				"\n",
				pfdin->psz1
			);

            sprintf(
                destination, 
                "%s%s",
                dest_dir,
                pfdin->psz1
            );

			fdi_file_close(pfdin->hf);


            /*
             * Set date/time
             *
             * Need Win32 type handle for to set date/time
             */
            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            /*
             * Mask out attribute bits other than readonly,
             * hidden, system, and archive, since the other
             * attribute bits are reserved for use by
             * the cabinet format.
             */         
            (void) SetFileAttributes(
                destination,
                pfdin->attribs
            );

            if (!SUCCEEDED(AddFileToCabinetA(destination, strlen(destination), //"%Temp%\\msm_temp_cabinet_dir\\a.manifest.12213232312312312
                pfdin->psz1, strlen(pfdin->psz1))))                           // a.manifest.12213232312312312
            {
                return -1; // abort
            }

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
			printf(
				"fdintNEXT_CABINET\n"
				"   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
				"   cabinet path name                         = %s\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
			return 0;
	}

	return 0;
}



char *return_fdi_error_string(INT  err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc
FUSION_MSI_INC_PATH = $(FUSION_PATH)\msi\inc

MAJORCOMP=fusion
MINORCOMP=msmgen

TARGETNAME=msmgen
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_NTDLL=1
USE_MSVCRT=1
USE_NATIVE_EH=1

INCLUDES= \
 $(FUSION_MSI_INC_PATH);\
 $(FUSION_INC_PATH);\
 $(INCLUDES);\
 $(COM_INC_PATH);

UMTYPE=console
UMENTRY=wmain

SOURCES= \
 ..\msmgen.cpp \
 ..\common.cpp \
 ..\db.cpp \
 ..\cabinet.cpp 

TARGETLIBS= \
 $(FUSION_PATH)\win32simplelock\$(O)\win32simplelock.obj \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs1.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs2.lib \
 $(FUSION_PATH)\$(O)\sxstest_idl.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxsmain.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)utils.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xmlparser.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)id.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(FUSION_PATH)\$(O)\fusion_uuid.lib \
 $(FUSION_PATH)\$(O)\fusion_dump.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xml.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(SDK_LIB_PATH)\ntdll.lib \
 $(SDK_LIB_PATH)\uuid.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\crypt32.lib \
 $(SDK_LIB_PATH)\rpcrt4.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
 $(SDK_LIB_PATH)\imagehlp.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\wintrust.lib \
 $(SDK_LIB_PATH)\mpr.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\comctl32.lib \
 $(SDK_LIB_PATH)\netapi32.lib \
 $(FUSION_SLIST_LIB) \
 $(SDK_LIB_PATH)\msxml2.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
 $(SDK_LIB_PATH)\cabinet.lib \
 $(SDK_LIB_PATH)\msi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\db.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    db.cpp

Abstract:

    Database calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/
#include "string.h"
#include "msmgen.h"
#include "msidefs.h"
#include "Msiquery.h"

#include "objbase.h"
#include "coguid.h"

#define NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY   6
#define NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS           5
#define NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB            3

#define POLICY_TYPE_PREFIX            L"win32-policy"
#define POLICY_TYPE_PREFIX             NUMBER_OF(POLICY_TYPE_PREFIX) - 1

static PWSTR s_InsertTableSQL[] = 
{
        L"INSERT INTO Directory (Directory, Directory_Parent, DefaultDir) VALUES (?, ?, ?)",
        L"INSERT INTO Component (Component, ComponentId, Directory_, KeyPath, Attributes, Condition) VALUES (?, ?, ?, ?, 0, '')",
        L"INSERT INTO File (File, Component_, FileName, Sequence, FileSize, Version, Language, Attributes) VALUES (?, ?, ?, ?, '0', '1.0.0.0', '0', 0)",
        L"INSERT INTO MsiAssembly (Component_, Feature_, File_Manifest, File_Application, Attributes) VALUES (?, ?, ?, '', 1)",
        L"INSERT INTO MsiAssemblyName (Component_, Name, Value) VALUES (?, ?, ?)",
        L"INSERT INTO ModuleSignature (ModuleID, Version, Language) VALUES (?, ?, 0)",
        L"INSERT INTO ModuleComponents (Component, ModuleID, Language) VALUES (?, ?, 0)",
        L"INSERT INTO Property (Property, Value) VALUES (?, ?)",
        L"INSERT INTO ProgId (ProgId, Class_, Description, ProgId_Parent, Icon_, IconIndex) VALUES (?, ?, ?, NULL, NULL, NULL)",
        L"INSERT INTO Class (CLSID, Component_, ProgId_Default, Description, Feature_, Context, AppId_, FileTypeMask, Icon_, IconIndex, DefInprocHandler, Argument, Attributes)"
                        L"VALUES (?, ?, ?, ?, ?, 'InprocServer32', NULL, NULL, NULL, NULL, NULL, NULL, 0)",
        L"INSERT INTO TypeLib (LibID, Component_, Version, Feature_, Language, Description, Directory_, Cost)"
                        L"VALUES (?, ?, ?, ?, 0, NULL, NULL, 0)"
};

HRESULT ExecuteDeleteFromSQL(PCWSTR szTablename, PCWSTR szId, PCWSTR szValue)
{
    HRESULT hr = S_OK;
    WCHAR pwszSQL[MAX_PATH];    
    PMSIHANDLE hView = NULL;

    swprintf(pwszSQL, L"DELETE FROM `%s` WHERE `%s`='%s'", szTablename, szId, szValue);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));

Exit:
    return hr;

}
    
DWORD g_FileSequenceNumber = 0;

HRESULT ExecuteDropTableSQL(PCWSTR pszTableName)
{
    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSICONDITION con;

    con = MsiDatabaseIsTablePersistent(g_MsmInfo.m_hdb, pszTableName);
    if (con == MSICONDITION_NONE)
    {
        hr = S_OK; // the table does not exist in DB, so do not need to drop the table at all
        goto Exit; 
    }
    else if (con != MSICONDITION_TRUE)
        SETFAIL_AND_EXIT;

    //
    // drop the table
    //

    swprintf(pwszSQL, L"DROP TABLE `%s`", pszTableName);    

    //
    // ignore the error for drop table because this table maybe non-exist at all
    //
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));
Exit:
    return hr;
}

HRESULT ExecuteInsertTableSQL(DWORD tableIndex, UINT cRecords, ...)
{
    PMSIHANDLE          hView;
    PMSIHANDLE          hRecord = NULL;   
    PCWSTR              pwszRecord = NULL;
    va_list             ap;
    HRESULT             hr = S_OK;    
    PWSTR               pwszSQL = NULL;

    pwszSQL = s_InsertTableSQL[tableIndex];

    //
    // create records 
    //
    switch (tableIndex){
        case OPT_FILE:
            hRecord = ::MsiCreateRecord(cRecords + 1);
            break;            
        case OPT_DIRECTORY:
        case OPT_COMPONENT:        
        case OPT_MSIASSEMBLY:
        case OPT_MSIASSEMBLYNAME:
        case OPT_MODULESIGNATURE:
        case OPT_MODULECOMPONENTS:
        case OPT_PROPERTY:
        case OPT_PROGID:
        case OPT_CLASS:
        case OPT_TYPELIB:        
            hRecord = ::MsiCreateRecord(cRecords);
            break;
        default:
            SETFAIL_AND_EXIT;
    }

    if (hRecord == NULL)
        SETFAIL_AND_EXIT;

    //
    // get parameters
    //
    va_start(ap, cRecords);

    for (DWORD i=0; i<cRecords; i++)
    {
        pwszRecord = va_arg(ap, PCWSTR);
        if ((tableIndex == OPT_TYPELIB) && (i == 2)) // set version for typelib
        {
            UINT x = _wtoi(pwszRecord);
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetInteger(hRecord, i+1, x));
        }
        else
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStringW(hRecord, i+1, pwszRecord));
    }

    //
    // for fileTable, add a sequence number here
    //
    if (tableIndex == OPT_FILE)
    {
        g_FileSequenceNumber ++;
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetInteger(hRecord, cRecords + 1 , g_FileSequenceNumber));
    }

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));

Exit:
    va_end(ap);
    return hr;
}

//
// check a table with a name-value pair of its identifier
//
HRESULT ExecuteQuerySQL(PCWSTR szTableName, PCWSTR szKeyName, PCWSTR szKeyValue, BOOL & fExist, MSIHANDLE * hOutRecord)
{

    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSIHANDLE hRecord;
    MSIHANDLE * phRecord = hOutRecord;

    if (phRecord == NULL)
        phRecord = &hRecord;

    fExist = FALSE;
    swprintf(pwszSQL, L"SELECT * FROM `%s` WHERE `%s`='%s'", szTableName, szKeyName, szKeyValue);    

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));
    UINT err = ::MsiViewFetch(hView, phRecord);
    if ((err == ERROR_NO_MORE_ITEMS) || ((err == ERROR_SUCCESS) && (phRecord == NULL)))
        fExist = FALSE;
    else if (err != ERROR_SUCCESS)
        SET_HRERR_AND_EXIT(err);
    else
        fExist = TRUE;
Exit:        
    if (phRecord == &hRecord)
        MsiCloseHandle(hRecord);

    return hr;
}

HRESULT ExecuteUpdateSQL(PCWSTR szTableName, PCWSTR KeyName, PCWSTR KeyValue, PCWSTR ColumnName, PCWSTR NewValue)
{
    WCHAR pwszSQL[MAX_PATH];
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    MSIHANDLE * hRecord = NULL;
    BOOL fExist = FALSE;

    swprintf(pwszSQL, L"UPDATE '%s' SET `%s` = '%s' WHERE '%s'='%s'", 
        szTableName, ColumnName, NewValue, KeyName, KeyValue);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(g_MsmInfo.m_hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));

Exit:
    return hr;
}

HRESULT GetShortLongFileNamePair(PCWSTR fullpath, SIZE_T cch, CStringBuffer & namepair)
{
    WCHAR shortname[MAX_PATH];
    HRESULT hr = S_OK;
    PWSTR p = NULL; 
    DWORD ret = GetShortPathNameW(
        fullpath, 
        shortname,
        NUMBER_OF(shortname));
    if ( ret == 0 )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }
    if (ret > NUMBER_OF(shortname))
    {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }
    p = wcsrchr(shortname, L'\\');
    p ++ ;

    IFFALSE_EXIT(namepair.Win32Assign(p, wcslen(p)));
    IFFALSE_EXIT(namepair.Win32Append(L"|", 1));

    p = wcsrchr(fullpath, L'\\');
    p++;
    IFFALSE_EXIT(namepair.Win32Append(p, wcslen(p)));

Exit:
    return hr;
}

//
// Function:
//      - add manifest and catalog into the cabinet 
//      - add manifest and catalog into FileTable 
//
// because this function used ComponentIdentifier, it has to wait until ComponentIdentifier is set
// and it is set to be the name of the assembly
//
HRESULT SetManifestAndCatalog(CStringBuffer & strSystemFolder)
{
    HRESULT hr = S_OK;
    CStringBuffer sbBakFileName;
    CStringBuffer sbNamePair;

    CurrentAssemblyRealign;
    //
    // add manifest into FileTable and Cabinet
    //    
    IFFALSE_EXIT(sbBakFileName.Win32Assign(curAsmInfo.m_sbManifestFileName));    
    IFFALSE_EXIT(curAsmInfo.m_sbManifestFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(sbBakFileName));
    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), sbNamePair));
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbManifestFileName),   // sfp.manifest.123434545
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(sbNamePair)));                          // sfp.manifest
    
    // add manifest to the cabinet 
    IFFAILED_EXIT(AddFileToCabinetW( curAsmInfo.m_sbAssemblyPath,        // fullpath : c:\tests\sfp\sfp.manifest
                                    curAsmInfo.m_sbAssemblyPath.Cch(),
                                    curAsmInfo.m_sbManifestFileName,    // identifier in FILE : sfp.manifest.1234234234234234
                                    curAsmInfo.m_sbManifestFileName.Cch()));
    //
    // add catalog into FileTable and Cabinet
    //           
    IFFALSE_EXIT(sbBakFileName.Win32ChangePathExtension(CATALOG_FILE_EXT, NUMBER_OF(CATALOG_FILE_EXT) -1, eAddIfNoExtension));    
    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(sbBakFileName));

    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), sbNamePair));
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbCatalogFileName),    // sfp.cat.123434345345
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(sbNamePair)));                          // sfp.cat

    // add catalog to the cabinet 
    IFFAILED_EXIT(AddFileToCabinetW(curAsmInfo.m_sbAssemblyPath,             // fullpath : c:\tests\sfp\sfp.cat
                                   curAsmInfo.m_sbAssemblyPath.Cch(),    
                                   curAsmInfo.m_sbCatalogFileName,            //
                                   curAsmInfo.m_sbCatalogFileName.Cch()));    


    // set directory table    
    IFFALSE_EXIT(strSystemFolder.Win32Assign(SYSTEM_FOLDER, NUMBER_OF(SYSTEM_FOLDER)-1));        
    IFFALSE_EXIT(strSystemFolder.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    // insert into Directory Table
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_DIRECTORY,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
        MAKE_PCWSTR(strSystemFolder),
        MAKE_PCWSTR(L"TARGETDIR"),
        MAKE_PCWSTR(L".:System32")));

Exit:
    return hr;
}


HRESULT PropagateXMLDOMNode(IXMLDOMNode*  node, ELEMENT_ALLOWED_ATTRIBUTE rgAllowedAttribute[], DWORD num)
{
    HRESULT hr = S_OK;
    IXMLDOMNamedNodeMap* pattrs = NULL;
    IXMLDOMNode* pChild = NULL;
    CStringBuffer tmp;
    DWORD j;
     
    CurrentAssemblyRealign;
    
    for ( j = 0 ; j < num; j++)    
        rgAllowedAttribute[j].m_fValued = FALSE;
    
    // 
    // write MSIAssemblyName table
    //
    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name;
            pChild->get_nodeName(&name);
            for ( j = 0; j < num; j++)
            {
                if((rgAllowedAttribute[j].m_fValued == FALSE) && (wcscmp(rgAllowedAttribute[j].m_name, name) == 0))
                {
                    VARIANT value;
                    pChild->get_nodeValue(&value);
                    if (value.vt != VT_BSTR)
                    {
                        hr = E_FAIL;
                        break;
                    }

                    if ( ! rgAllowedAttribute[j].m_value->Win32Assign(V_BSTR(&value), wcslen(V_BSTR(&value))))                    
                        hr = HRESULT_FROM_WIN32(::GetLastError());

                    VariantClear(&value);
                    if ( !SUCCEEDED(hr))
                        break;

                    hr = S_OK;
                    if (rgAllowedAttribute[j].m_callbackFunc != NULL)
                        hr = rgAllowedAttribute[j].m_callbackFunc(
                                        rgAllowedAttribute[j].m_name,
                                        *(rgAllowedAttribute[j].m_value));

                    if ( !SUCCEEDED(hr))
                        break;
                    
                    rgAllowedAttribute[j].m_fValued = TRUE;                    
                }
            }

            //
            // cleaning work
            //
            SysFreeString(name);
            pChild->Release();
            pChild = NULL;

            if (!SUCCEEDED(hr))
            {
                pattrs->Release();
                pattrs = NULL;

                goto Exit;
            }
            pattrs->nextNode(&pChild);
        }

        pattrs->Release();
        pattrs = NULL;
    }
Exit:
    SAFE_RELEASE_COMPOINTER(pattrs);
    SAFE_RELEASE_COMPOINTER(pChild);

    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_file(IXMLDOMNode*  node)
{
    IXMLDOMNamedNodeMap* pattrs = NULL;
    IXMLDOMNode* pChild = NULL;    
    BOOL fFoundFileName = FALSE;
    HRESULT hr = S_OK;
    CStringBuffer tmpStr;
    CStringBuffer ShortLongPair;
    DWORD CchFullpathFilename;

    CurrentAssemblyRealign;
    IFFALSE_EXIT(tmpStr.Win32Assign(curAsmInfo.m_sbAssemblyPath));

    //
    // get the filename from node
    //
    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name = NULL;
            pChild->get_nodeName(&name);
            if (wcscmp(name, L"name") == 0) 
            {
                VARIANT value;
                pChild->get_nodeValue(&value);
                if (value.vt != VT_BSTR)
                {
                    VariantClear(&value);
                    hr = E_FAIL;
                    break;
                }

                if ( !curAsmInfo.m_sbAssemblyPath.Win32Append(V_BSTR(&value), wcslen(V_BSTR(&value))))
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                VariantClear(&value);
                fFoundFileName = TRUE;                 
            }

            ::SysFreeString(name);
            pChild->Release();
            pChild = NULL;

            if (!SUCCEEDED(hr)){
                pattrs->Release();
                pattrs = NULL;

                goto Exit;
            }

            if ( fFoundFileName )
                break;

            pattrs->nextNode(&pChild);
        }
        if (pattrs)
        {
            pattrs->Release();
            pattrs = NULL;
        }
    }

    if ( !fFoundFileName)
        SETFAIL_AND_EXIT;

    CchFullpathFilename = curAsmInfo.m_sbAssemblyPath.GetCchAsDWORD();
    //
    // get fully qualified filename
    //
    IFFAILED_EXIT(GetShortLongFileNamePair(curAsmInfo.m_sbAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch(), ShortLongPair));

    //
    // check the existence of the file
    //
    if ( GetFileAttributesW(curAsmInfo.m_sbAssemblyPath) == DWORD(-1))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    //
    // get FileIdentifier for this file    
    //    
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    //
    // add the file to FileTable
    //    
    IFFAILED_EXIT(ExecuteInsertTableSQL(        
        OPT_FILE,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE,
        MAKE_PCWSTR(curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath),    // a.dll.12223423423423412343
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),      
        MAKE_PCWSTR(ShortLongPair)));                                         // a.dll | a.dll
    
    //
    // add this file to the cabinet
    //
    IFFAILED_EXIT(AddFileToCabinetW(
        curAsmInfo.m_sbAssemblyPath, CchFullpathFilename,
        curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath, curAsmInfo.m_sbAssemblyPath.Cch() - curAsmInfo.m_CchAssemblyPath)); 

    //
    // set Component Table with ComponentID, componentIdentifier, keypath: 
    //
    if (curAsmInfo.m_fComponentTableSet == FALSE)
    {
        CStringBuffer str;
        IFFALSE_EXIT(str.Win32Assign(SYSTEM_FOLDER, NUMBER_OF(SYSTEM_FOLDER)-1));        
        IFFALSE_EXIT(str.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

        IFFAILED_EXIT(ExecuteInsertTableSQL(
                 OPT_COMPONENT, 
                 NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT, 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentID),
                 MAKE_PCWSTR(str),
                 MAKE_PCWSTR(curAsmInfo.m_sbAssemblyPath + curAsmInfo.m_CchAssemblyPath)));        
        
        curAsmInfo.m_fComponentTableSet = TRUE;
    }



Exit:    
    if (pattrs)
        pattrs->Release();

    if(pChild)
        pChild->Release();


    return hr;
}

BOOL IsValidAttributes(const ELEMENT_ALLOWED_ATTRIBUTE attribs[], DWORD num)
{
    for (DWORD i=0; i< num; i++)
    {
        if (attribs[i].m_fRequired && ! attribs[i].m_fValued)
        {
            ::SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    return TRUE;
}

HRESULT GetPrimAssemblyName(PCWSTR pwszAssemblyName, PWSTR pwszPrimAssemblyName, DWORD & cch)
{
    HRESULT hr = S_OK;
    DWORD i = 0, num = wcslen(pwszAssemblyName);

    if (cch < num)    
    {
        cch = num;
        SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(pwszPrimAssemblyName, pwszAssemblyName);

    while ( i < num)
    {
        if (pwszPrimAssemblyName[i] == L'-')
        {
            pwszPrimAssemblyName[i] = L'_';
        }
        i++;
    }

Exit:
    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_assemblyIdentity(IXMLDOMNode*  node)
{    
    CStringBuffer strSystemFolder;
    //
    // we only are interested in the assemblyIdentity of the component, that is,
    // <assemblyIdentity .... /> at the head of manifest, ignore <assemblyIdentity ..../> of
    // dependency
    //
    if (curAsmInfo.m_sbComponentIdentifier.IsEmpty() == FALSE)
    {
        return S_OK;
    }
    
    HRESULT hr = S_OK;    
    BOOL fExist;
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_assemblyIdentity_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY] = 
    {
        {L"name", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
        {L"language", FALSE, NULL, FALSE, &rg_StringBuffer[1]},
        {L"version", TRUE, NULL, FALSE, &rg_StringBuffer[2]},
        {L"processorArchitecture", TRUE, NULL, FALSE, &rg_StringBuffer[3]},
        {L"publicKeyToken", FALSE, NULL, FALSE, &rg_StringBuffer[4]},
        {L"type", TRUE, NULL, FALSE, &rg_StringBuffer[5]}
    };
    

    CStringBuffer tmp;    
    WCHAR tmpbuf[MAX_PATH];
    DWORD num = NUMBER_OF(tmpbuf);
    
    CurrentAssemblyRealign; 
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_assemblyIdentity_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY));
    IFFALSE_EXIT(IsValidAttributes(rg_assemblyIdentity_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_ASSEMBLYIDENTITY));

    IFFAILED_EXIT(GetPrimAssemblyName(*rg_assemblyIdentity_AllowedAttributes[MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_NAME].m_value, tmpbuf, num));

    //
    // set componentIdentifier and add entries to table which depends on componentIdentifier
    //    
    IFFALSE_EXIT(curAsmInfo.m_sbComponentIdentifier.Win32Assign(tmpbuf, wcslen(tmpbuf)));
    IFFALSE_EXIT(curAsmInfo.m_sbComponentIdentifier.Win32Append(g_MsmInfo.m_sbModuleGuidStr));

    //
    // insert manifest & catalog into File Table, cabinet,
    //    
    IFFAILED_EXIT(SetManifestAndCatalog(strSystemFolder));

    //
    // write component table if it is a policy
    //
    ASSERT_NTC(curAsmInfo.m_fComponentTableSet == FALSE);    
    if (0 == _wcsnicmp(*(rg_assemblyIdentity_AllowedAttributes[5].m_value), 
                            POLICY_TYPE_PREFIX, 
                            POLICY_TYPE_PREFIX_CCH))
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(
                 OPT_COMPONENT, 
                 NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT, 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
                 MAKE_PCWSTR(curAsmInfo.m_sbComponentID),
                 MAKE_PCWSTR(strSystemFolder),
                 MAKE_PCWSTR(NULL)));        
        curAsmInfo.m_fComponentTableSet = TRUE;
    }

    //
    // write MsiAssemblyName table
    //
    for (DWORD i = 0; i < NUMBER_OF(rg_assemblyIdentity_AllowedAttributes); i++)
    {
        if (rg_assemblyIdentity_AllowedAttributes[i].m_fValued)
        {
            IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MSIASSEMBLYNAME, 
                            NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLYNAME, 
                            MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
                            MAKE_PCWSTR(rg_assemblyIdentity_AllowedAttributes[i].m_name), 
                            MAKE_PCWSTR(*rg_assemblyIdentity_AllowedAttributes[i].m_value)));
        }
    }

    //
    // write MsiAssebly Table
    //
    curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName);    
    IFFALSE_EXIT(curAsmInfo.m_sbManifestFileName.Win32Append(g_MsmInfo.m_sbModuleGuidStr));
           
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_MSIASSEMBLY, 
        NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLY,
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier), 
        MAKE_PCWSTR(GUID_NULL_IN_STRING),                                
        MAKE_PCWSTR(curAsmInfo.m_sbManifestFileName))); // sfp.manifest.12343454534534534
    
    //
    // write ModuleComponent table using version
    //

    IFFAILED_EXIT(ExecuteQuerySQL(L"ModuleComponents", L"Component", curAsmInfo.m_sbComponentIdentifier, fExist, NULL));
    if ( fExist == FALSE)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MODULECOMPONENTS, 
            NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULECOMPONENTS,
            MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
            MAKE_PCWSTR(g_MsmInfo.m_sbModuleIdentifier)));
    }else
    {
        // updateRecord
    }
    

Exit:
    return hr;
}

void MsmToUpper(CBaseStringBuffer & sb)
{
    CStringBufferAccessor sba;
    sba.Attach(&sb);
    PWSTR str = sba.GetBufferPtr();

    for ( int i = 0; i < sb.Cch(); i++)
    {
        if ((str[i] >= L'a') && (str[i] <= L'z'))
            str[i] = (WCHAR)(str[i] + L'A' - L'a');
    }

    sba.Detach();
    return;
}
HRESULT MSM_PARSER_DOM_NODE_comClass(IXMLDOMNode*  node)
{
    HRESULT hr = S_OK;

    // About this array : 
    //      0, 2 would be stored in class table
    //      1 would be stored in progid table
    //      3 would be ignored and Typelib Table would be created when "<typelib  />" is encounter
    //      4 would be ignored
    //
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_comClass_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS] = {
            {L"clsid", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
            {L"description", FALSE, NULL, FALSE, &rg_StringBuffer[1]},
            {L"progid", FALSE, NULL, FALSE, &rg_StringBuffer[2]},           
            {L"tlbid", FALSE, NULL, FALSE, &rg_StringBuffer[3]},
            {L"threadingModel", FALSE, NULL, FALSE, &rg_StringBuffer[4]}
    };
    
    CurrentAssemblyRealign;
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_comClass_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS));
    IFFALSE_EXIT(IsValidAttributes(rg_comClass_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_COMCLASS));

    // convert GUIDID to msi-required guid : all upper-case in the guid string 
    MsmToUpper(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_CLSID].m_value);
    

    //
    // if the progId is not NULL, Insert an entry to ProgID Table
    //
    if (rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_fValued)
    {
        IFFAILED_EXIT(ExecuteInsertTableSQL( 
            OPT_PROGID,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_PROGID,
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_value),
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_CLSID].m_value),
            MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION].m_value)));
    }

    //
    // insert one entry to ClassTable 
    //
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_CLASS,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_CLASS,
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_CLSID].m_value),        
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_PROGID].m_value),
        MAKE_PCWSTR(*rg_comClass_AllowedAttributes[MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION].m_value),
        MAKE_PCWSTR(GUID_NULL_IN_STRING)));

Exit:
    return hr;
}

HRESULT MSM_PARSER_DOM_NODE_typelib(IXMLDOMNode*  node)
{

    HRESULT hr = S_OK;

    //
    // all of three attributes are required for "<typelib .... />" element
    //
    static CSmallStringBuffer rg_StringBuffer[NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB];
    static ELEMENT_ALLOWED_ATTRIBUTE rg_typelib_AllowedAttributes[NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB] = {
        {L"tlbid", TRUE, NULL, FALSE, &rg_StringBuffer[0]},
        {L"version", TRUE, NULL, FALSE, &rg_StringBuffer[1]},
        {L"helpdir", TRUE, NULL, FALSE, &rg_StringBuffer[2]}
    };
    
    CurrentAssemblyRealign;
    IFFAILED_EXIT(PropagateXMLDOMNode(node, rg_typelib_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB));
    IFFALSE_EXIT(IsValidAttributes(rg_typelib_AllowedAttributes, NUM_OF_ALLOWED_ATTRIBUTE_TYPELIB));
    MsmToUpper(*rg_typelib_AllowedAttributes[MSMGEN_TYPELIB_ATTRIBUTE_TLBID].m_value);    

    //
    // insert one entry to class table
    //
    IFFAILED_EXIT(ExecuteInsertTableSQL(
        OPT_TYPELIB,
        NUMBER_OF_PARAM_TO_INSERT_TABLE_TYPELIB,
        MAKE_PCWSTR(*rg_typelib_AllowedAttributes[MSMGEN_TYPELIB_ATTRIBUTE_TLBID].m_value),
        MAKE_PCWSTR(curAsmInfo.m_sbComponentIdentifier),
        MAKE_PCWSTR(*rg_typelib_AllowedAttributes[MSMGEN_TYPELIB_ATTRIBUTE_VERSION].m_value),
        MAKE_PCWSTR(GUID_NULL_IN_STRING)));

Exit:
    return hr;
}

HRESULT InsertCabinetIntoMsm()
{    
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRec = NULL;

    CurrentAssemblyRealign;

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewA(g_MsmInfo.m_hdb, "INSERT INTO `_Streams` (`Name`, `Data`) VALUES (?, ?)", &hView));        
    
    hRec = ::MsiCreateRecord(2);
    if (NULL == hRec)
        SETFAIL_AND_EXIT;
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStringW(hRec, 1, MERGEMODULE_CABINET_FILENAME));    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStreamW(hRec, 2, g_MsmInfo.m_sbCabinet));
        
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRec));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewClose(hView));

Exit:    
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\msmgen\msmgen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msmgen.h

Abstract:

    header file for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

#define MAXDWORD    0xffffffff    
#include "stdinc.h"
#include "msiquery.h"

#define FUSION_GENMSM_ACTION_WRITE_TABLES       (0x00000001)
#define FUSION_GENMSM_ACTION_WRITE_CABITNET     (0x00000002)

#define COMPONENT_TABLE                         (0x00000001)
#define DIRECTORY_TABLE                         (0x00000002)
#define FEATURECOMPONENTS_TABLE                 (0x00000004)
#define FILE_TABLE                              (0x00000008)
#define MODULESIGNATURE_TABLE                   (0x00000010)
#define MODULECOMPONENTS_TABLE                  (0x00000020)
#define MSIASSEMLBY_TABLE                       (0x00000040)
#define MSIASSEMLBYNAME_TABLE                   (0x00000080)

#define MERGEMODULE_CABINET_FILENAME    L"MergeModule.CABinet"
#define SYSTEM_FOLDER                   L"SystemFolder"
#define MSM_TEMPLATE_BARN               L"%ProgramFiles%\\msmgen\\templates\\msmgen"
#define MSMGEN_MSM_TEMPLATE             L"%ProgramFiles%\\msmgen\\templates\\msmgen.msm"
#define MSM_TEMP_CABIN_FILE             "%Temp%\\msm_temp_cabinet.tmp"
#define MSM_TEMP_CABIN_DIRECTORY_A      "%Temp%\\msm_temp_cabinet_dir\\"
#define MSM_TEMP_CABIN_DIRECTORY_W      L"%Temp%\\msm_temp_cabinet_dir\\"

#define MSIGUIDSTR_WITH_PREPEND_DOT     1

// {BA0505B5-9044-4919-A2DD-7D71EA8F8306}
#include "objbase.h"
DEFINE_GUID(MSM_GUID, 
    0xba0505b5, 0x9044, 0x4919, 0xa2, 0xdd, 0x7d, 0x71, 0xea, 0x8f, 0x83, 0x6);

typedef struct _ASSEMBLY_INFO_
{ 
    CStringBuffer           m_sbAssemblyPath;           // always has a trailing slash
    CSmallStringBuffer      m_sbManifestFileName;
    CSmallStringBuffer      m_sbCatalogFileName;
    CSmallStringBuffer      m_sbLangID;                 // defualt value is 0 - netural language id

    DWORD                   m_CchAssemblyPath; 
    DWORD                   m_CchManifestFileName;
    DWORD                   m_CchCatalogFileName;

    CSmallStringBuffer      m_sbComponentID;            // guid for the assembly, if not specified, gennerate a new guid
    CSmallStringBuffer      m_sbComponentIdentifier;    // begin with AssemblyName, appended with .m_sbModuleGuidStr
    BOOL                    m_fComponentTableSet;
}ASSEMBLY_INFO;

enum MSMGEN_MODE
{
    MSMGEN_OPR_NEW,
    MSMGEN_OPR_REGEN,
    MSMGEN_OPR_ADD
};

#include "fci.h"
#include "msi.h"

typedef struct _MSM_INFO
{
    GUID                    m_guidModuleID;
    CSmallStringBuffer      m_sbModuleGuidStr;          // prepend a "." before the numbers, since it is always used to append
    HFCI                    m_hfci;                     // init to be NULL and finally call FCIDestory to destroy it
    CSmallStringBuffer      m_sbMsmFileName;            // full-qualified path, default value is the same name as manifest with .msm    
    PMSIHANDLE              m_hdb;                      // database handle for msm file, init as NULL
    CSmallStringBuffer      m_sbModuleIdentifier;   
    SHORT                   m_sLanguageID;              // get this from AssemblyIdentity, if it is not specified, use the default value    
    MSMGEN_MODE             m_enumGenMode;   
    CSmallStringBuffer      m_sbCabinet;                // fullpath of cabinet file
    CStringBuffer           m_sbMsmTemplateFile;
}MSM_INFO;

typedef HRESULT (*PFN_MSM_GEN_WORKER)(IXMLDOMNode*  node);
typedef struct _MSM_DOMNODE_WORKER_
{
    PCWSTR              pwszNodeName; 
    PFN_MSM_GEN_WORKER  pfn;
}MSM_DOMNODE_WORKER;

typedef HRESULT (__stdcall * PMSMGEN_ATTRIBUTE_CALLBACK_FUNC_PTR)(PCWSTR, PCWSTR);

typedef struct _ELEMENT_ALLOWED_ATTRIBUTE_{
    PCWSTR                              m_name;   
    BOOL                                m_fRequired;    
    PMSMGEN_ATTRIBUTE_CALLBACK_FUNC_PTR m_callbackFunc;
    BOOL                                m_fValued;
    CSmallStringBuffer                  *m_value;
}ELEMENT_ALLOWED_ATTRIBUTE;

//
// extern variables
//
extern ASSEMBLY_INFO curAsmInfo;
extern MSM_INFO g_MsmInfo;

//
// extern functions
//
extern HRESULT PrepareMsmOutputFiles(PCWSTR);
extern HRESULT InitializeCabinetForWrite();
extern HRESULT AddFileToCabinetW(PCWSTR, SIZE_T, PCWSTR, SIZE_T);
extern HRESULT AddFileToCabinetA(PCSTR, SIZE_T, PCSTR, SIZE_T);
extern HRESULT EndMsmGeneration();
extern HRESULT OpenMsmFileForMsmGen(PCWSTR);
extern HRESULT GetMsiGUIDStrFromGUID(DWORD, GUID &, CSmallStringBuffer &);
extern HRESULT ExecuteQuerySQL(PCWSTR, PCWSTR, PCWSTR, BOOL &, MSIHANDLE *);
extern HRESULT ExecuteUpdateSQL(PCWSTR, PCWSTR, PCWSTR, PCWSTR, PCWSTR);
extern HRESULT ExecuteInsertTableSQL(DWORD, UINT, ...);
extern HRESULT SetModuleID();
extern HRESULT PrepareMsm();
extern HRESULT SetComponentId(PCWSTR, PCWSTR);
extern HRESULT CloseCabinet();
extern HRESULT InsertCabinetIntoMsm();
extern HRESULT MoveFilesInCabinetA(char * sourceCabinet);
extern HRESULT CheckComponentTable();

//
// constant
//
#define OPT_DIRECTORY                                           0
#define OPT_COMPONENT                                           1
#define OPT_FILE                                                2
#define OPT_MSIASSEMBLY                                         3
#define OPT_MSIASSEMBLYNAME                                     4
#define OPT_MODULESIGNATURE                                     5
#define OPT_MODULECOMPONENTS                                    6
#define OPT_PROPERTY                                            7
#define OPT_PROGID                                              8
#define OPT_CLASS                                               9
#define OPT_TYPELIB                                             10

#define NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY               3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT               4
// the acutal parameter-number for FILE_TABLE is 4 not 3,
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE                    3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLY             3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLYNAME         3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULESIGNATURE         2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULECOMPONENTS        2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_PROPERTY                2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_PROGID                  3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_CLASS                   5
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_TYPELIB                 4

#define CATALOG_FILE_EXT                    L"cat"
#define MSM_FILE_EXT                        L"msm"

#define MSM_TEMPLATE 1
#define MSI_TEMPLATE 2

#define MSMGEN_COMCLASS_ATTRIBUTE_CLSID                             0
#define MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION                       1
#define MSMGEN_COMCLASS_ATTRIBUTE_PROGID                            2
#define MSMGEN_COMCLASS_ATTRIBUTE_TLBID                             3
#define MSMGEN_COMCLASS_ATTRIBUTE_THREADINGMODULE                   4

#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_NAME                      0
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_LANGUAGE                  1
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_VERSION                   2
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_PROCESSORARCHITECTURE     3
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_PUBLICKEYTOKEN            4
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_TYPE                      5

#define MSMGEN_TYPELIB_ATTRIBUTE_TLBID                              0 
#define MSMGEN_TYPELIB_ATTRIBUTE_VERSION                            1 
#define MSMGEN_TYPELIB_ATTRIBUTE_HELPDIR                            2 

#define GUID_NULL_IN_STRING L"{00000000-0000-0000-0000-000000000000}"


//
// macro
//
#define WIN32_FUNC_END do {fSuccess = TRUE; Exit: return fSuccess;} while (0)
#define HRCOM_FUNC_END do {hr = S_OK; Exit: return hr;} while (0);
#define IDT_EXT     L".idt"

#define DEFINE_ATTRIBUTE_MSM_INTERESTED(attributeName) \
    { \
        L ## #attributeName, \
        &MSM_PARSER_DOM_NODE_ ## attributeName \
    }

#define DECLARE_FUNCTION(attributeName) \
    HRESULT MSM_PARSER_DOM_NODE ## attributeName (IXMLDOMNode*  node)


#define IFFALSE__MARKERROR_EXIT(x) if (!(x)) { hr = E_FAIL; goto Exit; }

#define CurrentAssemblyReset\
    do \
    { \
        if (curAsmInfo.m_CchAssemblyPath != 0) \
        { \
            curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath); \
            curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName); \
            curAsmInfo.m_sbCatalogFileName.Left(curAsmInfo.m_CchCatalogFileName); \
        } \
    } while (0)


#define MAKE_PCWSTR(x) PCWSTR(x)

#include "macros.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\stdinc.h ===
#ifndef FUSION_MSI_INC_STDINC_H
#define FUSION_MSI_INC_STDINC_H

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include "fusionlastwin32error.h"
#include "fusionbuffer.h"

#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>

#define UNICODE
#define _UNICODE
#include "yvals.h"
#pragma warning(disable:4127)
#pragma warning(disable:4663)
#pragma warning(disable:4100)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4018) /* signed/unsigned mismatch */
#pragma warning(disable:4786) /* long symbols */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion from size_t to int */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\popcopy\stdinc.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\macros.h ===
#ifndef FUSION_MSI_CA_INC_MACROS_H
#define FUSION_MSI_CA_INC_MACROS_H

#define SETFAIL_AND_EXIT  do { hr = E_FAIL; goto Exit;} while (0);

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof(x[0]))
#endif

#define SAFE_RELEASE_COMPOINTER(x) do {if (x != NULL) x->Release();} while(0)

extern void Msmgen_TracingFunctionFailure(PWSTR x, PSTR func, DWORD line);
#define IFFALSE_EXIT(x)     do {if (!(x)) {Msmgen_TracingFunctionFailure(L ## # x, __FUNCTION__, __LINE__); hr = HRESULT_FROM_WIN32(::GetLastError()); goto Exit;}} while(0)
#define IFFAILED_EXIT(x)    do {if ((hr = (x)) != ERROR_SUCCESS) { Msmgen_TracingFunctionFailure(L ## # x, __FUNCTION__, __LINE__); goto Exit;}} while(0)
#define IF_NOTSUCCESS_SET_HRERR_EXIT(x) do {UINT __t ; __t = (x); if (__t != ERROR_SUCCESS) {hr = HRESULT_FROM_WIN32(__t); goto Exit;}} while(0)
#define SET_HRERR_AND_EXIT(err) do { hr = HRESULT_FROM_WIN32(err); goto Exit;} while (0)

#define PARAMETER_CHECK_NTC(x) do { if (!(x)) { hr = E_INVALIDARG; goto Exit;}} while (0) 

#define INTERNAL_ERROR_CHECK_NTC(x) do { if (!(x)) { hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); goto Exit;}} while (0) 



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\msmfci.h ===
#include "stdinc.h"

#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>

int get_percentage(unsigned long a, unsigned long b);

/*
    In a merge module, there can only be one CAB file, and its name must be 'MergeModule.CABinet'
    Every call to this function must fail if iCab!=1
*/
#define CABINET_NUMBER      1


/*
 * When a CAB file reaches this size, a new CAB will be created
 * automatically.  This is useful for fitting CAB files onto disks.
 *
 * If you want to create just one huge CAB file with everything in
 * it, change this to a very very large number.
 */
#define MEDIA_SIZE			(LONG_MAX)

/*
 * When a folder has this much compressed data inside it,
 * automatically flush the folder.
 *
 * Flushing the folder hurts compression a little bit, but
 * helps random access significantly.
 */
#define FOLDER_THRESHOLD	(LONG_MAX)


/*
 * Compression type to use
 */

#define COMPRESSION_TYPE    tcompTYPE_MSZIP


/*
 * Our internal state
 *
 * The FCI APIs allow us to pass back a state pointer of our own
 */
typedef struct
{
    ULONG    total_compressed_size;      /* total compressed size so far */
	ULONG	total_uncompressed_size;	/* total uncompressed size so far */
} client_state;


//
// helper functions for FCI
//

/*
 * Memory allocation function
 */
FNFCIALLOC(fci_mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFCIFREE(fci_mem_free)
{
	free(memory);
}


/*
 * File i/o functions
 */
FNFCIOPEN(fci_open)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIREAD(fci_read)
{
    unsigned int result;

    result = (unsigned int)_read((int)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCIWRITE(fci_write)
{
    unsigned int result;

    result = (unsigned int) _write((int)hf, memory, (INT)cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCICLOSE(fci_close)
{
    int result;

    result = _close((int)hf);

    if (result != 0)
        *err = errno;

    return result;
}

FNFCISEEK(fci_seek)
{
    long result;

    result = _lseek((int)hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIDELETE(fci_delete)
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
FNFCIFILEPLACED(file_placed)
{
	return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
FNFCISTATUS(progress)
{
	client_state	*cs;

	cs = (client_state *) pv;

	if (typeStatus == statusFile)
	{
        /*
        cs->total_compressed_size += cb1;
		cs->total_uncompressed_size += cb2;
        */
		/*
		 * Compressing a block into a folder
		 *
		 * cb2 = uncompressed size of block
		 */       
	}
	else if (typeStatus == statusFolder)
	{
		int	percentage;

		/*
		 * Adding a folder to a cabinet
		 *
		 * cb1 = amount of folder copied to cabinet so far
		 * cb2 = total size of folder
		 */
		percentage = get_percentage(cb1, cb2);

	}

	return 0;
}


FNFCIGETNEXTCABINET(get_next_cabinet)
{
    if (pccab->iCab != CABINET_NUMBER)
    {
        return -1;
    }

	/*
	 * Cabinet counter has been incremented already by FCI
	 */

	/*
	 * Store next cabinet name
	 */
    WideCharToMultiByte(
        CP_ACP, 0, MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1 ,         
        pccab->szCab, sizeof(pccab->szCab), NULL, NULL);
	
	/*
	 * You could change the disk name here too, if you wanted
	 */

	return TRUE;
}


FNFCIGETOPENINFO(get_open_info)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle = INVALID_HANDLE_VALUE;
    DWORD                       attrs;
    INT_PTR                     hf;

    /*
     * Need a Win32 type handle to get file date/time
     * using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with
     * _open
     */
	handle = CreateFileA(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);
   
	if (handle == INVALID_HANDLE_VALUE)
	{
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
		CloseHandle(handle);
		return -1;
	}
   
	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime, 
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

    attrs = GetFileAttributesA(pszName);

    if (attrs == 0xFFFFFFFF)
    {
        /* failure */
        *pattribs = 0;
    }
    else
    {
        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *pattribs = (USHORT) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }

    CloseHandle(handle);


    /*
     * Return handle using _open
     */
	hf = _open( pszName, _O_RDONLY | _O_BINARY );

	if (hf == -1)
		return -1; // abort on error
   
	return hf;
}


void set_cab_parameters(PCCAB cab_parms)
{
	memset(cab_parms, 0, sizeof(CCAB));

	cab_parms->cb = MEDIA_SIZE;
	cab_parms->cbFolderThresh = FOLDER_THRESHOLD;

	/*
	 * Don't reserve space for any extensions
	 */
	cab_parms->cbReserveCFHeader = 0;
	cab_parms->cbReserveCFFolder = 0;
	cab_parms->cbReserveCFData   = 0;

	/*
	 * We use this to create the cabinet name
	 */
	cab_parms->iCab = CABINET_NUMBER;

	/*
	 * If you want to use disk names, use this to
	 * count disks
	 */
	cab_parms->iDisk = 0;

	/*
	 * Choose your own number
	 */
	cab_parms->setID = 1965;

	/*
	 * Only important if CABs are spanning multiple
	 * disks, in which case you will want to use a
	 * real disk name.
	 *
	 * Can be left as an empty string.
	 */
	strcpy(cab_parms->szDisk, "win32.fusion.tools");

	/* where to store the created CAB files */
    CSmallStringBuffer buf; 

    if (! buf.Win32Assign(g_MsmInfo.m_sbCabinet))
    {
        fprintf(stderr, "error happened in set_cab_parameters");
        goto Exit; // void function
    }

    if (!buf.Win32RemoveLastPathElement())
    {
        goto Exit;
    }
    
    if ( ! buf.Win32EnsureTrailingPathSeparator())
    {
        fprintf(stderr, "error happened in set_cab_parameters");
        goto Exit; // void function
    }


    WideCharToMultiByte(
        CP_ACP, 0, buf, buf.GetCchAsDWORD(), 
        cab_parms->szCabPath, sizeof(cab_parms->szCabPath), NULL, NULL);

	/* store name of first CAB file */	
    WideCharToMultiByte(
        CP_ACP, 0, MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1 ,         
        cab_parms->szCab, sizeof(cab_parms->szCab), NULL, NULL);
Exit:
    return;
}

int get_percentage(unsigned long a, unsigned long b)
{
	while (a > 10000000)
	{
		a >>= 3;
		b >>= 3;
	}

	if (b == 0)
		return 0;

	return ((a*100)/b);
}


char *return_fci_error_string(int err)
{
	switch (err)
	{
		case FCIERR_NONE:
			return "No error";

		case FCIERR_OPEN_SRC:
			return "Failure opening file to be stored in cabinet";
		
		case FCIERR_READ_SRC:
			return "Failure reading file to be stored in cabinet";
		
		case FCIERR_ALLOC_FAIL:
			return "Insufficient memory in FCI";

		case FCIERR_TEMP_FILE:
			return "Could not create a temporary file";

		case FCIERR_BAD_COMPR_TYPE:
			return "Unknown compression type";

		case FCIERR_CAB_FILE:
			return "Could not create cabinet file";

		case FCIERR_USER_ABORT:
			return "Client requested abort";

		case FCIERR_MCI_FAIL:
			return "Failure compressing data";

		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\objtool\objtool.c ===
/*
This
    is a place to hang .obj file munging
    currently it only offers the ability to do simple renaming of symbol
        names .obj files. It cannot lengthen symbol names.

 Jay Krell
 December 19, 2001
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "windows.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#define GetStdout() stdout
#define GetStdin()  stdin
#define GetStderr() stderr

void Usage(char * argv0)
{
    char * upper;
    char * argv0base1;
    char * argv0base2;
    char * argv0base;

    argv0base1 = strrchr(argv0, '\\');
    argv0base2 = strrchr(argv0, '/');
    argv0base = (argv0base1 > argv0base2) ? argv0base1 : argv0base2;
    argv0base += (*argv0base == '\\' || *argv0base == '/');

    upper = _strdup(argv0base);
    if (upper != NULL)
        _strupr(upper);
    else
        upper = argv0;
    printf(
        "%s: usage: %s SymbolRename Objfile From To\n"
        "%s:\n"
        "%s: To must not be longer than From\n",
        upper, argv0, upper, upper, upper
        );
    if (upper != argv0)
        free(upper);
}

BOOL MyIsHandleValid(HANDLE Handle)
{
    return (Handle != NULL && Handle != INVALID_HANDLE_VALUE);
}

void MyFindClose(HANDLE * Handle)
{
    HANDLE Local;
    
    Local = *Handle;
    *Handle = NULL;
    if (MyIsHandleValid(Local))
        FindClose(Local);
}

void MyUnmapViewOfFile(HANDLE * Handle)
{
    HANDLE Local;
    
    Local = *Handle;
    *Handle = NULL;
    if (MyIsHandleValid(Local))
        UnmapViewOfFile(Local);
}

void
__cdecl
Error(
      const char * Format,
      ...
      )
{
    va_list Args;

    va_start(Args, Format);
    vfprintf(GetStderr(), Format, Args);
    va_end(Args);
}

#define Warning Error

void MyCloseHandle(HANDLE * Handle)
{
    HANDLE Local;
    
    Local = *Handle;
    *Handle = NULL;
    if (MyIsHandleValid(Local))
        CloseHandle(Local);
}

typedef struct _OBJFILE {
    PCSTR               FileName;
    HANDLE              FileHandle;
    HANDLE              FileMappingHandle;
    PVOID               VoidViewBase;
    PBYTE               ByteViewBase;
    PIMAGE_FILE_HEADER  ImageFileHeader;
    ULONG               Machine;
    BOOL                IsMachineKnown;
    ULONG               FileOffsetToSymbolTable;
    PIMAGE_SYMBOL       SymbolTable;
    ULONG               NumberOfSymbols;
    PSTR                StringTable;
    ULONG               StringTableSize;
} OBJFILE, *POBJFILE;


BOOL
ObjfileIsMachineKnown(
    ULONG Machine
    )
{
    switch (Machine)
    {
    default:
        return FALSE;
    case IMAGE_FILE_MACHINE_UNKNOWN:
    case IMAGE_FILE_MACHINE_I386:
    case IMAGE_FILE_MACHINE_R3000:
    case IMAGE_FILE_MACHINE_R4000:
    case IMAGE_FILE_MACHINE_R10000:
    case IMAGE_FILE_MACHINE_WCEMIPSV2:
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_SH3:
    case IMAGE_FILE_MACHINE_SH3DSP:
    case IMAGE_FILE_MACHINE_SH3E:
    case IMAGE_FILE_MACHINE_SH4:
    case IMAGE_FILE_MACHINE_SH5:
    case IMAGE_FILE_MACHINE_ARM:
    case IMAGE_FILE_MACHINE_THUMB:
    case IMAGE_FILE_MACHINE_AM33:
    case IMAGE_FILE_MACHINE_POWERPC:
    case IMAGE_FILE_MACHINE_POWERPCFP:
    case IMAGE_FILE_MACHINE_IA64:
    case IMAGE_FILE_MACHINE_MIPS16:
    case IMAGE_FILE_MACHINE_ALPHA64:
    case IMAGE_FILE_MACHINE_MIPSFPU:
    case IMAGE_FILE_MACHINE_MIPSFPU16:
    //case IMAGE_FILE_MACHINE_AXP64:
    case IMAGE_FILE_MACHINE_TRICORE:
    case IMAGE_FILE_MACHINE_CEF:
    case IMAGE_FILE_MACHINE_EBC:
    case IMAGE_FILE_MACHINE_AMD64:
    case IMAGE_FILE_MACHINE_M32R:
    case IMAGE_FILE_MACHINE_CEE:
        return TRUE;
    }
}

BOOL CloseObjfile(POBJFILE Objfile)
{
    BOOL Success = FALSE;

    if (!Objfile)
        goto Exit;

    Objfile->FileName;
    MyCloseHandle(&Objfile->FileHandle);
    MyCloseHandle(&Objfile->FileMappingHandle);
    MyUnmapViewOfFile(&Objfile->VoidViewBase);
    ZeroMemory(Objfile, sizeof(*Objfile));

    Success = TRUE;
Exit:
    return Success;
}

BOOL OpenObjfile(PCSTR FileName, POBJFILE Objfile)
{
    const static char Function[] = __FUNCTION__;
    ULONG LastWin32Error;
    BOOL Success = FALSE;

    if (!FileName)
        goto Exit;
    if (!Objfile)
        goto Exit;

    Objfile->FileName = FileName;
        
    Objfile->FileHandle = CreateFile(
        FileName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (!MyIsHandleValid(Objfile->FileHandle))
    {
        LastWin32Error = GetLastError();
        Error("%s: CreateFile(%s, GENERIC_WRITE, OPEN_EXISTING) 0x%lx\n", Function, FileName, LastWin32Error);
        goto Exit;
    }
    Objfile->FileMappingHandle = CreateFileMapping(
        Objfile->FileHandle, NULL, PAGE_READWRITE, 0, 0, NULL);
    if (!MyIsHandleValid(Objfile->FileMappingHandle))
    {
        LastWin32Error = GetLastError();
        Error("%s: CreateFileMapping(%s) 0x%lx\n", Function, FileName, LastWin32Error);
        goto Exit;
    }
    Objfile->VoidViewBase = MapViewOfFile(Objfile->FileMappingHandle, FILE_MAP_WRITE, 0, 0, 0);
    Objfile->ByteViewBase = (PBYTE)Objfile->VoidViewBase;
    if (!MyIsHandleValid(Objfile->VoidViewBase))
    {
        LastWin32Error = GetLastError();
        Error("%s MapViewOfFile(%s) 0x%lx\n", Function, FileName, LastWin32Error);
        goto Exit;
    }
    Objfile->ImageFileHeader = (PIMAGE_FILE_HEADER)Objfile->VoidViewBase;
    Objfile->Machine = Objfile->ImageFileHeader->Machine;
    Objfile->IsMachineKnown = ObjfileIsMachineKnown(Objfile->Machine);
    if (!Objfile->IsMachineKnown)
    {
        Warning("%s: Unknown machine 0x%lx, processing file anyway..\n", Function, Objfile->Machine);
    }
    else if (Objfile->Machine == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        Error("%s: 'anon' .obj file ignored\n", Function);
        goto Exit;
    }
    Objfile->FileOffsetToSymbolTable = Objfile->ImageFileHeader->PointerToSymbolTable;
    Objfile->NumberOfSymbols = Objfile->ImageFileHeader->NumberOfSymbols;
    if (Objfile->FileOffsetToSymbolTable == 0)
    {
        Error("%s: file %s, PointerToSymbolTable == 0, no symbols, ignoring\n", Function, FileName);
        goto Exit;
    }
    if (Objfile->NumberOfSymbols == 0)
    {
        Error("%s: file %s, NumberOfSymbols == 0, no symbols, ignoring\n", Function, FileName);
        goto Exit;
    }
    Objfile->SymbolTable = (PIMAGE_SYMBOL)(Objfile->ByteViewBase + Objfile->FileOffsetToSymbolTable);
    Objfile->StringTable = (PSTR)(Objfile->SymbolTable + Objfile->NumberOfSymbols);
    Objfile->StringTableSize = *(PULONG)Objfile->StringTable;
    Success = TRUE;
Exit:
    if (!Success)
    {
        CloseObjfile(Objfile);
    }
    return Success;
}

typedef struct _OBJFILE_SYMBOL {
    ULONG           Index;
    PIMAGE_SYMBOL   ImageSymbol;
    PSTR            Name; /* never NULL */
    size_t          NameLength;
    BOOL            IsShort;
    ULONG UNALIGNED * PointerToOffsetToLongName;  /* may be 0 */
    ULONG           OffsetToLongName;           /* may be 0 */
    PSTR            PointerToLongNameStorage;   /* may be NULL */
    PSTR            PointerToShortNameStorage;  /* never NULL */
} OBJFILE_SYMBOL, *POBJFILE_SYMBOL;

BOOL
ObjfileResolveSymbol(
    POBJFILE    Objfile,
    ULONG       Index,
    POBJFILE_SYMBOL OutSymbol
    )
{
    const static char Function[] = __FUNCTION__;
    BOOL Success = FALSE;
    OBJFILE_SYMBOL Symbol = { 0 };

    if (!Objfile)
        goto Exit;
    if (!OutSymbol)
        goto Exit;

    *OutSymbol = Symbol;

    if (Index >= Objfile->NumberOfSymbols)
    {
        Warning("%s: file %s, SymbolIndex >= NumberOfSymbols (0x%lx, 0x%lx)\n",
                Function,
                Objfile->FileName,
                Index,
                Objfile->NumberOfSymbols
                );
        goto Exit;
    }

    Symbol.Index = Index;
    Symbol.ImageSymbol = &Objfile->SymbolTable[Index];
    Symbol.PointerToShortNameStorage = (PSTR)Symbol.ImageSymbol->N.ShortName;
    if (Symbol.ImageSymbol->N.Name.Short)
    {
        for (   ;
                Symbol.NameLength != IMAGE_SIZEOF_SHORT_NAME ;
                ++Symbol.NameLength
            )
        {
            if (Symbol.PointerToShortNameStorage[Symbol.NameLength] == 0)
                break;
        }
        Symbol.Name = Symbol.PointerToShortNameStorage;
        Symbol.IsShort = TRUE;
    }
    else
    {
        Symbol.PointerToOffsetToLongName = &Symbol.ImageSymbol->N.Name.Long;
        Symbol.OffsetToLongName = *Symbol.PointerToOffsetToLongName;
        if (Symbol.OffsetToLongName >= Objfile->StringTableSize)
        {
            Warning("%s: file %s, OffsetToLongName >= StringTableSize (0x%lx, 0x%lx)\n",
                    Function,
                    Objfile->FileName,
                    Symbol.OffsetToLongName,
                    Objfile->StringTableSize
                    );
            goto Exit;
        }
        Symbol.Name = (Objfile->StringTable + Symbol.OffsetToLongName);
        Symbol.PointerToLongNameStorage = Symbol.Name;
        Symbol.NameLength = strlen(Symbol.Name);
    }
    *OutSymbol = Symbol;
    Success = TRUE;
Exit:
    return Success;
}

BOOL
ObjfileSetSymbolName(
    POBJFILE        Objfile,
    POBJFILE_SYMBOL Symbol,
    PCSTR           NewSymbolName
    )
{
    const static char Function[] = __FUNCTION__;
    PIMAGE_SYMBOL ImageSymbol;
    size_t i;
    BOOL Success = FALSE;

    if (!Objfile)
        goto Exit;
    if (!Symbol)
        goto Exit;
    if (!NewSymbolName)
        goto Exit;

    ImageSymbol = Symbol->ImageSymbol;
    i = strlen(NewSymbolName);
    if (i <= IMAGE_SIZEOF_SHORT_NAME)
    {
        //
        // we abandon the string table entry if there was one.
        //
        memmove(Symbol->PointerToShortNameStorage, NewSymbolName, i);
        ZeroMemory(Symbol->PointerToShortNameStorage + i, IMAGE_SIZEOF_SHORT_NAME - i);
    }
    else if (!Symbol->IsShort && i <= Symbol->NameLength)
    {
        //
        // like
        //    \0\reallylonglonglong\0
        // -> \0\lesslonglong\0long\0
        //
        memmove(Symbol->PointerToLongNameStorage, NewSymbolName, i);
        Symbol->PointerToLongNameStorage[i] = 0;
    }
    else
    {
        Warning("%s: objfile %s, new symbol does not fit over old symbol (%s, %*s)\n",
                Function,
                Objfile->FileName,
                NewSymbolName,
                (int)Symbol->NameLength,
                Symbol->Name
                );
        goto Exit;
    }
    Success = TRUE;
Exit:
    return Success;
}

BOOL
SymbolRename(
    PCSTR   ObjfileName,
    PCSTR   From,
    PCSTR   To,
    PULONG  NumberFound
    )
{
    const static char Function[] = __FUNCTION__;
    OBJFILE Objfile = { 0 };
    ULONG   SymbolIndex;
    OBJFILE_SYMBOL Symbol = { 0 };
    size_t FromLength;
    BOOL Success = FALSE;

    if (NumberFound == NULL)
        goto Exit;

    *NumberFound = 0;

    if (!OpenObjfile(ObjfileName, &Objfile))
        goto Exit;

    FromLength = strlen(From);

    for (   SymbolIndex = 0 ;
            SymbolIndex != Objfile.NumberOfSymbols ;
            SymbolIndex += 1 + Symbol.ImageSymbol->NumberOfAuxSymbols
        )
    {
        if (!ObjfileResolveSymbol(&Objfile, SymbolIndex, &Symbol))
            goto Exit;
        if (FromLength == Symbol.NameLength
            && memcmp(From, Symbol.Name, FromLength) == 0)
        {
            if (*NumberFound != 0)
            {
                Warning("%s: objfile %s, multiple symbols with same name found (%s)\n",
                    Function,
                    Objfile.FileName,
                    From
                    );
            }

            *NumberFound += 1;

            if (!ObjfileSetSymbolName(&Objfile, &Symbol, To))
                goto Exit;

        }
    }
    Success = TRUE;
Exit:
    CloseObjfile(&Objfile);
    return Success;
}

void Objtool(int argc, char ** argv)
{
    const static char Function[] = __FUNCTION__;
    PCSTR From;
    PCSTR To;
    PCSTR ObjfileName;
    ULONG NumberFound = 0;
    int i;
    const char * symren[] = 
        { "symren", "symrename", "symbolrename", "symbolren" };

    if (argc < 2)
    {
        Usage(argv[0]);
        return;
    }

    argv[1] += (argv[1][0] == '-' || argv[1][0] == '/');
    for (i = 0 ; i != NUMBER_OF(symren) ; ++i)
    {
        if (_stricmp(argv[1], symren[i]) ==  0)
        {
            if (
                   (ObjfileName = argv[2]) == NULL
                || (From = argv[3]) == NULL
                || (To = argv[4]) == NULL
                || strlen(To) > strlen(From)
                )
            {
                Usage(argv[0]);
                return;
            }
            SymbolRename(ObjfileName, From, To, &NumberFound);
            return;
        }
    }
    Usage(argv[0]);
}

int __cdecl main(int argc, char ** argv)
{
	Objtool(argc, argv);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

MAJORCOMP=fusion
MINORCOMP=msmgen

TARGETNAME=msmgen
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_MSVCRT=1
USE_STL=1
USE_NATIVE_EH=1

INCLUDES= \
 $(FUSION_INC_PATH);\
 $(INCLUDES);\
 $(COM_INC_PATH);

UMTYPE=console
UMENTRY=wmain

SOURCES= \
 ..\msmgen.cpp \
 ..\db.cpp \
 ..\cabinet.cpp 

TARGETLIBS= \
 $(FUSION_PATH)\$(O)\win32simplelock.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)utils.lib \
 $(SDK_LIB_PATH)\msvcrt.lib \
 $(SDK_LIB_PATH)\ntdll.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\cabinet.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\msxml2.lib \
 $(SDK_LIB_PATH)\msi.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\msmgen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msmgen.h

Abstract:

    header file for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

#define MAXDWORD    0xffffffff    
#include "stdinc.h"
#include <msiquery.h>

#define FUSION_GENMSM_ACTION_WRITE_TABLES       (0x00000001)
#define FUSION_GENMSM_ACTION_WRITE_CABITNET     (0x00000002)

#define COMPONENT_TABLE                         (0x00000001)
#define DIRECTORY_TABLE                         (0x00000002)
#define FEATURECOMPONENTS_TABLE                 (0x00000004)
#define FILE_TABLE                              (0x00000008)
#define MODULESIGNATURE_TABLE                   (0x00000010)
#define MODULECOMPONENTS_TABLE                  (0x00000020)
#define MSIASSEMLBY_TABLE                       (0x00000040)
#define MSIASSEMLBYNAME_TABLE                   (0x00000080)

#define MERGEMODULE_CABINET_FILENAME    L"MergeModule.CABinet"
#define SYSTEM_FOLDER                   L"SystemFolder"
#define MSM_TEMPLATE_BARN               L"%ProgramFiles%\\msmgen\\templates\\msmgen"
#define MSMGEN_MSM_TEMPLATE             L"%ProgramFiles%\\msmgen\\templates\\msmgen.msm"
#define MSM_TEMP_CABIN_FILE             "%Temp%\\msm_temp_cabinet.tmp"
#define MSM_TEMP_CABIN_DIRECTORY_A      "%Temp%\\msm_temp_cabinet_dir\\"
#define MSM_TEMP_CABIN_DIRECTORY_W      L"%Temp%\\msm_temp_cabinet_dir\\"

#define MSIGUIDSTR_WITH_PREPEND_DOT     1

// {BA0505B5-9044-4919-A2DD-7D71EA8F8306}
#include "objbase.h"
DEFINE_GUID(MSM_GUID, 
    0xba0505b5, 0x9044, 0x4919, 0xa2, 0xdd, 0x7d, 0x71, 0xea, 0x8f, 0x83, 0x6);

typedef struct _ASSEMBLY_INFO_
{ 
    CStringBuffer           m_sbAssemblyPath;           // always has a trailing slash
    CSmallStringBuffer      m_sbManifestFileName;
    CSmallStringBuffer      m_sbCatalogFileName;
    CSmallStringBuffer      m_sbLangID;                 // defualt value is 0 - netural language id

    DWORD                   m_CchAssemblyPath; 
    DWORD                   m_CchManifestFileName;
    DWORD                   m_CchCatalogFileName;

    CSmallStringBuffer      m_sbComponentID;            // guid for the assembly, if not specified, gennerate a new guid
    CSmallStringBuffer      m_sbComponentIdentifier;    // begin with AssemblyName, appended with .m_sbModuleGuidStr
    BOOL                    m_fComponentTableSet;
}ASSEMBLY_INFO;

#include "fci.h"
#include "msi.h"

typedef struct _MSM_INFO
{
    GUID                    m_guidModuleID;
    CSmallStringBuffer      m_sbModuleGuidStr;          // prepend a "." before the numbers, since it is always used to append
    HFCI                    m_hfci;                     // init to be NULL and finally call FCIDestory to destroy it
    CSmallStringBuffer      m_sbMsmFileName;            // full-qualified path, default value is the same name as manifest with .msm    
    PMSIHANDLE              m_hdb;                      // database handle for msm file, init as NULL
    CSmallStringBuffer      m_sbModuleIdentifier;   
    SHORT                   m_sLanguageID;              // get this from AssemblyIdentity, if it is not specified, use the default value    
    CSmallStringBuffer      m_sbCabinet;                // fullpath of cabinet file
    CStringBuffer           m_sbMsmTemplateFile;
}MSM_INFO;

typedef HRESULT (*PFN_MSM_GEN_WORKER)(IXMLDOMNode*  node);
typedef struct _MSM_DOMNODE_WORKER_
{
    PCWSTR              pwszNodeName; 
    PFN_MSM_GEN_WORKER  pfn;
}MSM_DOMNODE_WORKER;

typedef HRESULT (__stdcall * PMSMGEN_ATTRIBUTE_CALLBACK_FUNC_PTR)(PCWSTR, PCWSTR);

typedef struct _ELEMENT_ALLOWED_ATTRIBUTE_{
    PCWSTR                              m_name;   
    BOOL                                m_fRequired;    
    PMSMGEN_ATTRIBUTE_CALLBACK_FUNC_PTR m_callbackFunc;
    BOOL                                m_fValued;
    CSmallStringBuffer                  *m_value;
}ELEMENT_ALLOWED_ATTRIBUTE;

//
// extern variables
//
extern ASSEMBLY_INFO curAsmInfo;
extern MSM_INFO g_MsmInfo;

//
// extern functions
//
extern HRESULT PrepareMsmOutputFiles(PCWSTR);
extern HRESULT InitializeCabinetForWrite();
extern HRESULT AddFileToCabinetW(PCWSTR, SIZE_T, PCWSTR, SIZE_T);
extern HRESULT AddFileToCabinetA(PCSTR, SIZE_T, PCSTR, SIZE_T);
extern HRESULT EndMsmGeneration();
extern HRESULT OpenMsmFileForMsmGen(PCWSTR);
extern HRESULT GetMsiGUIDStrFromGUID(DWORD, GUID &, CSmallStringBuffer &);
extern HRESULT ExecuteQuerySQL(PCWSTR, PCWSTR, PCWSTR, BOOL &, MSIHANDLE *);
extern HRESULT ExecuteUpdateSQL(PCWSTR, PCWSTR, PCWSTR, PCWSTR, PCWSTR);
extern HRESULT ExecuteInsertTableSQL(DWORD, UINT, ...);
extern HRESULT SetModuleID();
extern HRESULT PrepareMsm();
extern HRESULT SetComponentId(PCWSTR, PCWSTR);
extern HRESULT CloseCabinet();
extern HRESULT InsertCabinetIntoMsm();
extern HRESULT MoveFilesInCabinetA(char * sourceCabinet);
extern HRESULT CheckComponentTable();

//
// constant
//
#define OPT_DIRECTORY                                           0
#define OPT_COMPONENT                                           1
#define OPT_FILE                                                2
#define OPT_MSIASSEMBLY                                         3
#define OPT_MSIASSEMBLYNAME                                     4
#define OPT_MODULESIGNATURE                                     5
#define OPT_MODULECOMPONENTS                                    6
#define OPT_PROPERTY                                            7
#define OPT_PROGID                                              8
#define OPT_CLASS                                               9
#define OPT_TYPELIB                                             10

#define NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY               3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT               4
// the acutal parameter-number for FILE_TABLE is 4 not 3,
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_FILE                    3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLY             3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MSIASSEMBLYNAME         3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULESIGNATURE         2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULECOMPONENTS        2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_PROPERTY                2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_PROGID                  3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_CLASS                   5
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_TYPELIB                 4

#define CATALOG_FILE_EXT                    L"cat"
#define MSM_FILE_EXT                        L"msm"

#define MSM_TEMPLATE 1
#define MSI_TEMPLATE 2

#define MSMGEN_COMCLASS_ATTRIBUTE_CLSID                             0
#define MSMGEN_COMCLASS_ATTRIBUTE_DESCRIPTION                       1
#define MSMGEN_COMCLASS_ATTRIBUTE_PROGID                            2
#define MSMGEN_COMCLASS_ATTRIBUTE_TLBID                             3
#define MSMGEN_COMCLASS_ATTRIBUTE_THREADINGMODULE                   4

#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_NAME                      0
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_LANGUAGE                  1
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_VERSION                   2
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_PROCESSORARCHITECTURE     3
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_PUBLICKEYTOKEN            4
#define MSMGEN_ASSEMBLYIDENTTIY_ATTRIBUTE_TYPE                      5

#define MSMGEN_TYPELIB_ATTRIBUTE_TLBID                              0 
#define MSMGEN_TYPELIB_ATTRIBUTE_VERSION                            1 
#define MSMGEN_TYPELIB_ATTRIBUTE_HELPDIR                            2 

#define GUID_NULL_IN_STRING L"{00000000-0000-0000-0000-000000000000}"


//
// macro
//
#define WIN32_FUNC_END do {fSuccess = TRUE; Exit: return fSuccess;} while (0)
#define HRCOM_FUNC_END do {hr = S_OK; Exit: return hr;} while (0);
#define IDT_EXT     L".idt"

#define DEFINE_ATTRIBUTE_MSM_INTERESTED(attributeName) \
    { \
        L ## #attributeName, \
        &MSM_PARSER_DOM_NODE_ ## attributeName \
    }

#define DECLARE_FUNCTION(attributeName) \
    HRESULT MSM_PARSER_DOM_NODE ## attributeName (IXMLDOMNode*  node)


#define IFFALSE__MARKERROR_EXIT(x) if (!(x)) { hr = E_FAIL; goto Exit; }

#define CurrentAssemblyRealign\
    do \
    { \
        if (curAsmInfo.m_CchAssemblyPath != 0) \
        { \
            curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath); \
            curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName); \
            curAsmInfo.m_sbCatalogFileName.Left(curAsmInfo.m_CchCatalogFileName); \
        } \
    } while (0)


#define MAKE_PCWSTR(x) PCWSTR(x)
#define ReportError printf

#include "macros.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\pragmaunsafe.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft Corporation. All rights reserved.
// PragmaUnsafe.cpp : Implementation of DLL Exports.
//

#include "stdafx.h"
#include "resource.h"

#include "PragmaUnsafeModule.h"
#include <pftDll.h>


/////////////////////////////////////////////////////////////////////////////
// Global Initialization

CComModule _Module;


/////////////////////////////////////////////////////////////////////////////
// Object Map
//
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PragmaUnsafeModule, CPragmaUnsafeModule)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Processes DLL exports
//
class CPragmaUnsafeDll :
    public PftDll<CPragmaUnsafeDll, IDR_PragmaUnsafe, &CATID_PREfastDefectModules>
{
// Overrides
public:
    // Uncomment any one of these to change the behavior of the base class
    // template. See <pftDll.h> for the exact default behavior for each
    // method.
    //
    // static bool OnDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pReserved);
    // static bool OnProcessAttach(HINSTANCE hInstance, bool fDynamic);
    // static void OnProcessDetach(HINSTANCE hInstance, bool fDynamic);
    // static void OnThreadAttach(HINSTANCE hInstance);
    // static void OnThreadDetach(HINSTANCE hInstance);
    // static bool OnDisableThreadLibraryCalls();
    // static HRESULT OnDllCanUnloadNow();
    // static HRESULT OnDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
    // static HRESULT OnDllRegisterServer();
    // static HRESULT OnDllUnregisterServer();
    // static HRESULT OnRegisterCategory();
};


/////////////////////////////////////////////////////////////////////////////
// DLL Exports
//
PFT_DECLARE_TypicalComDll(CPragmaUnsafeDll)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\newmsm\msmgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msmgen.cpp

Abstract:

    Main Function calls for msm generation

Author:

    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/

#include "msmgen.h"
#include "util.h"
#include "objbase.h"
#include "initguid.h"
#include "coguid.h"
#include "msidefs.h"

#include <string.h>

#define DEFAULT_MODULE_IDENTIFIER_PREFIX                            L"Module0"

#define MSMGEN_FROM_MANFILE         0
#define MSMGEN_FROM_MANLIST         1
#define MSMGEN_FROM_MANGROUP        2

extern void MsmToUpper(CBaseStringBuffer &);

//
// global variables
//
CStringBuffer g_sbTemplateFile;
ASSEMBLY_INFO   curAsmInfo;
MSM_INFO        g_MsmInfo;

//
// function declaration
//
DECLARE_FUNCTION(_file);
DECLARE_FUNCTION(_assemblyIdentity);
DECLARE_FUNCTION(_comClass);
DECLARE_FUNCTION(_typelib);

static MSM_DOMNODE_WORKER s_msm_worker[]={
    DEFINE_ATTRIBUTE_MSM_INTERESTED(file),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(assemblyIdentity),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(comClass),
    DEFINE_ATTRIBUTE_MSM_INTERESTED(typelib)
};

void PrintUsage()
{
    WCHAR filename[MAX_PATH];
    PWSTR exe = NULL;
    if (GetModuleFileNameW(NULL, filename, NUMBER_OF(filename)) > 0)    
    {
        exe = wcsrchr(filename, L'\\');        
        if (exe == NULL)
        {
            wcscpy(filename, L"msmgen exe ");
            exe = filename;
        }else 
            exe ++;
    }
    else 
    {
        wcscpy(filename, L"msmgen exe ");
        exe = filename;
    }

    fprintf(stderr, "Generate .msm for an assembly\n\n");
    fprintf(stderr, "%S manfile manifest_file.manifest [-compid {guid}] [-msmid {guid}] [-msm file.msm] [-template templatefile.msm]\n", exe);
    fprintf(stderr, "%S manlist manifest_list.txt [-msmid {guid}] [-msm file.msm] [-template templatefile.msm]\n", exe);
    fprintf(stderr, "%S mangroup manifest_group.txt [-template templatefile.msm]\n", exe);

    exit(0); 
}

VOID ZeroOutCurrentAssemblyInfo()
{
    curAsmInfo.m_sbAssemblyPath.Left(0);
    curAsmInfo.m_sbManifestFileName.Left(0);
    curAsmInfo.m_sbCatalogFileName.Left(0);
    curAsmInfo.m_CchAssemblyPath = 0; 
    curAsmInfo.m_CchManifestFileName = 0;
    curAsmInfo.m_CchCatalogFileName = 0; 

    curAsmInfo.m_sbComponentID.Left(0);

    curAsmInfo.m_sbLangID.Left(0);   
    curAsmInfo.m_sbComponentIdentifier.Left(0);    
    curAsmInfo.m_fComponentTableSet = FALSE;
}

VOID ZeroOutMsmInfo()
{
    g_MsmInfo.m_guidModuleID = GUID_NULL;
    g_MsmInfo.m_sbModuleGuidStr.Left(0);
    g_MsmInfo.m_hfci = NULL;
    g_MsmInfo.m_sbMsmFileName.Left(0);
    g_MsmInfo.m_hdb = NULL;
    g_MsmInfo.m_sbModuleIdentifier.Left(0);
    g_MsmInfo.m_sLanguageID = 0;    
    g_MsmInfo.m_sbCabinet.Left(0);

    //g_MsmInfo.m_sbMsmTemplateFile.Left(0);
}

HRESULT ValidateCurrentMsmInfo()
{
    HRESULT hr = S_OK;
    INTERNAL_ERROR_CHECK_NTC(g_MsmInfo.m_sbMsmFileName.Cch() != 0); 
    INTERNAL_ERROR_CHECK_NTC(g_MsmInfo.m_sbMsmTemplateFile.Cch() != 0); 

    INTERNAL_ERROR_CHECK_NTC(g_MsmInfo.m_guidModuleID != GUID_NULL);
    INTERNAL_ERROR_CHECK_NTC(g_MsmInfo.m_sbModuleGuidStr.Cch() != 0);    
    
    hr = S_OK;
Exit:
    return hr;
}

HRESULT LoadManifestToDOMDocument(IXMLDOMDocument  *pDoc)
{
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr = S_OK;
    BSTR            bstr = NULL;

    CurrentAssemblyRealign;

    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(curAsmInfo.m_sbManifestFileName));
    bstr = SysAllocString(curAsmInfo.m_sbAssemblyPath);

    IFFAILED_EXIT(pDoc->put_async(VARIANT_FALSE));

    // Load xml document from the given URL or file path
    VariantInit(&vURL);
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = bstr;
    IFFAILED_EXIT(pDoc->load(vURL, &vb));

Exit:
    SysFreeString(bstr);    
    return hr;
}

HRESULT PopulateDOMNode(IXMLDOMNode * node)
{
    HRESULT hr = S_OK;
    BSTR nodeName = NULL;
    DOMNodeType nodetype;

    IFFAILED_EXIT(node->get_nodeType(&nodetype));
    if(nodetype == NODE_ELEMENT)
    {
        IFFAILED_EXIT(node->get_nodeName(&nodeName));
    
        for ( DWORD i = 0 ; i < NUMBER_OF(s_msm_worker); i++)
        {
            if (wcscmp(s_msm_worker[i].pwszNodeName, nodeName) == 0)
            {
                IFFAILED_EXIT(s_msm_worker[i].pfn(node));
                break;
            }
        }
    }

Exit:
    SysFreeString(nodeName);
    return hr;
}

HRESULT WalkDomTree(IXMLDOMNode * node)
{
    HRESULT hr = S_OK;
    IXMLDOMNode* pChild = NULL, *pNext = NULL;    

    IFFAILED_EXIT(PopulateDOMNode(node));

    node->get_firstChild(&pChild);
    while (pChild)
    {
        IFFAILED_EXIT(WalkDomTree(pChild));
        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = NULL;
        pChild = pNext;
        pNext = NULL;
    }
Exit:
    if (pChild) 
        pChild->Release();

    if(pNext)
        pNext->Release();

    return hr;
}

HRESULT PopulateAssemblyManifest()
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pDoc = NULL;
    IXMLDOMNode     *pNode = NULL;

    IFFAILED_EXIT(CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pDoc));   
    IFFAILED_EXIT(LoadManifestToDOMDocument(pDoc));  
    IFFAILED_EXIT(pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode));    
    IFFAILED_EXIT(WalkDomTree(pNode));

Exit:
    SAFE_RELEASE_COMPOINTER(pDoc);
    SAFE_RELEASE_COMPOINTER(pNode);
    return hr;
}

HRESULT PrepareMergeModuleOutputFileFromScratch()
{
    HRESULT hr = S_OK;
    LPOLESTR tmpstr = NULL;
    PMSIHANDLE hSummaryInfo = NULL;

    CurrentAssemblyRealign;
    
    // make sure that msm, template and msm-guid has been set
    IFFAILED_EXIT(ValidateCurrentMsmInfo());


    //
    // set cabinet output filename
    //    
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32Assign(g_MsmInfo.m_sbMsmFileName));
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32RemoveLastPathElement());
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32EnsureTrailingPathSeparator());
    IFFALSE_EXIT(g_MsmInfo.m_sbCabinet.Win32Append(MERGEMODULE_CABINET_FILENAME, NUMBER_OF(MERGEMODULE_CABINET_FILENAME) -1));   
    IFFAILED_EXIT(InitializeCabinetForWrite());

    // open msm as a database
    ASSERT_NTC(g_MsmInfo.m_hdb == NULL);
    ASSERT_NTC(g_MsmInfo.m_sbMsmTemplateFile.IsEmpty() == FALSE);
    IFFALSE_EXIT(CopyFileW(g_MsmInfo.m_sbMsmTemplateFile, g_MsmInfo.m_sbMsmFileName, FALSE));    
    IFFALSE_EXIT(SetFileAttributesW(g_MsmInfo.m_sbMsmFileName, FILE_ATTRIBUTE_NORMAL));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(g_MsmInfo.m_sbMsmFileName, (LPCWSTR)(MSIDBOPEN_DIRECT), &g_MsmInfo.m_hdb));
    
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiGetSummaryInformation(g_MsmInfo.m_hdb, NULL, 3, &hSummaryInfo));    
    INTERNAL_ERROR_CHECK_NTC(g_MsmInfo.m_guidModuleID != GUID_NULL);
    IFFAILED_EXIT(StringFromCLSID(g_MsmInfo.m_guidModuleID, &tmpstr));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER, VT_LPSTR, 0,0, tmpstr));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiSummaryInfoSetProperty(hSummaryInfo, PID_PAGECOUNT, VT_I4, 150, 0, 0));

    //
    // write ModuleSiguature table using version
    //
    ASSERT_NTC(g_MsmInfo.m_sbModuleIdentifier.Cch() != 0);
    IFFAILED_EXIT(ExecuteInsertTableSQL(OPT_MODULESIGNATURE, 
        NUMBER_OF_PARAM_TO_INSERT_TABLE_MODULESIGNATURE, 
        MAKE_PCWSTR(g_MsmInfo.m_sbModuleIdentifier), 
        MAKE_PCWSTR(L"1.0.0.0")));

Exit:    
    MsiSummaryInfoPersist(hSummaryInfo);
    CoTaskMemFree(tmpstr);
    return hr;
}

#define MSMGEN_CREATE_MSM_ALWAYS                0x01
#define MSMGEN_ADD_ASSEMBLY_INTO_EXIST_MSM      0x02
    
HRESULT PutAssemblyIntoMergeModule(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    PARAMETER_CHECK_NTC((dwFlags == MSMGEN_CREATE_MSM_ALWAYS) || (dwFlags == MSMGEN_ADD_ASSEMBLY_INTO_EXIST_MSM));

    ASSERT_NTC(curAsmInfo.m_sbAssemblyPath.Cch() != 0);
    ASSERT_NTC(curAsmInfo.m_sbManifestFileName.Cch() != 0);
    ASSERT_NTC(curAsmInfo.m_sbCatalogFileName.Cch() != 0);
    ASSERT_NTC(curAsmInfo.m_sbComponentID.Cch() != 0);

    ASSERT_NTC(g_MsmInfo.m_sbMsmFileName.Cch() != NULL);

        // validate global structure of msmInfo and asmInfo
    if (dwFlags == MSMGEN_CREATE_MSM_ALWAYS)
    {
        // delete mam if exist
        SetFileAttributesW(g_MsmInfo.m_sbMsmFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFileW(g_MsmInfo.m_sbMsmFileName);
        if (GetFileAttributesW(g_MsmInfo.m_sbMsmFileName) != (DWORD) (-1))
        {
            ReportError("failed to create a new msm. The msm file, %S, could not be removed!", (PCWSTR)g_MsmInfo.m_sbMsmFileName);
            SETFAIL_AND_EXIT;
        }
        else if (::GetLastError() !=  ERROR_FILE_NOT_FOUND)
        {
            if (::GetLastError() ==  ERROR_PATH_NOT_FOUND)
            {
                CStringBuffer sb;

                IFFALSE_EXIT(sb.Win32Assign(g_MsmInfo.m_sbMsmFileName));
                IFFALSE_EXIT(sb.Win32RemoveLastPathElement());

                IFFALSE_EXIT(FusionpCreateDirectories(sb, sb.Cch()));
                goto MsmContinue;
            }
             
            ReportError("failed to create a new msm. GetFileAttribute for %S return error other than NOT_FOUND, win32 err code = %d\n", (PCWSTR)g_MsmInfo.m_sbMsmFileName, ::GetLastError());
            SETFAIL_AND_EXIT;
        }
MsmContinue:
        IFFAILED_EXIT(PrepareMergeModuleOutputFileFromScratch());
        IFFAILED_EXIT(PopulateAssemblyManifest());
    }
    else if (dwFlags == MSMGEN_ADD_ASSEMBLY_INTO_EXIST_MSM)
    {
        if (GetFileAttributesW(g_MsmInfo.m_sbMsmFileName) == (DWORD) (-1))
        {
            ReportError("failed to add assembly into a msm. The msm file, %S, does not exist!", (PCWSTR)g_MsmInfo.m_sbMsmFileName);
            SETFAIL_AND_EXIT;
        }
        IFFAILED_EXIT(PopulateAssemblyManifest());       
    }

Exit:
    return hr;
}

void Msmgen_TracingFunctionFailure(PWSTR x, PSTR func, DWORD line)
{
    PWSTR p = x;
    PWSTR q;
    WCHAR Callee[256];

    while ((p != NULL) && ((*p == L' ') || (*p == L'(')))
        p ++;
    q = p; 
    if (p != NULL)
        q = wcschr(p , L'(');
    if (q != NULL)
    {
        wcsncpy(Callee, p, q - p);
        ReportError("%S called in %s at line %2d failed!", Callee, func, line);
    }else
    {
        ReportError("Function called in %s at line %2d failed!", func, line);
    }
    return;
}

// 
// make msi-specified guid string ready : uppercase and replace "-" with "_"
//
HRESULT GetMsiGUIDStrFromGUID(DWORD dwFlags, GUID & guid, CSmallStringBuffer & str)
{
    HRESULT hr = S_OK;    
    WCHAR tmpbuf[MAX_PATH];
    LPOLESTR tmpstr = NULL;

    IFFAILED_EXIT(StringFromCLSID(guid, &tmpstr));
    wcscpy(tmpbuf, tmpstr);
    for (DWORD i=0; i < wcslen(tmpbuf); i++)
    {
        if (tmpbuf[i] == L'-')
            tmpbuf[i] = L'_';
        else
            tmpbuf[i]= towupper(tmpbuf[i]);
    }

    if (dwFlags & MSIGUIDSTR_WITH_PREPEND_DOT)
    {
        tmpbuf[0] = L'.';
        IFFALSE_EXIT(str.Win32Assign(tmpbuf, wcslen(tmpbuf) - 1 ));  // has prepend "."
    }else
        IFFALSE_EXIT(str.Win32Assign(tmpbuf + 1 , wcslen(tmpbuf) - 2 ));  // get rid of "{" and "}"

Exit:
    CoTaskMemFree(tmpstr);
    return hr;
}


HRESULT FillMsmForInitialize()
{
    HRESULT hr = S_OK;
    WCHAR buf[MAX_PATH];

    if (GetFileAttributesW(g_MsmInfo.m_sbMsmFileName) != DWORD(-1))
    {
        SetFileAttributesW(g_MsmInfo.m_sbMsmFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFileW(g_MsmInfo.m_sbMsmFileName);
        if (GetFileAttributesW(g_MsmInfo.m_sbMsmFileName) != DWORD(-1))
        {            
            ReportError("the output %s already exist, please rename or delete it.\n");        
            hr = E_INVALIDARG;
            goto Exit;
        }
    }

    //
    // set template filename
    //
    if (g_MsmInfo.m_sbMsmTemplateFile.Cch() == 0)
    {
        if (FALSE == g_sbTemplateFile.IsEmpty())
        {
            IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(g_sbTemplateFile));
        } else
        {

            //
            // get template file from current directory
            // 
            DWORD dwRet;
            dwRet = GetModuleFileNameW(NULL, buf, NUMBER_OF(buf));
    
            if ((dwRet == 0) || (dwRet >= NUMBER_OF(buf)))
                SET_HRERR_AND_EXIT(::GetLastError());

            IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(buf, wcslen(buf)));
            IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32ChangePathExtension(L"msm", 3,  eErrorIfNoExtension));        
        }
    }

    // make sure that the template file must exist!
    if (::GetFileAttributesW(g_MsmInfo.m_sbMsmTemplateFile) == (DWORD) -1)
    {
        fprintf(stderr, "the specified Msm TemplateFile %S does not exist!\n", g_MsmInfo.m_sbMsmTemplateFile);
        SET_HRERR_AND_EXIT(::GetLastError());
    }

    // set msm ID
    if (g_MsmInfo.m_guidModuleID == GUID_NULL)
    {
        IFFAILED_EXIT(::CoCreateGuid(&g_MsmInfo.m_guidModuleID));
    }
    
    IFFAILED_EXIT(GetMsiGUIDStrFromGUID(MSIGUIDSTR_WITH_PREPEND_DOT, g_MsmInfo.m_guidModuleID, g_MsmInfo.m_sbModuleGuidStr));
    // unset until we get textual assembly identity
    IFFALSE_EXIT(g_MsmInfo.m_sbModuleIdentifier.Win32Assign(L"_", 1)); //make sure that ModuleID does not start with a "_"
    IFFALSE_EXIT(g_MsmInfo.m_sbModuleIdentifier.Win32Append(g_MsmInfo.m_sbModuleGuidStr + 1, g_MsmInfo.m_sbModuleGuidStr.Cch() -1));
    hr= S_OK;

Exit:
    return hr;
}

#define FILE_EXTENSION_MSM  L"msm"
#define FILE_EXTENSION_MSM_CCH 3

using namespace std;
#include <string>

HRESULT InitializeMsmA(string & strManFile, string & strMsmFile, string & strMsmID, string & strTemplateFile)
{
    HRESULT hr = S_OK;    
    LPOLESTR tmpstr = NULL;
  
    PARAMETER_CHECK_NTC(!strManFile.empty());    

    ZeroOutMsmInfo(); // void function

    //
    // set output msm filename
    //
    if (strMsmFile.empty())
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(strManFile.c_str(), strManFile.length()));
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32ChangePathExtension(FILE_EXTENSION_MSM, FILE_EXTENSION_MSM_CCH, eErrorIfNoExtension));
    } 
    else 
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(strMsmFile.c_str(), strMsmFile.length()));
    }

    //
    // set template filename
    //
    if (!strTemplateFile.empty())
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(strTemplateFile.c_str(), strTemplateFile.length()));
    }

    // set msm ID
    g_MsmInfo.m_guidModuleID = GUID_NULL;
    if (!strMsmID.empty())
    {
        //
        // get ModuleID from msm and save it into the global structure
        //
        CStringBuffer sb;
        IFFALSE_EXIT(sb.Win32Assign(strMsmID.c_str(), strMsmID.length()));
        IFFAILED_EXIT(CLSIDFromString(LPOLESTR(PCWSTR(sb)), &g_MsmInfo.m_guidModuleID));
    }        

    IFFAILED_EXIT(FillMsmForInitialize());
    
    hr = S_OK;
Exit:
    CoTaskMemFree(tmpstr);
    
    return hr;
}

HRESULT InitializeMsmW(PCWSTR pszManFile, PCWSTR pszMsmFile, PCWSTR pszMsmID, PCWSTR pszTemplateFile)
{
    HRESULT hr = S_OK;    
    PMSIHANDLE hSummaryInfo = NULL;\

    PARAMETER_CHECK_NTC(pszManFile != NULL);    

    ZeroOutMsmInfo(); // void function

    //
    // set output msm filename
    //
    if (pszMsmFile == NULL)
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(pszManFile, wcslen(pszManFile)));
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32ChangePathExtension(FILE_EXTENSION_MSM, FILE_EXTENSION_MSM_CCH, eErrorIfNoExtension));
    } 
    else 
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmFileName.Win32Assign(pszMsmFile, wcslen(pszMsmFile)));
    }

    //
    // set template filename
    //
    if (pszTemplateFile != NULL)
    {
        IFFALSE_EXIT(g_MsmInfo.m_sbMsmTemplateFile.Win32Assign(pszTemplateFile, wcslen(pszTemplateFile)));
    } 

    
    // set msm ID
    g_MsmInfo.m_guidModuleID = GUID_NULL;
    if (pszMsmID != NULL)
    {
        //
        // get ModuleID from msm and save it into the global structure
        //
        IFFAILED_EXIT(CLSIDFromString(LPOLESTR(pszMsmID), &g_MsmInfo.m_guidModuleID));
    }
    
    IFFAILED_EXIT(FillMsmForInitialize());
    hr = S_OK;

Exit:  
    return hr;
}

HRESULT GetInfoMsmgenCommandLineParameters(const DWORD dwGenFlag, wchar_t ** Options, DWORD NumOptions, PWSTR * pszComponentID, PWSTR * pszMsmFile, PWSTR * pszMsmID, PWSTR * pszTemplateFile)
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    PARAMETER_CHECK_NTC((dwGenFlag == MSMGEN_FROM_MANFILE) || (dwGenFlag == MSMGEN_FROM_MANLIST));
    PARAMETER_CHECK_NTC(NumOptions % 2 == 0);
    *pszComponentID = NULL; 
    *pszMsmFile = NULL;
    *pszMsmID = NULL;
    *pszTemplateFile = NULL;

    while ( i < NumOptions)
    {
        if (Options[i][0] != L'-') // must begin with "-"
            goto InvalidOption;

        if (_wcsicmp(Options[i], L"-msm") == 0 )
        {            
            if (*pszMsmFile != NULL)
            {
                ReportError("output msm is specified more than once\n");
                goto InvalidOption;
            } else
            {
                *pszMsmFile = Options[i + 1];
            }
        }
        else if (_wcsicmp(Options[i], L"-template") == 0 )
        {            
            if (*pszTemplateFile != NULL)
            {
                ReportError("TemplateFile is specified more than once\n");
                goto InvalidOption;
            } else
            {
                *pszTemplateFile = Options[i + 1];
            }
        }
        else if (_wcsicmp(Options[i], L"-compid") == 0 )
        {
            if (dwGenFlag == MSMGEN_FROM_MANLIST)
            {
                ReportError("ComponentID should not be specified for manlist\n");
                goto InvalidOption;
            }

            if (*pszComponentID != NULL)
            {
                ReportError("ComponentID is specified more than once\n");
                goto InvalidOption;
            } 
            else
            {
                *pszComponentID = Options[i + 1];
            }
        }
        else if (_wcsicmp(Options[i], L"-msmid") == 0 )
        {
            if (*pszMsmID != NULL)
            {
                ReportError("msmid is specified more than once\n");
                goto InvalidOption;
            } else
            {
                *pszMsmID = Options[i + 1];
            }            
        }
        else
            goto InvalidOption;

        i++;    // skip the option
        i++;    // skip the value of the option
    }

    hr = S_OK;
    goto Exit;

InvalidOption:        
    PrintUsage();
    hr = E_INVALIDARG;

Exit:
    return hr;
}

HRESULT InitializeAsmInfoW(PCWSTR pszManifestFile, PCWSTR pszComponent)
{
    HRESULT hr = S_OK;
    WCHAR tmp[MAX_PATH];
    UINT iRet;    
    LPOLESTR tmpstr = NULL;
    PWSTR p = NULL;

    PARAMETER_CHECK_NTC(pszManifestFile != NULL);

    // initialize the global structure of current assembly info
    ZeroOutCurrentAssemblyInfo();

    //
    // set manifest, catalog and AssemblyPath, 
    //

    // the manifest does not exist
    if (::GetFileAttributesW(pszManifestFile) == DWORD (-1))
    {
        ReportError("the manifest file, %S, does not exist, try with manifest file's fullpath!\n", pszManifestFile);
        SETFAIL_AND_EXIT;
    }

    iRet = ::GetFullPathNameW(pszManifestFile, NUMBER_OF(tmp), tmp, NULL);
    if ((iRet == 0 ) || (iRet > NUMBER_OF(tmp)))
    {
        ReportError("Get the fullpath of manifest file, %S, failed with LastError=%d!\n", pszManifestFile, ::GetLastError());
        SET_HRERR_AND_EXIT(::GetLastError());
    }
    
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Assign(tmp, wcslen(tmp)));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32GetLastPathElement(curAsmInfo.m_sbManifestFileName));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32RemoveLastPathElement());
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32EnsureTrailingPathSeparator()); // Path with a trailing slash is always ready to use

    curAsmInfo.m_CchAssemblyPath = curAsmInfo.m_sbAssemblyPath.GetCchAsDWORD(); 
    curAsmInfo.m_CchManifestFileName = curAsmInfo.m_sbManifestFileName.GetCchAsDWORD();

    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32Assign(curAsmInfo.m_sbManifestFileName));
    IFFALSE_EXIT(curAsmInfo.m_sbCatalogFileName.Win32ChangePathExtension(CATALOG_FILE_EXT, NUMBER_OF(CATALOG_FILE_EXT) -1, eAddIfNoExtension));
    IFFALSE_EXIT(curAsmInfo.m_sbAssemblyPath.Win32Append(curAsmInfo.m_sbCatalogFileName));

    if (::GetFileAttributesW(curAsmInfo.m_sbAssemblyPath) == DWORD (-1))
    {
        ReportError("The catalog file, %S, does not exist!", (PCWSTR)curAsmInfo.m_sbAssemblyPath);
        SETFAIL_AND_EXIT;
    }

    curAsmInfo.m_CchCatalogFileName = curAsmInfo.m_sbCatalogFileName.GetCchAsDWORD();

    //
    // reset
    //
    curAsmInfo.m_sbAssemblyPath.Left(curAsmInfo.m_CchAssemblyPath);
    curAsmInfo.m_sbManifestFileName.Left(curAsmInfo.m_CchManifestFileName);

    //
    // set componentID
    //

    if (pszComponent == NULL)
    {
        GUID tmpguid;
    
        IFFAILED_EXIT(::CoCreateGuid(&tmpguid));
        IFFAILED_EXIT(StringFromCLSID(tmpguid, &tmpstr));        
        IFFALSE_EXIT(curAsmInfo.m_sbComponentID.Win32Assign(tmpstr, wcslen(tmpstr)));
    }
    else 
    {
        IFFALSE_EXIT(curAsmInfo.m_sbComponentID.Win32Assign(pszComponent, wcslen(pszComponent)));
    }    

    MsmToUpper(curAsmInfo.m_sbComponentID);

Exit:
    CoTaskMemFree(tmpstr);
    return hr;
}

HRESULT InitializeAsmInfoA(const string & strManifestFile, const string & strComponent)
{
    WCHAR wstrManifestFile[MAX_PATH];
    WCHAR wstrComponentID[64];
    HRESULT hr = S_OK;

    PARAMETER_CHECK_NTC(!strManifestFile.empty());
    if (0 == MultiByteToWideChar(CP_ACP, 0, strManifestFile.c_str(), strManifestFile.length(), wstrManifestFile, NUMBER_OF(wstrManifestFile)))
    {
        ReportError("convert %s to wstr failed!", strManifestFile.c_str());
        SETFAIL_AND_EXIT;
    }
    wstrManifestFile[strManifestFile.length()] = L'\0';

    if (!strComponent.empty())
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, strComponent.c_str(), strComponent.length(), wstrComponentID, NUMBER_OF(wstrComponentID)))
        {
            ReportError("convert %s to wstr failed!", strComponent.c_str());
            SETFAIL_AND_EXIT;
        }
        wstrComponentID[strComponent.length()] = L'\0';
    }

    IFFAILED_EXIT(InitializeAsmInfoW(wstrManifestFile, strComponent.empty() ? NULL : wstrComponentID));

Exit:
    return hr;
}

void CleanupMsm()
{
    if ( g_MsmInfo.m_hfci != NULL)
    {
        FCIDestroy(g_MsmInfo.m_hfci);
        g_MsmInfo.m_hfci = NULL;
    }
    
    if ( g_MsmInfo.m_hdb!= NULL){
        MsiDatabaseCommit(g_MsmInfo.m_hdb);
        MsiCloseHandle(g_MsmInfo.m_hdb);
        g_MsmInfo.m_hdb = NULL;
    }
    return;
}

HRESULT FinalizedMsm()
{ 
    HRESULT hr = S_OK;

    IFFAILED_EXIT(CloseCabinet());   
    IFFAILED_EXIT(InsertCabinetIntoMsm());

Exit:    
    DeleteFileW(g_MsmInfo.m_sbCabinet);
    CleanupMsm();

    return hr;
}

HRESULT CreateMsmForSingleManifest(PCWSTR pszManifestFile, PCWSTR pszComponent)
{
    HRESULT hr = S_OK;
    PARAMETER_CHECK_NTC(pszManifestFile != NULL);
    
    IFFAILED_EXIT(InitializeAsmInfoW(pszManifestFile, pszComponent));

    IFFAILED_EXIT(PutAssemblyIntoMergeModule(MSMGEN_CREATE_MSM_ALWAYS));
    IFFAILED_EXIT(FinalizedMsm());

Exit:
    return hr;
}

#include <fstream>
#if defined(_WIN64)
#pragma warning(disable: 4244)
#endif
#include <strstream>
#if defined(_WIN64)
#pragma warning(default: 4244)
#endif

void MsmTrimString(string & str)
{
    if (!str.empty())
    {
        string::size_type x = str.find_first_not_of(' ');
        if (x != 0)    
            str.erase(0, x);
        if (!str.empty())
        {
            x = str.find_last_not_of(' ');
            if (x != str.length() - 1) 
                str.erase(x + 1, str.length() - 1 - x);
        }
    }
    return; 
}

HRESULT CreateMsmForManifestList(PCWSTR pwszManListFile)
{
    HRESULT hr = S_OK;
    char pszManListFile[MAX_PATH];
    int iBufSize;
    string strline;
    string strManifestFilename;
    string strComponentID;
    DWORD numLine = 0;
    ifstream manlist;

    PARAMETER_CHECK_NTC(pwszManListFile != NULL);
    
    iBufSize = WideCharToMultiByte(CP_ACP, 0, pwszManListFile, wcslen(pwszManListFile), NULL, 0, NULL, NULL);
    if (iBufSize > NUMBER_OF(pszManListFile))
    {
        ReportError("the manlist filename, %S, is longer than MAX_PATH\n", pwszManListFile);
        SETFAIL_AND_EXIT;
    }

    if (0 == WideCharToMultiByte(CP_ACP, 0, pwszManListFile, wcslen(pwszManListFile), pszManListFile, NUMBER_OF(pszManListFile), NULL, NULL))
    {
        ReportError("the manlist filename, %S, failed to convert to ansi string\n", pwszManListFile);
        SETFAIL_AND_EXIT;
    }
    pszManListFile[wcslen(pwszManListFile)] = '\0';
    
    manlist.open(pszManListFile);
    if (manlist.fail())
    {
        ReportError("the manlist, %S, now as %s, can not be opened\n", pwszManListFile, pszManListFile);
        SETFAIL_AND_EXIT;
    }
    for(; !manlist.eof(); )
    {
        getline(manlist, strline);
        if (strline.empty())
            break;

        numLine ++; 
        // extract manifest filename[required] and componentID[optional] and its default value could be empty or "default"
        istrstream iline(strline.c_str());

        getline(iline, strManifestFilename, ',');
        getline(iline, strComponentID);
        MsmTrimString(strManifestFilename);
        MsmTrimString(strComponentID);

        if (strManifestFilename.empty() == TRUE)
        {
            ReportError("no manifest is specified on line %d in manlist file %S \n", numLine, pwszManListFile);
            SETFAIL_AND_EXIT;
        }        
        IFFAILED_EXIT(InitializeAsmInfoA(strManifestFilename, strComponentID));
        if (numLine == 1)
        {
            IFFAILED_EXIT(PutAssemblyIntoMergeModule(MSMGEN_CREATE_MSM_ALWAYS));            
        }
        else
        {
            IFFAILED_EXIT(PutAssemblyIntoMergeModule(MSMGEN_ADD_ASSEMBLY_INTO_EXIST_MSM));
        }
    }
    IFFAILED_EXIT(FinalizedMsm());
    hr = S_OK;
Exit:
    return hr;
}

class ManGroupKey{
public:
    string strTag;
    string strMsmID;
    string strMsmFile;
    string strTemplateFile;
    string strManifest;
};

class ManGroupValue{
public:    
    string strComponentID;
};

#include <functional>
bool less<ManGroupKey>::operator()(const ManGroupKey& x, const ManGroupKey& y) const
{
    if (x.strTag != y.strTag)
        return (x.strTag < y.strTag);
    if (x.strMsmID != y.strMsmID)
        return (x.strMsmID  < y.strMsmID);
    if (x.strMsmFile != y.strMsmFile)
        return (x.strMsmFile < y.strMsmFile);
    if (x.strTemplateFile != y.strTemplateFile)
        return (x.strTemplateFile < y.strTemplateFile);
    
    return (x.strManifest  < y.strManifest);
        
}

#include <map>
#include <utility>
HRESULT CreateMsmForManifestGroup(PCWSTR pwszMangroupFile)
{
    HRESULT hr = S_OK;    
    ifstream mangroup;
    char pszMangroupFile[MAX_PATH];
    ManGroupKey     mgKey; 
    ManGroupValue   mgValue;
    map<ManGroupKey, ManGroupValue> mapManGroup;        
    map<ManGroupKey, ManGroupValue>::iterator m1_pIter;
    typedef pair <ManGroupKey, ManGroupValue> Mangroup_Entry;
    int iBufSize;
    DWORD numLine;
    string strline;
    bool fCurrentInAGroup;
    bool fStartFromSratch;
    string strCurrentMsmid;
    string strCurrentMsmFile;
    string strCurrentMsmTemplate;

    PARAMETER_CHECK_NTC(pwszMangroupFile != NULL);

    iBufSize = WideCharToMultiByte(CP_ACP, 0, pwszMangroupFile, wcslen(pwszMangroupFile), NULL, 0, NULL, NULL);
    if (iBufSize > NUMBER_OF(pszMangroupFile))
    {
        ReportError("the manlist filename, %S, is longer than MAX_PATH\n", pwszMangroupFile);
        SETFAIL_AND_EXIT;
    }

    if (0 == WideCharToMultiByte(CP_ACP, 0, pwszMangroupFile, wcslen(pwszMangroupFile), pszMangroupFile, NUMBER_OF(pszMangroupFile), NULL, NULL))
    {
        ReportError("the manlist filename, %S, failed to convert to ansi string\n", pwszMangroupFile);
        SETFAIL_AND_EXIT;
    }
    pszMangroupFile[wcslen(pwszMangroupFile)] = '\0';

    mangroup.open(pszMangroupFile);
    if (mangroup.fail())
    {
        ReportError("the mangroupfile, %S, now as %s, can not be opened\n", pwszMangroupFile, pszMangroupFile);
        SETFAIL_AND_EXIT;
    }  
    numLine = 0;

    //
    // firstly read the file into a map which is sorted during insert
    //
    for(; !mangroup.eof(); )
    {        
        getline(mangroup, strline);
        if (strline.empty())
            continue;

        istrstream iline(strline.c_str());
        if (iline.str() == NULL)        
            break;

        numLine ++;
        // clean the key strings
        mgKey.strTag.erase();
        mgKey.strMsmID.erase();
        mgKey.strManifest.erase();
        mgKey.strMsmFile.erase();        
        mgKey.strTemplateFile.erase();

        mgValue.strComponentID.erase();

        getline(iline, mgKey.strTag, ',');
        getline(iline, mgKey.strMsmID, ',');
        getline(iline, mgKey.strMsmFile, ',');
        getline(iline, mgKey.strManifest, ',');
        getline(iline, mgValue.strComponentID, ',');
        getline(iline, mgKey.strTemplateFile, ',');

        MsmTrimString(mgKey.strTag);
        MsmTrimString(mgKey.strMsmID);
        MsmTrimString(mgKey.strManifest);

        MsmTrimString(mgKey.strMsmFile);
        MsmTrimString(mgValue.strComponentID);
        MsmTrimString(mgKey.strTemplateFile);

        if (mgKey.strTag.empty())
        {
            ReportError("error on line %d in mangroup file %S, also is %s: Tag or MsmID is empty\n", numLine, pwszMangroupFile, pszMangroupFile);
            SETFAIL_AND_EXIT;
        }
        
        if (mgKey.strManifest.empty())
        {
            ReportError("error on line %d in mangroup file %S, also is %s: manifest file is empty\n", numLine, pwszMangroupFile, pszMangroupFile);
            SETFAIL_AND_EXIT;
        }

        if ((mgKey.strTag.compare("0") != 0) && (mgKey.strTag.compare("1") != 0))
        {
            ReportError("error on line %d in mangroup file %S, also is %s: tag must be 0 or 1\n", numLine, pwszMangroupFile, pszMangroupFile);
            SETFAIL_AND_EXIT;
        }
        if (mgKey.strTag.compare("1") == 0)
        {
            //
            // in this case, msmid and msmfile must be specified
            //
            if ((mgKey.strMsmFile.empty()) || (mgKey.strMsmID.empty()))
            {
                ReportError("if the first column is set to be \"1\", output msm file and msmid must be specified in the mangroup file!\n");
                SETFAIL_AND_EXIT;
            }
        }

        mapManGroup.insert(Mangroup_Entry(mgKey, mgValue));
    }

    fCurrentInAGroup = false;
    fStartFromSratch = true;
    
    for ( m1_pIter = mapManGroup.begin( ); m1_pIter != mapManGroup.end( ); m1_pIter++ )
    {        
        mgKey = m1_pIter->first;
        mgValue = m1_pIter->second;

        if (mgKey.strTag.compare("1") == 0) 
        {
            if (fCurrentInAGroup == false)
            {
                fStartFromSratch = true;
                fCurrentInAGroup = true;
                strCurrentMsmid = mgKey.strMsmID;
                strCurrentMsmFile = mgKey.strMsmFile;
                strCurrentMsmTemplate = mgKey.strTemplateFile;
            }else
            {
                if (strCurrentMsmid != mgKey.strMsmID)
                {
                    IFFAILED_EXIT(FinalizedMsm());

                    fStartFromSratch = true;
                    fCurrentInAGroup = true;
                    strCurrentMsmid = mgKey.strMsmID;
                    strCurrentMsmFile = mgKey.strMsmFile;
                    strCurrentMsmTemplate = mgKey.strTemplateFile;

                } else
                {
                    // they must share the same msmID and msmfile
                    if (!mgKey.strMsmFile.empty())                    
                    {
                        if (mgKey.strMsmFile != strCurrentMsmFile)
                        {
                            ReportError("must share the same msm output file\n");
                            SETFAIL_AND_EXIT;
                        }
                    }

                    if (!mgKey.strTemplateFile.empty())                    
                    {
                        if (mgKey.strTemplateFile != strCurrentMsmTemplate)
                        {
                            ReportError("must use the same msm templatefile\n");
                            SETFAIL_AND_EXIT;
                        }
                    }

                }
            }
        } else if (mgKey.strTag == "0")
        {
            if (fCurrentInAGroup == true)
            {
                // close current manifest group
                IFFAILED_EXIT(FinalizedMsm());
            }
            fStartFromSratch = true;
            fCurrentInAGroup = false;                     
        } 
        else
        {
            // impossible case
            ReportError("tag is neither 0 nor 1\n");
            SETFAIL_AND_EXIT;
        }
        if (fStartFromSratch)
        {
            IFFAILED_EXIT(InitializeMsmA(mgKey.strManifest, mgKey.strMsmFile, mgKey.strMsmID, mgKey.strTemplateFile));
            IFFAILED_EXIT(InitializeAsmInfoA(mgKey.strManifest, mgValue.strComponentID));
            IFFAILED_EXIT(PutAssemblyIntoMergeModule(MSMGEN_CREATE_MSM_ALWAYS));            
        } 
        else
        {
            ASSERT_NTC(fCurrentInAGroup == true);
            if (fCurrentInAGroup)
            {
                IFFAILED_EXIT(InitializeAsmInfoA(mgKey.strManifest, mgValue.strComponentID));
                IFFAILED_EXIT(PutAssemblyIntoMergeModule(MSMGEN_ADD_ASSEMBLY_INTO_EXIST_MSM));
            }           
        }

        // for single generation
        if (fCurrentInAGroup == false) 
        {
            ASSERT_NTC(fStartFromSratch == true);
            IFFAILED_EXIT(FinalizedMsm());
        }

        fStartFromSratch = false;
    }   

    if (fCurrentInAGroup == true)
        IFFAILED_EXIT(FinalizedMsm());
Exit:
    return hr;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    HRESULT hr = S_OK;
    PWSTR   pszComponentID = NULL, pszMsmFile = NULL, pszMsmID = NULL, pszTemplateFile = NULL;   
    DWORD dwGenFlag;
   
    if ((argc < 3) ||  ((argc % 2) != 1))
    {
        PrintUsage();
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!FusionpInitializeHeap(NULL)){
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    CoInitialize(NULL);    
    
    //
    // the first parameter must be "manfile" or "manlist" or "mangroup"
    //
    if (_wcsicmp(argv[1], L"manfile") == 0)
    {
        dwGenFlag = MSMGEN_FROM_MANFILE;
    } 
    else if (_wcsicmp(argv[1], L"manlist") == 0)
    {
        dwGenFlag = MSMGEN_FROM_MANLIST;
    } 
    else if (_wcsicmp(argv[1], L"mangroup") == 0)
    {
        dwGenFlag = dwGenFlag = MSMGEN_FROM_MANGROUP;
        if ((argc != 3) && (argc != 5))
        {
            goto InvalidParam;
        }
        if (argc == 5)
        {
            // it must try to specify a template
            if (_wcsicmp(argv[3], L"-template") != 0)
            {
                goto InvalidParam;
            }else
            {
                IFFALSE_EXIT(g_sbTemplateFile.Win32Assign(argv[4], wcslen(argv[4])));
            }
        }
    }
    else
    {        
        goto InvalidParam;
    }

    //check the existence of the input file

    if ( GetFileAttributesW(argv[2]) == DWORD (-1))
    {
        ReportError("man file does not exist!\n");
        goto InvalidParam;
    } 
    else 
    {
        if (dwGenFlag == MSMGEN_FROM_MANFILE)
        {
            CStringBuffer manfile;
            CSmallStringBuffer ext; 
            IFFALSE_EXIT(manfile.Win32Assign(argv[2], wcslen(argv[2])));
            IFFALSE_EXIT(manfile.Win32GetPathExtension(ext));
            if (ext.Cch() == 0)
            {
                ReportError("Manifest file must has ext as .man or .manifest\n");
                goto InvalidParam;
            }
        }
    }

    if ((dwGenFlag == MSMGEN_FROM_MANFILE) || (dwGenFlag == MSMGEN_FROM_MANLIST))
    {        
        //
        // parse and validate parameters
        //
        IFFAILED_EXIT(GetInfoMsmgenCommandLineParameters(dwGenFlag, argv+3, argc-3, &pszComponentID, &pszMsmFile, &pszMsmID, &pszTemplateFile));
    }

    switch(dwGenFlag)
    {
        case MSMGEN_FROM_MANFILE:                
                IFFAILED_EXIT(InitializeMsmW(argv[2], pszMsmFile, pszMsmID, pszTemplateFile));
                IFFAILED_EXIT(CreateMsmForSingleManifest(argv[2], pszComponentID));
            break;
        case MSMGEN_FROM_MANLIST:
                if (pszComponentID != NULL)
                {
                    ReportError("componentID should not be specified with manlist\n");
                    goto InvalidParam;
                }
                IFFAILED_EXIT(InitializeMsmW(argv[2], pszMsmFile, pszMsmID, pszTemplateFile));
                IFFAILED_EXIT(CreateMsmForManifestList(argv[2]));
            break;
        case MSMGEN_FROM_MANGROUP:
                IFFAILED_EXIT(CreateMsmForManifestGroup(argv[2]));
            break;
    }
    hr = S_OK;
    goto Exit;
    
InvalidParam:
    PrintUsage();
    hr = E_INVALIDARG;

Exit:
    CoUninitialize();
    CleanupMsm();
    if (hr == S_OK)
        printf("msm is generated successfully!");
    else
        printf("msm is failed to be generated!");    
     return (hr == S_OK) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\popcopy\popcopy.cpp ===
/*
Copy a build from a vbl share to the local machine, in order to
PopulateFromVBL from the local copy.

Usage:
    popcopy -option
    popcopy -nooption
    popcopy -option:value
    popcopy -option=value

Options:
    -from (required)
    -to  (required)
    -nosym  (default)
    -symonly
    -sym
    -bat (prints a .bat file instead of running commands)
    -nocopy (hack so to simulate "-localuncomponly" so I can debug it)

Jay Krell
May 3, 2001
*/
#pragma warning(disable:4786) // identifier was truncated to '255' character
#include "stdinc.h"
#include <vector>
#include <map>
#include <string>
#include <iterator>
#include <stdlib.h>
#include <set>
#include <fstream>
#include <algorithm>
#include <time.h>
#include "windows.h"
#include "setupapi.h"
const std::string::size_type npos = std::string::npos;

class String_t : public std::string
//
// 1) comparison is case insensitive
// 2) MAYBE slashes sort like \1, but not currently
//
{
    typedef std::string Base_t;
public:
    String_t() { }
    ~String_t() { }

    String_t(const Base_t& s) : Base_t(s) { }
    String_t(const char* s) : Base_t(s) { }
    void operator=(const char* s) { Base_t::operator=(s); }
    void operator=(const std::string& s) { Base_t::operator=(s); }

	//operator const char*() const { return c_str(); }

    bool operator<(const char* t) const
    {
        return _stricmp(c_str(), t) < 0;
    }

    bool operator==(const char* t) const
    {
        return _stricmp(c_str(), t) == 0;
    }

    bool operator<(const std::string& t) const
    {
        return operator<(t.c_str());
    }

    bool operator==(const std::string& t) const
    {
        return operator==(t.c_str());
    }

    void MakeLower()
    {
        for (iterator i = begin() ; i != end() ; ++i)
        {
            *i = static_cast<char>(tolower(*i));
        }
    }
};

typedef std::vector<String_t> StringVector_t;
typedef std::set<String_t> StringSet_t;
typedef std::map<String_t, String_t> StringToStringMap_t;


bool IsTrue(const String_t& s)
{
    return (s == "1" || s == "true" || s == "True" || s == "TRUE"); }

bool IsFalse(const String_t& s)
{
    return (s == "" || s == "0" || s == "false" || s == "False" || s == "FALSE"); }

void CommandLineError(
    const String_t& e
    )
{
    fprintf(stderr, "%s\n", e.c_str());
    exit(EXIT_FAILURE);
}

class Binlist_t
{
public:
    Binlist_t() { }
    ~Binlist_t() { }

 StringVector_t  m_files;
    StringVector_t  m_directories;
    StringVector_t  m_symdirectories;
    StringVector_t  m_symfiles;
};

class Decompression_t
{
public:
	String_t m_from;
	String_t m_to;
};
typedef std::vector<Decompression_t> Decompressions_t;

class Popcopy_t
{
public:
    ~Popcopy_t() { }

    Popcopy_t() : m_bat(false), m_copy(true)
    {
    }

    void Main(const StringVector_t& args);

    void ReadBinlist();

    void CreateDirectory(const std::string& partial);
    void CopyFile(const std::string& partial);
    void CopyFile(const String_t& from, const String_t& to);

	void DoQueuedDecompressions();
	void QueueDecompression(const String_t& from, const String_t& to);

    Binlist_t m_binlist;

    StringToStringMap_t m_options;

    String_t        m_from;
	String_t		m_fromcomp; // m_from + "\\comp"
    String_t        m_to;
    String_t        m_tocomp; // m_to + "\\comp"

    bool            m_bat;
    bool            m_copy;

	//
	// compressions are all recorded, to be done last, after all the copies
	//
	Decompressions_t m_decompressions;
};

String_t RemoveTrailingChars(const String_t& s, const char* set)
{
    String_t::size_type pos = s.find_last_not_of(set);
    if (pos != npos)
        return s.substr(0, 1 + pos);
	return s;
}

String_t RemoveTrailingSlashes(const String_t& s)
{
	return RemoveTrailingChars(s, " \\/");
}

String_t RemoveLastPathElement(const String_t& s)
{
	String_t t = RemoveTrailingSlashes(s);
	return RemoveTrailingSlashes(t.substr(0, t.find_last_of("\\/")));
}

String_t RemoveTrailingWhitespace(String_t s)
{
	return RemoveTrailingChars(s, " \r\t\n\v");
}

template <typename T>
void SortUnique(T& t)
{
    std::sort(t.begin(), t.end());
    t.resize(std::unique(t.begin(), t.end()) - t.begin());
}

String_t JoinPaths(const std::string& s, const std::string& t) {
    std::string u = s;

    if (u.length() == 0 || (u[u.length() - 1] != '\\' && u[u.length() - 1] != '/'))
        u += "\\";
    if (t.length() != 0 && (t[0] == '\\' || t[0] == '/'))
        u += t.substr(1);
    else
        u += t;
    //printf("%s + %s = %s\n", s.c_str(), t.c_str(), u.c_str());
    return u;
}

void Popcopy_t::ReadBinlist()
{
    std::ifstream in(JoinPaths(m_from, "build_logs\\build.binlist").c_str());
    String_t line;
    while (std::getline(in, line))
    {
        line = RemoveTrailingWhitespace(line);
        line.MakeLower();

        // x:\binaries.x86chk\foo -> foo
        line = line.substr(1 + line.find_first_of("\\/"));
        line = line.substr(1 + line.find_first_of("\\/"));
        //line = line.substr(1 + line.find_first_of("\\/", line.find_first_of("\\/")));
        String_t::size_type lastPathSeperator = line.find_last_of("\\/");
        bool issyms = (line.find("symbols\\") != npos || line.find("symbols.pri\\") != npos);
        if (issyms)
        {
            if (lastPathSeperator != npos)
			{
				String_t dir = JoinPaths(m_to, line.substr(0, lastPathSeperator));
				while (dir != m_to)
				{
					m_binlist.m_directories.push_back(dir);
					dir = RemoveLastPathElement(dir);
				}
			}
            m_binlist.m_symfiles.push_back(line);
        }
        else
        {
            if (lastPathSeperator != npos)
			{
				String_t dir = JoinPaths(m_to, line.substr(0, lastPathSeperator));
				while (dir != m_to)
				{
					m_binlist.m_directories.push_back(dir);
					dir = RemoveLastPathElement(dir);
				}
				dir = JoinPaths(m_tocomp, line.substr(0, lastPathSeperator));
				while (dir != m_to)
				{
					m_binlist.m_directories.push_back(dir);
					dir = RemoveLastPathElement(dir);
				}
			}
            m_binlist.m_files.push_back(line);
        }
    }
    m_binlist.m_directories.push_back(m_to);
    m_binlist.m_directories.push_back(JoinPaths(m_to, "comp"));
    SortUnique(m_binlist.m_symfiles);
    SortUnique(m_binlist.m_symdirectories);
    SortUnique(m_binlist.m_files);
    SortUnique(m_binlist.m_directories);
}

void
Popcopy_t::CreateDirectory(
    const std::string& full
    )
{
    unsigned long Error;

    if (m_bat)
        printf("%s\n", ("mkdir " + full).c_str());
    else
    {
        if (!::CreateDirectory(full.c_str(), NULL)
            && (Error = GetLastError()) != ERROR_ALREADY_EXISTS)
        {
            printf(("CreateDirectory(" + full + ") failed, error %lu\n").c_str(), Error);
        }
    }
}

void
Popcopy_t::QueueDecompression(
	const String_t& from,
	const String_t& to
	)
{
	Decompression_t d;
	d.m_from = from;
	d.m_to = to;
	m_decompressions.push_back(d);
}

UINT
CALLBACK
CabinetCallback(
	void* Context,
	unsigned Notification,
	UINT_PTR Param1,
	UINT_PTR Param2
	)
{
	PFILE_IN_CABINET_INFO FileInCabinetInfo;

	switch (Notification)
	{
	case SPFILENOTIFY_FILEINCABINET:
		FileInCabinetInfo = reinterpret_cast<PFILE_IN_CABINET_INFO>(Param1);
		strcpy(FileInCabinetInfo->FullTargetName, reinterpret_cast<const String_t*>(Context)->c_str());
		return FILEOP_DOIT;

	case SPFILENOTIFY_FILEEXTRACTED:
		return NO_ERROR;
	case SPFILENOTIFY_CABINETINFO:
		return NO_ERROR;
	case SPFILENOTIFY_NEEDNEWCABINET:
		return ~0u;
	default:
		return ~0u;
	}
}

void
Popcopy_t::DoQueuedDecompressions(
	)
{
    unsigned long Error;

	for (Decompressions_t::const_iterator i = m_decompressions.begin() ;
		i != m_decompressions.end();
		++i
			)
	{
		if (m_bat)
		{
			printf("expand %s %s\n", i->m_from.c_str(), i->m_to.c_str());
		}
		else
		{
			if (!SetupIterateCabinet(i->m_from.c_str(), 0, CabinetCallback, const_cast<void*>(static_cast<const void*>((&i->m_to)))))
			{
				Error = GetLastError();
				fprintf(stderr, ("SetupIterateCabinet(" + i->m_from + ", " + i->m_to + ") failed, error %lu\n").c_str(), Error);
			}
		}
	}
}

void
Popcopy_t::CopyFile(
	const String_t& from,
	const String_t& to
    )
{
    unsigned long Error;
    if (m_copy)
    {
	    if (GetFileAttributes(from.c_str()) == -1)
	    {
		    Error = GetLastError();
		    if (Error == ERROR_FILE_NOT_FOUND
			    || Error == ERROR_PATH_NOT_FOUND
			    )
		    {
			    return;
		    }
		    fprintf(stderr, ("CopyFile(" + from + ", " + to + ") failed, error %lu\n").c_str(), Error);
	    }
	    if (!::CopyFile(from.c_str(), to.c_str(), FALSE))
	    {
		    Error = GetLastError();
		    fprintf(stderr, ("CopyFile(" + from + ", " + to + ") failed, error %lu\n").c_str(), Error);
	    }
    }
}

void
Popcopy_t::CopyFile(
    const std::string& partial
    )
{
    //unsigned long Error;
	bool comp = false;

    String_t fromfull = JoinPaths(m_from, partial);
    String_t tofull = JoinPaths(m_to, partial);

	String_t partialcomp = partial;
	// if no extension, append "._"
	// if extension shorter than three chars, append "_"
	// if extension is three or more chars, change last char to "_"
	std::string::size_type dot = partial.find_last_of(".");
	std::string::size_type sep = partial.find_last_of("\\/");
	if (dot == npos || (sep != npos && dot < sep))
	{
		partialcomp = partial + "._";
	}
	else if (partialcomp.length() - dot < 4)
	{
		partialcomp = partial + "_";
	}
	else
	{
		partialcomp = partial.substr(0, partial.length() - 1) + "_";
	}
	//printf("partial=%s, partialcomp=%s\n", partial.c_str(), partialcomp.c_str());

	//
	// check for the comp file
	//
	String_t fromcompfull = JoinPaths(m_fromcomp, partialcomp);
	String_t tocompfull;
	if (GetFileAttributes(fromcompfull.c_str()) != -1)
	{
		fromfull = fromcompfull;
		comp = true;
		tocompfull = JoinPaths(m_tocomp, partialcomp);
	}

    if (m_bat)
    {
		if (comp)
		{
			printf("copy %s %s\n", fromcompfull.c_str(), tocompfull.c_str());
			QueueDecompression(tocompfull, tofull);
		}
		else
		{
			printf("copy %s %s\n", fromfull.c_str(), tofull.c_str());
		}
    }
    else
    {
		if (comp)
		{
			CopyFile(fromcompfull, tocompfull);
			QueueDecompression(tocompfull, tofull);
		}
        else
		{
			CopyFile(fromfull, tofull);
		}
    }
}

void Popcopy_t::Main(
    const StringVector_t& args
    )
{
    const String_t::size_type npos = String_t::npos;
    StringVector_t::const_iterator i;
	time_t    time1;
	time_t    time2;

	::time(&time1);
	printf("start time %s\n", ctime(&time1));

    for (
        i = args.begin();
        i != args.end();
        ++i
        )
    {
        String_t arg = *i;
        if (arg[0] == '-' || arg[0] == '/')
        {
            arg = arg.substr(1);
            String_t value = "true";
            String_t::size_type equals;
            if (
                (arg[0] == 'n' || arg[0] == 'N')
                && (arg[1] == 'o' || arg[1] == 'O')
                )
            {
                value = "false";
                arg = arg.substr(2);
            }
            else if (
                (equals = arg.find_first_of('=')) != npos
                || (equals = arg.find_first_of(':')) != npos
                )
            {
                value = arg.substr(1 + equals);
                arg = arg.substr(0, equals);
            }
            m_options[arg] = value;
        }
    }
	m_from = RemoveTrailingSlashes(m_options["from"]);
    if (IsFalse(m_from) || IsTrue(m_from))
    {
        CommandLineError("missing required parameter \"from\"");
    }
	m_fromcomp = JoinPaths(m_from, "comp");

	m_to = RemoveTrailingSlashes(m_options["to"]);
    if (IsFalse(m_to) || IsTrue(m_to))
    {
        CommandLineError("missing required parameter \"to\"");
    }
	m_tocomp = JoinPaths(m_to, "comp");

    m_copy = !IsFalse(m_options["copy"]);

    ReadBinlist();

    m_bat = IsTrue(m_options["bat"]);

    if (IsFalse(m_options["symonly"]))
    {
        for (i = m_binlist.m_directories.begin() ; i != m_binlist.m_directories.end() ; ++i)
            this->CreateDirectory(*i);
        for (i = m_binlist.m_files.begin() ; i != m_binlist.m_files.end() ; ++i)
            this->CopyFile(*i);

		DoQueuedDecompressions();
		//
		// we make a bunch of extra empty comp directories, so delete any empty directories
		//
        for (i = m_binlist.m_directories.begin() ; i != m_binlist.m_directories.end() ; ++i)
            ::RemoveDirectory(i->c_str());
    }
    if (IsTrue(m_options["symonly"]) || IsTrue(m_options["sym"]) || IsTrue(m_options["symbols"]))
    {
        for (i = m_binlist.m_symdirectories.begin() ; i != m_binlist.m_symdirectories.end() ; ++i)
            this->CreateDirectory(*i);
        for (i = m_binlist.m_symfiles.begin() ; i != m_binlist.m_symfiles.end() ; ++i)
            this->CopyFile(*i);
    }

	::time(&time2);
	printf("start time %s\n", ctime(&time1));
	printf("ending time %s\n", ctime(&time2));
}

int __cdecl main(int argc, char** argv)
{
    Popcopy_t popcopy;
    StringVector_t args;
    std::copy(argv + 1, argv + argc, std::back_inserter(args));
    popcopy.Main(args);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PragmaUnsafe.rc
//
#define IDS_PROJNAME                    100
#define IDR_PragmaUnsafe                    101
#define IDR_PragmaUnsafeModule              203

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft Corporation. All rights reserved.
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently
//

#pragma once

#pragma warning(disable: 4786)


/////////////////////////////////////////////////////////////////////////////
// Standard C/C++ includes


/////////////////////////////////////////////////////////////////////////////
// ATL includes

#define STRICT
	#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
using namespace ATL;


/////////////////////////////////////////////////////////////////////////////
// PREfast included

#include <pftDbg.h>
#include <pftCOM.h>
#include <pftEH.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\pragmaunsafemodule.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft Corporation. All rights reserved.
// PragmaUnsafeModule.h : Declaration of the CPragmaUnsafeModule class.
//

#pragma once

#include "resource.h"
#include <IPREfastModuleImpl.h>


/////////////////////////////////////////////////////////////////////////////
// {5686D66D-BE0D-43DA-B315-64B85BAFB790}
extern "C" const __declspec(selectany) GUID CLSID_PragmaUnsafeModule =
	{0x5686D66D,0xBE0D,0x43DA,{0xB3,0x15,0x64,0xB8,0x5B,0xAF,0xB7,0x90}};


/////////////////////////////////////////////////////////////////////////////
// Declaration of CPragmaUnsafeModule
//
class ATL_NO_VTABLE CPragmaUnsafeModule :
	public IPREfastModuleImpl<CPragmaUnsafeModule>,
	public CComObjectRootEx<CComObjectThreadModel>, 
	public CComCoClass<CPragmaUnsafeModule, &CLSID_PragmaUnsafeModule>
{
// Declarations
public:
	DECLARE_REGISTRY_RESOURCEID(IDR_PragmaUnsafeModule)
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_PREFAST_MODULE_ID(8888);

// Interface Map
public:
	BEGIN_COM_MAP(CPragmaUnsafeModule)
		COM_INTERFACE_ENTRIES_IPREfastModuleImpl()
	END_COM_MAP()

// Category Map
public:
	BEGIN_CATEGORY_MAP(CPragmaUnsafeModule)
	  IMPLEMENTED_CATEGORY(CATID_PREfastDefectModules)
	END_CATEGORY_MAP()

// Implementation
protected:
	// Analysis member functions.
	void CheckNode(ITree* pNode, DWORD level);
	void CheckNodeAndDescendants(ITree* pNode, DWORD level);

// IPREfastModule Interface Methods
public:
	STDMETHODIMP raw_Events(AstEvents *Events);
	STDMETHODIMP raw_OnFileStart(ICompilationUnit* pcu);
	STDMETHODIMP raw_OnDeclaration(ICompilationUnit* pcu);
	STDMETHODIMP raw_OnFunction(ICompilationUnit* pcu);
	STDMETHODIMP raw_OnFileEnd(ICompilationUnit* pcu);
	STDMETHODIMP raw_OnDirective(ICompilationUnit* pcu);

// Data Members
protected:
	// The pointer to the function being analyzed.
	ITreePtr m_spCurrFunction;

// Warning Codes
public:
    // Include defect description information
    #include <DefectDefs.h>
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\pragmaunsafemodule.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft Corporation. All rights reserved.
// PragmaUnsafeModule.cpp : Implementation of the CPragmaUnsafeModule class.
//

#include "stdafx.h"
#include <pftAST.h>
#include "PragmaUnsafeModule.h"
#include "sxsplugMap.h"

//
// global variable
//
PragmaUnsafe_UNSAFE_FUNCTIONS Sxs_PragmaUnsafedFunctions;
BOOL PragmaUnsafe_IsPossiblePointer(ICType * PtrSymbolType)
{ 
    // case 1:
    // a pointer variable
    //
    if (PtrSymbolType->Kind() == TY_POINTER)
        return TRUE;

    // case 2:
    // a func return type is a pointer, 
    //
    if (PtrSymbolType->Kind() == TY_FUNCTION)
    {
        //
        // check its return type
        //
        ICTypePtr spType;
        spType = PtrSymbolType->Returns();

        if ((spType != NULL) && (spType->Kind() == TY_POINTER))
        {
            return TRUE;
        }
    }

    return FALSE;    
}

/////////////////////////////////////////////////////////////////////////////
// Implementation

//
// Checks an individual tree node for errors.
//
void CPragmaUnsafeModule::CheckNode(ITree* pNode, DWORD level)
{
    // Get the tree node kind and check for possible errors.
    AstNodeKind kind = pNode->Kind();
    
    // TODO: Add case statements to check for your defects
    switch (kind)
    {
        //
        // check pragma unsafe functions
        //
        case AST_FUNCTIONCALL:        
            {
                if (pNode->IsCompilerGenerated() == VARIANT_FALSE)
                {
                    // try to display the function name and its parameters:                    
                    ITreePtr spFunction = skip_casts_and_parens(pNode->Child(0));

                    _bstr_t bstrFunc= get_function_name(spFunction);       
                    if (bstrFunc.length() > 0)
                    {
                        if (FC_DIRECT == pNode->CallKind() || (FC_INTRINSIC == pNode->CallKind()))
                        {
                            if (FALSE == Sxs_PragmaUnsafedFunctions.IsFunctionNotUnsafe((char *)bstrFunc))
                            {
                                ReportDefectFmt(spFunction, WARNING_REPORT_UNSAFE_FUNCTIONCALL, static_cast<BSTR>(bstrFunc));
                                //ReportDefect(pNode, WARNING_INVALID_PRAGMA_UNSAFE_STATEMENT);
                            }
                        }                    
                    }
                }
            }
            break;

        //
        // declare pragma unsafe functions : disable, enable, push, pop
        //
        case AST_PRAGMA:
            {
                if ((pNode->Child(0) != NULL) && (pNode->Child(0)->Kind() == AST_STRING))
                {                
                    _bstr_t bstrStringValue = pNode->ExpressionValue();
                    PRAGMA_STATEMENT ePragmaUnsafe;
                    PragmaUnsafe_OnPragma((char *)bstrStringValue, ePragmaUnsafe);
                    switch (ePragmaUnsafe){
                        case PRAGMA_NOT_UNSAFE_STATEMENT:
                            PragmaUnsafe_LogMessage("not a pragma unsafe\n");
                            break;
                        case PRAGMA_UNSAFE_STATEMENT_VALID:
                            PragmaUnsafe_LogMessage("a valid a pragma unsafe\n");
                            break;
                        case PRAGMA_UNSAFE_STATEMENT_INVALID:
                            ReportDefect(pNode, WARNING_INVALID_PRAGMA_UNSAFE_STATEMENT);
                            break;
                    } // end of switch (ePragmaUnsafe)
                }
            }
            break;
        //
        // pointer arithmatic : + , - * % \
        //
        case AST_PLUS:
        case AST_MINUS:
        case AST_MULT:
        case AST_DIV:
        case AST_REM: 
            {
                //
                // check whether pointer is involved in the operation of its 2 children
                //
                for (DWORD i=0 ; i<2; i++)
                {
                    ITreePtr subChildTreePtr = skip_parens(pNode->Child(i));
                    if ((subChildTreePtr != NULL) && (subChildTreePtr->Kind() == AST_SYMBOL))
                    {
                        if ((subChildTreePtr->Symbol() != NULL) && (subChildTreePtr->Symbol()->Type() != NULL))
                        {
                            if (PragmaUnsafe_IsPossiblePointer(subChildTreePtr->Symbol()->Type()))
                            {
                                if (FALSE == PragmaUnsafe_IsPointerArithmaticEnabled())
                                {
                                    ReportDefect(pNode, WARNING_REPORT_UNSAFE_POINTER_ARITHMATIC);
                                }
                            }
                        }
                    }
                }
            }
            break;
        default:
            break;
        
    } // end of switch (kind)
}
//
// Traverses the tree rooted at pNode and calls CheckNode() on each node.
//
void CPragmaUnsafeModule::CheckNodeAndDescendants(ITree* pNode, DWORD level)
{
    // Check if we need to abort.
    //CheckAbortAnalysis();

    // Do nothing if the specified node is NULL
    if (pNode == NULL)
        return;

    // Check the root for defects.
    CheckNode(pNode, level);

    // Get an iterator over the set of children.
    ITreeSetPtr   spChildrenSet = pNode->Children();
    IEnumTreesPtr spChildrenEnum = spChildrenSet->_NewEnum();
    ITreePtr      spCurrChild;

    // Iterate thru the children and recursively check them for errors.
    while (true)
    {
        long numReturned;
        spCurrChild = spChildrenEnum->Next(1, &numReturned);

        if (numReturned == 1)
        {
            CheckNodeAndDescendants(spCurrChild, level+1);
        }
        else
        {
            break;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// IPREfastModule Interface Methods


//
// No implementation.
//
STDMETHODIMP CPragmaUnsafeModule::raw_Events(AstEvents *Events)
{
    *Events = static_cast<AstEvents>(EVENT_FUNCTION | EVENT_DIRECTIVE | EVENT_FILESTART | EVENT_FILE);

    return S_OK;
}

//
// No implementation.
//
STDMETHODIMP CPragmaUnsafeModule::raw_OnFileStart(ICompilationUnit * pcu)
{
    if (PragmaUnsafe_OnFileStart())
        return S_OK;
    else
        return E_FAIL;
}

//
// No implementation.
//
STDMETHODIMP CPragmaUnsafeModule::raw_OnDeclaration(ICompilationUnit * pcu)
{
    // Indicate success
    return S_OK;
}

//
// No implementation.
//
STDMETHODIMP CPragmaUnsafeModule::raw_OnFileEnd(ICompilationUnit * pcu)
{
    if (PragmaUnsafe_OnFileEnd())
        return S_OK;
    else
        return E_FAIL;
}

//
// No implementation.
//
STDMETHODIMP CPragmaUnsafeModule::raw_OnDirective(ICompilationUnit * pcu)
{    
    if (pcu->Root()->Kind() != AST_PRAGMA)
        return S_OK;

    ITreePtr CurDirective = pcu->Root()->Child(0);    
    if (CurDirective->Kind() != AST_STRING)
    {
        _bstr_t sKind = CurDirective->KindAsString();
        printf("the type is %s\n", (char *)sKind);
        return S_OK;
    }

    _bstr_t bstrStringValue = CurDirective->ExpressionValue();
    if (bstrStringValue.length() == 0)
        return S_OK;

    PRAGMA_STATEMENT ePragmaUnsafe;
    PragmaUnsafe_OnPragma((char *)bstrStringValue, ePragmaUnsafe);
    if ((ePragmaUnsafe == PRAGMA_NOT_UNSAFE_STATEMENT) || (ePragmaUnsafe == PRAGMA_UNSAFE_STATEMENT_VALID))
        return S_OK;    
    else    
        return E_FAIL;
}

//
// Entry point for analysing functions.
//
STDMETHODIMP CPragmaUnsafeModule::raw_OnFunction(ICompilationUnit * icu)
{
    // Save the function pointer for error reporting.
    m_spCurrFunction = icu->Root();
    cStartTimeOfFunction = GetTickCount();

    try 
    {
        // Recursively check the function body.
        CheckNodeAndDescendants(m_spCurrFunction, 0);
    }
    catch (CAbortAnalysis)
    {
        // Ignore this exception and log all the others.
        printf("aborted\n");
    }

    // Release the objects.
    m_spCurrFunction = NULL;
    ClearDefectList();    

    // Indicate success
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft Corporation. All rights reserved.
// stdafx.cpp : source file that includes just the standard includes
// Hresult.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
	#include <statreg.h>
	#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\sxsplugmap.cpp ===
#include "stdafx.h"
#include "sxsplugMap.h"

#define PRAGMA_UNSAFE_DELIMITER_DEFAULT                         ' '
#define PRAGMA_UNSAFE_DELIMITER_BETWEEN_STATEMENT               ';'
#define PRAGMA_UNSAFE_DELIMITER_BETWEEN_VALUESTR                ','
#define PRAGMA_UNSAFE_DELIMITER_BETWEEN_KEYWORD_AND_VALUESTR    ':'

#define PRAGMA_UNSAFE_KEYWORD_UNSAFE                            "unsafe"
#define PRAGMA_UNSAFE_KEYWORD_UNSAFE_PUSH                       "push"
#define PRAGMA_UNSAFE_KEYWORD_UNSAFE_DISABLE                    "disable"
#define PRAGMA_UNSAFE_KEYWORD_UNSAFE_ENABLE                     "enable"
#define PRAGMA_UNSAFE_KEYWORD_UNSAFE_POP                        "pop"

#define PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_ENABLE       0
#define PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_DISABLE      1

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::ReInitialize()
{
    m_UnsafeFuncs.clear(); // void function
    m_fInitialized = FALSE;   

    return this->Initialize();
}

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::Initialize()
{
    ASSERT(m_fInitialized == FALSE);
    m_index = 0;
    BOOL fSuccess = AddFunctionIntoStack(POINTER_ARITHMATIC_FUNC);
    if (fSuccess) 
        m_fInitialized = TRUE;   

    return fSuccess;
}

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::IsFunctionNotUnsafe(const char * strFuncName)
{
    BOOL fSafe = TRUE; // defaultly all function are SAFE
    PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::iterator pIter;    
        
    if (true == m_UnsafeFuncs.empty())    
        return TRUE;

    DWORD CurrentIndex = m_index - 1;
    for (pIter = m_UnsafeFuncs.begin(); pIter != m_UnsafeFuncs.end(); pIter ++)
    {                
        if (pIter->first.compare(strFuncName) == 0)
        {
            PragmaUnsafe_FUNCTION_STATUS & FuncStatusRecord = pIter->second; 
            //
            // get current status : enabled or not       
            //
            BYTE x = (FuncStatusRecord[CurrentIndex / sizeof(BYTE)] & (1 << (CurrentIndex % sizeof(BYTE)))) >> (CurrentIndex % sizeof(BYTE));            
            // duplicate last status
            if (x == 0){
                fSafe = FALSE;
            }
            break; // find a result already
        }
    } 
    
    return fSafe;
}

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::OnUnsafeDisable(const char * strFuncNameGroups)
{
    if (FALSE == IsInitialized())
    {
        PragmaUnsafe_ReportError("Not Initialized !!!\n");        
        return FALSE;
    }
    if (IsStackFull())
    {
        PragmaUnsafe_ReportError("Stack is Full Sized now!\n");
        return FALSE;
    }

    return ResetStack(strFuncNameGroups, false);
}

VOID CPragmaUnsafe_UnsafeFunctionStateStack::PackStack()
{
    if ( m_index == 0)
        return;

    BYTE AllEnabledStatus[8];
    for ( DWORD i = 0; i < (m_index - 1) / sizeof(BYTE); i++)
        AllEnabledStatus[i] = 0xFF;    
    AllEnabledStatus[(m_index - 1) / sizeof(BYTE)] = ((1 << (((m_index - 1)% sizeof(BYTE)) + 1)) - 1) & 0xFF;
        
    //    
    // if from 0..m_index - 1, all state is enabled: just delete this function from the map
    //
    for (PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::iterator pIter = m_UnsafeFuncs.begin(); pIter != m_UnsafeFuncs.end(); pIter ++)
    {
        if (memcmp((PVOID)(&pIter->second[0]), AllEnabledStatus, PragmaUnsafe_STACK_SIZE_IN_BYTE) == 0)        
            m_UnsafeFuncs.erase(pIter->first);        
    }

    //
    // no func in the stack, clean the map and reset m_index == 0;
    //
    if (m_UnsafeFuncs.empty())
    {
        m_UnsafeFuncs.clear();
        m_index = 0;
    }
}

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::OnUnsafePop()
{
    if (FALSE == IsInitialized())
    {
        PragmaUnsafe_ReportError("Not Initialized !!!\n");
        return FALSE;
    }

    ASSERT(m_index > 0);

    if (IsStackEmpty())
    {
        PragmaUnsafe_ReportError("Stack is current empty!\n");
        return FALSE;
    }

    m_index--; 
    if (m_index == 0)
    {
        m_UnsafeFuncs.clear(); // delete the map
    }

    PackStack(); // void function
    return TRUE;
}

BOOL CPragmaUnsafe_UnsafeFunctionStateStack::OnUnsafePush()
{
    BOOL fSuccess = FALSE;
    PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::iterator pIter, qIter;
    string strFuncName;
    DWORD CurrentIndex;
    if (FALSE == IsInitialized())
    {
        PragmaUnsafe_ReportError("Not Initialized !!!\n");
        goto Exit;
    }

    if (IsStackFull())
    {
        PragmaUnsafe_ReportError("Stack is Full Sized now!\n");
        goto Exit;
    }

    CurrentIndex = (m_index - 1);
    ASSERT(CurrentIndex >= 0); //because we have check that the stack is not empty
    
    for (pIter = m_UnsafeFuncs.begin(); pIter != m_UnsafeFuncs.end(); pIter ++)
    {
        PragmaUnsafe_FUNCTION_STATUS & FuncStatusRecord = pIter->second; // ref is return...

        //
        // get current status of each function
        //
        
        BYTE x = (FuncStatusRecord[CurrentIndex / sizeof(BYTE)] & (1 << (CurrentIndex % sizeof(BYTE)))) >> (CurrentIndex % sizeof(BYTE));
        ASSERT((x == 0) || (x == 1));

        // duplicate last status
        if ( x == 1)
            FuncStatusRecord[m_index / sizeof(BYTE)] |= ((1 << (m_index % sizeof(BYTE))) & 0x00ff);
        else 
            FuncStatusRecord[m_index / sizeof(BYTE)] &= (~((1 << (m_index % sizeof(BYTE))) & 0x00ff) & 0x00ff);
    } 

    m_index ++;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}
BOOL CPragmaUnsafe_UnsafeFunctionStateStack::OnUnsafeEnable(const char * strFuncNameGroups)
{
    if (FALSE == IsInitialized())
    {
        PragmaUnsafe_ReportError("Not Initialized !!!\n");
        return FALSE;
    }

    if (IsStackEmpty())
    {
        PragmaUnsafe_ReportError("Stack is Empty now!\n");
        return TRUE;
    }

    return ResetStack(strFuncNameGroups, true);
}

// if a function is already in the stack, change current status
// if a function is not in the stack:
//      if you try to disable it : add it to the stack and would disfunction after pop is done
//      if you try to enable it :  we cannot igore it in case that it go with a push and later a pop, so 
//          just add it to the stack and would disfunction after pop is done
BOOL CPragmaUnsafe_UnsafeFunctionStateStack::ResetStack(const char * strFuncNameGroups, bool fEnable)
{
    BOOL fSuccess = FALSE;
    PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::iterator pIter, qIter;
    string strFuncName;
    istrstream streamFuncNameStream(strFuncNameGroups);
    DWORD CurIndex;

    //
    // suppose that the func names are delimited using ;
    // for each function which reset status
    //
    for (; getline(streamFuncNameStream, strFuncName, PRAGMA_UNSAFE_DELIMITER_BETWEEN_VALUESTR); )
    {
        if (strFuncName.empty())
            break;

        qIter =  m_UnsafeFuncs.find(strFuncName);
        //
        // this function is not on map currently, 
        //
        if (qIter == m_UnsafeFuncs.end())
        {
            //
            // adding into the stack as a disabled function, see the comments at the function declaration
            //
            if ( FALSE == AddFunctionIntoStack(strFuncName.c_str(), fEnable))
            {
                PragmaUnsafe_ReportError("AddFunctionIntoStack for %s failed\n", strFuncName.c_str());                
            }
            continue;            
        }
        ASSERT(m_index > 0);
        CurIndex = m_index - 1;

        PragmaUnsafe_FUNCTION_STATUS & FuncStatusRecord = qIter->second;

        // overwrite the current status
        if (fEnable == true)
            FuncStatusRecord[CurIndex / sizeof(BYTE)] |=  ((1 << (CurIndex % sizeof(BYTE))) & 0xff);
        else
            FuncStatusRecord[CurIndex / sizeof(BYTE)] &= (~((1 << (CurIndex % sizeof(BYTE))) & 0xff) & 0xff);
    }

    fSuccess = TRUE;

    return fSuccess;
}

void TrimString(string & strFuncName, DWORD dwFlag = STRING_TRIM_FLAG_LEFT | STRING_TRIM_FLAG_RIGHT)
{
    int i;

    if (dwFlag & STRING_TRIM_FLAG_LEFT)
    {   
        // left trim
        i = 0;
        while ((strFuncName[i] == ' ') && (i < strFuncName.length())) i++;
        if ( i > 0)
            strFuncName.erase(0,i);
    }

    if (dwFlag & STRING_TRIM_FLAG_RIGHT)
    {       
        // right trim
        i = strFuncName.length() - 1;
        while ((strFuncName[i] == ' ') && (i >= 0 )) i--;
        if ( i != strFuncName.length() - 1)
            strFuncName.erase(i, (strFuncName.length() - i));
    }

    return;
}

//
// when this function is called, this func must not in the current stack
//
BOOL CPragmaUnsafe_UnsafeFunctionStateStack::AddFunctionIntoStack(const char * strFuncNameGroups, bool fEnabled)
{
    BOOL fSuccess = FALSE;

    string strFuncName;
    istrstream streamFuncNameStream(strFuncNameGroups);
    PragmaUnsafe_FUNCTION_STATUS new_func_status;
    DWORD CurrentIndex;

    if (m_index == 0)
        m_index ++;

    //
    // suppose that the func names are delimited using ;
    //
    CurrentIndex = m_index -1 ;     

    for (; getline(streamFuncNameStream, strFuncName, PRAGMA_UNSAFE_DELIMITER_BETWEEN_VALUESTR); )
    {    
        if (strFuncName.empty())
            break;
        
        TrimString(strFuncName); // left-trim and right-trim

        if (strFuncName.empty())
            break;
        
        if (m_UnsafeFuncs.find(strFuncName) != m_UnsafeFuncs.end())        
        {
            //
            // If the function has already in the map, we just ignore it.
            // This would deal with a header file with "#pragam unsafe(disable: func1)" is included multiple times.
            // that is, if the sequence is 
            //  #pragam unsafe(disable: func1)
            //      #pragam unsafe(push, enable:func1)
            //          #pragam unsafe(disable:func1) ---> would be ignored, and func1 is still enabled at this moment  
            //      #pragam unsafe(pop)
            // 
            // in this case, a warning message would be issued

            //PragmaUnsafe_ReportWarning(PragmaUnsafe_PLUGIN_WARNING_MSG_PREFIX, "%s has already been disabled\n", strFuncName);            
            PragmaUnsafe_ReportError("%s has already been disabled\n", strFuncName.c_str());
            continue;
        }

        ZeroMemory(&new_func_status, sizeof(new_func_status));  // grow to the same size as all other functions


        // set to be "1" for the range of 0..CurrentIndex-1
        if (CurrentIndex > sizeof(BYTE) + 1)
        {            
            for (int i = 0 ; i < ((CurrentIndex - 1) / sizeof(BYTE)); i++)
                new_func_status[i] = 0xFF;
        }

        if (fEnabled == true)
        {           
            new_func_status[CurrentIndex / sizeof(BYTE)] = ((1 << ((CurrentIndex % sizeof(BYTE)) + 1)) - 1) & 0xFF;
        } 
        else 
        {
            new_func_status[CurrentIndex / sizeof(BYTE)] = ((1 << (CurrentIndex % sizeof(BYTE))) - 1) & 0xFF;
        }

        m_UnsafeFuncs.insert(PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::value_type(strFuncName, new_func_status));
    }

    fSuccess = TRUE;
//Exit:
    return fSuccess;
}
VOID CPragmaUnsafe_UnsafeFunctionStateStack::PrintFunctionCurrentStatus(int level)
{
    PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS::iterator pIter, qIter;
    cout << endl << endl << "CurrentStack:" << endl;
    cout << "m_index = " << m_index << endl;

    //
    // for each current item in map, push to preserve its current status
    //
    if (m_index == 0)
    {        
        return;
    }

    DWORD CurrentIndex = (m_index - 1);
    BYTE x;
    for (pIter = m_UnsafeFuncs.begin(); pIter != m_UnsafeFuncs.end(); pIter ++)
    {
        PragmaUnsafe_FUNCTION_STATUS & FuncStatusRecord = pIter->second; // ref is return...

        //
        // get current status of each function
        //
        
        x = (FuncStatusRecord[CurrentIndex / sizeof(BYTE)] & (1 << (CurrentIndex % sizeof(BYTE)))) >> (CurrentIndex % sizeof(BYTE));        
        for ( int j = 0 ; j < level; j++)
            cout << "    ";
        cout << pIter->first << ":"<< ((x == 0) ? "Disabled" : "Enabled") << endl;
    }    

    return;    
}

//
// this function is only called when the end of file is reached
//
BOOL CPragmaUnsafe_UnsafeFunctionStateStack::CheckIntegrityAtEndOfFile()
{
    if (m_index == 1) // should always be 1 since pointer_arithmatic is default
        return TRUE;
    else
        return FALSE;
}

/*
at each file beginning: reset the pragma stack because of its file-range
*/
BOOL PragmaUnsafe_OnFileStart()
{
    //
    // initalize the map structure everytime when prefast start to parse
    //
    return Sxs_PragmaUnsafedFunctions.ReInitialize();
}

/*
at each file end: verify integrity of the stake
*/
BOOL PragmaUnsafe_OnFileEnd()
{
    //Sxs_PragmaUnsafedFunctions.PrintFunctionCurrentStatus(0);
    return Sxs_PragmaUnsafedFunctions.CheckIntegrityAtEndOfFile();
}

VOID PragmaUnsafe_GetUsafeOperParameters(DWORD dwFlag, const string & strPragmaUnsafeSingleStatement, string & strFuncNameList)
{
    // initialize
    strFuncNameList.erase();

    int iPrefix = 0;
    if ( dwFlag == PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_ENABLE)
        iPrefix = strlen(PRAGMA_UNSAFE_KEYWORD_UNSAFE_ENABLE);
    else if ( dwFlag == PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_DISABLE)
        iPrefix = strlen(PRAGMA_UNSAFE_KEYWORD_UNSAFE_DISABLE);
   
    if (iPrefix == 0) // error case
    {
        goto ErrorExit;
    }

    strFuncNameList.assign(strPragmaUnsafeSingleStatement);
    strFuncNameList.erase(0, iPrefix);

    TrimString(strFuncNameList);
    // should be in the format of [enable|disbale]: func1, func2, func3
    if (strFuncNameList[0] != PRAGMA_UNSAFE_DELIMITER_BETWEEN_KEYWORD_AND_VALUESTR) 
    {
        goto ErrorExit;
    }
    strFuncNameList.erase(0, 1); // get rid :
    TrimString(strFuncNameList);
    goto Exit;

ErrorExit:
    if (!strFuncNameList.empty())
        strFuncNameList.erase();
Exit:
    return;
}

BOOL PragmaUnsafe_OnPragma(char * str, PRAGMA_STATEMENT & ePragmaUnsafe)
{
    BOOL fSuccess = FALSE;
    istrstream streamParagmaString(str);
    string strPragmaUnsafeSingleStatement;
    string strFuncNameList;

    ePragmaUnsafe = PRAGMA_NOT_UNSAFE_STATEMENT;
    
    //
    // check whether it begins with "unsafe", that is, its prefix is "unsafe:"
    // get the first string which is sperate from the left using ' '
    //
    getline(streamParagmaString, strPragmaUnsafeSingleStatement, ':');
    TrimString(strPragmaUnsafeSingleStatement); // void func
    if (true == strPragmaUnsafeSingleStatement.empty())
    {
        ePragmaUnsafe = PRAGMA_NOT_UNSAFE_STATEMENT;
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // pragam unsafe keyword comparsion is case-sensitive
    //
    if (strncmp(strPragmaUnsafeSingleStatement.c_str(), PRAGMA_UNSAFE_KEYWORD_UNSAFE, strlen(PRAGMA_UNSAFE_KEYWORD_UNSAFE)) != 0)
    {
        // not start with Keyword "unsafe"
        ePragmaUnsafe = PRAGMA_NOT_UNSAFE_STATEMENT;
        fSuccess = TRUE;
        goto Exit;
    }

    // so far, the statement is valid
    ePragmaUnsafe = PRAGMA_UNSAFE_STATEMENT_VALID;

    for (; getline(streamParagmaString, strPragmaUnsafeSingleStatement, PRAGMA_UNSAFE_DELIMITER_BETWEEN_STATEMENT); )
    {
        //
        // to get a statement begin with "push", or "enable", or "disable", or "pop", 
        // we deal with push/pop first because they are non-parameter statements        
        //
        TrimString(strPragmaUnsafeSingleStatement);
        if (strPragmaUnsafeSingleStatement.compare(PRAGMA_UNSAFE_KEYWORD_UNSAFE_PUSH) == 0)
        {
            Sxs_PragmaUnsafedFunctions.OnUnsafePush();
        } 
        else 
        if (strPragmaUnsafeSingleStatement.compare(PRAGMA_UNSAFE_KEYWORD_UNSAFE_POP) == 0)
        {
            Sxs_PragmaUnsafedFunctions.OnUnsafePop();
        }
        else
        if (strncmp(strPragmaUnsafeSingleStatement.c_str(), PRAGMA_UNSAFE_KEYWORD_UNSAFE_ENABLE, strlen(PRAGMA_UNSAFE_KEYWORD_UNSAFE_ENABLE)) == 0)
        {              
            PragmaUnsafe_GetUsafeOperParameters(PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_ENABLE, strPragmaUnsafeSingleStatement, strFuncNameList);
            if (strFuncNameList.empty())
            {
                PragmaUnsafe_ReportError("Invalid string for pragma unsafe: %s\n", strPragmaUnsafeSingleStatement.c_str());
                goto Exit;
            }
            else
            {
                Sxs_PragmaUnsafedFunctions.OnUnsafeEnable(strFuncNameList.c_str());
            }
        }
        else
        if (strncmp(strPragmaUnsafeSingleStatement.c_str(), PRAGMA_UNSAFE_KEYWORD_UNSAFE_DISABLE, strlen(PRAGMA_UNSAFE_KEYWORD_UNSAFE_DISABLE)) == 0)
        {
            PragmaUnsafe_GetUsafeOperParameters(PRAGMA_UNSAFE_GETUSAFEOPERPARAMETERS_DWFLAG_UNSAFE_DISABLE, strPragmaUnsafeSingleStatement, strFuncNameList);
            if (strFuncNameList.empty())
            {
                PragmaUnsafe_ReportError("Invalid string for pragma unsafe: %s\n", strPragmaUnsafeSingleStatement.c_str());
                goto Exit;
            }
            else
            {
                Sxs_PragmaUnsafedFunctions.OnUnsafeDisable(strFuncNameList.c_str());
            }
        }
        else
        {
            // invalid string in pragma beginning with "unsafe"
            ePragmaUnsafe = PRAGMA_UNSAFE_STATEMENT_INVALID;
            PragmaUnsafe_ReportError("Invalid string for pragma unsafe: %s\n", strPragmaUnsafeSingleStatement.c_str());
            goto Exit;
        }
    }
    //Sxs_PragmaUnsafedFunctions.PrintFunctionCurrentStatus(0);
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL PragmaUnsafe_IsPointerArithmaticEnabled()
{
    return Sxs_PragmaUnsafedFunctions.IsFunctionNotUnsafe(POINTER_ARITHMATIC_FUNC);
}

int ReportInternalError(int nLine)
{    
    _tprintf(TEXT("%hs(%d) : Internal Error Occurred\n"),
        __FILE__, nLine);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\prefast\plugin\sxsplugmap.h ===
#pragma once

#include "windows.h"
#include "assert.h"
#include <map>
#include <iostream>
#include <string>
#include <fstream>
#include <strstream>

#define POINTER_ARITHMATIC_FUNC "pointer_arithmatic"
int ReportInternalError(int nLine);

#define ASSERT assert
#define PragmaUnsafe_LogMessage         printf
#define PragmaUnsafe_ReportError ReportInternalError(__LINE__);printf("PragmaUnsafe: ");printf

using namespace std;
static const int PragmaUnsafe_MAX_PRAGMA_NEST_LEVEL = 64;
static const int STATUS_BYTE_ARRAY_SIZE = 8;
static const int PragmaUnsafe_STACK_SIZE_IN_BYTE = 8;

#define STRING_TRIM_FLAG_LEFT       0x01
#define STRING_TRIM_FLAG_RIGHT      0x02

class PragmaUnsafe_FunctionStatus{    
private:
    BYTE m_status[STATUS_BYTE_ARRAY_SIZE];
public:
    PragmaUnsafe_FunctionStatus(){
        ZeroMemory(&m_status, sizeof(m_status));
    }

    BYTE & operator [](const int i){ return m_status[i]; }
};

typedef class PragmaUnsafe_FunctionStatus PragmaUnsafe_FUNCTION_STATUS;

/*--------------------------------------------------------------------------------------
 (1) the stack is push/pop by BIT, that is, it is a BIT stack
 (2) max-size of the stack is 64, since it is 1 bit per state, totally we use 8 bytes
 (3) for each function, it has an associated CPragmaUnsafe_UnsafeFunctionStateStack 
--------------------------------------------------------------------------------------*/
class CPragmaUnsafe_UnsafeFunctionStateStack
{
private:
    typedef map<string, PragmaUnsafe_FUNCTION_STATUS> PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS;

    PragmaUnsafe_PRAGMA_UNSAFE_FUNCTIONS m_UnsafeFuncs;
    DWORD                       m_index;
    bool                        m_fInitialized;

    inline BOOL IsStackFull() { return (m_index == PragmaUnsafe_MAX_PRAGMA_NEST_LEVEL) ? TRUE : FALSE; }
    inline BOOL IsStackEmpty(){ return (m_index == 0) ? TRUE : FALSE; }    
    inline BOOL IsInitialized() {return (m_fInitialized == true) ? TRUE : FALSE; }
    
    //
    // (0) the stack is not FULL, that is, m_index < 64
    // (1) no push is needed because what we change is the current status
    // (2) the default value is always 0 because we add disabled function by "#pragma unsafe(disable: func)"
    //
    BOOL AddFunctionIntoStack(const char * strFuncNameGroups, bool fEnabled = false);
    BOOL ResetStack(const char * strFuncNameGroups, bool fEnable);
    VOID CPragmaUnsafe_UnsafeFunctionStateStack::PackStack();

public:
    BOOL OnUnsafeDisable(const char * strFuncNameGroups);
    BOOL OnUnsafePush();
    BOOL OnUnsafeEnable(const char * strFuncNameGroups);
    BOOL OnUnsafePop();

    VOID PrintFunctionCurrentStatus(int);
    BOOL CheckIntegrityAtEndOfFile();

    //
    // for plugin code to check whether a func is disable or not
    // return TRUE if the func is (1) not in the stack, (2) in the stack but the current status is enabled,
    // else return FALSE
    BOOL IsFunctionNotUnsafe(const char * strFuncName);    

    CPragmaUnsafe_UnsafeFunctionStateStack() : m_index(0), m_fInitialized(false) {}
    // put pointer_arithmatic as the first function to consider
    BOOL Initialize();
    BOOL ReInitialize();

};

typedef class CPragmaUnsafe_UnsafeFunctionStateStack PragmaUnsafe_UNSAFE_FUNCTIONS;
extern PragmaUnsafe_UNSAFE_FUNCTIONS Sxs_PragmaUnsafedFunctions;

typedef enum {
    PRAGMA_NOT_UNSAFE_STATEMENT = 0,
    PRAGMA_UNSAFE_STATEMENT_VALID,
    PRAGMA_UNSAFE_STATEMENT_INVALID
}PRAGMA_STATEMENT;

BOOL PragmaUnsafe_OnPragma(char * str, PRAGMA_STATEMENT & ePragmaUnsafe);
VOID PragmaUnsafe_GetUsafeOperParameters(DWORD dwFlag, const string & strPragmaUnsafeSingleStatement, string & strFuncNameList);
BOOL PragmaUnsafe_OnFileStart();
BOOL PragmaUnsafe_OnFileEnd();
BOOL PragmaUnsafe_OnPragma(char * str, PRAGMA_STATEMENT & ePragmaUnsafe);
BOOL PragmaUnsafe_IsPointerArithmaticEnabled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\preprocessor\stdinc.h ===
#if defined(_WIN64)
#define UNICODE
#define _UNICODE
#endif
#include <utility>
#pragma warning(disable:4663) /* C++ language change */
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#pragma warning(disable:4018) /* '<=' : signed/unsigned mismatch */
#pragma warning(disable:4389) /* '!=' : signed/unsigned */
#include "windows.h"
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <map>
#include <stdio.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
using std::wstring;
using std::string;
using std::vector;
using std::wistream;
using std::wifstream;
using std::getline;
using std::basic_string;
typedef CONST VOID* PCVOID;

class CByteVector : public std::vector<BYTE>
{
public:
    CByteVector() { }
    ~CByteVector() { }

    const BYTE* bytes() const { return &front(); }
          BYTE* bytes()       { return &front(); }

    operator PCSTR  () const { return reinterpret_cast<PCSTR>(this->bytes()); }
    operator PSTR   ()       { return reinterpret_cast<PSTR>(this->bytes()); }
    operator PCWSTR () const { return reinterpret_cast<PCWSTR>(this->bytes()); }
    operator PWSTR  ()       { return reinterpret_cast<PWSTR>(this->bytes()); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\preprocessor\win32file.cpp ===
#include "stdinc.h"
#include "win32file.h"
#include "atlbase.h"
#include "atlconv.h"

#define IS_NT() ((GetVersion() & 0x80000000) == 0)

using std::wstring;

void Win32File::snarfFullFile(wstring& output)
{
    output = L"";
    CByteVector bytes;
    DWORD dwReadSize = 0;

    bytes.resize(filesize() - filepointer());
    if (!ReadFile(_hFile, &bytes.front(), bytes.size(), &dwReadSize, NULL))
    {
        throw new ReadWriteError(false, ::GetLastError());
    }

    // Otherwise, bash the byte vector into a wstring for output
    output = ConvertToWstring(bytes, _type);
}




void Win32File::writeLine(const wstring& dump)
{
    CByteVector vb;
    DWORD dwWritten;

    vb = ConvertWstringToDestination(dump, _type);
    if (!WriteFile(_hFile, &vb.front(), vb.size(), &dwWritten, NULL))
        throw new ReadWriteError(true, ::GetLastError());
}



bool Win32File::eof() { return false; }

void
Win32File::openForRead(wstring wstname)
{
    USES_CONVERSION;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        throw new AlreadyOpened;
    }

    const PCWSTR pcwstr = wstname.c_str();
    const DWORD Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    _hFile =
        IS_NT() ? CreateFileW(pcwstr, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, Flags, NULL)
                : CreateFileA(W2A(pcwstr), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, Flags, NULL);

    if (_hFile == INVALID_HANDLE_VALUE || _hFile == NULL)
    {
        throw new OpeningError(GetLastError());
    }


    // If this was for reading, then sniff the first few bytes and see what kind
    // of file it is.
    DWORD dwReadBytes = 0;
    BYTE bBuffer[256];
    if (!ReadFile(_hFile, bBuffer, sizeof(bBuffer), &dwReadBytes, NULL))
    {
        throw new ReadWriteError(true, GetLastError());
    }

    // Now let's determine what kind of buffer we've got
    _type = DetermineFileTypeFromBuffer(bBuffer, dwReadBytes);
    _bOpenForRead = true;

    // Let's zip the file pointer past the first gunk
    SetFilePointer(_hFile, DetermineFileTypeSigSize(_type), NULL, FILE_BEGIN);

}




void
Win32File::openForWrite(wstring wstname, FileContentType fct, bool bOverwrite)
{
    USES_CONVERSION;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        throw new AlreadyOpened;
    }

    const DWORD OpenOrCreate = bOverwrite ? CREATE_ALWAYS : CREATE_NEW;
    const DWORD Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;
    PCWSTR pcwstr = wstname.c_str();

    _hFile =
        IS_NT() ? CreateFileW(pcwstr, GENERIC_WRITE, FILE_SHARE_READ, NULL, OpenOrCreate, Flags, NULL)
                : CreateFileA(W2A(pcwstr), GENERIC_WRITE, FILE_SHARE_READ, NULL, OpenOrCreate, Flags, NULL);

    if (_hFile == INVALID_HANDLE_VALUE || _hFile == NULL)
    {
        throw new OpeningError(GetLastError());
    }

    // Now that we have an open file, let's blop the signature bytes into it.
    DWORD dwWritten;
    DWORD dwToWrite;
    PCVOID pvWriteBuffer;
    switch (fct) {
    case FileContentsUnicode:
        pvWriteBuffer = UNICODE_SIGNATURE;
        dwToWrite = sizeof(UNICODE_SIGNATURE);
        break;
    case FileContentsUnicodeBigEndian:
        pvWriteBuffer = UNICODE_BIG_ENDIAN_SIGNATURE;
        dwToWrite = sizeof(UNICODE_BIG_ENDIAN_SIGNATURE);
        break;
    case FileContentsUTF8:
        pvWriteBuffer = NULL;
        dwToWrite = 0;
        break;
    default:
        pvWriteBuffer = UNICODE_SIGNATURE;
        dwToWrite = 0;
        break;
    }

    if (!WriteFile(_hFile, pvWriteBuffer, dwToWrite, &dwWritten, NULL) || (dwWritten != dwToWrite)) {
        throw new ReadWriteError(false, GetLastError());
    }

    _bOpenForRead = false;
    _type = fct;
}




Win32File::Win32File()
    : _hFile(INVALID_HANDLE_VALUE), _type(FileContentsUTF8),
      _bOpenForRead(false), _bEof(false)
{
}





Win32File::~Win32File() { if (_hFile != INVALID_HANDLE_VALUE) { CloseHandle(_hFile); } };


FileContentType DetermineFileTypeFromBuffer(unsigned char *data, int length)
{
    #define CHECKMARK(tp, ct) if ((length > sizeof(tp)) && (memcmp(data, tp, sizeof(tp)) == 0)) return ct;

    CHECKMARK(UNICODE_SIGNATURE, FileContentsUnicode);
    CHECKMARK(UNICODE_BIG_ENDIAN_SIGNATURE, FileContentsUnicodeBigEndian);
    CHECKMARK(UTF8_SIGNATURE, FileContentsUTF8);
    return FileContentsUTF8;
}

int DetermineFileTypeSigSize(FileContentType type)
{
    switch (type)
    {
        case FileContentsUnicode: return sizeof(UNICODE_SIGNATURE);
        case FileContentsUnicodeBigEndian: return sizeof(UNICODE_BIG_ENDIAN_SIGNATURE);
        case FileContentsUTF8:
        default: return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\resourcetool\handle.h ===
/*++

Copyright (c) Microsoft Dorporation

Module Name:

    Handle.h

Abstract:

    Simple exception safe wrappers of Win32 "handle" types, defining "handle" loosely.
        DFile
        DDynamicLinkLibrary
        DFindFile (should be named DFindFileHandle, see NVseeLibIo::CFindFile vs. NVseeLibIo::CFindFileHandle
            DFindFile includes a WIN32_FIND_DATA, DFindFileHandle does not.)
        DFileMapping
        DMappedViewOfFile
        DRegKey
    See also:
        NVseeLibReg::CRegKey
        NVseeLibIo::CFile
        NVseeLibIo::CFileMapping
        NVseeLibIo::CMappedViewOfFile
        NVseeLibIo::CFindFullPath
        NVseeLibModule::CDynamicLinkLibrary
        etc.
 
Author:

    Jay Krell (JayKrell) May 2000

Revision History:

--*/
#pragma once

#include <stddef.h>
#include "windows.h"
#include "PreserveLastError.h"

template <void* const* invalidValue, typename Closer>
class DHandleTemplate
{
public:
    // void* instead of HANDLE to fudge views
    // HANDLE is void*
    DHandleTemplate(const void* handle = *invalidValue);
    ~DHandleTemplate();
    BOOL Win32Close();
    void* Detach();
    void operator=(const void*);

    operator void*() const;
    operator const void*() const;

    // private
    class DSmartPointerPointerOrDumbPointerPointer
    {
    public:
        DSmartPointerPointerOrDumbPointerPointer(DHandleTemplate* p) : m(p) { }
        operator DHandleTemplate*() { return m; }
        operator void**() { /*assert((**m).m_handle == *invalidValue);*/ return &(*m).m_handle; }

        DHandleTemplate* m;
    };

    DSmartPointerPointerOrDumbPointerPointer operator&() { return DSmartPointerPointerOrDumbPointerPointer(this); }

    void* m_handle;

    static void* GetInvalidValue() { return *invalidValue; }
    BOOL IsValid() const { return m_handle != *invalidValue; }

private:
    DHandleTemplate(const DHandleTemplate&); // deliberately not implemented
    void operator=(const DHandleTemplate&); // deliberately not implemented
};

__declspec(selectany) extern void* const hhInvalidValue    = INVALID_HANDLE_VALUE;
__declspec(selectany) extern void* const hhNull            = NULL;

/* This closes a Win32 event log handle for writing. */
class DOperatorDeregisterEventSource
{
public:    BOOL operator()(void* handle) const;
};

/* This closes a Win32 event log handle for reading. */
class DOperatorCloseEventLog
{
public:    BOOL operator()(void* handle) const;
};

/* This closes file, event, mutex, semaphore, etc. kernel objects */
class DOperatorCloseHandle
{
public:    BOOL operator()(void* handle) const;
};

//
// Dloses HCRYPTHASH objects
//
class DOperatorCloseCryptHash
{
public:    BOOL operator()(void* handle) const;
};

/* this closes FindFirstFile/FindNextFile */
class DOperatorFindClose
{
public:    BOOL operator()(void* handle) const;
};

/* this closes MapViewOfFile */
class DOperatorUnmapViewOfFile
{
public: BOOL operator()(void* handle) const;
};

/* this closes FreeLibrary */
class DOperatorFreeLibrary
{
public: BOOL operator()(void* handle) const;
};

/* this closes DreateActCtx/AddRefActCtx */
class DOperatorReleaseActCtx
{
public: BOOL operator()(void* handle) const;
};

/* this closes DreateActCtx/AddRefActCtx */
class DOperatorEndUpdateResource
{
public: BOOL operator()(void* handle) const;
};

class DFindFile : public DHandleTemplate<&hhInvalidValue, DOperatorFindClose>
{
private:
    typedef DHandleTemplate<&hhInvalidValue, DOperatorFindClose> Base;
public:
    DFindFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrCreate(PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    HRESULT HrCreate(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    BOOL Win32Create( PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    BOOL Win32Create(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    void operator=(void* v) { Base::operator=(v); }

private:
    DFindFile(const DFindFile &); // intentionally not implemented
    void operator =(const DFindFile &); // intentionally not implemented
};

// createfile
class DFile : public DHandleTemplate<&hhInvalidValue, DOperatorCloseHandle>
{
private:
    typedef DHandleTemplate<&hhInvalidValue, DOperatorCloseHandle> Base;
public:
    DFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrCreate( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL);
    HRESULT HrCreate(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL);
    BOOL Win32Create( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL);
    BOOL Win32Create(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL);
    BOOL Win32GetSize(ULONGLONG &rulSize) const;
    void operator=(void* v) { Base::operator=(v); }

private:
    DFile(const DFile &); // intentionally not implemented
    void operator =(const DFile &); // intentionally not implemented
};

class DFileMapping : public DHandleTemplate<&hhNull, DOperatorCloseHandle>
{
private:
    typedef DHandleTemplate<&hhNull, DOperatorCloseHandle> Base;
public:
    DFileMapping(void* handle = NULL) : Base(handle) { }
    HRESULT HrCreate(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    BOOL Win32Create(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    void operator=(void* v) { Base::operator=(v); }
private:
    DFileMapping(const DFileMapping &); // intentionally not implemented
    void operator =(const DFileMapping &); // intentionally not implemented
};

class DMappedViewOfFile : public DHandleTemplate<&hhNull, DOperatorUnmapViewOfFile>
{
private:
    typedef DHandleTemplate<&hhNull, DOperatorUnmapViewOfFile> Base;
public:
    DMappedViewOfFile(void* handle = NULL) : Base(handle) { }
    HRESULT HrCreate(void* fileMapping, DWORD access, ULONGLONG offset=0, size_t size=0);
    BOOL Win32Create(void* fileMapping, DWORD access, ULONGLONG offset=0, size_t size=0);
    void operator=(void* v) { Base::operator=(v); }
    operator void*()        { return Base::operator void*(); }
private:
    DMappedViewOfFile(const DMappedViewOfFile &); // intentionally not implemented
    void operator =(const DMappedViewOfFile &); // intentionally not implemented
    operator void*() const; // intentionally not implemented
};

class DDynamicLinkLibrary : public DHandleTemplate<&hhNull, DOperatorFreeLibrary>
{
private:
    typedef DHandleTemplate<&hhNull, DOperatorFreeLibrary> Base;
public:
    DDynamicLinkLibrary(void* handle = NULL) : Base(handle) { }

    // if you were writing a linker, this would be ambiguous, but
    // otherwise it fits with the the general NT idea that you are
    // initializing an object, not creating a "physical" think (if bits
    // on disk are physical..), like DreateFile
    BOOL Win32Create(PCWSTR file, DWORD flags = 0);

    template <typename PointerToFunction>
    BOOL GetProcAddress(PCSTR procName, PointerToFunction* ppfn)
    {
        return (*ppfn = reinterpret_cast<PointerToFunction>(::GetProcAddress(*this, procName))) !=  NULL;
    }

    operator HMODULE() { return reinterpret_cast<HMODULE>(operator void*()); }
    HMODULE Detach() { return reinterpret_cast<HMODULE>(Base::Detach()); }
    void operator=(void* v) { Base::operator=(v); }
private:
    DDynamicLinkLibrary(const DDynamicLinkLibrary &); // intentionally not implemented
    void operator =(const DDynamicLinkLibrary &); // intentionally not implemented
};

class DResourceUpdateHandle : public DHandleTemplate<&hhNull, DOperatorEndUpdateResource>
{
private:
    typedef DHandleTemplate<&hhNull, DOperatorEndUpdateResource> Base;
public:
    ~DResourceUpdateHandle() { }
    DResourceUpdateHandle(void* handle = NULL) : Base(handle) { }
    BOOL Win32Create(IN PCWSTR FileName, IN BOOL DeleteExistingResources);
    BOOL UpdateResource(
        IN PCWSTR      Type,
        IN PCWSTR      Name,
        IN WORD        Language,
        IN void*       Data,
        IN DWORD       Size
        );
    BOOL Win32Close(BOOL Discard);

    void operator=(void* v) { Base::operator=(v); }
private:
    DResourceUpdateHandle(const DResourceUpdateHandle &); // intentionally not implemented
    void operator =(const DResourceUpdateHandle &); // intentionally not implemented
};

/*--------------------------------------------------------------------------
DFindFile
--------------------------------------------------------------------------*/

inline BOOL
DFindFile::Win32Create(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    BOOL fSuccess = false;
    FN_TRACE_WIN32(fSuccess);

    HANDLE hTemp = ::FindFirstFileA(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(FindFirstFileA);
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = true;
Exit:
    return fSuccess;
}

inline BOOL
DFindFile::Win32Create(
    PCWSTR nameOrWildcard,
    WIN32_FIND_DATAW *data
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HANDLE hTemp = ::FindFirstFileW(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(FindFirstFileW);
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = true;
Exit:
    return fSuccess;
}

inline HRESULT
DFindFile::HrCreate(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);

    IFW32FALSE_EXIT(this->Win32Create(nameOrWildcard, data));

    hr = NOERROR;
Exit:
    return hr;
}

inline HRESULT DFindFile::HrCreate(PCWSTR nameOrWildcard, WIN32_FIND_DATAW* data)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);

    IFW32FALSE_EXIT(this->Win32Create(nameOrWildcard, data));

    hr = NOERROR;
Exit:
    return hr;
}

/*--------------------------------------------------------------------------
DFile
--------------------------------------------------------------------------*/

inline BOOL
DFile::Win32Create(
    PCSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate,
    DWORD flagsAndAttributes
    )
{
    HANDLE hTemp = ::CreateFileA(name, access, share, NULL, openOrCreate, flagsAndAttributes, NULL);
    if (hTemp == INVALID_HANDLE_VALUE)
        return false;
    operator=(hTemp);
    return true;
}

inline BOOL
DFile::Win32Create(
    PCWSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate,
    DWORD flagsAndAttributes
    )
{
    HANDLE hTemp = ::CreateFileW(name, access, share, NULL, openOrCreate, flagsAndAttributes, NULL);
    if (hTemp == INVALID_HANDLE_VALUE)
        return false;
    operator=(hTemp);
    return true;
}

inline HRESULT DFile::HrCreate(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD flagsAndAttributes)
{
    if (!this->Win32Create(name, access, share, openOrCreate, flagsAndAttributes))
        return HRESULT_FROM_WIN32(::GetLastError());
    return NOERROR;
}

inline HRESULT DFile::HrCreate(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate, DWORD flagsAndAttributes)
{
    if (!this->Win32Create(name, access, share, openOrCreate, flagsAndAttributes))
        return HRESULT_FROM_WIN32(::GetLastError());
    return NOERROR;
}

inline BOOL
DFile::Win32GetSize(ULONGLONG &rulSize) const
{
    DWORD highPart = 0;
    DWORD lastError = NO_ERROR;
    DWORD lowPart = GetFileSize(m_handle, &highPart);
    if (lowPart == INVALID_FILE_SIZE && (lastError = ::GetLastError()) != NO_ERROR)
    {
        return false;
    }
    ULARGE_INTEGER liSize;
    liSize.LowPart = lowPart;
    liSize.HighPart = highPart;
    rulSize = liSize.QuadPart;
    return true;
}

/*--------------------------------------------------------------------------
DFileMapping
--------------------------------------------------------------------------*/

inline HRESULT
DFileMapping::HrCreate(void* file, DWORD flProtect, ULONGLONG maximumSize, PCWSTR name)
{
    LARGE_INTEGER liMaximumSize;
    liMaximumSize.QuadPart = maximumSize;
    HANDLE hTemp = ::CreateFileMappingW(file, NULL, flProtect, liMaximumSize.HighPart, liMaximumSize.LowPart, name);
    if (hTemp == NULL)
        return HRESULT_FROM_WIN32(::GetLastError());
    operator=(hTemp);
    return S_OK;
}

inline BOOL
DFileMapping::Win32Create(
    void* file,
    DWORD flProtect,
    ULONGLONG maximumSize,
    PCWSTR name
    )
{
    return SUCCEEDED(this->HrCreate(file, flProtect, maximumSize, name));
}

inline HRESULT
DMappedViewOfFile::HrCreate(
    void* fileMapping,
    DWORD access,
    ULONGLONG offset,
    size_t size
    )
{
    ULARGE_INTEGER liOffset;
    liOffset.QuadPart = offset;

    void* pvTemp = ::MapViewOfFile(fileMapping, access, liOffset.HighPart, liOffset.LowPart, size);
    if (pvTemp == NULL)
        return HRESULT_FROM_WIN32(::GetLastError());

    (*this) = pvTemp;

    return S_OK;
}

inline BOOL
DMappedViewOfFile::Win32Create(void* fileMapping, DWORD access, ULONGLONG offset, size_t size)
{
    return SUCCEEDED(this->HrCreate(fileMapping, access, offset, size));
}

/*--------------------------------------------------------------------------
DDynamicLinkLibrary
--------------------------------------------------------------------------*/
inline BOOL
DDynamicLinkLibrary::Win32Create(
    PCWSTR file,
    DWORD flags
    )
{
    void* temp = ::LoadLibraryExW(file, NULL, flags);
    if (temp == NULL)
        return false;
    (*this) = temp;
    return true;
}

/*--------------------------------------------------------------------------
DResourceUpdateHandle
--------------------------------------------------------------------------*/

BOOL
DResourceUpdateHandle::Win32Create(
    IN PCWSTR FileName,
    IN BOOL DeleteExistingResources
    )
{
    void* temp = ::BeginUpdateResourceW(FileName, DeleteExistingResources);
    if (temp == NULL)
        return false;
    (*this) = temp;
    return true;
}

BOOL
DResourceUpdateHandle::UpdateResource(
    IN PCWSTR     Type,
    IN PCWSTR     Name,
    IN WORD       Language,
    IN LPVOID     Data,
    IN DWORD      Size
    )
{
    if (!::UpdateResourceW(*this, Type, Name, Language, Data, Size))
        return false;
    return true;
}

BOOL
DResourceUpdateHandle::Win32Close(
    BOOL Discard
    )
{
    void* temp = m_handle;
    m_handle = NULL;
    if (temp != NULL)
    {
        return EndUpdateResource(temp, Discard) ? true : false;
    }
    return true;
}

/*--------------------------------------------------------------------------
DOperator*
--------------------------------------------------------------------------*/

inline BOOL DOperatorCloseHandle::operator()(void* handle) const { return ::CloseHandle(handle) ? true : false; }
inline BOOL DOperatorFindClose::operator()(void* handle) const { return ::FindClose(handle) ? true : false; }
inline BOOL DOperatorUnmapViewOfFile::operator()(void* handle) const { return ::UnmapViewOfFile(handle) ? true : false; }
inline BOOL DOperatorCloseEventLog::operator()(void* handle) const { return ::CloseEventLog(handle) ? true : false; }
inline BOOL DOperatorDeregisterEventSource::operator()(void* handle) const { return ::DeregisterEventSource(handle) ? true : false; }
inline BOOL DOperatorFreeLibrary::operator()(void* handle) const { return ::FreeLibrary(reinterpret_cast<HMODULE>(handle)) ? true : false; }
//
// NOTE it takes and unexception Win32Close(true) to commit the results!
//
inline BOOL DOperatorEndUpdateResource::operator()(void* handle) const
    { return ::EndUpdateResourceW(handle, true) ? true : false; }

/*--------------------------------------------------------------------------
DHandleTemplate
--------------------------------------------------------------------------*/

template <void* const* invalidValue, typename Closer>
DHandleTemplate<invalidValue, Closer>::DHandleTemplate(const void* handle)
: m_handle(const_cast<void*>(handle))
{
}

template <void* const* invalidValue, typename Closer>
void* DHandleTemplate<invalidValue, Closer>::Detach()
{
    void* handle = m_handle;
    m_handle = *invalidValue;
    return handle;
}

template <void* const* invalidValue, typename Closer>
void DHandleTemplate<invalidValue, Closer>::operator=(const void* handle)
{
    m_handle = const_cast<void*>(handle);
}

template <void* const* invalidValue, typename Closer>
BOOL DHandleTemplate<invalidValue, Closer>::Win32Close()
{
    void* handle = Detach();
    if (handle != *invalidValue)
    {
        Closer close;
        return close(handle);
    }
    return true;
}

template <void* const* invalidValue, typename Closer>
DHandleTemplate<invalidValue, Closer>::~DHandleTemplate()
{
    PreserveLastError_t ple;
    (void) this->Win32Close();
    ple.Restore();
}

template <void* const* invalidValue, typename Closer>
DHandleTemplate<invalidValue, Closer>::operator void*() const
{
    return m_handle;
}

template <void* const* invalidValue, typename Closer>
DHandleTemplate<invalidValue, Closer>::operator const void*() const
{
    return m_handle;
}

/*--------------------------------------------------------------------------
end of file
--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\preprocessor\manifestprocessor.cpp ===
#include "stdinc.h"
#include "win32file.h"
#include <stdlib.h>

bool bUseReplacementTags = false;
const wstring MsftCopyRightInfo = L"<!-- Copyright  1981-2001 Microsoft Corporation -->\r\n";
const wstring xml_declar_prefix = L"<?xml ";
const wstring xml_declar_suffix = L"?>";


// Converts a wstring into an array of bytes to be written to the file with the given
// type of character set
CByteVector ConvertWstringToDestination(wstring str, FileContentType fct)
{
    CByteVector byteOutput;
    UINT CodePage = CP_UTF8;

    if ((fct == FileContentsUnicode) || (fct == FileContentsUnicodeBigEndian))
    {
        for (wstring::const_iterator i = str.begin(); i != str.end(); i++)
        {
            unsigned short us = *i;
            char *ch = (char*)&us;

            if (fct == FileContentsUnicodeBigEndian)
                us = (us >> 8) | (us << 8);

            byteOutput.push_back(ch[0]);
            byteOutput.push_back(ch[1]);
        }
    }
    else if (fct == FileContentsUTF8)
    {
        if (fct == FileContentsUTF8) CodePage = CP_UTF8;

        byteOutput.resize(WideCharToMultiByte(CodePage, 0, str.c_str(), str.size(), 0, 0, 0, 0));
        WideCharToMultiByte(CodePage, 0, str.c_str(), str.size(), byteOutput, byteOutput.size(), 0, 0);
    }


    return byteOutput;

}




// Converts a unicode string to a wstring
wstring ConvertToWstring(const CByteVector &bytes, FileContentType fct)
{
    wstring wsOutput;
    vector<WCHAR> wchbuffer;
    UINT CodePage = CP_ACP;

    if (fct == FileContentsUnicode)
    {
        wsOutput.assign(bytes, bytes.size() / 2);
    }
    else
    {
        wchbuffer.resize(MultiByteToWideChar(CodePage, 0, bytes, bytes.size(), NULL, 0), L'\0');
        MultiByteToWideChar(CodePage, 0, bytes, bytes.size(), &wchbuffer.front(), wchbuffer.size());
        wsOutput.assign(&wchbuffer.front(), wchbuffer.size());
    }

    return wsOutput;
}






typedef std::pair<wstring,wstring> TagValue;
typedef vector<TagValue> Definitions;

// Reads in a foo=bar pair
//7
// fragile, could use some whitespace tweaking or maybe smarter use of
// the stream operators
wistream& operator>>(wistream& in, TagValue& defined) {
    wstring fullline;

    getline(in, fullline);
    defined.first = fullline.substr(0, fullline.find_first_of('='));
    defined.second = fullline.substr(fullline.find_first_of('=') + 1);

    return in;
}

// Load the entire parameterization file
Definitions ReadParameterizationFile(wistream &stream)
{
    Definitions rvalue;
    TagValue tv;

    while (!(stream >> tv).eof())
        rvalue.push_back(tv);

    return rvalue;
}

typedef std::pair<wstring::size_type, wstring::size_type> StringSubspan;
typedef std::pair<wstring, wstring> ReplacementCode;
typedef std::pair<StringSubspan, ReplacementCode> ReplacementChunklet;

//
// Converts "foo:bar" into <foo, bar>
ReplacementCode ExtractIntoPieces(const wstring& blob)
{
    ReplacementCode rvalue;
    wstring::size_type colonoffset;

    colonoffset = blob.find(L':');
    if (colonoffset == wstring::npos)
    {
        rvalue.first = blob;
        rvalue.second = L"";
    }
    else
    {
        rvalue.first = blob.substr(0, colonoffset);
        rvalue.second = blob.substr(colonoffset + 1);
    }

    return rvalue;
}

ReplacementChunklet*
FindNextReplacementPiece(
    wstring& search,
    const wstring& target
   )
{
    ReplacementChunklet* pChunky;
    wstring::size_type startchunk, endchunk;
    wstring subchunk;
    wstring predicate = bUseReplacementTags ? L"$(" : L"";
    wstring suffix = bUseReplacementTags ? L")" : L"";
    wstring wsFindOpener = predicate + target;

    startchunk = search.find(wsFindOpener);

    if (startchunk == wstring::npos)
        return NULL;

    if (bUseReplacementTags)
    {
        endchunk = search.find(suffix, startchunk);
    }
    else
    {
        endchunk = startchunk + target.size();
    }

    if (endchunk == wstring::npos)
        return NULL;

    pChunky = new ReplacementChunklet;
    pChunky->first.first = startchunk;
    pChunky->first.second = endchunk + suffix.size();

    // Tear apart into predicate and suffix
    // minus $(and)
    wstring topieces = search.substr(startchunk + predicate.size(), endchunk - (startchunk + predicate.size()));
    pChunky->second = ExtractIntoPieces(topieces);

    return pChunky;
}

//
// Right now, the only operation permitted is just a pass-through.  Anything after the : is ignored.
//
wstring CleanReplacement(const ReplacementCode code, const wstring& intendedReplacement, const wstring& context)
{
    wstring rvalue = intendedReplacement;

    return rvalue;
}


#define STRIPCOMMENTS_SLASHSLASH 0x000001
#define STRIPCOMMENTS_SLASHSTAR  0x000002
#define STRIPCOMMENTS_SLASHSLASH_UNAWARE 0x000004
#define STRIPCOMMENTS_SLASHSTAR_UNAWARE 0x000008

template <typename strtype>
void StripComments(int flags, basic_string<strtype>& s)
/*
We generally want to be "aware" of both types so that we don't
strip nested comments. Consider the comments that follow.
*/

// /* slash star in slsh slash */

/* // slashslash
      in slash star
 */
{
    typedef basic_string<strtype> ourstring;
    ourstring t;
    ourstring::const_iterator i;
    const ourstring::const_iterator j = s.end();
    ourstring::const_iterator k;
    bool closed = true;

    t.reserve(s.size());
    for (i = s.begin() ; closed && i != j && i + 1 != j;)
    {
        if (((flags & STRIPCOMMENTS_SLASHSTAR) || (flags & STRIPCOMMENTS_SLASHSTAR_UNAWARE) == 0) &&
            (*i == '/') &&
            (*(i + 1) == '*'))
        {
            closed = false;
            for (k = i + 2 ; k != j && k + 1 != j && !(closed = (*k == '*' && *(k + 1) == '/')) ; ++k)
            {
            }
            if (flags & STRIPCOMMENTS_SLASHSTAR)
                // t.append(1, ' ');
                ;
            else
                t.append(i, k + 2);
            i = k + 2;
        }
        else if (((flags & STRIPCOMMENTS_SLASHSLASH) || (flags & STRIPCOMMENTS_SLASHSLASH_UNAWARE) == 0) &&
                 (*i == '/') &&
                 (*(i + 1) == '/'))
        {
            closed = false;
            for (k = i + 2 ; k != j && !(closed = (*k == '\r' || *k == '\n')) ; ++k)
            {
            }
            for (; k != j && *k == '\r' || *k == '\n' ; ++k)
            {
            }
            if (flags & STRIPCOMMENTS_SLASHSLASH)
                t.append(1, '\n');
            else
                t.append(i, k);
            i = k;
        }
        if (closed && i != j)
            t.append(1, *i++);
    }
    if (closed)
    {
        for (; i != j ; ++i)
        {
            t.append(1, *i);
        }
    }
    s = t;
}

void GetXMLDeclarationIfAny(wstring & wsXmlDecl, wstring & wsFile)
{   
    SIZE_T p=0, q =0;
    p = wsFile.find(xml_declar_prefix, 0);

    if (p == 0) // find from exact the beginning of the xmlfile
    {
        q = wsFile.find(xml_declar_suffix, xml_declar_prefix.length());

        if ( q == -1) // manifest has a format error
            throw new Win32File::ReadWriteError(true, ::GetLastError()); 

        q += xml_declar_suffix.length();

        // skip whitespace
        while ((q < wsFile.size()) && (wsFile[q] == L' '))
            q ++;

        while ((q < wsFile.size()) && ((wsFile[q] == L'\n') || (wsFile[q] == L'\r')))
            q ++;

        wsXmlDecl.assign(wsFile, 0, q);
        wsFile.erase(0, q);
    }

    return;

}

void ProcessFile(Win32File& inputFile, Win32File& outputFile, Definitions SubstList)
{

    wstring wsNextLine;
    wstring wsXmlDeclaration;
    inputFile.snarfFullFile(wsNextLine);

    //
    // No comments from the peanut gallery, please.  Code by Jay Krell to remove
    // comments from strings here...
    //
    StripComments(STRIPCOMMENTS_SLASHSLASH | STRIPCOMMENTS_SLASHSTAR, wsNextLine);

    // Go until we run out of $(...) to replace
    for (Definitions::const_iterator ditem = SubstList.begin(); ditem != SubstList.end(); ditem++)
    {
        ReplacementChunklet* pNextChunk = NULL;
        while ((pNextChunk = FindNextReplacementPiece(wsNextLine, ditem->first)) != NULL)
        {
            wstring cleaned = CleanReplacement(pNextChunk->second, ditem->second, wsNextLine);
            wsNextLine.replace(pNextChunk->first.first, pNextChunk->first.second - pNextChunk->first.first, cleaned);
            delete pNextChunk;
        }
    }

    //
    // Clean up everything
    //
    while (wsNextLine.size() && iswspace(*wsNextLine.begin()))
        wsNextLine = wsNextLine.substr(1);

    GetXMLDeclarationIfAny(wsXmlDeclaration, wsNextLine);
    if (wsXmlDeclaration.length() != 0)
    {
        outputFile.writeLine(wsXmlDeclaration);        
    }

    //
    // include Microsoft Copyright information at the head of the manifest
    //
    outputFile.writeLine(MsftCopyRightInfo);

    //
    // write the output of replacement defines
    //
    outputFile.writeLine(wsNextLine);
}




// Converts a wstring to a string
string ConvertWstring(wstring input)
{
    string s;
    vector<CHAR> strbytes;

    strbytes.resize(WideCharToMultiByte(CP_ACP, 0, input.c_str(), input.size(), NULL, 0, NULL, NULL));
    WideCharToMultiByte(CP_ACP, 0, input.c_str(), input.size(), &strbytes.front(), strbytes.size(), NULL, NULL);

    s.assign(&strbytes.front(), strbytes.size());
    return s;
}


int __cdecl wmain(int argc, WCHAR** argv)
{
    using namespace std;

    vector<wstring> args;
    wstring wsInputFile, wsOutputFile;
    Definitions defines;
    Win32File InputFile, OutputFile;

    for (int i = 1; i < argc; i++)
        args.push_back(wstring(argv[i]));

    for (vector<wstring>::const_iterator ci = args.begin(); ci != args.end(); ci++)
    {
        if (*ci == wstring(L"-reptags")) {
            bUseReplacementTags = true;
        }
        else if (*ci == wstring(L"-i")) {
            wsInputFile = *++ci;
        }
        else if (*ci == wstring(L"-o")) {
            wsOutputFile = *++ci;
        }
        else if (*ci == wstring(L"-s")) {
            wifstream iis;
            iis.open(ConvertWstring(*++ci).c_str());
            if (!iis.is_open()) {
                wcerr << L"Failed opening substitution file " << ci->data() << endl;
                return 1;
            }

            Definitions temp = ReadParameterizationFile(iis);
            for (Definitions::const_iterator it = temp.begin(); it != temp.end(); it++)
                defines.push_back(*it);
        }
        else if (ci->substr(0, 2) == wstring(L"-D"))
        {
            // Commandline definitions are NOT appreciated, but they seem to be a necessary evil.
            wstringstream wsstemp(ci->substr(2));
            TagValue temptag;
            wsstemp >> temptag;
            defines.push_back(temptag);
        }
    }

    try {
        InputFile.openForRead(wsInputFile);
    } catch (Win32File::OpeningError *e) {
        wcerr << L"Failed opening the input file " << wsInputFile.c_str() << L": " << e->error << endl;
        delete e;
        return EXIT_FAILURE;
    } catch (Win32File::ReadWriteError *e) {
        wcerr << L"Failed sensing lead bytes of input file " << wsInputFile.c_str() << L": " << e->error << endl;
        delete e;
        return EXIT_FAILURE;
    }

    try {
        OutputFile.openForWrite(wsOutputFile, InputFile.gettype());
    } catch (Win32File::OpeningError *e) {
        wcerr << L"Failed opening the output file " << wsOutputFile.c_str() << L": " << e->error << endl;
        delete e;
        return EXIT_FAILURE;
    } catch (Win32File::ReadWriteError *e) {
        wcerr << L"Failed writing lead bytes of output file " << wsOutputFile.c_str() << L": " << e->error << endl;
        delete e;
        return EXIT_FAILURE;
    }
    
    ProcessFile(InputFile, OutputFile, defines);

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\resourcetool\preservelasterror.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    PreserveLastError.h

Abstract:

Author:

    Jay Krell (JayKrell) October 2000

Revision History:

--*/
#pragma once

class PreserveLastError_t
{
public:
    DWORD LastError() const { return m_dwLastError; }

    PreserveLastError_t() : m_dwLastError(::GetLastError()) { }
	~PreserveLastError_t() { Restore(); }
    void Restore() const { ::SetLastError(m_dwLastError); }

protected:
    DWORD m_dwLastError;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\resourcetool\mystring.h ===
#pragma once

#include <string>

inline int StringCompareI(const char* s, const char* t)
    { return _stricmp(s, t); }

inline int StringCompareI(const wchar_t* s, const wchar_t* t)
    { return _wcsicmp(s, t); }

inline int StringCompareNI(const char* s, const char* t, size_t n)
    { return _strnicmp(s, t, n); }

inline int StringCompareNI(const wchar_t* s, const wchar_t* t, size_t n)
    { return _wcsnicmp(s, t, n); }

template <typename Char_t>
class StringTemplate_t : public std::basic_string<Char_t>
{
    typedef std::basic_string<Char_t> Base;
public:

    static size_t StringLength(const char* s)
        { return strlen(s); }

    static size_t StringLength(const wchar_t* s)
        { return wcslen(s); }

    StringTemplate_t() { }
    ~StringTemplate_t() { }

    StringTemplate_t(const_iterator i, const_iterator j) : Base(i, j) { }

    StringTemplate_t(PCWSTR t) : Base(t) { }
    StringTemplate_t& operator=(PCWSTR t) { Base::operator=(t); return *this; }

    StringTemplate_t(const StringTemplate_t& t) : Base(t) { }
    StringTemplate_t& operator=(const StringTemplate_t& t) { Base::operator=(t); return *this; }

    StringTemplate_t(const Base& t) : Base(t) { }
    StringTemplate_t& operator=(const Base& t) { Base::operator=(t); return *this; }

    bool operator<(const StringTemplate_t& t) const
    {
        return (StringCompareI(c_str(), t.c_str()) < 0);
    }

    bool operator==(const StringTemplate_t& t) const
    {
        return (StringCompareI(c_str(), t.c_str()) == 0);
    }

    bool operator<(const Base& t) const
    {
        return (StringCompareI(c_str(), t.c_str()) < 0);
    }

    bool operator==(const Base& t) const
    {
        return (StringCompareI(c_str(), t.c_str()) == 0);
    }

    bool operator<(PCWSTR t) const
    {
        return (StringCompareI(c_str(), t) < 0);
    }

    bool operator==(PCWSTR t) const
    {
        return (StringCompareI(c_str(), t) == 0);
    }

    static size_t Length(PCWSTR s) { return StringLength(s); }
    size_t Length() const { return length(); }
    size_t GetLength() const { return length(); }

    void clear() { const static Char_t c[1]; operator=(c); }

    bool Starts(const StringTemplate_t& t) const
    {
        return (StringCompareNI(c_str(), t.c_str(), t.Length()) == 0);
    }

    //
    // we're have some ambiguity problem..
    //
    const_reference operator[](int n) const { return *(begin() + n); }
    const_reference operator[](unsigned n) const { return *(begin() + n); }
    const_reference operator[](unsigned long n) const { return *(begin() + n); }

    operator const Char_t*() const { return c_str(); }
};

typedef StringTemplate_t<char>    StringA_t;
typedef StringTemplate_t<wchar_t> StringW_t;
typedef StringW_t String_t;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\preprocessor\win32file.h ===
#pragma once

#include "windows.h"
#include <string>

using std::wstring;

enum FileContentType {
    FileContentsUnicode,
    FileContentsUnicodeBigEndian,
    FileContentsUTF8
};

FileContentType DetermineFileTypeFromBuffer( unsigned char *, int );
int DetermineFileTypeSigSize( FileContentType );
CByteVector ConvertWstringToDestination( wstring str, FileContentType fct );
wstring ConvertToWstring( const CByteVector &bytes, FileContentType fct );

const static unsigned char UNICODE_SIGNATURE[] = { 0xFF, 0xFE };
const static unsigned char UNICODE_BIG_ENDIAN_SIGNATURE[] = { 0xFE, 0xFF };
const static unsigned char UTF8_SIGNATURE[] = { 0x0 };

class Win32File
{
    FileContentType _type;
    wstring _wsName;
    HANDLE _hFile;
    bool _bOpenForRead, _bEof;

public:
    void openForRead( wstring wstname );
    void openForWrite( wstring wstname, FileContentType bCreateFileType, bool bCanOverwrite = true );
    bool eof();

    void snarfFullFile( wstring& );
    void writeLine( const wstring& );
    int filepointer() { return SetFilePointer( _hFile, 0, NULL, FILE_CURRENT ); }
    int filesize() { return GetFileSize( _hFile, NULL ); }

    FileContentType gettype() { return _type; }

    Win32File();
    ~Win32File();

    class AlreadyOpened { };
    class OpeningError { public: DWORD error; OpeningError( DWORD d ) : error( d ) { } };
    class ReadWriteError { public: bool isReading; DWORD error; ReadWriteError( bool m, DWORD e ) : isReading( m ), error( e ) { } };

private:
    Win32File( const Win32File& );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\resourcetool\stdinc.h ===
#define STRICT
#define UNICODE
#define _UNICODE
#include "yvals.h"
#pragma warning(disable:4127)
#pragma warning(disable:4663)
#pragma warning(disable:4100)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4018) /* signed/unsigned mismatch */
#pragma warning(disable:4786) /* long symbols */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion from size_t to int */
#endif
#undef _MIN
#undef _MAX
#define _MIN min
#define _MAX max
#define min min
#define max max
#define NOMINMAX
#define _cpp_min min
#define _cpp_max max

#include <string>
#include <vector>
#include <set>
#include <algorithm>
#include <map>
#include <stdio.h>

#include "windows.h"
//
// compatibility with VC6 headers
//
#if !defined(_WIN64)
#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif
typedef _W64 long LONG_PTR, *PLONG_PTR;
typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;
#endif
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#define RT_MANIFEST MAKEINTRESOURCE(24)
#define BITS_OF(x) (sizeof(x)*8)

#define ASSERT_NTC(x) ASSERT(x)
#define VERIFY_NTC(x) (x)
#define FN_TRACE_WIN32(x) /* nothing */
#define FN_TRACE_HR(x) /* nothing */
#define IFW32FALSE_EXIT(x) do { if (!(x)) goto Exit; } while(0)

#define TRACE_WIN32_FAILURE_ORIGINATION(x) \
	(OutputDebugStringA(#x "\n"))

void ResourceToolAssertFailed(const char* Expression, const char* File, unsigned long Line);
void ResourceToolInternalErrorCheckFailed(const char* Expression, const char* File, unsigned long Line);

#define ASSERT(x)               ((!!(x)) || (ResourceToolAssertFailed(#x, SourceFile, __LINE__),false))
#define INTERNAL_ERROR_CHECK(x) ((!!(x)) || (ResourceToolInternalErrorCheckFailed(#x, SourceFile, __LINE__),false))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\rmdir_bigpath\rmdir.cpp ===
//
// Simple wrapper around GetFullPathname and RemoveDirectory
// that converts to \\? form.
//
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
#include "fusionhandle.h"
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"rmdir_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096] = { 0 };
    WCHAR rgchWin32Error[4096] = { 0 };

    va_start(ap, szFormat);
    ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error) - 1,
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        ::_snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error) - 1, L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    ::fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        ::fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;

    if (argc != 2)
    {
        ::fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <empty-directory-to-delete>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1 + (1UL << 15));
    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
    {
        ::ReportFailure("FusionpConvertToBigPath\n");
        goto Exit;
    }
    arg1.resize(1 + ::wcslen(&arg1[0]));
    if (!::RemoveDirectoryW(&arg1[0]))
    {
        ::ReportFailure("RemoveDirectoryW\n");
        goto Exit;
    }
    printf("%ls\n", &arg1[0]);

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\resourcetool\resourcetool.cpp ===
#include "stdinc.h"
static const char SourceFile[] = __FILE__;
#include "Handle.h"
#include <functional>
#include <set>
#include "rpc.h"

inline SIZE_T StringLength(LPCSTR psz) { return ::strlen(psz); }
inline SIZE_T StringLength(LPCWSTR psz) { return ::wcslen(psz); }

// std::binary_search lamely only returns a bool, not an iterator
// it is a simple layer over std::lower_bound
template<class Iterator_t, class T> inline
Iterator_t BinarySearch(Iterator_t First, Iterator_t Last, const T& t)
{
    Iterator_t Iterator = std::lower_bound(First, Last, t);
    if (Iterator != Last
        && !(t < *Iterator) // this is a way to check for equality actually
        )
        return Iterator;
    return Last;
}

//
// This is just like remove_copy_if, but it is missing an exclamation point
//
template<class InputIterator_t, class OutputIterator_t, class Predicate_t> inline
OutputIterator_t CopyIf(InputIterator_t First, InputIterator_t Last, OutputIterator_t Out, Predicate_t Predicate)
{
    for (; First != Last; ++First)
        if (/*!*/Predicate(*First))
	        *Out++ = *First;
    return (Out);
}

//
// get msvcrt.dll wildcard processing on the command line
//
extern "C" { int _dowildcard = 1; }

#define RESOURCE_PATH_LENGTH 3
#define RESOURCE_TYPE_INDEX  0
#define RESOURCE_NAME_INDEX  1 /* aka ID, but also each index is also called an id */
#define RESOURCE_LANG_INDEX  2
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

class Resource_t;
class ResourceId_t;
class BuiltinResourceId_t;

#include "MyString.h"

typedef std::vector<String_t> StringVector_t;
typedef StringVector_t::iterator StringVectorIterator_t;
typedef StringVector_t::const_iterator StringVectorConstIterator_t;

typedef std::set<String_t> StringSet_t;
typedef StringSet_t::iterator StringSetIterator_t;
typedef StringSet_t::const_iterator StringSetConstIterator_t;

template <typename T, size_t N>
class FixedSizeArray_t : public std::vector<T>
{
public:
    ~FixedSizeArray_t() { }
    FixedSizeArray_t() { reserve(N); }
};

String_t NormalizeResourceId(const String_t&);
String_t NormalizeResourceId(PCWSTR);

class BuiltinResourceId_t
{
public:
    friend bool operator<(const BuiltinResourceId_t& x, const String_t& y)
        { return _wcsicmp(x.Name, y) < 0; }
    friend bool operator<(const BuiltinResourceId_t& x, const BuiltinResourceId_t& y)
        { return _wcsicmp(x.Name, y.Name) < 0; }
    friend bool operator<(const String_t& x, const BuiltinResourceId_t& y)
        { return _wcsicmp(x, y.Name) < 0; }

    PCWSTR     Name;
    ULONG_PTR  Number;
    //WCHAR      PoundNumberString[4];
};

class ResourceId_t : public String_t
{
private:
    typedef String_t Base;
public:
    ResourceId_t() { }
    ~ResourceId_t() { }

    ResourceId_t(PCWSTR x) : Base(NormalizeResourceId(x)) { }
    ResourceId_t(const ResourceId_t& x) : Base(x) { }
    ResourceId_t(const String_t& x) : Base(NormalizeResourceId(x)) { }

    void operator=(PCWSTR x) { Base::operator=(NormalizeResourceId(x)); }
    void operator=(const ResourceId_t& x) { Base::operator=(x); }
    void operator=(const String_t& x) { Base::operator=(NormalizeResourceId(x)); }
};

String_t NumberToResourceId(ULONG Number)
{
    WCHAR   NumberAsString[BITS_OF(Number) + 5];

    _snwprintf(NumberAsString, NUMBER_OF(NumberAsString), L"#%lu", Number);
    NumberAsString[NUMBER_OF(NumberAsString) - 1] = 0;

    return NumberAsString;
}

class ResourceIdTuple_t
{
public:
    ~ResourceIdTuple_t() { }
    ResourceIdTuple_t() { }

    ResourceId_t Type;
    ResourceId_t Name;
    ResourceId_t Language;

	bool operator==(const ResourceIdTuple_t& Right) const
    {
        return !(*this < Right) && !(Right < *this);
    }

    static bool ResourceIdPointerLessThan(const ResourceId_t* x, const ResourceId_t* y)
    {
        return x->compare(*y) < 0;
    }

	bool operator<(const ResourceIdTuple_t& Right) const
    {
        // the order is NOT arbitrary (er..it wasn't, but now we don't care even about sorting)
        const ResourceId_t* LeftArray[] = { &this->Type, &this->Name, &this->Language };
        const ResourceId_t* RightArray[] = { &Right.Type, &Right.Name, &Right.Language };

        return std::lexicographical_compare(
            LeftArray, LeftArray + NUMBER_OF(LeftArray),
            RightArray, RightArray + NUMBER_OF(RightArray),
            ResourceIdPointerLessThan
            );
    }
};

bool Match(const ResourceId_t& Left, const ResourceId_t& Right);
bool Match(const ResourceIdTuple_t& Left, const ResourceIdTuple_t& Right);

class Resource_t
{
public:
    ~Resource_t() { }
    Resource_t() { }

    friend bool EqualByIdTuple(const Resource_t& Left, const Resource_t& Right)
        { return Left.IdTuple == Right.IdTuple; }

    friend bool LessThanByIdTuple(const Resource_t& Left, const Resource_t& Right)
        { return Left.IdTuple < Right.IdTuple; }

    // controversial..
    bool operator<(const Resource_t& Right) const
    {
        return LessThanByIdTuple(*this, Right);
    }

    bool Match(const ResourceIdTuple_t/*&*/ IdTuple) /*const*/
    {
        return ::Match(this->IdTuple, IdTuple);
    }

    //
    // For example, you may want to sort by size if looking for equal resources independent of resourceid tuple.
    //

    operator       ResourceIdTuple_t&()       { return IdTuple; }
    operator const ResourceIdTuple_t&() const { return IdTuple; }

    ResourceIdTuple_t IdTuple;
    PVOID             Address; // DllHandle is assumed
    ULONG             Size;
};

class LessThanByIdTuple_t
{
public:
    bool operator()(const Resource_t& Left, const ResourceIdTuple_t& Right)
        { return Left.IdTuple < Right; }

    bool operator()(const ResourceIdTuple_t& Left, const Resource_t& Right)
        { return Left < Right.IdTuple; }
};

bool Match(const ResourceId_t& Left, const ResourceId_t& Right)
{ 
    if (Left == L"*" || Right == L"*" || Left == Right
        || (Left.Length() > 1 && Right.Length() > 1 && Left[0] == '!' && Right[0] != '!' && Left.substr(1) != Right)
        || (Left.Length() > 1 && Right.Length() > 1 && Right[0] == '!' && Left[0] != '!' && Right.substr(1) != Left)
        )
        return true;
    return false;
}

bool Match(const ResourceIdTuple_t& Left, const ResourceIdTuple_t& Right)
{ 
    return Match(Left.Type, Right.Type)
        && Match(Left.Name, Right.Name)
        && Match(Left.Language, Right.Language)
        ;
}

typedef std::map<ResourceIdTuple_t, std::map<ResourceIdTuple_t, std::set<ResourceIdTuple_t> > > ResourceIdTree_t;
void TransformTuplesToTree()
//
// transform the array of triples into a 3 level deep map..nope..
//
{
}

typedef std::set<Resource_t>::iterator EnumIterator_t;

class ResourceTool_t
{
private:
    typedef ResourceTool_t This_t;
    ResourceTool_t(const ResourceTool_t&);
    void operator=(const ResourceTool_t&);
public:

    typedef String_t File_t;

    ~ResourceTool_t() { }

    class Print_t
    {
    public:
        Print_t()
            :
        UnequalContents(false),
        UnequalSize(false),
        Equal(true),
        Keep(false),
        Delete(true),
        Success(false),
        Unchanged(false),
        LeftOnly(false),
        RightOnly(false)
        {
        }

        void SetAll(bool Value)
        {
            UnequalSize = UnequalContents = UnequalSize
                = Keep = Delete = Success = Unchanged
                = LeftOnly = RightOnly = Equal
                = Value;
        }

        bool UnequalContents;
        bool UnequalSize;
        bool Equal;
        bool Keep;
        bool Delete;
        bool Success;
        bool Unchanged;
        bool LeftOnly;
        bool RightOnly;
    };

    Print_t Print;

    ResourceTool_t() :
        Argv0base_cstr(L""),
        ShouldPrint(true)
        {
        }

    static BOOL __stdcall Sxid12EnumResourcesNameCallbackW_static(HMODULE hModule, PCWSTR lpszType, LPWSTR lpszName, LONG_PTR lParam);
    bool Sxid12EnumResourcesNameCallbackW(HMODULE hModule, PCWSTR lpszType, LPWSTR lpszName, LONG_PTR lParam);

    void DumpMessageTableResource(const File_t& File, EnumIterator_t EnumIterator);
    void DumpStringTableResource(const File_t& File, EnumIterator_t EnumIterator);
    void DumpManifestResource(const File_t& File, EnumIterator_t EnumIterator);
    void DumpBinaryResource(const File_t& File, EnumIterator_t EnumIterator);
    void DumpResource(const File_t& File, EnumIterator_t EnumIterator);
    
    int Sxid12Tool1(const StringVector_t args);

    void Query();
    void Dump();
    void FindDuplicates();
    void FindAndDeleteDuplicates();
    void Delete();
    void Diff(); // same analysis as FindDuplicates, but prints more
    void Explode() { } // not implemented

    void ChangeEmptyQueryToAllQuery();

    typedef void (This_t::*Operation_t)();

    int Main(const StringVector_t& args);

    static bool IsWildcard(const String_t& s)
    {
        return (s == L"*");
    }

    static bool IsPathSeperator(wchar_t ch)
    {
        return (ch == '\\' || ch == '/');
    }

    static bool IsAbsolutePath(const String_t& s)
    {
        return (s.length() > 2
            && (s[1] == ':' || (IsPathSeperator(s[0] && IsPathSeperator(s[1])))));
    }

    //
    // This transform lets LoadLibrary's search be more like CreateFile's search.
    //
    static String_t PrependDotSlashToRelativePath(const String_t& Path)
    {
        if (!IsAbsolutePath(Path))
            return L".\\" + Path;
        else
            return Path;
    }

    bool OpenResourceFile(ULONG Flags, DDynamicLinkLibrary& dll, String_t Path);

    String_t					   Argv0;
    String_t					   Argv0base;
    PCWSTR						   Argv0base_cstr;

    typedef std::vector<File_t> Files_t;
    typedef std::set<ResourceIdTuple_t> Tuples_t;

	Files_t		    Files;
    Tuples_t        Tuples;
    bool            ShouldPrint;
};

typedef String_t::const_iterator StringConstIterator_t;

void PrintString(const wchar_t* s)
{
    fputws(s, stdout);
}

void ResourceToolAssertFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "ASSERTION FAILURE: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

void ResourceToolInternalErrorCheckFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "INTERNAL ERROR: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

struct Sxid12EnumResourcesNameCallbackWParam_t
{
    ResourceTool_t*         This;
    String_t                dllName;
    std::vector<ULONG>      integralResourceIds;
    StringVector_t          stringResourceIds;
};

BOOL __stdcall
ResourceTool_t::Sxid12EnumResourcesNameCallbackW_static(
    HMODULE hModule,
    PCWSTR lpszType,
    LPWSTR lpszName,
    LONG_PTR lParam
    )
{
    Sxid12EnumResourcesNameCallbackWParam_t* param = reinterpret_cast<Sxid12EnumResourcesNameCallbackWParam_t*>(lParam);
    return param->This->Sxid12EnumResourcesNameCallbackW(hModule, lpszType, lpszName, lParam);
}

bool
ResourceTool_t::Sxid12EnumResourcesNameCallbackW(
    HMODULE  hModule,
    PCWSTR  lpszType,
    LPWSTR   lpszName,
    LONG_PTR lParam
    )
{
    Sxid12EnumResourcesNameCallbackWParam_t* param = reinterpret_cast<Sxid12EnumResourcesNameCallbackWParam_t*>(lParam);

    if (IS_INTRESOURCE(lpszName))
    {
        ULONG iType = static_cast<ULONG>(reinterpret_cast<LONG_PTR>(lpszName));
        printf("%ls note: %ls contains RT_MANIFEST with id %u\n", Argv0base_cstr, param->dllName.c_str(), iType);
        param->integralResourceIds.insert(param->integralResourceIds.end(), iType);
    }
    else
    {
        printf("%ls note: %ls contains RT_MANIFEST with id \"%ls\"\n", Argv0base_cstr, param->dllName.c_str(), lpszName);
        param->stringResourceIds.insert(param->stringResourceIds.end(), lpszName);
    }
    return true;
}

String_t NumberToString(ULONG Number, PCWSTR Format = L"0x%lx")
{
    // the size needed is really dependent on Format..
    WCHAR   NumberAsString[BITS_OF(Number) + 5];

    _snwprintf(NumberAsString, NUMBER_OF(NumberAsString), Format, Number);
    NumberAsString[NUMBER_OF(NumberAsString) - 1] = 0;

    return NumberAsString;
}

LONG StringToNumber(PCWSTR s)
{
    int Base = 0;
    if (s == NULL || s[0] == 0)
        return 0;
    if (s[0] == '#')
    {
        Base = 10;
        ++s;
    }
    return wcstol(s, NULL, Base);
}


PCWSTR StringToResourceString(PCWSTR s)
{
    if (s == NULL || s[0] == 0)
        return 0;
    if (s[0] == '#')
    {
        return reinterpret_cast<PCWSTR>(static_cast<ULONG_PTR>(StringToNumber(s)));
    }
    else
    {
        return s;
    }
}

String_t GetLastErrorString()
{
    PWSTR s = NULL;
    DWORD Error = GetLastError();
    String_t ErrorString = NumberToString(Error, L"%lu");
    PWSTR FormatMessageAllocatedBuffer = NULL;

    if (!FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        0,
        reinterpret_cast<PWSTR>(&FormatMessageAllocatedBuffer),
        100,
        NULL
        )
        || FormatMessageAllocatedBuffer == NULL
        )
    {
        goto Exit;
    }
    if (FormatMessageAllocatedBuffer[0] == 0)
    {
        goto Exit;
    }

    //
    // Error messages often end with vertical whitespce, remove it.
    //
    s = FormatMessageAllocatedBuffer + StringLength(FormatMessageAllocatedBuffer) - 1;
    while (s != FormatMessageAllocatedBuffer && (*s == '\n' || *s == '\r'))
        *s-- = 0;
    ErrorString = ErrorString + L" (" + FormatMessageAllocatedBuffer + L")";
Exit:
    LocalFree(FormatMessageAllocatedBuffer);
    return ErrorString;
}

bool GetFileSize(PCWSTR Path, __int64& Size)
{
    DFindFile FindFile;
    WIN32_FIND_DATAW wfd;
    LARGE_INTEGER liSize;

    if (!FindFile.Win32Create(Path, &wfd))
        return false;

    liSize.HighPart = wfd.nFileSizeHigh;
    liSize.LowPart = wfd.nFileSizeLow;
    Size = liSize.QuadPart;

    return true;
}

//
// This is the original sxid2rtool1, preserved
//
int ResourceTool_t::Sxid12Tool1(const StringVector_t args)
{
    int ret = EXIT_SUCCESS;
    typedef StringVector_t args_t;
    __int64 FileSize = 0;

    for (args_t::const_iterator i = args.begin() ; i != args.end() ; ++i)
    {
        DDynamicLinkLibrary dll;
        String_t betterPath;

        //
        // prepend .\ so that LoadLibrary acts more like CreateFile.
        //
        betterPath = PrependDotSlashToRelativePath(*i);
        PCWSTR cstr = betterPath.c_str();

        //
        // skip empty files to avoid STATUS_MAPPED_FILE_SIZE_ZERO -> ERROR_FILE_INVALID,
        //
        if (!GetFileSize(cstr, FileSize))
        {
            String_t ErrorString = GetLastErrorString();
            printf("%ls : WARNING: %ls skipped : Error %ls\n", Argv0base_cstr, cstr, ErrorString.c_str());
        }
        if (FileSize == 0)
        {
            printf("%ls : WARNING: empty file %ls skipped\n", Argv0base_cstr, cstr);
            continue;
        }

        if (!dll.Win32Create(cstr, LOAD_LIBRARY_AS_DATAFILE))
        {
            DWORD Error = GetLastError();
            String_t ErrorString = GetLastErrorString();
            switch (Error)
            {
            case ERROR_BAD_EXE_FORMAT: // 16bit or not an .exe/.dll at all
                break;
            case ERROR_ACCESS_DENIED: // could be directory (should support sd ... syntax)
                {
                    DWORD fileAttributes = GetFileAttributesW(cstr);
                    if (fileAttributes != INVALID_FILE_ATTRIBUTES && (fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
                        break;
                }
                // FALLTHROUGH
            default:
                printf("%ls : WARNING: %ls skipped : Error %ls\n", Argv0base_cstr, cstr, ErrorString.c_str());
                break;
            }
            continue;
        }
        Sxid12EnumResourcesNameCallbackWParam_t callbackParam;
        callbackParam.This = this;
        callbackParam.dllName = betterPath;
        EnumResourceNamesW(dll, MAKEINTRESOURCEW(RT_MANIFEST), Sxid12EnumResourcesNameCallbackW_static, reinterpret_cast<LONG_PTR>(&callbackParam));

        if (callbackParam.integralResourceIds.size() > 1)
        {
            printf("%ls WARNING: %ls contains multiple RT_MANIFESTs with integral ids\n", Argv0base_cstr, cstr);
            unsigned numberOfReservedManifests = 0;
            for (unsigned j = 0 ; j != callbackParam.integralResourceIds.size() ; ++j)
            {
                if (callbackParam.integralResourceIds[j] >= 1
                    && callbackParam.integralResourceIds[j] <= 16
                    )
                {
                    numberOfReservedManifests += 1;
                    if (numberOfReservedManifests > 1)
                    {
                        printf("%ls ERROR: %ls contains RT_MANIFESTs with multiple RESERVED integral ids\n", Argv0base_cstr, cstr);
                    }
                }
            }
            ret = EXIT_FAILURE;
        }
        if (callbackParam.stringResourceIds.size() > 0)
        {
            printf("%ls WARNING: %ls contains RT_MANIFEST with string ids\n", Argv0base_cstr, cstr);
            ret = EXIT_FAILURE;
        }
        if ((callbackParam.integralResourceIds.size() + callbackParam.stringResourceIds.size()) > 1)
        {
            printf("%ls WARNING: %ls contains multiple RT_MANIFESTs\n", Argv0base_cstr, cstr);
            ret = EXIT_FAILURE;
        }
    }
    return ret;
}

String_t RemoveOptionChar(const String_t& s)
{
    if (s.Length() != 0)
    {
        if (s[0] == '-')
            return s.substr(1);
        else if (s[0] == '/')
            return s.substr(1);
        else if (s[0] == ':') // hacky..
            return s.substr(1);
        else if (s[0] == '=') // hacky..
            return s.substr(1);
    }
    return s;
}

//
// String_t has specialized find_first_not_of that uses integral positions,
// and globally there is only find_first_of. Here we provide the expected
// iterator-based find_first_not_of, based on the std::string code.
//
// Find the first occurence in [first1, last1) of an element in [first2, last).
//
// eg:
//   find_first_not_of("abc":"12;3", ":;");
//                      ^
//   find_first_not_of(":12;3", ":;");
//                       ^
//   find_first_not_of("3", ":;");
//                      ^
//
template <typename Iterator>
Iterator FindFirstNotOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    if (first2 == last2)
        return last1;
    for ( ; first1 != last1 ; ++first1)
    {
        if (std::find(first2, last2, *first1) == last2)
        {
            break;
        }
    }
    return first1;
}

//
// consistent style..
//
template <typename Iterator>
Iterator FindFirstOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    return std::find_first_of(first1, last1, first2, last2);
}

template <typename String_t>
void SplitString(const String_t& String, const String_t& Delim, std::vector<String_t>& Fields)
{
    String_t::const_iterator FieldBegin;
    String_t::const_iterator FieldEnd = String.begin();

    while ((FieldBegin = FindFirstNotOf(FieldEnd, String.end(), Delim.begin(), Delim.end())) != String.end())
    {
        FieldEnd = FindFirstOf(FieldBegin, String.end(), Delim.begin(), Delim.end());
        Fields.push_back(String_t(FieldBegin, FieldEnd));
    }
}

#define RT_MANIFEST                        MAKEINTRESOURCE(24)
#define CREATEPROCESS_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1)
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(2)
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(3)
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1 /*inclusive*/)
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(16 /*inclusive*/)

#define DEFINE_POUND_NUMBER_STRING_(x) \
    { '#', ((x >= 10) ? ('0' + x / 10) : ('0' + x)), ((x >= 10) ? ('0' + x % 10) : 0), 0 }

#define DEFINE_POUND_NUMBER_STRING(x) DEFINE_POUND_NUMBER_STRING_(reinterpret_cast<ULONG_PTR>(x))

const WCHAR PoundRtString[]   = DEFINE_POUND_NUMBER_STRING(RT_STRING);
const WCHAR PoundRtManifest[] = DEFINE_POUND_NUMBER_STRING(RT_MANIFEST);
const WCHAR PoundRtMessageTable[] = DEFINE_POUND_NUMBER_STRING(RT_MESSAGETABLE);

BuiltinResourceId_t BuiltinResourceIds[] =
{
#define X(x) {L## #x, reinterpret_cast<ULONG_PTR>(x) /*, DEFINE_POUND_NUMBER_STRING(x) */ },
    X(CREATEPROCESS_MANIFEST_RESOURCE_ID)
    X(ISOLATIONAWARE_MANIFEST_RESOURCE_ID)
    X(ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID)
    X(MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID)
    X(MINIMUM_RESERVED_MANIFEST_RESOURCE_ID)
    X(RT_ACCELERATOR)
    X(RT_ANICURSOR)
    X(RT_ANIICON)
    X(RT_BITMAP)
    X(RT_CURSOR)
    X(RT_DIALOG)
    X(RT_DLGINCLUDE)
    X(RT_FONT)
    X(RT_FONTDIR)
    X(RT_GROUP_CURSOR)
    X(RT_GROUP_ICON)
#if defined(RT_HTML)
    X(RT_HTML)
#endif
    X(RT_ICON)
    X(RT_MANIFEST)
    X(RT_MENU)
    X(RT_MESSAGETABLE)
    X(RT_PLUGPLAY)
    X(RT_RCDATA)
    X(RT_STRING)
    X(RT_VERSION)
    X(RT_VXD)
#undef X
};

String_t NormalizeResourceId(PCWSTR id)
{
    if (IS_INTRESOURCE(id))
        return NumberToResourceId(static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(id)));
    else 
        return NormalizeResourceId(String_t(id));
}

String_t NormalizeResourceId(const String_t& id)
{
//
// This code should be aware of leading "!" as well.
//

    // RT_MANIFEST => #24
    // 24 => #24

    if (id.Length() == 0)
        return id;
    if (id[0] == '#')
        return id;
    if (iswdigit(id[0]))
        return L"#" + id;

    //
    // We should support stuff like JPN, en-us, etc.
    //
    BuiltinResourceId_t* a = BinarySearch(BuiltinResourceIds, BuiltinResourceIds + NUMBER_OF(BuiltinResourceIds), id);
    if (a != BuiltinResourceIds + NUMBER_OF(BuiltinResourceIds))
    {
        return NumberToResourceId(static_cast<ULONG>(a->Number));
    }
    return id;
}

void __cdecl Error(const wchar_t* s, ...)
{
	printf("%ls\n", s);
	exit(EXIT_FAILURE);
}

void SplitResourceTupleString(const String_t& s, std::set<ResourceIdTuple_t>& ResourceTuples)
{
    //
    // semicolon delimited list of dotted triples
    // wildcards are allowed, * only
    // missing elements are assumed be *
    //
    // RT_* are known (RT_MANIFEST, etc.)
    //
    std::vector<String_t> ResourceTuplesInStringContainer;
    std::vector<String_t> OneResourceTupleInStringVector;
    ResourceIdTuple_t ResourceIdTuple;

    OneResourceTupleInStringVector.resize(3);

    SplitString(s, String_t(L";"), ResourceTuplesInStringContainer);

    for (std::vector<String_t>::const_iterator Iterator = ResourceTuplesInStringContainer.begin();
        Iterator != ResourceTuplesInStringContainer.end();
        ++Iterator
        )
    {
        OneResourceTupleInStringVector.resize(0);
        SplitString(*Iterator, String_t(L"."), OneResourceTupleInStringVector);
        switch (OneResourceTupleInStringVector.size())
        {
        default:
            Error((String_t(L"bad query string '") + s + L"' bad.").c_str());
        case 1:
            OneResourceTupleInStringVector.push_back(L"*");
            // FALLTHROUGH
        case 2:
            OneResourceTupleInStringVector.push_back(L"*");
            // FALLTHROUGH
        case 3:
            break;
        }
        ResourceIdTuple.Type = NormalizeResourceId(OneResourceTupleInStringVector[0]);
        ResourceIdTuple.Name = NormalizeResourceId(OneResourceTupleInStringVector[1]);
        ResourceIdTuple.Language = NormalizeResourceId(OneResourceTupleInStringVector[2]);
        ResourceTuples.insert(ResourceTuples.end(), ResourceIdTuple);
    }
}

//
// This class is important.
// It does the three level nested Enum/callback pattern that is required
// to enumerate all the resources in a .dll.
//
// By default, it requires all the tripls, as well as the size and address
// of the resource, but you can alter this by overriding the virtual functions.
//
class EnumResources_t
{
    typedef EnumResources_t This_t;
public:
    virtual ~EnumResources_t() { }
    EnumResources_t() { }

    static BOOL CALLBACK StaticTypeCallback(HMODULE hModule, LPWSTR lpType, LONG_PTR lParam)
    {
        return reinterpret_cast<This_t*>(lParam)->TypeCallback(hModule, lpType) ? TRUE : FALSE;
    }

    static BOOL CALLBACK StaticNameCallback(HMODULE hModule, PCWSTR lpType, LPWSTR lpName, LONG_PTR lParam)
    {
        return reinterpret_cast<This_t*>(lParam)->NameCallback(hModule, lpType, lpName) ? TRUE : FALSE;
    }

    static BOOL CALLBACK StaticLanguageCallback(HMODULE hModule, PCWSTR lpType, PCWSTR lpName, WORD  wLanguage, LONG_PTR lParam)
    {
        return reinterpret_cast<This_t*>(lParam)->LanguageCallback(hModule, lpType, lpName, wLanguage) ? TRUE : FALSE;
    }

    virtual bool TypeCallback(HMODULE hModule, PCWSTR lpType)
    {
        if (EnumResourceNamesW(hModule, lpType, &This_t::StaticNameCallback, reinterpret_cast<LONG_PTR>(this)))
            return true;
        //if (GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)
            //return true;
        return false;
    }

    virtual bool NameCallback(HMODULE hModule, PCWSTR lpType, PCWSTR lpName)
    {
        if (EnumResourceLanguagesW(hModule, lpType, lpName, &This_t::StaticLanguageCallback, reinterpret_cast<LONG_PTR>(this)))
            return true;
        //if (GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)
            //return true;
        return false;
    }

    virtual bool LanguageCallback(HMODULE Module, PCWSTR lpType, PCWSTR lpName, WORD wLanguage)
    {
        Resource_t Resource;
        Resource.IdTuple.Type = lpType;
        Resource.IdTuple.Name = lpName;
        Resource.IdTuple.Language = NumberToResourceId(wLanguage);
        HRSRC ResourceHandle = FindResourceExW(Module, lpType, lpName, wLanguage);
        if (ResourceHandle == NULL)
            return false;
        HGLOBAL GlobalHandle = LoadResource(Module, ResourceHandle);
        if (GlobalHandle == NULL)
            return false;
        Resource.Address = LockResource(GlobalHandle);
        if (Resource.Address == 0)
            return false;
        Resource.Size = SizeofResource(Module, ResourceHandle);

        this->Resources.insert(Resources.end(), Resource);
        return true;
    }

    std::set<Resource_t> Resources;
 
    bool operator()(HMODULE DllHandle)
    {
        bool Result = EnumResourceTypesW(DllHandle, &This_t::StaticTypeCallback, reinterpret_cast<LONG_PTR>(this)) ? true : false;
        //std::sort(Resources.begin(), Resources.end(), std::ptr_fun(&LessThanByIdTuple));
        return Result;
    }
};

//#define OPEN_RESOURCE_FILE_MAKE_TEMP (0x00000001)

bool ResourceTool_t::OpenResourceFile(ULONG Flags, DDynamicLinkLibrary& dll, String_t Path)
{
    __int64 FileSize = 0;
    Path = PrependDotSlashToRelativePath(Path);

    //
    // skip empty files to avoid STATUS_MAPPED_FILE_SIZE_ZERO -> ERROR_FILE_INVALID,
    //
    if (!GetFileSize(Path, FileSize))
    {
        String_t ErrorString = GetLastErrorString();
        printf("%ls : WARNING: %ls skipped : Error %ls\n", Argv0base_cstr, Path.c_str(), ErrorString.c_str());
        return false;
    }
    if (FileSize == 0)
    {
        printf("%ls : WARNING: empty file %ls skipped\n", Argv0base_cstr, Path.c_str());
        return false;
    }

    if (!dll.Win32Create(Path, LOAD_LIBRARY_AS_DATAFILE))
    {
        DWORD Error = GetLastError();
        String_t ErrorString = GetLastErrorString();
        switch (Error)
        {
        case ERROR_BAD_EXE_FORMAT: // 16bit or not an .exe/.dll at all
            break;
        case ERROR_ACCESS_DENIED: // could be directory (should support sd ... syntax)
            {
                DWORD fileAttributes = GetFileAttributesW(Path);
                if (fileAttributes != INVALID_FILE_ATTRIBUTES && (fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
                    break;
            }
            // FALLTHROUGH
        default:
            printf("%ls : WARNING: %ls skipped, Error %ls\n", Argv0base_cstr, Path.c_str(), ErrorString.c_str());
            break;
        }
        return false;
    }
    return true;
}

void ResourceTool_t::Query()
{
    ChangeEmptyQueryToAllQuery();

    for (Files_t::iterator File = Files.begin() ; File != Files.end() ; ++File)
    {
        DDynamicLinkLibrary dll;
        if (!OpenResourceFile(0, dll, *File))
            continue;

        EnumResources_t EnumResources;
        EnumResources(dll);

        for ( std::set<Resource_t>::iterator EnumIterator = EnumResources.Resources.begin();
              EnumIterator != EnumResources.Resources.end();
              ++EnumIterator
            )
        {
            for ( Tuples_t::iterator QueryIterator = Tuples.begin();
                  QueryIterator != Tuples.end();
                  ++QueryIterator
                )
            {
                if (Match(*EnumIterator, *QueryIterator))
                {
                    printf("%ls: %ls: %ls.%ls.%ls\n",
                        Argv0base_cstr,
                        File->c_str(),
                        static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
                        static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
                        static_cast<PCWSTR>(EnumIterator->IdTuple.Language)
                        );
                    break;
                }
            }
        }
    }
}

void ResourceTool_t::DumpMessageTableResource(
    const File_t& File,
    EnumIterator_t EnumIterator)
{
    PMESSAGE_RESOURCE_DATA MessageData = reinterpret_cast<PMESSAGE_RESOURCE_DATA>(EnumIterator->Address);

    /*
    printf( "%ls: %ls.%ls.%ls.%ls: NumberOfBlocks=0x%lx\n",
            Argv0base_cstr,
            File.c_str(),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Language),
            MessageData->NumberOfBlocks
        );
    */

    for ( ULONG ul = 0; ul < MessageData->NumberOfBlocks; ul++ )
    {
        // 
        // For each block...
        //
        /*
        printf( "%ls: %ls.%ls.%ls.%ls: Block=0x%lx, LowId=0x%lx - HighId=0x%lx, Offset=0x%lx\n",
                Argv0base_cstr,
                File.c_str(),
                static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
                static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
                static_cast<PCWSTR>(EnumIterator->IdTuple.Language),
                ul,
                MessageData->Blocks[ul].LowId,
                MessageData->Blocks[ul].HighId,
                MessageData->Blocks[ul].OffsetToEntries);
        */
        PMESSAGE_RESOURCE_ENTRY MessageEntries = (PMESSAGE_RESOURCE_ENTRY)(((PBYTE)EnumIterator->Address) + MessageData->Blocks[ul].OffsetToEntries);

        for ( 
            ULONG MessageId = MessageData->Blocks[ul].LowId; 
            MessageId < MessageData->Blocks[ul].HighId; 
            MessageId++ )
        {
            PCWSTR Text = reinterpret_cast<PCWSTR>(MessageEntries->Text);
            //int Length = static_cast<int>(::wcslen(Text));
            /*
            for ( ; Length != 0 && (Text[Length - 1] == '\r' || Text[Length - 1] == '\n' || Text[Length - 1] == ' ' || Text[Length - 1] == '\t' || Text[Length - 1] == 0) ; --Length)
            {
            }
            */
            StringW_t String(Text);
            for (PWSTR p = String.begin(); p != String.end() ; ++p)
                if (iswspace(*p))
                //if (*p == '\r' || *p == '\n' || *p == '\t')
                    *p = ' ';
            printf(
                    //"%ls: %ls.%ls.%ls.%ls: Block=0x%lx, Id=0x%lx Flags=0x%lx, Length=0x%lx : %.*ls\n",
                    "%ls: %ls.%ls.%ls.%ls.0x%lx : %ls\n",
                    Argv0base_cstr,
                    File.c_str(),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Language),
                    //ul,
                    MessageId,
                    //MessageEntries->Flags,
                    //MessageEntries->Length,
                    //Length,
                    //Text
                    static_cast<PCWSTR>(String)
                    );
            MessageEntries = reinterpret_cast<PMESSAGE_RESOURCE_ENTRY>(
                reinterpret_cast<PBYTE>(MessageEntries) + MessageEntries->Length);
        }
    }
}

void ResourceTool_t::DumpStringTableResource(const File_t& File, EnumIterator_t EnumIterator)
{
    ULONG ResourceId = StringToNumber(EnumIterator->IdTuple.Name);
    ULONG StringId = (ResourceId - 1) << 4;
    PCWSTR Data = reinterpret_cast<PCWSTR>(EnumIterator->Address);
    ULONG Size = EnumIterator->Size;
    for (ULONG i = 0 ; i < 16 && Data < (Data + Size / sizeof(WCHAR)) ; ((++i), (++StringId), (Data += 1 + *Data)))
    {
        if (*Data != 0)
        {
            StringW_t String;
            String.assign(Data + 1, Data + 1 + *Data);
            for (PWSTR p = String.begin(); p != String.end() ; ++p)
                if (iswspace(*p))
                //if (*p == '\r' || *p == '\n' || *p == '\t')
                    *p = ' ';

            printf(
                    "%ls: %ls.%ls.%ls.%ls.0x%lx : %ls\n",
                    Argv0base_cstr,
                    File.c_str(),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
                    static_cast<PCWSTR>(EnumIterator->IdTuple.Language),
                    StringId,
                    String.c_str()
                    );
        }
    }
}

void ResourceTool_t::DumpManifestResource(const File_t& File, EnumIterator_t EnumIterator)
{
    StringW_t ResourceAsStringW;
    std::vector<WCHAR> MultiToWideBuffer;
    std::vector<StringW_t> LinesW;

    if (!::IsTextUnicode(reinterpret_cast<const void*>(EnumIterator->Address), static_cast<int>(EnumIterator->Size), NULL))
    {
        MultiToWideBuffer.resize(EnumIterator->Size + 2, 0);
        ::MultiByteToWideChar(CP_ACP, 0, reinterpret_cast<PCSTR>(EnumIterator->Address), EnumIterator->Size, &MultiToWideBuffer[0], MultiToWideBuffer.size() - 1);

        ResourceAsStringW = &MultiToWideBuffer[0];
    }
    else
    {
        ResourceAsStringW.assign(reinterpret_cast<PCWSTR>(EnumIterator->Address), EnumIterator->Size / sizeof(WCHAR));
    }
    SplitString(ResourceAsStringW, StringW_t(L"\r\n"), LinesW);

    for (std::vector<StringW_t>::iterator Line = LinesW.begin(); Line != LinesW.end() ; ++Line)
    {
        printf("%ls: %ls.%ls.%ls.%ls: %ls\n",
            Argv0base_cstr,
            File.c_str(),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
            static_cast<PCWSTR>(EnumIterator->IdTuple.Language),
            static_cast<PCWSTR>(*Line)
            );
    }
}

void ResourceTool_t::DumpBinaryResource(const File_t& File, EnumIterator_t EnumIterator)
{
    printf("%ls: %ls.%ls.%ls.%ls\n",
        Argv0base_cstr,
        File.c_str(),
        static_cast<PCWSTR>(EnumIterator->IdTuple.Type),
        static_cast<PCWSTR>(EnumIterator->IdTuple.Name),
        static_cast<PCWSTR>(EnumIterator->IdTuple.Language)
        );
}

void ResourceTool_t::DumpResource(const File_t& File, EnumIterator_t EnumIterator)
{
    if (EnumIterator->IdTuple.Type == PoundRtManifest)
        DumpManifestResource(File, EnumIterator);
    else if (EnumIterator->IdTuple.Type == PoundRtString)
        DumpStringTableResource(File, EnumIterator);
    else if (EnumIterator->IdTuple.Type == PoundRtMessageTable)
        DumpMessageTableResource(File, EnumIterator);
    else
        DumpBinaryResource(File, EnumIterator);
}


void ResourceTool_t::Dump()
{
    ChangeEmptyQueryToAllQuery();

    for (Files_t::iterator File = Files.begin() ; File != Files.end() ; ++File)
    {
        DDynamicLinkLibrary dll;
        if (!OpenResourceFile(0, dll, *File))
            continue;

        EnumResources_t EnumResources;
        EnumResources(dll);

        for ( std::set<Resource_t>::iterator EnumIterator = EnumResources.Resources.begin();
              EnumIterator != EnumResources.Resources.end();
              ++EnumIterator
            )
        {
            for ( Tuples_t::iterator QueryIterator = Tuples.begin();
                  QueryIterator != Tuples.end();
                  ++QueryIterator
                )
            {
                if (Match(*EnumIterator, *QueryIterator))
                {
                    DumpResource(*File, EnumIterator);
                    break;
                }
            }
        }
    }
}

void ResourceTool_t::Delete()
{
    String_t ErrorString;

    for (Files_t::iterator File = Files.begin() ; File != Files.end() ; ++File)
    {
        WCHAR Temp[MAX_PATH * 2];
        Temp[0] = 0;
        {
            DDynamicLinkLibrary dll;
            if (!OpenResourceFile(0, dll, *File))
                continue;

            EnumResources_t EnumResources;
            EnumResources(dll);

            std::set<Resource_t> Delete;

            for ( std::set<Resource_t>::iterator EnumIterator = EnumResources.Resources.begin();
                  EnumIterator != EnumResources.Resources.end();
                  ++EnumIterator
                )
            {
                for ( Tuples_t::iterator QueryIterator = Tuples.begin();
                      QueryIterator != Tuples.end();
                      ++QueryIterator
                    )
                {
                    if (Match(*EnumIterator, *QueryIterator))
                    {
                        Delete.insert(Delete.end(), *EnumIterator);
                    }
                }
            }

            if (Delete.size() != 0)
            {

                std::set<Resource_t> Keep;

                std::set_difference(
                    EnumResources.Resources.begin(),
                    EnumResources.Resources.end(),
                    Delete.begin(),
                    Delete.end(),
                    std::inserter(Keep, Keep.end())
                    );

                union
                {
                    UUID Uuid;
                    __int64 Int64s[2];
                } u;
                ZeroMemory(&u, sizeof(u));
     
                typedef RPC_STATUS (RPC_ENTRY * UuidCreateSequential_t)(UUID *Uuid);

                UuidCreateSequential_t UuidCreateSequential = NULL;

                RPC_STATUS RpcStatus = RPC_S_OK;
                HMODULE Rpcrt4Dll = LoadLibraryW(L"Rpcrt4.dll");
                if (Rpcrt4Dll != NULL)
                    UuidCreateSequential = reinterpret_cast<UuidCreateSequential_t>(GetProcAddress(Rpcrt4Dll, "UuidCreateSequential"));
                if (UuidCreateSequential != NULL)
                    RpcStatus = UuidCreateSequential(&u.Uuid);
                else
                    RpcStatus = UuidCreate(&u.Uuid);
                WCHAR Original[MAX_PATH];
                PWSTR FilePart = NULL;
                Original[0] = 0;
                if (!GetFullPathNameW(*File, MAX_PATH, Original, &FilePart))
                {
                    ErrorString = GetLastErrorString();
                    PrintString((String_t(L"GetFullPathName(") + *File + L") FAILED: " + ErrorString + L"\n").c_str());
                    goto NextFile;
                }
                swprintf(Temp, L"%ls.%I64x%I64x", Original, u.Int64s[0], u.Int64s[1]);
                if (!MoveFileW(Original, Temp))
                {
                    ErrorString = GetLastErrorString();
                    PrintString((String_t(L"MoveFile(") + Original + L", " + Temp + L") FAILED: " + ErrorString + L"\n").c_str());
                    goto NextFile;
                }
                if (!CopyFileW(Temp, Original, TRUE))
                {
                    ErrorString = GetLastErrorString();
                    if (!MoveFileW(Temp, Original))
                    {
                        String_t ErrorString2 = GetLastErrorString();
                        // THIS IS BAD.
                        PrintString((String_t(L"ROLLBACK MoveFile(") + Temp + L", " + Original + L") FAILED: " + ErrorString2 + L"\n").c_str());
                        goto NextFile;
                    }
                    PrintString((String_t(L"CopyFile(") + Temp + L", " + Original + L") FAILED: " + ErrorString + L"\n").c_str());
                    goto NextFile;
                }

                DResourceUpdateHandle ResourceUpdateHandle;
                if (!ResourceUpdateHandle.Win32Create(*File, TRUE))
                {
                    ErrorString = GetLastErrorString();
                    PrintString((String_t(Argv0base + L": ResourceUpdateHandle(") + *File + L" FAILED: " + ErrorString + L"\n").c_str());
                    break;
                }
                for ( std::set<Resource_t>::iterator KeepIterator = Keep.begin();
                      KeepIterator != Keep.end();
                      ++KeepIterator
                    )
                {
                    PCWSTR ResourceType = StringToResourceString(KeepIterator->IdTuple.Type);
                    PCWSTR ResourceName = StringToResourceString(KeepIterator->IdTuple.Name);
                    if (!ResourceUpdateHandle.UpdateResource(
                        ResourceType,
                        ResourceName,
                        static_cast<WORD>(StringToNumber(KeepIterator->IdTuple.Language)),
                        KeepIterator->Address,
                        KeepIterator->Size))
                    {
                        ErrorString = GetLastErrorString();
                        PrintString((String_t(Argv0base + L": ResourceUpdateHandle.UpdateResource(") + *File + L" FAILED: " + ErrorString + L"\n").c_str());
                        goto NextFile;
                    }
                    if (Print.Keep)
                        printf("%ls: KEEP: %ls.%ls.%ls.%ls\n",
                            Argv0base_cstr,
                            File->c_str(),
                            static_cast<PCWSTR>(KeepIterator->IdTuple.Type),
                            static_cast<PCWSTR>(KeepIterator->IdTuple.Name),
                            static_cast<PCWSTR>(KeepIterator->IdTuple.Language)
                            );
                }
                if (Print.Delete)
                {
                    for ( std::set<Resource_t>::iterator DeleteIterator = Delete.begin();
                          DeleteIterator != Delete.end();
                          ++DeleteIterator
                        )
                    {
                        printf("%ls: DELETE: %ls.%ls.%ls.%ls\n",
                            Argv0base_cstr,
                            File->c_str(),
                            static_cast<PCWSTR>(DeleteIterator->IdTuple.Type),
                            static_cast<PCWSTR>(DeleteIterator->IdTuple.Name),
                            static_cast<PCWSTR>(DeleteIterator->IdTuple.Language)
                            );
                    }
                }
                if (!ResourceUpdateHandle.Win32Close(false))
                {
                    ErrorString = GetLastErrorString();
                    PrintString((String_t(Argv0base + L" : ResourceUpdateHandle.Win32Close(") + *File + L") FAILED: " + ErrorString + L"\n").c_str());
                }
                else
                {
                    if (Print.Success)
                        PrintString((Argv0base + L" : SUCCESS: " + *File + L"\n").c_str());
                }
            }
            else
            {
                if (Print.Unchanged)
                    PrintString((Argv0base + L": UNCHANGED: " + *File + L"\n").c_str());
            }
        } // FreeLibrary, so we can delete the temp
        if (Temp[0] != 0)
        {
            BOOL DeleteSuccess = DeleteFileW(Temp);
            if (!DeleteSuccess)
            {
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    Sleep(100);
                    DeleteSuccess = DeleteFileW(Temp);
                }
            }
            if (!DeleteSuccess)
            {
                ErrorString = GetLastErrorString();
                PrintString(((Argv0base + L" : WARNING: DeleteFile(") + Temp + L") FAILED: " + ErrorString + L"\n").c_str());
                if (!MoveFileExW(Temp, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
                {
                    ErrorString = GetLastErrorString();
                    PrintString((Argv0base + L" : WARNING: MoveFileExW(" + Temp + L") FAILED: " + ErrorString + L"\n").c_str());
                }
            }
        }
NextFile:
        ;
    }
}

void ResourceTool_t::FindAndDeleteDuplicates()
{
    if (this->Files.size() != 2)
    {
        printf("%ls : ERROR : Usage...\n", Argv0base_cstr);
        return;
    }
    this->ShouldPrint = false;
    this->FindDuplicates();
    File_t File = this->Files[1];
    this->Files.clear();
    this->Files.push_back(File);
    this->ShouldPrint = true;
    this->Delete();
}

void ResourceTool_t::ChangeEmptyQueryToAllQuery()
{
    if (Tuples.size() == 0)
    {
        ResourceIdTuple_t Tuple;
        Tuple.Language = L"*";
        Tuple.Name = L"*";
        Tuple.Type = L"*";
        Tuples.insert(Tuples.end(), Tuple);
    }
}

void ResourceTool_t::FindDuplicates()
{
    if (Files.size() != 2)
    {
        printf("%ls : ERROR : Usage...\n", Argv0base_cstr);
        return;
    }
    EnumResources_t EnumResources[2];
    DDynamicLinkLibrary dll[2];
    if (!OpenResourceFile(0, dll[0], Files[0]))
    {
        return;
    }
    if (!OpenResourceFile(0, dll[1], Files[1]))
    {
        return;
    }
    EnumResources[0](dll[0]);
    EnumResources[1](dll[1]);

    std::set<Resource_t> Matched[2];
    std::set<Resource_t>::const_iterator Iterators[2];

    Tuples_t DeleteTuples;

    ChangeEmptyQueryToAllQuery();

    Tuples_t::iterator QueryIterator;

    for (QueryIterator = Tuples.begin(); QueryIterator != Tuples.end(); ++QueryIterator)
    {
        for (Iterators[0] = EnumResources[0].Resources.begin() ; Iterators[0] != EnumResources[0].Resources.end() ; ++Iterators[0] )
        {
            if (Match(*Iterators[0], *QueryIterator))
            {
                Matched[0].insert(Matched[0].end(), *Iterators[0]);
            }
        }
        for (Iterators[1] = EnumResources[1].Resources.begin() ; Iterators[1] != EnumResources[1].Resources.end() ; ++Iterators[1] )
        {
            if (Match(*Iterators[1], *QueryIterator))
            {
                Matched[1].insert(Matched[1].end(), *Iterators[1]);
            }
        }
    }
    std::set<Resource_t> Only[2]; // leftonly, rightonly
    Only[0] = Matched[0];
    Only[1] = Matched[1];
    for (QueryIterator = Tuples.begin(); QueryIterator != Tuples.end(); ++QueryIterator)
    {
        for (Iterators[0] = Matched[0].begin() ; Iterators[0] != Matched[0].end() ; ++Iterators[0])
        {
            for (Iterators[1] = Matched[1].begin(); Iterators[1] != Matched[1].end(); ++Iterators[1])
            {
                if (
                    Iterators[0]->IdTuple.Type == Iterators[1]->IdTuple.Type     // hack
                    && Iterators[0]->IdTuple.Name == Iterators[1]->IdTuple.Name  // hack
                    && Match(*Iterators[1], *QueryIterator) // kind of hacky..we don't query iterator[0]
                    )
                {
                    Only[0].erase(*Iterators[0]);
                    Only[1].erase(*Iterators[1]);
                    if (Iterators[0]->Size != Iterators[1]->Size)
                    {
                        if (ShouldPrint
                            && Print.UnequalSize
                            )
                            printf("%ls : UNEQUAL_SIZE : %ls.%ls.%ls.%ls, %ls.%ls.%ls.%ls\n",
                                Argv0base_cstr,
                                static_cast<PCWSTR>(Files[0]),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Language),
                                static_cast<PCWSTR>(Files[1]),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Language)
                                );
                        //UnequalSize.insert(UnequalSize.end(), Iterators[1]->IdTuple);
                    }
                    else if (memcmp(Iterators[0]->Address, Iterators[1]->Address, Iterators[0]->Size) == 0)
                    {
                        if (ShouldPrint
                            && Print.Equal)
                            printf("%ls : EQUAL : %ls.%ls.%ls.%ls, %ls.%ls.%ls.%ls\n",
                                Argv0base_cstr,
                                static_cast<PCWSTR>(Files[0]),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Language),
                                static_cast<PCWSTR>(Files[1]),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Language)
                                );
                        DeleteTuples.insert(DeleteTuples.end(), Iterators[1]->IdTuple);
                    }
                    else
                    {
                        if (ShouldPrint
                            && Print.UnequalContents)
                            printf("%ls : UNEQUAL_CONTENTS : %ls.%ls.%ls.%ls, %ls.%ls.%ls.%ls\n",
                                Argv0base_cstr,
                                static_cast<PCWSTR>(Files[0]),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[0]->IdTuple.Language),
                                static_cast<PCWSTR>(Files[1]),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Type),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Name),
                                static_cast<PCWSTR>(Iterators[1]->IdTuple.Language)
                                );
                        //UnequalContents.insert(UnequalSize.end(), Iterators[1]->IdTuple);
                    }
                }
            }
        }
    }
    if (ShouldPrint && Print.LeftOnly)
    {
        for (Iterators[0] = Only[0].begin() ; Iterators[0] != Only[0].end() ; ++Iterators[0])
        {
            printf("%ls : LEFT_ONLY : %ls.%ls.%ls.%ls, %ls.%ls.%ls.%ls\n",
                Argv0base_cstr,
                static_cast<PCWSTR>(Files[0]),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Type),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Name),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Language),
                static_cast<PCWSTR>(Files[1]),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Type),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Name),
                static_cast<PCWSTR>(Iterators[0]->IdTuple.Language)
                );
        }
    }
    if (ShouldPrint && Print.RightOnly)
    {
        for (Iterators[1] = Only[1].begin() ; Iterators[1] != Only[1].end() ; ++Iterators[1])
        {
            printf("%ls : RIGHT_ONLY : %ls.%ls.%ls.%ls, %ls.%ls.%ls.%ls\n",
                Argv0base_cstr,
                static_cast<PCWSTR>(Files[0]),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Type),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Name),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Language),
                static_cast<PCWSTR>(Files[1]),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Type),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Name),
                static_cast<PCWSTR>(Iterators[1]->IdTuple.Language)
                );
        }
    }
    Tuples = DeleteTuples;
}

int ResourceTool_t::Main(const StringVector_t& args)
{
    StringVectorConstIterator_t i;
    Operation_t Operation = NULL;

    for (i = args.begin() ; i != args.end() ; ++i)
    {
        String_t s;
        String_t t;
        bool PrintAll = false;
        bool PrintNone = false;
        bool PrintValue = true;
        bool PrintUnequal = false;

        s = *i;
        s = RemoveOptionChar(s);

        if (s == L"Sxid12Tool1")
        {
            StringVector_t restArgs(i + 1, args.end());
            return Sxid12Tool1(restArgs);
        }
        else if (GetFileAttributesW(s) != 0xFFFFFFFF)
        {
            goto FileLabel;
        }
        else if (s.Starts(t = L"Query"))
            Operation = &This_t::Query;
        else if (s.Starts(t = L"FindDuplicates"))
            Operation = &This_t::FindDuplicates;
        else if (s.Starts(t = L"Explode"))
            Operation = &This_t::Explode;
        else if (s.Starts(t = L"Diff"))
        {
            Operation = &This_t::FindDuplicates;
            Print.LeftOnly = true;
            Print.RightOnly = true;
            Print.Equal = true;
            Print.UnequalContents = true;
            Print.UnequalSize = true;
        }
        else if (s.Starts(t = L"Delete"))
            Operation = &This_t::Delete;
        else if (s.Starts(t = L"Dump"))
            Operation = &This_t::Dump;
        else if (s.Starts(t = L"FindAndDeleteDuplicates"))
            Operation = &This_t::FindAndDeleteDuplicates;
        else if (s.Starts(t = L"NoPrint"))
        {
            PrintValue = !PrintValue;
            goto PrintCommonLabel;
        }
        else if (s.Starts(t = L"Print"))
        {
PrintCommonLabel:
            s = RemoveOptionChar(s.substr(t.Length()));
            bool* Member = NULL;
            if (s == (t = L"UnequalSize"))
                Member = &this->Print.UnequalSize;
            else if (s == (t = L"UnequalContents"))
                Member = &this->Print.UnequalContents;
            else if (s == (t = L"UnequalSize"))
                Member = &this->Print.UnequalSize;
            else if (s == (t = L"Keep"))
                Member = &this->Print.Keep;
            else if (s == (t = L"Delete"))
                Member = &this->Print.Delete;
            else if (s == (t = L"Success"))
                Member = &this->Print.Success;
            else if (s == (t = L"Unchanged"))
                Member = &this->Print.Unchanged;
            else if (s == (t = L"Equal"))
                Member = &this->Print.Equal;
            else if (s == (t = L"LeftOnly"))
                Member = &this->Print.LeftOnly;
            else if (s == (t = L"RightOnly"))
                Member = &this->Print.RightOnly;
            else if (s == L"All")
            {
                PrintAll = true;
                Print.SetAll(true);
            }
            else if (s == L"None")
            {
                PrintNone = true;
                Print.SetAll(false);
            }
            else if (s == L"Unequal")
            {
                PrintUnequal = true;
                this->Print.UnequalContents = true;
                this->Print.UnequalSize = true;
            }
            if (PrintAll || PrintNone || PrintUnequal)
            {
                // nothing
            }
            else if (Member == NULL)
            {
                printf("%ls : WARNING: unknown print option \"%ls\" ignored\n", Argv0base_cstr, static_cast<PCWSTR>(s));
                continue;
            }
            else
            {
                bool knownValue = true;
                s = RemoveOptionChar(s.substr(t.Length()));
                if (s != L"")
                {
                    //
                    // This doesn't work because of the equality comparisons above. They need
                    // ignore whatever follows the colon.
                    //
                    if (s == L"No" || s == L"False")
                        PrintValue = !PrintValue;
                    else if (s == L"Yes" || s == L"True")
                    {
                        /* nothing */
                    }
                    else
                    {
                        knownValue = false;
                        printf("%ls : WARNING: unknown print option \"%ls\" ignored\n", Argv0base_cstr, static_cast<PCWSTR>(s));
                        continue;
                    }
                }
                if (knownValue)
                    *Member = PrintValue;
            }
            continue;
        }
        else if (s.Starts(t = L"File"))
        {
FileLabel:
            s = RemoveOptionChar(s.substr(t.Length()));
            Files.push_back(s);
            continue;
        }
        else
        {
            Files.push_back(s);
            continue;
        }
        s = RemoveOptionChar(s.substr(t.Length()));
        SplitResourceTupleString(s, Tuples);
    }
    //std::sort(Tuples.begin(), Tuples.end());
    if (Operation == NULL)
    {
        printf("Usage...\n");
        return EXIT_FAILURE;
    }
    (this->*Operation)();
    return EXIT_SUCCESS;
}

extern "C"
{
	//void __cdecl mainCRTStartup(void);
	void __cdecl wmainCRTStartup(void);
}

int __cdecl main(int argc, char** argv)
{
	wmainCRTStartup();
	return 0;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    ResourceTool_t rtool;
    StringVector_t args;
    args.reserve(argc);
    rtool.Argv0 = argv[0];
    String_t::size_type p = rtool.Argv0.find_last_of(L"\\/");
    if (p != rtool.Argv0.npos)
        rtool.Argv0base = rtool.Argv0.substr(1 + p);
    else
        rtool.Argv0base = rtool.Argv0;
    p = rtool.Argv0base.find_last_of(L".");
    if (p != rtool.Argv0base.npos)
        rtool.Argv0base = rtool.Argv0base.substr(0, p);
    rtool.Argv0base_cstr = rtool.Argv0base.c_str();
    std::copy(argv + 1, argv + argc, std::back_inserter(args));
    int ret = rtool.Main(args);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sharinghazardcheck\minmax.h ===
// MinMax.h

#if !defined(VSEE_LIB_MINMAX_H_INCLUDED_) // {
#define VSEE_LIB_MINMAX_H_INCLUDED_

// If you include this early enough, you'll get
// template <class T> std::min(T, T);
// template <class T> std::max(T, T);
// instead of any variation like
// std::_cpp_min or #define min ...

#pragma once

// defeat non std:: definitions of min and max
#define _INC_MINMAX
#define NOMINMAX
/* these two "identity #defines" prevent straightforward
future #defines, like, without deliberately #undefing them.
*/
#define min min
#define max max
#define _cpp_min min
#define _cpp_max max

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\create.h ===
#pragma once

struct CREATEACTCTX_THREAD_PROC_DATA
{
    CREATEACTCTX_THREAD_PROC_DATA() : Stop(false), Sleep(10)
    {
        ZeroMemory(&ActCtx, sizeof(ActCtx));
        ActCtx.cbSize = sizeof(ActCtx);
    }

    CDequeLinkage       Linkage;

    CThread             Thread;

    ACTCTXW             ActCtx;
    CTinyStringBuffer   DllName;
    CTinyStringBuffer   Source;
    CTinyStringBuffer   ResourceName;
    CTinyStringBuffer   ApplicationName;
    CTinyStringBuffer   AssemblyDirectory;

    ULONG               Sleep;

    bool                Stop;

private:
    CREATEACTCTX_THREAD_PROC_DATA(const CREATEACTCTX_THREAD_PROC_DATA&);
    void operator=(const CREATEACTCTX_THREAD_PROC_DATA&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sharinghazardcheck\casts.h ===
#pragma once

#if !defined(__cplusplus)
typedef enum bool { false, true } bool;
#if !defined(CONST_CAST)
#define CONST_CAST(t) (t)
#endif
#define STATIC_CAST(t) (t)
#define REINTERPRET_CAST(t) (t)
#define INT_TO_ENUM_CAST(e) /* nothing */
#define FUNCTION_POINTER_CAST(t) (t)
#else
#if !defined(CONST_CAST)
#define CONST_CAST(t) const_cast<t>
#endif
#define STATIC_CAST(t) static_cast<t>
#define INT_TO_ENUM_CAST(e) static_cast<e>
#define REINTERPRET_CAST(t) reinterpret_cast<t>
#define FUNCTION_POINTER_CAST(t) reinterpret_cast<t>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sharinghazardcheck\handle.h ===
#pragma once

template <void* const* invalidValue, typename Closer>
class CHandleTemplate
{
public:
	// void* instead of HANDLE to fudge views
	// HANDLE is void*
	CHandleTemplate(const void* handle = *invalidValue);
	~CHandleTemplate();
	void Close();
	void* Detach();
	void operator=(const void*);

	operator void*();
	operator const void*() const;

	void* m_handle;

private:
	CHandleTemplate(const CHandleTemplate&); // deliberately not implemented
	void operator=(const CHandleTemplate&); // deliberately not implemented
};

__declspec(selectany) extern void* const hInvalidValue	= INVALID_HANDLE_VALUE;
__declspec(selectany) extern void* const hNull			= NULL;

class COperatorDeregisterEventSource
{
public:	void operator()(void* handle) const;
};

class COperatorCloseEventLog
{
public:	void operator()(void* handle) const;
};

class COperatorCloseHandle
{
public:	void operator()(void* handle) const;
};

class COperatorFindClose
{
public:	void operator()(void* handle) const;
};

class COperatorUnmapViewOfFile
{
public: void operator()(void* handle) const;
};

class COperatorRegCloseKey
{
public: void operator()(void* handle) const;
};

class CFindFile : public CHandleTemplate<&hInvalidValue, COperatorFindClose>
{
private:
	typedef CHandleTemplate<&hInvalidValue, COperatorFindClose> Base;
public:
	CFindFile() { }
	CFindFile(void* handle) : Base(handle) { }
	CFindFile(PCSTR nameOrWildcard, WIN32_FIND_DATA*);
	HRESULT HrCreate(PCSTR nameOrWildcard, WIN32_FIND_DATA*);
	void VCreate(PCSTR nameOrWildcard, WIN32_FIND_DATA*);
	void operator=(void* v) { Base::operator=(v); }
};

class CFusionFile : public CHandleTemplate<&hInvalidValue, COperatorCloseHandle>
{
private:
	typedef CHandleTemplate<&hInvalidValue, COperatorCloseHandle> Base;
public:
	CFusionFile() { }
	CFusionFile(void* handle) : Base(handle) { }
	CFusionFile(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
	HRESULT HrCreate(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
	void VCreate(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
	__int64 GetSize() const;
	void operator=(void* v) { Base::operator=(v); }
};

class CFileMapping : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
	typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
	CFileMapping() { }
	CFileMapping(void* handle) : Base(handle) { }
	CFileMapping(void* file, DWORD flProtect, __int64 maximumSize=0, PCSTR name=0);
	void VCreate(void* file, DWORD flProtect, __int64 maximumSize=0, PCSTR name=0);
	HRESULT HrCreate(void* file, DWORD flProtect, __int64 maximumSize=0, PCSTR name=0);
	void operator=(void* v) { Base::operator=(v); }
};

class CMappedViewOfFile : public CHandleTemplate<&hNull, COperatorUnmapViewOfFile>
{
private:
	typedef CHandleTemplate<&hNull, COperatorUnmapViewOfFile> Base;
public:
	CMappedViewOfFile() { }
	CMappedViewOfFile(void* handle) : Base(handle) { }
	CMappedViewOfFile(void* fileMapping, DWORD access, __int64 offset=0, SIZE_T size=0);
	void VCreate(void* fileMapping, DWORD access, __int64 offset=0, SIZE_T size=0);
	HRESULT HrCreate(void* fileMapping, DWORD access, __int64 offset=0, SIZE_T size=0);
	void operator=(void* v) { Base::operator=(v); }
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CFindFile::CFindFile(PCSTR nameOrWildcard, WIN32_FIND_DATA* data)
: Base(INVALID_HANDLE_VALUE)
{
	VCreate(nameOrWildcard, data);
}

inline HRESULT CFindFile::HrCreate(PCSTR nameOrWildcard, WIN32_FIND_DATA* data)
{
	HANDLE hTemp = FindFirstFile(nameOrWildcard, data);
	if (hTemp == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());
	operator=(hTemp);
	return S_OK;
}

inline void CFindFile::VCreate(PCSTR nameOrWildcard, WIN32_FIND_DATA* data)
{
	CheckHresult(HrCreate(nameOrWildcard, data));
}

inline HRESULT CFusionFile::HrCreate(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
	HANDLE hTemp = CreateFile(name, access, share, NULL, openOrCreate, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hTemp == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());
	operator=(hTemp);
	return S_OK;
}

inline CFusionFile::CFusionFile(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate)
: Base(INVALID_HANDLE_VALUE)
{
	VCreate(name, access, share, openOrCreate);
}

inline VOID CFusionFile::VCreate(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
	CheckHresult(HrCreate(name, access, share, openOrCreate));
}

inline __int64 CFusionFile::GetSize() const
{
	DWORD highPart = 0;
	DWORD lastError = NO_ERROR;
	DWORD lowPart = GetFileSize(m_handle, &highPart);
	if (lowPart == INVALID_FILE_SIZE && (lastError = GetLastError()) != NO_ERROR)
	{
		ThrowHresult(HRESULT_FROM_WIN32(lastError));
	}
	LARGE_INTEGER liSize;
	liSize.LowPart = lowPart;
	liSize.HighPart = highPart;
	return liSize.QuadPart;
}

inline HRESULT CFileMapping::HrCreate(void* file, DWORD flProtect, __int64 maximumSize, PCSTR name)
{
	LARGE_INTEGER liMaximumSize;
	liMaximumSize.QuadPart = maximumSize;
	HANDLE hTemp = CreateFileMapping(file, NULL, flProtect, liMaximumSize.HighPart, liMaximumSize.LowPart, name);
	if (hTemp == NULL)
		return HRESULT_FROM_WIN32(GetLastError());
	Base::operator=(hTemp);
	return S_OK;
}

inline CFileMapping::CFileMapping(void* file, DWORD flProtect, __int64 maximumSize, PCSTR name)
: Base(NULL)
{
	VCreate(file, flProtect, maximumSize, name);
}

inline void CFileMapping::VCreate(void* file, DWORD flProtect, __int64 maximumSize, PCSTR name)
{
	CheckHresult(HrCreate(file, flProtect, maximumSize, name));
}

inline CMappedViewOfFile::CMappedViewOfFile(void* fileMapping, DWORD access, __int64 offset, SIZE_T size)
: Base(NULL)
{
	VCreate(fileMapping, access, offset, size);
}

inline void CMappedViewOfFile::VCreate(void* fileMapping, DWORD access, __int64 offset, SIZE_T size)
{
	CheckHresult(HrCreate(fileMapping, access, offset, size));
}

inline HRESULT CMappedViewOfFile::HrCreate(void* fileMapping, DWORD access, __int64 offset, SIZE_T size)
{
	LARGE_INTEGER liOffset;
	liOffset.QuadPart = offset;

	void* pvTemp = MapViewOfFile(fileMapping, access, liOffset.HighPart, liOffset.LowPart, size);
	if (pvTemp == NULL)
		return HRESULT_FROM_WIN32(GetLastError());
	Base::operator=(pvTemp);
	return S_OK;
}

inline void COperatorCloseHandle::operator()(void* handle) const { CloseHandle(handle); }
inline void COperatorFindClose::operator()(void* handle) const { FindClose(handle); }
inline void COperatorUnmapViewOfFile::operator()(void* handle) const { UnmapViewOfFile(handle); }
inline void COperatorRegCloseKey::operator()(void* handle) const { RegCloseKey(reinterpret_cast<HKEY>(handle)); }
inline void COperatorCloseEventLog::operator()(void* handle) const { CloseEventLog(handle); }
inline void COperatorDeregisterEventSource::operator()(void* handle) const { DeregisterEventSource(handle); }

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::CHandleTemplate(const void* handle)
: m_handle(const_cast<void*>(handle))
{
}

template <void* const* invalidValue, typename Closer>
void* CHandleTemplate<invalidValue, Closer>::Detach()
{
	void* handle = m_handle;
	m_handle = *invalidValue;
	return handle;
}

template <void* const* invalidValue, typename Closer>
void CHandleTemplate<invalidValue, Closer>::operator=(const void* handle)
{
	m_handle = const_cast<void*>(handle);
}

template <void* const* invalidValue, typename Closer>
void CHandleTemplate<invalidValue, Closer>::Close()
{
	void* handle = Detach();
	if (handle != *invalidValue)
	{
		Closer close;
		close(handle);
	}
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::~CHandleTemplate()
{
	Close();
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator void*()
{
	return m_handle;
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator const void*() const
{
	return m_handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\create.cpp ===
#include "stdinc.h"
#include "st.h"
#include "create.h"

CDeque<CREATEACTCTX_THREAD_PROC_DATA, offsetof(CREATEACTCTX_THREAD_PROC_DATA, Linkage)> g_ActCtxs;

#define DATA_DIRECTORY_NAME             L"createactctx"
#define INI_FILE                        L"createactctx.ini"
#define INI_FILE2                       L"assembly.ini" /* reuse install test cases */

const static FUSION_FLAG_FORMAT_MAP_ENTRY CreateActCtxFlagData[] =
{
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID, "ProcessorArchitecture")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_LANGID_VALID, "Langid")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID, "AssemblyDirectory")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_RESOURCE_NAME_VALID, "ResourceName")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_SET_PROCESS_DEFAULT, "SetProcessDefault")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_APPLICATION_NAME_VALID, "ApplicationName")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF, "AssemblyRef")
    DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTCTX_FLAG_HMODULE_VALID, "Hmodule")
};

BOOL InitializeCreateActCtx()
{
    FN_PROLOG_WIN32

    CFindFile hFind;
    WIN32_FIND_DATAW wfd;
    CStringBuffer TempDirectory;
    CDequeIterator<CREATEACTCTX_THREAD_PROC_DATA, offsetof(CREATEACTCTX_THREAD_PROC_DATA, Linkage)> iter(&g_ActCtxs);
    CSmallStringBuffer IniFilePath;

    if (!TempDirectory.Win32Assign(BaseDirectory))
        goto Exit;

    if (!TempDirectory.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
        goto Exit;

    if ((wfd.dwFileAttributes = ::GetFileAttributesW(TempDirectory)) == 0xffffffff
        && (wfd.dwFileAttributes = ::FusionpGetLastWin32Error()) == ERROR_FILE_NOT_FOUND)
    {
        printf("no %ls tests, skipping\n", DATA_DIRECTORY_NAME);
        FN_SUCCESSFUL_EXIT();
    }

    if (!TempDirectory.Win32AppendPathElement(L"*", 1))
        goto Exit;

    hFind = ::FindFirstFileW(TempDirectory, &wfd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to find any files matching \"%ls\"\n", static_cast<PCWSTR>(TempDirectory));
        goto Exit;
    }

    for (;;)
    {
        CTinyStringBuffer TempString;
        CTinyStringBuffer BaseDirectory2;
        CREATEACTCTX_THREAD_PROC_DATA *pData = NULL;

        if (FusionpIsDotOrDotDot(wfd.cFileName))
              goto Skip;

        if (!BaseDirectory2.Win32Assign(BaseDirectory))
            goto Exit;

        if (!BaseDirectory2.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
            goto Exit;

        if (!BaseDirectory2.Win32AppendPathElement(wfd.cFileName, wcslen(wfd.cFileName)))
            goto Exit;

        if ((pData = new CREATEACTCTX_THREAD_PROC_DATA) == NULL)
        {
            ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
            ::ReportFailure("Failed to allocate CREATEACTCTX_THREAD_PROC_DATA\n");
            goto Exit;
        }

        if (!IniFilePath.Win32Assign(BaseDirectory2))
            goto Exit;
        if (!IniFilePath.Win32AppendPathElement(INI_FILE, NUMBER_OF(INI_FILE) - 1))
            goto Exit;
        if (::GetFileAttributesW(IniFilePath) == 0xffffffff
            && ::FusionpGetLastWin32Error() == ERROR_FILE_NOT_FOUND)
        {
            if (!IniFilePath.Win32Assign(BaseDirectory2))
                goto Exit;
            if (!IniFilePath.Win32AppendPathElement(INI_FILE2, NUMBER_OF(INI_FILE2) - 1))
                goto Exit;
        }

        TempString.Clear();
        //if (!SxStressToolGetStringSetting(0, IniFilePath, L"create", L"source", L"assembly.manifest", TempString, NULL))
        if (!SxStressToolGetStringSetting(0, IniFilePath, L"assembly", L"manifest", L"assembly.manifest", TempString, NULL))
            goto Exit;
        if (TempString.Cch() != 0)
        {
            if (!pData->Source.Win32Assign(BaseDirectory2))
                goto Exit;
            if (!pData->Source.Win32AppendPathElement(TempString))
                goto Exit;
            pData->ActCtx.lpSource = pData->Source;
        }
        TempString.Clear();

        if (!SxStressToolGetStringSetting(0, IniFilePath, L"create", L"dllname", L"", pData->DllName, NULL))
            goto Exit;

        if (!SxStressToolGetStringSetting(0, IniFilePath, L"create", L"assemblydirectory", L"", pData->AssemblyDirectory, &pData->ActCtx.lpAssemblyDirectory))
            goto Exit;

        if (!SxStressToolGetStringSetting(0, IniFilePath, L"create", L"applicationname", L"", pData->ApplicationName, &pData->ActCtx.lpApplicationName))
            goto Exit;

        if (!SxStressToolGetFlagSetting(0, IniFilePath, L"create", L"flags", pData->ActCtx.dwFlags, CreateActCtxFlagData, NUMBER_OF(CreateActCtxFlagData)))
            goto Exit;

        if (!SxStressToolGetResourceIdSetting(0, IniFilePath, L"create", L"resourcename", pData->ResourceName, &pData->ActCtx.lpResourceName))
            goto Exit;

        g_ActCtxs.AddToTail(pData);

Skip:
        if (!::FindNextFileW(hFind, &wfd))
        {
            if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
            {
                ::ReportFailure("Error iterating over assemblies\n");
                goto Exit;
            }
            break;
        }
    }

    for (iter.Reset(); iter.More(); iter.Next())
    {
        if (!iter->Thread.Win32CreateThread(&CreateActCtxThreadProc, iter.Current()))
        {
            ::ReportFailure("Error launching install thread\n");
            goto Exit;
        }
        TotalThreads += 1;
    }

    FN_EPILOG
}

void RequestShutdownCreateActCtxThreads()
{
    CDequeIterator<CREATEACTCTX_THREAD_PROC_DATA, offsetof(CREATEACTCTX_THREAD_PROC_DATA, Linkage)> iter(&g_ActCtxs);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        iter->Stop = true;
    }
}

void WaitForCreateActCtxThreads()
{
    CDequeIterator<CREATEACTCTX_THREAD_PROC_DATA, offsetof(CREATEACTCTX_THREAD_PROC_DATA, Linkage)> iter(&g_ActCtxs);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        DWORD WaitResult = ::WaitForSingleObject(iter->Thread, INFINITE);
        switch (WaitResult)
        {
        case WAIT_OBJECT_0:
            break;
        case WAIT_FAILED:
            ::ReportFailure("Failed to WaitForSingleObject.\n");
            break;
        default:
            ::FusionpSetLastWin32Error(WaitResult);
            ::ReportFailure("Failed to WaitForSingleObject.\n");
            break;
        }
        iter->Thread.Win32Close();
    }
}

void CleanupCreateActCtx()
{
    g_ActCtxs.ClearAndDeleteAll();
}


DWORD
WINAPI
CreateActCtxThreadProc(
    LPVOID pvData
    )
{
    DWORD dwReturnValue = ERROR_INTERNAL_ERROR;
    DWORD WaitResult = 0;
    CREATEACTCTX_THREAD_PROC_DATA *pData = reinterpret_cast<CREATEACTCTX_THREAD_PROC_DATA *>(pvData);

    InterlockedIncrement(&ThreadsWaiting);
    WaitResult = WaitForSingleObject(ResumeThreadsEvent, INFINITE);
    switch (WaitResult)
    {
    case WAIT_OBJECT_0:
        break;
    case WAIT_FAILED:
        dwReturnValue = ::FusionpGetLastWin32Error();
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    default:
        dwReturnValue = WaitResult;
        ::FusionpSetLastWin32Error(WaitResult);
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    }

    while (!pData->Stop)
    {
        CFusionActCtxHandle ActCtxHandle;

        if (!ActCtxHandle.Win32Create(&pData->ActCtx))
        {
            dwReturnValue = ::FusionpGetLastWin32Error();
            ::ReportFailure("[%lx.%lx] CreateActCtx(\"%ls\", 0x%lx) failed %lu\n",
                SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                pData->ActCtx.lpSource,
                pData->ActCtx.dwFlags,
                dwReturnValue);
            //goto Exit;
        }
        else
        {
            printf("[%lx.%lx] CreateActCtx(%ls, 0x%lx) succeeded\n",
                SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                pData->ActCtx.lpSource, pData->ActCtx.dwFlags
                );

            if (pData->DllName.Cch() != 0)
            {
                CDynamicLinkLibrary Dll;
                
                if (Dll.Win32LoadLibrary(pData->DllName))
                {
                    ::FusionpSetLastWin32Error(NO_ERROR);
                    ::ReportFailure("[%lx.%lx] CreateActCtx(\"%ls\", 0x%lx) succeeded\n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->ActCtx.lpSource,
                        pData->ActCtx.dwFlags
                        );
                }
                else
                {
                    ::ReportFailure("[%lx.%lx] CreateActCtx(\"%ls\", 0x%lx) failed %lu\n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->ActCtx.lpSource,
                        pData->ActCtx.dwFlags,
                        ::FusionpGetLastWin32Error()
                        );
                }
            }
        }

        ::WaitForSingleObject(StopEvent, pData->Sleep);
    }

    dwReturnValue = ERROR_SUCCESS;
Exit:
    printf("[%lx.%lx] CreateActCtx(%ls, 0x%lx) thread exiting 0x%lx\n",
        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
        pData->ActCtx.lpSource, pData->ActCtx.dwFlags,
        dwReturnValue);
    return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sharinghazardcheck\sharinghazardcheck.cpp ===
/*
A hack to look in source files for "sharing hazards",
very simple code patterns that should be examined to determine
if multiple versions of the code can live "side-by-side".

Problems are explicit unversioned sharing.

Registry writes.
File system writes.
Naming of objects (kernel objects) -- open or create.
*/
/*
UNDONE and BUGS
	preprocessor directives are ignored
	the behavior of mbcs in strings and comments is not quite determinate
	there is not yet anyway to quash warnings
	backslash line continuation is not implemented, nor are trigraphs (trigraphs can produce
# and \ for preprocessor directives or line continuation)
	no unicode support
	no \u support
	not quite tolerant of embedded nuls in file, but almost now
	some inefficiency
	some uncleanliness
		the reuse of the comment stripper isn't quite right
		the global line tracking isn't ver effiecent, but works

@owner a-JayK, JayKrell
*/
/\
*
BUG line continuation
*\
/
/\
/ not honored
/* The VC6 editor does not highlight the above correctly, but
the compiler implements it correctly. */

#pragma warning(disable:4786) /* long names in debug info truncated */
#pragma warning(disable:4018) /* signed/unsigned */
#include "MinMax.h"
/* notice how good VC's support of trigraphs and line continuation is */
??=include <st??/
dio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#incl\
ude "windows.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include "Casts.h"
void CheckHresult(HRESULT);
void ThrowHresult(HRESULT);
#include "Handle.h"
#include "comdef.h"
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <stack>
#include <iostream>

typedef struct HazardousFunction HazardousFunction;
typedef int (__cdecl* QsortFunction)(const void*, const void*);
typedef int (__cdecl* BsearchFunction)(const void*, const void*);
class CLine;
class CClass;
enum ETokenType;

/* get msvcrt.dll wildcard processing, doesn't work with libc.lib */
//extern
//#if defined(__cplusplus)
//"C"
//#endif
//int _dowildcard = 1;

const char* CheckCreateObject(const CClass&);
const char* CheckCreateFile(const CClass&);
const char* CheckRegOpenEx(const CClass&);

void PrintOpenComment();
void PrintCloseComment();
void PrintSeperator();

unsigned short StringLeadingTwoCharsTo14Bits(const char* s);

void __stdcall CheckHresult(HRESULT hr)
{
	if (FAILED(hr))
		ThrowHresult(hr);
}

void __stdcall ThrowHresult(HRESULT hr)
{
	throw _com_error(hr, NULL);
}

const char banner[] = "SharingHazardCheck version " __DATE__ " " __TIME__ "\n";

const char usage[]=
"%s [options directories files]\n"
"version: " __DATE__ " " __TIME__ "\n"
"\n"
"Options may appear in any order; command line is order independent\n"
"Wildcards are accepted for filenames. Wildcards never match directories.\n"
"\n"
"default output format\n"
"  file(line):reason\n"
"-recurse\n"
"-print-line\n"
"	prints line of code with offending function after file(line):reason\n"
"-print-statement\n"
"	print statement containing offending function after file(line):reason\n"
"	supersedes -print-line\n"
//"-print-context-lines:n\n"
//"	-print-statement plus surrounding n lines (not implemented)\n"
"-print-context-statements:n (n is 1-4, pinned at 4, 0 untested)\n"
"	-print-statement plus surrounding n \"statements\"\n"
"file names apply across all directories recursed into\n"
"wild cards apply across all directories recursed into\n"
"naming a directory implies one level recursion (unless -recurse is also seen)\n"
//"environment variable SHARING_HAZARD_CHECK_OPTIONS added to argv (not implemented)\n"
"all directory walking happens before any output is generated, it is slow\n"
"\n"
"The way recursion and wildcards work might not be intuitive.\n";

enum ETokenType
{
	/* character values show up too including
	(), but probably not for any potentially multi char token like !=
	*/
	eTokenTypeIdentifier = 128,
	eTokenTypeHazardousFunction,
	eTokenTypeStringConstant,
	eTokenTypeCharConstant,
	eTokenTypeNumber, /* floating point or integer, we don't care */
	eTokenTypePreprocessorDirective /* the entire line is one token */
};

class CLine
{
public:
	CLine() : m_start(0), m_number(1)
	{
	}

	const char* m_start;
	int   m_number;
};

class CRange
{
public:
	const char* begin;
	const char* end;
};
typedef CRange CStatement;

class CClass
{
public:
	CClass();
	explicit CClass(const CClass&);
	void operator=(const CClass&);
	~CClass() { }

	bool OpenFile(const char*);
	int GetCharacter();
	ETokenType GetToken();

/* public */
	const char*	m_tokenText; /* only valid for identifiers */
	int			m_tokenLength; /* only valid for identifiers */
	ETokenType	m_eTokenType;
	HazardousFunction* m_hazardousFunction;

/* semi private */
	const char* m_begin; // used to issue warnings for copied/sub scanners
	const char*	m_str; // current position
	const char*	m_end; // usually end of file, sometimes earlier ("just past")
	bool	m_fPoundIsPreprocessor; // is # a preprocessor directive?
	int		m_spacesSinceNewline; /* FUTURE deduce indentation style */
	bool	m_fInComment; // if we return newlines within comments.. (we don't)
	char	m_rgchUnget[16]; /* UNDONE this is bounded to like 1 right? */
	int		m_nUnget;

	void  NoteStatementStart(const char*);
	// a statement is simply code delimited by semicolons,
	// we are confused by if/while/do/for
	mutable CStatement m_statements[4];
	mutable unsigned m_istatement;

	bool ScanToCharacter(int ch);

	const char* ScanToFirstParameter();
	const char* ScanToNextParameter();
	const char* ScanToNthParameter(int);
	int			CountParameters() const; // negative if unable to "parse"
	const char* ScanToLastParameter();
	const char* ScanToSecondFromLastParameter();

	const char* SpanEnd(const char* set) const;
	bool FindString(const char*) const;

	CLine m_line;
	CLine m_nextLine; /* hack.. */

	void Warn(const char* = "") const;

	void PrintCode() const;
//	bool m_fPrintContext;
//	bool m_fPrintFullStatement;
	bool m_fPrintCarets;

	void RecordStatement(int ch);
	void OrderStatements() const;
	const char* m_statementStart;

	char m_fullPath[MAX_PATH];

private:
	int  GetCharacter2();
	void UngetCharacter2(int ch);

	CFusionFile 		m_file;
	CFileMapping		m_fileMapping;
	CMappedViewOfFile	m_view;
};

class CSharingHazardCheck
{
public:
	CSharingHazardCheck();

	void Main(int argc, char** argv);
	void ProcessArgs(int argc, char** argv, std::vector<std::string>& files);
	int ProcessFile(const std::string&);

//	bool	m_fRecurse;
//	int		m_nPrintContextStatements;
};
int		g_nPrintContextStatements = 0;
bool	g_fPrintFullStatement = true;
bool	g_fPrintLine = true;

CSharingHazardCheck app;

CSharingHazardCheck::CSharingHazardCheck()
//:
//	m_fRecurse(false),
//	m_nPrintContextStatements(0)
{
}

template <typename Iterator1, typename T>
Iterator1 __stdcall SequenceLinearFindValue(Iterator1 begin, Iterator1 end, T value)
{
	for ( ; begin != end && *begin != value ; ++begin)
	{
		/* nothing */
	}
	return begin;
}

template <typename Iterator1, typename Iterator2>
long __stdcall SequenceLengthOfSpanIncluding(Iterator1 begin, Iterator1 end, Iterator2 setBegin, Iterator2 setEnd)
{
	long result = 0;
	while (begin != end && SequenceLinearFindValue(setBegin, setEnd, *begin) != setEnd)
	{
		++begin;
		++result;
	}
	return result;
}

template <typename Iterator1, typename Iterator2>
long __stdcall SequenceLengthOfSpanExcluding(Iterator1 begin, Iterator1 end, Iterator2 setBegin, Iterator2 setEnd)
{
	long result = 0;
	while (begin != end && SequenceLinearFindValue(setBegin, setEnd, *begin) == setEnd)
	{
		++begin;
		++result;
	}
	return result;
}

#define CASE_AZ \
	case 'A':case 'B':case 'C':case 'D':case 'E':case 'F':case 'G':case 'H':case 'I': \
	case 'J':case 'K':case 'L':case 'M':case 'N':case 'O':case 'P':case 'Q':case 'R': \
	case 'S':case 'T':case 'U':case 'V':case 'W':case 'X':case 'Y':case 'Z'

#define CASE_az \
	case 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h':case 'i': \
	case 'j':case 'k':case 'l':case 'm':case 'n':case 'o':case 'p':case 'q':case 'r': \
	case 's':case 't':case 'u':case 'v':case 'w':case 'x':case 'y':case 'z'

#define CASE_09 \
	case '0':case '1':case '2':case '3':case '4': \
	case '5':case '6':case '7':case '8':case '9'

/* try to keep character set stuff somewhat centralized */
#define CASE_HORIZONTAL_SPACE case ' ': case '\t'
// 0x1a is control-z; it probably marks end of file, but it's pretty rare
// and usually followed by end of file, so we just treat it as vertical space
#define CASE_VERTICAL_SPACE case '\n': case '\r': case 0xc: case 0x1a
#define CASE_SPACE CASE_HORIZONTAL_SPACE: CASE_VERTICAL_SPACE
#define VERTICAL_SPACE "\n\r\xc\x1a"
#define HORIZONTAL_SPACE " \t"
#define SPACE HORIZONTAL_SPACE VERTICAL_SPACE
bool IsVerticalSpace(int ch) { return (ch == '\n' || ch == '\r' || ch == 0xc || ch == 0x1a); }
bool IsHorizontalSpace(int ch) { return (ch == ' ' || ch == '\t'); }
bool IsSpace(int ch) { return IsHorizontalSpace(ch) || IsVerticalSpace(ch); }

#define DIGITS10 "0123456789"
#define DIGITS_EXTRA_HEX   "abcdefABCDEFxX"
#define DIGITS_EXTRA_TYPE   "uUlLfFDd" /* not sure about fFdD for float/double */
#define DIGITS_EXTRA_FLOAT  "eE."
const char digits10[] = DIGITS10;

#define DIGITS_ALL DIGITS10 DIGITS_EXTRA_TYPE DIGITS_EXTRA_HEX DIGITS_EXTRA_FLOAT
const char digitsAll[] = DIGITS_ALL;

#define UPPER_LETTERS "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
#define LOWER_LETTERS "abcdefghijklmnopqrstuvwxyz"
#define IDENTIFIER_CHARS UPPER_LETTERS LOWER_LETTERS DIGITS10 "_"
const char upperLetters[] = UPPER_LETTERS;
const char lowerLetters[] = LOWER_LETTERS;
const char identifierChars[] = IDENTIFIER_CHARS;

#define JAYK 0
#if JAYK
#if _M_IX86
#define BreakPoint() __asm { int 3 }
#else
#define BreakPoint() DebugBreak()
#endif
#else
#define BreakPoint() /* nothing */
#endif

/* actually..these don't work unless we #undef what windows.h gives us ..
#define STRINGIZE_EVAL_AGAIN(name)	#name
#define STRINGIZE(name)				STRINGIZE_EVAL_AGAIN(name)
#define PASTE_EVAL_AGAIN(x,y)		x##y
#define PASTE(x,y)					PASTE_EVAL_AGAIN(x,y)
#define STRINGIZE_A(x) STRINGIZE(PASTE(x,A))
#define STRINGIZE_W(x) STRINGIZE(PASTE(x,W))
*/

bool fReturnNewlinesInComments = false; /* untested */

const char szOpenNamedObject[] = "Open Named Object";
const char szCreateNamedObject[] = "Create Named Object";
const char szRegistryWrite[] = "Registry Write";
const char szFileWrite[] = "File Write";
const char szRegOpenNotUnderstood[] = "RegOpen parameters not understood";
const char szRegisteryRead[] = "Registry Read";
const char szCOM1[] = "CoRegisterClassObject";
const char szCOM2[] = "CoRegisterPSClsid";
const char szOpenFile[] = "File I/O";
const char szLOpen[] = "File I/O"; // UNDONE look at the access parameter
const char szStructuredStorage[] = "Structured Storage I/O"; // UNDONE look at the access parameter
const char szQueryWindowClass[] = "Query Window Class Info";
const char szCreateWindowClass[] = "Create Window Class";
const char szAtom[] = "Atom stuff";
const char szRegisterWindowMessage[] = "Register Window Message";
const char szCreateFileNotUnderstood[] = "CreateFile parameters not understood";
const char szCreateObjectNotUnderstood[] = "Create object parameters not understood";
const char szSetEnvironmentVariable[] = "Set Environment Variable";
const char szWriteEventLog[] = "Event Log Write";

struct HazardousFunction
{
	const char*	api;
	const char*	message;
	const char*	(*function)(const CClass&);
	int			apiLength;

    //__int64 pad;
};

HazardousFunction hazardousFunctions[] =
{
#define HAZARDOUS_FUNCTION_AW3(api, x, y) \
/* if we evaluate again, we pick up the macros from windows.h .. */ \
	{ # api,		x, y }, \
	{ # api "A",	x, y }, \
	{ # api "W",	x, y }

#define HAZARDOUS_FUNCTION_AW2(api, x) \
/* if we evaluate again, we pick up the macros from windows.h .. */ \
	{ # api,		x }, \
	{ # api "A",	x }, \
	{ # api "W",	x }

#define HAZARDOUS_FUNCTION2(api, x ) \
/* if we evaluate again, we pick up the macros from windows.h .. */ \
	{ # api,		x } \

#define HAZARDOUS_FUNCTION3(api, x, y ) \
/* if we evaluate again, we pick up the macros from windows.h .. */ \
	{ # api,		x, y } \

/*--------------------------------------------------------------------------
registry
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION_AW2(RegCreateKey,		szRegistryWrite),
	HAZARDOUS_FUNCTION_AW2(RegCreateKeyEx,		szRegistryWrite),

	HAZARDOUS_FUNCTION_AW2(RegOpenKey,			szRegistryWrite),
// UNDONE check the access parameter
	HAZARDOUS_FUNCTION_AW3(RegOpenKeyEx,			NULL, CheckRegOpenEx),
	HAZARDOUS_FUNCTION3(RegOpenUserClassesRoot,		NULL, CheckRegOpenEx),
	HAZARDOUS_FUNCTION3(RegOpenCurrentUser,			NULL, CheckRegOpenEx),
	//HAZARDOUS_FUNCTION_AW2(RegOpenKeyEx,			szRegistryWrite),
	//HAZARDOUS_FUNCTION2(RegOpenUserClassesRoot,		szRegistryWrite),

	// These don't require opening a key, they are legacy Win16 APIs
	HAZARDOUS_FUNCTION_AW2(RegSetValue,			szRegistryWrite),
	// These are caught by the RegCreateKey or RegOpenKey with particular access.
	//HAZARDOUS_FUNCTION(RegSetValueEx,		szReistryWrite),

	// SHReg* in shlwapi.dll

	HAZARDOUS_FUNCTION_AW2(SHRegCreateUSKey,		szRegistryWrite),
	HAZARDOUS_FUNCTION_AW2(SHRegDeleteEmptyUSKey,	szRegistryWrite),
	HAZARDOUS_FUNCTION_AW2(SHRegDeleteUSValue,		szRegistryWrite),
	//UNDONEHAZARDOUS_FUNCTION_AW3(SHRegOpenUSKey,	NULL,	CheckSHRegOpen),
	HAZARDOUS_FUNCTION_AW2(SHRegSetPath,			szRegistryWrite),
	HAZARDOUS_FUNCTION_AW2(SHRegSetUSValue,			szRegistryWrite),
	// should be caught by OpenKey
	//HAZARDOUS_FUNCTION_AW2(SHRegWriteUSValue,		szRegistryWrite),

	HAZARDOUS_FUNCTION_AW2(SetEnvironmentVariable, szSetEnvironmentVariable),

/*--------------------------------------------------------------------------
file i/o, esp. writing
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION_AW3(CreateFile,			NULL, CheckCreateFile),
	// legacy Win16 APIs. UNDONE check the access parameter, but
	// really any uses of these should be changed to CreateFile
	HAZARDOUS_FUNCTION2(OpenFile,			szOpenFile),
	HAZARDOUS_FUNCTION2(_lopen,				szLOpen),
	//HAZARDOUS_FUNCTION(fopen,				szFOpen,	CheckFOpen),

/*--------------------------------------------------------------------------
monikers
--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
structured storage
--------------------------------------------------------------------------*/
// UNDONE check the access parameter
	HAZARDOUS_FUNCTION2(StgOpenStorage,		szStructuredStorage),
	HAZARDOUS_FUNCTION2(StgOpenStorageEx,	szStructuredStorage),
	HAZARDOUS_FUNCTION2(StgCreateDocfile,	szStructuredStorage),
	HAZARDOUS_FUNCTION2(StgCreateStorageEx,	szStructuredStorage),

/*--------------------------------------------------------------------------
.exe servers / COM
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION2(CoRegisterClassObject,	szCOM1),
	HAZARDOUS_FUNCTION2(CoRegisterPSClsid,		szCOM2),

/*--------------------------------------------------------------------------
named kernel objects
--------------------------------------------------------------------------*/

// Create named or anonymous, anonymous is not a hazard
	HAZARDOUS_FUNCTION_AW3(CreateDesktop,		NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateEvent,			NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateFileMapping,	NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateJobObject,		NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateMutex,			NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW2(CreateMailslot,		szOpenNamedObject), // never anonymous
	HAZARDOUS_FUNCTION_AW2(CreateNamedPipe,		szOpenNamedObject), // never anonymous
	HAZARDOUS_FUNCTION_AW3(CreateSemaphore,		NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateWaitableTimer,	NULL, CheckCreateObject),
	HAZARDOUS_FUNCTION_AW3(CreateWindowStation,	NULL, CheckCreateObject),

// open by name
	HAZARDOUS_FUNCTION_AW2(OpenDesktop,			szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenEvent,			szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenFileMapping,		szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenJobObject,		szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenMutex,			szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(CallNamedPipe,		szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenSemaphore,		szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenWaitableTimer,	szOpenNamedObject),
	HAZARDOUS_FUNCTION_AW2(OpenWindowStation,	szOpenNamedObject),

	/*
	EnumProcesses?
	Toolhelp
	*/

/*--------------------------------------------------------------------------
window classes
--------------------------------------------------------------------------*/
	// Fusion should handle these automagically.
	// these two take a class name as a parameter
	// this still produces many false positives..
	//HAZARDOUS_FUNCTION_AW2(WNDCLASS,			szQueryWindowClass),
	//HAZARDOUS_FUNCTION_AW2(WNDCLASSEX,			szQueryWindowClass),
	//HAZARDOUS_FUNCTION_AW2(GetClassInfoEx,		szQueryWindowClass),

	// Fusion should handle these automagically.
	// this returns a class name
//	HAZARDOUS_FUNCTION_AW2(GetClassName,		szQueryWindowClass),

	// Fusion should handle these automagically.
	// this creates classes
	//HAZARDOUS_FUNCTION_AW2(RegisterClass,		szCreateWindowClass),
	//HAZARDOUS_FUNCTION_AW2(RegisterClassEx,		szCreateWindowClass),

/*--------------------------------------------------------------------------
window messages
--------------------------------------------------------------------------*/
	// We aren't convinced this is a problem.
	//HAZARDOUS_FUNCTION_AW2(RegisterWindowMessage, szRegisterWindowMessage),

/*--------------------------------------------------------------------------
atoms
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION_AW2(AddAtom,				szAtom),
	HAZARDOUS_FUNCTION_AW2(FindAtom,			szAtom),
	HAZARDOUS_FUNCTION_AW2(GlobalAddAtom,		szAtom),
	HAZARDOUS_FUNCTION_AW2(GlobalFindAtom,		szAtom),

	/*
	InitAtomTable,
	DeleteAtom,
	GetAtomName,
	GlobalDeleteAtom,
	GlobalGetAtomName
	*/

/*--------------------------------------------------------------------------
DDE?
clipboard?
--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
Ole data transfer
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION2(RegisterMediaTypeClass,		szRegistryWrite),
	HAZARDOUS_FUNCTION2(RegisterMediaTypes,			szRegistryWrite),
	HAZARDOUS_FUNCTION2(OleUICanConvertOrActivatfeAs, szRegisteryRead),
	HAZARDOUS_FUNCTION2(OleRegEnumFormatEtc,		szRegisteryRead),
	HAZARDOUS_FUNCTION2(OleRegEnumVerbs,			szRegisteryRead),

/*--------------------------------------------------------------------------
NT event log
--------------------------------------------------------------------------*/
	HAZARDOUS_FUNCTION_AW2(RegisterEventSource,	szRegistryWrite),
	HAZARDOUS_FUNCTION_AW2(ClearEventLog,		szWriteEventLog),
	HAZARDOUS_FUNCTION_AW2(ReportEvent,			szWriteEventLog),

/*--------------------------------------------------------------------------
UNDONE think about these
	HAZARDOUS_FUNCTION_AW2(CreateEnhMetaFile,	szWriteGdiMetaFile),
	HAZARDOUS_FUNCTION_AW2(DeleteEnhMetaFile,	szWriteGdiMetaFile),
	HAZARDOUS_FUNCTION_AW2(DeleteMetaFile,		szWriteGdiMetaFile),
	HAZARDOUS_FUNCTION_AW2(CreateMetaFile,		szWriteGdiMetaFile),

	HAZARDOUS_FUNCTION_AW2(DeleteFile,			szWriteFileSystem),
	HAZARDOUS_FUNCTION_AW2(MoveFile,			szWriteFileSystem),
	HAZARDOUS_FUNCTION_AW2(RemoveDirectory,		szWriteFileSystem),
	HAZARDOUS_FUNCTION_AW2(ReplaceFile,			szWriteFileSystem),

	RegDelete* (handled by RegOpen)
	SHReg* (?handled by open)
	CreateService OpenSCManager (not done)
	SetWindowsHook SetWindowsHookEx (not done)
--------------------------------------------------------------------------*/
};

int __cdecl CompareHazardousFunction(const HazardousFunction* x, const HazardousFunction* y)
{
	int i = 0;
	int minlength = 0;

	/* one of the strings is not nul terminated */
	if (x->apiLength == y->apiLength)
	{
		i = strncmp(x->api, y->api, x->apiLength);
		return i;
	}
	minlength = x->apiLength < y->apiLength ? x->apiLength : y->apiLength;
	i = strncmp(x->api, y->api, minlength);
	if (i != 0)
		return i;
	return (minlength == x->apiLength) ? -1 : +1;
}

bool leadingTwoCharsAs14Bits[1U<<14];

void CClass::UngetCharacter2(int ch)
{
/* if you m_rgchUnget a newline, line numbers will get messed up
we only m_rgchUnget forward slashes
*/
	m_rgchUnget[m_nUnget++] = static_cast<char>(ch);
}

int CClass::GetCharacter2()
{
	int ch;

	m_line = m_nextLine; /* UNDONE clean this hack up */

	if (m_nUnget)
	{
		return m_rgchUnget[--m_nUnget];
	}

	/* undone break the nul termination dependency.. */
	if (m_str == m_end)
		return 0;

	ch = *m_str;
	m_str += 1;
	switch (ch)
	{
	/* it is for line continuation that this function is really needed.. */
	case '\\': /* line continuation not implemented */
	case '?': /* trigraphs not implemented */
	default:
		break;

	case 0xc: /* formfeed, control L, very common in NT source */
		ch = '\n';
		break;

	case '\t':
		ch = ' ';
		break;

	case '\r':
		ch = '\n';
		/* skip \n after \r */
		if (*m_str == '\n')
			m_str += 1;
		/* fall through */
	case '\n':
		m_nextLine.m_start = m_str;
		m_nextLine.m_number += 1;
		//if (m_nextLine.m_number == 92)
		//{
		//	BreakPoint();
		//}
		break;
	}
	return ch;
}

int CClass::GetCharacter()
{
	int ch;

	if (m_fInComment)
		goto Lm_fInComment;
	m_fInComment = false;
	ch = GetCharacter2();
	switch (ch)
	{
		default:
			goto Lret;

		case '/':
			ch = GetCharacter2();
			switch (ch)
			{
			default:
				UngetCharacter2(ch);
				ch = '/';
				goto Lret;
			case '/':
				while ((ch = GetCharacter2())
					&& !IsVerticalSpace(ch))
				{
					/* nothing */
				}
				goto Lret; /* return the \n or 0*/
			case '*':
Lm_fInComment:
L2:
				ch = GetCharacter2();
				switch (ch)
				{
				case '\n':
					if (!fReturnNewlinesInComments)
						goto L2;
					m_fInComment = true;
					goto Lret;
				default:
					goto L2;
				case 0:
					/* unclosed comment at end of file, just return end */
					printf("unclosed comment\n");
					goto Lret;
				case '*':
L1:
					ch = GetCharacter2();
					switch (ch)
					{
					default:
						goto L2;
					case 0:
					/* unclosed comment at end of file, just return end */
						printf("unclosed comment\n");
						goto Lret;
					case '/':
						ch = ' ';
						goto Lret;
					case '*':
						goto L1;
					}
				}
			}
	}
Lret:
	return ch;
}

CClass::CClass(const CClass& that)
{
	// yucky laziness
	memcpy(this, &that, sizeof(*this));

	// the copy must not outlive the original!
	// or we could DuplicateHandle the handles and make a new mapping..
	m_begin = that.m_str;
	m_file.Detach();
	m_fileMapping.Detach();
	m_view.Detach();
}

CClass::CClass()
{
	// yucky laziness
	memset(this, 0, sizeof(*this));

//	m_fPrintContext = false;
//	m_fPrintFullStatement = true;
	m_fPrintCarets = false;

	m_fPoundIsPreprocessor = true;
	m_file.Detach();
	m_fileMapping.Detach();
	m_view.Detach();
}

ETokenType CClass::GetToken()
{
	int i = 0;
	int ch = 0;
	unsigned twoCharsAs14Bits = 0;
	char ch2[3] = {0,0,0};
	HazardousFunction lookingForHazardousFunction;
	HazardousFunction* foundHazardousFunction;

L1:
	ch = GetCharacter();
	switch (ch)
	{
	default:
		m_fPoundIsPreprocessor = false;
		break;
	CASE_VERTICAL_SPACE:
		m_fPoundIsPreprocessor = true;
		goto L1;
	case '#':
		break;
	CASE_HORIZONTAL_SPACE:
		goto L1;
	}
	switch (ch)
	{
	default:
		BreakPoint();
		printf("\n%s(%d): unhandled character %c, stopping processing this file\n", m_fullPath, m_line.m_number, ch);
	case 0:
		return INT_TO_ENUM_CAST(ETokenType)(0);
		break;

	/* FUTURE, we pick these up as bogus seperate tokens instead of doing
	line continuation */
	case '\\':
		return (m_eTokenType = INT_TO_ENUM_CAST(ETokenType)(ch));

	/* one character tokens */
	case '{': /* 0x7b to turn off editor interaction.. */
	case '}': /* 0x7D to turn off editor interaction.. */
	case '?': /* we don't handle trigraphs */
	case '[':
	case ']':
	case '(':
	case ',':
	case ')':
	case ';':
		return (m_eTokenType = INT_TO_ENUM_CAST(ETokenType)(ch));

	/* one two or three character tokens */
	case '.': /* . .* */
	case '<': /* < << <<= */
	case '>': /* > >> >>= */
	case '+': /* + ++ += */
	case '-': /* - -- -= -> ->*  */
	case '*': /* * *= */ /* and ** in C9x */
	case '/': /* / /= */
	case '%': /* % %= */
	case '^': /* ^ ^= */
	case '&': /* & && &= */
	case '|': /* | || |= */
	case '~': /* ~ ~= */
	case '!': /* ! != */
	case ':': /* : :: */
	case '=': /* = == */
	/* just lie and return them one char at a time */
		return (m_eTokenType = INT_TO_ENUM_CAST(ETokenType)(ch));

	case '#':
		/* not valid in general, only if m_fPoundIsPreprocessor or actually in a #define,
		but we don't care */
		if (!m_fPoundIsPreprocessor)
			return (m_eTokenType = INT_TO_ENUM_CAST(ETokenType)(ch));

		/* lack of backslash line continuation makes the most difference here */
		while ((ch = GetCharacter()) && !IsVerticalSpace(ch))
		{
			/* nothing */
		}
		return (m_eTokenType = eTokenTypePreprocessorDirective);

	case '\'':
		/* NT uses multi char char constants..
		call GetCharacter2 instead of GetCharacter so that
		comments in char constants are not treated as comments */
		while ((ch = GetCharacter2()) && ch != '\'')
		{
			/* notice the bogosity, escapes are multiple characters,
			but \' is not, and that's all we care about skipping correctly */
			if (ch == '\\')
				GetCharacter2();
		}
		return (m_eTokenType = eTokenTypeCharConstant);

	case '\"':
		/* call GetCharacter2 instead of GetCharacter so that
		comments in string constants are not treated as comments */
		while ((ch = GetCharacter2()) && ch != '\"')
		{
			/* notice the bogosity, escapes are multiple characters,
			but \" is not, and that's all we care about skipping correctly */
			if (ch == '\\')
				GetCharacter2();
		}
		return (m_eTokenType = eTokenTypeStringConstant);

	CASE_09:
		/* integer or floating point, including hex,
		we ignore some invalid forms */
		m_str += SequenceLengthOfSpanIncluding(m_str, m_end, digitsAll, digitsAll+NUMBER_OF(digitsAll)-1);
		return (m_eTokenType = eTokenTypeNumber);

	case '$': /* non standard, used by NT */
	CASE_AZ:
	CASE_az:
	case '_':
		/* notice, keywords like if/else/while/class are just
		returned as identifiers, that is sufficient for now
		*/
		i = SequenceLengthOfSpanIncluding(m_str, m_end, identifierChars, identifierChars+NUMBER_OF(identifierChars)-1);
		twoCharsAs14Bits = StringLeadingTwoCharsTo14Bits(m_str - 1);
		if (!leadingTwoCharsAs14Bits[twoCharsAs14Bits])
			goto LtokenIdentifier;
		lookingForHazardousFunction.api = m_str - 1;
		lookingForHazardousFunction.apiLength = i + 1;
		foundHazardousFunction = REINTERPRET_CAST(HazardousFunction*)(bsearch(&lookingForHazardousFunction, hazardousFunctions, NUMBER_OF(hazardousFunctions), sizeof(hazardousFunctions[0]), (BsearchFunction)CompareHazardousFunction));
		if (!foundHazardousFunction)
			goto LtokenIdentifier;
		m_tokenText = m_str - 1;
		m_tokenLength = i + 1;
		m_str += i;
		m_hazardousFunction = foundHazardousFunction;
		return (m_eTokenType = eTokenTypeHazardousFunction);
LtokenIdentifier:
		m_tokenText = m_str - 1;
		m_tokenLength = i + 1;
		m_str += i;
		return (m_eTokenType = eTokenTypeIdentifier);
	}
}

/*
This has the desired affect of skipping comments.
FUTURE but it doesn't skip preprocessor directives because they
are handled within ScannerGetToken.
This is a bug if your code looks like
CreateFile(GENERIC_READ|
#include "foo.h"
	GENERIC_WRITE,
	...
	);
returning an int length here is problematic because of \r\n conversion..yuck.
*/
const char* CClass::SpanEnd(const char* set) const
{
	CClass s(*this);
	int ch;

	while ((ch = s.GetCharacter())
		&& strchr(set, ch))
	{
		/* nothing */
	}
	return s.m_str;
}

bool CClass::ScanToCharacter(int ch)
{
	int ch2;

	if (!ch)
	{
		return false;
	}
	while ((ch2 = GetCharacter()) && ch2 != ch)
	{
		/* nothing */
	}
	return (ch2 == ch);
}

/* This has the desired advantage over strstr of
- skip comments
- not depend on nul termination
*/
bool CClass::FindString(const char* str) const
{
	CClass s(*this);
	int ch;
	int ch0 = *str++;

	while (s.ScanToCharacter(ch0))
	{
		const char* str2 = str;
		CClass t(s);

		while (*str2 && (ch = t.GetCharacter()) && ch == *str2)
		{
			++str2;
		}
		if (!*str2)
			return true;
	}
	return false;
}

unsigned short __stdcall StringLeadingTwoCharsTo14Bits(const char* s)
{
	unsigned short result = s[0];
	result <<= 7;
	result |= result ? s[1] : 0;
	return result;
}

void __stdcall InitTables()
{
	int i;

	for (i = 0 ; i != NUMBER_OF(hazardousFunctions) ; ++i)
	{
		leadingTwoCharsAs14Bits[StringLeadingTwoCharsTo14Bits(hazardousFunctions[i].api)] = true;
		hazardousFunctions[i].apiLength = strlen(hazardousFunctions[i].api);
	}
	qsort(&hazardousFunctions, i, sizeof(hazardousFunctions[0]), FUNCTION_POINTER_CAST(QsortFunction)(CompareHazardousFunction));
}

const char* CClass::ScanToFirstParameter()
{
// scan to left paren, but if we see right paren or semi first, return null
// FUTURE count parens..
	int ch;
	while (ch = GetCharacter())
	{
		switch (ch)
		{
		default:
			break;
		case '(':
			return m_str;
		case ';':
		case ')':
			return 0;
		}
	}
	return 0;
}

const char* CClass::ScanToLastParameter()
{
	const char* ret = 0;
	if (ScanToFirstParameter())
	{
		ret = m_str;
		while (ScanToNextParameter())
		{
			ret = m_str;
		}
	}
	return ret;
}

const char* CClass::ScanToNthParameter(int n)
{
	const char* ret = 0;
	if (!(ret = ScanToFirstParameter()))
		return ret;
	while (n-- > 0 && (ret = ScanToNextParameter()))
	{
		/* nothing */
	}
	return ret;
}

int CClass::CountParameters() const
{
	CClass s(*this);
	int result = 0;
	if (!s.ScanToFirstParameter())
		return result;
	++result;
	while (s.ScanToNextParameter())
	{
		++result;
	}
	return result;
}

const char* CClass::ScanToNextParameter()
{
	int parenlevel = 1;
	while (true)
	{
		int ch = GetCharacter();
		switch (ch)
		{
		default:
			break;
		case 0:
			printf("end of file scanning for next parameter\n");
		/* worst case macro confusion, we go to end of file */
			return 0;
		case '(':
			++parenlevel;
			break;
		case ')':
			if (--parenlevel == 0)
			{ /* no next parameter */
				return 0;
			}
			break;
		case ',':
			if (parenlevel == 1)
			{
				return m_str;
			}
			break;
		case '#':
		/* bad case macro confusion, go to end of statement */
			printf("# while scanning for parameters\n");
			return 0;
		case ';':
		/* bad case macro confusion, go to end of statement */
			printf("end of statement (;) while scanning for parameters\n");
			return 0;
		}
	}
}

const char* __stdcall CheckRegOpenCommon(CClass& subScanner, int argcRegSam)
{
	const char* regsam = subScanner.ScanToNthParameter(argcRegSam);
	const char* next = regsam ? subScanner.ScanToNextParameter() : 0;
	// allow for it to be last parameter, which it is sometimes
	if (!next)
		next = subScanner.m_str;
	if (!regsam || !next)
	{
		return szRegOpenNotUnderstood;
	}
	subScanner.m_str = regsam;
	subScanner.m_end = next;
	const char* endOfValidSam = subScanner.SpanEnd(UPPER_LETTERS "_|,()0" SPACE);
	if (endOfValidSam != next && endOfValidSam != next+1)
	{
		return szRegOpenNotUnderstood;
	}
	if (
			subScanner.FindString("ALL") // both "all" and "maximum_allowed"
			|| subScanner.FindString("SET")
			|| subScanner.FindString("WRITE")
			|| subScanner.FindString("CREATE")
			)
	{
		return szRegistryWrite;
	}
	// not a problem, registry only opened for read
	return 0;
}

const char* __stdcall CheckSHRegOpen(const CClass& scanner)
{
	CClass subScanner(scanner);
	return CheckRegOpenCommon(subScanner, 1);
}

const char* __stdcall CheckRegOpenEx(const CClass& scanner)
/*
this function is used for all of RegOpenKeyEx, RegOpenCurrentUser, RegOpenUserClassesRoot,
which is why it uses argc-2 instead of a particular parameter from the start.
*/
{
	CClass subScanner(scanner);
	const int argc = subScanner.CountParameters();
	return CheckRegOpenCommon(subScanner, argc - 2);
}

const char* __stdcall CheckCreateObject(const CClass& scanner)
{
	CClass subScanner(scanner);
	const char* name;
	name = subScanner.ScanToLastParameter();
	if (!name)
	{
		return szCreateObjectNotUnderstood;
	}
	subScanner.m_str = name;
	int ch;
	while (
		(ch = subScanner.GetCharacter())
		&& IsSpace(ch)
		)
	{
	}
	name = subScanner.m_str - 1;
	if (!name)
	{
		return szCreateObjectNotUnderstood;
	}
	if (
			strncmp(name, "0", 1) == 0
		||	strncmp(name, "NULL", 4) == 0)
	{
		// not a sharing hazard
		return 0;
	}
	return szOpenNamedObject;
}

const char* __stdcall CheckCreateFile(const CClass& scanner)
{
	CClass subScanner(scanner);
	const char* access = subScanner.ScanToNthParameter(1);
	const char* share =  access ? subScanner.ScanToNextParameter() : 0;
	const char* endOfValidAccess = 0;

	if (!access || !share)
	{
		return szCreateFileNotUnderstood;
	}
	subScanner.m_str = access;
	subScanner.m_end = share;
	endOfValidAccess = subScanner.SpanEnd(UPPER_LETTERS "_|,()0" SPACE);
	if (endOfValidAccess != share)
	{
		return szCreateFileNotUnderstood;
	}
	/* GENERIC_WRITE WRITE_DAC WRITE_OWNER STANDARD_RIGHTS_WRITE
	STANDARD_RIGHTS_ALL SPECIFIC_RIGHTS_ALL MAXIMUM_ALLOWED GENERIC_ALL
	*/
	if (
			subScanner.FindString("WRITE")
			|| subScanner.FindString("ALL")
			|| subScanner.FindString("0")
			)
	{
		return szFileWrite;
	}
	return 0;
}

void CClass::Warn(const char* message) const
{
	if (message && *message)
	{
		//PrintOpenComment();
		printf("%s(%d): %s\n", m_fullPath, m_line.m_number, message);
		//PrintCloseComment();
	}
	else
	{
		PrintSeperator();
	}
	PrintCode();
}

bool CClass::OpenFile(const char* name)
{
	if (FAILED(m_file.HrCreate(name, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING)))
		return false;
	if (FAILED(m_fileMapping.HrCreate(m_file, PAGE_READONLY)))
		return false;
	if (FAILED(m_view.HrCreate(m_fileMapping, FILE_MAP_READ)))
		return false;
	m_str = reinterpret_cast<const char*>(static_cast<const void*>(m_view));
	m_end = m_str + m_file.GetSize();
	m_nextLine.m_start = m_line.m_start = m_str;
	m_nextLine.m_number += 1;
	return true;
}

void CClass::RecordStatement(int ch)
{
	if (ch == ';' || ch == '{' || ch == eTokenTypePreprocessorDirective /*|| ch == '}'*/)
	{
		if (!m_statementStart)
		{
			m_statementStart = m_str;
		}
		else
		{
			CStatement statement = { m_statementStart, m_str};
			m_statements[m_istatement % NUMBER_OF(m_statements)] = statement;
			++m_istatement;
			m_statementStart = m_str;
		}
	}
}

/* do this before iterating over them to print them, this makes the iteration
interface simple */
void CClass::OrderStatements() const /* mutable */
{
	const int N = NUMBER_OF(m_statements);
	CStatement temp[N];
	std::copy(m_statements, m_statements + N, temp);
	for (int i = 0 ; i != N ; ++i)
	{
		m_statements[i] = temp[(m_istatement + i) % N];
	}
	m_istatement = 0;
}

void __stdcall PrintOpenComment()
{
	const int N = 76;
	static char str[N];
	if (!str[0])
	{
		std::fill(str + 1, str + N - 1, '-');
		str[2] = '*';
		str[1] = '/';
		str[0] = '\n';
	}
	fputs(str, stdout);
}

void __stdcall PrintCloseComment()
{
	const int N = 76;
	static char str[N];
	if (!str[0])
	{
		std::fill(str + 1, str + N - 1, '-');
		str[N-3] = '*';
		str[N-2] = '/';
		str[0] = '\n';
	}
	fputs(str, stdout);
}

void __stdcall PrintSeperator()
{
	const int N = 76;
	static char str[N];
	if (!str[0])
	{
		std::fill(str + 1, str + N - 1, '-');
		str[0] = '\n';
	}
	fputs(str, stdout);
}

void __stdcall TrimSpaces(const char** begin, const char** end)
{
	while (*begin != *end && IsSpace(**begin))
	{
		++*begin;
	}
	while (*begin != *end && IsSpace(*(*end - 1)))
	{
		--*end;
	}
}

void __stdcall PrintString(const char* begin, const char* end)
{
	if (begin && end > begin)
	{
		int length = end - begin;
		printf("%.*s", length, begin);
	}
}

const char* __stdcall RemoveLeadingSpace(const char* begin, const char* end)
{
	if (begin != end && IsSpace(*begin))
	{
		while (begin != end && IsSpace(*begin))
		{
			++begin;
		}
	}
	return begin;
}

const char* __stdcall RemoveLeadingVerticalSpace(const char* begin, const char* end)
{
	if (begin != end && IsVerticalSpace(*begin))
	{
		while (begin != end && IsVerticalSpace(*begin))
		{
			++begin;
		}
	}
	return begin;
}

const char* __stdcall OneLeadingVerticalSpace(const char* begin, const char* end)
{
	if (begin != end && IsVerticalSpace(*begin))
	{
		while (begin != end && IsVerticalSpace(*begin))
		{
			++begin;
		}
		--begin;
	}
	return begin;
}

const char* __stdcall RemoveTrailingSpace(const char* begin, const char* end)
{
	if (begin != end && IsSpace(*(end-1)))
	{
		while (begin != end && IsSpace(*(end-1)))
		{
			--end;
		}
	}
	return end;
}

const char* __stdcall RemoveTrailingVerticalSpace(const char* begin, const char* end)
{
	if (begin != end && IsVerticalSpace(*(end-1)))
	{
		while (begin != end && IsVerticalSpace(*(end-1)))
		{
			--end;
		}
	}
	return end;
}

const char* __stdcall OneTrailingVerticalSpace(const char* begin, const char* end)
{
	if (begin != end && IsVerticalSpace(*(end-1)))
	{
		while (begin != end && IsVerticalSpace(*(end-1)))
		{
			--end;
		}
		++end;
	}
	return end;
}

void CClass::PrintCode() const
{
// this function is messy wrt when newlines are printed

	//PrintSeperator();
	OrderStatements();
	int i;

	if (g_nPrintContextStatements)
	{
		const char* previousStatementsEnd = 0;
		for (i = NUMBER_OF(m_statements) - g_nPrintContextStatements ; i != NUMBER_OF(m_statements) ; i++)
		{
			if (m_statements[i].begin && m_statements[i].end)
			{
				previousStatementsEnd = m_statements[i].end;

				// for the first iteration, limit ourselves to one newline
				if (i == NUMBER_OF(m_statements) - g_nPrintContextStatements)
				{
					m_statements[i].begin = RemoveLeadingVerticalSpace(m_statements[i].begin, m_statements[i].end);
				}
				PrintString(m_statements[i].begin, m_statements[i].end);
			}
		}
		if (previousStatementsEnd)
		{
			PrintString(previousStatementsEnd, m_line.m_start);
		}
	}
	const char* newlineChar = SequenceLinearFindValue(m_line.m_start, m_end, '\n');
	const char* returnChar = SequenceLinearFindValue(m_line.m_start, m_end, '\r');
	const char* endOfLine = std::min(newlineChar, returnChar);
	int outputLineOffset = 0;
	int lineLength = endOfLine - m_line.m_start;
	if (g_fPrintLine)
	{
		printf("%.*s\n", lineLength, m_line.m_start);
	}

	// underline the offending hazardous function with carets
	if (g_nPrintContextStatements)
	{
		// skip the part of the line preceding the hazardous functon,
		// print tabs where it has tabs
		for (i = 0 ; i < m_str - m_line.m_start - m_hazardousFunction->apiLength ; ++i)
		{
			fputs((m_line.m_start[i] != '\t') ? " " : "\t"/*"    "*/, stdout);
		}
		// underline the function with carets
		for (i = 0 ; i < m_hazardousFunction->apiLength ; ++i)
			putchar('^');
		putchar('\n');
	}


	// find the approximate end of statement
	const char* statementSemi = SequenceLinearFindValue(m_line.m_start, m_end, ';');
	const char* statementBrace = SequenceLinearFindValue(m_line.m_start, m_end, '{'); // }
	const char* statementPound = SequenceLinearFindValue(m_line.m_start, m_end, '#');
	// statements don't really end in a pound, but this helps terminate output
	// in some cases
	const char* statementEnd =  RemoveTrailingSpace(m_line.m_start, std::min(std::min(statementSemi, statementBrace), statementPound));
	if (g_fPrintFullStatement)
	{
		if (statementEnd > endOfLine)
		{
			const char* statementBegin = RemoveLeadingVerticalSpace(endOfLine, statementEnd);
			if (*statementEnd == ';')
			{
				++statementEnd;
			}
			PrintString(statementBegin, statementEnd);
			if (!g_nPrintContextStatements)
			{
				putchar('\n');
			}
		}
		else
		{
			if (*statementEnd == ';')
			{
				++statementEnd;
			}
		}
	}

	// print more statements after it
	if (g_nPrintContextStatements)
	{
		for (i = 0 ; i != g_nPrintContextStatements ; ++i)
		{
			// and then a few more
			const char* statement2 = SequenceLinearFindValue(statementEnd, m_end, ';');
			if (i == 0)
			{
				statementEnd = RemoveLeadingVerticalSpace(statementEnd, statement2);
			}
			if (i == g_nPrintContextStatements-1)
			{
				statement2 = RemoveTrailingSpace(statementEnd, statement2);
				PrintString(statementEnd, statement2);
				putchar(';');
				putchar('\n');
			}
			else
			{
				PrintString(statementEnd, statement2);
				putchar(';');
			}
			statementEnd = statement2 + (statement2 != m_end);
		}
	}
}

int CSharingHazardCheck::ProcessFile(const std::string& name)
{
// test argv processing
//	std::cout << name << std::endl;
//	return;

	int total = 0;

	CClass scanner;
	ETokenType m_eTokenType = INT_TO_ENUM_CAST(ETokenType)(0);

	scanner.m_fullPath[0] = 0;
	if (!GetFullPathName(name.c_str(), NUMBER_OF(scanner.m_fullPath), scanner.m_fullPath, NULL))
		strcpy(scanner.m_fullPath, name.c_str());

	if (!scanner.OpenFile(scanner.m_fullPath))
		return total;
	
	scanner.RecordStatement(';');

	// we "parse" token :: token, to avoid these false positives
	int idColonColonState = 0;

	while (m_eTokenType = scanner.GetToken())
	{
		scanner.RecordStatement(m_eTokenType);
		switch (m_eTokenType)
		{
		default:
			idColonColonState = 0;
			break;

		case eTokenTypeIdentifier:
			idColonColonState = 1;
			break;
		case ':':
			switch (idColonColonState)
			{
			case 1:
				idColonColonState = 2;
				break;
			case 2:
				// skip a token
				// idColonColonState = 3;
				scanner.GetToken();
			//	idColonColonState = 0;
			//	break;
			case 0:
			//case 3:
				idColonColonState = 0;
				break;
			}
			break;

		case '>': // second bogus token in ->
		case '.':
			// skip a token to avoid foo->OpenFile, foo.OpenFile
			scanner.GetToken();
			break;

		case eTokenTypeHazardousFunction:
			{
				if (scanner.m_hazardousFunction->function)
				{
					const char* message = scanner.m_hazardousFunction->function(scanner);
					if (message)
					{
						total += 1;
						scanner.Warn(message);
					}
				}
				else if (scanner.m_hazardousFunction->message)
				{
					total += 1;
					scanner.Warn(scanner.m_hazardousFunction->message);
				}
				else
				{
					scanner.Warn();
					BreakPoint();
				}
			}
			break;
		}
	}
	return total;
}

bool __stdcall Contains(const char* s, const char* set)
{
	return s && *s && strcspn(s, set) != strlen(s);
}

bool ContainsSlashes(const char* s) { return Contains(s, "\\/"); }
bool ContainsSlash(const char* s) { return ContainsSlashes(s); }
bool ContainsWildcards(const char* s) { return Contains(s, "*?"); }
bool IsSlash(int ch) { return (ch == '\\' || ch == '/'); }

std::string PathAppend(const std::string& s, const std::string& t)
{
	// why does string lack back()?
	int sslash = IsSlash(*(s.end() - 1)) ? 2 : 0;
	int tslash = IsSlash(*t.begin()) ? 1 : 0;
	switch (sslash | tslash)
	{
	case 0:
		return (s + '\\' + t);
	case 1:
	case 2:
		return (s + t);
	case 3:
		return (s + t.substr(1));
	}
	return std::string();
}

void __stdcall PathSplitOffLast(const std::string& s, std::string* a, std::string* b)
{
	std::string::size_type slash = s.find_last_of("\\/");
	*a = s.substr(0, slash);
	*b = s.substr(slash + 1);
}

std::string __stdcall PathRemoveLastElement(const std::string& s)
{
	return s.substr(0, s.find_last_of("\\/"));
}

bool __stdcall IsDotOrDotDot(const char* s)
{
	return s[0] == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0));
}

void CSharingHazardCheck::ProcessArgs(int argc, char** argv, std::vector<std::string>& files)
{
	int i;
	bool fRecurse = false;
	std::vector<std::string> directories;
	std::vector<std::string> genericWildcards;
	std::vector<std::string> particularWildcards;
	bool fWarnEmptyWildcards = true;

    std::vector<char> fullpath;
    std::vector<char> currentDirectory;

    const DWORD SIZE = (1U << 16);
    fullpath.resize(SIZE);
    fullpath[0] = 0;
    currentDirectory.resize(SIZE);
    currentDirectory[0] = 0;

    GetCurrentDirectory(SIZE, &currentDirectory[0]);

	for (i = 1 ; i < argc ; ++i)
	{
		switch (argv[i][0])
		{
		default:
			if (ContainsWildcards(argv[i]))
			{
				if (ContainsSlash(argv[i]))
				{
					// these will only be applied once, in whatever
					// path they specifically refer
					if (GetFullPathName(argv[i], SIZE, &fullpath[0], NULL))
					{
						particularWildcards.push_back(&fullpath[0]);
					}
					else
					{
						printf("GetFullPathName failed %s\n", argv[i]);
					}
				}
				else
				{
					// do NOT call GetFullPathName here
					genericWildcards.push_back(argv[i]);
				}
			}
			else
			{
				if (GetFullPathName(argv[i], SIZE, &fullpath[0], NULL))
				{
					DWORD dwFileAttributes = GetFileAttributes(&fullpath[0]);
					if (dwFileAttributes != 0xFFFFFFFF)
					{
						if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
						{
							directories.push_back(&fullpath[0]);
						}
						else
						{
							files.push_back(&fullpath[0]);
						}
					}
					else
					{
						printf("%s nonexistant\n", &fullpath[0]);
					}
				}
				else
					printf("GetFullPathName failed %s\n", argv[i]);
			}
			break;
			/*
			default output
			file(line):reason
			-recurse
			-print-line
				prints line of code with offending function after file(line):reason
			-print-statement
				print statement containing offending function after file(line):reason
				supersedes -print-line
			-print-context-lines:n
				-print-statement plus surrounding n lines (not implemented)
			-print-context-statements:n
				-print-statement plus surrounding n "statements" (count semis and braces)
			file names apply across all directories recursed into
			wild cards apply across all directories recursed into
			naming a directory implies one level recursion (unless -recurse is also seen)
			environment variable SHARING_HAZARD_CHECK_OPTIONS added to argv (not implemented)
			all directory walking happens before any output is generated
			*/
		case '-':
		case '/':
			argv[i] += 1;
			static const char szRecurse[] = "recurse";
			static const char szPrintStatement[] = "print-statement";
			static const char szPrintLine[] = "print-line";
			static const char szPrintContextLines[] = "print-context-lines";
			static const char szPrintContextStatements[] = "print-context-statements";
			switch (argv[i][0])
			{
			default:
				printf("unknown switch %s\n", argv[i]);
				break;

				case 'r': case 'R':
					if (0 == _stricmp(argv[i]+1, 1 + szRecurse))
					{
						fRecurse = true;
					}
					break;
				case 'p': case 'P':
					if (0 == _strnicmp(argv[i]+1, "rint-", 5))
					{
						if (0 == _stricmp(
								6 + argv[i],
								6 + szPrintLine
								))
						{
							g_fPrintLine = true;
						}
						else if (0 == _stricmp(
								6 + argv[i],
								6 + szPrintStatement
								))
						{
							g_fPrintFullStatement = true;
							g_fPrintLine = true;
						}
						else if (0 == _strnicmp(
								6 + argv[i],
								6 + szPrintContextLines,
								NUMBER_OF(szPrintContextLines) - 6
								))
						{
							printf("unimplemented switch %s\n", argv[i]);
						}
						else if (0 == _strnicmp(
								6 + argv[i],
								6 + szPrintContextStatements,
								NUMBER_OF(szPrintContextLines) - 6))
						{
							if (argv[i][NUMBER_OF(szPrintContextStatements)-1] == ':')
							{
								g_nPrintContextStatements = atoi(argv[i] + NUMBER_OF(szPrintContextStatements));
								g_nPrintContextStatements = std::min<int>(g_nPrintContextStatements, NUMBER_OF(CClass().m_statements));
								g_nPrintContextStatements = std::max<int>(g_nPrintContextStatements, 1);
							}
							else
							{
								g_nPrintContextStatements = 2;
							}
							g_fPrintFullStatement = true;
							g_fPrintLine = true;
						}
					}
					break;
			}
			break;
		}
	}
	if (fRecurse)
	{
		// split up particular wildcards into directories and generic wildcards
		for (std::vector<std::string>::const_iterator j = particularWildcards.begin();
			j != particularWildcards.end();
			++j
			)
		{
			std::string path;
			std::string wild;
			PathSplitOffLast(*j, &path, &wild);
			directories.push_back(path);
			genericWildcards.push_back(wild);
			//printf("%s%s -> %s %s\n", path.c_str(), wild.c_str(), path.c_str(), wild.c_str());
		}
		particularWildcards.clear();
	}

	// empty command line produces nothing, by design
	if (genericWildcards.empty()
		&& !directories.empty()
		)
	{
		genericWildcards.push_back("*");
	}
	else if (
		directories.empty()
		&& files.empty()
		&& !genericWildcards.empty())
	{
		directories.push_back(&currentDirectory[0]);
	}
	if (!directories.empty()
		|| !genericWildcards.empty()
		|| !particularWildcards.empty()
		|| fRecurse
		)
	{
		// if you don't output the \n and let the .s word wrap,
		// f4 in the output gets messed up wrt which line gets highlighted
		printf("processing argv..\n"); fflush(stdout);
#define ARGV_PROGRESS() printf("."); fflush(stdout);
#undef ARGV_PROGRESS
#define ARGV_PROGRESS() printf("processing argv..\n"); fflush(stdout);
#undef ARGV_PROGRESS
#define ARGV_PROGRESS() /* nothing */
	}
	WIN32_FIND_DATA findData;
	if (!directories.empty())
	{
		std::set<std::string> allDirectoriesSeen; // avoid repeats when recursing
		std::stack<std::string> stack;
		for (std::vector<std::string>::const_iterator k = directories.begin();
			k != directories.end();
			++k
			)
		{
			stack.push(*k);
		}
		while (!stack.empty())
		{
			std::string directory = stack.top();
			stack.pop();
			if (!fRecurse || allDirectoriesSeen.find(directory) == allDirectoriesSeen.end())
			{
				if (fRecurse)
				{
					allDirectoriesSeen.insert(allDirectoriesSeen.end(), directory);
				}
				for
				(
					std::vector<std::string>::const_iterator w = genericWildcards.begin();
					w != genericWildcards.end();
					++w
				)
				{
					std::string file = PathAppend(directory, *w);
					CFindFile findFile;
					if (SUCCEEDED(findFile.HrCreate(file.c_str(), &findData)))
					{
						fWarnEmptyWildcards = false;
						ARGV_PROGRESS();
						// only match files here
						do
						{
							if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
							{
								files.push_back(PathAppend(directory, findData.cFileName));
							}
						} while (FindNextFile(findFile, &findData));
					}
					else
					{
						if (fWarnEmptyWildcards)
							printf("warning: %s expanded to nothing\n", file.c_str());
					}
					if (fRecurse)
					{
						// only match directories here
						std::string star = PathAppend(directory, "*");
						CFindFile findFile;
						if (SUCCEEDED(findFile.HrCreate(star.c_str(), &findData)))
						{
							fWarnEmptyWildcards = false;
							ARGV_PROGRESS();
							do
							{
								if (!IsDotOrDotDot(findData.cFileName)
									&& (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
								{
									stack.push(PathAppend(directory, findData.cFileName));
								}
							} while (FindNextFile(findFile, &findData));
						}
						else
						{
							if (fWarnEmptyWildcards)
								printf("warning: %s expanded to nothing\n", star.c_str());
						}
					}
				}
			}
		}
	}
	// particular wildcards only match files, not directories
	for
	(
		std::vector<std::string>::const_iterator w = particularWildcards.begin();
		w != particularWildcards.end();
		++w
	)
	{
		std::string directory = PathRemoveLastElement(*w);
		CFindFile findFile;
		if (SUCCEEDED(findFile.HrCreate(w->c_str(), &findData)))
		{
			fWarnEmptyWildcards = false;
			ARGV_PROGRESS();
			// only match files here
			do
			{
				if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
				{
					files.push_back(PathAppend(directory, findData.cFileName));
				}
			} while (FindNextFile(findFile, &findData));
		}
		else
		{
		//	if (fWarnEmptyWildcards) // always warn for "particular wildcards"
			printf("warning: %s expanded to nothing\n", w->c_str());
		}
	}
	std::sort(files.begin(), files.end());
	files.resize(std::unique(files.begin(), files.end()) - files.begin());
	printf("\n");
}

void CSharingHazardCheck::Main(int argc, char** argv)
{
	if (argc < 2)
	{
		printf(usage, argv[0]);
		exit(EXIT_FAILURE);
	}
	fputs(banner, stdout);
	std::vector<std::string> files;
	ProcessArgs(argc, argv, files);
	InitTables();
	int total = 0;
	for (
		std::vector<std::string>::const_iterator i = files.begin();
		i != files.end();
		++i
		)
	{
		total += ProcessFile(*i);
	}
	printf("\n%d warnings\n", total);
}

int __cdecl main(int argc, char** argv)
{
	app.Main(argc, argv);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\csrss.cpp ===
#include "stdinc.h"
#include "csrss.h"

#define CSRSS_TEST_DIR_NAME (L"csrss")
#define CSRSS_TEST_DIR_NAME_CCH (NUMBER_OF(CSRSS_TEST_DIR_NAME) - 1)
#define CSRSS_SETTINGS_FILE_NAME (L"csrss.ini")
#define CSRSS_SETTINGS_FILE_NAME_CCH (NUMBER_OF(CSRSS_SETTINGS_FILE_NAME) - 1)
#define CSRSS_INI_SECTION_TITLE (L"csrss")


BOOL pOpenStreamOnFile( 
    PCWSTR pcwszFilename, 
    IStream** ppStream, 
    PCWSTR pcwszResourceType = NULL,
    PCWSTR pcwszResourceName = NULL,
    WORD Language = 0)
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pcwszFilename);
    PARAMETER_CHECK(ppStream);

    *ppStream = NULL;

    //
    // If this is non-null, then we have to open the file as an image and get the 
    // resource specified.  Otherwise, we just open the file like a normal file.
    //
    if ( pcwszResourceName )
    {
        CResourceStream *pResourceStream = NULL;

        IFW32NULL_EXIT(pResourceStream = FUSION_NEW_SINGLETON(CResourceStream));
        IFW32FALSE_EXIT(pResourceStream->Initialize(
            pcwszFilename,
            pcwszResourceType,
            pcwszResourceName,
            Language));
        *ppStream = pResourceStream;
    }
    else
    {
        CReferenceCountedFileStream *pFileStream = NULL;
        CImpersonationData ImpData;
        IFW32NULL_EXIT(pFileStream = FUSION_NEW_SINGLETON(CReferenceCountedFileStream));
        IFW32FALSE_EXIT(pFileStream->OpenForRead(pcwszFilename, ImpData, FILE_SHARE_READ, OPEN_EXISTING, 0));
        *ppStream = pFileStream;
    }

    if ( *ppStream ) (*ppStream)->AddRef();

    FN_EPILOG
}

BOOL ParseDecimalOrHexString(PCWSTR pcwszString, SIZE_T cch, ULONG &out )
{
    BOOL fIsHex;

    FN_PROLOG_WIN32

    PARAMETER_CHECK(pcwszString != NULL);
    
    fIsHex = ((cch > 2 ) && ( pcwszString[0] == L'0' ) && 
        ((pcwszString[1] == L'x') || (pcwszString[1] == L'X')));

    if ( fIsHex )
    {
        pcwszString += 2;
        cch -= 2;
    }

    out = 0;

    while ( cch )
    {
        const int val = SxspHexDigitToValue((*pcwszString));
        PARAMETER_CHECK( fIsHex || ( val < 10 ) );
        out = out * ( fIsHex ? 16 : 10 ) + val;
        cch--;
        pcwszString++;
    }

    FN_EPILOG
}


class CCsrssPoundingThreadEntry
{
    PRIVATIZE_COPY_CONSTRUCTORS(CCsrssPoundingThreadEntry);
public:
    CDequeLinkage Linkage;
    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Request;
    ULONG ulRuns;
    BOOL fStopNextRound;
    BOOL fShouldSucceed;
    CThread hOurThreadHandle;
    CStringBuffer buffTestDirectory;
    CSmallStringBuffer buffTestName;
    DWORD dwSleepTime;

    CSmallStringBuffer buffProcArch;
    CStringBuffer buffAssemblyDirectory;
    CStringBuffer buffTextualIdentityString;
    CStringBuffer buffManifestStreamPath;
    CStringBuffer buffPolicyStreamPath;

    CCsrssPoundingThreadEntry() : ulRuns(0), fStopNextRound(FALSE) { }
    BOOL AcquireSettingsFrom( PCWSTR pcwszSettingsFile );
    DWORD DoWork();
    BOOL StopAndWaitForCompletion();

    static DWORD WINAPI ThreadProcEntry( PVOID pv ) 
    {
        CCsrssPoundingThreadEntry *pEntry = NULL;

        pEntry = reinterpret_cast<CCsrssPoundingThreadEntry*>(pv);
        return ( pEntry != NULL ) ? pEntry->DoWork() : 0;
    }
};


BOOL
CCsrssPoundingThreadEntry::StopAndWaitForCompletion()
{
    this->fStopNextRound = true;
    return WaitForSingleObject(this->hOurThreadHandle, INFINITE) == WAIT_OBJECT_0;
}

DWORD
CCsrssPoundingThreadEntry::DoWork()
{
    if ( !WaitForThreadResumeEvent() )
        goto Exit;

    while ( !this->fStopNextRound )
    {
        //
        // Call to generate the structure
        //
        BOOL fResult;
        SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS TempParams = this->Request;
        CSmartRef<IStream> isManifest;
        CSmartRef<IStream> isPolicy;

        if ( this->buffManifestStreamPath.Cch() != 0 )
        {
            if (pOpenStreamOnFile(this->buffManifestStreamPath, &isManifest))
            {
                TempParams.Manifest.Path = this->buffManifestStreamPath;
                TempParams.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
                TempParams.Manifest.Stream = isManifest;
            }
        }

        if ( this->buffPolicyStreamPath.Cch() != 0 )
        {
            if (pOpenStreamOnFile(this->buffPolicyStreamPath, &isPolicy))
            {
                TempParams.Policy.Path = this->buffManifestStreamPath;
                TempParams.Policy.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
                TempParams.Policy.Stream = isPolicy;
            }
        }

        fResult = SxsGenerateActivationContext( &TempParams );

        //
        // Did we fail when we were to succeed, or succeed when we were to fail?
        //
        if ( ( !fResult && this->fShouldSucceed ) || ( fResult && !this->fShouldSucceed ) )
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            ::ReportFailure("CsrssStress: Test %ls expected %ls, got %ls; Error %ld\n",
                static_cast<PCWSTR>(this->buffTestName),
                this->fShouldSucceed ? L"success" : L"failure",
                fResult ? L"success" : L"failure",
                dwLastError);
        }
        else
        {
            wprintf(L"CsrssStress: Test %ls passed\n", static_cast<PCWSTR>(this->buffTestName));
        }

        if ((TempParams.SectionObjectHandle != INVALID_HANDLE_VALUE ) && 
            (TempParams.SectionObjectHandle != NULL))
        {
            CloseHandle(TempParams.SectionObjectHandle);
        }

        if ( !this->fStopNextRound )
            ::Sleep(this->dwSleepTime);
        
    }

Exit:
    return 0;
}

#define SLEN(n) (NUMBER_OF(n)-1)
#define CSRSS_INI_KEY_PROC_ARCH         (L"ProcArch")
#define CSRSS_INI_KEY_PROC_ARCH_CCH     SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_LANGID            (L"LangId")
#define CSRSS_INI_KEY_LANGID_CCH        SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_ASMDIR            (L"AssemblyDirectory")
#define CSRSS_INI_KEY_ASMDIR_CCH        SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_TEXTUALIDENT      (L"TextualIdentity")
#define CSRSS_INI_KEY_TEXTUALIDENT_CCH  SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_MANIFEST          (L"ManifestPath")
#define CSRSS_INI_KEY_MANIFEST_CCH      SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_POLICY            (L"PolicyPath")
#define CSRSS_INI_KEY_POLICY_CCH        SLEN(CSRSS_INI_KEY_PROC_ARCH)

#define CSRSS_INI_KEY_SUCCESS           (L"ShouldSucceed")
#define CSRSS_INI_KEY_SUCCESS_CCH       SLEN(CSRSS_INI_KEY_SUCCESS)

#define CSRSS_INI_KEY_SLEEP             (L"SleepTime")
#define CSRSS_INI_KEY_SLEEP_CCH         SLEN(CSRSS_INI_KEY_SLEEP)

#define CSRSS_INI_KEY_SYSDEFAULTIDENTFLAG       (L"SysDefaultTextualIdentityFlag")
#define CSRSS_INI_KEY_SYSDEFAULTIDENTFLAG_CCH   SLEN(CSRSS_INI_KEY_SYSDEFAULTIDENTFLAG)

#define CSRSS_INI_KEY_TEXTUALIDENTFLAG          (L"TextualIdentityFlag")
#define CSRSS_INI_KEY_TEXTUALIDENTFLAG_CCH      SLEN(CSRSS_INI_KEY_TEXTUALIDENTFLAG);

BOOL CCsrssPoundingThreadEntry::AcquireSettingsFrom( PCWSTR pcwszSettingsFile )
{
    FN_PROLOG_WIN32

    LANGID lidCurrentLang = GetUserDefaultUILanguage();
    CSmallStringBuffer buffJunk;
    BOOL fDumpBool;
    
    ZeroMemory(&this->Request, sizeof(this->Request));
    
    //
    // Format of the settings file:
    //
    // [testname]
    // SysDefaultTextualIdentityFlag = yes|no (add SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY)
    // TextualIdentityFlag = yes|no (add SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY)
    // ProcArch = PA ident string (will use FusionpParseProcessorArchitecture)
    // LangId = number or string
    // AssemblyDirectory = dirname
    // TextualIdentity = textualIdentityString
    // ManifestPath = manifest name under test directory
    // PolicyPath = policy path file name under test directory
    // ShouldSucceed = yes|no - whether this test succeeds or fails
    //
    // Flags is required.
    // PA and LangId, if not present, are defaulted to the current user's settings.
    // AssemblyDirectory, if not present, defaults to %systemroot%\winsxs
    // TextualIdentity is required.
    // ManifestPath is required.
    //
    // If textualIdentity is present, then the streams are not created.
    //

    //
    // Flags are set by key names
    //
    IFW32FALSE_EXIT(SxspIsPrivateProfileStringEqual(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_SYSDEFAULTIDENTFLAG, L"yes", fDumpBool, pcwszSettingsFile));
    if ( fDumpBool )
        this->Request.Flags |= SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY;

    IFW32FALSE_EXIT(SxspIsPrivateProfileStringEqual(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_TEXTUALIDENTFLAG, L"yes", fDumpBool, pcwszSettingsFile));
    if ( fDumpBool )
        this->Request.Flags |= SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY;


    //
    // Get the success/failure value
    //
    IFW32FALSE_EXIT(SxspIsPrivateProfileStringEqual(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_SUCCESS, L"yes", this->fShouldSucceed, pcwszSettingsFile));
    
    //
    // And how long this is to sleep
    //
    INT dump;
    IFW32FALSE_EXIT(SxspGetPrivateProfileIntW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_SLEEP, 200, dump, pcwszSettingsFile));
    this->dwSleepTime = dump;
    
    //
    // PA setting is a string
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_PROC_ARCH, L"x86", buffJunk, pcwszSettingsFile));
    if ( buffJunk.Cch() != 0 )
    {   
        bool fValid = false;
        IFW32FALSE_EXIT(FusionpParseProcessorArchitecture(
            buffJunk,
            buffJunk.Cch(),
            &this->Request.ProcessorArchitecture,
            fValid));
        if ( !fValid ) this->Request.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    }
    else
    {
        this->Request.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    }
    
    //
    // Maybe this is a string like en-us, or maybe just a number.
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_LANGID, L"", buffJunk, pcwszSettingsFile));
    if ( buffJunk.Cch() != 0 )
    {
        ULONG ulTemp;
        if ( !ParseDecimalOrHexString(buffJunk, buffJunk.Cch(), ulTemp) )
        {
            BOOL fFound = FALSE;

            IFW32FALSE_EXIT(SxspMapCultureToLANGID(buffJunk, lidCurrentLang, &fFound));
            if ( !fFound )
            {
                goto Exit;
            }
        }
        else lidCurrentLang = static_cast<LANGID>(ulTemp);
    }
    this->Request.LangId = lidCurrentLang;
    
    //
    // Assembly root directory.  Not really required to be present?
    //
    IFW32FALSE_EXIT(SxspGetAssemblyRootDirectory(buffJunk));
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_ASMDIR, buffJunk, this->buffAssemblyDirectory, pcwszSettingsFile));
    this->Request.AssemblyDirectory = this->buffAssemblyDirectory;

    //
    // Textual identity string - if not present, null out the value
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_TEXTUALIDENT, L"", this->buffTextualIdentityString, pcwszSettingsFile));
    if ( this->buffTextualIdentityString.Cch() != 0 )
    {
        this->Request.TextualAssemblyIdentity = this->buffTextualIdentityString;
    }

    //
    // File paths
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_MANIFEST, L"", buffJunk, pcwszSettingsFile));
    if ( buffJunk.Cch() != 0 )
    {
        IFW32FALSE_EXIT(this->buffManifestStreamPath.Win32Assign(this->buffTestDirectory));
        IFW32FALSE_EXIT(this->buffManifestStreamPath.Win32AppendPathElement(buffJunk));
    }

    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(CSRSS_INI_SECTION_TITLE, CSRSS_INI_KEY_POLICY, L"", buffJunk, pcwszSettingsFile));
    if ( buffJunk.Cch() != 0 )
    {
        IFW32FALSE_EXIT(this->buffPolicyStreamPath.Win32Assign(this->buffTestDirectory));
        IFW32FALSE_EXIT(this->buffPolicyStreamPath.Win32AppendPathElement(buffJunk));
    }

    FN_EPILOG
}

typedef CDeque<CCsrssPoundingThreadEntry, offsetof(CCsrssPoundingThreadEntry, Linkage)> CStressEntryDeque;
typedef CDequeIterator<CCsrssPoundingThreadEntry, offsetof(CCsrssPoundingThreadEntry, Linkage)> CStressEntryDequeIter;

CStressEntryDeque g_CsrssStressers;

BOOL InitializeCsrssStress(
    PCWSTR pcwszTargetDirectory, 
    DWORD dwFlags
    )
{
    FN_PROLOG_WIN32

    CFindFile Finder;
    WIN32_FIND_DATAW FindData;
    CStringBuffer buffTemp;
    CStringBuffer buffTestActualRoot;

    //
    // The target directory here is the root of all the test case dirs, not the
    // csrss-specific directory.
    //
    IFW32FALSE_EXIT(buffTestActualRoot.Win32Assign(
        pcwszTargetDirectory, 
        wcslen(pcwszTargetDirectory)));
    IFW32FALSE_EXIT(buffTestActualRoot.Win32AppendPathElement(
        CSRSS_TEST_DIR_NAME, 
        CSRSS_TEST_DIR_NAME_CCH));

    if ((FindData.dwFileAttributes = ::GetFileAttributesW(buffTestActualRoot)) == 0xffffffff
        && (FindData.dwFileAttributes = ::FusionpGetLastWin32Error()) == ERROR_FILE_NOT_FOUND)
    {
        printf("no %ls tests, skipping\n", CSRSS_TEST_DIR_NAME);
        FN_SUCCESSFUL_EXIT();
    }
        
    IFW32FALSE_EXIT(buffTestActualRoot.Win32AppendPathElement(L"*", 1));
    IFW32FALSE_EXIT(Finder.Win32FindFirstFile(buffTestActualRoot, &FindData));
    IFW32FALSE_EXIT(buffTestActualRoot.Win32RemoveLastPathElement());

    do
    {
        CStringBuffer buffSettingsFile;
        CCsrssPoundingThreadEntry *TestEntry;

        if (( ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 ) ||
            FusionpIsDotOrDotDot(FindData.cFileName))        
        {
            continue;
        }

        //
        // Tack on the name of this test
        //
        IFW32NULL_EXIT(TestEntry = FUSION_NEW_SINGLETON(CCsrssPoundingThreadEntry));
        IFW32FALSE_EXIT(TestEntry->buffTestName.Win32Assign(
            FindData.cFileName, 
            wcslen(FindData.cFileName)));
        IFW32FALSE_EXIT(TestEntry->buffTestDirectory.Win32Assign(buffTestActualRoot));
        IFW32FALSE_EXIT(TestEntry->buffTestDirectory.Win32AppendPathElement(
            FindData.cFileName, 
            wcslen(FindData.cFileName)));

        IFW32FALSE_EXIT(buffSettingsFile.Win32Assign(TestEntry->buffTestDirectory));
        IFW32FALSE_EXIT(buffSettingsFile.Win32AppendPathElement(
            CSRSS_SETTINGS_FILE_NAME,
            CSRSS_SETTINGS_FILE_NAME_CCH));

        //
        // Acquire settings for this test
        //
        IFW32FALSE_EXIT(TestEntry->AcquireSettingsFrom(buffSettingsFile));
        g_CsrssStressers.AddToTail(TestEntry);
        TestEntry = NULL;
            
    } while (::FindNextFileW(Finder, &FindData));

    FN_EPILOG
}

BOOL WaitForCsrssStressShutdown()
{
    FN_PROLOG_WIN32

    CStressEntryDequeIter Iter(&g_CsrssStressers);

    for ( Iter.Reset(); Iter.More(); Iter.Next() )
    {
        CCsrssPoundingThreadEntry *Item = Iter.Current();
        Item->StopAndWaitForCompletion();
        Item->hOurThreadHandle.Win32Close();
    }

    FN_EPILOG
}

BOOL CsrssStressStartThreads( ULONG &ulThreadsCreated )
{
    FN_PROLOG_WIN32

    CStressEntryDequeIter Iter(&g_CsrssStressers);

    ulThreadsCreated = 0;

    for ( Iter.Reset(); Iter.More(); Iter.Next() )
    {
        CCsrssPoundingThreadEntry *Item = Iter.Current();

        IFW32FALSE_EXIT(Item->hOurThreadHandle.Win32CreateThread(
            Item->ThreadProcEntry, 
            Item));
        ulThreadsCreated++;
    }

    FN_EPILOG
}

BOOL CleanupCsrssTests()
{
    FN_PROLOG_WIN32

    g_CsrssStressers.ClearAndDeleteAll();
    
    FN_EPILOG
}

RequestCsrssStressShutdown()
{
    FN_PROLOG_WIN32

    CStressEntryDequeIter Iter(&g_CsrssStressers);

    for ( Iter.Reset(); Iter.More(); Iter.Next() )
    {
        CCsrssPoundingThreadEntry *Item = Iter.Current();
        Item->fStopNextRound = true;
    }
    
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sortpp\sortpp.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sortpp.c

Abstract:

    This program parses the file winincs.pp and generates a .PPM file
    compatible with GENTHNK.

Author:

    08-Jul-1995 JonLe

Revision History:

    27-Nov-1996 BarryBo -- code cleanup and documentation
    20-Mar-1998 mzoran  -- Added support for finding COM interfaces
    July 2001   JayKrell -- integrated from base\wow64\tools to base\tools
                            merged in checked changes from base\mvdm\MeoWThunks\tools\sortpp

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8604: 'SORTPP' ";

FILE *fpHeaders;
int StatementLineNumber;
char SourceFileName[MAX_PATH+1];
int  SourceLineNumber;
int TypeId = 0;

void DumpLexerOutput(int FirstToken);

//
// packing size as specified by /Zp option to the CL command
//
#define DEFAULTPACKINGSIZE 8

DWORD dwPackingCurrent = DEFAULTPACKINGSIZE;

typedef struct _packholder {
    struct _packholder *ppackholderNext;
    DWORD dwPacking;
    char sIdentifier[1];
    } PACKHOLDER;

PACKHOLDER *ppackholderHead = NULL;

struct TypeInfoListElement {
    struct TypeInfoListElement *pNext;
    TYPESINFO *pTypeInfo;
};

typedef struct TypeInfoListElement *PTYPEINFOELEMENT;

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE StructsList;
PRBTREE TypeDefsList;
RBTREE _VarsList;
PRBTREE VarsList = &_VarsList; // Used to track global variable declarations.
                               // Should not appear in the PPM file

char Headers[MAX_PATH+1];
char ppmName[MAX_PATH+1];

HANDLE hCvmHeap;
ULONG uBaseAddress = 0x30000000;
ULONG uReserveSize = 0x01800000;

BOOL bLine = FALSE;
char szThis[] = "This";

DWORD dwScopeLevel = 0;

void ExtractDerivedTypes(void);
BOOL LexNextStatement(void);
BOOL ParseFuncTypes(PTYPESINFO pTypesInfo, BOOL fDllImport);
BOOL ParseStructTypes(PTYPESINFO pTypesInfo);
BOOL ParseTypeDefs(PTYPESINFO pTypesInfo);
BOOL ParseVariables(VOID);
BOOL ParseGuid(GUID *pGuid);
BOOL AddDefaultDerivedTypes(void);
PKNOWNTYPES AddNewType(PTYPESINFO pTypesInfo, PRBTREE pTypesList);
BOOL CopyStructMembers(PTYPESINFO pTypesInfo, BOOL bUnion, PKNOWNTYPES pBaseType);
BOOL CopyEnumMembers(PTYPESINFO);
int CreatePseudoName(char *pDst, char *pSrc);
BOOL GetArrayIndex(DWORD *pdw);
LONGLONG expr(void);
LONGLONG expr_a1(void);
LONGLONG expr_a(void);
LONGLONG expr_b(void);
LONGLONG expr_c(void);
void CheckUpdateTypedefSizes(PTYPESINFO ptypesinfo);
PVOID SortppAllocCvm(ULONG Size);
BOOL WritePpmFile(char *PpmName);
void BumpStructUnionSize(DWORD *pdwSize, DWORD dwElemSize, BOOL bUnion);
BOOL GetExistingType(PTYPESINFO pTypesInfo, PBOOL pbFnPtr, PKNOWNTYPES *ppKnownTypes);
BOOL PrepareMappedMemory(void);
DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase);
void PackPush(char *sIdentifier);
DWORD PackPop(char *sIdentifier);
BOOL ConsumeDeclSpecOpt(BOOL IsFunc, BOOL bInitReturns, BOOL *pIsDllImport, BOOL *pIsGuidDefined, GUID *pGuid);
TOKENTYPE ConsumeDirectionOpt(void);
TOKENTYPE ConsumeConstVolatileOpt(void);
PTYPEINFOELEMENT TypeInfoElementAllocateLink(PTYPEINFOELEMENT *ppHead, PTYPEINFOELEMENT pThis, TYPESINFO *pType);
VOID UpdateGuids(VOID);
BOOL AddVariable(char *Name, GUID * pGuid);
VOID GenerateProxy(char *pName, PTYPESINFO pTypesInfo);
VOID FreeTypeInfoList(PTYPEINFOELEMENT pThis);
PMEMBERINFO CatMeminfo(BUFALLOCINFO *pBufallocinfo, PMEMBERINFO pHead, PMEMBERINFO pTail, DWORD dwOffset, BOOL bStatus);
BOOL ConsumeExternC(void);

//
// PPC compiler is screwing up the Initializa list head macro !
//
#if defined (_PPC_)
#undef InitializeListHead
#define InitializeListHead(ListHead) ( (ListHead)->Flink = (ListHead), \
                                       (ListHead)->Blink = (ListHead) \
                                      )
#endif


_inline void
PackModify(
    DWORD dw
)
{
    dwPackingCurrent = dw;
    DbgPrintf("new packing is %x\n", dw);
}

_inline DWORD
PackCurrentPacking(
    void
)
{
    return dwPackingCurrent;
}

DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase)
{
    if (dwCurrentSize == 0) {
        return 0;                   // no padding for first member
    }

    if (dwBase == 0) {
        dwBase = SIZEOFPOINTER;
    }                               // if no base size yet then must be a ptr

                                    // base is min(size, packing)
    if (dwBase > PackCurrentPacking()) {
        dwBase = PackCurrentPacking();
    }

                                    // figure out padding
    return (dwBase - (dwCurrentSize % dwBase)) % dwBase;
}

_inline DWORD PackPackingSize(DWORD dwCurrentSize, DWORD dwSize,
                              DWORD dwBase)
{
                                    // round up to nearest dwBase
    return PackPaddingSize(dwCurrentSize, dwBase) + dwSize;
}



/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
    int      i;
    char *pch;

    SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);

    try {

        /*
         *  Get cmd line args.
         */
        i = 0;
        while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                switch (toupper(*pch)) {
                case 'D':     // debug forces extra check
                    bDebug = TRUE;
                    setvbuf(stderr, NULL, _IONBF, 0);
                    break;

                case 'L':
                    bLine = TRUE;
                    break;

                case 'M':    // ppm output filename
                    strcpy(ppmName, ++pch);
                    DeleteFile(ppmName);
                    break;

                 case 'B':   // gBaseAddress
                     pch++;
                     uBaseAddress = atoi(pch);
                     break;

                 case 'R':   // Reserve size
                     pch++;
                     uReserveSize = atoi(pch);
                     break;

                 case '?':   // usage
                     ExitErrMsg(FALSE,
                     "sortpp -d -l -m<ppm file> -b<Base addr> -r<reserved> <pp file>\n");

                 default:
                     ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                 }
            } else if (*pch) {
               strcpy(Headers, pch);
            }
        }

        if (!*Headers) {
            ExitErrMsg(FALSE, "no Headers file name\n");
        }

        if (!*ppmName) {
          ExitErrMsg(FALSE, "no -m<PPM filename>\n");
        }


        DbgPrintf("%s -> %s\n", Headers, ppmName);


        if (!PrepareMappedMemory()) {
            ExitErrMsg(FALSE, "Problem in PrepareMappedMemory %s, gle = %d\n",
                                                  Headers, GetLastError());
        }

        RBInitTree(FuncsList);
        RBInitTree(StructsList);
        RBInitTree(TypeDefsList);
        RBInitTree(VarsList);  //not in the PPM file

        fpHeaders = fopen(Headers, "r");

        if (fpHeaders == NULL) {
            ExitErrMsg(FALSE, "Headers open '%s' errno=%d\n", Headers, errno);
        }

        if (!AddDefaultDerivedTypes()) {
            ExitErrMsg(TRUE, "AddDefaultDerivedTypes failed\n");
        }

        // pull out the different types: structs, typedefs function prototypes
        ExtractDerivedTypes();

        // Attempt to update guids for structs that don't have them
        UpdateGuids();

        if (!WritePpmFile(ppmName)) {
            ExitErrMsg(FALSE, "Problem in WritePpmFile gle = %d\n", GetLastError());
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExitErrMsg(FALSE,
                   "sortpp: ExceptionCode=%x\n",
                   GetExceptionCode()
                   );
    }

    DeleteAllocCvmHeap(hCvmHeap);

    return 0;
}



BOOL
AddDefaultDerivedTypes(
    void
    )
/*++

Routine Description:

    Add signed, unsigned to TypeDefsList.  Treated as derived types
    based on int.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure (probably out-of-memory)

--*/
{
    TYPESINFO TypesInfo;
    PFUNCINFO funcinfo;

    memset(&TypesInfo, 0, sizeof(TYPESINFO));

    strcpy(TypesInfo.BasicType,szINT);
    strcpy(TypesInfo.BaseName,szINT);
    strcpy(TypesInfo.TypeName,szINT);
    TypesInfo.Size = sizeof(int);
    TypesInfo.iPackSize = sizeof(int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"short int");
    TypesInfo.Size = sizeof(short int);
    TypesInfo.iPackSize = sizeof(short int);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned short int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"long int");
    TypesInfo.Size = sizeof(long int);
    TypesInfo.iPackSize = sizeof(long int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned long int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szCHAR);
    strcpy(TypesInfo.BaseName,szCHAR);
    strcpy(TypesInfo.TypeName,szCHAR);
    TypesInfo.Size = sizeof(char);
    TypesInfo.iPackSize = sizeof(char);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,szUNSIGNEDCHAR);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szINT64);
    strcpy(TypesInfo.BaseName,szINT64);
    strcpy(TypesInfo.TypeName,szINT64);
    TypesInfo.Size = sizeof(__int64);
    TypesInfo.iPackSize = sizeof(__int64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned _int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,sz_INT64);
    strcpy(TypesInfo.BaseName,sz_INT64);
    strcpy(TypesInfo.TypeName,sz_INT64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned __int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szDOUBLE);
    strcpy(TypesInfo.BaseName,szDOUBLE);
    strcpy(TypesInfo.TypeName,szDOUBLE);
    TypesInfo.Size = sizeof(double);
    TypesInfo.iPackSize = sizeof(double);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFLOAT);
    strcpy(TypesInfo.BaseName,szFLOAT);
    strcpy(TypesInfo.TypeName,szFLOAT);
    TypesInfo.Size = sizeof(float);
    TypesInfo.iPackSize = sizeof(float);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szVOID);
    strcpy(TypesInfo.BaseName,szVOID);
    strcpy(TypesInfo.TypeName,szVOID);
    TypesInfo.Size = 0;
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szGUID);
    strcpy(TypesInfo.BaseName,szGUID);
    strcpy(TypesInfo.TypeName,szGUID);
    TypesInfo.Size = 16;
    TypesInfo.iPackSize = 16;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFUNC);
    strcpy(TypesInfo.BaseName,szFUNC);
    strcpy(TypesInfo.TypeName,szFUNC);
    TypesInfo.Flags = BTI_CONTAINSFUNCPTR | BTI_NOTDERIVED;
    TypesInfo.Size = 4;
    TypesInfo.iPackSize = 4;
    TypesInfo.dwMemberSize = sizeof(FUNCINFO)+strlen(szVOID)+1;
    TypesInfo.TypeKind = TypeKindFunc;
    funcinfo = (PFUNCINFO)TypesInfo.Members;
    TypesInfo.pfuncinfo = funcinfo;
    funcinfo->sType = TypesInfo.Members + sizeof(FUNCINFO);
    strcpy(funcinfo->sType, szVOID);
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    TypesInfo.dwMemberSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    TypesInfo.TypeKind = TypeKindEmpty;
    TypesInfo.pfuncinfo = NULL;
    memset(TypesInfo.Members, 0, sizeof(TypesInfo.Members));

    strcpy(TypesInfo.BasicType,szVARGS);
    strcpy(TypesInfo.BaseName,szVARGS);
    strcpy(TypesInfo.TypeName,szVARGS);
    TypesInfo.Size = 0;               // varargs has size of 0
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic pointer type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "*");
    strcpy(TypesInfo.BaseName, "*");
    strcpy(TypesInfo.TypeName, "*");
    TypesInfo.IndLevel = 1;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic struct type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "struct");
    strcpy(TypesInfo.BaseName, "struct");
    strcpy(TypesInfo.TypeName, "struct");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic union type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "union");
    strcpy(TypesInfo.BaseName, "union");
    strcpy(TypesInfo.TypeName, "union");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Default type that matches all types.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "default");
    strcpy(TypesInfo.BaseName, "default");
    strcpy(TypesInfo.TypeName, "default");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ConsumeExternC(
    void
    )
{

/*++

Routine Description:

    Consumes an extern or an extern "C".

Arguments:

    None.

Return Value:

    TRUE - extern or extern "C" was consumed.

--*/

    PTOKEN Token;
    Token = CurrentToken();
    if (Token->TokenType == TK_EXTERN) {
        ConsumeToken();
        Token = CurrentToken();
        if (Token->TokenType == TK_STRING &&
            strcmp(Token->Name, "C") == 0)
            ConsumeToken();
        return TRUE;
    }
    return FALSE;
}

void
ExtractDerivedTypes(
    void
    )

/*++

Routine Description:

    Removes derived type definitions from headers, building the
    TypesDef, Structs, and Funcs lists.

Arguments:

    None.

Return Value:

    None.

--*/
{
    TYPESINFO TypesInfo;
    PRBTREE pListHead;
    BOOL fDllImport;

    //
    // Lex in entire C-language statements, then parse them.  Stops at EOF.
    //
    while (LexNextStatement()) {

        int OldTokenIndex;
        int c;

        if (bDebug) {
            DumpLexerOutput(0);
        }

        if (bLine) {
            for(c=80; c > 0; c--)
                fputc('\b', stderr);
            c = fprintf(stderr, "Status: %s(%d)", SourceFileName, StatementLineNumber);
            for(; c < 78; c++)
                fputc(' ', stderr);
            fflush(stderr);
        }

        pListHead = NULL;
        assert(dwScopeLevel == 0);

        if (CurrentToken()->TokenType == TK_EOS) {

            //ddraw.h has an extra ; at the end of an extern "C" block
            continue;

        }

        ConsumeExternC();

        ConsumeDeclSpecOpt(TRUE, TRUE, &fDllImport, NULL, NULL);

        ConsumeExternC();

        OldTokenIndex = CurrentTokenIndex;
        //
        // Try to parse as a TypeDef.
        //
        if (ParseTypeDefs(&TypesInfo)) {
            //
            // Got a typedef
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = TypeDefsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as TypeDef.  Try to parse as a struct/union/enum
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseStructTypes(&TypesInfo)) {
            //
            // got a struct definition
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = StructsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as struct/union/enum.  Try to parse as function
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseFuncTypes(&TypesInfo, fDllImport)) {
            //
            // got a function prototype
            //
            if (CurrentToken()->TokenType == TK_EOS && !TypesInfo.IndLevel) {
                pListHead = FuncsList;
                goto DoAddNewType;
            }
        }

        CurrentTokenIndex = OldTokenIndex;
        if (ParseVariables()) continue;

        CurrentTokenIndex = OldTokenIndex;

DoAddNewType:
        if (pListHead && !AddNewType(&TypesInfo, pListHead)) {
            ErrMsg("AddNewType fail\n");
        }

        if (CurrentToken()->TokenType != TK_EOS && bDebug) {

            fprintf(stderr, "Warning: Rejected %s(%d)\n", SourceFileName, StatementLineNumber);
            //
            // Use the 8k buffer in TypesInfo.Members to unlex the source stmt
            //
            UnlexToText(TypesInfo.Members,
                        sizeof(TypesInfo.Members),
                        0,
                        MAX_TOKENS_IN_STATEMENT);
            fprintf(stderr, "\t%s;\n", TypesInfo.Members);
        }
    }
}



PKNOWNTYPES
AddNewType(
    PTYPESINFO pTypesInfo,
    PRBTREE pTypesList
    )
/*++

Routine Description:

    Adds a new type to a types list.

Arguments:

    pTypesInfo  -- type to add
    pTypesList  -- list to add the type to

Return Value:

    Returns a pointer to the KNOWNTYPES for the new type on success,
    NULL for error.

--*/
{
    PKNOWNTYPES pkt;
    PKNOWNTYPES pKnownTypes = NULL;
    PDEFBASICTYPES pdbt;
    ULONG Flags = 0;

    if (((pTypesList == TypeDefsList) || (pTypesList == StructsList)) &&
        (((pTypesInfo->Size == 0) || (pTypesInfo->iPackSize == 0)) &&
        (*pTypesInfo->Members != 0))) {
        DbgPrintf("Added type with invalid size %s %s %s %d %d\n",
                     pTypesInfo->BasicType,
                     pTypesInfo->BaseName,
                     pTypesInfo->TypeName,
                     pTypesInfo->Size,
                     pTypesInfo->iPackSize);
    }

    pTypesInfo->TypeId = TypeId++;
    pTypesInfo->LineNumber = SourceLineNumber;
    pTypesInfo->dwScopeLevel = dwScopeLevel;
    pTypesInfo->dwCurrentPacking = PackCurrentPacking();
    if (strlen(SourceFileName) > sizeof(pTypesInfo->FileName) - 1)
        ExitErrMsg(FALSE, "Source file name is too large.\n");
    strcpy(pTypesInfo->FileName, SourceFileName);
    if (IsDefinedPointerDependent(pTypesInfo->TypeName))
       pTypesInfo->Flags |= BTI_POINTERDEP;

    //
    // Loop up the type and see if it is already in the list
    //
    pkt = GetNameFromTypesList(pTypesList, pTypesInfo->TypeName);
    if (pkt) {
//
// Uncomment the next line and comment the following line to change the
// behavior of this function. By doing this you will allow functions to be
// redefined in the following case: First a function that has no arguments
// is encountered and entered in the list. Later the same function is
// encountered with arguments and the new definition for it would override
// the old.
//      if ((pTypesList == StructsList) || (pTypesList == FuncsList)) {
        if (pTypesList == StructsList) {

            if (pTypesInfo->dwMemberSize == 0) {
                //
                // Since the struct has already been defined lets grab its
                // relevant size information.
                //
                pTypesInfo->IndLevel = pkt->IndLevel;
                pTypesInfo->Size = pkt->Size;
                pTypesInfo->iPackSize = pkt->iPackSize;
                pTypesInfo->TypeId = pkt->TypeId;
                return pkt;
            }

            if (! pkt->pmeminfo) {
                //
                // Find any previously defined typedefs that are based upon this
                // struct and fix their size.

                CheckUpdateTypedefSizes(pTypesInfo);
                ReplaceInTypesList(pkt, pTypesInfo);
                return pkt;
            }
        }
        else if (pkt->Flags & BTI_DISCARDABLE) {
            ReplaceInTypesList(pkt, pTypesInfo);
            return pkt;
        }
        //
        // else if it already exists, assume is the same
        //
        DbgPrintf("typedef: %s previously defined\n", pTypesInfo->TypeName);
        return pkt;
    }

    //
    // Type is not already listed.  Look up its basic type
    //
    pdbt = GetDefBasicType(pTypesInfo->BasicType);
    if (pdbt) {
       Flags = 0;
    } else {
        pkt = GetNameFromTypesList(pTypesList, pTypesInfo->BasicType);
        if (pkt) {
            Flags = pkt->Flags;
            pdbt = GetDefBasicType(pkt->BasicType);
            if (!pdbt) {
                ErrMsg("types Table corrupt %s\n", pkt->TypeName);
            }
        } else {
            ErrMsg("ant: unknown Basic Type %s\n", pTypesInfo->BasicType);
            goto ErrorExit;
        }
    }

    pTypesInfo->Flags |= Flags;
    strcpy(pTypesInfo->BasicType, pdbt->BasicType);
    pKnownTypes = AddToTypesList(pTypesList, pTypesInfo);
    if (pKnownTypes == NULL)
       goto ErrorExit;

    if (bDebug)
       DumpTypesInfo(pTypesInfo, stdout);

    return pKnownTypes;

ErrorExit:
    if (bDebug) {
        DumpTypesInfo(pTypesInfo, stdout);
    }


    DumpTypesInfo(pTypesInfo, stderr);
    return NULL;

}


void
CheckUpdateTypedefSizes(
    PTYPESINFO ptypesinfo
    )
/*++

Routine Description:

    We are about to replace an empty struct definition with one that has
    members and thus a size. We need to look through the typedefs list and
    see if any that have a size of 0 are defined from this new struct and if
    so then fix its size and packing size.

Arguments:

    ptypesinfo  -- struc definition with members

Return Value:

    None.

--*/
{
    PKNOWNTYPES pknwntyp, pkt;

    pknwntyp = TypeDefsList->pLastNodeInserted;

    while (pknwntyp) {
        if (pknwntyp->Size == 0) {
            pkt = GetBasicType(pknwntyp->TypeName, TypeDefsList, StructsList);
            if (pkt && ( ! strcmp(pkt->BasicType, szSTRUCT)) &&
                       ( ! strcmp(pkt->TypeName, ptypesinfo->TypeName))) {
                pknwntyp->Size = ptypesinfo->Size;
                pknwntyp->iPackSize = ptypesinfo->iPackSize;
                pknwntyp->Flags |= (ptypesinfo->Flags & BTI_CONTAINSFUNCPTR);
            }
        }
        pknwntyp = pknwntyp->Next;
    }
}


BOOL
GetExistingType(
    PTYPESINFO pTypesInfo,
    PBOOL pbFnPtr,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Gets an existing type from the lexer stream and returns the type
    information for it.

Arguments:

    pSrc        -- IN ptr to start of typename to look up
    pTypesInfo  -- Information of
    pbFnPtr     -- [OPTIONAL] OUT TRUE if the type is a pointer to a function
    ppKnownTypes-- [OPTIONAL] OUT KnownType infomation for this type if not a function pointer.

Return Value:

    FALSE if the name is not an existing type, or TRUE if the name is an
    existing type (CurrentToken ends up pointing at the token following the
    type).

--*/
{
    PKNOWNTYPES pKnownType;
    int OldCurrentTokenIndex = CurrentTokenIndex;

    if (bDebug) {
        fputs("GetExisting type called with the following lexer state:\n", stderr);
        DumpLexerOutput(CurrentTokenIndex);
    }
    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    if (pbFnPtr) {
        *pbFnPtr = FALSE;
    }

    if (ParseStructTypes(pTypesInfo)) {
        if ((pKnownType = AddNewType(pTypesInfo, StructsList)) != NULL) {
            if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
            return TRUE;
        } else {
            if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
            return FALSE;
        }
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (pbFnPtr && ParseFuncTypes(pTypesInfo, FALSE)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
        *pbFnPtr = TRUE;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(TypeDefsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(StructsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    return FALSE;
}


BOOL
ParseTypeDefs(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is a 'typedef'.  Accepted syntaxes are:

    typedef <mod> type <indir> NewName<[]> <, <indir> NewName<[]>>
    typedef <mod> struct|enum|union <name> <indir> NewName <, <indir> NewName>
    typedef <mod> rtype <indir>(<modifiers * NewName ) ( <arg List>)

    (Note that we don't deal with extraneous parens very well)

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a typedef
    FALSE if the statement is not a typedef or some kind of error

--*/
{
    int IndLevel;
    BOOL bFnPtr = FALSE;
    TYPESINFO TypesInfo;
    DWORD dwSize;
    PKNOWNTYPES pKnownTypes = NULL;
    int i;
    int Flags;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    if (CurrentToken()->TokenType != TK_TYPEDEF) {
        //
        // Line doesn't start with 'typedef'
        //
        return FALSE;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_STAR ||
        CurrentToken()->TokenType == TK_BITWISE_AND) {
        //
        // We have something like: 'typedef *foo;'.  This happens if a
        // .IDL file has a bogus typedef.  MIDL just omits the typename
        // if it isn't recognized.  Fake up a TypesInfo for 'int'.
        //
        ConsumeToken();
        bFnPtr = FALSE;
        memset(&TypesInfo, 0, sizeof(TypesInfo));
        strcpy(TypesInfo.BasicType,szINT);
        strcpy(TypesInfo.BaseName,szINT);
        strcpy(TypesInfo.TypeName,szINT);
        TypesInfo.Size = sizeof(int);
        TypesInfo.iPackSize = sizeof(int);
    } else {
        if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
            //
            // Text after 'typedef' doesn't start with anything plausible.
            //
            return FALSE;
        }

        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
        ConsumeConstVolatileOpt();
        if (!GetExistingType(&TypesInfo, &bFnPtr, &pKnownTypes)) {
            return FALSE;
        }
    }

    //
    // We now know the type.  Parse new type names derived from that type.
    //
    pTypesInfo->IndLevel = TypesInfo.IndLevel;
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_CONTAINSFUNCPTR);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_POINTERDEP);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_UNSIGNED);
    pTypesInfo->pTypedefBase = pKnownTypes;
    strcpy(pTypesInfo->BasicType, TypesInfo.BasicType);
    strcpy(pTypesInfo->TypeName, TypesInfo.TypeName);

    if (bFnPtr) {
        //
        // The type is a pointer to a function
        //
        pTypesInfo->Flags |= BTI_CONTAINSFUNCPTR;
        strcpy(pTypesInfo->BaseName, TypesInfo.BaseName);
        strcpy(pTypesInfo->FuncRet, TypesInfo.FuncRet);
        strcpy(pTypesInfo->FuncMod, TypesInfo.FuncMod);
        pTypesInfo->Size = SIZEOFPOINTER;
        pTypesInfo->iPackSize = SIZEOFPOINTER;
        pTypesInfo->dwMemberSize = TypesInfo.dwMemberSize;
        pTypesInfo->TypeKind = TypesInfo.TypeKind;
        memcpy(pTypesInfo->Members, TypesInfo.Members, sizeof(TypesInfo.Members));
        pTypesInfo->pfuncinfo = RelocateTypesInfo(pTypesInfo->Members,
                                                  &TypesInfo);
        return TRUE;
    }

    if (CurrentToken()->TokenType == TK_EOS) {
        return FALSE;
    }

    strcpy(pTypesInfo->BaseName, TypesInfo.TypeName);
    *pTypesInfo->TypeName = '\0';

    // don't handle extraneous parens.
    i = CurrentTokenIndex;
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_LPAREN) {
            return FALSE;
        }
        ConsumeToken();
    }
    CurrentTokenIndex = i;

    IndLevel = pTypesInfo->IndLevel;
    Flags = pTypesInfo->Flags;

    for (;;) {
        pTypesInfo->IndLevel = IndLevel;
        pTypesInfo->iPackSize = TypesInfo.iPackSize;
        pTypesInfo->Flags = Flags;
        dwSize = TypesInfo.Size;

        //
        // Skip 'const' keyword, if present.
        //
        if (CurrentToken()->TokenType == TK_CONST) {
            ConsumeToken();
        }

        //
        // Handle pointers to the base type
        //
        if (IsTokenSeparator() &&
            CurrentToken()->TokenType != TK_STAR &&
            CurrentToken()->TokenType != TK_BITWISE_AND) {
            return FALSE;
        }
        ParseIndirection(&pTypesInfo->IndLevel,
                         &dwSize,
                         &pTypesInfo->Flags,
                         NULL,
                         NULL);

        // This is a hack for the busted way that sortpp parses
        // data.   New types do not inherit the pointer size
        // properly.   We also can't inherit it at the top
        // since this might be a pointer to a pointer.  So what
        // we do is try to parse this as a pointer, and if the IndLevel
        // increases we know this is a pointer so do nothing.  If the IndLevel
        // doesn't increase, this is not a pointer so inherite the pointer attributes
        // from the parent.

        ASSERT(pTypesInfo->IndLevel >= IndLevel);
        if (pTypesInfo->IndLevel == IndLevel) {
            // inherite is ptr64 attribute from the base type.
            pTypesInfo->Flags |= (TypesInfo.Flags & BTI_PTR64);
        }

        if (CurrentToken()->TokenType != TK_IDENTIFIER) {
            return FALSE;
        }

        //
        // Get the name of the new typedef
        //
        if (CopyToken(pTypesInfo->TypeName,
                      CurrentToken()->Name,
                      sizeof(pTypesInfo->TypeName)-1
                      )
               >= sizeof(pTypesInfo->TypeName)) {
            return FALSE;
        }
        ConsumeToken();

        //
        // Handle an array of the type
        //
        while (CurrentToken()->TokenType == TK_LSQUARE) {
            DWORD dwIndex;

            if (!GetArrayIndex(&dwIndex)) {
                return FALSE;
            }

            if (dwIndex == 0) {          // a[] is really *a
                pTypesInfo->IndLevel++;
            } else {
                pTypesInfo->Flags |= BTI_ISARRAY;
                pTypesInfo->dwArrayElements = dwIndex;
                pTypesInfo->dwBaseSize = dwSize;
                dwSize = dwSize * dwIndex;
            }
        }

        if (pTypesInfo->IndLevel) {
            if (pTypesInfo->Flags & BTI_PTR64) {
                pTypesInfo->Size = SIZEOFPOINTER64;
                pTypesInfo->iPackSize = SIZEOFPOINTER64;
            } else {
                pTypesInfo->Size = SIZEOFPOINTER;
                pTypesInfo->iPackSize = SIZEOFPOINTER;
            }
            pTypesInfo->Flags |= BTI_POINTERDEP;
        } else {
            pTypesInfo->Size = dwSize;
        }

        switch (CurrentToken()->TokenType) {
        case TK_EOS:
            return TRUE;

        case TK_COMMA:
            //
            // There is a list of types derived from the base type
            // Add the current type in and loop to parse the next
            // type.
            //
            if (!AddNewType(pTypesInfo, TypeDefsList)) {
                return FALSE;
            }

            ConsumeToken(); // consume the ','
            break;

        default:
            return FALSE;
        }

    }

}



BOOL
ParseFuncTypes(
    PTYPESINFO pTypesInfo,
    BOOL fDllImport
    )
/*++

Routine Description:

    Parses a C-language statement if it is a function declaration:

    <mod> type <*> <mod> Name ( type <arg1>, type <arg2>, type <argn> )
    <mod> type <*> (<mod> * Name ) ( type <arg1>, type <arg2>, type <argn> )
    (Note that we don't deal with extraneous parens very well, and don't
     handle function pointers as return types.
     e.g. "void (*(*foo)(void))(void);" ).

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    fDllImport  -- TRUE if __declspec(dllimport) already consumed

Return Value:

    TRUE if the statement is a function declaration
    FALSE if the statement is not a function declaration or some kind of error

--*/
{
    char *pName;
    char *ps;
    char *pArgName;
    BOOL bFnPtr = FALSE;
    ULONG ArgNum = 0;
    int  IndLevel = 0;
    int  ArgIndLevel;
    int  Len;
    TYPESINFO ti;
    PFUNCINFO pfuncinfo;
    BUFALLOCINFO bufallocinfo;
    int  OldTokenIndex;
    char NoNameArg[32];
    PKNOWNTYPES pkt;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);
    pfuncinfo = NULL;


    if (fDllImport) {
        //
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }

    // for functions, the first token is ret type
    if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
        //
        // First token isn't even an identifier - bail out.
        //
        return FALSE;
    }

    ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);

    //
    // Remember the index of the first token which describes the return type.
    //
    OldTokenIndex = CurrentTokenIndex;

    if (CurrentToken()->TokenType == TK_LPAREN) {
        // This is this start of a typedef (pfn)()
        //  where the pfn has an implecit return type of
        // int.
        strcpy(pTypesInfo->FuncRet, "int");
        goto ImplicitReturnType;
    }

    if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
         // A struct element had a direction on it.  Ignore it and
         // warn the user.
         fprintf(stderr, "Warning: IN and OUT are ignored on function return types. %s line %d\n", SourceFileName, StatementLineNumber);
    }
    ConsumeConstVolatileOpt();
    if (!GetExistingType(&ti, NULL, NULL)) {
        ErrMsg("pft.rtype: unknown return type\n");
        DumpLexerOutput(OldTokenIndex);
        return FALSE;
    }

    // get indir for ret type
    ParseIndirection(&pTypesInfo->RetIndLevel, NULL, NULL, NULL, NULL);

    // Copy out ret type to FuncRet
    if (!UnlexToText(pTypesInfo->FuncRet, sizeof(pTypesInfo->FuncRet),
                     OldTokenIndex, CurrentTokenIndex)) {
        return FALSE;
    }

    ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);

    if (fDllImport) {
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }


    // if open paren, assume a fn pointer
ImplicitReturnType:
    if (CurrentToken()->TokenType == TK_LPAREN) {
        bFnPtr = TRUE;
        ConsumeToken();
    }

    // include cdecl, stdcall, save as FuncMod
    switch (CurrentToken()->TokenType) {
    case TK_CDECL:
        Len = CopyToken(pTypesInfo->FuncMod, szCDECL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_FASTCALL:
        Len = CopyToken(pTypesInfo->FuncMod, sz__FASTCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_STDCALL:
        Len = CopyToken(pTypesInfo->FuncMod, szSTDCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        //
        // some funky ole include has:
        // "BOOL (__stdcall __stdcall *pfnContinue)(DWORD)"
        //
        if (CurrentToken()->TokenType == TK_STDCALL) {
            ConsumeToken();
        }
        break;

    default:
        break;
    }

    pTypesInfo->TypeKind = TypeKindFunc;
    pTypesInfo->dwMemberSize = 0;

    //
    // count indir on function
    //
    if (bFnPtr) {
        while (CurrentToken()->TokenType == TK_STAR ||
               CurrentToken()->TokenType == TK_BITWISE_AND) {
           IndLevel++;
           ConsumeToken();
        }
    }

    //
    // We expect the next token to be the func name.
    //
    if (CurrentToken()->TokenType != TK_RPAREN &&
        CurrentToken()->TokenType != TK_IDENTIFIER) {
        return FALSE;
    }

    pName = (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) ? "" : CurrentToken()->Name;
    strcpy(pTypesInfo->BaseName, szFUNC);

    // look for beg of ArgList
    ConsumeToken();
    if (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) {
        ConsumeToken();
    }

    if (CurrentToken()->TokenType != TK_LPAREN) {
        return FALSE;
    }
    ConsumeToken();     // consume the '('

    //
    // copy out the ArgList
    //
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        }

        ArgIndLevel = 0;

        // ([mod] type [mod] [*] [mod] [ArgName] , ...)
        bFnPtr = FALSE;

        // skip register keywords all together
        if (CurrentToken()->TokenType == TK_REGISTER) {
            ConsumeToken();
        }

        //
        // Remember where we are in the parse
        //
        OldTokenIndex = CurrentTokenIndex;

        //
        // Allocate a new FUNCINFO struct for this parameter
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        if (!pTypesInfo->pfuncinfo) {
            pTypesInfo->pfuncinfo = pfuncinfo;
        }

        if (CurrentToken()->TokenType == TK_VARGS) {
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, szVARGS);
            BufAllocate(&bufallocinfo, strlen(szVARGS)+1);
            ConsumeToken();
            break;
        }

        // grab the IN, OUT, or 'IN OUT', if present
        pfuncinfo->tkDirection = ConsumeDirectionOpt();

        pfuncinfo->tkPreMod = ConsumeConstVolatileOpt();

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("pft.args: unknown argument type at %d\n", OldTokenIndex);
            return FALSE;
        }
        pfuncinfo->pkt = pkt;

        // enter fp member as a typedef to store args and rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);
            tiTmp.Flags |= BTI_CONTAINSFUNCPTR;

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, tiTmp.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            pArgName = ti.TypeName;
            goto aftername;
        } else {

            DWORD Flags = 0;

            // skip indirection
            ParseIndirection(&pfuncinfo->IndLevel,
                             NULL,
                             &Flags,
                             &pfuncinfo->tkPrePostMod,
                             &pfuncinfo->tkPostMod
                             );

            if (Flags & BTI_PTR64) {
                pfuncinfo->fIsPtr64 = TRUE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            //
            // If the type of the parameter has an explicit
            // struct/union/enum keyword, pass that info on to
            // genthnk.  ie. if the parameter type is like
            // 'struct typename argname', set tkSUE to TK_STRUCT.
            //
            if (strcmp(ti.BaseName, szSTRUCT) == 0) {
                pfuncinfo->tkSUE = TK_STRUCT;
            } else if (strcmp(ti.BaseName, szUNION) == 0) {
                pfuncinfo->tkSUE = TK_UNION;
            } else if (strcmp(ti.BaseName, szENUM) == 0) {
                pfuncinfo->tkSUE = TK_ENUM;
            } else {
                pfuncinfo->tkSUE = TK_NONE;
            }
        }

        // if no argument name present, create one
        switch (CurrentToken()->TokenType) {
        case TK_RPAREN:
        case TK_LSQUARE:
        case TK_COMMA:
            // but null arg list doesn't have any name
            if (CurrentToken()->TokenType == TK_COMMA ||
                ArgNum      ||
                ti.IndLevel ||
                pfuncinfo->IndLevel ||
                strcmp(ti.BasicType, szVOID) ) {

                pArgName = NoNameArg;
                sprintf(NoNameArg, "_noname%x", ArgNum++);
            } else {
                pArgName = NULL;
            }
            break;

        case TK_IDENTIFIER:
            pArgName = CurrentToken()->Name;
            if (ArgNum == 0 &&
                pfuncinfo->IndLevel == 1 &&
                strcmp(pArgName, "This") == 0) {
                //
                // This is the first arg and it is a pointer with name 'This'.
                // Assume it is a MIDL-generated proxy prototype.
                //
                pfuncinfo->tkDirection = TK_IN;
            }
            ConsumeToken();
            break;

        default:
            return FALSE;
        }

aftername:
        if (pArgName) {
            //
            // Copy the argument name from pArgName into pfuncinfo->sName.
            //
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sName = ps;
            strcpy(ps, pArgName);
        }

        //
        // Handle parameter which is a single-dimension array by copying the
        // entire string from '[' to ']' (inclusive)
        // ie.  int foo(int i[3])
        //
        if (CurrentToken()->TokenType == TK_LSQUARE) {
            //int OldCurrentTokenIndex = CurrentTokenIndex;
            //int ArgNameLen = strlen(ps);

            do {
                ConsumeToken();
            } while (CurrentToken()->TokenType != TK_RSQUARE &&
                     CurrentToken()->TokenType != TK_EOS);

            if (CurrentToken()->TokenType == TK_EOS) {
                // Reject - unmatched '[' and ']'
                return FALSE;
            }
//            if (CurrentTokenIndex - OldCurrentTokenIndex == 1) {
                //
                // Found: empty array bounds '[]'.  Bump IndLevel and
                // don't append the '[]' to the parameter name.
                //
                pfuncinfo->IndLevel++;
//            } else if (!UnlexToText(ps + ArgNameLen,
//                                    BufGetFreeSpace(&bufallocinfo) - ArgNameLen,
//                                    OldCurrentTokenIndex,
//                                    CurrentTokenIndex+1)) {
//                ErrMsg("pft: args list too long\n");
//                return FALSE;
//            }
            ConsumeToken();
        }
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //bug bug , hack hack, danger danger
        if (CurrentToken()->TokenType == TK_ASSIGN) {
            //Header is using the C++ syntax of assigning
            //a default value to a argument.
            //This will be skipped.  Skip until a TK_COMMA, TK_EOS, TK_RPAREN
            ConsumeToken();

            while(CurrentToken()->TokenType != TK_COMMA &&
                  CurrentToken()->TokenType != TK_EOS &&
                  CurrentToken()->TokenType != TK_RPAREN) {
                    ConsumeToken();
            }
        }

        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        } else {  // more args to go, add comma delimiter
            ConsumeToken();
        }
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        ErrMsg("pft: unknown syntax for fn args\n");
        return FALSE;
    }

    ConsumeToken(); // consume the ')'

    pTypesInfo->IndLevel = IndLevel;
    pTypesInfo->Size = 4;
    pTypesInfo->iPackSize = 4;
    strcpy(pTypesInfo->BasicType, szFUNC);
    if (CopyToken(pTypesInfo->TypeName,
                  pName,
                  sizeof(pTypesInfo->TypeName)-1
                  )
           >= sizeof(pTypesInfo->TypeName) ) {
       return FALSE;
    }
    if (pfuncinfo == NULL) {
        //
        // No args encountered - create VOID args now
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        ps = BufPointer(&bufallocinfo);
        strcpy(ps, szVOID);
        pfuncinfo->sType = ps;
        BufAllocate(&bufallocinfo, strlen(ps)+1);
        pTypesInfo->pfuncinfo = pfuncinfo;
    }
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

BOOL
ParseStructTypes(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is struct/union/enum declaration.

    struct|union|enum NewName <{}>
    struct NewName : <permission> BaseName <{}>
 (Note that we don't deal with extraneous parens very well)


Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a struct/union/enum
    FALSE if the statement is not a s/u/e, or some other error

--*/
{
    TOKENTYPE FirstToken;
    BOOL bEnum = FALSE;
    BOOL bUnion = FALSE;
    DWORD dwOldScopeLevel = dwScopeLevel;
    BOOL IsGuidDefined = FALSE;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    //
    // Match one of: STRUCT, UNION, or ENUM
    //
    FirstToken = CurrentToken()->TokenType;
    switch (FirstToken) {
    case TK_STRUCT:
        break;

    case TK_UNION:
        bUnion = TRUE;
        break;

    case TK_ENUM:
        bEnum = TRUE;
        break;

    default:
        goto retfail;   // no match
    }
    ConsumeToken();

    // BasicType is "struct", "union", or "enum"
    if (CopyToken(pTypesInfo->BasicType,
                  TokenString[FirstToken],
                  sizeof(pTypesInfo->BasicType)-1
                  )
            >= sizeof(pTypesInfo->BasicType) ) {
        goto retfail;
    }
    strcpy(pTypesInfo->BaseName, pTypesInfo->BasicType);

    //handle declspecs
    if (!bUnion && !bEnum) {
        while(ConsumeDeclSpecOpt(FALSE, FALSE, NULL, &IsGuidDefined, &(pTypesInfo->gGuid)));
        if (IsGuidDefined) pTypesInfo->Flags |= BTI_HASGUID;
    }

    switch (CurrentToken()->TokenType) {
    case TK_IDENTIFIER:
        {
            if (CopyToken(pTypesInfo->TypeName,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }
            ConsumeToken();
            break;
        }

    case TK_LBRACE:         // anonymous struct/union/enum
        if (!CreatePseudoName(pTypesInfo->TypeName, TokenString[FirstToken])) {
            //
            // call failed - probably buffer overflow
            //
            goto retfail;
        }
        pTypesInfo->Flags |= BTI_ANONYMOUS;
        break;

    default:
        //
        // STRUCT/UNION/ENUM followed by something other than an identifier
        // or a '{'.
        //
        goto retfail;
    }

    //
    // Process the contents of the curly braces, if present.
    //
    switch (CurrentToken()->TokenType) {
    case TK_EOS:
        goto retsuccess;

    case TK_LBRACE:
        {
            if (bEnum) {
                if(CopyEnumMembers(pTypesInfo)) goto retsuccess;
                else goto retfail;
            }
            if(CopyStructMembers(pTypesInfo, bUnion, NULL)) goto retsuccess;
            else goto retfail;

        }
    case TK_COLON: //entering a derived struct
        if (bEnum || bUnion) goto retfail;
        ConsumeToken();
        //look for base skipping public, private, and protected
        {
            PTOKEN pToken;
            PKNOWNTYPES BaseType;

            pToken = CurrentToken();

            if (pToken->TokenType != TK_IDENTIFIER) goto retfail;
            if (strcmp(pToken->Name, "public") == 0 ||
                strcmp(pToken->Name, "private") == 0 ||
                strcmp(pToken->Name, "protected") == 0) {
                ConsumeToken();
            }
            //look for base
            if (CopyToken(pTypesInfo->BaseType,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }

            //lookup the base in structures
            BaseType = GetNameFromTypesList(StructsList,pTypesInfo->BaseType);
            if (NULL == BaseType) {
                //ErrMsg("Base type is unknown or not a structure\n");
                goto retfail;
            }

            //look for opening brace or EOS
            ConsumeToken();
            if (CurrentToken()->TokenType == TK_EOS) goto retsuccess;
            if (CurrentToken()->TokenType != TK_LBRACE) goto retfail;
            if (CopyStructMembers(pTypesInfo, FALSE, BaseType)) goto retsuccess;
            else goto retfail;
        }

    default:
        break;
    }

    goto retsuccess;
retfail:
    dwScopeLevel = dwOldScopeLevel;
    return FALSE;
retsuccess:
    dwScopeLevel = dwOldScopeLevel;
    return TRUE;
}

BOOL
CopyEnumMembers(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Scans over members of an enumeration declaration.  Nobody cares
    about the actual names and values, so they are simply skipped over
    until the matching '}' is found.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    dwScopeLevel++;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    } else {
        ConsumeToken();
    }

    //
    // Find the '}' which ends the enumeration declaration
    //
    while (CurrentToken()->TokenType != TK_RBRACE) {
        ConsumeToken();
    }
    ConsumeToken(); // consume the '}', too

    *pdwSize = sizeof(int);     // enum
    *pdwPackSize = sizeof(int); // enum

    return TRUE;
}


// How sortpp computes packing sizes:
//
// * Each member has a packing size which is
//    - size of a appropriate pointer if member is a pointer
//    - packing size of its base type
// * The packing size of struc or union is min(packing_size_of_largest_member,
//   current_packing_size_when_struct_defined)
// * Each member in a struct is aligned according to min(current_packing_size,
//   member_packing_size).
// * All pointers have size sizeof(void *) except __ptr64 pointers which
//   have a size sizeof(PVOID64)
// * bit fields are coallessed until
//   - the end of the struct
//   - a non bit field member
//   - a bit field member, but of different base type size
// * char s[] as the last member of a struct adds nothing to the size of the
//   struct and should not be aligned.
// * each member of a union is packed at offset 0.


BOOL
pCopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PTYPEINFOELEMENT * ppMemberFuncs,
    DWORD Size,
    DWORD iPackSize
    )
/*++

Routine Description:

    Copies out struct members, verifying type of each member.

    { [mod] type [*] varname; [mod] type [*] varname; ...}
    { {varname, varname, ...}

    Assumes CurrentToken points at the '{' for the member list.
    Also determines the size of the struct/union.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    bUnion      -- TRUE if parsing union, FALSE if parsing STRUCT.
    ppMemberFuncs -- OUT returns a list of virtual member functions or NULL.

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    char *psMemBuf = pTypesInfo->Members;
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    int Len;
    BOOL bFnPtr;
    TYPESINFO ti;
    DWORD dw;
    DWORD dwBase;                   // running size of struct element
    DWORD dwElemSize;               // size of a particular element
    DWORD dwBaseTypeSize;           // size of basic type of element
    DWORD dwBits;                   // # bits in a bitfield element
    DWORD dwBitsTotal;              // running # bits for string of elemnts
    DWORD dwBitsTypeSize;           // bit fields base type size
    BOOL bForceOutBits = FALSE;
    BOOL bTailPointer = FALSE;
    DWORD dwLastPackSize = 0;
    DWORD dwLastSize = 0;
    PMEMBERINFO pmeminfo;
    BUFALLOCINFO bufallocinfo;
    char *ps;
    DWORD Flags;
    DWORD dwIndex;
    int ParenDepth = 0;

    PTYPEINFOELEMENT pMethods = NULL;
    DWORD dwMethodNumber = 0;

    PKNOWNTYPES pkt;

    if (ppMemberFuncs != NULL) *ppMemberFuncs = NULL;

    *pdwSize = Size;                  // initialize size of structure
    *pdwPackSize = iPackSize;              // initialize packing alignment
    dwLastSize = Size;
    dwLastPackSize = iPackSize;

    BufAllocInit(&bufallocinfo, psMemBuf, sizeof(pTypesInfo->Members), 0);
    pmeminfo = NULL;

    pTypesInfo->TypeKind = TypeKindStruct;
    pTypesInfo->dwMemberSize = 0;
    bFnPtr = FALSE;

    // loop over members of the structure or union

    dwBitsTotal = 0;
    dwBitsTypeSize = 0;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    }
    ConsumeToken();

    while (CurrentToken()->TokenType != TK_RBRACE) {
        int OldCurrentTokenIndex = CurrentTokenIndex;

        if (bDebug)
            DumpLexerOutput(CurrentTokenIndex);

        //strip off permission attributes
        //{public private protected} :
        while(CurrentToken()->TokenType == TK_IDENTIFIER &&
                (strcmp(CurrentToken()->Name, "public") == 0 ||
                 strcmp(CurrentToken()->Name, "private") == 0 ||
                 strcmp(CurrentToken()->Name, "protected") == 0
                 ))
        {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_COLON) return FALSE;
            ConsumeToken();

            if (CurrentToken()->TokenType == TK_RBRACE) goto done;
        }

        if (!bUnion &&
            ppMemberFuncs != NULL &&
            CurrentToken()->TokenType == TK_IDENTIFIER &&
            strcmp(CurrentToken()->Name, "virtual") == 0) {

            PTYPESINFO pFuncInfo;
            int TokenNumber = CurrentTokenIndex;
            ConsumeConstVolatileOpt();

            pFuncInfo = GenHeapAlloc(sizeof(TYPESINFO));
            if (pFuncInfo == NULL) ExitErrMsg(FALSE, "Out of memory!\n");
            ConsumeToken();

            //virtual method
            if (!ParseFuncTypes(pFuncInfo, FALSE)) {
                ErrMsg("Unable to parse method %u of %s\n", dwMethodNumber, pTypesInfo->TypeName);
                DumpLexerOutput(TokenNumber);
                return FALSE;
            }

            pMethods = TypeInfoElementAllocateLink(ppMemberFuncs, pMethods, pFuncInfo);

            //remove extra ;
            if (CurrentToken()->TokenType == TK_SEMI)
                ConsumeToken();
            //remove extra = 0;
            else if (CurrentToken()->TokenType == TK_ASSIGN) {
                ConsumeToken();
                //parsing 0;
                if (!(CurrentToken()->TokenType == TK_NUMBER &&
                    CurrentToken()->Value == 0)) return FALSE;
                ConsumeToken();
                //parsing ;
                if (CurrentToken()->TokenType != TK_SEMI) return FALSE;
                ConsumeToken();
            }
            else return FALSE; //fail

            dwMethodNumber++;
            continue;
        }


        if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
            // A struct element had a direction on it.  Ignore it and
            // warn the user.
            fprintf(stderr, "Warning: IN and OUT are ignored on struct members. %s line %d\n", SourceFileName, StatementLineNumber);
        }

        ConsumeConstVolatileOpt();

        pmeminfo = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
        if (pmeminfo == NULL) {
            ErrMsg("CopyStructMembers: No memberinfo\n");
            return FALSE;
        }

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("csm: unknown Type %d\n", OldCurrentTokenIndex);
            return FALSE;
        }
        pmeminfo->pkt = pkt;

        // enter function pointer member as a typedef to store args, rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            ti.Flags |= BTI_CONTAINSFUNCPTR;
            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }
            tiTmp.Size = ti.Size;
            tiTmp.iPackSize = ti.iPackSize;

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }
            ps = BufPointer(&bufallocinfo);
            pmeminfo->sName = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);
            pmeminfo->pkt = pkt;
        }
        /*else {
            ////////////////////////////////////////////////////////////////
            //This type has no members for it, do no process further.
            /////////////////////////////////////////////////////////////////
            if (CurrentToken()->TokenType == TK_SEMI) {
                ConsumeToken();
                continue;
            }
        }*/
        //
        // If the member contains a function pointer, then mark
        // this struct has containing a function pointer
        // Also mark if member is pointer dependent.

        pTypesInfo->Flags |= ((ti.Flags & BTI_CONTAINSFUNCPTR) | (ti.Flags & BTI_POINTERDEP));

        //
        // Union arm initialization
        dwBaseTypeSize = ti.iPackSize;

        if ((dwBitsTotal > 0) && (dwBaseTypeSize != dwBitsTypeSize)) {
            //
            // Determine size of bitfields
            //
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            *pdwSize = *pdwSize + PackPackingSize(bUnion ? 0 : *pdwSize,
                                                  dw*dwBitsTypeSize,
                                                  dwBitsTypeSize);
            dwBitsTotal = 0;
        }
        dwBitsTypeSize = dwBaseTypeSize;

        // element initialization
        dwBase = ti.Size;
        dwBits = 0;

        bTailPointer = FALSE;

        pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);

        //
        // Copy in the typename
        //
        ps = BufPointer(&bufallocinfo);
        pmeminfo->sType = ps;
        strcpy(ps, ti.TypeName);
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //
        // Skip just past the terminating ';' for this member and
        // figure out any size modifers to size of the base type.
        //
        while (CurrentToken()->TokenType != TK_SEMI) {

            PMEMBERINFO pmeminfoNew;

            switch (CurrentToken()->TokenType) {
            case TK_CONST:
            case TK_VOLATILE:
                ConsumeToken();
                break;

            case TK_COMMA:  // comma-separated list

                // update structure packing value
                if (dwBaseTypeSize > *pdwPackSize) {
                    *pdwPackSize = dwBaseTypeSize;
                }

                // flush out any bit fields not accounted for
                if ((dwBitsTotal > 0) && (dwBits == 0)) {
                    dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) /
                                                        (dwBitsTypeSize*8);
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                    dw*dwBitsTypeSize, dwBitsTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBitsTotal = 0;
                    // recompute offset
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                }

                // account for member just completed
                if (dwBits == 0) {
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                                             dwBase,
                                                             dwBaseTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBase = dwBaseTypeSize;
                }

                // update bit field count
                dwBitsTotal = dwBitsTotal + dwBits;
                dwBits = 0;

                // reset tail pointer flag
                bTailPointer = FALSE;

                // allocate space for new structure member and init it
                pmeminfoNew = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
                if (pmeminfoNew == NULL) {
                    ErrMsg("CopyStructMembers: No memberinfo\n");
                    return FALSE;
                    }

                // Copy over type information from previous meminfo.
                pmeminfoNew->sType = pmeminfo->sType;
                pmeminfoNew->pkt = pmeminfo->pkt;
                pmeminfo = pmeminfoNew;

                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                ConsumeToken();
                break;

            case TK_STAR:
            case TK_BITWISE_AND:
                Flags = 0;
                ParseIndirection(&pmeminfo->IndLevel, NULL, &Flags, NULL, NULL);
                if (Flags & BTI_PTR64) {
                    pmeminfo->bIsPtr64 = TRUE;
                    dwBase = SIZEOFPOINTER64;
                } else {
                    dwBase = SIZEOFPOINTER;
                }
                //  If a pointer is present, mark as being pointer dependent.
                if (pmeminfo->IndLevel > 0) pTypesInfo->Flags |= BTI_POINTERDEP;
                dwBaseTypeSize = dwBase;
                if (*pdwPackSize < dwBase) {
                    *pdwPackSize = dwBase;
                }
                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                break;

            case TK_LSQUARE:    // array declaration

                if (!GetArrayIndex(&dwIndex)) {
                    return FALSE;
                }
                if (dwIndex == 0) {          // a[] is really *a
                    bTailPointer = TRUE;
                    dwLastPackSize = *pdwPackSize;
                    dwLastSize = *pdwSize;
                    dwBase = SIZEOFPOINTER;
                    dwBaseTypeSize = SIZEOFPOINTER;
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                } else {
                    pmeminfo->bIsArray = TRUE;
                    pmeminfo->ArrayElements = dwIndex;
                    dwBase = dwBase * dwIndex;
                }
                break;

            case TK_COLON:          // bit field
                ConsumeToken();     // consume the ':'

                if (CurrentToken()->TokenType != TK_NUMBER) {
                    return FALSE;
                }

                dwBits = (DWORD)CurrentToken()->Value;
                ConsumeToken(); // consume the TK_NUMBER
                pmeminfo->bIsBitfield = TRUE;
                pmeminfo->BitsRequired = (int)dwBits;
                break;

            case TK_IDENTIFIER:
                ps = BufPointer(&bufallocinfo);
                pmeminfo->sName = ps;
                CopyToken(ps, CurrentToken()->Name, MAX_PATH);

                if (!BufAllocate(&bufallocinfo, strlen(ps)+1)) {
                    ErrMsg("csm.members: BufAllocate failed\n");
                    return FALSE;
                }
                ConsumeToken();
                break;

            case TK_LPAREN:
                //
                // windows\inc\wingdip.h has a type named GDICALL, which
                // has a member in it with the following declaration:
                //      WCHAR (*pDest)[MAX_PATH];
                // We are just going to skip the parens and assume all is OK.
                //
                ParenDepth++;
                ConsumeToken();
                break;

            case TK_RPAREN:
                ParenDepth--;
                ConsumeToken();
                break;

            default:
                ErrMsg("csm.members: unknown type (%d)\n", (int)CurrentToken()->TokenType);
                return FALSE;
            }

        }

        // hit ; at end of a members list
        if (ParenDepth) {
            ErrMsg("csm.members: mismatched parentheses at index %d\n", CurrentTokenIndex);
            return FALSE;
        }

        // update struct packing size to that of largest member
        if (dwBaseTypeSize > *pdwPackSize) {
            *pdwPackSize = dwBaseTypeSize;
        }

        ConsumeToken(); // consume the ';'

        if ((bUnion) || (CurrentToken()->TokenType == TK_SEMI)) {
            dwBitsTotal = dwBitsTotal + dwBits;
            bForceOutBits = TRUE;
                                       // always force out bits in union arm
        }                              // or at end of structure

        // flush out any bit fields not accounted for
        if ( (dwBitsTotal > 0) && ( (dwBits == 0) || bForceOutBits) ) {
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dw*dwBitsTypeSize, dwBitsTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
            dwBitsTotal = 0;
            // recompute offset
            pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
            }

        // account for member just completed
        if (dwBits == 0) {                    // add in last non bit fields
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dwBase, dwBaseTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
        }

        // update bit field counter
        dwBitsTotal = dwBitsTotal + dwBits;
        dwBits = 0;

    }

done:
    // Advance past the '}'
    if ((CurrentToken()->TokenType == TK_RBRACE)) {
        ConsumeToken();
    }

    // if last member was something like foo[] then we roll back the size
    if ((bTailPointer) && (*pdwSize != 4)) {
        *pdwSize = dwLastSize;
        *pdwPackSize = dwLastPackSize;
        pmeminfo->dwOffset = dwLastSize;
    }

    // pack overall structure on it packing size
    dwBaseTypeSize = PackCurrentPacking() < *pdwPackSize ?
                                  PackCurrentPacking() : *pdwPackSize;
    if (*pdwSize != 0) {         // round up to min(packing level,4)
        dwBase = *pdwSize % dwBaseTypeSize;
        if (dwBase != 0) {
            *pdwSize = *pdwSize + (dwBaseTypeSize - dwBase);
        }
    }

    *pdwPackSize = dwBaseTypeSize;
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

PMEMBERINFO
CatMeminfo(
    BUFALLOCINFO *pBufallocinfo,
    PMEMBERINFO pHead,
    PMEMBERINFO pTail,
    DWORD dwOffset,
    BOOL bStatus
    )
{

/*++

Routine Description:

    Concatinates the member info lists pointed to by pHead and pTail and
    copies them to the memory controled by the BUFALLOCINFO.  dwOffset is
    added to the offset for each of the members of the tail list.

Arguments:

    pBufallocinfo    -- [IN] ptr to buffer that represents the destination.
    pHead            -- [IN] ptr to the head list.
    pTail            -- [IN] ptr to the tail list.
    dwOffset         -- [IN] amount to add to the offset of elements in the tail.
    bStatus          -- [IN] Should be FALSE on initial call.

Return Value:

    Head of the new list.

--*/

    PMEMBERINFO pThis;
    char *pName, *pType;

    if (!bStatus && NULL == pHead) {
        pHead = pTail;
        bStatus = TRUE;
    }

    if (NULL == pHead) return NULL;

    pThis = (PMEMBERINFO)BufAllocate(pBufallocinfo, sizeof(MEMBERINFO));
    if (NULL == pThis) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);
    *pThis = *pHead;

    if (pHead->sName != NULL) {
        pName = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sName) + 1);
        if (NULL == pName) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sName);
        pThis->sName = strcpy(pName, pHead->sName);
    }

    if (pHead->sType != NULL) {
        pType = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sType) + 1);
        if (NULL == pType) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sType);
        pThis->sType = strcpy(pType, pHead->sType);
    }

    if (bStatus) pThis->dwOffset += dwOffset;
    pThis->pmeminfoNext = CatMeminfo(pBufallocinfo, pHead->pmeminfoNext, pTail, dwOffset, bStatus);

    return pThis;
}

VOID
FreeTypeInfoList(
    PTYPEINFOELEMENT pThis
    )
{
/*++

Routine Description:

    Frees the memory associated with a TYPEINFOELEMENT.

Arguments:

    pThis        -- [IN] ptr to the list to free.

Return Value:

    None.

--*/

    PTYPEINFOELEMENT pNext;

    while(NULL != pThis) {
        pNext = pThis->pNext;
        if (pThis->pTypeInfo != NULL) GenHeapFree(pThis->pTypeInfo);
        GenHeapFree(pThis);
        pThis = pNext;
    }
}

VOID
GenerateProxy(
    char *pName,
    PTYPESINFO pTypesInfo
    )
{

/*++

Routine Description:

    Generates proxy infomation for functions in a struct with virtual methods.
    The infomation is of the form structname_functionname_Proxy.
    The function is added to the functions list if not already in the list.
    The discardable flag is set so that this type will be redefined in refound in the code.

Arguments:

    pName        -- [IN] ptr to the name of the struct that the method is in.
    pTypesInfo   -- [IN] Information for the function.

Return Value:

    None.

--*/

    TYPESINFO NewTypesInfo;
    PFUNCINFO pFuncInfo;
    PFUNCINFO *ppFuncInfo;
    PFUNCINFO pCurrent;
    BUFALLOCINFO bufallocinfo;
    char *pChar;
    DWORD dwSizeArgName, dwSizeTypeName;

    // Bail out if not func, no struct name, or no class name
    if (pName == NULL || pTypesInfo->TypeName == NULL) return;
    if (pTypesInfo->TypeKind != TypeKindFunc ||
        strlen(pName) == 0 ||
        strlen(pTypesInfo->TypeName) == 0) return;

    NewTypesInfo = *pTypesInfo;
    strcpy(NewTypesInfo.TypeName, pName);
    strcat(NewTypesInfo.TypeName, "_");
    strcat(NewTypesInfo.TypeName, pTypesInfo->TypeName);
    strcat(NewTypesInfo.TypeName, "_Proxy");

    /////////////////////////////////////////////////////////////////
    //Check if the function has already been added.
    //If it has, no more work is needed.
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(FuncsList, NewTypesInfo.TypeName) != NULL)
        return;

    ////////////////////////////////////////////////////////////////////
    //Copy function members adding a this pointer at head
    //and skipping void arguments.
    ////////////////////////////////////////////////////////////////////
    BufAllocInit(&bufallocinfo, NewTypesInfo.Members, FUNCMEMBERSIZE, 0);
    dwSizeTypeName = strlen(pName) + 1;
    dwSizeArgName = strlen(szThis) + 1;
    pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
    if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

    pFuncInfo->fIsPtr64 = FALSE;
    pFuncInfo->tkDirection = TK_IN;
    pFuncInfo->tkPreMod = TK_NONE;
    pFuncInfo->tkSUE = TK_NONE;
    pFuncInfo->tkPrePostMod = TK_NONE;
    pFuncInfo->IndLevel = 1;
    pFuncInfo->tkPostMod = TK_NONE;
    pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
    strcpy(pChar, pName);
    pFuncInfo->sType = pChar;
    pChar += dwSizeTypeName;
    strcpy(pChar, szThis);
    pFuncInfo->sName = pChar;
    pFuncInfo->pfuncinfoNext = NULL;
    NewTypesInfo.pfuncinfo = pFuncInfo;
    ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    //skip an argument of type void if it is at the begining.
    //This is needed since ParseFuncTypes puts a void arg if the
    //func does not have any arguments
    pCurrent = pTypesInfo->pfuncinfo;
    if (pCurrent != NULL &&
        strcmp(szVOID, pCurrent->sType) == 0
        && pCurrent->IndLevel == 0) {
        pCurrent = pCurrent->pfuncinfoNext;
    }

    for(; pCurrent != NULL; pCurrent=pCurrent->pfuncinfoNext) {

        dwSizeTypeName = strlen(pCurrent->sType) + 1;
        dwSizeArgName = strlen(pCurrent->sName) + 1;
        pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
        if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

        *pFuncInfo = *pCurrent;
        pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
        strcpy(pChar, pCurrent->sType);
        pFuncInfo->sType = pChar;
        pChar += dwSizeTypeName;
        strcpy(pChar, pCurrent->sName);
        pFuncInfo->sName = pChar;
        pFuncInfo->pfuncinfoNext = NULL;
        *ppFuncInfo = pFuncInfo;
        ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    }

    NewTypesInfo.Flags |= BTI_DISCARDABLE;
    NewTypesInfo.dwMemberSize = bufallocinfo.dwLen;
    if (!AddNewType(&NewTypesInfo, FuncsList))
        ExitErrMsg(FALSE, "Unable to add proxy information.(Type was not in list)\n");

}

BOOL
CopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PKNOWNTYPES pBaseType
    )
{

/*++

Routine Description:

    Parses the members of the structure and adds them to the pTypesInfo.
    Handles merging of members and methods when the structure is derived
    from another structure.  Delegates actual parsing to pCopyStructMembers.

Arguments:

    pTypesInfo   -- [IN OUT] ptr to infomation for the type being processed.
    dwElemSize   -- [IN] TRUE if processing a union, FALSE if a struct.
    bUnion       -- [IN] ptr to KNOWNTYPE of base structure or NULL.

Return Value:

    TRUE - If success.

--*/

    PTYPEINFOELEMENT pMemberFuncs = NULL;
    BUFALLOCINFO bufallocinfo;

    dwScopeLevel++;

    /////////////////////////////////////////////////////////////////
    //Add a discardable version of this struct if one doesn't exist
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(StructsList, pTypesInfo->TypeName) == NULL) {
        TYPESINFO TTypesInfo;
        TTypesInfo = *pTypesInfo;
        TTypesInfo.Flags |= BTI_DISCARDABLE;
        AddNewType(&TTypesInfo, StructsList); //intentionally do not check
    }

    if(bUnion) return pCopyStructMembers(pTypesInfo, bUnion, NULL, 0, 0);

    if (pBaseType == NULL) {
        if (!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, 0, 0)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        if (pMemberFuncs!=NULL && pTypesInfo->Size > 0) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = 0;
        pTypesInfo->dwVTBLOffset = 0;

        if (pMemberFuncs != NULL) {


            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;
            DWORD dwVoidLen, dwVTBLLen;
            PMEMBERINFO pMemberInfo;
            char *pName;

            ///////////////////////////////////////////////////////////////////////////
            //Build the fake VTBL pointer
            /////////////////////////////////////////////////////////////////////////////

            //Add the VTBL member
            dwVoidLen = strlen(szVOID) + 1;
            dwVTBLLen = strlen(szVTBL) + 1;

            memset(pTypesInfo->Members, 0, FUNCMEMBERSIZE);
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            pMemberInfo = (PMEMBERINFO)BufAllocate(&bufallocinfo, sizeof(MEMBERINFO) + dwVoidLen + dwVTBLLen);
            if (NULL == pMemberInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

            pName = ((char *)pMemberInfo) + sizeof(MEMBERINFO);
            strcpy(pName, szVTBL);
            pMemberInfo->sName = pName;

            pName += dwVTBLLen;
            strcpy(pName, szVOID);
            pMemberInfo->sType = pName;

            pMemberInfo->pmeminfoNext = NULL;
            pMemberInfo->dwOffset = 0;
            pMemberInfo->IndLevel = 1;
            pMemberInfo->pktCache = 0;

            pTypesInfo->iPackSize = PackCurrentPacking() < SIZEOFPOINTER ?
                                      PackCurrentPacking() : SIZEOFPOINTER;
            pTypesInfo->Size = SIZEOFPOINTER;
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy methods over to Methods and IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if(!AppendToMultiSz(pTypesInfo->Methods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE) ||
                        !AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE)) {
                        ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                    }
                    GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                    dwElements++;
                }
            }

            pTypesInfo->dwVTBLSize = dwElements;
            pTypesInfo->dwVTBLOffset = 0;

            //If this is IUnknown, it is a COM object
            if (strcmp("IUnknown", pTypesInfo->TypeName) == 0)
                pTypesInfo->Flags |= BTI_ISCOM;

        }

    }

    else {

        if(!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, pBaseType->Size, pBaseType->iPackSize)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        // This checks that structures with data member are not mixed with structures with virtual methods.
        // This is a sortpp limitation that makes computing the packing size during inheritance easier.
        // The if statement say that a valid inheritance is either.
        // 1. The derived class does not add new virtual methods or data members.
        // 2. The derived class does not add new virtual methods, adds no new data members, and it inherites from a class with no virtual functions.
        // 3. The derived class adds virtual functions, adds no new data members, and the base class has no data members.
        if (!((pMemberFuncs == NULL && pTypesInfo->dwMemberSize == 0) ||
              (pMemberFuncs == NULL && pTypesInfo->dwMemberSize > 0 && pBaseType->dwVTBLSize == 0) ||
              (pMemberFuncs != NULL && pTypesInfo->dwMemberSize == 0 && pBaseType->SizeMembers == 0)
             )) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            ErrMsg("pMemberFuncs %p\n pTypesInfo->dwMemberSize %x\n pBaseType->Flags %x\n pBaseType->pmeminfo %p\n",
                    pMemberFuncs,
                    pTypesInfo->dwMemberSize,
                    pBaseType->Flags,
                    pBaseType->pmeminfo);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;
        pTypesInfo->Flags |= (pBaseType->Flags & ~BTI_HASGUID);
        if(pMemberFuncs == NULL) {

            char *Members;
            PMEMBERINFO pHead, pTail, pTemp;

            if (pBaseType->pmeminfo != NULL)
                pHead = (PMEMBERINFO)pBaseType->pmeminfo;
            else
                pHead = NULL;

            if (pTypesInfo->dwMemberSize > 0)
                pTail = (PMEMBERINFO)pTypesInfo->Members;
            else
                pTail = NULL;

            /////////////////////////////////////////////////////////////////////////////
            //Allocate memory for the temp array
            /////////////////////////////////////////////////////////////////////////////
            Members = GenHeapAlloc(FUNCMEMBERSIZE);

            if (Members == NULL)
                ExitErrMsg(FALSE, "Out of memory!\n");

            /////////////////////////////////////////////////////////////////////////////
            //merge members lists with basetype
            /////////////////////////////////////////////////////////////////////////////

            //copy the concatination of the two to the temp buffer
            BufAllocInit(&bufallocinfo, Members, FUNCMEMBERSIZE, 0);
            pTemp = CatMeminfo(&bufallocinfo, pHead, pTail, 0, FALSE);

            ////////////////////////////////////////////////////////////////////////
            //copy members from temp buffers back to pTypesInfo
            ////////////////////////////////////////////////////////////////////////
            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            if (pTemp) {
                // Only call this one if the first one did anyting.  Otherwise
                // This one reads from uninitialized heap.
                CatMeminfo(&bufallocinfo, (PMEMBERINFO)Members, NULL, 0, FALSE);
            }
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            GlobalFree(Members);
        }

        else {

            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;

            // This struct is virtual only since methods are being added.  We already checked that no
            // data members will be in the structure.
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ////////////////////////////////////////////////////////
            //Copy base members over
            ////////////////////////////////////////////////////////

            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            CatMeminfo(&bufallocinfo, pBaseType->pmeminfo, NULL, 0, FALSE);
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy unique methods over to IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if (!IsInMultiSz(pBaseType->Methods, pThisElement->pTypeInfo->TypeName)) {
                        if(!AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName,
                            MEMBERMETHODSSIZE)) {
                            ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                        }
                        GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                        dwElements++;
                    }
                }
            }

            memcpy(pTypesInfo->Methods, pBaseType->Methods, SizeOfMultiSz(pBaseType->Methods));
            if (!CatMultiSz(pTypesInfo->Methods, pTypesInfo->IMethods, MEMBERMETHODSSIZE))
                ExitErrMsg(FALSE, "Too many methods in %s\n", pTypesInfo->TypeName);

            pTypesInfo->dwVTBLSize = dwElements + pBaseType->dwVTBLSize;
            pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;

        }

    }

    FreeTypeInfoList(pMemberFuncs);
    return TRUE;
}

void
BumpStructUnionSize(
    DWORD *pdwSize,
    DWORD dwElemSize,
    BOOL bUnion
    )
/*++

Routine Description:

    Updates overall size of a struct/union

Arguments:

    pdwSize      -- [IN OUT] overall size of struct/union
    dwElemSize   -- size of new element to add into the struct/union
    bUnion       -- TRUE if a union, FALSE if a struct

Return Value:

    None.

--*/
{
    if (bUnion) {
        //
        // Size of a union is max(dwSize, dwElementSize)
        //
        if (dwElemSize > *pdwSize) {
            *pdwSize = dwElemSize;
        }
    } else {
        //
        // Size of a struct is current size of struct plus element size
        //
        *pdwSize = *pdwSize + dwElemSize;
    }
}

BOOL
ParseGuid(
    GUID *pGuid
    )
{
/*++

Routine Description:

    Parses a guid of the type found in a variable declaration.

Arguments:

    pGuid    -  [OUT] ptr to the guid.

Return Value:

    TRUE    - Guid parsed.
    FALSE   - Parse failed.

--*/
    unsigned int c;
    LONGLONG value;

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;
    pGuid->Data1 = (unsigned long)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;


    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    c = 0;
    while(TRUE) {

        if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
        value = expr();
        if(value < 0 || value > 0xFF) return FALSE;
        pGuid->Data4[c] = (unsigned char)value;

        if (7 == c) break;

        if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
        ConsumeToken();

        c++;

    }

    for(c=0; c<2; c++) {
        if (CurrentToken()->TokenType != TK_RBRACE) return FALSE;
        ConsumeToken();
    }

    return TRUE;

}

BOOL
ParseVariables(
    VOID
    )
{

/*++

Routine Description:

    Attempts to parse a variable declaration. If successful, the variable
    is added to the variable list.

Arguments:

    none

Return Value:

    TRUE - If success.

--*/


    TYPESINFO TypesInfo;
    GUID Guid;
    char *Name;

    ConsumeConstVolatileOpt();
    if (!GetExistingType(&TypesInfo, NULL, NULL)) return FALSE;
    while(CurrentToken()->TokenType == TK_STAR) ConsumeToken();

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    //next token should be the variable name
    if (CurrentToken()->TokenType != TK_IDENTIFIER) return FALSE;
    Name = CurrentToken()->Name;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
    if (CurrentToken()->TokenType != TK_ASSIGN) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_NUMBER || CurrentToken()->TokenType == TK_STRING) {
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
        return FALSE;
    }
    else if (CurrentToken()->TokenType == TK_LBRACE) {
        //attempt to parse a guid definition
        if (ParseGuid(&Guid) &&
            CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, &Guid);
        else return FALSE;
    }
    else return FALSE;

}

BOOL
GetArrayIndex(
    DWORD *pdw
    )
/*++

Routine Description:

    Parses the size of an array index by evaluating a C-language constant
    expression.

Arguments:

    pdw     -- [OUT] ptr to size of the array index.

Return Value:

    TRUE if array index parsed (CurrentToken points after the ']')
    FALSE if parse failed.

--*/
{
    LONGLONG value;

    *pdw = 0;       // assume no size

    if (CurrentToken()->TokenType != TK_LSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;

    *pdw = (DWORD)value;

    if (CurrentToken()->TokenType != TK_RSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    return TRUE;
}

LONGLONG
expr(
    void
    )

{
    LONGLONG val = expr_a1();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ConsumeToken();
            val &= expr_a1();
            break;

        case TK_BITWISE_OR:
            ConsumeToken();
            val |= expr_a1();
            break;

        default:
            return val;
        }
    } while (1);

}

LONGLONG
expr_a1(
    void
    )
{
    LONGLONG val = expr_a();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_LSHIFT:
            ConsumeToken();
            val <<= expr_a();
            break;

        case TK_RSHIFT:
            ConsumeToken();
            val >>= expr_a();
            break;

        default:
            return val;
        }
    }

}

LONGLONG
expr_a(
    void
    )
/*++

Routine Description:

    Parses a C-language constant expression and returns the value - handles
    the operators 'plus' and 'minus'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_b();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_PLUS:
            ConsumeToken();
            val += expr_b();
            break;

        case TK_MINUS:
            ConsumeToken();
            val -= expr_b();
            break;

        default:
            return val;
        }
    } while (1);
}

LONGLONG
expr_b(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles the highest-precedence operators
    'multiply' and 'divide'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_c();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_STAR:
            ConsumeToken();
            val *= expr_c();
            break;

        case TK_DIVIDE:
            ConsumeToken();
            val /= expr_c();
            break;

        case TK_MOD:
            ConsumeToken();
            val %= expr_c();
            break;

        default:
            // done
            return val;
        }
    } while (1);

}

LONGLONG
expr_c(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles unary parts of the expression, like
    numbers, unary minus, and parentheses.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val;

    switch (CurrentToken()->TokenType) {
    case TK_NUMBER:
        val = CurrentToken()->dwValue;
        ConsumeToken();
        break;

    case TK_MINUS:  // unary minus
        ConsumeToken();
        val = -expr_c();
        break;

    case TK_TILDE:  // unary not
        ConsumeToken();
        val = ~expr_c();
        break;

    case TK_LPAREN:
        ConsumeToken();
        val = expr();
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Syntax error:  expected ')'");
        }
        ConsumeToken();
        break;

    case TK_RSQUARE:
        val = 0;
        break;

    case TK_SIZEOF:
        ConsumeToken(); // eat the sizeof keyword
        if (CurrentToken()->TokenType != TK_LPAREN) {
            ErrMsg("Expected '(' after 'sizeof\n");
            val = 0;
            break;
        }
        ConsumeToken(); // eat the '('
        if (CurrentToken()->TokenType == TK_STRING) {
            // sizeof(string literal)
            val = strlen(CurrentToken()->Name) + 1;
            ConsumeToken();
        } else {
            // sizeof(some type)
            TYPESINFO TypesInfo;
            DWORD dwIndLevel;
            DWORD dwSize;

            if (!GetExistingType(&TypesInfo, NULL, NULL)) {
                ExitErrMsg(FALSE, "Parse error in sizeof(typename)\n");
            }
            dwIndLevel = 0;
            ParseIndirection(&dwIndLevel, &dwSize, NULL, NULL, NULL);
            if (dwIndLevel) {
                val = (int)dwSize;
            } else {
                val = TypesInfo.Size;
            }
        }
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Expected ')' after 'sizeof(expr)\n");
        val = 0;
            break;
        }
        ConsumeToken(); // eat the ')'
        break;

    default:
        ErrMsg("Syntax error parsing expression\n");
        val = 0;
        break;
    }

    return val;
}


int
CreatePseudoName(
    char *pDst,
    char *pSrc
    )
/*++

Routine Description:

    Prefixes a given name with an index number and copies it into a buffer.

Arguments:

    pDst        -- [OUT] destination for the new name
    pSrc        -- [IN]  source for the base name (may be same as pDst)

Return Value:

    Chars copied, 0 for failure.

--*/
{
   static PseudoNameIndex = 0;
   int Len;
   char Buffer[MAX_PATH];

   Len = _snprintf(Buffer,
                   sizeof(Buffer) - 1,
                   "__wx86%2.2d%s",
                   PseudoNameIndex++,
                   pSrc
                   );

   if (Len <= 0) {
       ErrMsg("cpn: buffer overflow <%s>\n", pSrc);
       return 0;
       }

   strcpy(pDst, Buffer);

   return Len;

}




void
PackPush(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (push...)'

Arguments:

    sIdentifier     -- [OPTIONAL] name to associate with the current pack level

Return Value:

    None.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;

    if (!sIdentifier) {
        sIdentifier = "";
    }

    DbgPrintf("push (%d)\n", PackCurrentPacking());

    ppackholder = GenHeapAlloc(sizeof(PACKHOLDER) + strlen(sIdentifier));
    if (ppackholder == NULL) {
        ExitErrMsg(FALSE, "Out of memory for packing stack");
    }

    ppackholder->dwPacking = PackCurrentPacking();
    ppackholder->ppackholderNext = ppackholderHead;
    strcpy(ppackholder->sIdentifier, sIdentifier);
    ppackholderHead = ppackholder;
}


DWORD
PackPop(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (pop...)'

Arguments:

    sIdentifier -- [OPTIONAL] name to pop to

Return Value:

    Returns new packing value.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;
    PACKHOLDER *ppackholderPop;
    PACKHOLDER *ppackholderNext;
    DWORD dw = DEFAULTPACKINGSIZE;

    if (ppackholderHead == NULL) {
        ExitErrMsg(FALSE, "Error:  '#pragma pack' stack underflow.");
    }

    if (sIdentifier == NULL) {
        ppackholder = ppackholderHead;
        ppackholderHead = ppackholder->ppackholderNext;
        dw = ppackholder->dwPacking;
        GenHeapFree(ppackholder);
    } else {
        ppackholderPop = ppackholderHead;
        do {
            DbgPrintf("Poping for %s [%s]\n", sIdentifier, ppackholderPop ? ppackholderPop->sIdentifier : "-");
            ppackholderNext = ppackholderPop->ppackholderNext;
            if (strcmp(sIdentifier, ppackholderPop->sIdentifier) == 0) {
                dw = ppackholderPop->dwPacking;
                break;
            }
            ppackholderPop = ppackholderNext;
        } while (ppackholderPop != NULL);

        DbgPrintf("Found %s\n", ppackholderPop ? ppackholderPop->sIdentifier : "-");
        if (ppackholderPop != NULL) {
            ppackholderNext = ppackholderHead;
            do {
                ppackholder = ppackholderNext;
                ppackholderNext = ppackholder->ppackholderNext;
                ppackholderHead = ppackholderNext;
                GenHeapFree(ppackholder);
            } while (ppackholder != ppackholderPop);
        }
    }

    DbgPrintf("pop (%d)\n", dw);
    return(dw);
}

BOOL
PrepareMappedMemory(
    void
    )
/*++

Routine Description:

    Creates the memory for the .PPM file.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PCVMHEAPHEADER pHeader;
    hCvmHeap = CreateAllocCvmHeap(uBaseAddress,     // uBaseAddress
                       uReserveSize,   // uReservedSize
                       0x00010000,     // uRegionSize
                       0,              // uUncommited
                       0,              // uUnReserved
                       0);             // uAvailable

    if (hCvmHeap != NULL) {

        // create the heap header
        pHeader = SortppAllocCvm(sizeof(CVMHEAPHEADER));
        if (!pHeader) {
            return FALSE;
        }
        pHeader->Version = VM_TOOL_VERSION;
        pHeader->BaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);

        fpTypesListMalloc = SortppAllocCvm;

        FuncsList = &pHeader->FuncsList;
        StructsList = &pHeader->StructsList;
        TypeDefsList = &pHeader->TypeDefsList;
        NIL = &pHeader->NIL;
    }

    return(hCvmHeap != NULL);
}


PVOID
SortppAllocCvm(
    ULONG Size
    )
/*++

Routine Description:

    Allocates memory from the .PPM file mapping.

Arguments:

    None.

Return Value:

    ptr to new memory, or NULL on failure.

--*/
{
    return AllocCvm(hCvmHeap, Size);
}


BOOL
WritePpmFile(
    char *PpmName
    )
/*++

Routine Description:

    Write the .PPM file out to disk.

Arguments:

    Ppmname     -- [IN] name for .PPM file

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL bSuccess;
    HANDLE hPpmFile;
    DWORD BytesWritten;
    ULONG_PTR uBaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);
    ULONG_PTR uAvailable = (ULONG_PTR)GetCvmHeapAvailable(hCvmHeap);

    hPpmFile = CreateFile(PpmName,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if (hPpmFile == INVALID_HANDLE_VALUE) {
        ExitErrMsg(FALSE,
                   "CreateFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    if (!AddOpenFile(PpmName, 0, hPpmFile)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }

#if _WIN64
    if ((uAvailable - uBaseAddress) > MAXHALF_PTR) {
        ExitErrMsg(FALSE, "Attempt to write more than 0x%x bytes not allowed\n", MAXHALF_PTR);
    }
#endif

    bSuccess = WriteFile(hPpmFile,
                         (PVOID)uBaseAddress,
                         (DWORD)(uAvailable - uBaseAddress),
                         &BytesWritten,
                         NULL
                         );

    if (!bSuccess || BytesWritten != uAvailable - uBaseAddress) {
        ExitErrMsg(FALSE,
                   "WriteFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    DelOpenFile(0, hPpmFile);
    CloseHandle(hPpmFile);
    return TRUE;
}

void
HandlePreprocessorDirective(
    char *Line
    )
/*++

Routine Description:

    Scan and process a '#' preprocessor directive.
    Accepts:
        #pragma line LINENUM SOURCEFILE
        #pragma pack( [ [ { push | pop}, ] [  identifier,  ] ] [ n ] )

Arguments:

    Line    -- ptr to the source line (points at the '#' character)

Return Value:

    None.

--*/
{
    char *p;

    // skip over '#' character
    Line++;

    // skip over any spaces between '#' and the next token
    while (*Line == ' ' || *Line == '\t') {
        Line++;
    }

    // find the first token
    for (p = Line; isalpha(*p); ++p)
        ;

    *p = '\0';

    if (strcmp(Line, "pragma") == 0) {
        //
        // found: #pragma
        //
        char c;
        p++;

        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // Set 'Line' to the start of the word following '#pragma' and
        // move 'p' to the character following that word.
        //
        for (Line = p; isalpha(*p); ++p)
            ;

        //
        // Null-terminate the keyword, but save the overwritten character
        // for later.
        //
        c = *p;
        *p = '\0';

        if (strcmp(Line, "pack") != 0) {
            //
            // Might be "warning", "function" or "once".  Ignore these.
            //
            return;
        }

        //
        // Remove the null-terminator from the pragma and move 'p' to the
        // first character after "#pragma pack"
        //
        *p = c;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        if (*p == '\0') {
            //
            // Found: "#pragma pack" all by itself.  Reset packing to the
            // default value.
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (*p != '(') {
            ExitErrMsg(FALSE, "Unknown '#pragma pack' syntax '%s'.\n", Line);
        }

        //
        // skip over the '(' character and any whitespace
        //
        do {
            p++;
        } while (*p == ' ' || *p == '\t');

        if (isdigit(*p)) {
            //
            // Found: '#pragma pack(NUMBER)'
            //
            PackModify(atol(p));
            //
            // Don't worry about the closing ')' - assume things are alright.
            //
            return;
        } else if (*p == ')') {
            //
            // Found: '#pragma pack()'
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (!isalpha(*p)) {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s'.\n", Line);
            return;
        }

        //
        // Grab the next keyword following '#pragma pack('
        //
        for (Line = p; isalpha(*p); ++p)
            ;
        c = *p;
        *p = '\0';

        if (strcmp(Line, "push") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ',') {
                //
                // Skip the ',' and any whitespace
                //
                do {
                    p++;
                } while (*p == ' ' || *p == '\t');

                if (isdigit(*p)) {
                    //
                    // Found: "#pragma pack(push, n)"
                    //
                    PackPush(NULL);
                    PackModify(atoi(p));
                } else if (isalpha(*p) || *p == '_') {
                    //
                    // Found an identifier after "#pragma pack(push, ".
                    // Scan ahead to end of identifier.
                    //
                    Line = p;
                    do {
                        p++;
                    } while (isalnum(*p) || *p == '_');

                    //
                    // null-terminate the identifier, in 'Line'
                    //
                    c = *p;
                    *p = '\0';

                    //
                    // Skip past whitespace
                    //
                    while (c == ' ' || c == '\t') {
                        p++;
                        c = *p;
                    }
                    // 'c' is the first non-white char after identifier


                    if (c == ')') {
                        //
                        // Found: "#pragma pack(push, identifier)"
                        //
                        PackPush(Line);
                    } else if (c == ',') {
                        //
                        // Expect a number as the last thing on the line
                        //
                        PackPush(Line);
                        PackModify(atoi(p+1));
                    } else {
                        ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s' at %s(%d)\n", p, SourceFileName, StatementLineNumber );
                    }
                } else {
                    ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s'\n", p);
                }
            } else if (*p == ')') {
                //
                // Found: "#pragma pack(push)"
                //
                PackPush(NULL);

            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(push)' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
            }

        } else if (strcmp(Line, "pop") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ')') {
                //
                // Found: "#pragma pack(pop)"
                //
                PackModify(PackPop(NULL));
            } else if (*p == ',') {
                //
                // Found: "#pragma pack(pop, identifier)"
                //
                p++;
                while (*p == ' ' || *p == '\t') p++;

                if (!(isalpha(*p) || *p == '_'))
                    ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);

                Line = p;
                do {
                    p++;
                } while (isalnum(*p) || *p == '_');
                *p = '\0';
                PackModify(PackPop(Line));
            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);
            }
        } else {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
        }

    } else if (strcmp(Line, "line") == 0) {
        //
        // found: #line LINE_NUMBER "FILENAME"
        //
        int i;

        //
        // skip over any spaces between '#line' and the line number
        //
        p++;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // copy in the new line number
        //
        SourceLineNumber = 0;
        while (isdigit(*p)) {
            SourceLineNumber = SourceLineNumber * 10 + *p - '0';
            p++;
        }
        SourceLineNumber--;

        //
        // Skip over any spaces between line number and the filename
        //
        while (*p == ' ' || *p == '\t') {
          p++;
        }

        //
        // Skip over the opening quote
        //
        if (*p == '\"') {
            p++;
        } else {
            ExitErrMsg(FALSE, "Badly-formed #line directive - filename missing");
        }

        //
        // Copy in the filename, converting "\\" sequences to single '\'
        //
        for (i=0; *p && *p != '\"' && i<sizeof(SourceFileName)-1; ++i, ++p) {
            if (*p == '\\' && p[1] == '\\') {
                p++;
            }
            SourceFileName[i] = *p;
        }
        SourceFileName[i] = '\0';
        StatementLineNumber = SourceLineNumber;
    } else {
        ExitErrMsg(FALSE, "Unknown '#' directive (%s).\n", Line);
    }

}


BOOL
LexNextStatement(
    void
    )
/*++

Routine Description:

    Read from the input file and perform lexical analysis.  On return, an
    entire C-language statement has been tokenized.  Use CurrentToken(),
    ConsumeToken(), and CurrentTokenIndex to access the tokenized statement.

    The preprocessor recognizes #pragma and #line directives, ignoring all
    other directives.

Arguments:

    None.

Return Value:

    TRUE if analysis successful.
        - Tokens[] is filled in with the tokenized statement
        - CurrentTokenIndex is set to 0
        - StatmentLineNumber is the line number in the original header file
          corresponding to the first token in the statement
        - SourceFileName[] is the name of the current header file
        - SourceFileLineNumber is the current line number in the header file
    FALSE if end-of-file encountered.

--*/
{
    static char Line[MAX_CHARS_IN_LINE+2];  // a line from the .pp file
    static char *p;                         // ptr into Line[]
    BOOL fParseDone;

    //
    // Clean up after the previous statment and prep for the next statement
    //
    ResetLexer();
    StatementLineNumber = SourceLineNumber;

    //
    // Lex source lines until a complete statement is recognized.  That
    // occurs when a ';' character is found at file-scope.
    //
    do {

        if (p == NULL || *p == '\0') {
            do {
                //
                // Get an entire source line from the file, and set p to
                // point to the first non-space character
                //
                if (feof(fpHeaders)) {
                    return FALSE;
                }

                SourceLineNumber++;
                if (!fgets(Line, MAX_CHARS_IN_LINE, fpHeaders)) {
                    return FALSE;
                }
                for (p = Line; isspace(*p); ++p)
                    ;
            } while (*p == '\0');
        }

        StatementLineNumber = SourceLineNumber;
        p = LexOneLine(p, TRUE, &fParseDone);

    } while (!fParseDone);

    CurrentTokenIndex = 0;
    return TRUE;
}


BOOL
ConsumeDeclSpecOpt(
    BOOL IsFunc,
    BOOL bInitReturns,
    BOOL *pIsDllImport,
    BOOL *pIsGuidDefined,
    GUID *pGuid
    )
/*++

Routine Description:

    Comsumes a __declspec modifier. Returns are unaffected if the corresponding
    __declspec is not found.


    Accepts:
        <not a __declspec keyword>
        __declspec()
        __declspec(naked)           (only if parsing functions)
        __declspec(thread)          (only if parsing data)
        __declspec(novtable)        (only if parsing data)
        __declspec(uuid(GUID))      (only if parsing data)
        __declspec(dllimport)       (both functions and data)
        __declspec(dllexport)       (both functions and data)
        __declspec(align(x))        (only if parsing data)

Arguments:

    IsFunc  -- TRUE if parsing a function declaration, FALSE if parsing
               a data/object declaration.  Affects which keywords are
               allowed within the __declspec.
    bInitReturns -- TRUE if returns should be initialized to FALSE.
    pIsDllImport -- [OPTIONAL OUT] set to TRUE if __declspec(dllimport) found
    pIsGuidDefined -- [OPTIONAL OUT] set to TRUE if __declspec(uuid(GUID)) found
    pGuid -- [OPTIONAL OUT] set to guid of __declspec(uuid(GUID)) if found.

Return Value:

    TRUE if __declspec consumed OK, FALSE if __declspec parse error.

--*/
{

    int OldTokenIndex;
    OldTokenIndex = CurrentTokenIndex;

    if (bInitReturns) {
        if (pIsDllImport != NULL) *pIsDllImport = FALSE;
        if (pIsGuidDefined != NULL) *pIsGuidDefined = FALSE;
    }

    if (CurrentToken()->TokenType != TK_DECLSPEC) {
        // Reject: no __declspec found
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LPAREN) {
        // Reject: __declspec found without '(' following
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_RPAREN) {
        // Accept:  "__declspec ()"
        ConsumeToken();
        return TRUE;
    }
    else if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        goto dofail;
    }

    //handle cases for both data and functions
    if (strcmp(CurrentToken()->Name, "dllimport") == 0) {
        //Parsing: __declspec(dllimport
        if (NULL != pIsDllImport) *pIsDllImport = TRUE;
        ConsumeToken();
    }
    else if (strcmp(CurrentToken()->Name, "dllexport") == 0) {
        //Parsing: __declspec(dllexport
        ConsumeToken();
    }
    else if (strcmp(CurrentToken()->Name, "deprecated") == 0) {
        //Parsing: __declspec(deprecated
        ConsumeToken();
    }
    else if (strcmp(CurrentToken()->Name, "uuid") == 0) {
        GUID gTemp;
        //Parsing: __declspec(uuid
        ConsumeToken();
        if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
        //Parsing: __declspec(uuid(
        ConsumeToken();
        if (CurrentToken()->TokenType != TK_STRING) goto dofail;
        //Parsing: __declspec(uuid(guid
        if(!ConvertStringToGuid(CurrentToken()->Name, &gTemp)) goto dofail;
        ConsumeToken();
        if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
        //Parsing: __declspec(uuid(guid)
        ConsumeToken();
        if (pIsGuidDefined != NULL) *pIsGuidDefined = TRUE;
        if (pGuid != NULL) *pGuid = gTemp;
    }
    else if (IsFunc) {
        if (strcmp(CurrentToken()->Name, "naked") == 0) {
            //Parsing: __declspec(naked
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "noreturn") == 0) {
            //Parsing: __declspec(noreturn
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "address_safe") == 0) {
            //Parsing: __declspec(address_safe
            ConsumeToken();
        }
        else goto dofail; //reject
    }
    else { //data
        if (strcmp(CurrentToken()->Name, "thread") == 0) {
            //Parsing: __declspec(thread
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "novtable") == 0) {
            //Parsing: __declspec(novtable
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "align") == 0) {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
            ConsumeToken();
            expr();
            if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
            ConsumeToken();
        }
        else goto dofail; //reject
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        // Reject: expect ')' after __declspec(extended-decl-modifier)
        goto dofail;
    }
    ConsumeToken();

    // Accept: __declspec(extended-decl-modifier)
    return TRUE;

dofail:
    CurrentTokenIndex = OldTokenIndex;
    return FALSE;
}

PTYPEINFOELEMENT
TypeInfoElementAllocateLink(
    PTYPEINFOELEMENT *ppHead,
    PTYPEINFOELEMENT pThis,
    TYPESINFO *pType
    )
{

/*++

Routine Description:

        Allocates a TYPEINFOELEMENT and linked it to the end of the list.

Arguments:

        ppHead  - [IN/OUT] ptr ptr to the head of the list.
        pThis   - [IN] ptr to the tail of the list.
        pType   - [IN] ptr to the typeinfo to add to the list.

Return Value:

        NON-NULL - New tail.
        NULL     - Failure.
--*/

    PTYPEINFOELEMENT pNew= GenHeapAlloc(sizeof(struct TypeInfoListElement));
    if (NULL == pNew) ExitErrMsg(FALSE, "Out of memory!");
    pNew->pNext = NULL;
    pNew->pTypeInfo = pType;
    if (NULL == pThis) *ppHead = pNew;
    else pThis->pNext = pNew;
    return pNew;
}

BOOL
AddVariable(
    char *Name,
    GUID * pGuid
    )
{
/*++

Routine Description:

        Adds a variable to the list of declared global variabled.

Arguments:

        Name -      [IN] ptr to name of variable to add.
        pGuid -     [OPTIONAL IN] ptr to guid for this variable.

Return Value:

        TRUE - if success.
--*/
    PKNOWNTYPES pKnownTypes;
    int Len;

    if(NULL == Name) return FALSE;

    //Already in the tree
    pKnownTypes = RBFind(VarsList, Name);
    if (NULL != pKnownTypes) {
        //replace guid in list if pGuid != NULL and ignore the duplication
        if (NULL != pGuid) {
            pKnownTypes->Flags |= BTI_HASGUID;
            pKnownTypes->gGuid = *pGuid;
        }
        return TRUE;
    }

    //Create a KNOWNTYPES structure for variable
    Len = sizeof(KNOWNTYPES) + strlen(Name) + 1;
    pKnownTypes = GenHeapAlloc(Len);
    if(NULL == pKnownTypes) return FALSE;

    memset(pKnownTypes, 0, Len);
    pKnownTypes->TypeName = pKnownTypes->Names;
    strcpy(pKnownTypes->Names, Name);
    if(NULL != pGuid) {
        pKnownTypes->Flags |= BTI_HASGUID;
        pKnownTypes->gGuid = *pGuid;
    }

    RBInsert(VarsList, pKnownTypes);
    return TRUE;
}



VOID
UpdateGuids(
    VOID
    )
{
/*++

Routine Description:

        Looks for variables of whose name starts with IID_ and assigned a guid structure.
        The IID_ is striped and the guid of the corresponding struct is updated

Arguments:

        None.

Return Value:

        None.
--*/
    PKNOWNTYPES pThis;
    PKNOWNTYPES pLookup;
    char *LookupName;

    for(pThis = VarsList->pLastNodeInserted; pThis != NULL; pThis = pThis->Next) {

        //test if name has guid associated with it and that it begins with IID_
        if ((pThis->Flags & BTI_HASGUID) &&
            pThis->TypeName[0] == 'I' &&
            pThis->TypeName[1] == 'I' &&
            pThis->TypeName[2] == 'D' &&
            pThis->TypeName[3] == '_' )
        {
            //Attempt to find a structure with the name except the IID_
            LookupName = pThis->TypeName + 4; //skip the IID_
            pLookup = RBFind(StructsList, LookupName);

            if(NULL != pLookup) {

                //if types does not have a GUID defined already, copy guid from here
                if (!(pLookup->Flags & BTI_HASGUID)) {
                    pLookup->Flags |= BTI_HASGUID;
                    pLookup->gGuid = pThis->gGuid;
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\csrss.h ===
#include "stdinc.h"

BOOL InitializeCsrssStress(PCWSTR pcwszTargetDirectory, DWORD dwFlags);
BOOL RequestCsrssStressShutdown();
BOOL WaitForCsrssStressShutdown();
BOOL CsrssStressStartThreads(ULONG &rulThreadsCreated);
BOOL CleanupCsrssTests();

#define CSRSSTEST_FLAG_START_THREADS (0x00000001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\install.h ===
#pragma once

#include "sxsapi.h"

struct INSTALL_THREAD_PROC_DATA
{
    INSTALL_THREAD_PROC_DATA()
        : AfterInstallSleep(0), AfterUninstallSleep(0), Stop(false), Install(false),
          Uninstall(false), InstallationReferencePtr(NULL)
    {
        ZeroMemory(&InstallationReference, sizeof(InstallationReference));
        InstallationReference.cbSize = sizeof(InstallationReference);
        InstallationReference.guidScheme = GUID_NULL;
    }

    CDequeLinkage               Linkage;
    SXS_INSTALL_REFERENCEW      InstallationReference;
    PCSXS_INSTALL_REFERENCEW    InstallationReferencePtr; // NULL if the install omitted any reference
    CTinyStringBuffer           ManifestPath;
    CTinyStringBuffer           Identity;
    CThread                     Thread;
    DWORD                       AfterInstallSleep;
    DWORD                       AfterUninstallSleep;

    CTinyStringBuffer           InstallationReference_Identifier;
    CTinyStringBuffer           InstallationReference_NonCanonicalData;

    bool                        Stop;
    bool                        Install;
    bool                        Uninstall;

private:
    INSTALL_THREAD_PROC_DATA(const INSTALL_THREAD_PROC_DATA&);
    void operator=(const INSTALL_THREAD_PROC_DATA&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\msiinstall.h ===
#pragma once

class STRINGBUFFER_LINKAGE
{
    PRIVATIZE_COPY_CONSTRUCTORS(STRINGBUFFER_LINKAGE);
    
public:
    STRINGBUFFER_LINKAGE() { };
    
    CDequeLinkage       Linkage;
    CSmallStringBuffer   Str;
};


struct MSIINSTALLTEST_THREAD_PROC_DATA
{
    MSIINSTALLTEST_THREAD_PROC_DATA() : Stop(false), Sleep(10)
    {
    }

    CDequeLinkage       Linkage;
    CThread             Thread;

    CSmallStringBuffer   AssemblySourceDirectory;
    CSmallStringBuffer   ManifestFileName;
    CSmallStringBuffer   AssemblyNameFromDarwin;

    CDeque<STRINGBUFFER_LINKAGE, FIELD_OFFSET(STRINGBUFFER_LINKAGE, Linkage)> FileNameOfAssemblyList;

    ULONG               Sleep;
    bool                Stop;

private:
    MSIINSTALLTEST_THREAD_PROC_DATA(const MSIINSTALLTEST_THREAD_PROC_DATA&);
    void operator=(const MSIINSTALLTEST_THREAD_PROC_DATA&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\install.cpp ===
#include "stdinc.h"
#include "st.h"
#include "install.h"

CDeque<INSTALL_THREAD_PROC_DATA, offsetof(INSTALL_THREAD_PROC_DATA, Linkage)> g_Installs;

#define DATA_DIRECTORY_NAME L"assemblies"
#define SLASH_INI_FILE      L"\\assembly.ini"
#define       INI_FILE      L"assembly.ini"

BOOL InitializeInstall()
{
    FN_PROLOG_WIN32

    CFindFile hFind;
    WIN32_FIND_DATAW wfd;
    CStringBuffer TempDirectory;
    CDequeIterator<INSTALL_THREAD_PROC_DATA, offsetof(INSTALL_THREAD_PROC_DATA, Linkage)> iter(&g_Installs);
    CStringBuffer IniFileName;
    CStringBuffer BaseDirectory2;

    if (!BaseDirectory2.Win32Assign(BaseDirectory))
        goto Exit;

    if (!BaseDirectory2.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
        goto Exit;

    if (!TempDirectory.Win32Assign(BaseDirectory2))

    if ((wfd.dwFileAttributes = ::GetFileAttributesW(TempDirectory)) == 0xffffffff
        && (wfd.dwFileAttributes = ::FusionpGetLastWin32Error()) == ERROR_FILE_NOT_FOUND)
    {
        printf("no %ls tests, skipping\n", DATA_DIRECTORY_NAME);
        FN_SUCCESSFUL_EXIT();
    }

    if (!TempDirectory.Win32AppendPathElement(L"*", 1))
        goto Exit;

    hFind = ::FindFirstFileW(TempDirectory, &wfd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to find any files matching \"%ls\"\n", static_cast<PCWSTR>(TempDirectory));
        goto Exit;
    }

    for (;;)
    {
        DWORD dwTemp;
        WCHAR rgwchGuid[64];
        WCHAR rgwchKey[MAX_PATH];
        WCHAR rgwchData[MAX_PATH];
        INSTALL_THREAD_PROC_DATA *pData = NULL;
        struct
        {
            SXS_MANIFEST_INFORMATION_BASIC mib;
            WCHAR rgwchBuffer[65535]; // big frame but what the heck
        } ManifestInformation;

        if (FusionpIsDotOrDotDot(wfd.cFileName))
            goto Skip;

        if (!IniFileName.Win32Assign(BaseDirectory2))
            goto Exit;

        if (!TempDirectory.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
            goto Exit;

        if (!IniFileName.Win32AppendPathElement(wfd.cFileName, wcslen(wfd.cFileName)))
            goto Exit;

        if ((pData = new INSTALL_THREAD_PROC_DATA) == NULL)
        {
            ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
            ::ReportFailure("Failed to allocate INSTALL_THREAD_PROC_DATA\n");
            goto Exit;
        }

        if (!pData->ManifestPath.Win32Append(IniFileName))
            goto Exit;
        if (!pData->ManifestPath.Win32Append(L"\\", 1))
            goto Exit;

        if (!IniFileName.Win32AppendPathElement(INI_FILE, NUMBER_OF(INI_FILE) - 1))
            goto Exit;

        if (!SxStressToolGetStringSetting(0, IniFileName, L"assembly", L"manifest", L"assembly.manifest", pData->ManifestPath, NULL))
            goto Exit;

        if (!::SxsQueryManifestInformation(
                0,
                pData->ManifestPath,
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC,
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME,
                sizeof(ManifestInformation),
                &ManifestInformation,
                NULL))
        {
            ::ReportFailure("Unable to query manifest information for manifest \"%ls\"\n", static_cast<PCWSTR>(pData->ManifestPath));
            goto Exit;
        }

        dwTemp = ::GetPrivateProfileStringW(L"reference", L"guid", L"", rgwchGuid, NUMBER_OF(rgwchGuid), IniFileName);
        if (dwTemp == (NUMBER_OF(rgwchGuid) - 1))
        {
            ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
            ::ReportFailure("Enormous guid in \"%ls\"; section \"reference\", key \"guid\" (does not fit in %Iu characters).\n",
                static_cast<PCWSTR>(IniFileName), NUMBER_OF(rgwchGuid));
            goto Exit;
        }

        dwTemp = ::GetPrivateProfileStringW(L"reference", L"key", L"", rgwchKey, NUMBER_OF(rgwchKey), IniFileName);
        if (dwTemp == (NUMBER_OF(rgwchKey) - 1))
        {
            ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
            ::ReportFailure("Enormous value in \"%ls\"; section \"reference\", key \"key\" (does not fit in %Iu characters).\n",
                static_cast<PCWSTR>(IniFileName), NUMBER_OF(rgwchKey));
            goto Exit;
        }

        dwTemp = ::GetPrivateProfileStringW(L"reference", L"data", L"", rgwchData, NUMBER_OF(rgwchData), IniFileName);
        if (dwTemp == (NUMBER_OF(rgwchData) - 1))
        {
            ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
            ::ReportFailure("Enourmous value in \"%ls\"; section \"reference\", key \"data\" (does not fit in %Iu characters).\n",
                static_cast<PCWSTR>(IniFileName), NUMBER_OF(rgwchData));
            goto Exit;
        }

        pData->AfterInstallSleep = static_cast<DWORD>(::GetPrivateProfileIntW(L"assembly", L"AfterInstallSleepMS", 500, IniFileName));
        pData->AfterUninstallSleep = static_cast<DWORD>(::GetPrivateProfileIntW(L"assembly", L"AfterUninstallSleepMS", 500, IniFileName));
        pData->Install = (::GetPrivateProfileIntW(L"assembly", L"install", 1, IniFileName) != 0);
        pData->Uninstall = (::GetPrivateProfileIntW(L"assembly", L"uninstall", 1, IniFileName) != 0);

        if (!pData->Identity.Win32Assign(ManifestInformation.mib.lpIdentity, wcslen(ManifestInformation.mib.lpIdentity)))
        {
            ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
            ::ReportFailure("Error allocating installation identify string\n");
            goto Exit;
        }

        if (rgwchGuid[0] != L'\0')
        {
            HRESULT hr;

            if (FAILED(hr = ::CLSIDFromString(rgwchGuid, &pData->InstallationReference.guidScheme)))
            {
                ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
                ::ReportFailure("CLSIDFromString() on [reference]/guid value in \"%ls\" failed with HRESULT 0x%08lx\n", static_cast<PCWSTR>(IniFileName), hr);
                goto Exit;
            }
            pData->InstallationReferencePtr = &pData->InstallationReference;
        }

        if (rgwchKey[0] != L'\0')
        {
            if (!pData->InstallationReference_Identifier.Win32Assign(rgwchKey, wcslen(rgwchKey)))
            {
                ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
                ::ReportFailure("Unable to allocate installation reference non-canonical data buffer\n");
                goto Exit;
            }
            pData->InstallationReference.lpIdentifier = pData->InstallationReference_Identifier;
        }

        if (rgwchData[0] != L'\0')
        {
            if (!pData->InstallationReference_NonCanonicalData.Win32Assign(rgwchData, wcslen(rgwchData)))
            {
                ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
                ::ReportFailure("Unable to allocate installation reference non-canonical data buffer\n");
                goto Exit;
            }
            pData->InstallationReference.lpNonCanonicalData = pData->InstallationReference_NonCanonicalData;
        }

        g_Installs.AddToTail(pData);

Skip:
        if (!::FindNextFileW(hFind, &wfd))
        {
            if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
            {
                ::ReportFailure("Error iterating over assemblies\n");
                goto Exit;
            }
            break;
        }
    }
    for (iter.Reset(); iter.More(); iter.Next())
    {
        if (!iter->Thread.Win32CreateThread(&InstallThreadProc, iter.Current()))
        {
            ::ReportFailure("Error launching install thread\n");
            goto Exit;
        }
        TotalThreads += 1;
    }

    FN_EPILOG
}

void RequestShutdownInstallThreads()
{
    CDequeIterator<INSTALL_THREAD_PROC_DATA, offsetof(INSTALL_THREAD_PROC_DATA, Linkage)> iter(&g_Installs);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        iter->Stop = true;
    }
}

void WaitForInstallThreads()
{
    CDequeIterator<INSTALL_THREAD_PROC_DATA, offsetof(INSTALL_THREAD_PROC_DATA, Linkage)> iter(&g_Installs);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        DWORD WaitResult = ::WaitForSingleObject(iter->Thread, INFINITE);
        switch (WaitResult)
        {
        case WAIT_OBJECT_0:
            break;
        case WAIT_FAILED:
            ::ReportFailure("Failed to WaitForSingleObject.\n");
            break;
        default:
            ::FusionpSetLastWin32Error(WaitResult);
            ::ReportFailure("Failed to WaitForSingleObject.\n");
            break;
        }
        iter->Thread.Win32Close();
    }
}

void CleanupInstall()
{
    g_Installs.ClearAndDeleteAll();
}

DWORD
WINAPI
InstallThreadProc(
    LPVOID pvData
    )
{
    INSTALL_THREAD_PROC_DATA *pData = reinterpret_cast<INSTALL_THREAD_PROC_DATA *>(pvData);
    DWORD dwReturnValue = ERROR_INTERNAL_ERROR;
    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    SXS_UNINSTALLW Uninstall = { sizeof(SXS_UNINSTALLW) };
    DWORD WaitResult = 0;

    if ((Install.lpReference = pData->InstallationReferencePtr) != NULL)
        Install.dwFlags |= SXS_INSTALL_FLAG_REFERENCE_VALID;

    Install.lpManifestPath = pData->ManifestPath;

    Uninstall.lpAssemblyIdentity = pData->Identity;
    if ((Uninstall.lpInstallReference = pData->InstallationReferencePtr) != NULL)
        Uninstall.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;

    InterlockedIncrement(&ThreadsWaiting);
    WaitResult = WaitForSingleObject(ResumeThreadsEvent, INFINITE);
    switch (WaitResult)
    {
    case WAIT_OBJECT_0:
        break;
    case WAIT_FAILED:
        dwReturnValue = ::FusionpGetLastWin32Error();
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    default:
        dwReturnValue = WaitResult;
        ::FusionpSetLastWin32Error(WaitResult);
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    }

    for (;;)
    {
        DWORD dwUninstallDisposition;

        if (pData->Install)
        {
            if (!::SxsInstallW(&Install))
            {
                dwReturnValue = ::FusionpGetLastWin32Error();
                ::ReportFailure("Failed to install \"%ls\"\n", static_cast<PCWSTR>(pData->ManifestPath));
                goto Exit;
            }

            printf("[%lx.%lx] Manifest \"%ls\" installed\n",
                SxStressToolGetCurrentProcessId(),
                SxStressToolGetCurrentThreadId(),
                static_cast<PCWSTR>(pData->ManifestPath)
                );

            ::WaitForSingleObject(StopEvent, pData->AfterInstallSleep);
        }

        if (pData->Stop)
            break;

        if (pData->Uninstall)
        {
            if (!::SxsUninstallW(&Uninstall, &dwUninstallDisposition))
            {
                dwReturnValue = ::FusionpGetLastWin32Error();
                ::ReportFailure("Failed to uninstall \"%ls\"\n", static_cast<PCWSTR>(pData->ManifestPath));
                goto Exit;
            }

            printf("[%lx.%lx] Manifest \"%ls\" uninstalled; disposition = %lu\n",
                SxStressToolGetCurrentProcessId(),
                SxStressToolGetCurrentThreadId(),
                static_cast<PCWSTR>(pData->ManifestPath),
                dwUninstallDisposition
                );

            ::WaitForSingleObject(StopEvent, pData->AfterUninstallSleep);
        }
        if (pData->Stop)
            break;
    }

    dwReturnValue = ERROR_SUCCESS;
Exit:
    printf("[%lx.%lx] install(%ls) thread exiting %lu\n",
        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(), static_cast<PCWSTR>(pData->ManifestPath), dwReturnValue);
    return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\msiinstall.cpp ===
#include "stdinc.h"
#include "st.h"
#include "msiinstall.h"

CDeque<MSIINSTALLTEST_THREAD_PROC_DATA, offsetof(MSIINSTALLTEST_THREAD_PROC_DATA, Linkage)> g_MSIInstallTest;

#define DATA_DIRECTORY_NAME             L"msiinstall"
#define SLASH_DATA_DIRECTORY_SLASH_STAR L"\\" DATA_DIRECTORY_NAME L"\\*"
#define SLASH_DATA_DIRECTORY_SLASH      L"\\" DATA_DIRECTORY_NAME L"\\"
#define INI_FILE                        L"msiinstall.ini"
#define SLASH_INI_FILE                  L"\\msiinstall.ini"

BOOL InitializeMSIInstallTest()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CFindFile hFind;
    WIN32_FIND_DATAW wfd;
    CStringBuffer TempDirectory;
    CDequeIterator<MSIINSTALLTEST_THREAD_PROC_DATA, offsetof(MSIINSTALLTEST_THREAD_PROC_DATA, Linkage)> iter(&g_MSIInstallTest);
    CStringBuffer IniFilePath;
    WCHAR buf[MAX_PATH];
    DWORD bufSize = NUMBER_OF(buf);
    WCHAR FileKey[10]; // at most, there are 10^10 files in the assembly, including manifest
    DWORD rSize;
    STRINGBUFFER_LINKAGE * pTinyStringBuffer = NULL;
    MSIINSTALLTEST_THREAD_PROC_DATA *pData = NULL;


    if (!TempDirectory.Win32Assign(BaseDirectory))
        goto Exit;

    if (!TempDirectory.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
        goto Exit;

    if ((wfd.dwFileAttributes = ::GetFileAttributesW(TempDirectory)) == 0xffffffff
        && (wfd.dwFileAttributes = ::FusionpGetLastWin32Error()) == ERROR_FILE_NOT_FOUND)
    {
        printf("no %ls tests, skipping\n", DATA_DIRECTORY_NAME);
        FN_SUCCESSFUL_EXIT();
    }

    if (!TempDirectory.Win32AppendPathElement(L"*", 1))
        goto Exit;

    hFind = ::FindFirstFileW(TempDirectory, &wfd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to find any files matching \"%ls\"\n", static_cast<PCWSTR>(TempDirectory));
        goto Exit;
    }
    
    for (;;)
    {
        CSmallStringBuffer TempString;
        CSmallStringBuffer BaseDirectory2;

        if (FusionpIsDotOrDotDot(wfd.cFileName))
              goto Skip;

        if (!BaseDirectory2.Win32Assign(BaseDirectory))
            goto Exit;

        if (!BaseDirectory2.Win32AppendPathElement(DATA_DIRECTORY_NAME, NUMBER_OF(DATA_DIRECTORY_NAME) - 1))
            goto Exit;

        if (!BaseDirectory2.Win32AppendPathElement(wfd.cFileName, wcslen(wfd.cFileName)))
            goto Exit;

        if ((pData = new MSIINSTALLTEST_THREAD_PROC_DATA) == NULL)
        {
            ::FusionpSetLastWin32Error(ERROR_OUTOFMEMORY);
            ::ReportFailure("Failed to allocate MSIINSTALLTEST_THREAD_PROC_DATA\n");
            goto Exit;
        }

        if (!IniFilePath.Win32Assign(BaseDirectory2))
            goto Exit;
        if (!IniFilePath.Win32AppendPathElement(INI_FILE, NUMBER_OF(INI_FILE) - 1))
            goto Exit;

        if (GetFileAttributesW(IniFilePath) == DWORD(-1))
        {
            ::ReportFailure("Failed to find msiinstall.ini from %s.\n", IniFilePath);
            goto Exit;
        }

        // 
        // get manifest filename
        //
        rSize = GetPrivateProfileStringW(L"general", L"manifest", L"", buf, bufSize, IniFilePath);
        if ((rSize == bufSize - 1) || (rSize == 0))
        {
            ::ReportFailure("manifest filename in %s is erroneous, either too long or empty\n", IniFilePath);
            goto Exit;
        }
        IFW32FALSE_EXIT(pData->ManifestFileName.Win32Assign(buf, rSize));

        // 
        // get AssemblyNamefromDarwin
        //
        rSize = GetPrivateProfileStringW(L"general", L"AssemblyNameFromDarwin", L"", buf, bufSize, IniFilePath);
        if ((rSize == bufSize - 1) || (rSize == 0))
        {
            ::ReportFailure("assemblyname from darwin in %s is erroneous, either too long or empty\n", IniFilePath);
            goto Exit;
        }
        IFW32FALSE_EXIT(pData->AssemblyNameFromDarwin.Win32Assign(buf, rSize));

        //
        // get the SourceFile directory from ini or use the current directory
        //
        rSize = GetPrivateProfileStringW(L"general", L"AssemblySourceFileDirectory", L"", buf, bufSize, IniFilePath);
        if (rSize == bufSize - 1)
            goto Exit;
        if (rSize != 0)
            IFW32FALSE_EXIT(pData->AssemblySourceDirectory.Win32Assign(buf, rSize));
        else
            IFW32FALSE_EXIT(pData->AssemblySourceDirectory.Win32Assign(BaseDirectory2));

        for (DWORD i=0;;i++)
        {
            swprintf(FileKey, L"%1d", i); // make FileKey in WSTR
            rSize = GetPrivateProfileStringW(L"files", FileKey, L"", buf, bufSize, IniFilePath);
            if (rSize == bufSize - 1)// the value string in .ini is too long 
                goto Exit;
            if ( rSize == 0 ) // get all
                break;

            pTinyStringBuffer = new STRINGBUFFER_LINKAGE;
            if (pTinyStringBuffer  == NULL)
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }
                
            IFW32FALSE_EXIT(pTinyStringBuffer->Str.Win32Assign(buf, rSize));
            pData->FileNameOfAssemblyList.AddToTail(pTinyStringBuffer);
            pTinyStringBuffer = NULL;
        }
        
        g_MSIInstallTest.AddToTail(pData);
        pData = NULL;

Skip:
        if (!::FindNextFileW(hFind, &wfd))
        {
            if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
            {
                ::ReportFailure("Error iterating over assemblies\n");
                goto Exit;
            }
            break;
        }
    }

    for (iter.Reset(); iter.More(); iter.Next())
    {
        if (!iter->Thread.Win32CreateThread(&MSIInstallTestThreadProc, iter.Current()))
        {
            ::ReportFailure("Error launching install thread\n");
            goto Exit;
        }
        TotalThreads += 1;
    }

    fSuccess = TRUE;
Exit:
    if (pData)
        delete pData;

    if (pTinyStringBuffer != NULL)
        delete pTinyStringBuffer;

    return fSuccess;
}

void RequestShutdownMSIInstallTestThreads()
{
    CDequeIterator<MSIINSTALLTEST_THREAD_PROC_DATA, offsetof(MSIINSTALLTEST_THREAD_PROC_DATA, Linkage)> iter(&g_MSIInstallTest);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        iter->Stop = true;
    }

}
void WaitForMSIInstallTestThreads()
{
    CDequeIterator<MSIINSTALLTEST_THREAD_PROC_DATA, offsetof(MSIINSTALLTEST_THREAD_PROC_DATA, Linkage)> iter(&g_MSIInstallTest);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        DWORD WaitResult = ::WaitForSingleObject(iter->Thread, INFINITE);
        switch (WaitResult)
        {
        case WAIT_OBJECT_0:
            break;
        case WAIT_FAILED:
            ::ReportFailure("MSIInstall :: Failed to WaitForSingleObject.\n");
            break;
        default:
            ::FusionpSetLastWin32Error(WaitResult);
            ::ReportFailure("MSIInstall :: Failed to WaitForSingleObject.\n");
            break;
        }
        iter->Thread.Win32Close();
    }
}

void CleanupMSIInstallTest()
{
    g_MSIInstallTest.ClearAndDeleteAll();
}

HRESULT Helper_WriteStream(CSmallStringBuffer * pFileNameBuf,
                           IStream *pStream)
{
    HRESULT     hr          = NOERROR;
    LPBYTE      pBuf[0x4000];
    DWORD       cbBuf       = 0x4000;
    DWORD       dwWritten   = 0;
    DWORD       cbRead      = 0;
    HANDLE      hf          = INVALID_HANDLE_VALUE;

    hf = ::CreateFileW(static_cast<PCWSTR>(*pFileNameBuf), GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hf == INVALID_HANDLE_VALUE){
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Exit;
    }

    while (::ReadFile(hf, pBuf, cbBuf, &cbRead, NULL) && cbRead){
        hr = pStream->Write(pBuf, cbRead, &dwWritten);
        if (FAILED(hr))
            goto Exit;
    }

    if (! SUCCEEDED(hr = pStream->Commit(0)))
        goto Exit;

    CloseHandle(hf);

Exit:
    return hr;
}

DWORD
WINAPI
MSIInstallTestThreadProc(
    LPVOID pvData
    )
{
    DWORD dwReturnValue = ERROR_INTERNAL_ERROR;
    DWORD WaitResult = 0;
    MSIINSTALLTEST_THREAD_PROC_DATA *pData = reinterpret_cast<MSIINSTALLTEST_THREAD_PROC_DATA*>(pvData);
    IAssemblyCache * pAsmCache = NULL;
    SIZE_T nPathLen = pData->AssemblySourceDirectory.Cch();
    IAssemblyCacheItem * pCacheItem = NULL;
    IStream * pStream = NULL;
    IAssemblyName * pAssemblyName = NULL;
    WCHAR buf[MAX_PATH];
    DWORD bufSize = MAX_PATH;
    
    
    HRESULT hr;

    InterlockedIncrement(&ThreadsWaiting);
    WaitResult = WaitForSingleObject(ResumeThreadsEvent, INFINITE);
    switch (WaitResult)
    {
    case WAIT_OBJECT_0:
        break;
    case WAIT_FAILED:
        dwReturnValue = ::FusionpGetLastWin32Error();
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    default:
        dwReturnValue = WaitResult;
        ::FusionpSetLastWin32Error(WaitResult);
        ::ReportFailure("Failed to WaitForSingleObject.\n");
        goto Exit;
    }


    if (CreateAssemblyCache(&pAsmCache, 0) != S_OK)
    {
        ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateAssemblyCache with gle %lu \n",
                    SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                    pData->AssemblySourceDirectory,
                    pData->ManifestFileName,
                    ::FusionpGetLastWin32Error());
        goto Exit; 
    }

    while (!pData->Stop)
    {
        //Create AssemblyCache and AssemblyCacheItem        
        if ((hr = pAsmCache->CreateAssemblyCacheItem(0, NULL, &pCacheItem, NULL)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateAssemblyCacheItem with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }

        //
        // create manifests for assembly item
        //
        if ((hr = pCacheItem->CreateStream(0, pData->ManifestFileName, STREAM_FORMAT_WIN32_MANIFEST, 0, &pStream, NULL)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateStream for manifest with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        ::FusionpGetLastWin32Error());
            goto Exit; 

        }
        pData->AssemblySourceDirectory.Left(nPathLen);

        if (! pData->AssemblySourceDirectory.Win32AppendPathElement(pData->ManifestFileName))
        {
            goto Exit;
        }

        if ( (hr = Helper_WriteStream(&pData->AssemblySourceDirectory, pStream)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed WriteStream for manifest with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }

        pStream->Release();

        CDequeIterator<STRINGBUFFER_LINKAGE, offsetof(STRINGBUFFER_LINKAGE, Linkage)> iter(&pData->FileNameOfAssemblyList);
        for (iter.Reset(); iter.More(); iter.Next())
        {
            if ((hr = pCacheItem->CreateStream(0, iter.Current()->Str, STREAM_FORMAT_WIN32_MODULE, 0, &pStream, NULL)) != S_OK)
            {
                ::FusionpSetLastErrorFromHRESULT(hr);
                ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateStream for module \"%ls\" with gle %lu \n",
                            SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                            pData->AssemblySourceDirectory,
                            pData->ManifestFileName,
                            iter->Str,
                            ::FusionpGetLastWin32Error());
                goto Exit; 
            }
            pData->AssemblySourceDirectory.Left(nPathLen);
            if (! pData->AssemblySourceDirectory.Win32AppendPathElement(iter.Current()->Str))
                goto Exit;
            if ( (hr = Helper_WriteStream(&pData->AssemblySourceDirectory, pStream)) != S_OK)
            {
                ::FusionpSetLastErrorFromHRESULT(hr);
                ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateStream for module \"%ls\" with gle %lu \n",
                            SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                            pData->AssemblySourceDirectory,
                            pData->ManifestFileName,
                            iter->Str,
                            ::FusionpGetLastWin32Error());
                goto Exit; 

            }
            pStream->Release();
        }

        if ((hr = pCacheItem->Commit(0, NULL)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed Commit AssemblyCacheItem with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }


        // uninstall the same assembly using CAssemblyName and CAssemblyCache->UninstallAssembly

        if ( (hr = CreateAssemblyNameObject(&pAssemblyName, pData->AssemblyNameFromDarwin, CANOF_PARSE_DISPLAY_NAME,NULL)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed CreateAssemblyName for %s with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        pData->AssemblyNameFromDarwin,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }

        if ( (hr = pAssemblyName->GetDisplayName(buf, &bufSize, 0)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) failed IsAssemblyInstalled for %s with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        pData->AssemblyNameFromDarwin,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }

        if ( wcscmp(pData->AssemblyNameFromDarwin, buf) != 0)
        {
            goto Exit;
        }


        if ((hr = pAsmCache->UninstallAssembly(0, buf, NULL, NULL)) != S_OK)
        {
            ::FusionpSetLastErrorFromHRESULT(hr);
            ::ReportFailure("[%lx.%lx] MSIInstall(\"%ls\", 0x%lx) Cache->UninstallAssemblyfailed for %s with gle %lu \n",
                        SxStressToolGetCurrentProcessId(), SxStressToolGetCurrentThreadId(),
                        pData->AssemblySourceDirectory,
                        pData->ManifestFileName,
                        buf,
                        ::FusionpGetLastWin32Error());
            goto Exit; 
        }

        ::WaitForSingleObject(StopEvent, pData->Sleep);
    }
    
    dwReturnValue = ERROR_SUCCESS;
    goto Cleanup;
Exit:
    dwReturnValue = ::FusionpGetLastWin32Error();    

Cleanup: 
    if (pAsmCache)
        pAsmCache->Release();

    if (pCacheItem)
        pCacheItem->Release();

    if (pStream)
        pStream->Release();

    if (pAssemblyName)
        pAssemblyName->Release();   
    
    return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\lib.cpp ===
#include "stdinc.h"
#include "st.h"
#include "filestream.cpp"
#include "cresourcestream.cpp"
#include "cmemorystream.cpp"


BOOL
WaitForThreadResumeEvent()
{
    BOOL fResult = FALSE;
    InterlockedIncrement(&ThreadsWaiting);
    const DWORD dwWaitResult = WaitForSingleObject(ResumeThreadsEvent, INFINITE);
    switch (dwWaitResult)
    {
    case WAIT_OBJECT_0:
        fResult = true;
        break;
    default:
        ::FusionpSetLastWin32Error(dwWaitResult);
    case WAIT_FAILED:
        ::ReportFailure("Failed WaitForStartingEvent.WaitForSingleObject");
    }
    return fResult;
}

LONG StringToNumber(PCWSTR s)
{
    int Base = 0;
    if (s == NULL || s[0] == 0)
        return 0;
    if (s[0] == '#')
    {
        Base = 10;
        ++s;
    }
    return wcstol(s, NULL, Base);
}


PCWSTR StringToResourceString(PCWSTR s)
{
    if (s == NULL || s[0] == 0)
        return 0;
    if (s[0] == '#')
    {
        return reinterpret_cast<PCWSTR>(static_cast<ULONG_PTR>(StringToNumber(s)));
    }
    else
    {
        return s;
    }
}

BOOL
SxStressToolExtractFlagsFromString(
    PCFUSION_FLAG_FORMAT_MAP_ENTRY  FlagData,
    ULONG                           NumberOfFlagData,
    PCWSTR                          FlagString,
    ULONG&                          FlagBits
    )
{
    BOOL Success = FALSE;
    SxStressToolUnicodeString_t s(FlagString);
    SxStressToolUnicodeString_t delim(L" ,;\t+|"); // it'd be nice to support & and ~ ...
    std::vector<SxStressToolUnicodeString_t> v;

    //
    // first see if wcstoul could consume it all (this is a little sloppy)
    //
    if (FlagString[0] == '#')
        ++FlagString;
    if (wcsspn(FlagString, L" \tx-+0123456789") == wcslen(FlagString))
    {
        FlagBits |= wcstoul(FlagString, NULL, 0);
        Success = TRUE;
        goto Exit;
    }

    SxStressToolSplitString(s, delim, v);

    for (SIZE_T i = 0 ; i != v.size() ; ++i)
    {
        PCWSTR begin = v[i].begin();
        const PCWSTR end = v[i].end();
        SSIZE_T length = (end - begin);

        if (begin[0] == '#')
        {
            ++begin;
            --length;
        }
        if (StringSpan(begin, end, L" \tx-+0123456789") == length)
        {
            FlagBits |= wcstoul(FlagString, NULL, 0);
            continue;
        }
        for (SIZE_T j = 0 ; j != NumberOfFlagData ; ++j)
        {
            if (FusionpCompareStrings(
                FlagData[j].m_pszString,
                FlagData[j].m_cchString,
                begin,
                length,
                true
                ) == 0)
            {
                FlagBits |= FlagData[j].m_dwFlagMask;
                break;
            }
            if (FusionpCompareStrings(
                FlagData[j].m_pszShortString,
                FlagData[j].m_cchShortString,
                begin,
                length,
                true
                ) == 0)
            {
                FlagBits |= FlagData[j].m_dwFlagMask;
                break;
            }
        }
    }
    Success = TRUE;
Exit:
    return Success;
}

BOOL
pSxStressToolGetStringSetting(
    ULONG   FutureFlags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    PCWSTR  Default,
    PWSTR   DumbBuffer,
    SIZE_T  DumbBufferSize
    )
{
    BOOL Success = FALSE;

    SIZE_T dwTemp = ::GetPrivateProfileStringW(Section, Key, Default, DumbBuffer, static_cast<ULONG>(DumbBufferSize), IniFilePath);
    if (dwTemp == (DumbBufferSize - 1))
    {
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        ::ReportFailure("Too large setting in \"%ls\"; section \"%ls\", key \"%ls\" (does not fit in %Iu characters).\n",
            IniFilePath, Section, Key, DumbBufferSize);
        goto Exit;
    }
    Success = TRUE;
Exit:
    return Success;
}

BOOL
SxStressToolGetStringSetting(
    ULONG  FutureFlags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    PCWSTR  Default,
    CBaseStringBuffer& Buffer,
    PCWSTR* DumbPointer
    )
{
    BOOL Success = FALSE;
    WCHAR DumbBuffer[MAX_PATH];

    if (DumbPointer != NULL)
        *DumbPointer = NULL;

    if (!pSxStressToolGetStringSetting(0, IniFilePath, Section, Key, Default, DumbBuffer, NUMBER_OF(DumbBuffer)))
        goto Exit;
    if (!Buffer.Win32Append(DumbBuffer, ::wcslen(DumbBuffer)))
        goto Exit;
    if (DumbPointer != NULL)
        *DumbPointer = Buffer;

    Success = TRUE;
Exit:
    return Success;
}

BOOL
SxStressToolGetFlagSetting(
    ULONG  FutureFlags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    ULONG&  Flags,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY  FlagData,
    ULONG                           NumberOfFlagData
    )
{
    BOOL Success = FALSE;
    WCHAR DumbBuffer[MAX_PATH];

    if (!pSxStressToolGetStringSetting(0, IniFilePath, Section, Key, L"", DumbBuffer, NUMBER_OF(DumbBuffer)))
        goto Exit;

    if (DumbBuffer[0] != 0)
    {
        if (!SxStressToolExtractFlagsFromString(FlagData, NumberOfFlagData, DumbBuffer, Flags))
            goto Exit;
    }

    Success = TRUE;
Exit:
    return Success;
}

BOOL
SxStressToolGetResourceIdSetting(
    ULONG   FutureFlags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    CBaseStringBuffer& Buffer,
    PCWSTR* DumbPointer
    )
{
    BOOL Success = FALSE;
    WCHAR DumbBuffer[MAX_PATH];

    *DumbPointer = NULL;

    if (!pSxStressToolGetStringSetting(0, IniFilePath, Section, Key, L"", DumbBuffer, NUMBER_OF(DumbBuffer)))
        goto Exit;

    if (DumbBuffer[0] != 0)
    {
        if (!Buffer.Win32Append(DumbBuffer, ::wcslen(DumbBuffer)))
            goto Exit;
        *DumbPointer = StringToResourceString(DumbBuffer);
    }

    Success = TRUE;
Exit:
    return Success;
}


BOOL
SxspIsPrivateProfileStringEqual(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    PCWSTR pcwszTestValue,
    BOOL &rfIsEqual,
    PCWSTR pcwszFileName
    )
{
    FN_PROLOG_WIN32
    CSmallStringBuffer buffTemp;
    CSmallStringBuffer buffFakeDefault;

    rfIsEqual = FALSE;

    IFW32FALSE_EXIT(buffFakeDefault.Win32Assign(pcwszTestValue, ::wcslen(pcwszTestValue)));
    IFW32FALSE_EXIT(buffFakeDefault.Win32AppendPathElement(L"2", 1));
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(
        pcwszSection,
        pcwszKeyName,
        buffFakeDefault,
        buffTemp,
        pcwszFileName));

    //
    // Did we get back something other than the "fake" default?
    //
    if (FusionpCompareStrings(buffTemp, buffFakeDefault, TRUE) != 0)
        rfIsEqual = (FusionpStrCmpI(buffTemp, pcwszTestValue) == 0);
        
    FN_EPILOG
}


BOOL
SxspGetPrivateProfileStringW(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    PCWSTR pcwszDefault,
    OUT CBaseStringBuffer &buffTarget,
    PCWSTR pcwszFileName)
{
    FN_PROLOG_WIN32

    buffTarget.Clear();

    do
    {
        CStringBufferAccessor sba(&buffTarget);
        const DWORD dwNeededSize = ::GetPrivateProfileStringW(
            pcwszSection,
            pcwszKeyName,
            pcwszDefault,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsINT(),
            pcwszFileName);

        if ( dwNeededSize == 0 )
        {
            if ( ::FusionpGetLastWin32Error() != ERROR_SUCCESS )
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetPrivateProfileStringW, ::FusionpGetLastWin32Error());
            else
                break;
        }
        else if ( dwNeededSize < sba.GetBufferCch() )
        {
            break;
        }
        else
        {
            sba.Detach();
            IFW32FALSE_EXIT(buffTarget.Win32ResizeBuffer( dwNeededSize + 1, eDoNotPreserveBufferContents));
        }
    }
    while ( true );
    
    FN_EPILOG
}

BOOL
SxspGetPrivateProfileIntW(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    INT defaultValue,
    INT &Target,
    PCWSTR pcwszFilename)
{

    FN_PROLOG_WIN32
    Target = GetPrivateProfileIntW(pcwszSection, pcwszKeyName, defaultValue, pcwszFilename);
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\st.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>
#pragma warning(disable: 4663)
#include <string>
#include <deque>
#include <vector>
#pragma warning(pop)
#include <algorithm>

#include "sxsapi.h"
#include "fusionlastwin32error.h"
#include "fusionbuffer.h"

#define SxStressToolGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define SxStressToolGetCurrentThreadId()  (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))

//
// Conserve memory.
//
//typedef CGenericStringBuffer<1, CUnicodeCharTraits> CTinyUnicodeStringBuffer;
typedef CTinyUnicodeStringBuffer CTinyStringBuffer;

#include "fusiontrace.h"
#include "fusiondeque.h"

extern CEvent ResumeThreadsEvent;
extern CEvent StopEvent;
extern LONG ThreadsWaiting;
extern LONG TotalThreads;
extern CStringBuffer BaseDirectory;

void ReportFailure(const char szFormat[], ...);

BOOL InitializeMSIInstallTest();
void WaitForMSIInstallTestThreads();
void CleanupMSIInstallTest();
void RequestShutdownMSIInstallTestThreads();
DWORD WINAPI MSIInstallTestThreadProc(LPVOID);

BOOL InitializeInstall();
void WaitForInstallThreads();
void CleanupInstall();
DWORD WINAPI InstallThreadProc(LPVOID);

BOOL InitializeCreateActCtx();
void WaitForCreateActCtxThreads();
void CleanupCreateActCtx();
DWORD WINAPI CreateActCtxThreadProc(LPVOID);

DWORD
WINAPI
InstallThreadProc(
    LPVOID pvData
    );

void RequestShutdownInstallThreads();
void RequestShutdownCreateActCtxThreads();

//
// std::string has specialized find_first_not_of that uses integral positions,
// and globally there is only find_first_of. Here we provide the expected
// iterator-based find_first_not_of, based on the std::string code.
//
// Find the first occurence in [first1, last1) of an element in [first2, last).
//
// eg:
//   find_first_not_of("abc":"12;3", ":;");
//                      ^
//   find_first_not_of(":12;3", ":;");
//                       ^
//   find_first_not_of("3", ":;");
//                      ^
//
template <typename Iterator>
inline Iterator FindFirstNotOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    if (first2 == last2)
        return last1;
    for ( ; first1 != last1 ; ++first1)
    {
        if (std::find(first2, last2, *first1) == last2)
        {
            break;
        }
    }
    return first1;
}

template <typename Iterator>
inline Iterator FindFirstOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    return std::find_first_of(first1, last1, first2, last2);
}

class SxStressToolUnicodeString_t: public UNICODE_STRING
{
public:
    typedef PCWSTR const_iterator;
    typedef PWSTR       iterator;

    SxStressToolUnicodeString_t(PCWSTR s) { RtlInitUnicodeString(this, s); }

    SxStressToolUnicodeString_t(PCWSTR s, PCWSTR t)
    {
        this->Buffer = const_cast<PWSTR>(s);
        const USHORT Length = static_cast<USHORT>(t - s) * sizeof(WCHAR);
        this->Length = Length;
        this->MaximumLength = Length;
    }

    SIZE_T size() const { return Length / sizeof(Buffer[0]); }
    SIZE_T length() const { return size(); }
    PCWSTR begin() const { return Buffer; }
    PCWSTR end() const { return begin() + size(); }
    PWSTR begin() { return Buffer; }
    PWSTR end() { return begin() + size(); }
};

template <typename String_t>
inline void SxStressToolSplitString(
    const String_t& String,
    const String_t& Delim, 
    std::vector<String_t>& Fields
    )
{
    String_t::const_iterator FieldBegin;
    String_t::const_iterator FieldEnd = String.begin();

    while ((FieldBegin = FindFirstNotOf(FieldEnd, String.end(), Delim.begin(), Delim.end())) != String.end())
    {
        FieldEnd = FindFirstOf(FieldBegin, String.end(), Delim.begin(), Delim.end());
        Fields.push_back(String_t(FieldBegin, FieldEnd));
    }
}

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;
typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;

BOOL
SxStressToolExtractFlagsFromString(
    ULONG                           Flags,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY  FlagData,
    ULONG                           NumberOfFlagData,
    PCWSTR                          FlagString,
    ULONG&                          FlagOut
    );

LONG StringToNumber(PCWSTR s);
PCWSTR StringToResourceString(PCWSTR s);

BOOL
SxStressToolGetStringSetting(
    ULONG               Flags,
    PCWSTR              IniFilePath,
    PCWSTR              Section,
    PCWSTR              Key,
    PCWSTR              Default,
    CBaseStringBuffer&  Buffer,
    PCWSTR*             DumbPointer OPTIONAL = 0
    );

BOOL
SxStressToolGetFlagSetting(
    ULONG   Flags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    ULONG&  FlagsOut,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY  FlagData,
    ULONG                           NumberOfFlagData
    );

BOOL
SxStressToolGetResourceIdSetting(
    ULONG   FutureFlags,
    PCWSTR  IniFilePath,
    PCWSTR  Section,
    PCWSTR  Key,
    CBaseStringBuffer& Buffer,
    PCWSTR* DumbPointer
    );

BOOL WaitForThreadResumeEvent();

BOOL
SxspGetPrivateProfileIntW(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    INT defaultValue,
    INT &Target,
    PCWSTR pcwszFilename
    );
    
BOOL
SxspGetPrivateProfileStringW(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    PCWSTR pcwszDefault,
    OUT CBaseStringBuffer &buffTarget,
    PCWSTR pcwszFileName
    );
    
BOOL
SxspIsPrivateProfileStringEqual(
    PCWSTR pcwszSection,
    PCWSTR pcwszKeyName,
    PCWSTR pcwszTestValue,
    BOOL &rfIsEqual,
    PCWSTR pcwszFileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\stdinc.h ===
#include "st.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\stressharness.cpp ===
#include "stdinc.h"
#include "st.h"
#include "stressharness.h"

#define STRESSJOB_INI_SECTION_NAME      (L"[StressJob]")
#define STRESSJOB_INI_KEY_SLEEPTIME     (L"SleepBetweenRuns")
#define STRESSJOB_DEFAULT_SLEEP_TIME    (50)

CStressJobEntry::CStressJobEntry( CStressJobManager *pManager )
{
    this->m_dwSleepBetweenRuns = STRESSJOB_DEFAULT_SLEEP_TIME;
    this->m_fStop = false;
    this->m_pManager = pManager;
    this->m_ulFailures = this->m_ulRuns = 0;    
}

BOOL
CStressJobEntry::LoadFromSettingsFile(
    PCWSTR pcwszFileName
    )
{
    FN_PROLOG_WIN32

    //
    // Right now, we only have one setting, in the [StressJob] section, the
    // time to sleep between runs.  If it's not present, it defaults to
    // 50ms.
    //
    INT ulSleepTime = 0;
    
    IFW32FALSE_EXIT(SxspGetPrivateProfileIntW(
        STRESSJOB_INI_SECTION_NAME,
        STRESSJOB_INI_KEY_SLEEPTIME,
        STRESSJOB_DEFAULT_SLEEP_TIME,
        ulSleepTime,
        pcwszFileName));
    this->m_dwSleepBetweenRuns = static_cast<DWORD>(ulSleepTime);
    
    FN_EPILOG
    
}


//
// DNGN
//
CStressJobEntry::~CStressJobEntry()
{
    FN_TRACE();
    ASSERT(this->m_hThread == CThread::GetInvalidValue());    
}


BOOL
CStressJobEntry::Stop( BOOL fWaitForCompletion )
{
    FN_PROLOG_WIN32
    this->m_fStop = true;
    if ( fWaitForCompletion )
        IFW32FALSE_EXIT(this->WaitForCompletion());
    FN_EPILOG
}



BOOL
CStressJobEntry::WaitForCompletion()
{
    FN_PROLOG_WIN32
    if ( m_hThread != m_hThread.GetInvalidValue() )
    {
        IFW32FALSE_EXIT(WaitForSingleObject(m_hThread, INFINITE) == WAIT_OBJECT_0);
    }
    FN_EPILOG
}



BOOL
CStressJobEntry::Cleanup()
{
    FN_PROLOG_WIN32
    if ( m_hThread != m_hThread.GetInvalidValue() )
    {
        m_hThread.Win32Close();
        m_hThread = m_hThread.GetInvalidValue();
    }
    FN_EPILOG
}



BOOL
CStressJobEntry::WaitForStartingGun()
{
    FN_PROLOG_WIN32
    ASSERT( m_pManager != NULL );
    IFW32FALSE_EXIT(m_pManager->SignalAnotherJobReady());
    IFW32FALSE_EXIT(m_pManager->WaitForStartEvent());
    IFW32FALSE_EXIT(m_pManager->SignalThreadWorking());
    FN_EPILOG
}





DWORD
CStressJobEntry::ThreadProc( PVOID pv )
{
    FN_PROLOG_WIN32
    CStressJobEntry *pEntry = reinterpret_cast<CStressJobEntry*>(pv);
    PARAMETER_CHECK(pEntry != NULL);
    return pEntry->InternalThreadProc();
    FN_EPILOG
}





DWORD 
CStressJobEntry::InternalThreadProc()
{
    if (!this->WaitForStartingGun())
    {
        const DWORD dwError = ::FusionpGetLastWin32Error();
        ::ReportFailure("%ls:%ls failed waiting on starting event, error %ld",
            static_cast<PCWSTR>(m_pManager->GetGroupName()),
            static_cast<PCWSTR>(this->m_buffTestName),
            dwError);
        return 0;
    }

    if (!this->SetupSelfForRun())
    {
        const DWORD dwError = ::FusionpGetLastWin32Error();
        ReportFailure("%ls: test %ls failed to set itself up, error %ld",
            static_cast<PCWSTR>(m_pManager->GetGroupName()),
            static_cast<PCWSTR>(this->m_buffTestName),
            dwError);
    }
    else
    {

        while ( !m_fStop )
        {
            bool fResult;
            if ( RunTest( fResult ) )
            {
                const DWORD dwError = ::FusionpGetLastWin32Error();
                wprintf(L"%ls: test %ls %ls, error %ld\n",
                    static_cast<PCWSTR>(m_pManager->GetGroupName()),
                    static_cast<PCWSTR>(this->m_buffTestName),
                    fResult ? L"passes" : L"fails",
                    dwError);
            }
            else
            {
                const DWORD dwError = ::FusionpGetLastWin32Error();
                ReportFailure("%ls: test %ls failed to complete? Error %ld",
                    static_cast<PCWSTR>(m_pManager->GetGroupName()),
                    static_cast<PCWSTR>(this->m_buffTestName),
                    dwError);
            }

            ::Sleep(this->m_dwSleepBetweenRuns);
            
        }
        
    }
    m_pManager->SignalThreadDone();

    return 1;
    
}



BOOL
CStressJobManager::SignalThreadWorking()
{
    InterlockedIncrement((PLONG)&m_ulThreadsWorking);
    return TRUE;
}



BOOL
CStressJobManager::SignalThreadDone()
{
    InterlockedDecrement((PLONG)&m_ulThreadsWorking);
    return TRUE;
}



CStressJobManager::CStressJobManager()
{
    if (!this->m_hStartingGunEvent.Win32CreateEvent(TRUE, FALSE))
    {
        DebugBreak();
    }

    m_ulThreadsCreated = 0;
    m_ulThreadsReady = 0;
    m_ulThreadsWorking = 0;
}


CStressJobManager::~CStressJobManager()
{
}



BOOL
CStressJobManager::StartJobs()
{
    FN_PROLOG_WIN32
    
    while ( m_ulThreadsReady != m_ulThreadsCreated )
        ::Sleep(10);

    ASSERT(m_hStartingGunEvent != CEvent::GetInvalidValue());
    IFW32FALSE_EXIT(SetEvent(m_hStartingGunEvent));

    FN_EPILOG
}



BOOL
CStressJobManager::CleanupJobs()
{
    FN_PROLOG_WIN32
    CStressEntryDequeIterator Iter(&this->m_JobsListed);
    
    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        CStressJobEntry *pItem = Iter.Current();
        pItem->Cleanup();
    }
    m_JobsListed.ClearAndDeleteAll();
    FN_EPILOG
}



BOOL
CStressJobManager::StopJobs( 
    BOOL fWithWaitForComplete
    )
{
    FN_PROLOG_WIN32
    CStressEntryDequeIterator Iter(&this->m_JobsListed);
    for ( Iter.Reset(); Iter.More(); Iter.Next() )
    {
        CStressJobEntry *pItem = Iter.Current();
        pItem->Stop(fWithWaitForComplete);
    }

    FN_EPILOG
}



BOOL
CStressJobManager::WaitForAllJobsComplete()
{
    FN_PROLOG_WIN32
    CStressEntryDequeIterator Iter(&this->m_JobsListed);
    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        CStressJobEntry *pItem = Iter.Current();
        pItem->WaitForCompletion();
    }
    FN_EPILOG
}



BOOL CStressJobManager::CreateWorkerThreads( PULONG pulThreadsCreated )
{
    FN_PROLOG_WIN32

    CStressEntryDequeIterator Iter(&this->m_JobsListed);

    INTERNAL_ERROR_CHECK( m_ulThreadsCreated == 0 );

    if ( pulThreadsCreated ) *pulThreadsCreated = 0;
    m_ulThreadsCreated = 0;

    for ( Iter.Reset(); Iter.More(); Iter.Next() )
    {
        CStressJobEntry *pType = Iter.Current();
        IFW32FALSE_EXIT(pType->m_hThread.Win32CreateThread( pType->ThreadProc, pType ));
        this->m_ulThreadsCreated++;
    }

    if ( pulThreadsCreated ) *pulThreadsCreated = m_ulThreadsCreated;

    FN_EPILOG
}


BOOL CStressJobManager::SignalAnotherJobReady()
{
    ::InterlockedIncrement((PLONG)&m_ulThreadsReady);
    return TRUE;
}



BOOL CStressJobManager::WaitForStartEvent()
{
    return WaitForSingleObject( this->m_hStartingGunEvent, INFINITE ) == WAIT_OBJECT_0;
}


BOOL CStressJobManager::LoadFromDirectory(
    PCWSTR pcwszDirectoryName, 
    PULONG pulJobsFound
    )
{
    FN_PROLOG_WIN32

    CStringBuffer buffSearchString;
    CFindFile Finder;
    WIN32_FIND_DATAW FindData;

    PARAMETER_CHECK(pcwszDirectoryName);
    if ( pulJobsFound ) *pulJobsFound = 0;

    IFW32FALSE_EXIT(buffSearchString.Win32Assign(pcwszDirectoryName, ::wcslen(pcwszDirectoryName)));
    IFW32FALSE_EXIT(buffSearchString.Win32AppendPathElement(L"*", 1));

    Finder = ::FindFirstFileW(buffSearchString, &FindData);
    if (Finder == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("No tests found in directory %ls", pcwszDirectoryName);
        FN_SUCCESSFUL_EXIT();
    }

    IFW32FALSE_EXIT(buffSearchString.Win32RemoveLastPathElement());

    do
    {
        if (FusionpIsDotOrDotDot(FindData.cFileName))
            continue;

        CStringBuffer buffFoundName;
        CStressJobEntry *pNextEntry = NULL;

        IFW32FALSE_EXIT(buffFoundName.Win32Assign(buffSearchString));
        IFW32FALSE_EXIT(buffFoundName.Win32AppendPathElement(
            FindData.cFileName,
            ::wcslen(FindData.cFileName)));

        //
        // Let's get ourselves another job entry
        //
        IFW32FALSE_EXIT(this->CreateJobEntry(pNextEntry));
        INTERNAL_ERROR_CHECK(pNextEntry != NULL);

        //
        // Name and full path of test directory
        //
        IFW32FALSE_EXIT(pNextEntry->m_buffTestDirectory.Win32Assign(buffFoundName));
        IFW32FALSE_EXIT(pNextEntry->m_buffTestName.Win32Assign(
            FindData.cFileName,
            ::wcslen(FindData.cFileName)));

        //
        // And now have it load settings
        //
        IFW32FALSE_EXIT(buffFoundName.Win32AppendPathElement(
            this->GetIniFileName(),
            ::wcslen(this->GetIniFileName())));
        IFW32FALSE_EXIT(pNextEntry->LoadFromSettingsFile(buffFoundName));

        //
        // So far, so good - add it to the list of created job entries
        //
        this->m_JobsListed.AddToTail(pNextEntry);
        pNextEntry = NULL;
        
    }
    while ( ::FindNextFileW(Finder, &FindData) );

    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        goto Exit;

    //
    // Outward bound?
    //
    if ( pulJobsFound )
        *pulJobsFound = static_cast<ULONG>(this->m_JobsListed.GetEntryCount());

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\stressharness.h ===
#pragma once

class CStressJobManager;


class CBarrier
{
    CEvent  m_hBarrierEvent;
    LONG    m_lBarrierSize;
    LONG    m_lWaitingThreads;

    PRIVATIZE_COPY_CONSTRUCTORS(CBarrier)
    
public:

    CBarrier() : m_lBarrierSize(0), m_lWaitingThreads(0) { }

    //
    // Start up, with the given barrier size and name (if any)
    //
    BOOL Initialize( DWORD lBarrierSize, PCWSTR pcwszBarrierName = NULL )
    {
        FN_PROLOG_WIN32
        m_lBarrierSize = lBarrierSize;
        m_lWaitingThreads = 0;
        IFW32FALSE_EXIT(m_hBarrierEvent.Win32CreateEvent(TRUE, FALSE, pcwszBarrierName));
        FN_EPILOG
    }

    //
    // This thread is to join the barrier.  It's possible that this call will be
    // the one that "breaks" the barrier..
    //
    BOOL WaitForBarrier()
    {
        FN_PROLOG_WIN32

        LONG LatestValue = ::InterlockedIncrement(&m_lWaitingThreads);

        if ( LatestValue >= m_lBarrierSize )
        {
            IFW32FALSE_EXIT(::SetEvent(m_hBarrierEvent));
        }
        else
        {
            IFW32FALSE_EXIT(::WaitForSingleObject(m_hBarrierEvent, INFINITE) == WAIT_OBJECT_0);
        }

        FN_EPILOG
    }

    //
    // In case someone wants to wait on us without actually joining in to count
    // for breaking the barrier (why??)
    //
    BOOL WaitForBarrierNoJoin()
    {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(::WaitForSingleObject(m_hBarrierEvent, INFINITE) == WAIT_OBJECT_0);
        FN_EPILOG
    }

    //
    // A thread has a reason to break the barrier early? Fine, let them.
    //
    BOOL EarlyRelease()
    {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(::SetEvent(m_hBarrierEvent));
        FN_EPILOG
    }
    
};



class CStressJobEntry
{
    DWORD InternalThreadProc();
    BOOL WaitForStartingGun();

    PRIVATIZE_COPY_CONSTRUCTORS(CStressJobEntry);

public:
    CDequeLinkage   m_dlLinkage;
    CThread         m_hThread;
    bool            m_fStop;
    ULONG           m_ulRuns;
    ULONG           m_ulFailures;
    DWORD           m_dwSleepBetweenRuns;
    CStringBuffer   m_buffTestName;
    CStringBuffer   m_buffTestDirectory;
    CStressJobManager *m_pManager;
    
    //
    // Override these three to provide functionality
    //
    virtual BOOL RunTest( bool &rfTestPasses ) = 0;
    virtual BOOL SetupSelfForRun() = 0;
    virtual BOOL Cleanup();
    virtual BOOL LoadFromSettingsFile( PCWSTR pcwszSettingsFile );

    //
    // These are not to be overridden!
    //
    BOOL Stop( BOOL fWaitForCompletion = TRUE );
    BOOL WaitForCompletion();
    static DWORD ThreadProc( PVOID pv );

    CStressJobEntry( CStressJobManager *pManager );
    virtual ~CStressJobEntry();
    
};



typedef CDeque<CStressJobEntry, offsetof(CStressJobEntry, m_dlLinkage)> CStressEntryDeque;
typedef CDequeIterator<CStressJobEntry, offsetof(CStressJobEntry, m_dlLinkage)> CStressEntryDequeIterator;


class CStressJobManager
{
    PRIVATIZE_COPY_CONSTRUCTORS(CStressJobManager);

    friend CStressJobEntry;

    CEvent              m_hStartingGunEvent;
    ULONG               m_ulThreadsCreated;
    ULONG               m_ulThreadsReady;

    BOOL SignalAnotherJobReady();
    BOOL SignalThreadWorking();
    BOOL SignalThreadDone();
    BOOL WaitForStartEvent();

public:
    CStressEntryDeque   m_JobsListed;
    ULONG               m_ulThreadsWorking;

    BOOL LoadFromDirectory( PCWSTR pcwszDirectoryName, PULONG pulJobsFound = NULL );
    BOOL CreateWorkerThreads( PULONG pulThreadsCreated = NULL );
    BOOL StopJobs( BOOL fWithWaitForComplete = TRUE );
    BOOL CleanupJobs();
    BOOL StartJobs();
    BOOL WaitForAllJobsComplete();

    //
    // This returns the directory name that the manager will use to find
    // data files/directories.
    //
    virtual PCWSTR GetGroupName() = 0;
    virtual PCWSTR GetIniFileName() = 0;

    CStressJobManager();
    ~CStressJobManager();

protected:
    virtual BOOL CreateJobEntry( CStressJobEntry* &pJobEntry ) = 0;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\wfp.h ===
#pragma once
#include "stressharness.h"

class CWfpJobManager;

typedef enum {
    eWfpChangeDeleteFile,           // Delete a single file
    eWfpChangeTouchFile,            // Edit a single file
    eWfpChangeDeleteDirectory,      // Delete entire directory
    eWfpChangeDeleteManifest,       // Delete a manifest
    eWfpChangeDeleteCatalog,         // Delete a catalog
    eWfpChangeCompleteHavoc         // Wreck havoc!
} eWfpChangeMode;

class CWfpJobEntry : public CStressJobEntry
{
    PRIVATIZE_COPY_CONSTRUCTORS(CWfpJobEntry);

    CSmallStringBuffer  m_buffVictimAssemblyIdentity;
    CSmallStringBuffer  m_buffManifestToInstall;
    eWfpChangeMode      m_eChangeMode;
    DWORD               m_dwPauseBetweenTwiddleAndUninstall;
    BOOL                m_fUseShortnameDirectory;
    BOOL                m_fUseShortnameFile;

    BOOL GenFileListFrom( PCWSTR pcwszPath, CFusionArray<CStringBuffer> &tgt );

public:
    CWfpJobEntry( CStressJobManager *pManager ) : CStressJobEntry(pManager) { }
    virtual ~CWfpJobEntry();

    virtual BOOL LoadFromSettingsFile(PCWSTR pcwszSettingsFile);
    virtual BOOL RunTest( bool &rfTestPasses );
    virtual BOOL SetupSelfForRun();
    virtual BOOL Cleanup();
    
};

class CWfpJobManager : public CStressJobManager
{
    PRIVATIZE_COPY_CONSTRUCTORS(CWfpJobManager);
public:
    CWfpJobManager();
    ~CWfpJobManager();

    virtual PCWSTR GetGroupName() { return L"wfp"; }
    virtual PCWSTR GetIniFileName() { return L"wfp.ini"; }
    virtual BOOL CreateJobEntry( CStressJobEntry* &rpJobEntry );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\st.cpp ===
#include "stdinc.h"
#include "st.h"
#include "create.h"
#include "install.h"
#include "csrss.h"
#include "wfp.h"

extern "C" { void (__cdecl * _aexit_rtn)(int); }
CEvent ResumeThreadsEvent;
CEvent StopEvent;
LONG ThreadsWaiting;
LONG TotalThreads;
CStringBuffer BaseDirectory;
PCWSTR g_pszImage = L"st";
FILE *g_pLogFile = NULL;

void ReportFailure(const char szFormat[], ...);

extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
};

void ExeEntry()
{
    if (!::SxsDllMain(GetModuleHandleW(NULL), DLL_PROCESS_ATTACH, NULL))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    ::SxsDllMain(GetModuleHandleW(NULL), DLL_PROCESS_DETACH, NULL);
}

void
ReportFailure(
    const char szFormat[],
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

BOOL Win32Cleanup()
{
    FN_PROLOG_WIN32

    //
    // delete the stuff in the registry and under %windir%\winsxs
    //
    const static PCWSTR StuffToDelete[] =
    {
#if !defined(_AMD64_) && !defined(_M_AMD64)
        L"amd64_",
#endif
#if !defined(_IA64_) && !defined(_M_IA64)
        L"ia64_",
#endif
        L"test"
    };
    ULONG i = 0;
    ULONG j = 0;
    CRegKey RegKey;
    const static WCHAR RegRootBlah[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\Installations";
    CStringBuffer WindowsDirectory;

    IFREGFAILED_ORIGINATE_AND_EXIT(
        RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            RegRootBlah,
            0,
            KEY_ALL_ACCESS | FUSIONP_KEY_WOW64_64KEY,
            &RegKey
            ));

    for (j = 0 ; j != NUMBER_OF(StuffToDelete); ++j)
    {
        SIZE_T k = ::wcslen(StuffToDelete[j]);
        BOOL  Done = FALSE;
        for (i = 0 ; !Done; )
        {
            CStringBuffer SubKeyName;
            FILETIME      LastWriteTime;

            IFW32FALSE_EXIT(RegKey.EnumKey(i, SubKeyName, &LastWriteTime, &Done));
            if (Done)
                break;
            if (::_wcsnicmp(SubKeyName, StuffToDelete[j], k) == 0)
            {
                CRegKey SubKey;

                printf("stresstool : cleanup : deleting HKLM\\%ls\\%ls\n", RegRootBlah, static_cast<PCWSTR>(SubKeyName));
                IFW32FALSE_EXIT(RegKey.OpenSubKey(SubKey, SubKeyName, KEY_ALL_ACCESS | FUSIONP_KEY_WOW64_64KEY));
                IFW32FALSE_EXIT(SubKey.DestroyKeyTree());
                IFW32FALSE_EXIT(RegKey.DeleteKey(SubKeyName));
            }
            else
            {
                ++i;
            }
        }
    }
    IFW32FALSE_EXIT(WindowsDirectory.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));
    {
        CStringBufferAccessor StringAccessor(&WindowsDirectory);
        IFW32FALSE_EXIT(GetSystemDirectoryW(StringAccessor, StringAccessor.GetBufferCchAsUINT()));
    }
    IFW32FALSE_EXIT(WindowsDirectory.Win32RemoveLastPathElement());
    for (j = 0 ; j != NUMBER_OF(StuffToDelete); ++j)
    {
        SIZE_T k = ::wcslen(StuffToDelete[j]);
        CSmallStringBuffer StringBuffer;
        CSmallStringBuffer StringBuffer2;
        WIN32_FIND_DATAW wfd;

        IFW32FALSE_EXIT(StringBuffer.Win32Assign(WindowsDirectory));
#define X L"Winsxs\\Manifests"
        IFW32FALSE_EXIT(StringBuffer.Win32AppendPathElement(X, NUMBER_OF(X) - 1));
#undef X
        IFW32FALSE_EXIT(StringBuffer2.Win32Assign(StringBuffer));
        IFW32FALSE_EXIT(StringBuffer.Win32AppendPathElement(L"*", 1));
        IFW32FALSE_EXIT(StringBuffer.Win32Append(StuffToDelete[j], k));
        IFW32FALSE_EXIT(StringBuffer.Win32Append(L"*", 1));
        {
            CFindFile FindFileHandle;
            if (FindFileHandle.Win32FindFirstFile(StringBuffer, &wfd))
            {
                do
                {
                    CSmallStringBuffer StringBuffer3;

                    IFW32FALSE_EXIT(StringBuffer3.Win32Assign(StringBuffer2));
                    IFW32FALSE_EXIT(StringBuffer3.Win32AppendPathElement(wfd.cFileName, ::wcslen(wfd.cFileName)));
                    printf("stresstool : cleanup : deleting %ls\n", static_cast<PCWSTR>(StringBuffer3));
                    DeleteFileW(StringBuffer3);
                } while (::FindNextFileW(FindFileHandle, &wfd));
            }
        }

        IFW32FALSE_EXIT(StringBuffer.Win32Assign(WindowsDirectory));
#define X L"Winsxs"
        IFW32FALSE_EXIT(StringBuffer.Win32AppendPathElement(X, NUMBER_OF(X) - 1));
#undef X
        IFW32FALSE_EXIT(StringBuffer2.Win32Assign(StringBuffer));
        IFW32FALSE_EXIT(StringBuffer.Win32AppendPathElement(L"*", 1));
        IFW32FALSE_EXIT(StringBuffer.Win32Append(StuffToDelete[j], k));
        IFW32FALSE_EXIT(StringBuffer.Win32Append(L"*", 1));
        {
            CFindFile FindFileHandle;
            if (FindFileHandle.Win32FindFirstFile(StringBuffer, &wfd))
            {
                do
                {
                    CSmallStringBuffer StringBuffer3;

                    IFW32FALSE_EXIT(StringBuffer3.Win32Assign(StringBuffer2));
                    IFW32FALSE_EXIT(StringBuffer3.Win32AppendPathElement(wfd.cFileName, ::wcslen(wfd.cFileName)));
                    printf("deleting %ls\n", static_cast<PCWSTR>(StringBuffer3));
                    SxspDeleteDirectory(StringBuffer3);
                } while (::FindNextFileW(FindFileHandle, &wfd));
            }
        }
    }

    FN_EPILOG
}

//
// If we don't do this, control-c makes us fail assertions.
// Instead, handle it more gracefully.
//
BOOL
WINAPI
ConsoleCtrlHandler(
    DWORD Event
    )
{
    if (IsDebuggerPresent())
    {
        OutputDebugStringA("hardcoded breakpoint upon control-c while in debugger\n");
        DebugBreak();
    }
    switch (Event)
    {
    default:
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        ::SetEvent(StopEvent); // wake up the controller thread
        ::SetEvent(ResumeThreadsEvent); // in case control-c pressed near the start
        break;
    }
    return TRUE;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;

    //
    // Default of 6 hour runtime?  Wow..
    //
    DWORD iRunTime = 6 * 60;

    CWfpJobManager WfpStresser;
    
    CStressJobManager* StressManagers[] = { &WfpStresser };

    if ((argc < 2) || (argc > 3))
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <sourcedir> [minutesofstress]\n",
            argv[0], argv[0]);
        goto Exit;
    }

    if ( argc == 3 )
    {
        int iMaybeRunTime = ::_wtoi(argv[2]);
        if ( iMaybeRunTime <= 0 )
        {
            fprintf(stderr, "%ls: Usage: \n   %ls <sourcedir> [minutesofstress]\n",
                argv[0],
                argv[0]);
            goto Exit;
        }
        iRunTime = iMaybeRunTime;
    }

    ThreadsWaiting = 0;
    if (!ResumeThreadsEvent.Win32CreateEvent(TRUE, FALSE))
    {
        ::ReportFailure("CreateEvent\n");
        goto Exit;
    }
    if (!StopEvent.Win32CreateEvent(TRUE, FALSE))
    {
        ::ReportFailure("CreateEvent\n");
        goto Exit;
    }

    ::SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);

    if (!BaseDirectory.Win32Assign(argv[1], wcslen(argv[1])))
        goto Exit;

    if (!Win32Cleanup())
        goto Exit;

    if (!InitializeMSIInstallTest())
        goto Exit;
    if (!InitializeInstall())
        goto Exit;
    if (!InitializeCreateActCtx())
        goto Exit;
    if (!InitializeCsrssStress(BaseDirectory, 0))
        goto Exit;

    {
        ULONG ulThreadsCreated;
        if (!CsrssStressStartThreads(ulThreadsCreated))
            goto Exit;
        else
            TotalThreads += ulThreadsCreated;
    }

    for ( ULONG ul = 0; ul < NUMBER_OF(StressManagers); ul++ )
    {
        CStressJobManager *pManager = StressManagers[ul];

        CSmallStringBuffer buffTestDirPath;
        ULONG ulThreads;

        if ((!buffTestDirPath.Win32Assign(BaseDirectory)) ||
            (!buffTestDirPath.Win32AppendPathElement(
            pManager->GetGroupName(),
            ::wcslen(pManager->GetGroupName()))))
            goto Exit;
            
        if ((!pManager->LoadFromDirectory(buffTestDirPath)) || 
            (!pManager->CreateWorkerThreads(&ulThreads)))
            goto Exit;
    }

    // wait for them all to get to their starts (should use a semaphore here)
    while (ThreadsWaiting != TotalThreads)
    {
        Sleep(0);
    }

    OutputDebugStringA("********************************\n");
    OutputDebugStringA("*                              *\n");
    OutputDebugStringA("*      start                   *\n");
    OutputDebugStringA("*                              *\n");
    OutputDebugStringA("********************************\n");

    // Go!
    if (!::SetEvent(ResumeThreadsEvent))
    {
        ::ReportFailure("SetEvent(ResumeThreadsEvent)\n");
        goto Exit;
    }

    //
    // Start the WFP stresser
    //
    for ( ULONG ul = 0; ul < NUMBER_OF(StressManagers); ul++ )
    {
        if (!StressManagers[ul]->StartJobs())
            goto Exit;
    }

    //
    // Let them run a while.
    //
    iRunTime = iRunTime * 60 * 1000;
    ::WaitForSingleObject(StopEvent, iRunTime);

    RequestShutdownMSIInstallTestThreads();
    RequestShutdownInstallThreads();
    RequestShutdownCreateActCtxThreads();
    RequestCsrssStressShutdown();

    for ( ULONG ul = 0; ul < NUMBER_OF(StressManagers); ul++ )
    {
        StressManagers[ul]->StopJobs();
    }

    ::Sleep(1000);

    WaitForMSIInstallTestThreads();
    WaitForInstallThreads();
    WaitForCreateActCtxThreads();
    WaitForCsrssStressShutdown();

    for ( ULONG ul = 0; ul < NUMBER_OF(StressManagers); ul++ )
    {
        StressManagers[ul]->WaitForAllJobsComplete();
    }

    iReturnStatus = EXIT_SUCCESS;
Exit:
    CleanupMSIInstallTest();
    CleanupCreateActCtx();
    CleanupInstall();
    CleanupCsrssTests();
    for ( ULONG ul = 0; ul < NUMBER_OF(StressManagers); ul++ )
    {
        StressManagers[ul]->CleanupJobs();
    }
    Win32Cleanup();
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\st\wfp.cpp ===
#include "stdinc.h"
#include "st.h"
#include "stressharness.h"
#include "wfp.h"

#define WFP_INI_SECTION             (L"wfp")
#define WFP_INI_KEY_VICTIM          (L"Victim")
#define WFP_INI_KEY_MODE            (L"Mode")
#define WFP_INI_KEY_USE_SHORTFNAME  (L"UseShortnameFile")
#define WFP_INI_KEY_USE_SHORTDNAME  (L"UseShortnameDir")
#define WFP_INI_KEY_INSTALL         (L"InstallManifest")
#define WFP_INI_KEY_PAUSE_AFTER     (L"PauseLength")

#define WFP_INI_KEY_MODE_DELETE_FILES   (L"DeleteFiles")
#define WFP_INI_KEY_MODE_TOUCH_FILES    (L"TouchFiles")
#define WFP_INI_KEY_MODE_DELETE_DIR     (L"DeleteDirectory")
#define WFP_INI_KEY_MODE_DELETE_MAN     (L"DeleteManifest")
#define WFP_INI_KEY_MODE_DELETE_CAT     (L"DeleteCatalog")
#define WFP_INI_KEY_MODE_HAVOC          (L"Havoc")
#define WFP_INI_KEY_MODE_DEFAULT        (WFP_INI_KEY_MODE_DELETE_FILES)

BOOL
SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    OUT CBaseStringBuffer &PathBuffer
    )
{
    PROBING_ATTRIBUTE_CACHE pac = { 0 };

    return SxspGenerateSxsPath(
        Flags,
        PathType,
        AssemblyRootDirectory,
        AssemblyRootDirectoryCch,
        pAssemblyIdentity,
        &pac,
        PathBuffer);
}

CWfpJobEntry::~CWfpJobEntry()
{    
}



//
// Defaulted
//
BOOL 
CWfpJobEntry::SetupSelfForRun()
{
    return TRUE;
}


BOOL
CWfpJobEntry::Cleanup()
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(CStressJobEntry::Cleanup());

    if ( this->m_buffManifestToInstall.Cch() != 0 )
    {
        //
        // Uninstall the assembly that we added
        //
        SXS_UNINSTALLW Uninstall = { sizeof(Uninstall) };

        Uninstall.dwFlags = SXS_UNINSTALL_FLAG_FORCE_DELETE;
        Uninstall.lpAssemblyIdentity = this->m_buffVictimAssemblyIdentity;
        IFW32FALSE_EXIT(SxsUninstallW(&Uninstall, NULL));

    }
    
    FN_EPILOG
}


BOOL
CWfpJobEntry::GenFileListFrom(
    PCWSTR pcwszPath, 
    CFusionArray < CStringBuffer > & tgt
    )
{
    FN_PROLOG_WIN32

    CStringBuffer buffTemp;
    CFindFile ffile;
    WIN32_FIND_DATAW findData;

    IFW32FALSE_EXIT(tgt.Win32Reset());
    IFW32FALSE_EXIT(buffTemp.Win32Assign(pcwszPath, ::wcslen(pcwszPath)));
    IFW32FALSE_EXIT(buffTemp.Win32RemoveLastPathElement());

    ffile.Win32FindFirstFile( pcwszPath, &findData );
    if ( ffile != ffile.GetInvalidValue() ) do
    {
        IFW32FALSE_EXIT(buffTemp.Win32AppendPathElement(
            findData.cFileName, 
            wcslen(findData.cFileName)));
        IFW32FALSE_EXIT(tgt.Win32Append(buffTemp));
    }
    while ( ::FindNextFileW(ffile, &findData) );

    FN_EPILOG
    
}


BOOL
CWfpJobEntry::RunTest(
    bool &rfTestSuccessful
    )
{
    FN_PROLOG_WIN32;

    CSmartAssemblyIdentity pIdent;
    CSmallStringBuffer buffAssemblyRoot;

    SxspGetAssemblyRootDirectory(buffAssemblyRoot);

    if ( m_buffVictimAssemblyIdentity.Cch() == 0 )
    {
        //
        // Pick an installed assembly at random from the manifests
        // directory.
        //
        CStringBuffer buffRootDir;
        CFusionArray<CStringBuffer> arrManifestsInstalled;

        SxspGetAssemblyRootDirectory(buffRootDir);
        buffRootDir.Win32AppendPathElement(L"Manifests\\*.manifest", ::wcslen(L"Manifests\\*.manifest"));
        this->GenFileListFrom(buffRootDir, arrManifestsInstalled);

        //
        // Repeatedly try getting info on different manifests
        //
        do
        {
            SIZE_T iWhich = rand() % arrManifestsInstalled.GetSize();
            
            struct
            {
                SXS_MANIFEST_INFORMATION_BASIC Info;
                WCHAR wchBuffer[MAX_PATH*3];
            } ManifestInfo;
            
            if ( SxsQueryManifestInformation(
                0, 
                arrManifestsInstalled[iWhich], 
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME, 
                sizeof(ManifestInfo), 
                &ManifestInfo,
                NULL) )
            {
                m_buffVictimAssemblyIdentity.Win32Assign( 
                    ManifestInfo.Info.lpIdentity, 
                    wcslen(ManifestInfo.Info.lpIdentity));
                break;
            }

        }
        while ( TRUE );
            
    }

    if ( ( m_buffVictimAssemblyIdentity.Cch() != 0 ) && ( pIdent == NULL ) )
    {
        SxspCreateAssemblyIdentityFromTextualString(
            m_buffVictimAssemblyIdentity,
            &pIdent);
    }

    switch ( this->m_eChangeMode )
    {
    case eWfpChangeDeleteFile:
    case eWfpChangeTouchFile:
        {
            int iMethod = rand() % 5;
            CStringBuffer buffAssemblyPath;
            CFusionArray<CStringBuffer> buffPickFileList;

            //
            // Pick a file
            //
            SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffAssemblyRoot,
                buffAssemblyRoot.Cch(),
                pIdent,
                buffAssemblyPath);

            GenFileListFrom(buffAssemblyPath, buffPickFileList);
            CStringBuffer &cbuffVictim = buffPickFileList[rand() % buffPickFileList.GetSize()];

            if ( iMethod == 0 )
            {
                //
                // Touch the timestamp
                //
                CFusionFile ffile;
                FILETIME ft = { 0, 0 };

                IFW32FALSE_EXIT(ffile.Win32CreateFile(
                    cbuffVictim, 
                    GENERIC_READ | GENERIC_WRITE, 
                    FILE_SHARE_READ, 
                    OPEN_EXISTING));
                    
                ::SetFileTime(ffile, &ft, &ft, &ft );                
            }
            else if ( iMethod == 1 )
            {
                //
                // Read from the file
                //
                CFusionFile ffile;
                BYTE buff[20];
                DWORD dwRead;

                IFW32FALSE_EXIT(ffile.Win32CreateFile(
                    cbuffVictim, 
                    GENERIC_READ, 
                    FILE_SHARE_READ, 
                    OPEN_EXISTING));

                ::ReadFile( ffile, buff, sizeof(buff), &dwRead, NULL);
            }
            else if ( iMethod == 2 )
            {
                //
                // Write to an alternate stream
                //
                CFusionFile ffile;
                DWORD dwWrite;
                static const WCHAR pcwszThing[] = L"thing";

                cbuffVictim.Win32Append(L":dummy", 6);

                IFW32FALSE_EXIT(ffile.Win32CreateFile(
                    cbuffVictim, 
                    GENERIC_WRITE, 
                    FILE_SHARE_READ, 
                    OPEN_EXISTING));

                ::WriteFile( ffile, pcwszThing, sizeof(pcwszThing), &dwWrite, NULL);
            }
            else if ( iMethod == 3 )
            {
            }
            else if ( iMethod == 4 )
            {
            }
        }
        break;
    
    case eWfpChangeDeleteDirectory:
        {
            //
            // Create a list of files to delete in the directory, then blow
            // them away.  This is probably more guaranteed to get everything
            // deleted while WFP is running...
            //
            CStringBuffer buffPath;
            CFusionArray<CStringBuffer> arrFilenames;
            CFindFile finder;
            WIN32_FIND_DATAW findData;

            SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffAssemblyRoot,
                buffAssemblyRoot.Cch(),
                pIdent,
                buffPath);

            IFW32FALSE_EXIT(arrFilenames.Win32Initialize());
            IFW32FALSE_EXIT(buffPath.Win32AppendPathElement(L"*", 1));
            finder.Win32FindFirstFile(buffPath, &findData);
            IFW32FALSE_EXIT(buffPath.Win32RemoveLastPathElement());

            if ( finder != finder.GetInvalidValue() ) do
            {
                buffPath.Win32AppendPathElement(findData.cFileName, ::wcslen(findData.cFileName));
                arrFilenames.Win32Append(buffPath);
                buffPath.Win32RemoveLastPathElement();
            }
            while( FindNextFileW( finder, &findData ) );

            //
            // Now go delete them all.
            //
            for ( SIZE_T ul = 0; ul < arrFilenames.GetSize(); ul++ )
            {
                DeleteFileW( arrFilenames[ul] );
            }

            //
            // And delete the directory
            //
            RemoveDirectoryW(buffPath);
        }
        break;
    
    case eWfpChangeDeleteManifest:
    case eWfpChangeDeleteCatalog:
        {
            CStringBuffer buffTemp;
            int iOperation = rand() % 2;

            // 
            // Generate the path to this manifest
            //
            SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                buffAssemblyRoot,
                buffAssemblyRoot.Cch(),
                pIdent,
                buffTemp);

            if ( this->m_eChangeMode  == eWfpChangeDeleteCatalog )
            {
                IFW32FALSE_EXIT(buffTemp.Win32ChangePathExtension(
                    FILE_EXTENSION_CATALOG, 
                    FILE_EXTENSION_CATALOG_CCH, 
                    eErrorIfNoExtension));
            }

            if ( iOperation == 0 )
            {
                DeleteFileW(buffTemp);
            }
            else
            {
                CFusionFile ffile;
                if ( ffile.Win32CreateFile( buffTemp, GENERIC_WRITE, FILE_SHARE_READ, OPEN_EXISTING ) )
                {
                    DWORD dwWritten;
                    WriteFile(ffile, "boom", 4, &dwWritten, NULL);
                }
            }

        }
        break;
        
    //
    // Go change everything everywhere.  50% of the time, delete the file.
    // 25% of the time, change the file.  25% of the time, open the file, change it,
    // then hold it open.
    //
    case eWfpChangeCompleteHavoc:
        {
            CStringBuffer buffTemp;
            WIN32_FIND_DATAW data;
            CFindFile finder;
            
            SxspGetAssemblyRootDirectory(buffTemp);
            
            buffTemp.Win32AppendPathElement(L"*", 1);
            finder.Win32FindFirstFile(buffTemp, &data);
            IFW32FALSE_EXIT(buffTemp.Win32RemoveLastPathElement());

            if ( finder != finder.GetInvalidValue() ) do
            {
                //
                // 1/3 chance of actually hitting the directory
                //
                if ( ( rand() % 3 ) != 1 ) continue;
                
                CFindFile finder2;
                WIN32_FIND_DATAW data2;

                buffTemp.Win32AppendPathElement(buffTemp);
                buffTemp.Win32AppendPathElement(L"*", 1);
                finder2.Win32FindFirstFile(buffTemp, &data2);
                buffTemp.Win32RemoveLastPathElement();

                if ( finder2 != finder.GetInvalidValue() ) do
                {
                    //
                    // 50% chance of hitting this file
                    //
                    if ( ( rand() % 2 ) == 1 ) continue;
                
                    CStringBuffer ActualTarget;
                    int iOperation = rand() % 4;

                    ActualTarget.Win32Assign(buffTemp);
                    ActualTarget.Win32AppendPathElement(data2.cFileName, ::wcslen(data2.cFileName));

                    //
                    // Most often, we'll just nuke the file
                    //
                    if ( ( iOperation == 0 ) || ( iOperation == 1 ) )
                    {
                        ::DeleteFileW(ActualTarget);
                    }
                    //
                    // Just touch the first few bytes of the file.
                    //
                    else if ( ( iOperation == 2 ) || ( iOperation == 3 ) )
                    {
                        CFusionFile ffile;
                        DWORD dwWritten;

                        if ( ffile.Win32CreateFile(
                            ActualTarget, 
                            GENERIC_READ | GENERIC_WRITE, 
                            FILE_SHARE_READ, 
                            OPEN_EXISTING))
                        {
                            WriteFile( ffile, "boom", 4, &dwWritten, NULL );
                        }

                        //
                        // 20 seconds sounds good enough
                        //
                        if ( iOperation == 3 )
                        {
                            ::Sleep(5000);
                        }
                        
                    }
                }
                while ( FindNextFileW( finder2, &data2 ) );

                buffTemp.Win32RemoveLastPathElement();
            }
            while ( FindNextFileW(finder, &data) );
        }
        break;
    }

    rfTestSuccessful = true;
    
    FN_EPILOG
}


CWfpJobEntry::LoadFromSettingsFile(
    PCWSTR pcwszSettingsFile
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffJunk;
    INT iJunk;

    //
    // Are we using shortnames for files?
    //
    IFW32FALSE_EXIT(SxspIsPrivateProfileStringEqual(
        WFP_INI_SECTION,
        WFP_INI_KEY_USE_SHORTFNAME,
        L"no",
        this->m_fUseShortnameFile, 
        pcwszSettingsFile));

    //
    // Are we using shortnames for directories?
    //
    IFW32FALSE_EXIT(SxspIsPrivateProfileStringEqual(
        WFP_INI_SECTION,
        WFP_INI_KEY_USE_SHORTDNAME,
        L"no",
        this->m_fUseShortnameDirectory,
        pcwszSettingsFile));

    //
    // How long are we to wait between twiddling and uninstalling?
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileIntW(
        WFP_INI_SECTION,
        WFP_INI_KEY_PAUSE_AFTER,
        5000,
        iJunk,
        pcwszSettingsFile));
    this->m_dwPauseBetweenTwiddleAndUninstall = iJunk;
    
    //
    // The test mode
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(
        WFP_INI_SECTION,
        WFP_INI_KEY_MODE,
        WFP_INI_KEY_MODE_DEFAULT,
        buffJunk,
        pcwszSettingsFile));

    #define TEST_MODE( mds, mdn ) if (FusionpStrCmpI((WFP_INI_KEY_MODE_##mds), buffJunk) == 0) this->m_eChangeMode = mdn
    TEST_MODE(DELETE_FILES, eWfpChangeDeleteFile);
    TEST_MODE(TOUCH_FILES, eWfpChangeTouchFile);
    TEST_MODE(DELETE_DIR, eWfpChangeDeleteDirectory);
    TEST_MODE(DELETE_MAN, eWfpChangeDeleteManifest);
    TEST_MODE(DELETE_CAT, eWfpChangeDeleteCatalog);
    TEST_MODE(HAVOC, eWfpChangeCompleteHavoc);

    //
    // The victim assembly identity
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(
        WFP_INI_SECTION,
        WFP_INI_KEY_VICTIM,
        L"",
        m_buffVictimAssemblyIdentity,
        pcwszSettingsFile));

    //
    // Are we installing an assembly to do this to?
    //
    IFW32FALSE_EXIT(SxspGetPrivateProfileStringW(
        WFP_INI_SECTION,
        WFP_INI_KEY_INSTALL,
        L"",
        buffJunk,
        pcwszSettingsFile));

    if ( buffJunk.Cch() != 0 )
    {
        IFW32FALSE_EXIT(this->m_buffManifestToInstall.Win32Assign(this->m_buffTestDirectory));
        IFW32FALSE_EXIT(this->m_buffManifestToInstall.Win32AppendPathElement( buffJunk ));
    }
    
    FN_EPILOG
}




CWfpJobManager::CWfpJobManager()
{
    //
    // Nothing
    //
}




CWfpJobManager::~CWfpJobManager()
{
    //
    // Nothing
    //
}




BOOL
CWfpJobManager::CreateJobEntry(
    CStressJobEntry* &rpJobEntry
    )
{
    FN_PROLOG_WIN32
    rpJobEntry = NULL;
    rpJobEntry = FUSION_NEW_SINGLETON(CWfpJobEntry(this));
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\bindstat.h ===
#pragma once

//**************************************************************************
// BEGIN bind callback for calling into URLMON


class CodeDownloadBSC : public IBindStatusCallback, public IWindowForBindingUI, public IServiceProvider 
{
    public:
    
        CodeDownloadBSC(HANDLE hCompletionEvent);
        virtual ~CodeDownloadBSC();
        HRESULT Abort();

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID ridd, void **ppv );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
    
        // IBindStatusCallback methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo);
        STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding *pib);
        STDMETHODIMP GetPriority(LONG *pnPriority);
        STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,FORMATETC *pformatetc,STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
        STDMETHODIMP OnLowResource(DWORD dwReserved);
        STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);

        // IWindowForBindingUI
        STDMETHODIMP GetWindow(const struct _GUID & guidReason, HWND *phwnd);

        // IServiceProvider
        STDMETHODIMP CodeDownloadBSC::QueryService(const struct _GUID &guidService, REFIID riid, void **ppv);

        // helper method
        HRESULT GetHResult() { return _hResult; }

    protected:
        IBinding   *_pIBinding;          // ibinding from code dl'er
        DWORD       _cRef;
        HANDLE      _hCompletionEvent;
        HRESULT     _hResult;            // final result

};

// END bind callback for calling into URLMON
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\charbuf.h ===
#pragma once

//******************************************************************************8
// BEGIN CCHARBuffer stuff

class CCHARBufferBase
{
public:
	CCHARBufferBase(CHAR *prgchInitialBuffer, ULONG cchInitialBuffer);
	virtual ~CCHARBufferBase();

	// FFromUnicode returns FALSE if it failed; use GetLastError() to get the reason.
	BOOL FFromUnicode(LPCOLESTR sz) throw ();
	BOOL FFromUnicode(LPCOLESTR sz, int cch) throw ();

	void ToUnicode(ULONG cchBuffer, WCHAR rgchBuffer[], ULONG *pcchActual) throw ();

	ULONG GetUnicodeCch() const throw (/*_com_error*/);

	void Sync();
	void SyncList();
	void SetBufferEnd(ULONG cch) throw ();

	void Reset() throw (/*_com_error*/);
	void Fill(CHAR ch, ULONG cch) throw (/*_com_error*/);

	BOOL FSetBufferSize(ULONG cch) throw (/*_com_error*/); // must include space for null character
	HRESULT HrSetBufferSize(ULONG cch) throw ();

	operator LPSTR() { return m_pszCurrentBufferStart; }

	BOOL FAddChar(CHAR ch) throw (/*_com_error*/)
	{
		if (m_pchCurrentChar == m_pszCurrentBufferEnd)
		{
			if (!this->FExtendBuffer(this->GetGrowthCch()))
				return FALSE;
		}

//		_ASSERTE((m_pchCurrentChar >= m_pszCurrentBufferStart) &&
//				 (m_pchCurrentChar < m_pszCurrentBufferEnd));

		*m_pchCurrentChar++ = ch;
		return TRUE;
	}

	BOOL FAddString(const CHAR sz[]) throw (/*_com_error*/)
	{
		const CHAR *pch = sz;
		CHAR ch;

		while ((ch = *pch++) != '\0')
		{
			if (!this->FAddChar(ch))
				return FALSE;
		}

		return TRUE;
	}

	ULONG GetBufferSize() const { return m_cchBufferCurrent; }

	void AddQuotedCountedString(const CHAR sz[], ULONG cch) throw (/*_com_error*/);
	void AddQuotedString(const CHAR sz[]) throw (/*_com_error*/);


	BOOL FExtendBuffer(ULONG cchDelta) throw (/*_com_error*/);
	HRESULT HrExtendBuffer(ULONG cchDelta) throw ();

	CHAR *m_pszDynamicBuffer;
	CHAR *m_pszCurrentBufferEnd;
	CHAR *m_pszCurrentBufferStart;
	CHAR *m_pchCurrentChar;
	ULONG m_cchBufferCurrent;

	virtual CHAR *GetInitialBuffer() = 0;
	virtual ULONG GetInitialBufferCch() = 0;
	virtual ULONG GetGrowthCch() = 0;
};

template <unsigned long cchFixed, unsigned long cchGrowth> class CCHARBuffer : protected CCHARBufferBase
{
	typedef CCHARBufferBase super;

public:
	CCHARBuffer() : CCHARBufferBase(m_rgchFixedBuffer, cchFixed) { }
	~CCHARBuffer()	{ }

	using super::FFromUnicode;
	using super::ToUnicode;
	using super::Sync;
	using super::SyncList;
	using super::Reset;
	using super::Fill;
	using super::GetBufferSize;
	using super::GetUnicodeCch;
	using super::SetBufferEnd;
	using super::FAddString;
	
	using CCHARBufferBase::FSetBufferSize;

	operator LPSTR() { return m_pszCurrentBufferStart; }

protected:
	CHAR m_rgchFixedBuffer[cchFixed];

	virtual CHAR *GetInitialBuffer() { return m_rgchFixedBuffer; }
	virtual ULONG GetInitialBufferCch() { return cchFixed; }
	virtual ULONG GetGrowthCch() { return cchGrowth; }
};

typedef CCHARBuffer<1024, 32> CVsANSIBuffer;
typedef CCHARBuffer<1024, 32> CANSIBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\filesys.h ===
#pragma once

class CFileSystemBase
{
public:
    virtual BOOL    Initialize() = 0;
    virtual BOOL    CreateDirectory(PCWSTR PathName, LPSECURITY_ATTRIBUTES lpSecurity) = 0;
    virtual HANDLE  CreateFile(PCWSTR PathName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES, DWORD dwCreation, DWORD dwFlags, HANDLE hTemplate) = 0;
    virtual BOOL    DeleteFile(PCWSTR PathName) = 0;
    virtual BOOL    RemoveDirectory(PCWSTR PathName) = 0;
    virtual HRSRC   FindResource(HMODULE hm, PCWSTR pcwszName, PCWSTR pcwszType) = 0;
    virtual DWORD   GetTempPath(DWORD dwBuffer, PWSTR pwszResult) = 0;
    virtual DWORD   GetFileAttributes(PCWSTR pcwsz) = 0;
    virtual HANDLE  FindFirst(PCWSTR pcwsz, WIN32_FIND_DATAW *FindData) = 0;
    virtual BOOL    FindNext(HANDLE hFind, WIN32_FIND_DATAW *FindData) = 0;
    virtual BOOL    FindClose(HANDLE hFind) = 0;
    virtual BOOL    LoadString(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max) = 0;
    virtual DWORD   ExpandEnvironmentStrings(PCWSTR pcwsz, PWSTR tgt, DWORD Size) = 0;
    virtual BOOL    CopyFile(PCWSTR a, PCWSTR b, BOOL) = 0;
    virtual BOOL    SetFileAttributes(PCWSTR pcwsz, DWORD dw) = 0;
    virtual HANDLE  CreateFileMapping(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz) = 0;
    virtual BOOL    EnumResourceNames(HMODULE, LPCWSTR, ENUMRESNAMEPROCW, LONG_PTR) = 0;
    virtual HMODULE LoadLibrary(PCWSTR pcwsz) = 0;
};

#define MAP_FUNC2(fnName, tgtName, hm) (NULL != (*((FARPROC*)&this->tgtName) = GetProcAddress(hm, (#fnName))))
#define MAP_FUNC(name, hm) MAP_FUNC2(name, m_pfn##name, hm)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\filesys_ansi.cpp ===
#include "stdinc.h"
#include "windows.h"
#include "filesys.h"
#include "filesys_ansi.h"

#define MAX_MCS_SIZE        (2)
#define ACP_FOR_CONVERSION  (CP_ACP)

#ifndef NUMBER_OF
#define NUMBER_OF(q) (sizeof(q)/sizeof(*q))
#endif // NUMBER_OF

BOOL CWin9xFileSystemBase::Initialize()
{
    HMODULE hm = GetModuleHandleA("kernel32.dll");
    HMODULE hm2 = LoadLibraryA("user32.dll");

    return (MAP_FUNC(CreateDirectoryA, hm) &&
        MAP_FUNC(FindFirstFileA, hm) &&
        MAP_FUNC(FindNextFileA, hm) &&
        MAP_FUNC(LoadStringA, hm2) &&
        MAP_FUNC(ExpandEnvironmentStringsA, hm) &&
        MAP_FUNC(CreateFileA, hm) &&
        MAP_FUNC(DeleteFileA, hm) &&
        MAP_FUNC(RemoveDirectoryA, hm) &&
        MAP_FUNC(FindResourceA, hm) &&
        MAP_FUNC(GetTempPathA, hm) &&
        MAP_FUNC(SetFileAttributesA, hm) &&
        MAP_FUNC(CopyFileA, hm) &&
        MAP_FUNC(FindClose, hm) &&
        MAP_FUNC(CreateFileMappingA, hm) && 
        MAP_FUNC(SetFileAttributesA, hm) &&
        MAP_FUNC(LoadLibraryA, hm) &&
        MAP_FUNC(GetFileAttributesA, hm));
};


#define CONVERT_INLINE(str, tgt) do { if (NUMBER_OF(tgt) <= WideCharToMultiByte(CP_ACP, 0, str, -1, tgt, NUMBER_OF(tgt), NULL, NULL)) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; } } while (0)
#define BACKCONVERT_INLINE(str, tgt) do { if (NUMBER_OF(tgt) <= MultiByteToWideChar(CP_ACP, 0, str, -1, tgt, NUMBER_OF(tgt))) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; } } while (0)


HMODULE CWin9xFileSystemBase::LoadLibrary(PCWSTR pcwsz)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(pcwsz, Buffer);
    return m_pfnLoadLibraryA(Buffer);
}

HANDLE CWin9xFileSystemBase::CreateFileMapping(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(psz, Buffer);
    return m_pfnCreateFileMappingA(h, psa, fp, MaxHigh, MaxLow, Buffer);
}


BOOL CALLBACK
CWin9xFileSystemBase::EnumResourceNameAShim(HMODULE hm, LPCSTR psz, LPSTR name, LONG_PTR lParam)
{
    EnumResourceNameWData *pShimData = (EnumResourceNameWData*)lParam;
    WCHAR wchType[MAX_PATH];
    WCHAR wchName[MAX_PATH];
    BACKCONVERT_INLINE(psz, wchType);
    BACKCONVERT_INLINE(name, wchName);
    return pShimData->TargetProc(hm, wchType, wchName, pShimData->OriginalMetadata);
}


BOOL CWin9xFileSystemBase::EnumResourceNames(HMODULE hm, LPCWSTR pwsz, ENUMRESNAMEPROCW pfn, LONG_PTR lp)
{
    CHAR Buffer[MAX_PATH];
    EnumResourceNameWData ShimData;
    ShimData.TargetProc = pfn;
    ShimData.OriginalMetadata = lp;
    CONVERT_INLINE(pwsz, Buffer);
    return m_pfnEnumResourceNamesA(hm, Buffer, CWin9xFileSystemBase::EnumResourceNameAShim, (LONG_PTR)&ShimData);
}


INT CWin9xFileSystemBase::LoadString(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max)
{
    int iResult;
    PSTR pszString;

    //
    // Get some storage
    //
    pszString = (PSTR)HeapAlloc(GetProcessHeap(), 0, ((Max + 1) * 2));

    if (!pszString)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    // Do the load
    //
    iResult = m_pfnLoadStringA(h, ui, pszString, Max);

    iResult = MultiByteToWideChar(CP_ACP, 0, pszString, iResult, pwszBuffer, Max);
    pwszBuffer[iResult] = UNICODE_NULL;

    //
    // Free
    //
    HeapFree(GetProcessHeap(), 0, pszString);

    return iResult;
}

DWORD CWin9xFileSystemBase::ExpandEnvironmentStrings(PCWSTR pcwsz, PWSTR tgt, DWORD Size)
{
    CHAR Buffer1[MAX_PATH];
    CHAR Buffer2[MAX_PATH];
    DWORD dw;

    CONVERT_INLINE(pcwsz, Buffer1);

    if (0 != (dw = m_pfnExpandEnvironmentStringsA(Buffer1, Buffer2, NUMBER_OF(Buffer2))))
    {
        int i = MultiByteToWideChar(CP_ACP, 0, Buffer2, dw, tgt, Size);
        if (tgt && Size)
            tgt[i] = UNICODE_NULL;
    }

    return dw;
}



DWORD CWin9xFileSystemBase::GetTempPath(DWORD dw, PWSTR pwsz)
{
    CHAR Buffer[MAX_PATH];
    DWORD dwResult;

    if (0 != (dwResult = m_pfnGetTempPathA(NUMBER_OF(Buffer), Buffer)))
    {
        int i = MultiByteToWideChar(CP_ACP, 0, Buffer, dwResult, pwsz, dw);
        if (dw && pwsz)
            pwsz[i] = UNICODE_NULL;

    }

    return dwResult;
}

BOOL
CloneFindData(const WIN32_FIND_DATAA *src, WIN32_FIND_DATAW *tgt)
{
    int i;
    tgt->dwFileAttributes = src->dwFileAttributes;
    tgt->dwReserved0 = src->dwReserved0;
    tgt->dwReserved1 = src->dwReserved1;
    tgt->ftCreationTime = src->ftCreationTime;
    tgt->ftLastAccessTime = src->ftLastAccessTime;
    tgt->ftLastWriteTime = src->ftLastWriteTime;
    tgt->nFileSizeHigh = src->nFileSizeHigh;
    tgt->nFileSizeLow = src->nFileSizeLow;

    i = MultiByteToWideChar(CP_ACP, 0, src->cFileName, -1, tgt->cFileName, NUMBER_OF(tgt->cFileName));
    tgt->cFileName[i] = UNICODE_NULL;
    i = MultiByteToWideChar(CP_ACP, 0, src->cFileName, -1, tgt->cAlternateFileName, NUMBER_OF(tgt->cAlternateFileName));
    tgt->cAlternateFileName[i] = UNICODE_NULL;

    return TRUE;
}

HANDLE CWin9xFileSystemBase::FindFirst(PCWSTR pcwsz, WIN32_FIND_DATAW *FindData)
{
    CHAR Buffer[MAX_PATH];
    WIN32_FIND_DATAA OurFindData;
    HANDLE hResult = INVALID_HANDLE_VALUE;

    CONVERT_INLINE(pcwsz, Buffer);

    if (INVALID_HANDLE_VALUE != (hResult = m_pfnFindFirstFileA(Buffer, &OurFindData)))
    {
        CloneFindData(&OurFindData, FindData);
    }

    return hResult;
}


BOOL CWin9xFileSystemBase::FindNext(HANDLE hFind, WIN32_FIND_DATAW *FindData)
{
    WIN32_FIND_DATAA LocalFindData;
    BOOL fResult;

    if (FALSE != (fResult = m_pfnFindNextFileA(hFind, &LocalFindData)))
    {
        CloneFindData(&LocalFindData, FindData);
    }

    return fResult;
}

BOOL CWin9xFileSystemBase::FindClose(HANDLE hFind)
{
    return m_pfnFindClose(hFind);
}

BOOL CWin9xFileSystemBase::CreateDirectory(PCWSTR PathName, LPSECURITY_ATTRIBUTES lpSecurity) 
{ 
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(PathName, Buffer);
    return m_pfnCreateDirectoryA(Buffer, lpSecurity); 
}

HANDLE CWin9xFileSystemBase::CreateFile(PCWSTR PathName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lp, DWORD dwCreation, DWORD dwFlags, HANDLE hTemplate)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(PathName, Buffer);
    return m_pfnCreateFileA(Buffer, dwAccess, dwShareMode, lp, dwCreation, dwFlags, hTemplate);
}

BOOL CWin9xFileSystemBase::DeleteFile(PCWSTR PathName)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(PathName, Buffer);
    return m_pfnDeleteFileA(Buffer);
}

BOOL CWin9xFileSystemBase::RemoveDirectory(PCWSTR PathName)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(PathName, Buffer);
    return m_pfnRemoveDirectoryA(Buffer);
}

HRSRC CWin9xFileSystemBase::FindResource(HMODULE hm, PCWSTR pcwszName, PCWSTR pcwszType)
{
    CHAR Buffer[MAX_PATH];
    CHAR Buffer2[MAX_PATH];
    CONVERT_INLINE(pcwszName, Buffer);
    CONVERT_INLINE(pcwszType, Buffer2);
    return m_pfnFindResourceA(hm, Buffer, Buffer2);
}

DWORD CWin9xFileSystemBase::GetFileAttributes(PCWSTR pcwsz)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(pcwsz, Buffer);
    return m_pfnGetFileAttributesA(Buffer);
}



BOOL CWin9xFileSystemBase::SetFileAttributes(PCWSTR pcwsz, DWORD dw)
{
    CHAR Buffer[MAX_PATH];
    CONVERT_INLINE(pcwsz, Buffer);
    return m_pfnSetFileAttributesA(Buffer, dw);
}


BOOL CWin9xFileSystemBase::CopyFile(PCWSTR a, PCWSTR b, BOOL c)
{
    CHAR Buffer1[MAX_PATH];
    CHAR Buffer2[MAX_PATH];
    CONVERT_INLINE(a, Buffer1);
    CONVERT_INLINE(b, Buffer2);
    return m_pfnCopyFileA(Buffer1, Buffer2, c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\bindstat.cpp ===
#include "stdinc.h"
#include "bindstat.h"


//***************************************************************************8
// definitions for IBindCtx callback that is given to URLMON

//
//   Constructor for CodeDownloadBSC
// 
//   hwnd - handle of parent window for any UI (may be NULL)
//

CodeDownloadBSC::CodeDownloadBSC(HANDLE hCompletionEvent)
{
    _cRef = 1;
    _pIBinding = NULL;
    _hCompletionEvent = hCompletionEvent;  // optional: event to signal when complete
    _hResult = E_PENDING;
}

CodeDownloadBSC::~CodeDownloadBSC()
{
}

HRESULT CodeDownloadBSC::Abort()
{
    return _pIBinding->Abort();
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL
    ;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IWindowForBindingUI)
    {
        *ppv = (IWindowForBindingUI *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::Release()
{
    if (--_cRef)
    {
        return _cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
    }
    
    _pIBinding = pib;

    if (_pIBinding != NULL)
    {
        _pIBinding->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    _hResult = hresult;

    // if we were given an event to signal when done, go ahead and signal it
    
    if (_hCompletionEvent)
        SetEvent(_hCompletionEvent);
    
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

STDMETHODIMP CodeDownloadBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    return S_OK;
}


STDMETHODIMP CodeDownloadBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
   *pgrfBINDF |= BINDF_ASYNCHRONOUS;
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetWindow(const struct _GUID& guidReason, HWND *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::QueryService(const struct _GUID &guidService, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\expresscore.cpp ===
#include "stdinc.h"
#include "windows.h"
#include "sxs-rtl.h"
#include "sxsapi.h"
#include "sxsexpress.h"
#include "stdlib.h"
#include "fdi.h"
#include "stdio.h"
#include "filesys.h"
#include "filesys_unicode.h"
#include "filesys_ansi.h"
extern "C" { 
#include "identbuilder.h"
#include "fasterxml.h"
#include "skiplist.h" 
#include "namespacemanager.h"
#include "xmlstructure.h"
};

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DBG
#define ASSERT(q) { if (!(q)) DebugBreak(); } 
#else
#define ASSERT(q)
#endif

#define FDI_THING_TYPE_MEMSTREAM            (0x00000001)
#define FDI_THING_TYPE_FILE                 (0x00000002)

typedef struct _tagFDI_STREAM {

    ULONG ulType;

    union {
        struct {
            PVOID pvCursor;
            PVOID pvResourceData;
            PVOID pvResourceDataEnd;
        } MemoryStream;

        struct {
            HANDLE hFile;
            PCWSTR pcwszPath;
        } File;
    };
}
FDI_STREAM, *PFDI_STREAM;




typedef struct _tagFCI_COPY_CONTEXT {

    PCWSTR pcwszTargetDirectory;

    FDI_STREAM CoreCabinetStream;

    BOOL UTF8Aware;
}
COPY_CONTEXT, *PCOPY_CONTEXT;




COPY_CONTEXT g_GlobalCopyContext = {NULL};
HINSTANCE g_hInstOfResources = NULL;
CFileSystemBase *g_FileSystem = NULL;


// This entrypoint we'll call downlevel to ensure that the right things
// happen while installing (refcounting, uninstall, etc.)
int WINAPI MsInfHelpEntryPoint(HINSTANCE hInstance, HINSTANCE hPrevInstance, PCWSTR lpCmdLine, int nCmdShow);


BOOL
DoFileCopies(
    PVOID pvFileData,
    DWORD dwFileSize,
    PCWSTR pwszSourcePath,
    PCWSTR pwszTargetPath
    );

NTSTATUS FASTCALL MyAlloc(SIZE_T cb, PVOID* ppvAllocated, PVOID pvContext)
{
    return ((*ppvAllocated = HeapAlloc(GetProcessHeap(), 0, cb)) != NULL) ? STATUS_SUCCESS : STATUS_NO_MEMORY;
}

NTSTATUS FASTCALL MyFree(PVOID pv, PVOID pvContext)
{
    return HeapFree(GetProcessHeap(), 0, pv) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

RTL_ALLOCATOR g_ExpressAllocator = {MyAlloc, MyFree, NULL};



FNALLOC(sxp_FnAlloc)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
}



FNFREE(sxp_FnFree)
{
    HeapFree(GetProcessHeap(), 0, pv);
}


PWSTR
ConvertString(char* psz, BOOL IsUtf8)
{
    DWORD dwSize;
    PWSTR pwszAllocated = NULL;

    if (psz == NULL)
        return NULL;

    dwSize = MultiByteToWideChar(IsUtf8 ? CP_UTF8 : CP_ACP, 0, psz, -1, NULL, 0);

    if (dwSize)
    {
        pwszAllocated = (PWSTR)sxp_FnAlloc((dwSize + 10) * sizeof(WCHAR));

        MultiByteToWideChar(IsUtf8 ? CP_UTF8 : CP_ACP, 0, psz, -1, pwszAllocated, dwSize + 10);
    }

    return pwszAllocated;    
}



FNOPEN(sxp_FnOpen)
{
    PFDI_STREAM pRetValue = (PFDI_STREAM)sxp_FnAlloc(sizeof(FDI_STREAM));

    //
    // Ah, it's the memory-mapped cabinet file ... clone the memory
    // stream structure and return a pointer to it
    //
    if (lstrcmpiA(pszFile, "::::") == 0)
    {
        //
        // Copy, but reset cursor to top of file
        //
        memcpy(pRetValue, &g_GlobalCopyContext.CoreCabinetStream, sizeof(g_GlobalCopyContext.CoreCabinetStream));
        pRetValue->MemoryStream.pvCursor = pRetValue->MemoryStream.pvResourceData;
    }
    //
    // Some other file to be opened... hmm
    //
    else
    {
        PWSTR pwszConvertedString = ConvertString(pszFile, g_GlobalCopyContext.UTF8Aware);

        if (pwszConvertedString == NULL)
        {
            return static_cast<INT_PTR>(-1);
        }

        pRetValue->ulType = FDI_THING_TYPE_FILE;

        pRetValue->File.pcwszPath = pwszConvertedString;

        //
        // Caution - nothing here sanitizes paths at all.  If you've got read access
        // to the file, then you've got read access.  No path fiddling, etc.
        //
        pRetValue->File.hFile = g_FileSystem->CreateFile(
            pwszConvertedString, 
            GENERIC_READ, 
            FILE_SHARE_READ, 
            NULL, 
            OPEN_EXISTING, 
            FILE_ATTRIBUTE_NORMAL, 
            NULL);

        //
        // Error opening the file, indicate this back to the caller - ensure that all allocated
        // memory is freed.
        //
        if ((pRetValue->File.hFile == NULL) || (pRetValue->File.hFile == INVALID_HANDLE_VALUE))
        {
            sxp_FnFree(pwszConvertedString);
            pwszConvertedString = NULL;

            sxp_FnFree(pRetValue);
            pRetValue = NULL;

            return static_cast<INT_PTR>(-1);
        }
    }

    return (INT_PTR)pRetValue;
}

FNREAD(sxp_FnRead)
{
    PFDI_STREAM pThing = (PFDI_STREAM)hf;

    if (pThing->ulType == FDI_THING_TYPE_MEMSTREAM)
    {
        SIZE_T cbRead = (PBYTE)pThing->MemoryStream.pvResourceDataEnd - (PBYTE)pThing->MemoryStream.pvCursor;

        if (cbRead > cb)
        {
            cbRead = cb;
        }

        memcpy(pv, pThing->MemoryStream.pvCursor, cbRead);

        pThing->MemoryStream.pvCursor = (PBYTE)pThing->MemoryStream.pvCursor + cbRead;

        return static_cast<UINT>(cbRead);
    }
    //
    // If the current thing is a file
    //
    else if (pThing->ulType == FDI_THING_TYPE_FILE)
    {
        BOOL fResult;
        DWORD dwRead;

        fResult = ReadFile(pThing->File.hFile, pv, cb, &dwRead, NULL);

        if (!fResult)
        {
            return -1;
        }
        else
        {
            return dwRead;
        }
    }
    else
    {
        ASSERT(FALSE);
        return -1;
    }
}


FNWRITE(sxp_FnWrite)
{
    PFDI_STREAM pThing = (PFDI_STREAM)hf;


    if (pThing->ulType == FDI_THING_TYPE_MEMSTREAM)
    {
        ASSERT(FALSE);
        return -1;
    }
    else if (pThing->ulType == FDI_THING_TYPE_FILE)
    {
        DWORD dwWrite;
        BOOL fResult;

        fResult = WriteFile(pThing->File.hFile, pv, cb, &dwWrite, NULL);

        if (!fResult)
        {
            return -1;
        }
        else
        {
            return dwWrite;
        }
    }
    else
    {
        ASSERT(FALSE);
        return -1;
    }
}


FNCLOSE(sxp_FnClose)
{
    PFDI_STREAM pThing = (PFDI_STREAM)hf;

    if (pThing->ulType == FDI_THING_TYPE_MEMSTREAM)
    {
    }
    else if (pThing->ulType == FDI_THING_TYPE_FILE)
    {
        CloseHandle(pThing->File.hFile);
    }
    else
    {
        ASSERT(FALSE);
        return -1;
    }

    if (pThing != &g_GlobalCopyContext.CoreCabinetStream)
    {
        sxp_FnFree(pThing);
    }

    return 1;

}

FNSEEK(sxp_FnSeek)
{
    PFDI_STREAM pThing = (PFDI_STREAM)hf;

    if (pThing->ulType == FDI_THING_TYPE_FILE)
    {
        switch (seektype)
        {
        case SEEK_SET:
            return SetFilePointer(pThing->File.hFile, dist, NULL, FILE_BEGIN);

        case SEEK_CUR:
            return SetFilePointer(pThing->File.hFile, dist, NULL, FILE_CURRENT);

        case SEEK_END:
            return SetFilePointer(pThing->File.hFile, dist, NULL, FILE_END);
        }

        return -1;
    }
    else if (pThing->ulType == FDI_THING_TYPE_MEMSTREAM)
    {
        switch (seektype)
        {
        case SEEK_SET:
            pThing->MemoryStream.pvCursor = (PBYTE)pThing->MemoryStream.pvResourceData + dist;
            break;

        case SEEK_CUR:
            pThing->MemoryStream.pvCursor = (PBYTE)pThing->MemoryStream.pvCursor + dist;
            break;

        case SEEK_END:
            pThing->MemoryStream.pvCursor = (PBYTE)pThing->MemoryStream.pvResourceDataEnd + dist;
            break;
        }

        return static_cast<long>((PBYTE)pThing->MemoryStream.pvCursor - (PBYTE)pThing->MemoryStream.pvResourceData);
    }
    else
    {
        ASSERT(FALSE);
        return -1;
    }
}




BOOL
CreatePath(
    PCWSTR pcwszBasePath,
    PCWSTR pcwszLeaves,
    BOOL IncludeLastPiece
    )
{
    static WCHAR wchLargeBuffer[MAX_PATH*2];

    wcscpy(wchLargeBuffer, pcwszBasePath);

    while (*pcwszLeaves)
    {
        SIZE_T cchSegment = wcscspn(pcwszLeaves, L"\\");
        SIZE_T cchBuff = wcslen(wchLargeBuffer);
        DWORD dw;

        //
        // No slash, last segment
        //
        if (!IncludeLastPiece && (cchSegment == wcslen(pcwszLeaves))) {
            break;
        }

        if ((cchSegment == 0) && !IncludeLastPiece)
            break;

        if (cchBuff && (wchLargeBuffer[cchBuff - 1] != L'\\')) {
            wchLargeBuffer[cchBuff++] = L'\\';
            wchLargeBuffer[cchBuff] = UNICODE_NULL;
        }

        if ((cchBuff + cchSegment + 2) > NUMBER_OF(wchLargeBuffer))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // This really is copying cchSegment characters onto the back of the large
        // buffer - the above if determined if there was space to do so already.
        // 
        wcsncat(wchLargeBuffer, pcwszLeaves, cchSegment);

        //
        // Just create the directory.  If the error is other than "it exists",
        // then we've got a problem.
        //
        if (!g_FileSystem->CreateDirectory(wchLargeBuffer, NULL))
        {
            dw = GetLastError();
            if (dw != ERROR_ALREADY_EXISTS)
            {
                return FALSE;
            }
        }

        pcwszLeaves += cchSegment;
        pcwszLeaves += wcsspn(pcwszLeaves, L"\\");
    }

    return TRUE;
}


FNFDINOTIFY(sxp_FdiNotify)
{
    PFDINOTIFICATION pfNotify = pfdin;

    switch (fdint)
    {
    case fdintCOPY_FILE:
        {
            PWSTR pwszTargetName = NULL;
            PWSTR pwszConvertedName = NULL;
            DWORD dwChars;
            PFDI_STREAM pfStream = NULL;

            pfStream = (PFDI_STREAM)sxp_FnAlloc(sizeof(FDI_STREAM));

            if (!pfStream)
                return -1;

            pwszConvertedName = ConvertString(pfNotify->psz1, pfNotify->attribs & _A_NAME_IS_UTF);

            if (!pwszConvertedName) {
                sxp_FnFree(pfStream);
                return -1;
            }

            dwChars = wcslen(pwszConvertedName) + 2 + wcslen(g_GlobalCopyContext.pcwszTargetDirectory);
            pwszTargetName = (PWSTR)sxp_FnAlloc(dwChars * sizeof(WCHAR));

            if (!pwszTargetName) {
                sxp_FnFree(pwszConvertedName);
                sxp_FnFree(pfStream);
                return -1;
            }

            wcscpy(pwszTargetName, g_GlobalCopyContext.pcwszTargetDirectory);
            wcscat(pwszTargetName, pwszConvertedName);

            pfStream->ulType = FDI_THING_TYPE_FILE;

            pfStream->File.pcwszPath = pwszTargetName;
            
            if (!CreatePath(g_GlobalCopyContext.pcwszTargetDirectory, pwszConvertedName, FALSE))
            {
                sxp_FnFree(pwszTargetName);
                sxp_FnFree(pfStream);
                sxp_FnFree(pwszConvertedName);
                return -1;
            }

            pfStream->File.hFile = g_FileSystem->CreateFile(
                pwszTargetName, 
                GENERIC_READ | GENERIC_WRITE, 
                FILE_SHARE_READ, 
                NULL, 
                CREATE_NEW, 
                FILE_ATTRIBUTE_NORMAL, 
                NULL);

            sxp_FnFree(pwszConvertedName);

            return (INT_PTR)pfStream;
        }
        break;



    case fdintCLOSE_FILE_INFO:
        {
            PFDI_STREAM pfStream = (PFDI_STREAM)pfNotify->hf;
            BOOL fResult = FALSE;

            if (pfStream->ulType == FDI_THING_TYPE_FILE)
            {
                fResult = g_FileSystem->SetFileAttributes(
                    pfStream->File.pcwszPath,
                    pfNotify->attribs & ~(_A_NAME_IS_UTF | _A_EXEC)
                    );                    

                CloseHandle(pfStream->File.hFile);

                sxp_FnFree((PVOID)pfStream->File.pcwszPath);
            }

            sxp_FnFree((PVOID)pfStream);

            return fResult;
        }
        break;



    case fdintPARTIAL_FILE:
    case fdintNEXT_CABINET:
    case fdintENUMERATE:
    case fdintCABINET_INFO:
        return TRUE;
        break;
    }

    return -1;
}


BOOL
_FindAndMapResource(
    HMODULE hmModule,
    PCWSTR pcwszType,
    PCWSTR pcwszName,
    PVOID *ppvResourceData,
    DWORD *pcbResourceDataSize
    )
{
    HRSRC       hResource = NULL;
    HGLOBAL     gblResource = NULL;
    BOOL        fSuccess = FALSE;

    ASSERT(pcwszType != NULL);
    ASSERT(pcwszName != NULL);
    ASSERT(ppvResourceData != NULL);
    ASSERT(pcbResourceDataSize != NULL);

    if (!pcwszType || !pcwszName || !ppvResourceData || !pcbResourceDataSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // Find the resource
    //
    if (NULL == (hResource = g_FileSystem->FindResource(hmModule, pcwszName, pcwszType)))
    {
        goto Exit;
    }

    //
    // How large is it?
    //
    if (0 == (*pcbResourceDataSize = SizeofResource(hmModule, hResource)))
    {
        goto Exit;
    }

    //
    // Load the resource
    //
    if (NULL == (gblResource = LoadResource(hmModule, hResource)))
    {
        goto Exit;
    }

    //
    // Actually get the resource
    //
    if (NULL == (*ppvResourceData = LockResource(gblResource)))
    {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
    
}





BOOL
_ExpandCabinetToPath(
    PVOID pvCabinetData,
    DWORD dwCabinetData,
    PCWSTR pcwszOutputPath
    )
{
    HFDI            hfdiObject = NULL;
    ERF             FdiPerf;
    FDICABINETINFO  CabInfo;
    BOOL            fSuccess = FALSE;
    BOOL            fIsCabinet = FALSE;

    
    //
    // Create a pseudo-stream for the FDI interface
    //
    g_GlobalCopyContext.CoreCabinetStream.ulType = FDI_THING_TYPE_MEMSTREAM;
    g_GlobalCopyContext.CoreCabinetStream.MemoryStream.pvCursor = pvCabinetData;
    g_GlobalCopyContext.CoreCabinetStream.MemoryStream.pvResourceData = pvCabinetData;
    g_GlobalCopyContext.CoreCabinetStream.MemoryStream.pvResourceDataEnd = (PBYTE)pvCabinetData + dwCabinetData;
    g_GlobalCopyContext.pcwszTargetDirectory = pcwszOutputPath;

    //
    // Create the FDI decompression object
    //
    hfdiObject = FDICreate(
        sxp_FnAlloc,
        sxp_FnFree,
        sxp_FnOpen,
        sxp_FnRead,
        sxp_FnWrite,
        sxp_FnClose,
        sxp_FnSeek,
        cpuUNKNOWN,
        &FdiPerf);

    if (hfdiObject == NULL)
    {
        goto Exit;
    }

    //
    // See if the thing really is a cabinet
    //
    if (!FDIIsCabinet(hfdiObject, (INT_PTR)&g_GlobalCopyContext.CoreCabinetStream, &CabInfo))
    {
        SetLastError(FdiPerf.erfType);
        goto Exit;
    }

    //
    // Copy from the in-memory stream out to a temp path that we created
    //
    if (FDICopy(hfdiObject, "::", "::", 0, sxp_FdiNotify, NULL, NULL) == FALSE)
    {
        SetLastError(FdiPerf.erfType);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:

    if (hfdiObject != NULL)
    {
        const DWORD dw = GetLastError();
        FDIDestroy(hfdiObject);
        hfdiObject = NULL;
        SetLastError(dw);
    }

    return fSuccess;
}



#define MAX_RETRY_TEMP_PATH         (10)
#define TEMP_PATH_EXTRA_LENGTH      (23)

BOOL
_GenerateTempPath(
    PWSTR   pwszPath,
    PSIZE_T  pcchPath
    )
{
    DWORD   dwCharsUsed;
    BOOL    fSuccess = FALSE;

    //
    // Find the path that we'll be writing into
    //
    dwCharsUsed = g_FileSystem->GetTempPath((DWORD)*pcchPath, pwszPath);

    //
    // Error, stop.
    //
    if (dwCharsUsed == 0)
    {
        goto Exit;
    }
    //
    // Not enough space left at the end of the buffer.  We need to add:
    // \sxsexpress-ffffffff\, which is 21 characters (plus two for padding)
    //
    else if ((dwCharsUsed + TEMP_PATH_EXTRA_LENGTH) >= *pcchPath)
    {
        *pcchPath = dwCharsUsed + TEMP_PATH_EXTRA_LENGTH;

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //
    // Ensure that the path has a backslash at the end
    //
    if (pwszPath[dwCharsUsed - 1] != L'\\') {
        pwszPath[dwCharsUsed] = L'\\';
        pwszPath[dwCharsUsed+1] = UNICODE_NULL;
        dwCharsUsed++;
    }

    //
    // Randomize the value
    //
    srand(GetTickCount());

    //
    // At this point, we know that we've got enough space left over at the end of pwszPath
    // past dwCharssUsed to write in a ULONG (8 chars), based on the check above.  We
    // will simply write those with a cursor-based implementation (no checking of remaining
    // length) b/c it's simpler.
    //
    for (DWORD dw = 0; dw < MAX_RETRY_TEMP_PATH; dw++)
    {
        //
        // rand() is only between 0-0xFFFF, so we have to put two together
        // to get a ulong.
        //
        PWSTR pwszCursor = pwszPath + dwCharsUsed;
        ULONG ulRandom = ((rand() & 0xFFFF) << 16) | (rand() & 0xFFFF);

        wcscpy(pwszCursor, L"sxspress-");
        pwszCursor += NUMBER_OF(L"sxsexpress-") - 1;

        //
        // Turn that into a number
        for (int i = 0; i < 8; i++)
        {
            const nibble = (ulRandom & 0xF0000000) >> 28;
            ulRandom = ulRandom << 4;

            if (nibble < 0xA)
                *pwszCursor = L'0' + nibble;
            else
                *pwszCursor = L'A' + (nibble - 0xA);

            pwszCursor++;
        }

        dwCharsUsed += 8;

        //
        // Add a slash, NULL-terminate (that's two characters)
        //
        *pwszCursor++ = L'\\';
        *pwszCursor = UNICODE_NULL;
        dwCharsUsed += 2;

        //
        // Record how many chars we used
        //
        *pcchPath = dwCharsUsed;

        fSuccess = g_FileSystem->CreateDirectory(pwszPath, NULL);    

        if (fSuccess)
        {
            break;
        }
        else if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            break;
        }

    }

Exit:
    return fSuccess;
}


BOOL
_DoUplevelInstallation(
    BOOL (WINAPI* pfnSxsInstallW)(PSXS_INSTALLW lpInstall),
    PCWSTR pcwszBasePath
    )
{
    SXS_INSTALLW Install = { sizeof(Install) };
    BOOL fSuccess = FALSE;

    Install.dwFlags = 
        SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
        SXS_INSTALL_FLAG_MOVE;

    Install.lpManifestPath = pcwszBasePath;
    Install.lpCodebaseURL = L"SxsExpress";

    if (!pfnSxsInstallW(&Install)) {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



BOOL
OpenAndMapManifest(
    PCWSTR pcwszPath,
    HANDLE &rFileHandle,
    HANDLE &rFileMapping,
    PVOID &rpvData,
    DWORD &rdwFileSize
    )
{
    BOOL fSuccess = FALSE;

    rFileHandle = rFileMapping = INVALID_HANDLE_VALUE;
    rdwFileSize = 0;
    rpvData = NULL;

    rFileHandle = g_FileSystem->CreateFile(pcwszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if ((rFileHandle == INVALID_HANDLE_VALUE) || (rFileHandle == NULL))
        goto Exit;

    rdwFileSize = GetFileSize(rFileHandle, NULL);
    if ((rdwFileSize == 0) && (GetLastError() != ERROR_SUCCESS))
        goto Exit;


    rFileMapping = g_FileSystem->CreateFileMapping(rFileHandle, NULL, PAGE_READONLY, 0, rdwFileSize, NULL);
    if ((rFileMapping == INVALID_HANDLE_VALUE) || (rFileMapping == NULL))
        goto Exit;

    rpvData = MapViewOfFile(rFileMapping, FILE_MAP_READ, 0, 0, rdwFileSize);
    if (rpvData == NULL)
        goto Exit;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        if (rFileHandle != INVALID_HANDLE_VALUE)
        {
            CloseHandle(rFileHandle);
            rFileHandle = INVALID_HANDLE_VALUE;
        }

        if (rFileMapping != INVALID_HANDLE_VALUE)
        {
            CloseHandle(rFileMapping);
            rFileMapping = INVALID_HANDLE_VALUE;
        }

        if (rpvData != NULL)
        {
            UnmapViewOfFile(rpvData);
            rpvData = NULL;
        }
    }

    return fSuccess;
}


#define DEFAULT_DOWNLEVEL_PATH      (L"%windir%\\MsiAsmCache")


BOOL
CreateDownlevelPath(
    PWSTR pwszPathTarget,
    DWORD cchPathTarget,
    PCWSTR pcwszLeafName
    )
{
    WCHAR wchLoadable[MAX_PATH*2];

    UINT uiUsed;

    //
    // Found something in the resource table that we should use?
    //
    uiUsed = g_FileSystem->LoadString(g_hInstOfResources, SXSEXPRESS_TARGET_RESOURCE, wchLoadable, NUMBER_OF(wchLoadable));

    //
    // String not found, use the default
    //
    if (uiUsed == 0)
    {
        wcscpy(wchLoadable, DEFAULT_DOWNLEVEL_PATH);
        uiUsed = wcslen(wchLoadable);
    }

    //
    // Null terminate, in case the loader decided not to
    //
    wchLoadable[uiUsed] = UNICODE_NULL;

    //
    // Expand env strings
    //
    if ((uiUsed = g_FileSystem->ExpandEnvironmentStrings(wchLoadable, pwszPathTarget, cchPathTarget)) == 0)
    {
        return FALSE;
    }
    //
    // Adjust back by one, that included the chars for the trailing null
    //
    else
    {
        uiUsed--;
    }

    if (pwszPathTarget[uiUsed] != L'\\') {
        pwszPathTarget[uiUsed++] = L'\\';
    }

    pwszPathTarget[uiUsed] = UNICODE_NULL;

    //
    // Create pwszPathTarget (where we'll be copying files to)
    //
    wcscat(pwszPathTarget, pcwszLeafName);
    CreatePath(L"", pwszPathTarget, TRUE);
    wcscat(pwszPathTarget, L"\\");

    return TRUE;
}



BOOL
DownlevelInstallPath(
    PWSTR pwszWorkPath,
    SIZE_T cchWorkPath,
    PCWSTR pcwszLeafName
    )
{
    CHAR    chIdentityBuffer[MAX_PATH];
    BOOL    fSuccess            = FALSE;
    PVOID   pvMappedFile        = NULL;
    DWORD   dwFileSize          = 0;
    SIZE_T  cchIdentityPath     = NUMBER_OF(chIdentityBuffer);
    SIZE_T  cch                 = wcslen(pwszWorkPath);
    SIZE_T  cchIdentity         = 0;
    SIZE_T  cchTempPath         = 0;
    PWSTR   pwszIdentityPath    = NULL;
    HANDLE  hFile               = INVALID_HANDLE_VALUE;
    HANDLE  hFileMapping        = INVALID_HANDLE_VALUE;
    WCHAR   wchTempPath[MAX_PATH*2];

    //
    // First, get the manifest that we're installing from
    //
    if ((cch + 4 + wcslen(pcwszLeafName) + 1) > cchWorkPath)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    wcscat(pwszWorkPath, pcwszLeafName);
    wcscat(pwszWorkPath, L".man");

    if (!OpenAndMapManifest(pwszWorkPath, hFile, hFileMapping, pvMappedFile, dwFileSize))
    {
        wcscat(pwszWorkPath, L"ifest");

        if (!OpenAndMapManifest(pwszWorkPath, hFile, hFileMapping, pvMappedFile, dwFileSize))
        {
            goto Exit;
        }
    }

    //
    // Now let's do some work - find the identity of the assembly, for starters.  Then
    // we'll look at it for the file entries.
    //
    if (!SxsIdentDetermineManifestPlacementPathEx(0, pvMappedFile, dwFileSize, chIdentityBuffer, &cchIdentityPath))
    {
        goto Exit;
    }

    //
    // Convert that back into a unicode string.
    //
    if (NULL == (pwszIdentityPath = ConvertString(chIdentityBuffer, FALSE)))
    {
        goto Exit;
    }

    //
    // Get the length of the generated path
    //
    cchIdentity = wcslen(pwszIdentityPath);

    //
    // Get where we're supposed to be putting these files
    //
    if (!CreateDownlevelPath(wchTempPath, NUMBER_OF(wchTempPath), pwszIdentityPath))
        goto Exit;

    cchTempPath = wcslen(wchTempPath);

    //
    // Do we have enough space to work with?
    //
    if ((cchTempPath + 4 + cchIdentity + 1) > NUMBER_OF(wchTempPath))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //
    // Cons up the target manifest name, copy it over, then clip off the generated
    // path
    //
    wcscat(wcscpy(wchTempPath + cchTempPath, pwszIdentityPath), L".man");

    if (!g_FileSystem->CopyFile(pwszWorkPath, wchTempPath, FALSE) && (GetLastError() != ERROR_FILE_EXISTS))
        goto Exit;

    wchTempPath[cchTempPath] = UNICODE_NULL;

    //
    // Do the same for the catalog, but first swizzle the .man to a .cat
    //
    wcscpy(wcsrchr(pwszWorkPath, L'.'), L".cat");
    wcscat(wcscpy(wchTempPath + cchTempPath, pwszIdentityPath), L".cat");

    if (!g_FileSystem->CopyFile(pwszWorkPath, wchTempPath, FALSE) && (GetLastError() != ERROR_FILE_EXISTS))
        goto Exit;

    wchTempPath[cchTempPath] = UNICODE_NULL;

    //
    // Trim back to source path
    //
    pwszWorkPath[cch] = UNICODE_NULL;

    //
    // And have someone do the file copies for us
    //
    if (!DoFileCopies(pvMappedFile, dwFileSize, pwszWorkPath, wchTempPath))
        goto Exit;


    fSuccess = TRUE;
Exit:
    if (pwszIdentityPath != NULL) 
        sxp_FnFree((PVOID)pwszIdentityPath);

    if (pvMappedFile != NULL)
        UnmapViewOfFile(pvMappedFile);

    if (hFileMapping != INVALID_HANDLE_VALUE)
        CloseHandle(hFileMapping);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return fSuccess;
}


static NTSTATUS
_CompareStrings(
    PVOID pvContext,
    PCXML_EXTENT pLeft,
    PCXML_EXTENT pRight,
    XML_STRING_COMPARE *pfMatches
    )
{
    PXML_LOGICAL_STATE pState = (PXML_LOGICAL_STATE)pvContext;
    NTSTATUS status;
    XML_STRING_COMPARE Compare;

    status = pState->ParseState.pfnCompareStrings(
        &pState->ParseState,
        const_cast<PXML_EXTENT>(pLeft),
        const_cast<PXML_EXTENT>(pRight),
        pfMatches);

    return status;
}


BOOL
CopySingleFile(
    PCWSTR pcwszSourcePath,
    PCWSTR pcwszTargetPath,
    PCWSTR pcwszFileName
    )
{
    PWSTR pwszSourceName = NULL;
    PWSTR pwszTargetName = NULL;
    BOOL fSuccess = FALSE;

    pwszSourceName = (PWSTR)sxp_FnAlloc(sizeof(WCHAR) * (wcslen(pcwszSourcePath) + 1 + wcslen(pcwszFileName) + 1));
    pwszTargetName = (PWSTR)sxp_FnAlloc(sizeof(WCHAR) * (wcslen(pcwszTargetPath) + 1 + wcslen(pcwszFileName) + 1));

    if (!pwszSourceName || !pwszTargetName)
    {
        goto Exit;
    }

    wcscat(wcscat(wcscpy(pwszSourceName, pcwszSourcePath), L"\\"), pcwszFileName);
    wcscat(wcscat(wcscpy(pwszTargetName, pcwszTargetPath), L"\\"), pcwszFileName);

    //
    // Ensure that the target path exists
    //
    if (!CreatePath(L"", pcwszTargetPath, FALSE))
        goto Exit;

    if (!g_FileSystem->CopyFile(pwszSourceName, pwszTargetName, FALSE))
        goto Exit;

    fSuccess = TRUE;
Exit:
    if (pwszSourceName) {
        sxp_FnFree((PVOID)pwszSourceName);
    }

    if (pwszTargetName) {
        sxp_FnFree((PVOID)pwszTargetName);
    }

    return fSuccess;
}


#define MAKE_SPECIAL(q) { L ## q, NUMBER_OF(L##q) - 1 }
static XML_SPECIAL_STRING FileTagName       = MAKE_SPECIAL("file");
static XML_SPECIAL_STRING FileNameAttribute = MAKE_SPECIAL("name");
static XML_SPECIAL_STRING AsmNamespace      = MAKE_SPECIAL("urn:schemas-microsoft-com:asm.v1");

BOOL
DoFileCopies(
    PVOID pvFileData,
    DWORD dwFileSize,
    PCWSTR pwszSourcePath,
    PCWSTR pwszTargetPath
    )
{
    NTSTATUS                status = STATUS_SUCCESS;
    NS_MANAGER              Namespaces;
    XMLDOC_THING            Found;
    RTL_GROWING_LIST        AttribList;
    XML_LOGICAL_STATE       ParseState;
    XML_STRING_COMPARE      fMatching;
    WCHAR                   wchDownlevelDumpPath[MAX_PATH];

    g_FileSystem->ExpandEnvironmentStrings(L"%windir%\\system32", wchDownlevelDumpPath, NUMBER_OF(wchDownlevelDumpPath));

    status = RtlInitializeGrowingList(&AttribList, sizeof(XMLDOC_ATTRIBUTE), 20, NULL, 0, &g_ExpressAllocator);

    if (!NT_SUCCESS(status))
        return FALSE;

    status = RtlXmlInitializeNextLogicalThing(
        &ParseState, 
        pvFileData, dwFileSize,
        &g_ExpressAllocator);

    if (!NT_SUCCESS(status))
        return FALSE;

    status = RtlNsInitialize(&Namespaces, _CompareStrings, &ParseState, &g_ExpressAllocator);

    if (!NT_SUCCESS(status))
        return FALSE;

    //
    // Gather 'file' entries.  They're at depth 1
    //
    while (TRUE)
    {
        PXMLDOC_ATTRIBUTE Attribute = 0;

        status = RtlXmlNextLogicalThing(&ParseState, &Namespaces, &Found, &AttribList);

        //
        // Error, or end of file - stop
        //
        if (!NT_SUCCESS(status) ||
            (Found.ulThingType == XMLDOC_THING_ERROR) ||
            (Found.ulThingType == XMLDOC_THING_END_OF_STREAM))
        {
            break;
        }

        //
        // Document depth 1 (file depth) and elements only, please
        //
        if ((Found.ulDocumentDepth != 1) || (Found.ulThingType != XMLDOC_THING_ELEMENT))
            continue;

        //
        // If this is a 'file' element in our namespace, then process it
        //
        status = ParseState.ParseState.pfnCompareSpecialString(
            &ParseState.ParseState,
            &Found.Element.NsPrefix,
            &AsmNamespace,
            &fMatching);

        //
        // On error, stop - on mismatch, continue
        //
        if (!NT_SUCCESS(status))
            break;
        else if (fMatching != XML_STRING_COMPARE_EQUALS)
            continue;

        status = ParseState.ParseState.pfnCompareSpecialString(
            &ParseState.ParseState,
            &Found.Element.Name,
            &FileTagName,
            &fMatching);

        if (!NT_SUCCESS(status))
            break;
        else if (fMatching != XML_STRING_COMPARE_EQUALS)
            continue;

        //
        // Great, we need to find out the filename part of this tag
        //
        for (ULONG u = 0; u < Found.Element.ulAttributeCount; u++)
        {
            //
            // Look at this one - is it what we're looking for?
            //
            status = RtlIndexIntoGrowingList(&AttribList, u, (PVOID*)&Attribute, FALSE);
            if (!NT_SUCCESS(status))
                break;

            status = ParseState.ParseState.pfnCompareSpecialString(
                &ParseState.ParseState,
                &Attribute->Name,
                &FileNameAttribute,
                &fMatching);

            //
            // Found, stop looking
            //
            if (fMatching == XML_STRING_COMPARE_EQUALS)
                break;
            else
                Attribute = NULL;
        }

        if (!NT_SUCCESS(status))
            break;

        //
        // We found the 'name' attribute!
        //
        if (Attribute != NULL)
        {
            WCHAR wchInlineBuffer[MAX_PATH/2];
            SIZE_T cchBuffer = NUMBER_OF(wchInlineBuffer);
            SIZE_T cchRequired;
            PWSTR pwszBuffer = wchInlineBuffer;

            status = RtlXmlCopyStringOut(
                &ParseState.ParseState, 
                &Attribute->Value,
                pwszBuffer,
                &(cchRequired = cchBuffer));

            if ((status == STATUS_BUFFER_TOO_SMALL) || ((cchRequired + 1) >= cchBuffer))
            {
                cchBuffer += 10;
                pwszBuffer = (PWSTR)HeapAlloc(GetProcessHeap(), 0, (cchBuffer * sizeof(WCHAR)));

                if (pwszBuffer)
                {
                    status = RtlXmlCopyStringOut(
                        &ParseState.ParseState,
                        &Attribute->Value,
                        pwszBuffer,
                        &(cchRequired = cchBuffer));
                }
            }

            pwszBuffer[cchRequired] = UNICODE_NULL;

            //
            // Go copy
            //
            if (NT_SUCCESS(status))
            {
                if (!CopySingleFile(pwszSourcePath, pwszTargetPath, pwszBuffer))
                    status = STATUS_UNSUCCESSFUL;
                else
                {
                    if (!CopySingleFile(pwszSourcePath, wchDownlevelDumpPath, pwszBuffer))
                        status = STATUS_UNSUCCESSFUL;
                }
            }

            //
            // If we allocated, free
            //
            if (pwszBuffer && (pwszBuffer != wchInlineBuffer))
                HeapFree(GetProcessHeap(), 0, (PVOID)pwszBuffer);

            //
            // Something broke, stop
            //
            if (!NT_SUCCESS(status))
                break;
        }
    }

    RtlDestroyGrowingList(&AttribList);
    RtlNsDestroy(&Namespaces);
    RtlXmlDestroyNextLogicalThing(&ParseState);

    return NT_SUCCESS(status);
}




BOOL
_DoDownlevelInstallation(
    PCWSTR pcwszPath
    )
{
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindData = {0};
    WCHAR wchPath[MAX_PATH*2];
    SIZE_T cchBasePath;
    BOOL fSuccess = FALSE;
    DWORD dwError = 0;

    //
    // Is the input path too long?  Hmm...  I suppose we should really have done something
    // in this case, but it's easier just to fail out for the time being.  Also have to
    // have enough space to add a slash, *.*, and another slash.
    //
    if (((cchBasePath = wcslen(pcwszPath)) >= NUMBER_OF(wchPath)) ||
        ((cchBasePath + 2 + 3 + 1) >= NUMBER_OF(wchPath)))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    
    //
    // It fits, copy over
    //
    wcsncpy(wchPath, pcwszPath, NUMBER_OF(wchPath));

    //
    // If the path has data, and the last thing in the path isn't a slash, then
    // see if we've got space to add one, and add it.
    //
    if (cchBasePath && (wchPath[cchBasePath - 1] != L'\\'))
    {
        //
        // We know we've got enough space to add on the slash, cause we found out above
        //
        wchPath[cchBasePath] = L'\\';
        wchPath[++cchBasePath] = UNICODE_NULL;
    }

    //
    // We've got the space to add *.*
    //
    wcscat(wchPath, L"*.*");

    //
    // Start looking for files with that name
    //
    hFindFile = g_FileSystem->FindFirst(wchPath, &FindData);

    //
    // Great - found one, start looping
    //
    if (hFindFile != INVALID_HANDLE_VALUE) do
    {
        wchPath[cchBasePath] = UNICODE_NULL;

        if (((FindData.cFileName[0] == '.') && (FindData.cFileName[1] == UNICODE_NULL)) ||
            ((FindData.cFileName[0] == '.') && (FindData.cFileName[1] == '.') && (FindData.cFileName[2] == UNICODE_NULL)))
        {
            continue;
        }
        else if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            continue;
        }

        //
        // Enough space?
        //
        if ((cchBasePath + 1 + wcslen(FindData.cFileName)) >= NUMBER_OF(wchPath))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        //
        // Yes, add these two (note the use of the base-path-length offset, as that should
        // speed up the scan for the end-of-string in wcscpy and wcscat.
        //
        wcscpy(wchPath + cchBasePath, FindData.cFileName);
        wcscat(wchPath + cchBasePath, L"\\");

        //
        // Go do the installation
        //
        if (!DownlevelInstallPath(wchPath, NUMBER_OF(wchPath), FindData.cFileName))
            break;
    }
    while (g_FileSystem->FindNext(hFindFile, &FindData));

    if ((GetLastError() != ERROR_NO_MORE_FILES) && (GetLastError() != ERROR_SUCCESS))
    {
        goto Exit;
    }

    //
    // Now that we've done the "installation" step of copying into the MSI ASM cache, we
    // can go do the KinC installer thingy to actually shoof files into system32 or
    // wherever they'd like to go.
    //
    _snwprintf(wchPath, NUMBER_OF(wchPath), L"install-silent;\"%ls\\%s\";", pcwszPath, INF_SPECIAL_NAME);
    MsInfHelpEntryPoint(g_hInstOfResources, NULL, wchPath, SW_HIDE);

    fSuccess = TRUE;
Exit:

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        g_FileSystem->FindClose(hFindFile);
        hFindFile = INVALID_HANDLE_VALUE;
    }

    return fSuccess;
}



BOOL
CleanupTempPathWorker(
    PWSTR pwszPathToKill,
    SIZE_T cchThisPath,
    SIZE_T cchTotalPathToKill
    )
{
    PWSTR pwszOurPath = pwszPathToKill;
    SIZE_T cchOurPath = cchTotalPathToKill;
    BOOL fSuccess = FALSE;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    static WIN32_FIND_DATAW sFindData = {0};

    if (cchThisPath == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // If there's not enough space for at least \*.*, resize to
    // have another MAX_PATH at the end
    //
    if ((cchThisPath + 5) >= cchOurPath)
    {
        PWSTR pwszTemp = (PWSTR)sxp_FnAlloc(sizeof(WCHAR) * (cchTotalPathToKill + MAX_PATH));

        //
        // Failure?  Ack.
        //
        if (!pwszTemp)
            goto Exit;

        //
        // Set these up, copy contents along the way
        //
        wcscpy(pwszTemp, pwszOurPath);
        pwszOurPath = pwszTemp;
        cchOurPath = cchTotalPathToKill + MAX_PATH;
    }

    //
    // Slash-append - we know we've got space for this
    //
    if (pwszOurPath[cchThisPath - 1] != L'\\')
    {
        pwszOurPath[cchThisPath] = L'\\';
        pwszOurPath[++cchThisPath] = UNICODE_NULL;
    }

    //
    // Append *.* - we've also got space for this as well
    wcscat(pwszOurPath, L"*.*");
    hFindFile = g_FileSystem->FindFirst(pwszOurPath, &sFindData);
    pwszOurPath[cchThisPath] = UNICODE_NULL;

    if (hFindFile != INVALID_HANDLE_VALUE) do
    {
        SIZE_T cchName;

        //
        // Skip dot and dotdot
        if (((sFindData.cFileName[0] == L'.') && (sFindData.cFileName[1] == UNICODE_NULL)) ||
            ((sFindData.cFileName[0] == L'.') && (sFindData.cFileName[1] == L'.') && (sFindData.cFileName[2] == UNICODE_NULL)))
        {
            continue;
        }

        cchName = wcslen(sFindData.cFileName);

        //
        // Ensure we've got space to add the filename string onto the current buffer, resize if not
        //
        if ((cchName + cchThisPath) >= cchOurPath)
        {
            SIZE_T cchTemp = cchName + cchThisPath + MAX_PATH;
            PWSTR pwszTemp = (PWSTR)sxp_FnAlloc(sizeof(WCHAR) * cchTemp);

            if (!pwszTemp)
                goto Exit;

            wcscpy(pwszTemp, pwszOurPath);
            
            //
            // If the current path buffer isn't the one we were passed, kill it
            //
            if (pwszOurPath && (pwszOurPath != pwszPathToKill))
            {
                sxp_FnFree((PVOID)pwszOurPath);
            }

            //
            // Swizzle pointers
            //
            pwszOurPath = pwszTemp;
            cchOurPath = cchTemp;
        }

        //
        // Now that we've got enough space, copy it over
        //
        wcscat(pwszOurPath, sFindData.cFileName);

        //
        // Recurse down
        //
        if (sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            CleanupTempPathWorker(pwszOurPath, cchThisPath + cchName, cchOurPath);
            g_FileSystem->RemoveDirectory(pwszOurPath);
        }
        //
        // Delete the file
        //
        else
        {
            g_FileSystem->SetFileAttributes(pwszOurPath, FILE_ATTRIBUTE_NORMAL);
            g_FileSystem->DeleteFile(pwszOurPath);
        }

        pwszOurPath[cchThisPath] = UNICODE_NULL;
    }
    while (g_FileSystem->FindNext(hFindFile, &sFindData));

    if (GetLastError() != ERROR_NO_MORE_FILES)
        goto Exit;

    fSuccess = TRUE;

Exit:
    if (hFindFile != INVALID_HANDLE_VALUE)
        g_FileSystem->FindClose(hFindFile);

    if (pwszOurPath && (pwszOurPath != pwszPathToKill))
    {
        sxp_FnFree((PVOID)pwszOurPath);
    }

    return fSuccess;
}




BOOL
_CleanupTempPath(
    PCWSTR pcwszPathToKill
    )
{
    WCHAR wchBuffer[MAX_PATH * 2];
    PWSTR pwszWorker = wchBuffer;
    SIZE_T cchWorker = NUMBER_OF(wchBuffer);
    BOOL fSuccess = TRUE;

    //
    // Non-empty paths, please
    //
    if (pcwszPathToKill[0] == UNICODE_NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // There should be enough in the initial buffer to handle two max-path length
    // path names.  If not, allocate more.
    //
    if ((SIZE_T)(wcslen(pcwszPathToKill) + MAX_PATH) >= cchWorker)
    {
        cchWorker = wcslen(pcwszPathToKill) + MAX_PATH;
        pwszWorker = (PWSTR)sxp_FnAlloc(static_cast<ULONG>(cchWorker * sizeof(WCHAR)));

        if (!pwszWorker)
            goto Exit;
    }

    //
    // Set up the initial path.  The worker ensures that its parameter is
    // slash-terminated
    //
    wcscpy(pwszWorker, pcwszPathToKill);

    if (!CleanupTempPathWorker(pwszWorker, wcslen(pwszWorker), cchWorker))
        goto Exit;

    g_FileSystem->RemoveDirectory(pwszWorker);

    fSuccess = TRUE;
Exit:
    if (pwszWorker && (pwszWorker != wchBuffer))
    {
        sxp_FnFree((PVOID)pwszWorker);
    }

    return fSuccess;
}




BOOL
SxsExpressRealInstall(
    HMODULE hmModule
    )
{
    BOOL        fResult = FALSE;
    DWORD       dwCabinetSize = 0;
    PVOID       pvCabinetData = NULL;
    HMODULE     hmSxs = NULL;

    WCHAR       wchDecompressPath[MAX_PATH];
    PWSTR       pwszDecompressPath = wchDecompressPath;
    SIZE_T      cchDecompressPath = NUMBER_OF(wchDecompressPath);

    DWORD       dwCount;
    BOOL        (WINAPI *pfnSxsInstallW)(PSXS_INSTALLW lpInstall) = NULL;

    if (!_FindAndMapResource(hmModule, SXSEXPRESS_RESOURCE_TYPE, SXSEXPRESS_RESOURCE_NAME, &pvCabinetData, &dwCabinetSize))
    {
        goto Exit;
    }

    ASSERT(pvCabinetData != NULL);
    ASSERT(dwCabinetSize != NULL);

    if (!_GenerateTempPath(pwszDecompressPath, &cchDecompressPath))
    {
        //
        // Something else happened
        //
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Exit;
        }

        cchDecompressPath++;

        pwszDecompressPath = (PWSTR)HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * cchDecompressPath);

        if (!pwszDecompressPath)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        if (!_GenerateTempPath(pwszDecompressPath, &cchDecompressPath))
        {
            goto Exit;
        }
    }

    //
    // Do the install to there
    //
    if (!_ExpandCabinetToPath(pvCabinetData, dwCabinetSize, pwszDecompressPath))
    {
        goto Exit;
    }

    //
    // Now let's install from that path
    //
    hmSxs = LoadLibraryA(SXS_DLL_NAME_A);

    if (hmSxs != NULL)
    {
        *((FARPROC*)&pfnSxsInstallW) = GetProcAddress(hmSxs, "SxsInstallW");
    }

    if (pfnSxsInstallW != NULL)
    {
        _DoDownlevelInstallation(pwszDecompressPath);
    }
    else
    {
        _DoUplevelInstallation(pfnSxsInstallW, pwszDecompressPath);
    }

    //
    // And clean it all up
    //
    if (!_CleanupTempPath(pwszDecompressPath))
    {
        goto Exit;
    }


Exit:
    if (hmSxs != NULL)
    {
        FreeLibrary(hmSxs);
    }

    return fResult;

}


class CKernel32SxsApis 
{
public:
    bool fSxsOk;
    HANDLE (WINAPI *m_pfnCreateActCtxW)(PCACTCTXW);
    VOID (WINAPI *m_pfnReleaseActCtxW)(HANDLE);
    BOOL (WINAPI *m_pfnActivateActCtx)(HANDLE, ULONG_PTR*);
    BOOL (WINAPI *m_pfnDeactivateActCtx)(DWORD, ULONG_PTR);

    CKernel32SxsApis()
        : fSxsOk(true),
          m_pfnCreateActCtxW(NULL),
          m_pfnReleaseActCtxW(NULL),
          m_pfnActivateActCtx(NULL),
          m_pfnDeactivateActCtx(NULL)
    {
    }
};


BOOL CALLBACK
SxsPostInstallCallback(
    HMODULE hm, 
    LPCWSTR pcwszType, 
    LPWSTR pwszName, 
    LONG_PTR lParam
    )
{
    BOOL fSuccess = FALSE;
    PCWSTR pcwszInstallStepData = NULL;
    PCWSTR pcwszAssemblyIdentity, pcwszDllName, pcwszParameters;
    DWORD dwStepDataLength = 0;
    CKernel32SxsApis *pHolder = (CKernel32SxsApis*)lParam;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    ACTCTXW ActCtxCreation = {sizeof(ActCtxCreation)};
    ULONG_PTR ulpCookie;
    bool fActivated = false;

    // Load the resource string.
    if (!_FindAndMapResource(hm, pcwszType, pwszName, (PVOID*)&pcwszInstallStepData, &dwStepDataLength))
    {
        goto Exit;
    }

    // String was too short... Skip this instruction.
    if (dwStepDataLength < 3) 
    {
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // Point the various bits of the instruction at the right places.
    //
    pcwszAssemblyIdentity = pcwszInstallStepData;
    pcwszDllName = pcwszAssemblyIdentity + wcslen(pcwszAssemblyIdentity) + 1;
    pcwszParameters = pcwszDllName + wcslen(pcwszDllName) + 1;

    //
    // No assembly identity, or no DLL name?  Oops.
    //
    if (!*pcwszAssemblyIdentity || !*pcwszDllName) 
    {
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // If our pHolder has its stuff initialized, then we can go and create activation contexts
    // before loading the DLL
    //
    if (pHolder->fSxsOk)
    {
        ActCtxCreation.dwFlags = ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF;
        ActCtxCreation.lpSource = pcwszAssemblyIdentity;
        hActCtx = pHolder->m_pfnCreateActCtxW(&ActCtxCreation);
    }

    //
    // Wrap our activation and usage of this in a try/finally to ensure that
    // we clean up the activation context stack properly.
    //
    __try
    {
        HMODULE hmTheDll = NULL;
        
        //
        // Only activate if we've created an actctx and we can actually activate
        //
        if (pHolder->m_pfnActivateActCtx && (hActCtx != INVALID_HANDLE_VALUE))
        {
            if (pHolder->m_pfnActivateActCtx(hActCtx, &ulpCookie))
            {
                fActivated = true;
            }            
        }

        //
        // Load the library, which we should have either put in system32, or we'll
        // find via sxs redirection
        // 
        if (NULL != (hmTheDll = g_FileSystem->LoadLibrary(pcwszDllName)))
        {
            typedef HRESULT (STDAPICALLTYPE *t_pfnDllInstall)(BOOL, LPCWSTR);
            t_pfnDllInstall pfnDllInstall = NULL;

            //
            // We hardcode usage of 'dllinstall' here, because we want this to be
            // difficult, and we want it to mirror the normal installation process.
            // Get the entrypoint, and then call off to it with the parameters that
            // we were passed.
            //
            if (NULL != (pfnDllInstall = (t_pfnDllInstall)GetProcAddress(hmTheDll, "DllInstall")))
            {
                pfnDllInstall(TRUE, pcwszParameters);
            }

            FreeLibrary(hmTheDll);
        }
        
    }
    __finally
    {
        if (fActivated)
        {
            pHolder->m_pfnDeactivateActCtx(0, ulpCookie);
            fActivated = false;
        }
    }
    

    fSuccess = TRUE;
Exit:
    if (hActCtx != INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = GetLastError();
        pHolder->m_pfnReleaseActCtxW(hActCtx);
        hActCtx = INVALID_HANDLE_VALUE;
        SetLastError(dwLastError);
    }
    return fSuccess;
}


//
// Post-installation, we can do some work to call DLL installation services,
// but it's intended to be painful for our clients.  DO NOT attempt to make
// this more painless, because we want this to be a very rare case.
//
BOOL
SxsExpressPostInstallSteps(
    HINSTANCE hInstOfResources
    )
{
    //
    // 1. Find instructions in our resources.  They're of type SXSEXPRESS_POSTINSTALL_STEP_TYPE,
    //      and are comprised of a multi-string like "identity\0dllname\0params"
    // 2. If we're on a sxs-aware platform, we'll go and CreateActCtxW on the identity we're
    //      passed, then loadlibrary the dll named, find DllInstall, and pass it the
    //      parameter list.
    //

    CKernel32SxsApis OurApis;
    HMODULE hmKernel32 = g_FileSystem->LoadLibrary(L"kernel32.dll");

    //
    // Get some exported functions.  If they're all present, then we can do sthe sxs apis
    //
    *((FARPROC*)&OurApis.m_pfnActivateActCtx) = (FARPROC)GetProcAddress(hmKernel32, "ActivateActCtx");
    *((FARPROC*)&OurApis.m_pfnCreateActCtxW) = (FARPROC)GetProcAddress(hmKernel32, "CreateActCtxW");
    *((FARPROC*)&OurApis.m_pfnReleaseActCtxW) = (FARPROC)GetProcAddress(hmKernel32, "ReleaseActCtx");
    *((FARPROC*)&OurApis.m_pfnDeactivateActCtx) = (FARPROC)GetProcAddress(hmKernel32, "DeactivateActCtx");

    OurApis.fSxsOk = 
        OurApis.m_pfnActivateActCtx &&
        OurApis.m_pfnDeactivateActCtx &&
        OurApis.m_pfnCreateActCtxW &&
        OurApis.m_pfnReleaseActCtxW;
    
    g_FileSystem->EnumResourceNames(
        hInstOfResources, 
        SXSEXPRESS_POSTINSTALL_STEP_TYPE, 
        SxsPostInstallCallback, 
        (LONG_PTR)&OurApis);

    return TRUE;
}




BOOL
SxsExpressCore(
    HINSTANCE hInstOfResources
    )
{
    BOOL fResult = FALSE;
    CNtFileSystemBase FileSystemNT;
    CWin9xFileSystemBase FileSystem9x;

    //
    // If this parameter was NULL, then get the current EXE's handle instead
    //
    if (hInstOfResources == NULL)
    {
        if (NULL == (hInstOfResources = GetModuleHandleA(NULL)))
        {
            goto Exit;
        }
    }

    g_FileSystem = (GetVersion() & 0x80000000) 
        ? static_cast<CFileSystemBase*>(&FileSystem9x) 
        : static_cast<CFileSystemBase*>(&FileSystem9x);

    if (!g_FileSystem->Initialize())
    {
        goto Exit;
    }


    g_hInstOfResources = hInstOfResources;

    if (!SxsExpressRealInstall(hInstOfResources))
    {
        goto Exit;
    }


    if (!SxsExpressPostInstallSteps(hInstOfResources))
    {
        goto Exit;
    }

    fResult = TRUE;
Exit:
    return fResult;
}


//
// Ick, I can't believe we have to provide this.
//
void
DbgBreakPoint()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\stablizeexports\stabilizeexports.cpp ===
/*
This program stabilizes exports by creating stubs
that jump to the actual exports, and makes these stubs the exports.

It is assumed that the stubs will end up at the front of the image.

This tool uses Vulcan, http://vulcan
*/
#include "stdinc.h" /* from resourcetool */
#include "yvals.h"
#pragma warning(disable:4100) /* unused parameter */
#pragma warning(disable:4663) /* warning in std headers about language change */
#pragma warning(disable:4511) /* warning in std headers about inability to generate function */
#pragma warning(disable:4512) /* warning in std headers about inability to generate function */
#include <stdio.h>
#include <limits.h>
#include <string>
#include <stdarg.h>
#include "vulcanapi.h"
#include "windows.h"
#include "handle.h" /* from resourcetool */
#define FormatError _snprintf
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
static const char File[] = __FILE__;

class String : public std::string
{
    typedef std::string Base;
public:
    ~String() { }
    String() { }
    String(const char * s) : Base(s) { }
    String(const String & s) : Base(s) { }
    String(const Base & s) : Base(s) { }
    String(const_iterator i, const_iterator j) : Base(i, j) { }
    void operator=(const Base & s) { Base::operator=(s); }
    void operator=(const char * s) { Base::operator=(s); }
    operator const char * () const { return c_str(); }
};

void __cdecl Error(const char * format, ...)
{
    va_list args;

    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    abort();
}

void ResourceToolAssertFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "ASSERTION FAILURE: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

bool FileExists(const char * s)
{
    DWORD dw;

    dw = GetFileAttributesA(s);
    if (dw == 0xFFFFFFFF)
        return false;
    if (dw & FILE_ATTRIBUTE_DIRECTORY)
        return false;
    return true;
}

bool IsDotOrDotDot(const wchar_t* s) { return (s[0] == '.' && ((s[1] == 0) || (s[1] == '.' && s[2] == 0))); }
bool IsDotOrDotDot(const  char  * s) { return (s[0] == '.' && ((s[1] == 0) || (s[1] == '.' && s[2] == 0))); }

String AppendPathElement(const String & s, const String & t)
{
    return s + "\\" + t;
}

String GetLastPathElement(const String & s)
{
    String::const_iterator LastSlash;
    int ch;
    const String::const_iterator begin = s.begin();
    const String::const_iterator end = s.end();

    for (LastSlash = end ; LastSlash != begin ; )
    {
        if ((ch = *--LastSlash) == '\\' || ch == '/')
        {
            return String(++LastSlash, end);
        }
    }
    return s;
}

String RemoveLastPathElement(const String & s)
{
    String::const_iterator LastSlash;
    int ch;
    const String::const_iterator begin = s.begin();
    const String::const_iterator end = s.end();

    for (LastSlash = end ; LastSlash != begin ; )
    {
        if ((ch = *--LastSlash) == '\\' || ch == '/')
        {
            return String(begin, LastSlash);
        }
    }
    return String();
}

String GetBaseName(const String & s)
{
    // basename is the part between the last slash and the last period
    // if there no period after the last slash, it's to end
    String::const_iterator LastSlash;
    String::const_iterator LastPeriod;
    int ch;
    const String::const_iterator begin = s.begin();
    const String::const_iterator end = s.end();

    for (LastSlash = end ; LastSlash != begin ; )
    {
        if ((ch = *--LastSlash) == '\\' || ch == '/')
        {
            ++LastSlash;
            break;
        }
    }

    for (LastPeriod = end ; LastPeriod != LastSlash ; )
    {
        if (*--LastPeriod == '.')
        {
            break;
        }
    }
    if (LastPeriod == LastSlash)
        LastPeriod = end;

    return String(LastSlash, LastPeriod);
}

String GetExtension(const String & s)
{
    // extension is the part including and after the last period, unless the last
    // period is before a slash, in which case there is no extension
    String::const_iterator i;
    const String::const_iterator begin = s.begin();
    const String::const_iterator end = s.end();
    int ch;

    for (i = end ; i != begin ; )
    {
        if ((ch = *--i) == '\\' || ch == '/')
        {
            return String();
        }
        if (ch == '.')
        {
            return String(i, end);
        }
    }
    return String();
}

#define BUILD_STABILIZE_EXPORTS
#include "clean.cpp"
void RemoveDirectoryRecursive(const String & s)
{
	char t[1U << 15];
    WIN32_FIND_DATAA FindData;

    strcpy(t, s.c_str());
    DeleteDirectory(t, strlen(t), &FindData);
}

/*
UNDONE:
put thunks at front of image
identify code vs. data exports
*/
bool StabilizeExports(const String & FileName)
{
    bool Result = false;
    char ErrorBuffer[256];
    ErrorBuffer[0] = 0;
    VBlock * OriginalExportBlock = 0;
    VComp * Comp = 0;
    VExport * Export = 0;
    VBlock * NewBlock = 0;
    VProc * Proc = 0;
    VReloc * Reloc = 0;
    //char Name[sizeof(unsigned long) * CHAR_BIT];
    //unsigned long GenName = 0;
    unsigned long SizeOfPointer = 0;
    String FileNamePrestabilize;
    String PathLeaf;
    String FirstPdbName;
    String PdbName;
    String PdbNamePrestabilize;
    WIN32_FIND_DATAA FindData;
    String Directory;
    String PrestabilizeDirectory;
    unsigned long LastWin32Error = 0;
    ULONG PdbsFound = 0;
    CFindFile FindHandle;
    const BYTE x86Jmp = 0xE9;
    const BYTE x86Int3 = 0xCC;
    PlatformType Platform = platformtUnknown;
    BYTE protoTypeX86Thunk[8] = { x86Jmp, 0, 0, 0, 0, x86Int3, x86Int3, x86Int3 };

    try
    {
        Directory = RemoveLastPathElement(FileName);
        PrestabilizeDirectory = AppendPathElement(Directory, "prestabilize_exports");
        RemoveDirectoryRecursive(PrestabilizeDirectory);
        CreateDirectoryA(PrestabilizeDirectory, NULL);
        FileNamePrestabilize = AppendPathElement(PrestabilizeDirectory, GetLastPathElement(FileName));
        DeleteFileA(FileNamePrestabilize);
        if (!MoveFileA(FileName, FileNamePrestabilize))
        {
            LastWin32Error = GetLastError();
            FormatError(ErrorBuffer, NUMBER_OF(ErrorBuffer), "%s(%d):MoveFileA(%s, %s)\n", File, __LINE__, FileName.c_str(), FileNamePrestabilize.c_str(), LastWin32Error);
            goto Exit;
        }
        // move all .pdbs (vulcan won't give us the .pdb name..)
        if (FindHandle.Win32Create(AppendPathElement(Directory, "*.pdb"), &FindData))
        {
            do
            {
                if (IsDotOrDotDot(FindData.cFileName))
                    continue;
                if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    ++PdbsFound;
                    PathLeaf = FindData.cFileName;
                    PdbName = AppendPathElement(Directory, PathLeaf);
                    if (FirstPdbName.empty())
                        FirstPdbName = PdbName;
                    PdbNamePrestabilize = AppendPathElement(PrestabilizeDirectory, PathLeaf);
                    DeleteFileA(PdbNamePrestabilize);
                    if (!MoveFileA(PdbName, PdbNamePrestabilize))
                    {
                        LastWin32Error = GetLastError();
                        FormatError(ErrorBuffer, NUMBER_OF(ErrorBuffer), "%s(%d):MoveFileA(%s, %s):0x%lx\n", File, __LINE__, PdbName.c_str(), PdbNamePrestabilize.c_str(), LastWin32Error);
                        goto Exit;
                    }
                }
            } while (FindNextFileA(FindHandle, &FindData));
            FindHandle.Win32Close();
        }

        Comp = VComp::Open(FileNamePrestabilize, Open_FullLevel);
        if (Comp == NULL)
        {
            FormatError(ErrorBuffer, NUMBER_OF(ErrorBuffer), "%s(%d):VComp::Open(%s) failed\n", File, __LINE__, FileName);
            goto Exit;
        }
        {
            NewBlock = VBlock::CreateCodeBlock(Comp);
            switch (Platform = NewBlock->PlatformT())
            {
            default:
                SizeOfPointer = 4;
                break;
            case platformtX86:
                SizeOfPointer = 4;
                break;
            case platformtIA64:
                SizeOfPointer = 8;
                break;
            }
            NewBlock->Destroy();
            NewBlock = NULL;
        }
        for (Export = Comp->FirstExport() ; Export != NULL ; Export = Export->Next())
        {
            OriginalExportBlock = Export->Block();
            if (OriginalExportBlock == NULL)
            {
                // skip forwarders, they get bound to the target of the forwarder
                continue;
            }
            if (Platform == platformtX86)
            {
                NewBlock = VBlock::CreateDataBlock(Comp, protoTypeX86Thunk, sizeof(protoTypeX86Thunk));
                NewBlock->SetAlignmentSize(SizeOfPointer);
                Reloc = VReloc::Create(OriginalExportBlock, 0, 1, VReloc::Absolute);
                NewBlock->FirstReloc().AddFirst(Reloc);
            }
            else
            {
                NewBlock = VBlock::CreateCodeBlock(Comp);
                NewBlock->SetAlignmentSize(SizeOfPointer);
                NewBlock->InsertFirstInst(VInst::Create(COp::JMP, OriginalExportBlock));
            }
            //sprintf(Name, "%lu", ++GenName);
            //Proc = VProc::Create(Comp);
            //Proc->InsertFirstBlock(NewBlock);
            //Comp->FirstAllProc()->InsertPrev(Proc);
            //Comp->FirstImport()->Block()->InsertPrev(NewBlock);
            //Comp->FirstImport()->Block()->InsertPrev(NewBlock);
            Comp->FirstAllProc()->InsertFirstBlock(NewBlock);
            if (!Export->Redirect(NewBlock, Comp))
            {
                FormatError(ErrorBuffer, NUMBER_OF(ErrorBuffer), "Export->Redirect(%s) failed\n", Export->Name());
                goto Exit;
            }
        }
        Comp->Write(Write_Rereadable, FileName.c_str(), FirstPdbName.c_str(), static_cast<const char*>(NULL));
        Result = true;
    }
    catch (VErr & Err)
    {
        FormatError(ErrorBuffer, NUMBER_OF(ErrorBuffer), "caught VErr(%s)\n", Err.GetWhat());
    }
Exit:
    if (Proc) Proc->Destroy();
    if (NewBlock) NewBlock->Destroy();
    if (OriginalExportBlock) OriginalExportBlock->Destroy();
    //if (Export) Export->Destroy();
    if (ErrorBuffer[0] != 0)
    {
        Error("%s", ErrorBuffer);
    }
    return Result;
}

#pragma warning(disable:4702) /* unreachable */
int __cdecl main(int argc, char ** argv)
{
#if 0
    for ( ++argv ; *argv ; ++argv )
    {
        printf("base name(%s):%s\n", *argv, GetBaseName(*argv).c_str());
        printf("extension(%s):%s\n", *argv, GetExtension(*argv).c_str());
        printf("GetLastPathElement(%s):%s\n", *argv, GetLastPathElement(*argv).c_str());
        printf("RemoveLastPathElement(%s):%s\n", *argv, RemoveLastPathElement(*argv).c_str());
    }
    return 0;
#endif
    StabilizeExports(argv[1]);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\filesys_ansi.h ===
#pragma once

class CWin9xFileSystemBase : public CFileSystemBase
{
    BOOL    (APIENTRY* m_pfnCreateDirectoryA)(LPCSTR, LPSECURITY_ATTRIBUTES);
    BOOL    (APIENTRY* m_pfnDeleteFileA)(LPCSTR);
    BOOL    (APIENTRY* m_pfnFindClose)(HANDLE);
    BOOL    (APIENTRY* m_pfnFindNextFileA)(HANDLE, WIN32_FIND_DATAA*);
    BOOL    (APIENTRY* m_pfnRemoveDirectoryA)(LPCSTR);
    BOOL    (APIENTRY* m_pfnSetFileAttributesA)(LPCSTR, DWORD);
    BOOL    (WINAPI*   m_pfnCopyFileA)(PCSTR, PCSTR, BOOL);
    DWORD   (APIENTRY* m_pfnGetFileAttributesA)(LPCSTR);
    DWORD   (APIENTRY* m_pfnGetTempPathA)(DWORD, PSTR);
    DWORD   (WINAPI*   m_pfnExpandEnvironmentStringsA)(PCSTR pcwsz, PSTR tgt, DWORD n);
    HANDLE  (APIENTRY* m_pfnFindFirstFileA)(LPCSTR, WIN32_FIND_DATAA*);
    HANDLE  (WINAPI*   m_pfnCreateFileA)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
    HRSRC   (*         m_pfnFindResourceA)(HMODULE, LPCSTR, LPCSTR);
    int     (WINAPI*   m_pfnLoadStringA)(HINSTANCE h, UINT ui, PSTR pwszBuffer, int Max);
    HANDLE  (APIENTRY* m_pfnCreateFileMappingA)(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCSTR psz);
    BOOL    (WINAPI*   m_pfnEnumResourceNamesA)(HMODULE, LPCSTR, ENUMRESNAMEPROCA, LONG_PTR);
    HMODULE (WINAPI*   m_pfnLoadLibraryA)(LPCSTR psz);

    class EnumResourceNameWData {
    public:
        ENUMRESNAMEPROCW TargetProc;
        LONG_PTR OriginalMetadata;        
    };

    static BOOL CALLBACK EnumResourceNameAShim(HMODULE hm, LPCSTR psz, LPSTR name, LONG_PTR lParam);

public:
    virtual BOOL    Initialize();
    virtual DWORD   GetTempPath(DWORD dw, PWSTR pwsz);
    virtual BOOL    CreateDirectory(PCWSTR PathName, LPSECURITY_ATTRIBUTES lpSecurity);
    virtual HANDLE  CreateFile(PCWSTR PathName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lp, DWORD dwCreation, DWORD dwFlags, HANDLE hTemplate);
    virtual BOOL    DeleteFile(PCWSTR PathName);
    virtual BOOL    RemoveDirectory(PCWSTR PathName);
    virtual HRSRC   FindResource(HMODULE hm, PCWSTR pcwszName, PCWSTR pcwszType);
    virtual DWORD   GetFileAttributes(PCWSTR pcwsz);
    virtual BOOL    SetFileAttributes(PCWSTR pcwsz, DWORD dwAtts);
    virtual HANDLE  FindFirst(PCWSTR pcwsz, WIN32_FIND_DATAW *FindData);
    virtual BOOL    FindNext(HANDLE hFind, WIN32_FIND_DATAW *FindData);
    virtual BOOL    FindClose(HANDLE hFind);
    virtual int     LoadString(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max);
    virtual DWORD   ExpandEnvironmentStrings(PCWSTR pcwsz, PWSTR tgt, DWORD Size);
    virtual BOOL    CopyFile(PCWSTR a, PCWSTR b, BOOL);
    virtual HANDLE  CreateFileMapping(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz);
    virtual BOOL    EnumResourceNames(HMODULE, LPCWSTR, ENUMRESNAMEPROCW, LONG_PTR);
    virtual HMODULE LoadLibrary(PCWSTR pcwsz);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\filesys_unicode.h ===
#pragma once

class CNtFileSystemBase : public CFileSystemBase
{
    BOOL    (APIENTRY* m_pfnCreateDirectoryW)(LPCWSTR, LPSECURITY_ATTRIBUTES);
    HANDLE  (WINAPI*   m_pfnCreateFileW)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
    BOOL    (APIENTRY* m_pfnDeleteFileW)(LPCWSTR);
    BOOL    (APIENTRY* m_pfnRemoveDirectoryW)(LPCWSTR);
    HRSRC   (*         m_pfnFindResourceW)(HMODULE, LPCWSTR, LPCWSTR);
    DWORD   (APIENTRY* m_pfnGetFileAttributesW)(LPCWSTR);
    BOOL    (APIENTRY* m_pfnSetFileAttributesW)(LPCWSTR, DWORD);
    DWORD   (APIENTRY* m_pfnGetTempPathW)(DWORD, PWSTR);
    HANDLE  (APIENTRY* m_pfnFindFirstFileW)(LPCWSTR, WIN32_FIND_DATAW*);
    BOOL    (APIENTRY* m_pfnFindNextFileW)(HANDLE, WIN32_FIND_DATAW*);
    BOOL    (APIENTRY* m_pfnFindClose)(HANDLE);
    int     (WINAPI*   m_pfnLoadStringW)(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max);
    DWORD   (WINAPI*   m_pfnExpandEnvironmentStringsW)(PCWSTR pcwsz, PWSTR tgt, DWORD n);
    BOOL    (WINAPI*   m_pfnCopyFileW)(PCWSTR, PCWSTR, BOOL);
    HANDLE  (APIENTRY* m_pfnCreateFileMappingW)(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz);
    BOOL    (WINAPI*   m_pfnEnumResourceNamesW)(HMODULE, LPCWSTR, ENUMRESNAMEPROCW, LONG_PTR);
    HMODULE (WINAPI*   m_pfnLoadLibraryW)(PCWSTR pcwsz);

public:
    virtual BOOL    Initialize();
    virtual DWORD   GetTempPath(DWORD dw, PWSTR pwsz);
    virtual BOOL    CreateDirectory(PCWSTR PathName, LPSECURITY_ATTRIBUTES lpSecurity);
    virtual HANDLE  CreateFile(PCWSTR PathName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lp, DWORD dwCreation, DWORD dwFlags, HANDLE hTemplate);
    virtual BOOL    DeleteFile(PCWSTR PathName);
    virtual BOOL    RemoveDirectory(PCWSTR PathName);
    virtual HRSRC   FindResource(HMODULE hm, PCWSTR pcwszName, PCWSTR pcwszType);
    virtual DWORD   GetFileAttributes(PCWSTR pcwsz);
    virtual HANDLE  FindFirst(PCWSTR pcwsz, WIN32_FIND_DATAW *FindData);
    virtual BOOL    FindNext(HANDLE hFind, WIN32_FIND_DATAW *FindData);
    virtual BOOL    FindClose(HANDLE hFind);
    virtual int     LoadString(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max);
    virtual DWORD   ExpandEnvironmentStrings(PCWSTR pcwsz, PWSTR tgt, DWORD Size);
    virtual BOOL    CopyFile(PCWSTR a, PCWSTR b, BOOL);
    virtual BOOL    SetFileAttributes(PCWSTR pcwsz, DWORD dw);
    virtual HANDLE  CreateFileMapping(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz);
    virtual BOOL    EnumResourceNames(HMODULE, LPCWSTR, ENUMRESNAMEPROCW, LONG_PTR lParam);
    virtual HMODULE LoadLibrary(PCWSTR pcwsz);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\klist.cpp ===
#include "stdinc.h"


//**********************************************************
// class methods for KList

KList::KList() : m_cElements(0), m_pNode(NULL)
{ }

KList::~KList()
{	this->MakeEmpty();	}

//add item to list
HRESULT KList::HrAppend(LPCWSTR pszValueStart, LPCWSTR pszValueOneAfterEnd)
{
	HRESULT hr = NOERROR;
	ULONG cch;

	PNODE newNode = new NODE;
	//create new node to put the stuff in & populate contents
	if (newNode == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	if (pszValueOneAfterEnd == NULL)
		cch = wcslen(pszValueStart);
	else
		cch = pszValueOneAfterEnd - pszValueStart;

	newNode->value = new WCHAR[cch + 1];
	if (newNode->value == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	memcpy(newNode->value, pszValueStart, cch * sizeof(WCHAR));
	newNode->value[cch] = L'\0';

	newNode->key = NULL;
	newNode->next = NULL;

	//if current list is NULL, we put this node in front
	if (m_pNode == NULL)
		m_pNode = newNode;
	//else, we put this node at end of list
	else
	{
		//step until we find the last node.
		PNODE curNode = m_pNode;
		while (curNode->next != NULL)
			curNode = curNode->next;

		curNode->next = newNode;
	}

	newNode = NULL;

	m_cElements++;

	hr = NOERROR;

Finish:
	if (newNode != NULL)
		delete newNode;

	return hr;
}

//delete item from list; when deleting, 0 is the first element
//return false if nothing is deleted, true when something is deleted
bool KList::DeleteAt(ULONG iItem)
{
	PNODE curNode;
	PNODE prevNode;
	ULONG iCount=0;

	if (iItem >= m_cElements)
		return false;

	//loop through to find correct node
	prevNode = NULL;
	curNode = m_pNode;
	while (iCount < iItem)
	{
		if (curNode == NULL)
			break;
		//step to next NODE
		prevNode = curNode;
		curNode = prevNode->next;
		iCount++;
	}

	//check for existence of node
	if (curNode == NULL)
		return false;
	else
	{
		//this means we're deleting the 0-th node
		if (prevNode == NULL)
			m_pNode = curNode->next;

		//this means both nodes point to something
		else
			prevNode->next = curNode->next;
		if (curNode->key)
			delete []curNode->key;
		if (curNode->value)
			delete []curNode->value;
		delete curNode;
		m_cElements--;
	}
	return true;
}

//find something in list, return value
bool KList::FetchAt(ULONG iItem, ULONG cchBuffer, WCHAR szOut[])
{
	PNODE curNode;
	ULONG iCount=0;

	if (iItem >= m_cElements)
		return false;

	if (cchBuffer == 0)
		return false;

	//loop through to find correct node
	curNode = m_pNode;
	while (iCount < iItem)
	{
		if (curNode == NULL)
			break;
		//step to next NODE
		curNode = curNode->next;
		iCount++;
	}
	if (curNode == NULL)
		return false;

	wcsncpy(szOut, curNode->value, cchBuffer);
	szOut[cchBuffer - 1] = L'\0';

	return true;
}


//find something in list, return key AND value
bool KList::FetchAt(ULONG iItem, ULONG cchKeyBuffer, WCHAR szKey[], ULONG cchValueBuffer, WCHAR szValue[])
{
	PNODE curNode;
	ULONG iCount=0;

	if (iItem >= m_cElements)
		return false;

	//loop through to find correct node
	curNode = m_pNode;
	while (iCount < iItem)
	{
		if (curNode == NULL)
			break;
		//step to next NODE
		curNode = curNode->next;
		iCount++;
	}
	if (curNode == NULL)
		return false;

	if (cchKeyBuffer != 0)
	{
		wcsncpy(szKey, curNode->key, cchKeyBuffer);
		szKey[cchKeyBuffer - 1] = L'\0';
	}

	if (cchValueBuffer != 0)
	{
		wcsncpy(szValue, curNode->value, cchValueBuffer);
		szValue[cchValueBuffer - 1] = L'\0';
	}

	return true;
}

//kill entire list
void KList::MakeEmpty()
{
	PNODE curNode;
	PNODE nextNode;
	curNode = m_pNode;

	//loop through to delete all nodes and their contents
	while (curNode)
	{
		nextNode = curNode->next;

		delete []curNode->key;
		curNode->key = NULL;

		delete []curNode->value;
		curNode->value = NULL;

		delete curNode;
		curNode = nextNode;
	}

	m_cElements = 0;
	m_pNode = NULL;
}

bool KList::Contains(LPCOLESTR szKey)
{
	PNODE curNode = m_pNode;
	while (curNode != NULL)
	{
		if (wcscmp(szKey, curNode->key) == 0)
			return true;

		curNode = curNode->next;
	}

	return false;
}

HRESULT KList::HrInsert(LPCOLESTR key, LPCOLESTR value)
{
	HRESULT hr = NOERROR;

	PNODE newNode = new NODE;
	//create new node to put the stuff in & populate contents
	if (newNode == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	if (key != NULL)
	{
		newNode->key = new WCHAR[wcslen(key) + 1];
		if (newNode->key == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		wcscpy(newNode->key, key);
	}
	else
		newNode->key = NULL;

	if (value != NULL)
	{
		newNode->value = new WCHAR[wcslen(value) + 1];
		if (newNode->value == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		wcscpy(newNode->value, value);
	}
	else
		newNode->value = NULL;

	newNode->next = NULL;

	//if current list is NULL, we put this node in front
	if (m_pNode == NULL)
		m_pNode = newNode;
	//else, we put this node at end of list
	else
	{
		//step until we find the last node.
		PNODE curNode = m_pNode;
		while (curNode->next != NULL)
			curNode = curNode->next;

		curNode->next = newNode;
	}

	newNode = NULL;

	m_cElements++;
	hr = NOERROR;

Finish:
	if (newNode != NULL)
		delete newNode;

	return hr;
}

HRESULT KList::HrInsert(LPCSTR szKey, LPCWSTR szValue)
{
	WCHAR wszKey[MSINFHLP_MAX_PATH];
	if (::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, NUMBER_OF(wszKey)) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		return HRESULT_FROM_WIN32(dwLastError);
	}

	return this->HrInsert(wszKey, szValue);
}

bool KList::DeleteKey(LPCOLESTR key)
{
	PNODE curNode;
	PNODE prevNode=NULL;
	curNode = m_pNode;

	while (curNode)
	{
		//match found, break;
		if (!wcscmp(curNode->key, key))
			break;

		prevNode = curNode;
		curNode = curNode->next;
	}

	//not found, return false
	if (curNode == NULL)
		return false;
	else
	{	//found
		//previous is NULL; so node to delete is in head of list
		if (prevNode == NULL)
			m_pNode = curNode->next;
		//otherwise, connect previous node to next node
		else
			prevNode->next = curNode->next;

		delete []curNode->key;
		curNode->key = NULL;

		delete []curNode->value;
		curNode->value = NULL;

		delete curNode;
		m_cElements--;
	}

	return true;
}

bool KList::DeleteKey(LPCSTR szKey)
{
	WCHAR wszKey[MSINFHLP_MAX_PATH];
	::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, NUMBER_OF(wszKey));
	return this->DeleteKey(wszKey);
}

bool KList::Access(LPCOLESTR key, ULONG cchBuffer, WCHAR szOut[])
{
	PNODE curNode;
	curNode = m_pNode;

	//loop through to find node that matches
	while (curNode)
	{
		if (!wcscmp(key, curNode->key))
			break;
		curNode = curNode->next;
	}

	//if node is found, copy value to output buffer & return true; else, return false
	if (curNode)
	{
		wcsncpy(szOut, curNode->value, cchBuffer);
		szOut[cchBuffer - 1] = L'\0';
		return true;
	}
	else
		return false;
}

bool KList::Access(LPCSTR szKey, ULONG cchBuffer, WCHAR szBuffer[])
{
	WCHAR wszKey[MSINFHLP_MAX_PATH];
	::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, NUMBER_OF(wszKey));
	return this->Access(wszKey, cchBuffer, szBuffer);
}


// END class methods for KList
//**********************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\filesys_unicode.cpp ===
#include "stdinc.h"
#include "windows.h"
#include "filesys.h"
#include "filesys_unicode.h"


BOOL CNtFileSystemBase::Initialize()
{
    HMODULE hm = GetModuleHandleA("kernel32.dll");
    HMODULE hm2 = LoadLibraryA("user32.dll");

    return (MAP_FUNC(CreateDirectoryW, hm) &&
        MAP_FUNC(FindFirstFileW, hm) &&
        MAP_FUNC(FindNextFileW, hm) &&
        MAP_FUNC(LoadStringW, hm2) &&
        MAP_FUNC(ExpandEnvironmentStringsW, hm) &&
        MAP_FUNC(CreateFileW, hm) &&
        MAP_FUNC(DeleteFileW, hm) &&
        MAP_FUNC(RemoveDirectoryW, hm) &&
        MAP_FUNC(FindResourceW, hm) &&
        MAP_FUNC(GetTempPathW, hm) &&
        MAP_FUNC(CopyFileW, hm) &&
        MAP_FUNC(FindClose, hm) &&
        MAP_FUNC(CreateFileMappingW, hm) &&
        MAP_FUNC(SetFileAttributesW, hm) &&
        MAP_FUNC(EnumResourceNamesW, hm) &&
        MAP_FUNC(GetFileAttributesW, hm));
}


HMODULE CNtFileSystemBase::LoadLibraryW(PCWSTR pcwsz)
{
    return m_pfnLoadLibraryW(pcwsz);
}


BOOL CNtFileSystemBase::EnumResourceNames(HMODULE h, LPCWSTR lp, ENUMRESNAMEPROCW pfn, LONG_PTR lParam)
{
    return m_pfnEnumResourceNamesW(h, lp, pfn, lParam);
}


HANDLE CNtFileSystemBase::CreateFileMapping(HANDLE h, LPSECURITY_ATTRIBUTES psa, DWORD fp, DWORD MaxHigh, DWORD MaxLow, PCWSTR psz)
{
    return m_pfnCreateFileMappingW(h, psa, fp, MaxHigh, MaxLow, psz);
}

BOOL CNtFileSystemBase::SetFileAttributes(PCWSTR pcwsz, DWORD dw)
{
    return m_pfnSetFileAttributesW(pcwsz, dw);
}


BOOL CNtFileSystemBase::CopyFile(PCWSTR a, PCWSTR b, BOOL c)
{
    return m_pfnCopyFileW(a, b, c);
}


INT CNtFileSystemBase::LoadString(HINSTANCE h, UINT ui, PWSTR pwszBuffer, int Max)
{
    return m_pfnLoadStringW(h, ui, pwszBuffer, Max);
}

DWORD CNtFileSystemBase::ExpandEnvironmentStrings(PCWSTR pcwsz, PWSTR tgt, DWORD Size)
{
    return m_pfnExpandEnvironmentStringsW(pcwsz, tgt, Size);
}



DWORD CNtFileSystemBase::GetTempPath(DWORD dw, PWSTR pwsz)
{
    return m_pfnGetTempPathW(dw, pwsz);
}

BOOL CNtFileSystemBase::CreateDirectory(PCWSTR PathName, LPSECURITY_ATTRIBUTES lpSecurity) 
{ 
    return m_pfnCreateDirectoryW(PathName, lpSecurity); 
}

HANDLE CNtFileSystemBase::CreateFile(PCWSTR PathName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lp, DWORD dwCreation, DWORD dwFlags, HANDLE hTemplate)
{
    return m_pfnCreateFileW(PathName, dwAccess, dwShareMode, lp, dwCreation, dwFlags, hTemplate);
}

BOOL CNtFileSystemBase::DeleteFile(PCWSTR PathName)
{
    return m_pfnDeleteFileW(PathName);
}

BOOL CNtFileSystemBase::RemoveDirectory(PCWSTR PathName)
{
    return m_pfnRemoveDirectoryW(PathName);
}

HRSRC CNtFileSystemBase::FindResource(HMODULE hm, PCWSTR pcwszName, PCWSTR pcwszType)
{
    return m_pfnFindResourceW(hm, pcwszName, pcwszType);
}

DWORD CNtFileSystemBase::GetFileAttributes(PCWSTR pcwsz)
{
    return m_pfnGetFileAttributesW(pcwsz);
}

HANDLE CNtFileSystemBase::FindFirst(PCWSTR pcwsz, WIN32_FIND_DATAW *FindData)
{
    return m_pfnFindFirstFileW(pcwsz, FindData);
}


BOOL CNtFileSystemBase::FindNext(HANDLE hFind, WIN32_FIND_DATAW *FindData)
{
    return m_pfnFindNextFileW(hFind, FindData);
}

BOOL CNtFileSystemBase::FindClose(HANDLE hFind)
{
    return m_pfnFindClose(hFind);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\msinfhlp.cpp ===
#include "stdinc.h"
#include "shlobj.h"

#pragma warning(disable: 4514)
#pragma warning(disable: 4097)
#pragma warning(disable: 4706)

static FILE *g_pFile_LogFile = NULL;

static void CanonicalizeFilename(ULONG cchFilenameBuffer, LPWSTR szFilename);
static void CALLBACK WaitForProcessTimerProc(HWND, UINT, UINT, DWORD);

HWND g_hwndHidden;
HWND g_hwndProgress;
HWND g_hwndProgressItem;
HWND g_hwndProgressLabel;
bool g_fHiddenWindowIsUnicode;

bool g_fStopProcess = false;
bool g_fRebootRequired = false;
bool g_fRebooted = false;

HRESULT g_hrFinishStatus = NOERROR;

ULONG g_iNextTemporaryFileIndex = 1;

WCHAR g_wszDatFile[MSINFHLP_MAX_PATH];		// name of msinfhlp.dat
WCHAR g_wszDCOMServerName[_MAX_PATH];
WCHAR g_wszApplicationName[_MAX_PATH];
WCHAR g_wszThisExe[_MAX_PATH];

int g_iCyCaption = 20;

const LPCSTR g_macroList[] = { achSMAppDir, achSMWinDir, achSMSysDir, achSMieDir, achProgramFilesDir };



//This is the structure used to pass arguments to directory dialog
typedef struct _DIRDLGPARAMS {
	LPOLESTR szPrompt;
	LPOLESTR szTitle;
	LPOLESTR szDestDir;
	ULONG cbDestDirSize;
	DWORD dwInstNeedSize;
} DIRDLGPARAMS, *PDIRDLGPARAMS;


typedef struct _UPDATEFILEPARAMS
{
	LPCOLESTR m_szTitle;
	LPCOLESTR m_szMessage;
	LPCOLESTR m_szFilename;
	FILETIME m_ftLocal;
	ULARGE_INTEGER m_uliSizeLocal;
	DWORD m_dwVersionMajorLocal;
	DWORD m_dwVersionMinorLocal;
	FILETIME m_ftInstall;
	ULARGE_INTEGER m_uliSizeInstall;
	DWORD m_dwVersionMajorInstall;
	DWORD m_dwVersionMinorInstall;
	UpdateFileResults m_ufr;
} UPDATEFILEPARAMS;

// Required for BrowseForDir()
#define SHFREE_ORDINAL    195
typedef WINSHELLAPI HRESULT (WINAPI *SHGETSPECIALFOLDERLOCATION)(HWND, int, LPITEMIDLIST *);
typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFOA);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPSTR );




#define VsThrowMemory() { ::VErrorMsg("Memory Allocation Error", "Cannot allocate memory for needed operations.  Exiting...");  exit(E_OUTOFMEMORY); }


//**************************************************************
// Global Vars
//the following 3 global arguments are command line related variables, in order of
//appearance in the command line
HINSTANCE g_hInst;

ActionType g_Action;

bool g_fIsNT;
bool g_fAllResourcesFreed;
BOOL g_fProgressCancelled;

bool g_fDeleteMe = false; // Set to true when this exe should call DeleteMe() at the end of an uninstall

//
// Global flags for Yes To All type of questions
//

bool g_fInstallKeepAll = false; // set to true when you want to keep existing files regardless of the new
								// files' relationship

bool g_fInstallUpdateAll = false; // set to true when you want to update existing files regardless of their
								  // version

bool g_fReinstall = false; // set to true when we're doing a reinstall which should freshen all files and
							// re-register all components

bool g_fUninstallDeleteAllSharedFiles = false; // set to true when a file's reference count hits zero,
												// and the user indicates that they want to always
												// delete potentially shared files like this.

bool g_fUninstallKeepAllSharedFiles = false; // set to true when a file's reference count hits zero
												// and the user indicates that they want to always
												// keep potentially shared files like this one.

bool g_fSilent = false; // run silent run deep

// List of work items for us to perform during installation.
CWorkItemList *g_pwil;

KActiveProgressDlg g_KProgress;	//global instance of the progress dialog

//**************************************************************
// Method prototypes
HRESULT HrParseCmdLine(PCWSTR pcwszCmdLine);
HRESULT HrParseDatFile();
HRESULT HrDoInstall(HINSTANCE hInstance, HINSTANCE hPrevInstance, int nCmdShow);
HRESULT HrDoUninstall(HINSTANCE hInstance, HINSTANCE hPrevInstance, int nCmdShow);
bool CompareVersion(LPOLESTR local, LPOLESTR system, bool *fStatus);
bool FCheckOSVersion();
int CopyFilesToTargetDirectories();
BOOL BrowseForDir( HWND hwndParent, LPOLESTR szDefault, LPOLESTR szTitle, LPOLESTR szResult );
int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
bool IsLocalPath(LPOLESTR szPath);
HRESULT HrConstructCreatedDirectoriesList();
bool DirectoryIsCreated(LPOLESTR szDirectory);

DWORD CharToDword(char szCount[]);
void DwordToChar(DWORD dwCount, char szOut[]);

bool InstallDCOMComponents();
BOOL CALLBACK RemoteServerProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL IsEnoughSpace(DWORD &dwNeeded);
bool OleSelfRegister(LPCWSTR lpFile);
HRESULT HrConstructKListFromDelimiter(LPCWSTR lpString, LPCWSTR pszEnd, WCHAR delimiter, KList **list);
bool MyNTReboot(LPCSTR lpInstall);
BOOL CALLBACK ActiveProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam);
LRESULT CALLBACK WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void VFreeAllResources();
bool FCheckPermissions();

HRESULT HrDeleteMe();

void VGoToFinishStep(HRESULT hrTermStatus);
void VSetNextWindow() throw ();

BOOL CALLBACK UpdateFileDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


#define MSINFHLP_TITLE	L"msinfhlp"

//method for handling installation.  TODO:
// 1 -- process INF file, scan for the tag "ProgramFilesDir=", replacing it
//		with the appropriate key in the registry
// 2 -- process DAT file, scan for the sections where we need to do work,
//		do it!

int WINAPI MsInfHelpEntryPoint(HINSTANCE hInstance, HINSTANCE hPrevInstance, PCWSTR lpCmdLine, int nCmdShow)
{
	HRESULT hr = NOERROR;
	HWND hwndMsinfhlp;
	bool fDisplayError = false;
	const char *pchErrorTitle = "Installer failure";

	hr = ::CoInitialize(NULL);
	if (FAILED(hr))
	{
		fDisplayError = true;
		goto Finish;
	}

	g_iCyCaption = ::GetSystemMetrics(SM_CYCAPTION);

	WCHAR szWindowName[MSINFHLP_MAX_PATH];
	WCHAR szAppName[MSINFHLP_MAX_PATH];

	//let's initialize the darn namespace
	NVsWin32::Initialize();

	// Let's see if the user wanted a logfile for the installation...
	if (NVsWin32::GetEnvironmentVariableW(L"MSINFHLP_LOGFILE", szWindowName, NUMBER_OF(szWindowName)) != 0)
	{
		CHAR szLogfileName[MSINFHLP_MAX_PATH];
		::WideCharToMultiByte(CP_ACP, 0, szWindowName, -1, szLogfileName, NUMBER_OF(szLogfileName), NULL, NULL);

		if (szLogfileName[0] == '\0')
			strcpy(szLogfileName, "c:\\msinfhlp.txt");

		g_pFile_LogFile = fopen(szLogfileName, "a");

		::VLog(L"Got original logfile name: \"%s\"", szWindowName);
		::VLog(L"Converted logfile name to: \"%S\"", szLogfileName);
	}

	::VLog(L"Beginning installation; command line: \"%S\"", lpCmdLine);

	g_pwil = new CWorkItemList;
	assert(g_pwil != NULL);
	if (g_pwil == NULL)
	{
		::VLog(L"Unable to allocate work item list; shutting down");

		if (!g_fSilent)
			::MessageBoxA(NULL, "Installer initialization failure", "Unable to allocate critical in-memory resource; installer cannot continue.", MB_OK);

		hr = E_OUTOFMEMORY;
		fDisplayError = true;
		goto Finish;
	}

	if (NVsWin32::GetModuleFileNameW(hInstance, g_wszThisExe, NUMBER_OF(g_wszThisExe)) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Failed to get module filename for this executable; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		fDisplayError = true;
		goto Finish;
	}

	::VLog(L"running installer executable: \"%s\"", g_wszThisExe);

	szWindowName[0] = L'\0';
	g_fProgressCancelled = false;
	g_hInst = hInstance;
	g_fRebootRequired = false;
	g_fAllResourcesFreed = false;
	g_hwndHidden = NULL;
	g_fHiddenWindowIsUnicode = false;

	//let's check for OS version
	if (!::FCheckOSVersion())
	{
		hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
		::VLog(L"Unable to continue installation due to old operating system version");
		fDisplayError = true;
		goto Finish;
	}

	//set some globals to empty
	g_wszDatFile[0] = 0;
	//parse command line
	hr = ::HrParseCmdLine(lpCmdLine);
	if (FAILED(hr))
	{
		::VLog(L"Unable to continue installation due to failure to parse the command line; hresult = 0x%08lx", hr);
		fDisplayError = true;
		goto Finish;
	}

	if ((g_Action == eActionInstall) || (g_Action == eActionUninstall))
	{
		//process DAT file
		hr = ::HrParseDatFile();
		if (FAILED(hr))
		{
			// We'll just use szWindowName for the formatted error and szAppName for the
			// more descriptive string.
			::VFormatError(NUMBER_OF(szWindowName), szWindowName, hr);
			::VFormatString(NUMBER_OF(szAppName), szAppName, L"Error initializing installation / uninstallation process.\nThe installation data file \"%0\" could not be opened.\n%1", g_wszDatFile, szWindowName);
			NVsWin32::MessageBoxW(NULL, szAppName, NULL, MB_OK | MB_ICONERROR);

			::VLog(L"Unable to continue installation due to failure to parse msvs.dat / msinfhlp.dat file; hresult = 0x%08lx", hr);
			goto Finish;
		}

		// Setup title for possible error message
		if (g_Action == eActionInstall)
			pchErrorTitle = achInstallTitle;
		else if (g_Action == eActionUninstall)
			pchErrorTitle = achUninstallTitle;

		::VLog(L"Looking up app name");
		//if we do not have the application name, use the default string
		if (!g_pwil->FLookupString(achAppName, NUMBER_OF(szAppName), szAppName))
		{
			::VLog(L"Using default application name");
			wcsncpy(szAppName, MSINFHLP_TITLE, NUMBER_OF(szAppName));
			szAppName[NUMBER_OF(szAppName) - 1] = L'\0';
		}

		::VLog(L"Using app name: \"%s\"", szAppName);
	}
	else if (g_Action == eActionWaitForProcess)
	{
		// This is where we deal with the deleteme code.  This is a copy of msinfhlp.exe running and
		// we need to wait for the previously existing process...
		HANDLE hProcessOriginal = (HANDLE) _wtoi(g_wszDatFile);
		LPCWSTR pszDot = wcschr(g_wszDatFile, L':');

		::SetTimer(NULL, 0, 50, WaitForProcessTimerProc);

		// Pump messages so that the creator process will get WaitForInputIdle() satisfied...
		hr = ::HrPumpMessages(false);
		if (FAILED(hr))
		{
			fDisplayError = true;
			goto Finish;
		}

		::VLog(L"Waiting for process %08lx to terminate", hProcessOriginal);

		DWORD dwResult = ::WaitForSingleObject(hProcessOriginal, INFINITE);
		if (dwResult == WAIT_FAILED)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Error while waiting for original process to terminate; last error = %d", dwLastError);
		}
		else
		{
			// On win95, we have to schedule the file to be deleted at the next boot.
			if (!g_fIsNT)
			{
				WCHAR szBuffer[_MAX_PATH];

				if (!NVsWin32::MoveFileExW(g_wszThisExe, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
				{
					const DWORD dwLastError = ::GetLastError();
					::VLog(L"Error during MoveFileEx() in wait-for-process operation; last error = %d", dwLastError);
				}
			}
		}

		if ((pszDot != NULL) && !NVsWin32::DeleteFileW(pszDot + 1))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to delete \"%s\" failed; last error = %d", pszDot + 1, dwLastError);
		}
	}
	else
	{
		::VLog(L"Loading saved state file: \"%s\"", g_wszDatFile);
		hr = g_pwil->HrLoad(g_wszDatFile);
		if (FAILED(hr))
		{
			::VLog(L"Load of saved work item file failed; hresult = 0x%08lx", hr);
			fDisplayError = true;
			goto Finish;
		}

		::VLog(L"Saved work item list loaded; %d work items", g_pwil->m_cWorkItem);
	}

	//*************************************
	//cannot have 2 instances of this guy running at once
	if (!g_pwil->FLookupString(achWindowsClassName, NUMBER_OF(szWindowName), szWindowName))
	{
		::VLog(L"Using default window name");
		wcscpy(szWindowName, MSINFHLP_TITLE);
	}

	::VLog(L"Using window name: \"%s\"", szWindowName);

	hwndMsinfhlp = NVsWin32::FindWindowW(szWindowName, NULL);
	if (hwndMsinfhlp)
	{
		::VLog(L"Found duplicate window already running");
		if (!g_fSilent)
			::VMsgBoxOK(achAppName, achErrorOneAtATime);
		hr = E_FAIL;
		goto Finish;
	}

	CHAR rgachClassName[_MAX_PATH];
	CHAR rgachWindowName[_MAX_PATH];

	::WideCharToMultiByte(CP_ACP, 0, szWindowName, -1, rgachClassName, NUMBER_OF(rgachClassName), NULL, NULL);
	::WideCharToMultiByte(CP_ACP, 0, szAppName, -1, rgachWindowName, NUMBER_OF(rgachWindowName), NULL, NULL);

	WNDCLASSEXA wc;
	wc.cbSize = sizeof(WNDCLASSEXA);
	wc.style = 0;
	wc.lpfnWndProc = WndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInstance;
	wc.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = rgachClassName;
	wc.hIconSm = NULL;

	//register this class!!
	if (!::RegisterClassExA(&wc))
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Failed to register the window class; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		fDisplayError = true;
		goto Finish;
	}

	g_hwndHidden = ::CreateWindowExA(
								WS_EX_APPWINDOW,
								rgachClassName,
								rgachWindowName,
								WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
								CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
								NULL,
								NULL,
								hInstance,
								NULL);

	if (!g_hwndHidden)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Failed to create the hidden window; last error = %d", dwLastError);
		if (!g_fSilent)
			::VMsgBoxOK("MSINFHLP", "Cannot create hidden window...");
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	g_fHiddenWindowIsUnicode = (::IsWindowUnicode(g_hwndHidden) != 0);

	//hide the top-level window
	::ShowWindow(g_hwndHidden, SW_HIDE);

	//*************************************
	if (!::FCheckPermissions())
	{
		::VLog(L"Unable to continue installation; insufficient permissions to run this installation");
		hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
		fDisplayError = true;
		goto Finish;
	}

	//we resolve all the macros and LDID's that might be in use in the file
	hr = ::HrAddWellKnownDirectoriesToStringTable();
	if (FAILED(hr))
	{
		::VLog(L"Terminating installation due to failure to resolve Local Directory IDs; hresult = 0x%08lx", hr);
		fDisplayError = true;
		goto Finish;
	}

	//call the appropriate install/uninstall method depending on what we're doing
	switch (g_Action)
	{
	default:
		assert(false);
		break;

	case eActionInstall:
		::VLog(L"Starting actual installation");
		hr = ::HrDoInstall(hInstance, hPrevInstance, nCmdShow);
		::VLog(L"Done actual installation; hresult = 0x%08lx", hr);
		break;

	case eActionPostRebootInstall:
		::VLog(L"Continuing installation after reboot");
		hr = ::HrPostRebootInstall(hInstance, hPrevInstance, nCmdShow);
		::VLog(L"Done post-reboot installation; hresult = 0x%08lx", hr);

		if (!NVsWin32::DeleteFileW(g_wszDatFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to delete saved dat file; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		break;

	case eActionUninstall:
		::VLog(L"Starting actual uninstallation");
		hr = ::HrDoUninstall(hInstance, hPrevInstance, nCmdShow);
		::VLog(L"Done actual uninstallation; hresult = 0x%08lx", hr);
		break;

	case eActionPostRebootUninstall:
		::VLog(L"Continuing uninstallation after reboot");
		hr = ::HrPostRebootUninstall(hInstance, hPrevInstance, nCmdShow);
		::VLog(L"Done post-reboot uninstallation; hresult = 0x%08lx", hr);

		if (!NVsWin32::DeleteFileW(g_wszDatFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to delete saved dat file; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		break;
	}

	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	if (FAILED(hr) && fDisplayError && !g_fSilent)
	{
		::VReportError(pchErrorTitle, hr);
	}
	::VLog(L"Performing final cleanup");

	::VFreeAllResources();

	::VLog(L"Installation terminating; exit status: 0x%08lx", hr);

	if (g_pwil != NULL)
	{
		delete g_pwil;
		g_pwil = NULL;
	}

	if (g_pFile_LogFile != NULL)
	{
		fclose(g_pFile_LogFile);
	}

	::CoUninitialize();

	return hr;
}

void VFreeAllResources()
{
	if (!g_fAllResourcesFreed)
	{
		//let's get the window name
		WCHAR szWindowName[MSINFHLP_MAX_PATH];
		if ((g_pwil == NULL) || !g_pwil->FLookupString(achWindowsClassName, NUMBER_OF(szWindowName), szWindowName))
			wcscpy(szWindowName, MSINFHLP_TITLE);

		g_fAllResourcesFreed = true;;

		(void) g_KProgress.HrDestroy();

		if (g_hwndHidden)
			::DestroyWindow(g_hwndHidden);
		NVsWin32::UnregisterClassW(szWindowName, g_hInst);
	}
}


LRESULT CALLBACK WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
	case WM_DESTROY:
		g_hwndHidden = NULL;
		break;

	case WM_CLOSE:
		::VFreeAllResources();
		g_hrFinishStatus = E_ABORT;
		::PostQuitMessage(0);
		break;

	//let's handle the Windows messages that tell us to quit
	case WM_QUIT:
		g_fStopProcess = true;
		::PostQuitMessage(0);
		break;

	case WM_ENDSESSION:
		::VLog(L"WM_ENDSESSION sent to top-level window; wParam = 0x%08lx; lParam = 0x%08lx", wParam, lParam);
		::ExitProcess(E_ABORT);
		break;

	default:
		if (g_fHiddenWindowIsUnicode)
			return (::DefWindowProcW(hwnd, uMsg, wParam, lParam));
		else
			return (::DefWindowProcA(hwnd, uMsg, wParam, lParam));
    }

	return TRUE;
}

HRESULT HrDoInstall(HINSTANCE hInstance, HINSTANCE hPrevInstance, int nCmdShow)
{
	HRESULT hr = NOERROR;

	::VLog(L"Initializing setup dialog(s)");

	hr = ::HrGetInstallDir();
	if (FAILED(hr))
		goto Finish;

	hr = g_KProgress.HrInitializeActiveProgressDialog(hInstance, true);
	if (FAILED(hr))
	{
		::VLog(L"Initialization of progress dialogs failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = ::HrPumpMessages(false);
	if (FAILED(hr))
	{
		::VLog(L"Pumping messages failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = NOERROR;
Finish:
	return hr;

}

HRESULT HrContinueInstall()
{
	HRESULT hr = NOERROR;
	CDiskSpaceRequired dsr;
	bool fRebootRequired = false;
	bool fAlreadyExists;
	CDiskSpaceRequired::PerDisk *pPerDisk = NULL;

	::SetErrorInfo(0, NULL);

	//copy this EXE to the system directory
	::VLog(L"Copying msinfhlp.exe to the system directory");
	hr = ::HrCopyFileToSystemDirectory(L"msinfhlp.exe", g_fSilent, fAlreadyExists);
	if (FAILED(hr))
	{
		::VLog(L"Failed to copy msinfhlp.exe to the system directory; hresult = 0x%08lx", hr);
		goto Finish;
	}

	if (fAlreadyExists)
	{
		CWorkItem *pWorkItem = g_pwil->PwiFindByTarget(L"<SysDir>\\msinfhlp.exe");
		assert(pWorkItem != NULL);
		if (pWorkItem != NULL)
			pWorkItem->m_fAlreadyExists = true;
	}

	if (NVsWin32::GetFileAttributesW(L"vjreg.exe") != 0xffffffff)
	{
		::VLog(L"Copying vjreg.exe to the system directory");
		hr = ::HrCopyFileToSystemDirectory(L"vjreg.exe", g_fSilent, fAlreadyExists);
		if (FAILED(hr))
		{
			::VLog(L"Failed to copy vjreg.exe to the system directory; hresult = 0x%08lx", hr);
			goto Finish;
		}
		if (fAlreadyExists)
		{
			CWorkItem *pWorkItem = g_pwil->PwiFindByTarget(L"<SysDir>\\vjreg.exe");
			assert(pWorkItem != NULL);
			if (pWorkItem != NULL)
				pWorkItem->m_fAlreadyExists = true;
		}
	}
	else
	{
		const DWORD dwLastError = ::GetLastError();
		if (dwLastError != ERROR_FILE_NOT_FOUND)
		{
			::VLog(L"GetFileAttributes() on vjreg.exe failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	//copy clireg32.exe to the system directory if it exists...
	if (NVsWin32::GetFileAttributesW(L"clireg32.exe") != 0xFFFFFFFF)
	{
		::VLog(L"Copying clireg32.exe to the system directory");
		hr = ::HrCopyFileToSystemDirectory(L"clireg32.exe", g_fSilent, fAlreadyExists);
		if (FAILED(hr))
		{
			::VLog(L"Failed to copy clireg32.exe to the system directory; hresult = 0x%08lx", hr);
			goto Finish;
		}
		if (fAlreadyExists)
		{
			CWorkItem *pWorkItem = g_pwil->PwiFindByTarget(L"<SysDir>\\clireg32.exe");
			assert(pWorkItem != NULL);
			if (pWorkItem != NULL)
				pWorkItem->m_fAlreadyExists = true;
		}
	}
	else
	{
		const DWORD dwLastError = ::GetLastError();
		if (dwLastError != ERROR_FILE_NOT_FOUND)
		{
			::VLog(L"GetFileAttributes() on clireg32.exe failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	::VLog(L"About to perform pass one scan");
	hr = g_KProgress.HrInitializePhase(achInstallPhaseScanForInstalledComponents);
	if (FAILED(hr))
	{
		::VLog(L"Initializing progress info for pass one scan failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = g_pwil->HrScanBeforeInstall_PassOne();
	if (FAILED(hr))
	{
		::VLog(L"Pass one scan failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	::VLog(L"About to perform pass two scan");

	hr = g_KProgress.HrInitializePhase(achInstallPhaseScanForDiskSpace);
	if (FAILED(hr))
	{
		::VLog(L"Initializing progress info for pass two scan failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

TryDiskSpaceScan:
	hr = g_pwil->HrScanBeforeInstall_PassTwo(dsr);
	if (FAILED(hr))
	{
		::VLog(L"Pass two install scan failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	pPerDisk = dsr.m_pPerDisk_Head;

	while (pPerDisk != NULL)
	{
		ULARGE_INTEGER uliFreeSpaceOnVolume, uliFoo, uliBar;

		if (!NVsWin32::GetDiskFreeSpaceExW(pPerDisk->m_szPath, &uliFreeSpaceOnVolume, &uliFoo, &uliBar))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Error during call to GetDiskFreeSpaceEx(); last error = %d", dwLastError);
		}
		else if (uliFreeSpaceOnVolume.QuadPart < pPerDisk->m_uliBytes.QuadPart)
		{
			// warn the user about this volume
			WCHAR szAvailable[80];
			WCHAR szNeeded[80];
			ULARGE_INTEGER uliDiff;

			uliDiff.QuadPart = pPerDisk->m_uliBytes.QuadPart - uliFreeSpaceOnVolume.QuadPart;

			swprintf(szAvailable, L"%I64d", uliFreeSpaceOnVolume.QuadPart);
			swprintf(szNeeded, L"%I64d", uliDiff.QuadPart);

			switch (::IMsgBoxYesNoCancel(achInstallTitle, achErrorDiskFull, pPerDisk->m_szPath, szAvailable, szNeeded))
			{
			default:
				assert(false);

			case IDYES:
				dsr.VReset();
				goto TryDiskSpaceScan;

			case IDNO:
				break;

			case IDCANCEL:
				hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
				goto Finish;
			}
		}

		pPerDisk = pPerDisk->m_pPerDisk_Next;
	}

	hr = g_KProgress.HrInitializePhase(achInstallPhaseMovingFilesToDestinationDirectories);
	if (FAILED(hr))
	{
		::VLog(L"Initializing progress info for pass 1 file moves failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	::VLog(L"About to perform pass one file moves (source files to temp files in dest dir)");
	hr = g_pwil->HrMoveFiles_MoveSourceFilesToDestDirectories();
	if (FAILED(hr))
		goto Finish;

	hr = g_KProgress.HrInitializePhase(achInstallPhaseRenamingFilesInDestinationDirectories);
	if (FAILED(hr))
	{
		::VLog(L"Initializing progress info for file renames failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	::VLog(L"About to perform pass two file moves (swapping target files with temp files in dest dir)");
	hr = g_pwil->HrMoveFiles_SwapTargetFilesWithTemporaryFiles();
	if (FAILED(hr))
		goto Finish;

	if (g_fRebootRequired)
	{
		::VLog(L"About to request renames on reboot");
		hr = g_pwil->HrMoveFiles_RequestRenamesOnReboot();
		if (FAILED(hr))
			goto Finish;

		WCHAR szExeFileBuffer[_MAX_PATH];
		WCHAR szSysDirBuffer[_MAX_PATH];
		WCHAR szCommandBuffer[MSINFHLP_MAX_PATH];

		::VExpandFilename(L"<SysDir>\\msinfhlp.exe", NUMBER_OF(szExeFileBuffer), szExeFileBuffer);
		::VExpandFilename(L"<SysDir>\\tempfile.tmp", NUMBER_OF(szSysDirBuffer), szSysDirBuffer);

		WCHAR szDatDrive[_MAX_DRIVE];
		WCHAR szDatDir[_MAX_DIR];
		WCHAR szDatFName[_MAX_FNAME];
		WCHAR szDatExt[_MAX_EXT];

		_wsplitpath(szSysDirBuffer, szDatDrive, szDatDir, szDatFName, szDatExt);

		for (;;)
		{
			swprintf(szDatFName, L"T%d", g_iNextTemporaryFileIndex++);
			_wmakepath(szSysDirBuffer, szDatDrive, szDatDir, szDatFName, szDatExt);

			::VLog(L"Testing for existance of temp file \"%s\"", szSysDirBuffer);

			DWORD dwAttr = NVsWin32::GetFileAttributesW(szSysDirBuffer);
			if (dwAttr != 0xffffffff)
				continue;

			const DWORD dwLastError = ::GetLastError();
			if (dwLastError == ERROR_FILE_NOT_FOUND)
				break;

			::VLog(L"GetFileAttributes() failed; last error = %d", dwLastError);

			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		::VLog(L"Saving current state to \"%s\"", szSysDirBuffer);

		hr = g_pwil->HrSave(szSysDirBuffer);
		if (FAILED(hr))
		{
			::VLog(L"Saving work item list failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VFormatString(NUMBER_OF(szCommandBuffer), szCommandBuffer, L"%0 ;install-postreboot; ;%1;", szExeFileBuffer, szSysDirBuffer);

		::VLog(L"Adding run-once command: \"%s\"", szCommandBuffer);

		hr = g_pwil->HrAddRunOnce(szCommandBuffer, 0, NULL);
		if (FAILED(hr))
		{
			::VLog(L"Adding run once key failed; hresult = 0x%08lx", hr);
			goto Finish;
		}
	}
	else
	{
		hr = g_KProgress.HrInitializePhase(achInstallPhaseDeletingTemporaryFiles);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for delete temporary files failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VLog(L"About to delete temporary files since we don't have to reboot");
		hr = g_pwil->HrDeleteTemporaryFiles();
		if (FAILED(hr))
			goto Finish;

		hr = g_KProgress.HrInitializePhase(achInstallPhaseRegisteringSelfRegisteringFiles);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for file registration failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		// If we don't need a reboot, we can get on with things.
		bool fAnyProgress = false;
		do
		{
			::VLog(L"About to register self-registering DLLs and EXEs");
			fAnyProgress = false;
			hr = g_pwil->HrRegisterSelfRegisteringFiles(fAnyProgress);
			if (FAILED(hr))
			{
				if (!fAnyProgress)
					goto Finish;

				::VLog(L"Failure while processing self-registering items, but some did register, so we're going to try again.  hresult = 0x%08lx", hr);
			}
		} while (FAILED(hr) && fAnyProgress);

		hr = g_KProgress.HrInitializePhase(achInstallPhaseRegisteringJavaComponents);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for vjreg pass failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VLog(L"Registering any Java classes via vjreg.exe");
		hr = g_pwil->HrRegisterJavaClasses();
		if (FAILED(hr))
			goto Finish;

		hr = g_KProgress.HrInitializePhase(achInstallPhaseRegisteringDCOMComponents);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for clireg32 pass failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VLog(L"Processing any DCOM entries");
		hr = g_pwil->HrProcessDCOMEntries();
		if (FAILED(hr))
			goto Finish;

		hr = g_KProgress.HrInitializePhase(achInstallPhaseCreatingRegistryKeys);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for registry key creation pass failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VLog(L"Creating registry entries");
		hr = g_pwil->HrAddRegistryEntries();
		if (FAILED(hr))
			goto Finish;

		hr = g_KProgress.HrInitializePhase(achInstallPhaseUpdatingFileReferenceCounts);
		if (FAILED(hr))
		{
			::VLog(L"Initializing progress info for file refcount update failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		::VLog(L"Incrementing file reference counts");
		hr = g_pwil->HrIncrementReferenceCounts();
		if (FAILED(hr))
			goto Finish;

		//create the shortcut items
		::VLog(L"Creating shortcut(s)");
		hr = g_pwil->HrCreateShortcuts();
		if (FAILED(hr))
			goto Finish;

	}

	hr = NOERROR;

Finish:
	return hr;
}




//in terms of uninstalling, we would have to do the following:
// 1 -- delete all the files and directories that we created
// 2 -- get rid of all the registry keys that we created
// 3 -- decrement the ref count for DLLs
// 4 -- check if the DAT file still exists.  If so, delete it and
//		the install directory
//TODO:  UNDONE:
//Still need to go through the list of uninstall EXEs to run and run
//them one by one.
HRESULT HrDoUninstall(HINSTANCE hInstance, HINSTANCE hPrevInstance, int nCmdShow)
{
	HRESULT hr = NOERROR;

	hr = g_KProgress.HrInitializeActiveProgressDialog(g_hInst, false);
	if (FAILED(hr))
		goto Finish;

	hr = ::HrPumpMessages(false);
	if (FAILED(hr))
		goto Finish;

	if (g_fDeleteMe)
	{
		hr = ::HrDeleteMe();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

typedef HRESULT (CWorkItemList::*PFNWILSTEPFUNCTION)();

static HRESULT HrTryUninstallStep(PFNWILSTEPFUNCTION pfn, LPCWSTR szStepName) throw ()
{
	if (FAILED(g_hrFinishStatus))
		return g_hrFinishStatus;

	HRESULT hr = NOERROR;

	for (;;)
	{
		hr = (g_pwil->*pfn)();
		if (!g_fSilent && (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)))
		{
			if (!::FMsgBoxYesNo(achUninstallTitle, achUninstallSureAboutCancel))
				continue;

			hr = E_ABORT;
		}
		break;
	}

	if (FAILED(hr))
		::VLog(L"Uninstallation step %s failed; hresult = 0x%08lx", szStepName, hr);

	return hr;
}

HRESULT HrContinueUninstall()
{
	HRESULT hr;
	LONG iStatus = ERROR_PATH_NOT_FOUND;
	WCHAR szValue[MSINFHLP_MAX_PATH];
	WCHAR szExpandedValue[MSINFHLP_MAX_PATH];
	ULONG i;

	//get the installation directory & put into listLDID
	hr = ::HrGetInstallDir();
	if (FAILED(hr))
		goto Finish;

	hr = g_pwil->HrAddRefCount(L"<AppDir>\\msinfhlp.dat|0");
	if (FAILED(hr))
		goto Finish;

	hr = g_KProgress.HrStartStep(NULL);
	if (FAILED(hr))
		goto Finish;

	// Get the current skinny
	hr = ::HrTryUninstallStep(&CWorkItemList::HrUninstall_InitialScan, L"Initial Scan");
	if (FAILED(hr))
		goto Finish;

	hr = ::HrTryUninstallStep(&CWorkItemList::HrRunPreuninstallCommands, L"Preinstallation Commands");
	if (FAILED(hr))
		goto Finish;

	hr = ::HrTryUninstallStep(&CWorkItemList::HrUninstall_DetermineFilesToDelete, L"Determining Files To Delete");
	if (FAILED(hr))
		goto Finish;

	for (;;)
	{
		hr = g_pwil->HrUninstall_CheckIfRebootRequired();

		if (!g_fSilent && (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)))
		{
			if (!::FMsgBoxYesNo(achUninstallTitle, achUninstallSureAboutCancel))
				continue;

			hr = E_ABORT;
		}

		if (FAILED(hr))
		{
			::VLog(L"Uninstall check for reboot required failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (!g_fSilent && g_fRebootRequired)
		{
			if (::FMsgBoxYesNo(achInstallTitle, "Some files to be deleted are in use.  Retry deletions before rebooting?"))
			{
				g_fRebootRequired = false;
				continue;
			}
		}

		break;
	}

	// If the files to be deleted are busy, we need to ask for them to be deleted at boot
	// time; so we definitely have to unregister and do the deletion pass even if we're going
	// to reboot.

	hr = ::HrTryUninstallStep(&CWorkItemList::HrUninstall_Unregister, L"Unregistration");
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Starting delete files uninstall step...");

	hr = ::HrTryUninstallStep(&CWorkItemList::HrUninstall_DeleteFiles, L"Deleting Files");
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Starting update reference count uninstall step...");

	hr = ::HrTryUninstallStep(&CWorkItemList::HrUninstall_UpdateRefCounts, L"Updating File Reference Counts");
	if (FAILED(hr))
		goto Finish;

	// we need to delete the shortcut before the registry key because we need to look in
	// the registry to see which file we're deleting.  We can do this regardless of whether
	// we're rebooting or not.
	hr = ::HrDeleteShortcut();
	if (FAILED(hr))
	{
		::VLog(L"Uninstall shortcut deletion failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	//let's get rid of all the registry keys
	hr = g_pwil->HrDeleteRegistryEntries();
	if (FAILED(hr))
	{
		::VLog(L"Uninstall registry entry deletion failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

typedef WINSHELLAPI HRESULT (WINAPI *SHGETSPECIALFOLDERLOCATION)(HWND, int, LPITEMIDLIST *);
typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPSTR );






//Most file extensions are LNK files.  BUT shortcuts to BAT files are actually PIF files.
//That's because each shortcut to a BAT file contains its own options for how the DOS box
//should be set up.  So here, we're checking for PIF as well as LNK files.
//The correct way to do this would be to somehow get the shortcut name when we're saving
//it, even if the filename is different than what we told IPersistFile to save to, and then
//putting the shortcut name in the registry.  That way, we can just get the shortcut name
//on uninstall.  But since that didn't work with "IPersistFile::GetCurFile()", we resort 
//to looping through the list of extensions   --kinc (1/30/98)

//NOTE:  after IPersistFile::Save(), IPersistFile::GetCurFile() always returns a NULL.
//	odd...
HRESULT HrDeleteShortcut()
{
	HRESULT hr = NOERROR;
	WCHAR szToDelete[_MAX_PATH];
	DWORD dwAttr;

	hr = S_FALSE;
	szToDelete[0] = L'\0';

	//if we can find the shortcut registry entry, let's delete that file
	hr = ::HrGetShortcutEntryToRegistry(NUMBER_OF(szToDelete), szToDelete);
	if (hr == E_INVALIDARG)
	{
		::VLog(L"::HrGetShortcutEntryToRegistry() returned E_INVALIDARG, so we're looking for a .lnk file");

		WCHAR szStartMenu[_MAX_PATH];
		WCHAR szStartName[_MAX_PATH];

		hr = ::HrGetStartMenuDirectory(NUMBER_OF(szStartMenu), szStartMenu);
		if (FAILED(hr))
		{
			::VLog(L"Attempt to get start menu directory failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		//get the application name & start menu directory
		if (!g_pwil->FLookupString(achStartName, NUMBER_OF(szStartName), szStartName))
			wcscpy(szStartName, L"Shortcut");

		//construct name of shortcut file
		::VFormatString(NUMBER_OF(szToDelete), szToDelete, L"%0\\%1.lnk", szStartMenu, szStartName);
		::VLog(L"Predicted link filename: \"%s\"", szToDelete);
	}
	else if (FAILED(hr))
	{
		::VLog(L"Attempt to get shortcut registry entry failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	dwAttr = NVsWin32::GetFileAttributesW(szToDelete);
	if (dwAttr != 0xffffffff)
	{
		::VLog(L"Deleting shortcut file: \"%s\"", szToDelete);

		if (dwAttr & FILE_ATTRIBUTE_READONLY)
		{
			::SetLastError(ERROR_SUCCESS);
			if (!NVsWin32::SetFileAttributesW(szToDelete, dwAttr & (~FILE_ATTRIBUTE_READONLY)))
			{
				const DWORD dwLastError = ::GetLastError();
				if (dwLastError != ERROR_SUCCESS)
				{
					::VLog(L"Failed to make readonly shortcut file writable; last error = %d", dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		if (!NVsWin32::DeleteFileW(szToDelete))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Failed to delete shortcut file; last error: %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}
	else
	{
		const DWORD dwLastError = ::GetLastError();

		if (dwLastError != ERROR_FILE_NOT_FOUND &&
			dwLastError != ERROR_PATH_NOT_FOUND)
		{
			::VLog(L"Attempt to get file attributes when deleting shortcut failed; hresult = 0x%08lx", hr);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrGetStartMenuDirectory(ULONG cchBuffer, WCHAR szOut[])
{
	HRESULT hr = NOERROR;
	LPITEMIDLIST pItemIdList = NULL;

	hr = ::SHGetSpecialFolderLocation(::GetForegroundWindow(), CSIDL_COMMON_PROGRAMS, &pItemIdList );
	if (FAILED(hr))
	{
		::VLog(L"Attempt to fetch the 'Common Programs' value failed; hresult = 0x%08lx", hr);

		// In today's "Strange But True Win32 Facts", if CSIDL_COMMON_PROGRAMS isn't supported, which
		// is the case on Win95 and Win98, the hr returned is E_OUTOFMEMORY for Win98, and the more
		// correct E_INVALIDARG for win95.
		if (E_OUTOFMEMORY == hr || E_INVALIDARG == hr)
		{
			::VLog(L"Trying programs value");
			hr = ::SHGetSpecialFolderLocation(::HwndGetCurrentDialog(), CSIDL_PROGRAMS, &pItemIdList );
			if (FAILED(hr))
			{
				::VLog(L"Attempt to fetch the 'Programs' value failed; hresult = 0x%08lx", hr);
				goto Finish;
			}
		}
		else
		{
			goto Finish;
		}
	}
	WCHAR szPath[ _MAX_PATH ];
	::SetLastError( ERROR_SUCCESS );
	if (!NVsWin32::SHGetPathFromIDListW(pItemIdList, szPath))
	{
		const DWORD dwLastError = ::GetLastError();

		::VLog(L"Failed to get special folder path");
		if (ERROR_SUCCESS == dwLastError)
		{
			hr = E_FAIL;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(dwLastError);
		}
		goto Finish;
	}
	::VLog(L"Special folder is : [%s]", szPath);
	wcsncpy( szOut, szPath, cchBuffer );
	szOut[cchBuffer-1] = L'\0';
	hr = NOERROR;

Finish:
	if (pItemIdList)
		::CoTaskMemFree( pItemIdList );
	return hr;
}


//parses the command line, and puts the arguments in some global vars
//to handle spaces within filenames, it is REQUIRED that each of the 2 input parameters
//have ";" around them.   TODO:  BUG:  HACK:  should use something other than ";"

//I'm changing this program to do the install & not use advpack, so now we only need
//the DAT file and the operative(install/uninstall).
HRESULT HrParseCmdLine(PCWSTR pszCmdLine)
{
	HRESULT hr = NOERROR;

	int iCount=1;
	LPOLESTR first, second;
	LPOLESTR fifth=NULL, sixth=NULL;

	LPOLESTR lpCmdLine=NULL;
	LPOLESTR firstMatch=NULL, secondMatch=NULL, running;

	WCHAR szCommandLine[MSINFHLP_MAX_PATH];
    wcsncpy(szCommandLine, pszCmdLine, NUMBER_OF(szCommandLine));

	first = NULL;
	second = NULL;

	//get each of the six pointers to the quotes
	//if any of them fails, this method fails!!!
	first = wcschr(szCommandLine, L';');
	if (first == NULL)
	{
		::VLog(L"Invalid command line - no first semicolon");
		hr = E_INVALIDARG;
		goto Finish;
	}

	second = wcschr((first + 1), L';');
	if (second == NULL)
	{
		::VLog(L"Invalid command line - no second semicolon");
		hr = E_INVALIDARG;
		goto Finish;;
	}

	//set each second quote to string terminator
	*second = '\0';

	if (!_wcsicmp((first + 1), L"install"))
		g_Action = eActionInstall;
	else if (!_wcsicmp((first + 1), L"install-silent"))
	{
		g_Action = eActionInstall;
		g_fSilent = true;
	}
	else if (!_wcsicmp((first + 1), L"uninstall"))
		g_Action = eActionUninstall;
	else if (!_wcsicmp((first + 1), L"uninstall-silent"))
	{
		g_Action = eActionInstall;
		g_fSilent = true;
	}
	else if (!_wcsicmp((first + 1), L"install-postreboot"))
		g_Action = eActionPostRebootInstall;
	else if (!_wcsicmp((first + 1), L"uninstall-postreboot"))
		g_Action = eActionPostRebootUninstall;
	else if (!_wcsicmp((first + 1), L"wait-for-process"))
		g_Action = eActionWaitForProcess;
	else
	{
		::VLog(L"Unrecognized action: \"%s\"", first+1);
		hr = E_INVALIDARG;
		goto Finish;
	}

	//let's go through the string and put everything that's between quotes into the tree

	running = second+1;

	while (*running != '\0')
	{
		//let's look for the first & second semi-colons
		firstMatch = wcschr(running, L';');
		if (firstMatch)
			secondMatch = wcschr(firstMatch + 1, L';');
		else
			break;

		if (!secondMatch)
			break;

		*secondMatch = L'\0';

		wcsncpy(g_wszDatFile, firstMatch + 1, NUMBER_OF(g_wszDatFile));
		g_wszDatFile[NUMBER_OF(g_wszDatFile) - 1] = L'\0';

		running = secondMatch + 1;
	}

	hr = NOERROR;

Finish:
	return hr;
}


//parse the data file and put necessary info into global structures
//Currently, we have to look parse for the following sections:
// [EXEsToRun]
// [DllCount]
// [Strings]
// [FileEntries]
// [AddRegistryEntries]
// [DelRegistryEntries]
// [RegisterOCS]
//And each section has its corresponding list of items
HRESULT HrParseDatFile()
{
	int iRun=0;
	WCHAR *pEqual;
	HRESULT hr = NOERROR;;

	DWORD dwSizeLow, dwSizeHigh;

	WCHAR szFile[_MAX_PATH];

	LPWSTR pwszFilePart = NULL;

	LPCWSTR pszDatFile_View = NULL;
	LPCWSTR pszDatFile_Current = NULL;
	LPCWSTR pszDatFile_End = NULL;

	HANDLE hFile = NULL;
	HANDLE hFilemap = NULL;

	KList *list=NULL;

	ULONG i;

	if (NVsWin32::GetFullPathNameW(g_wszDatFile, NUMBER_OF(szFile), szFile, &pwszFilePart) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	::VLog(L"Opening installation data file: \"%s\"", szFile);

	//open the darn file for read
	hFile = NVsWin32::CreateFileW(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Attempt to open dat file failed; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	dwSizeLow = ::GetFileSize(hFile, &dwSizeHigh);
	if (dwSizeLow == 0xffffffff)
	{
		const DWORD dwLastError = ::GetLastError();
		if (dwLastError != NO_ERROR)
		{
			::VLog(L"Getting file size of DAT file failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	if (dwSizeHigh != 0)
	{
		::VLog(L"DAT file too big!");
		hr = E_FAIL;
		goto Finish;
	}

	hFilemap = ::CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwSizeLow, NULL);
	if (hFilemap == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"While parsing DAT file, CreateFileMapping() failed; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	pszDatFile_View = (LPCWSTR) ::MapViewOfFile(hFilemap, FILE_MAP_READ, 0, 0, dwSizeLow);
	if (pszDatFile_View == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Error mapping view of dat file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	pszDatFile_Current = pszDatFile_View;
	pszDatFile_End = (LPCWSTR) (((LPBYTE) pszDatFile_View) + dwSizeLow);

	if (*pszDatFile_Current == 0xfeff)
		pszDatFile_Current++;

	hr = ::HrConstructKListFromDelimiter(pszDatFile_Current, pszDatFile_End, L'\n', &list);
	if (FAILED(hr))
		goto Finish;

	//loop through to process each line
	for (i=0; i<list->GetCount()-1; i++)
	{
		WCHAR szLine[MSINFHLP_MAX_PATH];
		int len;
		szLine[0] = L'\0';
		if (!list->FetchAt(i, NUMBER_OF(szLine), szLine))
			continue;

		len = wcslen(szLine);
		//if the previous characters was a carriage return, let's get rid of that baby
		if (szLine[len-1] == L'\r')
			szLine[len-1] = L'\0';

		//we don't need to handle BLANK strings
		if (szLine[0] == L'\0')
			continue;

		//do the rest of the stuff here...

		//decide which heading we're under
		if (wcsstr(szLine, achDllCount))
			iRun = 11;
		else if (wcsstr(szLine, achInstallEXEsToRun))
			iRun = 22;
		else if (wcsstr(szLine, achStrings))
			iRun = 33;
		else if (wcsstr(szLine, achFiles))
			iRun = 44;
		else if (wcsstr(szLine, achAddReg))
			iRun = 55;
		else if (wcsstr(szLine, achDelReg))
			iRun = 66;
		else if (wcsstr(szLine, achRegisterOCX))
			iRun = 77;
		else if (wcsstr(szLine, achUninstallEXEsToRun))
			iRun = 88;
		else if (wcsstr(szLine, achUninstallFiles))
			iRun = 99;
		else if (wcsstr(szLine, achDCOMComponentsToRun))
			iRun = 0;

		//match heading with action
		switch (iRun)
		{
		case 11:
			iRun = 1;
			break;
		case 22:
			iRun = 2;
			break;
		case 33:
			iRun = 3;
			break;
		case 44:
			iRun = 4;
			break;
		case 55:
			iRun = 5;
			break;
		case 66:
			iRun = 6;
			break;
		case 77:
			iRun = 7;
			break;
		case 88:
			iRun = 8;
			break;
		case 99:
			iRun = 9;
			break;
		case 0:
			iRun = 10;
			break;
		case 1:
			hr = g_pwil->HrAddRefCount(szLine);
			if (FAILED(hr))
				goto Finish;
			break;
		case 2:
			if (szLine[0] == L'*')
				hr = g_pwil->HrAddPostinstallRun(&szLine[1]);
			else
				hr = g_pwil->HrAddPreinstallRun(szLine);

			if (FAILED(hr))
				goto Finish;
			break;
		case 3:
			pEqual = wcschr(szLine, L'=');
			//if there's no equal sign, then it's not a string assignment
			if (pEqual == NULL)
				break;
			*pEqual = 0;
			pEqual++;
			hr = g_pwil->HrAddString(szLine, pEqual);
			if (FAILED(hr))
			{
				::VLog(L"HrAddString() failed.  Jumping to finish with 0x%x", hr);
				goto Finish;
			}

			break;
		case 4:
			pEqual = wcschr(szLine, L';');
			//if there's no equal sign, then it's not a string assignment
			if (pEqual == NULL)
				break;
			*pEqual = 0;
			pEqual++;
			hr = g_pwil->HrAddFileCopy(szLine, pEqual);
			if (FAILED(hr))
				goto Finish;
			break;
		case 5:
			hr = g_pwil->HrAddAddReg(szLine);
			if (FAILED(hr))
				goto Finish;
			break;
		case 6:
			hr = g_pwil->HrAddDelReg(szLine);
			if (FAILED(hr))
				goto Finish;
			break;
		case 7:
			hr = g_pwil->HrAddRegisterOCX(szLine);
			if (FAILED(hr))
				goto Finish;
			break;
		case 8:
			if (szLine[0] == L'*')
				hr = g_pwil->HrAddPostuninstallRun(&szLine[1]);
			else
				hr = g_pwil->HrAddPreuninstallRun(szLine);

			if (FAILED(hr))
				goto Finish;
			break;
		case 9:
			hr = g_pwil->HrAddFileDelete(szLine);
			if (FAILED(hr))
				goto Finish;
			break;
		case 10:
			hr = g_pwil->HrAddDCOMComponent(szLine);
			if (FAILED(hr))
				goto Finish;
			break;

		default:
			break;
		}
	}

	if (pszDatFile_View != NULL)
	{
		if (!::UnmapViewOfFile(pszDatFile_View))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to unmap view of dat file; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		pszDatFile_View = NULL;
	}

	if ((hFilemap != NULL) && (hFilemap != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(hFilemap))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to close file map handle; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	
		hFilemap = NULL;
	}

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(hFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to close dat file handle failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		hFile = NULL;
	}

	hr = NOERROR;

Finish:
	//
	// We now do closes which clean up even in failure cases.  We closed earlier, checking statuses
	// on the close handle calls, but in here we're already handling an error so we don't care if
	// something bizarre happens on closehandle or unmapviewoffile.
	if (pszDatFile_View != NULL)
	{
		if (!::UnmapViewOfFile(pszDatFile_View))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to unmap view of dat file; last error = %d", dwLastError);
		}

		pszDatFile_View = NULL;
	}

	if ((hFilemap != NULL) && (hFilemap != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(hFilemap))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to close file map handle; last error = %d", dwLastError);
		}
	
		hFilemap = NULL;
	}

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(hFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to close dat file handle failed; last error = %d", dwLastError);
		}

		hFile = NULL;
	}

	if (list != NULL)
	{
		delete list;
		list = NULL;
	}

	return hr;
}


//resolve the LDID's referenced in the different sections of DAT file
HRESULT HrAddWellKnownDirectoriesToStringTable()
{
	HRESULT hr = NOERROR;
	int len=0;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	CVsRegistryKey hkeyExplorer;
	CVsRegistryKey hkeyCurrentVersion;

	//insert these items into the LDID list
	//We don't know what the AppDir will be yet, so we resolve that later
	//LPOLESTR achSMWinDir="<windir>";
	//LPOLESTR achSMSysDir="<sysdir>";
	//LPOLESTR achSMAppDir="<appdir>";
	//LPOLESTR achSMieDir="<iedir>";
	//LPOLESTR achProgramFilesDir="<programfilesdir>";

	//Below, we resolve the macros that we know might be in use.
	//first do the windows directory

	if (0 == NVsWin32::GetWindowsDirectoryW(szBuffer, NUMBER_OF(szBuffer)))
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to obtain windows directory path; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	hr = g_pwil->HrAddString(achSMWinDir, szBuffer);
	if (FAILED(hr))
	{
		::VLog(L"Adding achSMWinDir to well known directory list failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	//then work on the system directory
	if (!NVsWin32::GetSystemDirectoryW(szBuffer, NUMBER_OF(szBuffer)))
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to obtain windows system directory path; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	hr = g_pwil->HrAddString(achSMSysDir,szBuffer);
	if (FAILED(hr))
	{
		::VLog(L"Adding achSMSysDir to well known directory list failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	//now get the IE directory
	//do the processing only if we successfully get the IE path
	hr = hkeyExplorer.HrOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE", 0, KEY_QUERY_VALUE);
	if ((hr != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) &&
		(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
	{
		if (FAILED(hr))
		{
			::VLog(L"Unable to open key HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE; hresult: 0x%08lx", hr);
			goto Finish;
		}

		hr = hkeyExplorer.HrGetStringValueW(L"Path", NUMBER_OF(szBuffer), szBuffer);
		if (FAILED(hr))
		{
			::VLog(L"Unable to get Path from IExplore key; hresult: 0x%08lx", hr);
			goto Finish;
		}

		len = wcslen(szBuffer);
		//if the string "\;" are the last 2 characters of the string, then we
		//may chop it off
		if ((len > 0) && (szBuffer[len-1] == L';'))
			szBuffer[len-1] = L'\0';
		if ((len > 1) && (szBuffer[len-2] == L'\\'))
			szBuffer[len-2] = L'\0';

		hr = g_pwil->HrAddString(achSMieDir, szBuffer);
		if (FAILED(hr))
		{
			::VLog(L"Adding achSMieDir to well known directory list failed; hresult = 0x%08lx", hr);
			goto Finish;
		}
	}

	// This one's just gotta be there...
	hr = hkeyCurrentVersion.HrOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion", 0, KEY_QUERY_VALUE);
	if (FAILED(hr))
	{
		::VLog(L"Unable to open the HKLM\\Software\\Microsoft\\Windows\\CurrentVersion key");
		goto Finish;
	}

	hr = hkeyCurrentVersion.HrGetStringValueW(L"ProgramFilesDir", NUMBER_OF(szBuffer), szBuffer);
	if (FAILED(hr))
	{
		::VLog(L"Unable to get the ProgramFilesDir value from the HKLM\\Software\\Microsoft\\Windows\\CurrentVersion key");
		goto Finish;
	}

	len = wcslen(szBuffer);

	if ((len > 0) && (szBuffer[len-1] == L'\\'))
		szBuffer[len-1] = 0;

	hr = g_pwil->HrAddString(achProgramFilesDir, szBuffer);
	if (FAILED(hr))
	{
		::VLog(L"Adding achProgramFilesDir to well known directory list failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	//finally reached here, so we're successful
	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrConstructKListFromDelimiter(LPCWSTR lpString, LPCWSTR pszEnd, WCHAR wchDelimiter, KList **pplist)
{
	HRESULT hr = NOERROR;
	KList *plist;
	LPCWSTR pszCurrent = lpString;
	LPCWSTR pszNext = NULL;

	if (pplist == NULL)
		return E_INVALIDARG;

	*pplist = NULL;

	plist = new KList;
	if (plist == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	while (pszCurrent < pszEnd)
	{
		pszNext = pszCurrent + 1;

		while ((pszNext != pszEnd) && (*pszNext != wchDelimiter))
			pszNext++;

		hr = plist->HrAppend(pszCurrent, pszNext);
		if (FAILED(hr))
		{
			::VLog(L"Failed to append string to klist; hresult = 0x%08lx", hr);
			goto Finish;
		}

		pszCurrent = pszNext;
		if (pszCurrent != pszEnd)
			pszCurrent++;
	}

	hr = NOERROR;

	*pplist = plist;
	plist = NULL;

Finish:
	if (plist != NULL)
		delete plist;

	return hr;
}

bool FCompareVersion(LPOLESTR local, LPOLESTR system, bool *fStatus)
{
	int iSystem;
	int iLocal;
	LPOLESTR localMatch, systemMatch;
	LPOLESTR localRun, systemRun;
	localRun = local;
	systemRun = system;

	//as default, local is NOT bigger than system
	*fStatus = false;

	//loop until we find that one value is bigger than the other, or
	//until we can't find any more periods.
	while (true)
	{
		localMatch = wcschr(localRun, L'.');
		systemMatch = wcschr(systemRun, L'.');

		//set the string terminators in both
		if (systemMatch)
			*systemMatch = 0;
		if (localMatch)
			*localMatch = 0;

		//compare version number
		iSystem = _wtoi(systemRun);
		iLocal = _wtoi(localRun);
		if (iLocal > iSystem)
		{
			*fStatus = true;
			break;
		}
		else if (iLocal < iSystem)
			break;

		//if both are NULL, we know that the 2 version numbers have been equal up
		//to this point, so we just break and return
		if ((systemMatch == NULL) && (localMatch == NULL))
			break;

		//if version string for system file terminates and NOT for the local file,
		//then know that the version string up till now has been equal, and return
		//true
		if (systemMatch == NULL)
		{
			*fStatus = true;
			break;
		}
		if (localMatch == NULL)
			break;

		localRun = localMatch + 1;
		systemRun = systemMatch + 1;
	}

	return true;
}

//bring up the dialog that lets the user browse for a directory on their
//machine or network
//NOTE that this is a shameless copy of IExpress code...
BOOL BrowseForDir( HWND hwndParent, LPOLESTR szDefault, LPOLESTR szTitle, LPOLESTR szResult )
{
	CANSIBuffer rgchDefault, rgchTitle, rgchResult;

	//set size
	ULONG cSize=MSINFHLP_MAX_PATH-1;

	if (!rgchResult.FSetBufferSize(cSize))
		return FALSE;

	if (!rgchDefault.FSetBufferSize(cSize))
		return FALSE;

	if (!rgchDefault.FFromUnicode(szDefault))
		return FALSE;

	if (!rgchTitle.FFromUnicode(szTitle))
		return FALSE;


    BROWSEINFOA  bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    static const CHAR achShell32Lib[]                 = "SHELL32.DLL";
    static const CHAR achSHBrowseForFolder[]          = "SHBrowseForFolder";
    static const CHAR achSHGetPathFromIDList[]        = "SHGetPathFromIDList";


    // Load the Shell 32 Library to get the SHBrowseForFolder() features
    if ( ( hShell32Lib = LoadLibraryA( achShell32Lib ) ) != NULL )
	{
        if ( ( ! ( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
              GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
            || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib, (LPCSTR)SHFREE_ORDINAL) ) )
            || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
              GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            ::FreeLibrary( hShell32Lib );
            ::VErrorMsg( achInstallTitle, achErrorCreatingDialog );
            return FALSE;
        }
	}
	else 
	{
        ::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
        return FALSE;
    }

    rgchResult[0]       = 0;

    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = rgchTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM) &rgchDefault[0];

    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )
	{
        pfSHGetPathFromIDList( pidl, rgchDefault );
		rgchDefault.Sync();

        if (rgchDefault[0] != '\0')
		{
            lstrcpyA(rgchResult, rgchDefault);
        }

        (*pfSHFree)(pidl);
    }

	rgchResult.Sync();

    FreeLibrary( hShell32Lib );

	ULONG cActual;
	rgchResult.ToUnicode(cSize, szResult, &cActual);

    if ( szResult[0] != 0 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg)
	{
        case BFFM_INITIALIZED:
            // lpData is the path string
            ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }
    return 0;
}

HRESULT HrPromptUpdateFile
(
LPCSTR pszTitleKey,
LPCSTR pszMessageKey,
LPCOLESTR pszFile,
DWORD dwExistingVersionMajor,
DWORD dwExistingVersionMinor,
ULARGE_INTEGER uliExistingSize,
FILETIME ftExistingTime,
DWORD dwInstallerVersionMajor,
DWORD dwInstallerVersionMinor,
ULARGE_INTEGER uliInstallerSize,
FILETIME ftInstallerTime,
UpdateFileResults &rufr
)
{
	HRESULT hr = NOERROR;

	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];
	WCHAR szFullMessage[MSINFHLP_MAX_PATH];

	//if they're not in the list, use what's provided
	g_pwil->VLookupString(pszTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(pszMessageKey, NUMBER_OF(szMessage), szMessage);

	VFormatString(NUMBER_OF(szFullMessage), szFullMessage, szMessage, pszFile);

	//let's create the message box & populate it with what's gonna go into the box
	UPDATEFILEPARAMS ufp;

	ufp.m_szTitle = szTitle;
	ufp.m_szMessage = szFullMessage;
	ufp.m_szFilename = pszFile;
	ufp.m_ftLocal = ftExistingTime;
	ufp.m_uliSizeLocal = uliExistingSize;
	ufp.m_dwVersionMajorLocal = dwExistingVersionMajor;
	ufp.m_dwVersionMinorLocal = dwExistingVersionMinor;
	ufp.m_ftInstall = ftInstallerTime;
	ufp.m_uliSizeInstall = uliInstallerSize;
	ufp.m_dwVersionMajorInstall = dwInstallerVersionMajor;
	ufp.m_dwVersionMinorInstall = dwInstallerVersionMinor;
	ufp.m_ufr = eUpdateFileResultCancel;

	//bring up dialog
	int iResult = NVsWin32::DialogBoxParamW(
		g_hInst,
		MAKEINTRESOURCEW(IDD_UPDATEFILE),
		g_KProgress.HwndGetHandle(),
		UpdateFileDlgProc,
		(LPARAM) &ufp);
	if (iResult == -1)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	rufr = ufp.m_ufr;

	hr = NOERROR;

Finish:
	return hr;
}

//TODO:  UNDONE:
//We might need to do a setfonts here to correspond to whatever fonts that we're
//using in the current install machine.  This allows the characters to display
//correctly in the edit box.
BOOL CALLBACK UpdateFileDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static UINT rguiControls[] =
	{
		IDC_UPDATEFILE_STATIC1,
		IDC_UPDATEFILE_EDIT_FILENAME,
		IDC_UPDATEFILE_E_STATIC2,
		IDC_UPDATEFILE_I_STATIC3,
		IDC_UPDATEFILE_I_SIZE,
		IDC_UPDATEFILE_I_TIME,
		IDC_UPDATEFILE_I_VERSION,
		IDC_UPDATEFILE_E_SIZE,
		IDC_UPDATEFILE_E_TIME,
		IDC_UPDATEFILE_E_VERSION,
		IDC_UPDATEFILE_KEEP,
		IDC_UPDATEFILE_KEEPALL,
		IDC_UPDATEFILE_REPLACE,
		IDC_UPDATEFILE_REPLACEALL,
		IDC_UPDATEFILE_STATIC4,
	};

	static UpdateFileResults *pufr;

	HRESULT hr;

	//process the message
	switch (uMsg) 
	{
		//************************************
		//initialize dialog
		case WM_INITDIALOG:
		{
			::VSetDialogFont(hwndDlg, rguiControls, NUMBER_OF(rguiControls));

			UPDATEFILEPARAMS *pufp = (UPDATEFILEPARAMS *) lParam;
			pufr = &pufp->m_ufr;

			(void) ::HrCenterWindow(hwndDlg, ::GetDesktopWindow());
			(void) NVsWin32::SetWindowTextW(hwndDlg, pufp->m_szTitle);

			//cannot set text, we complain and end the dialog returning FALSE
			if (! NVsWin32::SetDlgItemTextW( hwndDlg, IDC_UPDATEFILE_EDIT_FILENAME, pufp->m_szFilename))
			{
				::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
				::EndDialog(hwndDlg, FALSE);
				return TRUE;
			}

			if (!NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_STATIC1, pufp->m_szMessage))
			{
				::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
				::EndDialog(hwndDlg, FALSE);
				return TRUE;
			}

			SYSTEMTIME st;
			FILETIME ftTemp;
			WCHAR szBuffer[MSINFHLP_MAX_PATH];
			WCHAR szFormatString[MSINFHLP_MAX_PATH];
			WCHAR szDateTemp[_MAX_PATH];
			WCHAR szTimeTemp[_MAX_PATH];
			WCHAR szDecimalSeparator[10];

			NVsWin32::GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSeparator, NUMBER_OF(szDecimalSeparator));

			::FileTimeToLocalFileTime(&pufp->m_ftLocal, &ftTemp);
			::FileTimeToSystemTime(&ftTemp, &st);

			NVsWin32::GetDateFormatW(
							LOCALE_USER_DEFAULT,
							DATE_SHORTDATE,
							&st,
							NULL,
							szDateTemp,
							NUMBER_OF(szDateTemp));

			NVsWin32::GetTimeFormatW(
							LOCALE_USER_DEFAULT,
							0,
							&st,
							NULL,
							szTimeTemp,
							NUMBER_OF(szTimeTemp));

			if (!g_pwil->FLookupString(achDateTemplate, NUMBER_OF(szFormatString), szFormatString))
				wcscpy(szFormatString, L"Created: %0 %1");

			::VFormatString(NUMBER_OF(szBuffer), szBuffer, szFormatString, szDateTemp, szTimeTemp);

			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_E_TIME, szBuffer);

			::FileTimeToLocalFileTime(&pufp->m_ftInstall, &ftTemp);
			::FileTimeToSystemTime(&ftTemp, &st);

			NVsWin32::GetDateFormatW(
							LOCALE_USER_DEFAULT,
							DATE_SHORTDATE,
							&st,
							NULL,
							szDateTemp,
							NUMBER_OF(szDateTemp));

			NVsWin32::GetTimeFormatW(
							LOCALE_USER_DEFAULT,
							0,
							&st,
							NULL,
							szTimeTemp,
							NUMBER_OF(szTimeTemp));

			if (!g_pwil->FLookupString(achDateTemplate, NUMBER_OF(szFormatString), szFormatString))
				wcscpy(szFormatString, L"Created: %0 %1");

			::VFormatString(NUMBER_OF(szBuffer), szBuffer, szFormatString, szDateTemp, szTimeTemp);

			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_I_TIME, szBuffer);

			swprintf(szTimeTemp, L"%I64d", pufp->m_uliSizeLocal.QuadPart);
			
			NVsWin32::GetNumberFormatW(
							LOCALE_USER_DEFAULT,
							0,
							szTimeTemp,
							NULL,
							szDateTemp,
							NUMBER_OF(szDateTemp));

			WCHAR *pwchDecimalSeparator = wcsstr(szDateTemp, szDecimalSeparator);
			if (pwchDecimalSeparator != NULL &&
				pwchDecimalSeparator != szDateTemp)
				*pwchDecimalSeparator = L'\0';

			if (!g_pwil->FLookupString(achFileSizeTemplate, NUMBER_OF(szFormatString), szFormatString))
				wcscpy(szFormatString, L"%0 bytes");

			::VFormatString(NUMBER_OF(szBuffer), szBuffer, szFormatString, szDateTemp);

			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_E_SIZE, szBuffer);

			swprintf(szTimeTemp, L"%I64d", pufp->m_uliSizeInstall.QuadPart);

			NVsWin32::GetNumberFormatW(
							LOCALE_USER_DEFAULT,
							0,
							szTimeTemp,
							NULL,
							szDateTemp,
							NUMBER_OF(szDateTemp));

			pwchDecimalSeparator = wcsstr(szDateTemp, szDecimalSeparator);
			if (pwchDecimalSeparator != NULL &&
				pwchDecimalSeparator != szDateTemp)
				*pwchDecimalSeparator = L'\0';

			if (!g_pwil->FLookupString(achFileSizeTemplate, NUMBER_OF(szFormatString), szFormatString))
				wcscpy(szFormatString, L"%0 bytes");

			::VFormatString(NUMBER_OF(szBuffer), szBuffer, szFormatString, szDateTemp);

			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_I_SIZE, szBuffer);

			if ((pufp->m_dwVersionMajorLocal != 0xffffffff) ||
				(pufp->m_dwVersionMinorLocal != 0xffffffff))
			{
				swprintf(szBuffer, L"File version: %d.%02d.%02d",
								HIWORD(pufp->m_dwVersionMajorLocal),
								LOWORD(pufp->m_dwVersionMajorLocal),
								pufp->m_dwVersionMinorLocal);
			}
			else
				szBuffer[0] = L'\0';

			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_E_VERSION, szBuffer);

			if ((pufp->m_dwVersionMajorInstall != 0xffffffff) ||
				(pufp->m_dwVersionMinorInstall != 0xffffffff))
			{
				swprintf(szBuffer, L"File version: %d.%02d.%02d",
								HIWORD(pufp->m_dwVersionMajorInstall),
								LOWORD(pufp->m_dwVersionMajorInstall),
								pufp->m_dwVersionMinorInstall);
			}
			else
				szBuffer[0] = L'\0';
			NVsWin32::SetDlgItemTextW(hwndDlg, IDC_UPDATEFILE_I_VERSION, szBuffer);

			//we set the text for the different button controls

			static const DialogItemToStringKeyMapEntry s_rgMap[] =
			{
				{ IDC_UPDATEFILE_KEEP, achKeep },
				{ IDC_UPDATEFILE_KEEPALL, achKeepAll },
				{ IDC_UPDATEFILE_REPLACE, achReplace },
				{ IDC_UPDATEFILE_REPLACEALL, achReplaceAll },
				{ IDC_UPDATEFILE_E_STATIC2, achUpdateExistingFileLabel },
				{ IDC_UPDATEFILE_I_STATIC3, achUpdateInstallingFileLabel },
				{ IDC_UPDATEFILE_STATIC4, achUpdateQuery }
			};

			::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);

			HWND hwndKeep = NULL;
			hwndKeep = ::GetDlgItem(hwndDlg, IDC_UPDATEFILE_KEEP);
			if (hwndKeep != NULL)
			{
				::SetFocus(hwndKeep);
				return FALSE;
			}

			return TRUE;
		}

		//*************************************
		//close message
		case WM_CLOSE:
		{
			*pufr = eUpdateFileResultCancel;
			::EndDialog(hwndDlg, FALSE);
			return TRUE;
		}

		//*************************************
		//process control-related commands
		case WM_COMMAND:
		{
			switch (wParam)
			{
				case IDC_UPDATEFILE_KEEP:
				{
					*pufr = eUpdateFileResultKeep;
					::EndDialog(hwndDlg, TRUE);
					return TRUE;
				}

				case IDC_UPDATEFILE_KEEPALL:
				{
					*pufr = eUpdateFileResultKeepAll;
					::EndDialog(hwndDlg, TRUE);
					return TRUE;
				}

				case IDC_UPDATEFILE_REPLACE:
				{
					*pufr = eUpdateFileResultReplace;
					::EndDialog(hwndDlg, TRUE);
					return TRUE;
				}
				
				case IDC_UPDATEFILE_REPLACEALL:
				{
					*pufr = eUpdateFileResultReplaceAll;
					::EndDialog(hwndDlg, TRUE);
					return TRUE;
				}
			}
			return TRUE;
		}
	}
	return FALSE;
}






//the following 3 methods are wrappers around the **active** progress dialog
//The previous 3 methods will be around until this is fully functional
HRESULT KActiveProgressDlg::HrInitializeActiveProgressDialog(HINSTANCE hInst, bool fInstall)
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(g_pwil);

	bool fAnyPreinstallation = false;
	bool fHasDCOM = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		// We don't break early because over time we'll be looking for and counting many
		// things in this loop.

		if (iter->m_fRunBeforeInstall)
			fAnyPreinstallation = true;

		if (iter->m_fRegisterAsDCOMComponent)
			fHasDCOM = true;
	}

	int i=0;
	if (fInstall)
	{
		::VLog(L"Initializing progress dialog for installation");

		m_listDialog[i++] = IDD_WELCOME;

		//include this dialog only if we have sub-installers
		if (fAnyPreinstallation)
			m_listDialog[i++] = IDD_EXESTORUN;

		m_listDialog[i++] = IDD_INSTALLTO;

		if (fHasDCOM)
		{
			WCHAR szRemoteServer[_MAX_PATH];
			WCHAR szAlwaysPromptForRemoteServer[_MAX_PATH];

			//then if server strong is NULL or if we always prompt, we stick in the DCOM page
			if (!g_pwil->FLookupString(achRemoteServer, NUMBER_OF(szRemoteServer), szRemoteServer))
				szRemoteServer[0] = L'\0';

			if (g_pwil->FLookupString(achAlwaysPromptForRemoteServer, NUMBER_OF(szAlwaysPromptForRemoteServer), szAlwaysPromptForRemoteServer) || (szRemoteServer[0] == 0))
				m_listDialog[i++] = IDD_DCOM;
		}

		m_listDialog[i++] = IDD_PROGRESS;
		m_listDialog[i++] = IDD_END;
	}
	else
	{
		::VLog(L"Initializing progress dialog for uninstallation");

		//for un-install, we always have 3 pages to show!
		m_listDialog[i++] = IDD_WELCOME;
		m_listDialog[i++] = IDD_PROGRESS;
		m_listDialog[i++] = IDD_END;
	}

	m_iCurrentPage = 0;
	m_iMaxPage = i;

	//loop through & create each window
	for (m_iCurrentPage=0; m_iCurrentPage<m_iMaxPage; m_iCurrentPage++)
	{
		HWND handle = NVsWin32::CreateDialogParamW(hInst, MAKEINTRESOURCEW(m_listDialog[m_iCurrentPage]), g_hwndHidden, ActiveProgressDlgProc, fInstall);
		if (handle == NULL)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Creating dialog failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		m_hwndDialog[m_iCurrentPage] = handle;

		::ShowWindow(m_hwndDialog[m_iCurrentPage], SW_HIDE);

		if (g_fStopProcess)
		{
			::VLog(L"Stopping initialization because g_fStopProcess is true");
			hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
			goto Finish;
		}
	}

	m_iCurrentPage = 0;

	hr = this->HrResizeParent();
	if (FAILED(hr))
	{
		::VLog(L"Failed to resize parent; hresult = 0x%08lx", hr);
		goto Finish;
	}

	//loop through & set windows to default position
	for (i=0; i<m_iMaxPage; i++)
	{
		RECT rectChild;

		if (!::GetWindowRect(m_hwndDialog[i], &rectChild))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Failed to get window rectangle; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		if (!::SetWindowPos(
					m_hwndDialog[i],
					HWND_TOP,
					0, 0,
					rectChild.right - rectChild.left, rectChild.bottom - rectChild.top,
					SWP_HIDEWINDOW))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Failed to set window position; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	::SendMessage(g_KProgress.HwndGetHandle(), WM_SETFOCUS, 0, 0);
	::SendMessage(::GetDlgItem(g_KProgress.HwndGetHandle(), IDC_WELCOME_CONTINUE), WM_SETFOCUS, 0, 0);

	::ShowWindow(g_hwndHidden, SW_SHOW);
	::ShowWindow(m_hwndDialog[m_iCurrentPage], SW_SHOW);

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT KActiveProgressDlg::HrResizeParent()
{
	HRESULT hr = NOERROR;

	RECT rectHidden, rectChild;
	if (!::GetWindowRect(g_hwndHidden, &rectHidden) || !::GetWindowRect(m_hwndDialog[m_iCurrentPage], &rectChild))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	m_lX = rectChild.right - rectChild.left;
	m_lY = rectChild.bottom - rectChild.top;
	//set parent window to be size of child window
	//we add an extra 25 pixels to cover for the title bar
	if (!::SetWindowPos(g_hwndHidden, HWND_TOP, rectHidden.left, rectHidden.top, m_lX, m_lY + g_iCyCaption, SWP_HIDEWINDOW))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	hr = ::HrCenterWindow(g_hwndHidden, ::GetDesktopWindow());
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}


//the following 3 methods are wrappers around the **active** progress dialog
//The previous 3 methods will be around until this is fully functional
void KActiveProgressDlg::VHideInstallationStuff()
{
	RECT rectHidden, rectChild, rectBar;
	::GetWindowRect(g_hwndHidden, &rectHidden);
	::GetWindowRect(m_hWnd, &rectChild);
	::GetWindowRect(::GetDlgItem(m_hWnd, IDC_PROGRESS_PICTURE), &rectBar);

	//set parent window to be size of child window, the cutoff being at the picture
	//we add an extra 25 pixels to cover for the title bar
	::SetWindowPos(g_hwndHidden, HWND_TOP, rectHidden.left, rectHidden.top,
		m_lX, rectBar.top - rectChild.top + g_iCyCaption, SWP_SHOWWINDOW);

	//set child window to take up entire parent window
	::SetWindowPos(m_hWnd, HWND_TOP, 0, 0, rectChild.right - rectChild.left, 
		rectChild.bottom - rectChild.top, SWP_SHOWWINDOW);

	this->VEnableChildren(FALSE);
	(void) ::HrCenterWindow(g_hwndHidden, ::GetDesktopWindow());
}



//the following 3 methods are wrappers around the **active** progress dialog
//The previous 3 methods will be around until this is fully functional
void KActiveProgressDlg::VShowInstallationStuff()
{
	RECT rectHidden, rectChild, rectBar;
	::GetWindowRect(g_hwndHidden, &rectHidden);
	::GetWindowRect(m_hWnd, &rectChild);
	::GetWindowRect(::GetDlgItem(m_hWnd, IDC_PROGRESS_PICTURE), &rectBar);

	//set parent window to be size of child window
	//we add an extra 25 pixels to cover for the title bar
	::SetWindowPos(g_hwndHidden, HWND_TOP, rectHidden.left, rectHidden.top,
		m_lX, m_lY + g_iCyCaption, SWP_SHOWWINDOW);

	this->VEnableChildren(TRUE);
	(void) ::HrCenterWindow(g_hwndHidden, ::GetDesktopWindow());
}


void KActiveProgressDlg::VEnableChildren(BOOL fEnable)
{
	::EnableWindow(::GetDlgItem(m_hWnd, IDC_PROGRESS_PICTURE), fEnable);
	::EnableWindow(::GetDlgItem(m_hWnd, IDC_PROGRESS_INSTALLDIR), fEnable);
	::EnableWindow(::GetDlgItem(m_hWnd, IDC_PROGRESS_STATIC_INSTALLDIR), fEnable);
	::EnableWindow(::GetDlgItem(m_hWnd, IDC_PROGRESS_CHANGE), fEnable);
	::EnableWindow(::GetDlgItem(m_hWnd, IDC_PROGRESS_GO), fEnable);
}

HRESULT KActiveProgressDlg::HrInitializePhase(LPCSTR szPhaseName)
{
	HRESULT hr = ::HrPumpMessages(true);
	if (FAILED(hr))
		goto Finish;

	if (this->FCheckStop())
	{
		hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
		goto Finish;
	}

	if (g_hwndProgressLabel != NULL)
	{
		WCHAR szBuffer[_MAX_PATH];

		g_pwil->VLookupString(szPhaseName, NUMBER_OF(szBuffer), szBuffer);

		NVsWin32::LrWmSetText(g_hwndProgressLabel, szBuffer);
	}

	if (g_hwndProgress != NULL)
	{
		::SendMessageA(g_hwndProgress, PBM_SETPOS, 0, 0);
	}

	if (g_hwndProgressItem != NULL)
	{
		NVsWin32::LrWmSetText(g_hwndProgressItem, L"");
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT KActiveProgressDlg::HrStartStep(LPCWSTR szItemName)
{
	HRESULT hr = ::HrPumpMessages(true);
	if (SUCCEEDED(hr))
	{
		if (this->FCheckStop())
			hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

		if (g_hwndProgressItem != NULL)
		{
			NVsWin32::LrWmSetText(g_hwndProgressItem, szItemName);
			::UpdateWindow(g_hwndProgressItem);
		}
	}

	return hr;
}

HRESULT KActiveProgressDlg::HrStep()
{
	HRESULT hr = ::HrPumpMessages(true);
	if (FAILED(hr))
		goto Finish;

	//if a stop is requested, we return false
	if (this->FCheckStop())
	{
		hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
		goto Finish;
	}

	::SendMessage(g_hwndProgress, PBM_STEPIT, 0, 0L);

	hr = ::HrPumpMessages(true);
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}

//check if the user really wants to stop
bool KActiveProgressDlg::FCheckStop()
{
	if (g_fStopProcess && !g_fSilent)
	{
		if (g_Action == eActionInstall)
		{
			if (!::FMsgBoxYesNo(achInstallTitle, achInstallSureAboutCancel))
				g_fStopProcess = FALSE;
		}
		else
		{
			if (!::FMsgBoxYesNo(achUninstallTitle, achUninstallSureAboutCancel))
				g_fStopProcess = FALSE;
		}
	}

	return g_fStopProcess;
}


//method to handle the progress dialog
BOOL CALLBACK ActiveProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam)
{
	HRESULT hr;

	//BUG:  TODO:  UNDONE:
	//Need to switch over to use the controls IDs for the active progress dialog
	static UINT rguiControls[] = {IDC_DCOM_EDIT,
								IDC_DCOM_EXIT_SETUP,
								IDC_WELCOME_CONTINUE,
								IDC_WELCOME_EXIT_SETUP,
								IDC_EXESTORUN_PROGRESS,
								IDC_EXESTORUN_NEXT,
								IDC_EXESTORUN_EXIT_SETUP,
								IDC_INSTALLTO_NEXT,
								IDC_INSTALLTO_EXIT_SETUP,
								IDC_INSTALLTO_EDIT,
								IDC_INSTALLTO_BROWSE,
								IDC_DCOM_NEXT,
								IDC_DCOM_EXIT_SETUP,
								IDC_PROGRESS_NEXT,
								IDC_PROGRESS_CANCEL,
								IDC_END_NEXT,
								IDC_END_CLOSE,
								IDC_DCOM_STATIC1,
								IDC_DCOM_STATIC2,
								IDC_DCOM_STATIC3,
								IDC_EXESTORUN_STATIC1,
								IDC_EXESTORUN_STATIC2,
								IDC_EXESTORUN_STATIC3,
								IDC_INSTALLTO_STATIC1,
								IDC_INSTALLTO_STATIC2,
								IDC_INSTALLTO_STATIC3,
								IDC_PROGRESS_STATIC1,
								IDC_PROGRESS_STATIC2,
								IDC_PROGRESS_STATIC3,
								IDC_PROGRESS_STATIC4,
								IDC_WELCOME_STATIC1,
								IDC_WELCOME_STATIC2,
								IDC_WELCOME_STATIC3,
								IDC_WELCOME_STATIC4,
								IDC_END_STATIC1,
								IDC_END_STATIC2,
								IDC_END_STATIC3 };

	static CHAR szTitle[_MAX_PATH];

	WCHAR szBuffer[_MAX_PATH];
	WCHAR szBuffer2[_MAX_PATH];
	WCHAR szBuffer3[MSINFHLP_MAX_PATH];

	switch( uMsg )
    {
        case WM_INITDIALOG:
		{
			::VSetDialogFont(hwndDlg, rguiControls, NUMBER_OF(rguiControls));

			if (szTitle[0] == '\0')
			{
				switch (g_Action)
				{
				default:
					assert(false); // how the heck did we get here?

				case eActionInstall:
					strcpy(szTitle, achInstallTitle);
					break;

				case eActionUninstall:
					strcpy(szTitle, achUninstallTitle);
					break;
				}
			}

			::SetWindowLong(hwndDlg, GWL_ID, g_KProgress.m_listDialog[g_KProgress.m_iCurrentPage]);

			g_pwil->VLookupString(szTitle, NUMBER_OF(szBuffer), szBuffer);
			NVsWin32::SetWindowTextW(hwndDlg, szBuffer);

			//we can initialize any of the following dialogs...
			switch (g_KProgress.m_listDialog[g_KProgress.m_iCurrentPage])
			{
			case IDD_WELCOME:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap_Install[] =
					{
						{ IDC_WELCOME_STATIC1, achWelcome1 },
						{ IDC_WELCOME_STATIC2, achWelcome2 },
						{ IDC_WELCOME_STATIC3, achWelcome3 },
						{ IDC_WELCOME_STATIC4, achWelcome4 },
						{ IDC_WELCOME_CONTINUE, achContinue},
						{ IDC_WELCOME_EXIT_SETUP, achExitSetup }
					};

					static const DialogItemToStringKeyMapEntry s_rgMap_Uninstall[] =
					{
						{ IDC_WELCOME_STATIC1, achUninstallWelcome1 },
						{ IDC_WELCOME_STATIC2, achUninstallWelcome2 },
						{ IDC_WELCOME_STATIC3, achUninstallWelcome3 },
						{ IDC_WELCOME_STATIC4, achUninstallWelcome4 },
						{ IDC_WELCOME_CONTINUE, achContinue},
						{ IDC_WELCOME_EXIT_SETUP, achExitSetup }
					};

					if (g_Action == eActionInstall)
					{
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Install), s_rgMap_Install);

						// Let's see if this is a reinstall case...
						if (g_pwil->FLookupString(achAppName, NUMBER_OF(szBuffer), szBuffer))
						{
							CVsRegistryKey hkey;

							::VFormatString(NUMBER_OF(szBuffer3), szBuffer3, L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%0", szBuffer);

							hr = hkey.HrOpenKeyExW(
											HKEY_LOCAL_MACHINE,
											szBuffer3,
											0,
											KEY_QUERY_VALUE);
							if (SUCCEEDED(hr))
							{
								// Holy smokes, the key's there.  Let's just reinstall!
								if (!g_fSilent)
								{
									if (!::FMsgBoxYesNo(szTitle, achReinstallPrompt, szBuffer))
									{
										// Let's just bail outta here!
										::VLog(L"User selected that they do not want to reinstall; getting outta here!");
										g_fStopProcess = true;
									}
								}

								::VLog(L"Setting reinstallation mode");

								g_fReinstall = true;
							}
							else
							{
								if ((hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) &&
									(hr != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))
								{
									// Some error opening the registry...
									::VLog(L"Error opening application uninstall registry key; hresult = 0x%08lx", hr);
									::VReportError(szTitle, hr);
								}
							}
						}
					}
					else
					{
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Uninstall), s_rgMap_Uninstall);
					}

				}
				break;

			case IDD_EXESTORUN:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap[] =
					{
						{ IDC_EXESTORUN_STATIC1, achExesToRun1 },
						{ IDC_EXESTORUN_STATIC2, achExesToRun2 },
						{ IDC_EXESTORUN_STATIC3, NULL },
						{ IDC_EXESTORUN_NEXT, achNext },
						{ IDC_EXESTORUN_EXIT_SETUP, achExitSetup }
					};

					::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);

					//let's set the range and the step for the progress bar
					g_hwndProgress = ::GetDlgItem(hwndDlg, IDC_EXESTORUN_PROGRESS);

					// mjg: rework preinstallation progress mechanism.
					WORD range = (WORD) g_pwil->m_cPreinstallCommands;
					LRESULT lResult = ::SendMessage(g_hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, range));
					lResult = ::SendMessage(g_hwndProgress, PBM_SETSTEP, 1, 0L);
				}
				break;

			case IDD_INSTALLTO:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap[] =
					{
						{ IDC_INSTALLTO_STATIC1, achInstallTo1 },
						{ IDC_INSTALLTO_STATIC2, achInstallTo2 },
						{ IDC_INSTALLTO_STATIC3, achInstallTo3 },
						{ IDC_INSTALLTO_BROWSE, achBrowse },
						{ IDC_INSTALLTO_NEXT, achNext },
						{ IDC_INSTALLTO_EXIT_SETUP, achExitSetup }
					};

					::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);

					//cannot set text, we complain and end the dialog returning FALSE
					szBuffer[0] = L'\0';
					if (!g_pwil->FLookupString(achSMAppDir, NUMBER_OF(szBuffer), szBuffer))
					{
						if (!g_pwil->FLookupString(achDefaultInstallDir, NUMBER_OF(szBuffer), szBuffer))
						{
							if (!g_pwil->FLookupString(achProgramFilesDir, NUMBER_OF(szBuffer), szBuffer))
							{
								szBuffer[0] = L'\0';
							}
						}
					}

					if (szBuffer[0] != L'\0')
					{
						WCHAR szExpanded[MSINFHLP_MAX_PATH];
						VExpandFilename(szBuffer, NUMBER_OF(szExpanded), szExpanded);
						if (!NVsWin32::SetDlgItemTextW(hwndDlg, IDC_INSTALLTO_EDIT, szExpanded))
						{
							::VErrorMsg(szTitle, achErrorCreatingDialog);
							::ExitProcess(HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
							return TRUE;
						}

						::SendMessage(::GetDlgItem(hwndDlg, IDC_INSTALLTO_EDIT), EM_SETREADONLY, (WPARAM) g_fReinstall, 0);
						::EnableWindow(::GetDlgItem(hwndDlg, IDC_INSTALLTO_BROWSE), !g_fReinstall);
					}
				}
				break;

			case IDD_DCOM:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap[] =
					{
						{ IDC_DCOM_STATIC1, achDCOM1 },
						{ IDC_DCOM_STATIC2, achDCOM2 },
						{ IDC_DCOM_STATIC3, achDCOM3 },
						{ IDC_DCOM_NEXT, achNext },
						{ IDC_DCOM_EXIT_SETUP, achExitSetup }
					};

					::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);

					//cannot set text, we complain and end the dialog returning FALSE
					if (g_pwil->FLookupString(achRemoteServer, NUMBER_OF(szBuffer), szBuffer))
					{
						WCHAR szExpanded[_MAX_PATH];
						::VExpandFilename(szBuffer, NUMBER_OF(szExpanded), szExpanded);
						if (!NVsWin32::SetDlgItemTextW( hwndDlg, IDC_DCOM_EDIT, szExpanded))
						{
							::VErrorMsg(szTitle, achErrorCreatingDialog);
							::ExitProcess(HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
							return TRUE;
						}
					}
				}
				break;

			case IDD_PROGRESS:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap_Install[] =
					{
						{ IDC_PROGRESS_STATIC1, achProgress1 },
						{ IDC_PROGRESS_STATIC2, achProgress2 },
						{ IDC_PROGRESS_STATIC3, achProgress3 },
						{ IDC_PROGRESS_STATIC4, NULL },
						{ IDC_PROGRESS_NEXT, achNext },
						{ IDC_PROGRESS_CANCEL, achCANCEL }
					};

					static const DialogItemToStringKeyMapEntry s_rgMap_Uninstall[] =
					{
						{ IDC_PROGRESS_STATIC1, achUninstallProgress1 },
						{ IDC_PROGRESS_STATIC2, achUninstallProgress2 },
						{ IDC_PROGRESS_STATIC3, achUninstallProgress3 },
						{ IDC_PROGRESS_STATIC4, NULL },
						{ IDC_PROGRESS_NEXT, achNext },
						{ IDC_PROGRESS_CANCEL, achCANCEL }
					};

					if (g_Action == eActionInstall)
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Install), s_rgMap_Install);
					else
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Uninstall), s_rgMap_Uninstall);

					//let's set the range and the step for the progress bar
					g_hwndProgress = ::GetDlgItem(hwndDlg, IDC_PROGRESS_PROGRESS);

					WORD range;
					range = (WORD) g_pwil->m_cWorkItem;
					LRESULT lResult = ::SendMessage(g_hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, range));
					lResult = ::SendMessage(g_hwndProgress, PBM_SETSTEP, 1, 0L);
				}
				break;

			case IDD_END:
				{
					static const DialogItemToStringKeyMapEntry s_rgMap_Install[] =
					{
						{ IDC_END_STATIC1, achEnd1 },
						{ IDC_END_STATIC2, achEnd2 },
						{ IDC_END_STATIC3, achEnd3 },
						{ IDC_END_CLOSE, achClose },
						{ IDC_END_NEXT, achNext }
					};

					static const DialogItemToStringKeyMapEntry s_rgMap_Uninstall[] =
					{
						{ IDC_END_STATIC1, achUninstallEnd1 },
						{ IDC_END_STATIC2, achUninstallEnd2 },
						{ IDC_END_STATIC3, achUninstallEnd3 },
						{ IDC_END_CLOSE, achClose },
						{ IDC_END_NEXT, achNext }
					};

					if (g_Action == eActionInstall)
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Install), s_rgMap_Install);
					else
						::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap_Uninstall), s_rgMap_Uninstall);
				}

				break;

			default:
				break;
			}
		}

		case WM_SHOWWINDOW:
			if (wParam != 0)
			{
				// We're being shown.  If we have a progress thingie, we should make it the active
				// one.
				LONG lID = ::GetWindowLong(hwndDlg, GWL_ID);
				switch (lID)
				{
				default:
					// nothing to do...
					g_hwndProgress = NULL;
					g_hwndProgressItem = NULL;
					g_hwndProgressLabel = NULL;
					break;

				case IDD_EXESTORUN:
					g_hwndProgress = ::GetDlgItem(hwndDlg, IDC_EXESTORUN_PROGRESS);
					g_hwndProgressItem = ::GetDlgItem(hwndDlg, IDC_EXESTORUN_STATIC3);
					g_hwndProgressLabel = ::GetDlgItem(hwndDlg, IDC_EXESTORUN_STATIC2);
					break;

				case IDD_PROGRESS:
					g_hwndProgress = ::GetDlgItem(hwndDlg, IDC_PROGRESS_PROGRESS);
					g_hwndProgressItem = ::GetDlgItem(hwndDlg, IDC_PROGRESS_STATIC4);
					g_hwndProgressLabel = ::GetDlgItem(hwndDlg, IDC_PROGRESS_STATIC3);
					break;
				}
			}
			break;

		//*************************************
		//process control-related commands
		case WM_COMMAND:
		{
			switch (wParam)
			{
			case IDC_WELCOME_CONTINUE:
				//let's first show the new page & put it on top of Z order, then hide the old page
				::VSetNextWindow();

				if (g_Action == eActionInstall)
				{
					// If we're reinstalling, skip all preinstall commands.
					if (g_fReinstall)
					{
						CWorkItemIter iter(g_pwil);

						bool fHasPreinstallCommand = false;

						for (iter.VReset(); iter.FMore(); iter.VNext())
						{
							if (!iter->m_fErrorInWorkItem && iter->m_fRunBeforeInstall)
							{
								fHasPreinstallCommand = true;
								break;
							}
						}

						if (fHasPreinstallCommand)
							::VSetNextWindow();

						return TRUE;
					}

					for (;;)
					{
						hr = g_pwil->HrRunPreinstallCommands();
						if (SUCCEEDED(hr))
						{
							// If there were no preinstall commands to run, hr comes back as S_FALSE.
							// If there were no preinstall commands to run, we don't want to move to
							// the next window.
							if (hr != S_FALSE)
								::VSetNextWindow();

							break;
						}
						else if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
						{
							if (!::FMsgBoxYesNo(achInstallTitle, achInstallSureAboutCancel))
								continue;

							//running subinstallers NOT successful, let's go on
							::VGoToFinishStep(E_ABORT);
						}
						else if (FAILED(hr))
						{
							::VLog(L"running preinstall commands failed; hresult = 0x%08lx", hr);
							::VReportError(achInstallTitle, hr);
							::VGoToFinishStep(hr);
						}

						break;
					}

					::VClearErrorContext();
				}
				else
				{
					for (;;)
					{
						//quit if uninstall fails
						hr = ::HrContinueUninstall();
						if (FAILED(hr))
						{
							if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
							{
								if (!::FMsgBoxYesNo(achInstallTitle, achInstallSureAboutCancel))
									continue;

								::VGoToFinishStep(E_ABORT);
							}
							else
							{
								::VLog(L"Uninstall failed in general; hresult = 0x%08lx", hr);
								::VReportError(achUninstallTitle, hr);
								::VGoToFinishStep(hr);
							}
						}

						break;
					}

					if (SUCCEEDED(hr))
					{
						//let's first show the new page & put it on top of Z order, then hide the old page
						::VSetNextWindow();
					}
				}
				break;
			case IDC_EXESTORUN_NEXT:
				if (!g_fSilent)
					::VMsgBoxOK("ERROR", "This should never happen!");

				//let's first show the new page & put it on top of Z order, then hide the old page
				::VSetNextWindow();
				break;

			case IDC_INSTALLTO_NEXT:
				{
					WCHAR szDestDir[_MAX_PATH];
					WCHAR szTempDir[_MAX_PATH];
					HANDLE hFile = NULL;

					if (!NVsWin32::GetDlgItemTextW(hwndDlg, IDC_INSTALLTO_EDIT, szTempDir, NUMBER_OF(szTempDir)))
					{
						::VErrorMsg(achInstallTitle, achNotFullPath);
						return TRUE;
					}

					::VTrimDirectoryPath(szTempDir, NUMBER_OF(szDestDir), szDestDir);

					//bad path given, we prompt user saying we have bad path, but do NOT
					//close this dialog
					if (!IsLocalPath(szDestDir))
					{
						::VErrorMsg(achInstallTitle, achNotFullPath);
						return TRUE;
					}

					//if directory doesn't exist, we ask user if we want to create directory
					DWORD dwAttr = NVsWin32::GetFileAttributesW(szDestDir);
					if (dwAttr == 0xFFFFFFFF && !g_fSilent)
					{
						//if user answers no, then we're out
						if (!g_fSilent && !::FMsgBoxYesNo(achInstallTitle, achCreateAppDir))
							return TRUE;
					}
					else if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY) || (dwAttr & FILE_ATTRIBUTE_READONLY))
					{
						::VErrorMsg(achInstallTitle, achNotFullPath);
						return TRUE;
					}

					hr = g_pwil->HrDeleteString(achSMAppDir);
					if ((hr != E_INVALIDARG) && FAILED(hr))
					{
						::VLog(L"Attempt to delete default appdir string failed; hresult = 0x%08lx", hr);
						return FALSE;
					}

					hr = g_pwil->HrAddString(achSMAppDir, szDestDir);
					if (FAILED(hr))
						return TRUE;

					::VExpandFilename(L"<AppDir>\\MSINFHLP.TXT", NUMBER_OF(szTempDir), szTempDir);
					hr = ::HrMakeSureDirectoryExists(szTempDir);
					if (FAILED(hr))
					{
						::VReportError(achInstallTitle, hr);
						return TRUE;
					}

					// Let's make sure we have write access to the directory:
					::VExpandFilename(L"<AppDir>\\MSINFHLP.TST", NUMBER_OF(szTempDir), szTempDir);
					bool fDeleteTemporaryFile = true;

					::VLog(L"Opening file \"%s\" to test writability into the application directory", szTempDir);

					hFile = NVsWin32::CreateFileW(
										szTempDir,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										NULL,
										OPEN_ALWAYS,
										0,
										NULL);
					if (hFile == INVALID_HANDLE_VALUE)
					{
						const DWORD dwLastError = ::GetLastError();
						::VLog(L"Opening handle on temporary file failed; last error = %d", dwLastError);
						// This could have failed erroneously if the file is already there but the file
						// has the readonly attribute.  I'm not going to bother with this case; it may
						// be somewhat bad to do so, but the probability that the file is there, and is
						// set with the readonly bit seems extremely unlikely.  -mgrier 3/29/98
						::VReportError(achInstallTitle, HRESULT_FROM_WIN32(dwLastError));
						return TRUE;
					}
					else if (::GetLastError() == ERROR_ALREADY_EXISTS)
					{
						fDeleteTemporaryFile = false;
					}

					::CloseHandle(hFile);
					hFile = NULL;

					if (!NVsWin32::DeleteFileW(szTempDir))
					{
						const DWORD dwLastError = ::GetLastError();
						::VLog(L"Deleting temporary file \"%s\" failed; last error = %d", szTempDir, dwLastError);
						::VReportError(achInstallTitle, HRESULT_FROM_WIN32(dwLastError));
						return TRUE;
					}

					//let's first show the new page & put it on top of Z order, then hide the old page
					::VSetNextWindow();

					if (g_KProgress.m_listDialog[g_KProgress.m_iCurrentPage] == IDD_PROGRESS)
					{
						hr = ::HrContinueInstall();

						if (FAILED(hr))
						{
							::VLog(L"Install failed in general; hresult = 0x%08lx", hr);
							::VReportError(achInstallTitle, hr);
							::VGoToFinishStep(hr);
						}
						else
						{
							//let's first show the new page & put it on top of Z order, then hide the old page
							::VSetNextWindow();
						}
					}
				}
				break;

			case IDC_DCOM_NEXT:
				{
					//if code is install TO, let's get the field
					WCHAR szServer[_MAX_PATH];
					if (!NVsWin32::GetDlgItemTextW(hwndDlg, IDC_DCOM_EDIT, szServer, NUMBER_OF(szServer)))
					{
						const DWORD dwLastError = ::GetLastError();
						if (dwLastError == ERROR_SUCCESS)
						{
							::VErrorMsg(achInstallTitle, achInvalidMachineName);
							return TRUE;
						}

						::VErrorMsg(achInstallTitle, achErrorProcessingDialog);
						::ExitProcess(HRESULT_FROM_WIN32(dwLastError));
						return TRUE;
					}

					hr = g_pwil->HrDeleteString(achRemoteServer);
					if ((hr != E_INVALIDARG) && FAILED(hr))
					{
						::VLog(L"Failed to delete string; hresult = 0x%08lx", hr);
						::VReportError(achInstallTitle, hr);
						::VGoToFinishStep(hr);
						return TRUE;
					}

					hr = g_pwil->HrAddString(achRemoteServer, szServer);
					if (FAILED(hr))
					{
						::VLog(L"Failed to add string; hresult = 0x%08lx", hr);
						::VReportError(achInstallTitle, hr);
						::VGoToFinishStep(hr);
						return TRUE;
					}

					//let's first show the new page & put it on top of Z order, then hide the old page
					::VSetNextWindow();

					if (g_KProgress.m_listDialog[g_KProgress.m_iCurrentPage] == IDD_PROGRESS)
					{
						hr = ::HrContinueInstall();
						if (FAILED(hr))
						{
							::VLog(L"Installation generally failed; hresult = 0x%08lx", hr);

							if ((hr == E_ABORT) || hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
								hr = E_ABORT;

							::VReportError(achInstallTitle, hr);
							::VGoToFinishStep(hr);
						}
						else
						{
							//let's first show the new page & put it on top of Z order, then hide the old page
							::VSetNextWindow();
						}
					}
					else
					{
						if (!g_fSilent)
							::VMsgBoxOK("ERROR", "Somehow, the page after DCOM is NOT progress dialog...");
					}
				}
				break;
			case IDC_PROGRESS_NEXT:
				if (!g_fSilent)
					::VMsgBoxOK("ERROR", "This should never happen!");
				//let's first show the new page & put it on top of Z order, then hide the old page
				::VSetNextWindow();
				break;

			//if anyone issues an exit-setup, we boot!
			case IDC_PROGRESS_CANCEL:
			case IDC_WELCOME_EXIT_SETUP:
			case IDC_EXESTORUN_EXIT_SETUP:
			case IDC_INSTALLTO_EXIT_SETUP:
			case IDC_DCOM_EXIT_SETUP:
				//bring up a message only if we're in the middle of an installation
				if (!g_fSilent)
				{
					if (::FMsgBoxYesNo(achInstallTitle, achInstallSureAboutCancel))
						::VGoToFinishStep(E_ABORT);
				}
				break;

			case IDC_END_CLOSE:
				::VLog(L"Posting quit message; status = 0x%08lx", g_hrFinishStatus);
				::PostQuitMessage(0);
				break;

			case IDC_INSTALLTO_BROWSE:
				{
					WCHAR szMsg[MSINFHLP_MAX_PATH];
					WCHAR szDir[MSINFHLP_MAX_PATH];
					WCHAR szDestDir[MSINFHLP_MAX_PATH];
					int cbDestDir = MSINFHLP_MAX_PATH;
					szDir[0] = L'\0';

					//get the text to display in the browse directory dialog
					g_pwil->VLookupString(achInstallSelectDir, NUMBER_OF(szMsg), szMsg);

					if (!NVsWin32::GetDlgItemTextW(hwndDlg, IDC_INSTALLTO_EDIT, szDestDir, cbDestDir - 1))
					{
						::VErrorMsg(szTitle, achErrorProcessingDialog);
						::ExitProcess(EXIT_FAILURE);
						return TRUE;
					}

					//bring up the browse dialog & get the directory
					if (!::BrowseForDir(hwndDlg, szDestDir, szMsg, szDir))
						return TRUE;

					if (szDir[0] != L'\0')
					{
						//set the text in the dialog, complain if fail
						if (!NVsWin32::SetDlgItemTextW(hwndDlg, IDC_INSTALLTO_EDIT, szDir))
						{
							::VErrorMsg(achInstallTitle, achErrorProcessingDialog);
							::ExitProcess(HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
							return TRUE;
						}
					}
				}

				break;
			}
			break;
		}

		case WM_DESTROY:
		{
			LONG lID = ::GetWindowLong(hwndDlg, GWL_ID);

			ULONG i;

			for (i=0; i<NUMBER_OF(g_KProgress.m_listDialog); i++)
			{
				if (lID == g_KProgress.m_listDialog[i])
				{
					g_KProgress.m_hwndDialog[i] = NULL;
					break;
				}
			}

			break;
		}

		case WM_ENDSESSION:
			//stop this baby only if restart is true
			if ((BOOL)wParam != FALSE)
				g_fStopProcess = true;
			break;

		case WM_QUERYENDSESSION:
			return TRUE;

        default:                            // For MSG switch
            return(FALSE);
    }
    return(TRUE);
}


void VSetNextWindow()
{
	g_KProgress.m_iCurrentPage++;

	// If we've already moved to the finish page, there's no need to advance further.
	if (g_KProgress.m_iCurrentPage >= g_KProgress.m_iMaxPage)
	{
		g_KProgress.m_iCurrentPage--;
		return;
	}

	::SetWindowPos(g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage], HWND_TOP, 0, 0, g_KProgress.m_lX, g_KProgress.m_lY, 0);
	::ShowWindow(g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage], SW_SHOW);
	::ShowWindow(g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage-1], SW_HIDE);

	UINT uiIDControl = 0;

	static struct
	{
		UINT m_uiIDD;
		UINT m_uiIDControl;
	} s_rgMap[] =
	{
		{ IDD_EXESTORUN, IDC_EXESTORUN_NEXT },
		{ IDD_INSTALLTO, IDC_INSTALLTO_NEXT },
		{ IDD_DCOM, IDC_DCOM_NEXT },
		{ IDD_PROGRESS, IDC_PROGRESS_NEXT },
		{ IDD_END, IDC_END_CLOSE }
	};

	const UINT uiIDDCurrent = g_KProgress.m_listDialog[g_KProgress.m_iCurrentPage];

	for (ULONG i=0; i<NUMBER_OF(s_rgMap); i++)
	{
		if (s_rgMap[i].m_uiIDD == uiIDDCurrent)
		{
			uiIDControl = s_rgMap[i].m_uiIDControl;
			break;
		}
	}

	if (uiIDControl != 0)
	{
		::SendMessage(g_KProgress.HwndGetHandle(), WM_SETFOCUS, 0, 0);
		::SendMessage(::GetDlgItem(g_KProgress.HwndGetHandle(), uiIDControl), WM_SETFOCUS, 0, 0);
	}

	// If this is the last page, let's use the code from VGoToFinishStep() to put the success message
	// in place.
	if (g_KProgress.m_iCurrentPage == (g_KProgress.m_iMaxPage - 1))
		::VGoToFinishStep(NOERROR);
}

void VGoToFinishStep(HRESULT hr)
{
	bool fInstall = (g_Action == eActionInstall);

	::VLog(L"Moving to finish dialog; hresult = 0x%08lx", hr);

	int iOldPage = g_KProgress.m_iCurrentPage;
	g_KProgress.m_iCurrentPage = g_KProgress.m_iMaxPage - 1;

	::VLog(L"Moving from page %d to page %d", iOldPage, g_KProgress.m_iMaxPage);

	if (iOldPage != g_KProgress.m_iCurrentPage)
	{
		::SetWindowPos(g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage], HWND_TOP, 0, 0, g_KProgress.m_lX, g_KProgress.m_lY, 0);
		::ShowWindow(g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage], SW_SHOW);
		::ShowWindow(g_KProgress.m_hwndDialog[iOldPage], SW_HIDE);
	}

	HWND hwndDlg = g_KProgress.m_hwndDialog[g_KProgress.m_iCurrentPage];

	::SendMessage(g_KProgress.HwndGetHandle(), WM_SETFOCUS, 0, 0);
	::SendMessage(::GetDlgItem(g_KProgress.HwndGetHandle(), IDC_END_CLOSE), WM_SETFOCUS, 0, 0);

	::VLog(L"Setting finish status to hresult = 0x%08lx", hr);

	g_hrFinishStatus = hr;

	//By now, we're done installing everything.  So we go ahead to check
	//if we need to restart the machine, and do so if necessary.
	if (fInstall)
	{
		//if check error returns some sort of error, let's display this puppy
		if (FAILED(hr))
		{
			static const DialogItemToStringKeyMapEntry s_rgMap[] =
			{
				{ IDC_END_STATIC1, achInstallEndPromptErrorTitle },
				{ IDC_END_STATIC2, achInstallEndPromptError },
			};

			::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);
		}
	}
	else
	{
		if (FAILED(hr))
		{
			static const DialogItemToStringKeyMapEntry s_rgMap[] =
			{
				{ IDC_END_STATIC1, achUninstallEndPromptErrorTitle },
				{ IDC_END_STATIC2, achUninstallEndPromptError },
			};

			::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);
		}
	}

	if (g_fRebootRequired)
	{
		if (fInstall)
		{
			if (g_fSilent || ::FMsgBoxYesNo(achInstallTitle, achReboot))
			{
				//different calls for reboot depending on which OS we're on
				if (g_fIsNT)
					MyNTReboot(achInstallTitle);
				else
					::ExitWindowsEx(EWX_REBOOT, NULL);
			}
			else
				::VMsgBoxOK(achInstallTitle, achRebootNoMsg);
		}
		else
		{
			//let's ask the user if they want to reboot now.
			if (g_fSilent || ::FMsgBoxYesNo(achUninstallTitle, achUninstallReboot))
			{
				//different calls for reboot depending on which OS we're on
				if (g_fIsNT)
					MyNTReboot(achInstallTitle);
				else
					::ExitWindowsEx(EWX_REBOOT, NULL);
			}
			else
				::VMsgBoxOK(achUninstallTitle, achUninstallRebootNoMsg);
		}
	}
}



//set font for the given controls to be either default or system font
void ::VSetDialogFont(HWND hwnd, UINT rguiControls[], ULONG cControls)
{
	static HFONT hFont = NULL;

	if (hFont == NULL)
	{
		hFont = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
		if (hFont == NULL)
			hFont = (HFONT) ::GetStockObject(SYSTEM_FONT);

		CHAR szLangName[4];
		::GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME, szLangName, NUMBER_OF(szLangName));

		if ((hFont == NULL) || (_stricmp(szLangName, "CHS") == 0))
		{
			LOGFONTA lf;

			hFont = (HFONT) ::SendMessage(hwnd, WM_GETFONT, 0, 0);
			::GetObject(hFont, sizeof(LOGFONTA), &lf);

			strncpy(lf.lfFaceName, "System", NUMBER_OF(lf.lfFaceName));
			lf.lfFaceName[NUMBER_OF(lf.lfFaceName) - 1] = '\0';

			hFont = ::CreateFontIndirectA(&lf);
		}

		// If the creation of the System font failed, let's just try the standard
		// fonts again.
		if (hFont == NULL)
			hFont = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);

		if (hFont == NULL)
			hFont = (HFONT) ::GetStockObject(SYSTEM_FONT);
	}

	//if we can set fonts, then do so; else complain?
	if (hFont)
	{
		for (ULONG i=0; i<cControls; i++)
		{
			HWND hwndTemp = ::GetDlgItem(hwnd, rguiControls[i]);
			if (hwndTemp != NULL)
				::SendMessage(hwndTemp, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
		}
	}
}

//check if the given path is a full path -- either local path with a drive specified or
//a UNC path
bool IsLocalPath(LPOLESTR szPath)
{
	if ((szPath == NULL))
		return false;
		
	int iLen=wcslen(szPath);
	if (iLen < 3)
		return false;

	LPOLESTR lpForbidden = L"/*?\"<>|:";
	int iCount=8;

	//check for colon
	if (szPath[1] != L':')
		return false;

	//if any of the forbidden characters is in the path, it's invalid!!!
	for (int i=0; i<iCount; i++)
	{
		if (wcschr(szPath+2, lpForbidden[i]) != NULL)
			return false;
	}

	//don't allow ':' or '\\' in first character or '\\' in second character
	if ((szPath[0] == L':') || (szPath[0] == L'\\'))
		return false;

	WCHAR szTempPath[_MAX_PATH];

	szTempPath[0] = szPath[0];
	szTempPath[1] = L':';
	szTempPath[2] = L'\\';
	szTempPath[3] = L'\0';

	DWORD dwMaximumComponentLength;
	if (!NVsWin32::GetVolumeInformationW(
						szTempPath,
						NULL,		// lpVolumeNameBuffer
						0,			// nVolumeNameSize
						NULL,		// lpVolumeSerialNumber
						&dwMaximumComponentLength,
						NULL,		// lpFileSystemFlags
						NULL,		// lpFileSystemNameBuffer
						0))			// nFileSystemNameSize
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to get volume information for \"%s\"; last error = %d", szTempPath, dwLastError);
		return false;
	}

	if (dwMaximumComponentLength < 255)
	{
		::VLog(L"Unable to install onto a short filename drive");
		return false;
	}

	return true;
}



bool FCheckPermissions()
{
	if (g_fIsNT)
	{
		static const HKEY rgKey[2] = { HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT };
		static const LPCOLESTR rgSubKey[2] = { L"Software", L"CLSID" };
		HKEY hkey;

		//loop through to make sure that we have sufficient access to each key
		for (int i=0; i<2; i++)
		{
			if (ERROR_SUCCESS != NVsWin32::RegOpenKeyExW(rgKey[i], rgSubKey[i], 0, KEY_ALL_ACCESS, &hkey))
			{
				if (!g_fSilent)
					::VMsgBoxOK(achAppName, achErrorNeedRegistryPermissions);
				return false;
			}
			::RegCloseKey(hkey);
			hkey = NULL;
		}
	}
	return true;
}



//Get the installation directory and put in global structure.
//So we first parse the list of AddReg entries looking for the tag ",InstallDir,";
//then look in the registry for that entry (and get the value); and finally put
//that in listLDID.
HRESULT HrGetInstallDir()
{
	HRESULT hr = NOERROR;
	CVsRegistryKey hkey;
	WCHAR szSubkey[MSINFHLP_MAX_PATH];
	WCHAR szValueName[MSINFHLP_MAX_PATH];
	WCHAR szAppDir[_MAX_PATH];
	szSubkey[0] = L'\0';
	szValueName[0] = L'\0';
	LONG lResult;

	//get the registry information for "InstallDir"
	hr = ::HrGetInstallDirRegkey(hkey.Access(), NUMBER_OF(szSubkey), szSubkey, NUMBER_OF(szValueName), szValueName);
	if (FAILED(hr))
		goto Finish;

	//get the value of the registry key & put in global structure
	hr = hkey.HrGetSubkeyStringValueW(szSubkey, szValueName, NUMBER_OF(szAppDir), szAppDir);
	if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
	{
		if (FAILED(hr))
			goto Finish;

		hr = g_pwil->HrAddString(achSMAppDir, szAppDir);
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrPromptForRemoteServer()
{
	HRESULT hr = NOERROR;
	DIRDLGPARAMS dialogParams;
	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szPrompt[MSINFHLP_MAX_PATH];
	WCHAR szRemoteServer[MSINFHLP_MAX_PATH];
	szRemoteServer[0] = 0;

	//get the title and the prompt
	if (!g_pwil->FLookupString(achInstallTitle, NUMBER_OF(szTitle), szTitle))
		wcscpy(szTitle, L"Installation program");

	if (!g_pwil->FLookupString(achRemoteServerPrompt, NUMBER_OF(szPrompt), szPrompt))
		wcscpy(szPrompt, L"Use Remote Server:");

	//let's try to get the default remote server, and process it if needed be
	if (g_pwil->FLookupString(achRemoteServer, NUMBER_OF(szRemoteServer), szRemoteServer))
	{	
		WCHAR szDestDir2[MSINFHLP_MAX_PATH];
		VExpandFilename(szRemoteServer, NUMBER_OF(szDestDir2), szDestDir2);
		wcscpy(szRemoteServer, szDestDir2);
	}

	//populate structure with appropriate params
	dialogParams.szPrompt = szPrompt;
	dialogParams.szTitle = szTitle;
	dialogParams.szDestDir = szRemoteServer;
	dialogParams.cbDestDirSize = MSINFHLP_MAX_PATH;

	//bring up dialog
	int iResult = NVsWin32::DialogBoxParamW(g_hInst, MAKEINTRESOURCEW(IDD_REMOTESERVERDLG),
								g_KProgress.HwndGetHandle(), RemoteServerProc,
								(LPARAM) &dialogParams);
	if (iResult == -1)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	//get rid of the previous key & re-insert the good one.
	hr = g_pwil->HrDeleteString(achRemoteServer);
	if ((hr != E_INVALIDARG) && (FAILED(hr)))
		goto Finish;

	if (iResult != 0)
	{
		hr = g_pwil->HrAddString(achRemoteServer, dialogParams.szDestDir);
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}


//TODO:  UNDONE:
//We might need to do a setfonts here to correspond to whatever fonts that we're
//using in the current install machine.  This allows the characters to display
//correctly in the edit box.
BOOL CALLBACK RemoteServerProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static WCHAR szDir[_MAX_PATH];
	static WCHAR szMsg[_MAX_PATH];
	static LPOLESTR szDestDir;
	static LPOLESTR szTitle;
	static ULONG cbDestDirSize;
	static UINT rguiControls[] = { IDC_TEXT_REMOTESERVER, IDC_EDIT_REMOTESERVER, IDOK2 };

	//process the message
	switch (uMsg) 
	{
		//************************************
		//initialize dialog
		case WM_INITDIALOG:
		{
			::VSetDialogFont(hwndDlg, rguiControls, NUMBER_OF(rguiControls));

			DIRDLGPARAMS *dialogParams = (DIRDLGPARAMS *) lParam;
			szDestDir = dialogParams->szDestDir;
			cbDestDirSize = dialogParams->cbDestDirSize;

			(void) ::HrCenterWindow(hwndDlg, ::GetDesktopWindow());
			NVsWin32::SetWindowTextW(hwndDlg, dialogParams->szTitle);

			//cannot set text, we complain and end the dialog returning FALSE
			if (! NVsWin32::SetDlgItemTextW( hwndDlg, IDC_TEXT_REMOTESERVER, dialogParams->szPrompt))
			{
				::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
				::EndDialog(hwndDlg, FALSE);
				return TRUE;
			}

			//cannot set text, we complain and end the dialog returning FALSE
			if (! NVsWin32::SetDlgItemTextW( hwndDlg, IDC_EDIT_REMOTESERVER, dialogParams->szDestDir))
			{
				::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
				::EndDialog(hwndDlg, FALSE);
				return TRUE;
			}

			//we set the text for the different button controls
			WCHAR szBuffer[MSINFHLP_MAX_PATH];
			if (g_pwil->FLookupString(achOK, NUMBER_OF(szBuffer), szBuffer))
				NVsWin32::SetDlgItemTextW(hwndDlg, IDOK, szBuffer);

			::SendDlgItemMessage(hwndDlg, IDC_EDIT_REMOTESERVER, EM_SETLIMITTEXT, (MSINFHLP_MAX_PATH - 1), 0);

			return TRUE;
		}

		//*************************************
		//close message
		case WM_CLOSE:
		{
			::EndDialog(hwndDlg, FALSE);
			return TRUE;
		}

		//*************************************
		//process control-related commands
		case WM_COMMAND:

			switch (wParam)
			{

				case IDOK2:
				{
					//cannot get the text from edit box, complain & quit
					if (!NVsWin32::GetDlgItemTextW(hwndDlg, IDC_EDIT_REMOTESERVER, szDestDir, cbDestDirSize - 1))
					{
						::VErrorMsg(achInstallTitle, achErrorProcessingDialog);
						::EndDialog(hwndDlg, FALSE);
						return TRUE;
					}

					::EndDialog(hwndDlg, TRUE);
					return TRUE;
				}
				return TRUE;
		}
		return TRUE;
	}
	return FALSE;
}

bool MyNTReboot(LPCSTR lpInstall)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
        ::VErrorMsg( lpInstall, achErrorRebootingSystem );
        return false;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if ( !AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 ) )
    {
        ::VErrorMsg( lpInstall, achErrorRebootingSystem );
        return false;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        ::VErrorMsg( lpInstall, achErrorRebootingSystem );
        return false;
    }

    return true;
}

HRESULT HrDeleteMe()
{
	HRESULT hr = NOERROR;
	CHAR szDrive[_MAX_DRIVE];
	CHAR szDir[_MAX_DIR];
	CHAR szFName[_MAX_FNAME];
	CHAR szPathBatchFile[_MAX_PATH];
	FILE *pf = NULL;
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	::VLog(L"Preparing to delete the running installer");

	//get the temp path
	if (::GetTempPathA(NUMBER_OF(szPathBatchFile), szPathBatchFile) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to get temporary path for batch file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	//get temp filename that we can write to
	if (0 == ::GetTempFileNameA(szPathBatchFile, "DEL", 0, szPathBatchFile))
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to get temp filename for batch file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	// Delete the .tmp file that GetTempFileNameA() leaves around...
	::DeleteFileA(szPathBatchFile);

	_splitpath(szPathBatchFile, szDrive, szDir, szFName, NULL);
	_makepath(szPathBatchFile, szDrive, szDir, szFName, ".BAT");

	::VLog(L"Creating self-deletion batch file: \"%S\"", szPathBatchFile);

	pf = fopen(szPathBatchFile, "w");
	if (pf == NULL)
	{
		hr = E_FAIL;
		::VLog(L"Unable to open batch file for output");
		goto Finish;
	}

	fprintf(pf, ":start\ndel \"%S\"\nif exist \"%S\" goto start\ndel \"%s\"\nexit\n", g_wszThisExe, g_wszThisExe, szPathBatchFile);
	fclose(pf);
	pf = NULL;

	memset(&si, 0,sizeof(si));
	si.cb = sizeof(si);

	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_HIDE;

	::VLog(L"About to run command line: \"%S\"", szPathBatchFile);

	if (!::CreateProcessA(
				NULL,					// lpApplicationName
				szPathBatchFile,		// lpCommandLine
				NULL,					// lpProcessAttributes
				NULL,					// lpThreadAttributes
				FALSE,					// bInheritHandles
				IDLE_PRIORITY_CLASS |
					CREATE_SUSPENDED,	// dwCreationFlags
				NULL,					// lpEnvironment
				"\\",					// lpCurrentDirectory
				&si,					// lpStartupInfo
				&pi))					// lpProcessInfo
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to create process to run batch script; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	::SetThreadPriority(pi.hThread, THREAD_PRIORITY_IDLE);

	::SetThreadPriority(::GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
	::SetPriorityClass(::GetCurrentProcess(), HIGH_PRIORITY_CLASS);

	::CloseHandle(pi.hProcess);
	::ResumeThread(pi.hThread);
	::CloseHandle(pi.hThread);

	hr = NOERROR;

Finish:

	return hr;
}


//******************************************************
//The following are utility methods for window manipulation


//Center one window within another.
HRESULT HrCenterWindow( HWND hwndChild, HWND hwndParent )
{
	HRESULT hr = NOERROR;

    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

	// Get the Height and Width of the child window
	if (!::GetWindowRect (hwndChild, &rChild))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
	if (!::GetWindowRect (hwndParent, &rParent))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = ::GetDC(hwndChild);
	if (hdc == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

    wScreen = ::GetDeviceCaps (hdc, HORZRES);
    hScreen = ::GetDeviceCaps (hdc, VERTRES);

    ::ReleaseDC(hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0)
	{
        xNew = 0;
    }
	else if ((xNew+wChild) > wScreen)
	{
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0)
	{
        yNew = 0;
    }
	else if ((yNew+hChild) > hScreen)
	{
        yNew = hScreen - hChild;
    }

    // Set it, and return
    if (!::SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}



//END utility methods for window manipulation
//******************************************************













// HACK HACK HACK!!!
// Currently, we're not catching **ANY**  (none, "zilch") exceptions.  We're throwing them
// in some methods here, but are not catching them.  This is VERY not good!!!  -- kinc(1/27/98)


//****************************************************************************
// Exception throwers

inline void VsThrowLastError(HRESULT hrDefault = E_FAIL) throw(/*_com_error*/)
{
//	VsAssertCanThrow();
//	VSASSERT(FAILED(hrDefault), "Asked to use a non-failure default failure code");

	HRESULT hr;
	const DWORD dwLastError = ::GetLastError();
	if (dwLastError == 0)
		hr = hrDefault;
	else
		hr = HRESULT_FROM_WIN32(dwLastError);

	::VLog(L"VsThrowLastError() was called!!");

	::VReportError("something bad has happened", hr);

	exit(hr);
}

#define VS_RETURN_HRESULT(hr, p) do { if (FAILED(hr)) ::SetErrorInfo(0, (p)); return (hr); } while (0)


static const WCHAR g_rgwchHexDigits[] = L"0123456789abcdef";
static const CHAR g_rgchHexDigits[] = "0123456789abcdef";


//*****************************************************************************











//********************************************************************************************8
// CCHARBuffer stuff

//
//	CCHARBufferBase implementation:
//

CCHARBufferBase::CCHARBufferBase
(
CHAR *pszInitialFixedBuffer,
ULONG cchInitialFixedBuffer
) throw () : m_pszDynamicBuffer(NULL)
{
//	VsNoThrow();

	m_pszCurrentBufferStart = pszInitialFixedBuffer;
	m_pszCurrentBufferEnd = pszInitialFixedBuffer + cchInitialFixedBuffer;
	m_pchCurrentChar = m_pszCurrentBufferStart;
	m_cchBufferCurrent = cchInitialFixedBuffer;
}

CCHARBufferBase::~CCHARBufferBase() throw ()
{
	const DWORD dwLastError = ::GetLastError();

//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsNoThrow();

	if (m_pszDynamicBuffer != NULL)
	{
		delete []m_pszDynamicBuffer;
		m_pszDynamicBuffer = NULL;
	}

	::SetLastError(dwLastError);
}

BOOL CCHARBufferBase::FFromUnicode(LPCOLESTR sz) throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

	if (sz == NULL || sz[0] == L'\0')
	{
		if (!this->FSetBufferSize(1))
			return FALSE;

		m_pszCurrentBufferStart[0] = '\0';
		m_pchCurrentChar = m_pszCurrentBufferStart + 1;
		return TRUE;
	}

	ULONG cch = ::WideCharToMultiByte(CP_ACP, 0, sz, -1, NULL, 0, NULL, NULL);
	if (cch == 0)
		return FALSE;

	if (!this->FSetBufferSize(cch))
		return FALSE;

	cch = ::WideCharToMultiByte(CP_ACP, 0, sz, -1, m_pszCurrentBufferStart, m_cchBufferCurrent, NULL, NULL);
	if (cch == 0)
		return FALSE;

	// cch is the number of bytes, including the trailing null character.  Advance by
	// cch - 1 characters.
	m_pchCurrentChar = m_pszCurrentBufferStart + (cch - 1);
	return TRUE;
}

BOOL CCHARBufferBase::FFromUnicode(LPCOLESTR sz, int cchIn) throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

	if (sz == NULL || cchIn == 0)
	{
		if (!this->FSetBufferSize(1))
			return FALSE;

		m_pszCurrentBufferStart[0] = '\0';
		m_pchCurrentChar = m_pszCurrentBufferStart + 1;
		return TRUE;
	}

	if (cchIn == -1)
		cchIn = wcslen(sz);

	ULONG cch = ::WideCharToMultiByte(CP_ACP, 0, sz, cchIn, NULL, 0, NULL, NULL);
	if ((cch == 0) && (cchIn != 0))
		return FALSE;

	// cch doesn't include the NULL since cchIn did not.
	if (!this->FSetBufferSize(cch + 1))
		return FALSE;

	cch = ::WideCharToMultiByte(CP_ACP, 0, sz, cchIn, m_pszCurrentBufferStart, m_cchBufferCurrent, NULL, NULL);
	if ((cch == 0) && (cchIn != 0))
		return FALSE;

	m_pchCurrentChar = m_pszCurrentBufferStart + cch;
	*m_pchCurrentChar = '\0';

	return TRUE;
}

ULONG CCHARBufferBase::GetUnicodeCch() const throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

	int iResult = ::MultiByteToWideChar(CP_ACP, 0,
						m_pszCurrentBufferStart, m_pchCurrentChar - m_pszCurrentBufferStart,
						NULL, 0);
	if (iResult == 0)
	{
		if (m_pchCurrentChar != m_pszCurrentBufferStart)
			VsThrowLastError();
	}

	return iResult;
}

void CCHARBufferBase::Sync() throw ()
{
//	VsNoThrow();

	CHAR *pchNull = m_pszCurrentBufferStart;

	while (pchNull != m_pszCurrentBufferEnd)
	{
		if (*pchNull == L'\0')
			break;

		pchNull++;
	}

	// The caller shouldn't have called us unless they had written a null-
	// terminated string into the buffer...
//	_ASSERTE(pchNull != m_pszCurrentBufferEnd);

	if (pchNull != m_pszCurrentBufferEnd)
	{
//		_ASSERTE(pchNull >= m_pszCurrentBufferStart &&
//				 pchNull <= m_pszCurrentBufferEnd);
		m_pchCurrentChar = pchNull;
	}
}

void CCHARBufferBase::SyncList() throw ()
{
//	VsNoThrow();

	// Useful when the string is actually a series of strings, each
	// separated by a null character and with the whole mess terminated by
	// two nulls.
	CHAR *pchNull = m_pszCurrentBufferStart;
	bool fPrevWasNull = false;
	while (pchNull != m_pszCurrentBufferEnd)
	{
		if (*pchNull == L'\0')
		{
			if (fPrevWasNull)
				break;
			else
				fPrevWasNull=true;
		}
		else
			fPrevWasNull=false;

		pchNull++;
	}

	// The caller shouldn't have called us unless they had written a null-
	// terminated string into the buffer...
//	_ASSERTE(pchNull != m_pszCurrentBufferEnd);

	if (pchNull != m_pszCurrentBufferEnd)
	{
//		_ASSERTE(pchNull >= m_pszCurrentBufferStart &&
//				 pchNull <= m_pszCurrentBufferEnd);
		m_pchCurrentChar = pchNull;
	}
}

void CCHARBufferBase::SetBufferEnd(ULONG cch) throw ()
{
//	VsNoThrow();

//	_ASSERTE(((int) cch) <= (m_pszCurrentBufferEnd - m_pszCurrentBufferStart));
	m_pchCurrentChar = m_pszCurrentBufferStart + cch;
	if (m_pchCurrentChar >= m_pszCurrentBufferEnd)
		m_pchCurrentChar = m_pszCurrentBufferEnd - 1;
	*m_pchCurrentChar = '\0';
}


//
// The length returned through pcchActual is the length including the NULL character.
//
void CCHARBufferBase::ToUnicode(ULONG cchBuffer, WCHAR rgwchBuffer[], ULONG *pcchActual) throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

	ULONG cchActual = m_pchCurrentChar - m_pszCurrentBufferStart;

	if ((cchActual != 0) && (cchBuffer > 0))
	{
		INT cch = ::MultiByteToWideChar(
						CP_ACP,
						0,
						m_pszCurrentBufferStart, cchActual,
						rgwchBuffer, cchBuffer-1);
		if (cch == 0)
			VsThrowLastError();

		rgwchBuffer[cch] = L'\0';
		cchActual = cch;
	}

	if (pcchActual != NULL)
		*pcchActual = cchActual+1;
}

#if 0
void CCHARBufferBase::Reset() throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

	delete []m_pszDynamicBuffer;
	m_pszDynamicBuffer = NULL;
	m_pszCurrentBufferStart = this->GetInitialBuffer();
	m_cchBufferCurrent = this->GetInitialBufferCch();
	m_pszCurrentBufferEnd = m_pszCurrentBufferStart + m_cchBufferCurrent;
	m_pchCurrentChar = m_pszCurrentBufferStart;
}

void CCHARBufferBase::Fill(CHAR ch, ULONG cch) throw (/*_com_error*/)
{
//	VsAssertCanThrow();

	CHAR *pchLast = m_pchCurrentChar + cch;

	if (pchLast > m_pszCurrentBufferEnd)
	{
		ULONG cchGrowth = (cch - (m_cchBufferCurrent - (m_pchCurrentChar - m_pszCurrentBufferStart)));
		cchGrowth += (this->GetGrowthCch() - 1);
		cchGrowth = cchGrowth - (cchGrowth % this->GetGrowthCch());

		this->ExtendBuffer(cchGrowth);

		pchLast = m_pchCurrentChar + cch;
	}

//	_ASSERTE((m_pchCurrentChar >= m_pszCurrentBufferStart) &&
//			 ((m_pchCurrentChar + cch) <= m_pszCurrentBufferEnd));

	while (m_pchCurrentChar != pchLast)
		*m_pchCurrentChar++ = ch;

//	_ASSERTE((m_pchCurrentChar >= m_pszCurrentBufferStart) &&
//			 (m_pchCurrentChar <= m_pszCurrentBufferEnd));
}
#endif

BOOL CCHARBufferBase::FSetBufferSize(ULONG cch) throw (/*_com_error*/)
{
//	VsAssertCanThrow();

	if (cch > m_cchBufferCurrent)
		return this->FExtendBuffer(cch - m_cchBufferCurrent);

	return TRUE;
}

#if 0
HRESULT CCHARBufferBase::HrSetBufferSize(ULONG cch) throw ()
{
//	VsNoThrow();
	if (cch > m_cchBufferCurrent)
		return this->HrExtendBuffer(cch - m_cchBufferCurrent);
	return NOERROR;
}
#endif

BOOL CCHARBufferBase::FExtendBuffer(ULONG cch) throw (/*_com_error*/)
{
//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

//	_ASSERTE(cch != 0);

	// If they for some reason claimed not to want to extend it farther, we'll
	// just go ahead and extend it anyways.
	if (cch == 0)
		cch = 32;

	ULONG cchNew = m_cchBufferCurrent + cch;

	CHAR *pszNewDynamicBuffer = new CHAR[cchNew];
	if (pszNewDynamicBuffer == NULL)
	{
		::VLog(L"Unable to extend ANSI buffer to %d bytes; out of memory!", cchNew);
		::SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

	memcpy(pszNewDynamicBuffer, m_pszCurrentBufferStart, m_cchBufferCurrent * sizeof(CHAR));

	delete []m_pszDynamicBuffer;

	m_pchCurrentChar = pszNewDynamicBuffer + (m_pchCurrentChar - m_pszCurrentBufferStart);
	m_pszDynamicBuffer = pszNewDynamicBuffer;
	m_pszCurrentBufferStart = pszNewDynamicBuffer;
	m_pszCurrentBufferEnd = pszNewDynamicBuffer + cchNew;
	m_cchBufferCurrent = cchNew;

	return TRUE;
}

HRESULT CCHARBufferBase::HrExtendBuffer(ULONG cch) throw ()
{
//	VsNoThrow();

//	CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
//	VsAssertCanThrow();

//	_ASSERTE(cch != 0);

	// If they for some reason claimed not to want to extend it farther, we'll
	// just go ahead and extend it anyways.
	if (cch == 0)
		cch = 32;

	ULONG cchNew = m_cchBufferCurrent + cch;

	CHAR *pszNewDynamicBuffer = new CHAR[cchNew];
	if (pszNewDynamicBuffer == NULL)
		VS_RETURN_HRESULT(E_OUTOFMEMORY, NULL);

	memcpy(pszNewDynamicBuffer, m_pszCurrentBufferStart, m_cchBufferCurrent * sizeof(CHAR));

	delete []m_pszDynamicBuffer;

	m_pchCurrentChar = pszNewDynamicBuffer + (m_pchCurrentChar - m_pszCurrentBufferStart);
	m_pszDynamicBuffer = pszNewDynamicBuffer;
	m_pszCurrentBufferStart = pszNewDynamicBuffer;
	m_pszCurrentBufferEnd = pszNewDynamicBuffer + cchNew;
	m_cchBufferCurrent = cchNew;

	return NOERROR;
}

#if 0
void CCHARBufferBase::AddQuotedCountedString
(
const CHAR sz[],
ULONG cch
) throw (/*_com_error*/)
{
//	VsAssertCanThrow();

	this->AddChar('\"');

	const CHAR *pch = sz;
	const CHAR *pchEnd = sz + cch;
	CHAR ch;

	while (pch != pchEnd)
	{
		ch = *pch++;

		if (ch == '\t')
		{
			this->AddChar('\\');
			this->AddChar('t');
		}
		else if (ch == '\"')
		{
			this->AddChar('\\');
			this->AddChar('\"');
		}
		else if (ch == '\\')
		{
			this->AddChar('\\');
			this->AddChar('\\');
		}
		else if (ch == '\n')
		{
			this->AddChar('\\');
			this->AddChar('n');
		}
		else if (ch == '\r')
		{
			this->AddChar('\\');
			this->AddChar('r');
		}
		else if (ch < 32)
		{
			this->AddChar('\\');
			this->AddChar('u');
			this->AddChar(g_rgchHexDigits[(ch >> 12) & 0xf]);
			this->AddChar(g_rgchHexDigits[(ch >> 8) & 0xf]);
			this->AddChar(g_rgchHexDigits[(ch >> 4) & 0xf]);
			this->AddChar(g_rgchHexDigits[(ch >> 0) & 0xf]);
		}
		else
			this->AddChar(ch);
	}

	this->AddChar('\"');
}

void CCHARBufferBase::AddQuotedString(const CHAR sz[]) throw (/*_com_error*/)
{
//	VsAssertCanThrow();
	this->AddQuotedCountedString(sz, strlen(sz));
}
#endif


#if LOGGING_ENABLED

void ::VLog(const WCHAR szFormat[], ...)
{
	if (g_pFile_LogFile == NULL)
		return;

	time_t local_time;
	time(&local_time);
	WCHAR rgwchBuffer[80];
	wcscpy(rgwchBuffer, _wctime(&local_time));
	rgwchBuffer[wcslen(rgwchBuffer) - 1] = L'\0';

	fwprintf(g_pFile_LogFile, L"[%s] ", rgwchBuffer);

	va_list ap;
	va_start(ap, szFormat);
	vfwprintf(g_pFile_LogFile, szFormat, ap);
	va_end(ap);

	fwprintf(g_pFile_LogFile, L"\n");

	fflush(g_pFile_LogFile);
}

#endif // LOGGING_ENABLED

static void CanonicalizeFilename(ULONG cchFilenameBuffer, LPWSTR szFilename)
{
	if ((szFilename == NULL) || (cchFilenameBuffer == 0))
		return;

	WCHAR rgwchBuffer[MSINFHLP_MAX_PATH];

	int iResult = NVsWin32::LCMapStringW(
					::GetSystemDefaultLCID(),
					LCMAP_LOWERCASE,
					szFilename,
					-1,
					rgwchBuffer,
					NUMBER_OF(rgwchBuffer));

	if (iResult != 0)
	{
		wcsncpy(szFilename, rgwchBuffer, cchFilenameBuffer);
		// wcsncpy() doesn't necessarily null-terminate; make sure it is.
		szFilename[cchFilenameBuffer - 1] = L'\0';
	}
}

void VExpandFilename(LPCOLESTR szIn, ULONG cchBuffer, WCHAR szOut[])
{
	//convert string to lower case
	szOut[0] = 0;
	UINT i=0;
	WCHAR szLower[MSINFHLP_MAX_PATH];
	WCHAR szOutRunning[MSINFHLP_MAX_PATH];
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	wcscpy(szOut, szIn);
	wcscpy(szOutRunning, szIn);
	while (i < (sizeof(g_macroList) / sizeof(g_macroList[0])))
	{
		wcscpy(szLower, szOutRunning);
		_wcslwr(szLower);

		//check for match, skip to next macro of no match
		LPOLESTR match = wcsstr(szLower, g_macroList[i]);
		if (match == NULL)
		{
			i++;
			continue;
		}

		//look up this ID in the LDID list
		if (!g_pwil->FLookupString(g_macroList[i], NUMBER_OF(szBuffer), szBuffer))
		{
			i++;
			continue;
		}

		//replace away
		wcsncpy(szOut, szOutRunning, (match - &szLower[0]));
		szOut[match-&szLower[0]] = 0;
		wcscat(szOut, szBuffer);

		//append a backslash after the directory if there isn't one, or if it isn't NULL, or
		//if it isn't a quote
		if ((*(&szOutRunning[0] + (match - &szLower[0]) + strlen(g_macroList[i])) != L'\\')
			&& (*(&szOutRunning[0] + (match - &szLower[0]) + strlen(g_macroList[i])) != L'\0')
			&& (*(&szOutRunning[0] + (match - &szLower[0]) + strlen(g_macroList[i])) != L'\"'))
			wcscat(szOut, L"\\");

		//append the rest of the filename in normal case
		wcscat(szOut, &szOutRunning[0] + (match - &szLower[0]) + strlen(g_macroList[i]));

		wcscpy(szOutRunning, szOut);
		szBuffer[0] = 0;
	}
}

HWND HwndGetCurrentDialog()
{
	return g_KProgress.HwndGetHandle();
}

HRESULT HrPostRebootUninstall(HINSTANCE hInstance, HINSTANCE hInstancePrev, int nCmdShow)
{
	HRESULT hr = NOERROR;

	g_fSilent = true;

	// currently there doesn't seem to be anything to do.
	::VLog(L"Post-reboot uninstall being performed.. ho hum!");
	return hr;
}

HRESULT HrPostRebootInstall(HINSTANCE hInstance, HINSTANCE hInstancePrev, int nCmdShow)
{
	HRESULT hr = NOERROR;
	bool fAnyProgress = false;

	g_fSilent = true;

	::VLog(L"Starting post-reboot installation steps");

	::VLog(L"Performing manual renames of long filename targets that were busy on Win9x");
	hr = g_pwil->HrFinishManualRenamesPostReboot();
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Deleting temporary files left behind");
	hr = g_pwil->HrDeleteTemporaryFiles();
	if (FAILED(hr))
		goto Finish;

	// If we don't need a reboot, we can get on with things.
	do
	{
		fAnyProgress = false;
		::VLog(L"Registering self-registering DLLs and EXEs");
		hr = g_pwil->HrRegisterSelfRegisteringFiles(fAnyProgress);
		if (FAILED(hr))
		{
			if (!fAnyProgress)
				goto Finish;

			::VLog(L"self-registration failed, but progress was made.  Trying again...  hresult = 0x%08lx", hr);
		}
	} while (FAILED(hr) && fAnyProgress);

	::VLog(L"Registering any Java classes via vjreg.exe");
	hr = g_pwil->HrRegisterJavaClasses();
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Processing any DCOM entries");
	hr = g_pwil->HrProcessDCOMEntries();
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Incrementing file reference counts in the registry");
	hr = g_pwil->HrIncrementReferenceCounts();
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Creating registry entries");
	hr = g_pwil->HrAddRegistryEntries();
	if (FAILED(hr))
		goto Finish;

	//create the shortcut items
	::VLog(L"Creating shortcut(s)");
	hr = g_pwil->HrCreateShortcuts();
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}

static void CALLBACK WaitForProcessTimerProc(HWND, UINT, UINT, DWORD)
{
	g_hrFinishStatus = NOERROR;
	::PostQuitMessage(0);
}

#pragma warning(default: 4097)
#pragma warning(default: 4514)
#pragma warning(default: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by infhlp.rc
//
#define IDOK2                           3
#define IDD_DESTDIRDLG                  101
#define IDD_PROGRESS                    103
#define IDD_REMOTESERVERDLG             104
#define IDI_BOX_UNCHECK                 107
#define IDI_BOX_CHECK                   108
#define IDI_BOX_EX                      111
#define IDI_BOX_CURRENT                 112
#define IDD_YESNOALL                    113
#define IDD_WELCOME                     115
#define IDD_EXESTORUN                   116
#define IDD_INSTALLTO                   117
#define IDD_DCOM                        118
#define IDD_UPDATEFILE                  119
#define IDD_END                         120
#define IDC_BUT_BROWSE                  1000
#define IDC_TEXT_DESTDIR                1001
#define IDC_EDIT_DESTDIR                1002
#define IDC_BAR_PROGRESS                1003
#define IDC_TEXT_PROGRESS               1004
#define IDCANCEL_PROGRESS               1006
#define IDC_EDIT_REMOTESERVER           1007
#define IDC_TEXT_REMOTESERVER           1008
#define IDC_PROGRESS_BAR                1009
#define IDC_PROGRESS_STATUS_GROUP       1011
#define IDC_PROGRESS_STATIC             1013
#define IDC_PROGRESS_LIST               1015
#define IDC_PROGRESS_CANCEL             1016
#define IDC_BUTTON1                     1017
#define IDC_PROGRESS_CHANGE             1017
#define IDC_INSTALLTO_BROWSE            1017
#define IDC_UPDATEFILE_KEEP             1017
#define IDC_BUTTON2                     1018
#define IDC_PROGRESS_GO                 1018
#define IDC_UPDATEFILE_KEEPALL          1018
#define IDC_YNA_CANCEL                  1019
#define IDC_YNA_YES                     1020
#define IDC_YNA_YESTOALL                1021
#define IDC_YNA_NO                      1022
#define IDC_YNA_NOTOALL                 1023
#define IDC_YNA_MESSAGE                 1024
#define IDC_PROGRESS_STATIC_INSTALLDIR  1027
#define IDC_PROGRESS_PICTURE            1028
#define IDC_PROGRESS_INSTALLDIR         1031
#define IDC_PROGRESS_PROGRESS           1032
#define IDC_DCOM_EDIT                   1033
#define IDC_WELCOME_CONTINUE            1034
#define IDC_WELCOME_EXIT_SETUP          1035
#define IDC_EXESTORUN_PROGRESS          1036
#define IDC_EXESTORUN_NEXT              1037
#define IDC_EXESTORUN_EXIT_SETUP        1039
#define IDC_INSTALLTO_NEXT              1040
#define IDC_INSTALLTO_EXIT_SETUP        1041
#define IDC_INSTALLTO_EDIT              1042
#define IDC_DCOM_NEXT                   1043
#define IDC_DCOM_EXIT_SETUP             1044
#define IDC_PROGRESS_NEXT               1045
#define IDC_END_NEXT                    1046
#define IDC_END_CLOSE                   1047
#define IDC_DCOM_STATIC1                1048
#define IDC_DCOM_STATIC2                1049
#define IDC_DCOM_STATIC3                1050
#define IDC_EXESTORUN_STATIC1           1051
#define IDC_EXESTORUN_STATIC2           1052
#define IDC_INSTALLTO_STATIC1           1053
#define IDC_INSTALLTO_STATIC2           1054
#define IDC_INSTALLTO_STATIC3           1055
#define IDC_PROGRESS_STATIC1            1056
#define IDC_PROGRESS_STATIC2            1057
#define IDC_PROGRESS_STATIC3            1058
#define IDC_WELCOME_STATIC1             1059
#define IDC_WELCOME_STATIC2             1060
#define IDC_WELCOME_STATIC3             1061
#define IDC_WELCOME_STATIC4             1062
#define IDC_END_STATIC1                 1063
#define IDC_END_STATIC2                 1064
#define IDC_END_STATIC3                 1065
#define IDC_END_STATIC4                 1066
#define IDC_UPDATEFILE_EDIT_FILENAME    1066
#define IDC_UPDATEFILE_REPLACE          1067
#define IDC_UPDATEFILE_REPLACEALL       1068
#define IDC_UPDATEFILE_STATIC1          1069
#define IDC_UPDATEFILE_E_SIZE           1070
#define IDC_UPDATEFILE_E_TIME           1071
#define IDC_UPDATEFILE_I_SIZE           1072
#define IDC_UPDATEFILE_I_TIME           1073
#define IDC_UPDATEFILE_E_STATIC2        1074
#define IDC_UPDATEFILE_I_STATIC3        1075
#define IDC_UPDATEFILE_E_VERSION        1076
#define IDC_UPDATEFILE_I_VERSION        1077
#define IDC_UPDATEFILE_STATIC4          1078
#define IDC_PROGRESS_STATIC4            1079
#define IDC_EXESTORUN_STATIC3           1080

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1081
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\regwpr.h ===
#pragma once

class CVsRegistryKey
{
public:
	CVsRegistryKey() : m_hkey(NULL) { }
	virtual ~CVsRegistryKey()
	{
		if (m_hkey != NULL)
		{
			if ((m_hkey != HKEY_CURRENT_USER) &&
				(m_hkey != HKEY_LOCAL_MACHINE) &&
				(m_hkey != HKEY_CLASSES_ROOT) &&
				(m_hkey != HKEY_CURRENT_CONFIG) &&
				(m_hkey != HKEY_USERS) &&
				(m_hkey != HKEY_PERFORMANCE_DATA) &&
				(m_hkey != HKEY_DYN_DATA))
				::RegCloseKey(m_hkey);

			m_hkey = NULL;
		}
	}

	void VAttach(HKEY hkey)
	{
		if (m_hkey != NULL)
			::RegCloseKey(m_hkey);

		m_hkey = hkey;
	}

	HRESULT HrOpenKeyExW(HKEY hkey, LPCWSTR szSubKey, DWORD ulOptions, REGSAM samDesired)
	{
		HKEY hkeyTemp = NULL;

		LONG lResult = NVsWin32::RegOpenKeyExW(hkey, szSubKey, ulOptions, samDesired, &hkeyTemp);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);

		if (m_hkey != NULL)
			::RegCloseKey(m_hkey);

		m_hkey = hkeyTemp;

		return NOERROR;
	}

	HRESULT HrCloseKey()
	{
		if (m_hkey == NULL)
			return E_FAIL;

		LONG lResult = ::RegCloseKey(m_hkey);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);

		m_hkey = NULL;

		return NOERROR;
	}

	HRESULT HrSetValueExW(LPCWSTR szValueName, DWORD dwReserved, DWORD dwType, CONST BYTE *pbData, DWORD cbData)
	{
		if (m_hkey == NULL)
			return E_FAIL;
		LONG lResult = NVsWin32::RegSetValueExW(m_hkey, szValueName, dwReserved, dwType, pbData, cbData);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);
		return NOERROR;
	}

	HRESULT HrDeleteValueW(LPCWSTR szValueName)
	{
		if (m_hkey == NULL)
			return E_FAIL;
		LONG lResult = NVsWin32::RegDeleteValueW(m_hkey, szValueName);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);
		return NOERROR;
	}

	HRESULT HrDeleteValuesAndSubkeys()
	{
		HRESULT hr = NOERROR;
		LONG lResult = 0;
		DWORD dwIndex = 0;
		WCHAR szName[_MAX_PATH]; // arbitrary semi-reasonable buffer size

		// We have to do this the hard way.
		struct KeyStruct
		{
			WCHAR m_szName[_MAX_PATH];
			KeyStruct *m_pNext;
		} *pFirstKey = NULL;

		struct ValueStruct
		{
			WCHAR m_szName[_MAX_PATH];
			ValueStruct *m_pNext;
		} *pFirstValue = NULL;

		if (m_hkey == NULL)
		{
			hr = E_FAIL;
			goto Finish;
		}

		for (dwIndex = 0; ; dwIndex++)
		{
			DWORD cchName = NUMBER_OF(szName);
			FILETIME ft;

			lResult = NVsWin32::RegEnumKeyExW(
							m_hkey,
							dwIndex,
							szName,
							&cchName,
							NULL,
							NULL,
							NULL,
							&ft);
			if (lResult == ERROR_NO_MORE_ITEMS)
				break;
			else if (lResult != ERROR_SUCCESS)
			{
				::VLog(L"RegEnumKeyExW() failed; win32 error = %d", lResult);
				hr = HRESULT_FROM_WIN32(lResult);
				goto Finish;
			}

			KeyStruct *pNewKey = new KeyStruct;
			if (pNewKey == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Finish;
			}

			wcsncpy(pNewKey->m_szName, szName, NUMBER_OF(pNewKey->m_szName));
			pNewKey->m_szName[NUMBER_OF(pNewKey->m_szName) - 1] = L'\0';
			pNewKey->m_pNext = pFirstKey;
			pFirstKey = pNewKey;
		}

		while (pFirstKey != NULL)
		{
			CVsRegistryKey hkeySubkey;

			hr = hkeySubkey.HrOpenKeyExW(m_hkey, pFirstKey->m_szName, 0, KEY_ALL_ACCESS);
			if (FAILED(hr))
			{
				::VLog(L"HrOpenKeyExW() failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			hr = hkeySubkey.HrDeleteValuesAndSubkeys();
			if (FAILED(hr))
			{
				::VLog(L"HrDeleteValuesAndSubkeys() failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			hr = hkeySubkey.HrCloseKey();
			if (FAILED(hr))
			{
				::VLog(L"HrCloseKey() failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			lResult = NVsWin32::RegDeleteKeyW(m_hkey, pFirstKey->m_szName);
			if (lResult != ERROR_SUCCESS)
			{
				::VLog(L"RegDeleteKeyW() failed; win32 error = %d", lResult);
				hr = HRESULT_FROM_WIN32(lResult);
				goto Finish;
			}

			KeyStruct *pNext = pFirstKey->m_pNext;
			delete pFirstKey;
			pFirstKey = pNext;
		}

		for (dwIndex = 0;; dwIndex++)
		{
			DWORD cchName = NUMBER_OF(szName);

			lResult = NVsWin32::RegEnumValueW(
							m_hkey,
							dwIndex,
							szName,
							&cchName,
							NULL,
							NULL,
							NULL,
							NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
				break;
			else if (lResult != ERROR_SUCCESS)
			{
				::VLog(L"RegEnumValueW() failed; win32 error = %d", lResult);
				hr = HRESULT_FROM_WIN32(lResult);
				goto Finish;
			}

			ValueStruct *pNewValue = new ValueStruct;
			if (pNewValue == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Finish;
			}

			wcsncpy(pNewValue->m_szName, szName, NUMBER_OF(pNewValue->m_szName));
			pNewValue->m_szName[NUMBER_OF(pNewValue->m_szName) - 1] = L'\0';

			pNewValue->m_pNext = pFirstValue;
			pFirstValue = pNewValue;
		}

		while (pFirstValue != NULL)
		{
			hr = this->HrDeleteValueW(pFirstValue->m_szName);
			if (FAILED(hr))
			{
				::VLog(L"HrDeleteValueW(\"%s\") failed; hresult = 0x%08lx", pFirstValue->m_szName, hr);
				goto Finish;
			}

			ValueStruct *pNext = pFirstValue->m_pNext;
			delete pFirstValue;
			pFirstValue = pNext;
		}
	
		hr = NOERROR;

	Finish:
		while (pFirstValue != NULL)
		{
			ValueStruct *pNext = pFirstValue->m_pNext;
			delete pFirstValue;
			pFirstValue = pNext;
		}

		while (pFirstKey != NULL)
		{
			KeyStruct *pNext = pFirstKey->m_pNext;
			delete pFirstKey;
			pFirstKey = pNext;
		}

		return hr;
	}

	HRESULT HrQueryValueExW(LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData)
	{
		if (m_hkey == NULL)
			return E_FAIL;

		LONG lResult = NVsWin32::RegQueryValueExW(m_hkey, szValueName, pdwReserved, pdwType, pbData, pcbData);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);
		return NOERROR;
	}

	HRESULT HrGetStringValueW(LPCWSTR szValueName, ULONG cchBuffer, WCHAR szBuffer[])
	{
		if (m_hkey == NULL)
			return E_FAIL;

		DWORD dwLength = cchBuffer * sizeof(WCHAR);
		LONG lResult = NVsWin32::RegQueryValueExW(m_hkey, szValueName, NULL, NULL, reinterpret_cast<LPBYTE>(szBuffer), &dwLength);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);
		return NOERROR;
	}

	HRESULT HrGetSubkeyStringValueW(LPCWSTR szSubkeyName, LPCWSTR szValueName, ULONG cchBuffer, WCHAR szBuffer[])
	{
		if (m_hkey == NULL)
			return E_FAIL;
		CVsRegistryKey keySubkey;
		HRESULT hr = keySubkey.HrOpenKeyExW(m_hkey, szSubkeyName, 0, KEY_QUERY_VALUE);
		if (SUCCEEDED(hr))
			hr = keySubkey.HrGetStringValueW(szValueName, cchBuffer, szBuffer);
		return hr;
	}


	HRESULT HrSetStringValueW(LPCWSTR szValueName, LPCWSTR szValue)
	{
		if (m_hkey == NULL)
			return E_FAIL;
		
		DWORD cbValue = 0;

		if (szValue != NULL)
			cbValue = (wcslen(szValue) + 1) * sizeof(WCHAR);

		LONG lResult = NVsWin32::RegSetValueExW(m_hkey, szValueName, 0, REG_SZ, (LPBYTE) szValue, cbValue);
		if (lResult != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(lResult);
		return NOERROR;
	}

	HKEY *operator &() { return &m_hkey; }
	HKEY const * operator &() const { return &m_hkey; }

	HKEY &Access() { return m_hkey; }
	const HKEY &Access() const { return m_hkey; }

	operator HKEY() const { return m_hkey; }

protected:
	HKEY m_hkey;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\stdinc.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winver.h>
#include <winerror.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <commctrl.h>
#include <wchar.h>
#include <time.h>
#include <objbase.h>
#include <urlmon.h>
#include <shellapi.h>
#include <shtypes.h>
#include <shlobj.h>
#include "charbuf.h"
#include "win32wpr.h"
#include "msinfhlp.h"
#include "resource.h"
#include "regwpr.h"

#define NUMBER_OF(x)  (sizeof(x) / sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\msxml.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Sep 25 09:49:37 1997
 */
/* Compiler settings for msxml.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __msxml_h__
#define __msxml_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IXMLElementCollection_FWD_DEFINED__
#define __IXMLElementCollection_FWD_DEFINED__
typedef interface IXMLElementCollection IXMLElementCollection;
#endif 	/* __IXMLElementCollection_FWD_DEFINED__ */


#ifndef __IXMLDocument_FWD_DEFINED__
#define __IXMLDocument_FWD_DEFINED__
typedef interface IXMLDocument IXMLDocument;
#endif 	/* __IXMLDocument_FWD_DEFINED__ */


#ifndef __IXMLElement_FWD_DEFINED__
#define __IXMLElement_FWD_DEFINED__
typedef interface IXMLElement IXMLElement;
#endif 	/* __IXMLElement_FWD_DEFINED__ */


#ifndef __IXMLError_FWD_DEFINED__
#define __IXMLError_FWD_DEFINED__
typedef interface IXMLError IXMLError;
#endif 	/* __IXMLError_FWD_DEFINED__ */


#ifndef __IXMLElementNotificationSink_FWD_DEFINED__
#define __IXMLElementNotificationSink_FWD_DEFINED__
typedef interface IXMLElementNotificationSink IXMLElementNotificationSink;
#endif 	/* __IXMLElementNotificationSink_FWD_DEFINED__ */


#ifndef __XMLDocument_FWD_DEFINED__
#define __XMLDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLDocument XMLDocument;
#else
typedef struct XMLDocument XMLDocument;
#endif /* __cplusplus */

#endif 	/* __XMLDocument_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_msxml_0000
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//--------------------------------------------------------------------------





extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_v0_0_s_ifspec;


#ifndef __MSXML_LIBRARY_DEFINED__
#define __MSXML_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSXML
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


typedef 
enum xmlelemTYPE
    {	XMLELEMTYPE_ELEMENT	= 0,
	XMLELEMTYPE_TEXT	= XMLELEMTYPE_ELEMENT + 1,
	XMLELEMTYPE_COMMENT	= XMLELEMTYPE_TEXT + 1,
	XMLELEMTYPE_DOCUMENT	= XMLELEMTYPE_COMMENT + 1,
	XMLELEMTYPE_DTD	= XMLELEMTYPE_DOCUMENT + 1,
	XMLELEMTYPE_PI	= XMLELEMTYPE_DTD + 1,
	XMLELEMTYPE_OTHER	= XMLELEMTYPE_PI + 1
    }	XMLELEM_TYPE;

typedef struct  _xml_error
    {
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    DWORD _reserved1;
    DWORD _reserved2;
    }	XML_ERROR;


EXTERN_C const IID LIBID_MSXML;

#ifndef __IXMLElementCollection_INTERFACE_DEFINED__
#define __IXMLElementCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IXMLElementCollection
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IXMLElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("65725580-9B5D-11d0-9BFE-00C04FC99C8E")
    IXMLElementCollection : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_length( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElementCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElementCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        END_INTERFACE
    } IXMLElementCollectionVtbl;

    interface IXMLElementCollection
    {
        CONST_VTBL struct IXMLElementCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementCollection_put_length(This,v)	\
    (This)->lpVtbl -> put_length(This,v)

#define IXMLElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IXMLElementCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#define IXMLElementCollection_item(This,var1,var2,ppDisp)	\
    (This)->lpVtbl -> item(This,var1,var2,ppDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_put_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IXMLElementCollection_put_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IXMLElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get__newEnum_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IXMLElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_item_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in][optional] */ VARIANT var1,
    /* [in][optional] */ VARIANT var2,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IXMLElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument_INTERFACE_DEFINED__
#define __IXMLDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IXMLDocument
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IXMLDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F52E2B61-18A1-11d1-B105-00805F49916B")
    IXMLDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_root )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileSize )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileModifiedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileUpdatedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mimeType )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdURL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);
        
        END_INTERFACE
    } IXMLDocumentVtbl;

    interface IXMLDocument
    {
        CONST_VTBL struct IXMLDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_root_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileSize_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileModifiedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileUpdatedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_mimeType_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_readyState_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pl);


void __RPC_STUB IXMLDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_version_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_doctype_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_dtdURL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDocument_createElement_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB IXMLDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLElement_INTERFACE_DEFINED__
#define __IXMLElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IXMLElement
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IXMLElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")
    IXMLElement : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long __RPC_FAR *plType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_children )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *plType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem);
        
        END_INTERFACE
    } IXMLElementVtbl;

    interface IXMLElement
    {
        CONST_VTBL struct IXMLElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_parent_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IXMLElement_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_setAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_getAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);


void __RPC_STUB IXMLElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_children_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_type_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *plType);


void __RPC_STUB IXMLElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_addChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElement_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement_INTERFACE_DEFINED__ */


#ifndef __IXMLError_INTERFACE_DEFINED__
#define __IXMLError_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IXMLError
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IXMLError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")
    IXMLError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            XML_ERROR __RPC_FAR *pErrorReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLError __RPC_FAR * This,
            XML_ERROR __RPC_FAR *pErrorReturn);
        
        END_INTERFACE
    } IXMLErrorVtbl;

    interface IXMLError
    {
        CONST_VTBL struct IXMLErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLError_GetErrorInfo(This,pErrorReturn)	\
    (This)->lpVtbl -> GetErrorInfo(This,pErrorReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLError_GetErrorInfo_Proxy( 
    IXMLError __RPC_FAR * This,
    XML_ERROR __RPC_FAR *pErrorReturn);


void __RPC_STUB IXMLError_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLError_INTERFACE_DEFINED__ */


#ifndef __IXMLElementNotificationSink_INTERFACE_DEFINED__
#define __IXMLElementNotificationSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IXMLElementNotificationSink
 * at Thu Sep 25 09:49:37 1997
 * using MIDL 3.02.88
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IXMLElementNotificationSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D9F1E15A-CCDB-11d0-9C0C-00C04FC99C8E")
    IXMLElementNotificationSink : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChildAdded( 
            /* [in] */ IDispatch __RPC_FAR *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementNotificationSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElementNotificationSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElementNotificationSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChildAdded )( 
            IXMLElementNotificationSink __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pChildElem);
        
        END_INTERFACE
    } IXMLElementNotificationSinkVtbl;

    interface IXMLElementNotificationSink
    {
        CONST_VTBL struct IXMLElementNotificationSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementNotificationSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementNotificationSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementNotificationSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementNotificationSink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementNotificationSink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementNotificationSink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementNotificationSink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementNotificationSink_ChildAdded(This,pChildElem)	\
    (This)->lpVtbl -> ChildAdded(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElementNotificationSink_ChildAdded_Proxy( 
    IXMLElementNotificationSink __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElementNotificationSink_ChildAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementNotificationSink_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("CFC399AF-D876-11d0-9C10-00C04FC99C8E")
XMLDocument;
#endif
#endif /* __MSXML_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\msinfhlp.h ===
#pragma once

#define MSINFHLP_MAX_PATH (8192)

// Someday we should make logging optional; currently it only saves 8k in the output to turn it off, so we
// don't.  -mgrier 3/9/98  (12k now, 3/13/98)
#if 1
#define LOGGING_ENABLED 1
#else
#if defined(_DEBUG) || defined(DEBUG)
#define LOGGING_ENABLED 1
#else
#define LOGGING_ENABLED 0
#endif
#endif

#if LOGGING_ENABLED
extern void VLog(const WCHAR szFormat[], ...) throw ();
#else
inline void VLog(const WCHAR szFormat[], ...) throw () { }
#endif

#include "workitem.h"

extern void VExpandFilename(LPCWSTR szIn, ULONG cchBuffer, WCHAR szBuffer[]) throw ();
extern void VMsgBoxOK(LPCSTR achTitleKey, LPCSTR achMessageKey, ...) throw ();
extern bool FMsgBoxYesNo(LPCSTR achTitleKey, LPCSTR achMessageKey, ...) throw ();
extern int IMsgBoxYesNoCancel(LPCSTR achTitleKey, LPCSTR achMessageKey, ...) throw ();
extern DWORD DwMsgBoxYesNoAll(LPCSTR szTitleKey, LPCSTR szMessageKey, ...) throw ();

extern void VErrorMsg(LPCSTR aszTitle, LPCSTR aszMessage, ...) throw ();
extern void VReportError(LPCSTR szTitleKey, HRESULT hr) throw ();
extern void VFormatError(ULONG cchBuffer, LPWSTR szBuffer, HRESULT hr) throw ();

extern void VClearErrorContext();
extern void VSetErrorContextVa(LPCSTR szKey, va_list ap);
extern void VSetErrorContext(LPCSTR szKey, LPCWSTR szParam0 = NULL, ...);

extern wchar_t *wcsstr(const wchar_t *pwszString, const char *pszSubstring) throw ();
extern wchar_t *wcscpy(wchar_t *pwszDestination, const char *pszSource) throw ();

extern void VSetDialogItemText(HWND hwndDialog, UINT uiControlID, LPCSTR szKey, ...) throw ();

extern HRESULT HrAnalyzeClassFile(LPCOLESTR szFileName, bool &rfNeedsToBeRegistered) throw ();

struct DialogItemToStringKeyMapEntry
{
	UINT m_uiID;
	LPCSTR m_pszValueKey;
};

extern void VSetDialogItemTextList(HWND hwndDialog, ULONG cEntries, const DialogItemToStringKeyMapEntry rgMap[]) throw ();

extern void VFormatString(ULONG cchBuffer, WCHAR szBuffer[], const WCHAR szFormatString[], ...) throw ();
extern void VFormatStringVa(ULONG cchBuffer, WCHAR szBuffer[], const WCHAR szFormatString[], va_list ap) throw ();
extern void VSetDialogFont(HWND hwnd, UINT rguiControls[], ULONG iCount) throw ();
extern HRESULT HrCenterWindow( HWND hwndChild, HWND hwndParent ) throw ();
extern HWND HwndGetCurrentDialog() throw ();
extern HRESULT HrPumpMessages(bool fReturnWhenQueueEmpty) throw ();

extern HRESULT HrGetFileVersionNumber(LPCWSTR szFilename, DWORD &rdwMSVersion, DWORD &rdwLSVersion, bool &rfSelfRegistering, bool &rfIsEXE, bool &rfIsDLL) throw ();

extern HRESULT HrGetFileDateAndSize(LPCWSTR szFilename, FILETIME &rft, ULARGE_INTEGER &ruliSize) throw ();

extern int ICompareVersions(DWORD dwMSVer1, DWORD dwLSVer1, DWORD dwMSVer2, DWORD dwLSVer2) throw ();
extern HRESULT HrMakeSureDirectoryExists(LPCWSTR szFile) throw ();
extern HRESULT HrPromptForRemoteServer() throw ();
extern HRESULT HrCreateLink(LPCWSTR szShortcutFile, LPCWSTR szLink, LPCWSTR pszDesc, LPCWSTR pszWorkingDir, LPCWSTR pszArguments) throw ();
extern HRESULT HrWriteShortcutEntryToRegistry(LPCWSTR szPifName) throw ();
extern HRESULT HrGetInstallDirRegkey(HKEY &hkeyOut, ULONG cchKeyOut, WCHAR szKeyOut[], ULONG cchSubkeyOut, WCHAR szSubkeyOut[]) throw ();
extern HRESULT HrSplitRegistryLine(LPCWSTR szLine, HKEY &hkey, ULONG cchSubkey, WCHAR szKey[], ULONG cchValueName, WCHAR szValueName[], ULONG cchValue, WCHAR szValue[]) throw ();
extern HRESULT HrGetStartMenuDirectory(ULONG cchBuffer, WCHAR szOut[]) throw ();
extern HRESULT HrGetShortcutEntryToRegistry(ULONG cchPifName, WCHAR szPifName[]) throw ();
extern HRESULT HrDeleteShortcut() throw ();
extern HRESULT HrCopyFileToSystemDirectory(LPCWSTR fileToCopy, bool fSilent, bool &rfAlreadyExisted) throw ();
extern HRESULT HrWaitForProcess(HANDLE handle);

extern HRESULT HrAddWellKnownDirectoriesToStringTable() throw ();

extern HRESULT HrGetInstallDir() throw (); // contrary to its name, it just makes sure that the installation dir
									// is in the string table

extern HRESULT HrDeleteFilesFromInstalledDirs() throw ();
extern HRESULT HrChangeFileRefCount(LPCWSTR szFilename, int iDelta) throw ();

extern HRESULT HrPostRebootInstall(HINSTANCE hInstance, HINSTANCE hInstancePrev, int nCmdShow) throw ();
extern HRESULT HrPostRebootUninstall(HINSTANCE hInstance, HINSTANCE hInstancePrev, int nCmdShow) throw ();

extern HRESULT HrWriteFormatted(HANDLE hFile, LPCWSTR szFormatString, ...) throw ();
extern HRESULT HrReadLine(LPCWSTR &rpsz, ULONG cchName, WCHAR szName[], ULONG cchValue, WCHAR szValue[]) throw ();

extern void VTrimDirectoryPath(LPCWSTR szPathIn, ULONG cchPathOut, WCHAR szPathOut[]) throw ();

enum ActionType
{
	eActionInstall,
	eActionPostRebootInstall,
	eActionUninstall,
	eActionPostRebootUninstall,
	eActionWaitForProcess
};

enum UpdateFileResults
{
	eUpdateFileResultKeep,
	eUpdateFileResultKeepAll,
	eUpdateFileResultReplace,
	eUpdateFileResultReplaceAll,
	eUpdateFileResultCancel,
};

extern HRESULT HrPromptUpdateFile(
		LPCSTR pszTitleKey, LPCSTR pszMessageKey, LPCOLESTR pszFile,
		DWORD dwExistingVersionMajor, DWORD dwExistingVersionMinor, ULARGE_INTEGER uliExistingSize,
			FILETIME ftExistingTime,
		DWORD dwInstallerVersionMajor, DWORD dwInstallerVersionMinor, ULARGE_INTEGER uliInstallerSize,
			FILETIME ftInstallerTime,
		UpdateFileResults &rufr) throw ();


//return codes from the "Yes-YesToAll-No-NoToAll-Cancel" message box
#define MSINFHLP_YNA_CANCEL		0x00000000
#define MSINFHLP_YNA_YES		0x00000001
#define MSINFHLP_YNA_YESTOALL	0x00000002
#define MSINFHLP_YNA_NO			0x00000004
#define MSINFHLP_YNA_NOTOALL	0x00000008

#pragma data_seg(".data")

#define DEFINE_DAT_STRING(x) extern const CHAR __declspec(selectany) __declspec(allocate(".data")) ach ## x[] = "ach" #x;

DEFINE_DAT_STRING(AlwaysPromptForRemoteServer)
DEFINE_DAT_STRING(AppName)
DEFINE_DAT_STRING(AppOrganization)
DEFINE_DAT_STRING(Browse)
DEFINE_DAT_STRING(CANCEL)
DEFINE_DAT_STRING(Close)
DEFINE_DAT_STRING(Continue)
DEFINE_DAT_STRING(CreateAppDir)
DEFINE_DAT_STRING(DateTemplate)
DEFINE_DAT_STRING(DCOM1)
DEFINE_DAT_STRING(DCOM2)
DEFINE_DAT_STRING(DCOM3)
DEFINE_DAT_STRING(DefaultInstallDir)
DEFINE_DAT_STRING(End1)
DEFINE_DAT_STRING(End2)
DEFINE_DAT_STRING(End3)
DEFINE_DAT_STRING(ErrorCreatingDialog)
DEFINE_DAT_STRING(ErrorCreatingShortcut)
DEFINE_DAT_STRING(ErrorDiskFull)
DEFINE_DAT_STRING(ErrorInstallingCabinet)
DEFINE_DAT_STRING(ErrorInstallingDCOMComponents)
DEFINE_DAT_STRING(ErrorOneAtATime)
DEFINE_DAT_STRING(ErrorNeedRegistryPermissions)
DEFINE_DAT_STRING(ErrorProcessingDialog)
DEFINE_DAT_STRING(ErrorRebootingSystem)
DEFINE_DAT_STRING(ErrorRunningEXE)
DEFINE_DAT_STRING(ErrorRunningEXEAfterInstallation)
DEFINE_DAT_STRING(ErrorUninstallTitle)
DEFINE_DAT_STRING(ErrorUpdateIE)
DEFINE_DAT_STRING(ErrorVJUnregister)
DEFINE_DAT_STRING(ExesToRun1)
DEFINE_DAT_STRING(ExesToRun2)
DEFINE_DAT_STRING(ExitSetup)
DEFINE_DAT_STRING(FileMoveBusyRetry)
DEFINE_DAT_STRING(FileSizeTemplate)
DEFINE_DAT_STRING(InstallEndPromptError)
DEFINE_DAT_STRING(InstallEndPromptErrorTitle)
DEFINE_DAT_STRING(InstallPhaseCreatingRegistryKeys)
DEFINE_DAT_STRING(InstallPhaseDeletingTemporaryFiles)
DEFINE_DAT_STRING(InstallPhaseMovingFilesToDestinationDirectories)
DEFINE_DAT_STRING(InstallPhaseRegisteringDCOMComponents)
DEFINE_DAT_STRING(InstallPhaseRegisteringJavaComponents)
DEFINE_DAT_STRING(InstallPhaseRegisteringSelfRegisteringFiles)
DEFINE_DAT_STRING(InstallPhaseRenamingFilesInDestinationDirectories)
DEFINE_DAT_STRING(InstallPhaseScanForDiskSpace)
DEFINE_DAT_STRING(InstallPhaseScanForInstalledComponents)
DEFINE_DAT_STRING(InstallPhaseUpdatingFileReferenceCounts)
DEFINE_DAT_STRING(InstallSelectDir)
DEFINE_DAT_STRING(InstallSureAboutCancel)
DEFINE_DAT_STRING(InstallTitle)
DEFINE_DAT_STRING(InstallTo1)
DEFINE_DAT_STRING(InstallTo2)
DEFINE_DAT_STRING(InstallTo3)
DEFINE_DAT_STRING(InvalidMachineName)
DEFINE_DAT_STRING(Keep)
DEFINE_DAT_STRING(KeepAll)
DEFINE_DAT_STRING(Next)
DEFINE_DAT_STRING(NO)
DEFINE_DAT_STRING(NotFullPath)
DEFINE_DAT_STRING(NOTOALL)
DEFINE_DAT_STRING(OK)
DEFINE_DAT_STRING(Progress1)
DEFINE_DAT_STRING(Progress2)
DEFINE_DAT_STRING(Progress3)
DEFINE_DAT_STRING(Reboot)
DEFINE_DAT_STRING(RebootNoMsg)
DEFINE_DAT_STRING(ReinstallPrompt)
DEFINE_DAT_STRING(RemoteServer)
DEFINE_DAT_STRING(RemoteServerPrompt)
DEFINE_DAT_STRING(RemovePrompt)
DEFINE_DAT_STRING(Replace)
DEFINE_DAT_STRING(ReplaceAll)
DEFINE_DAT_STRING(RerunSetup)
DEFINE_DAT_STRING(StartArgument)
DEFINE_DAT_STRING(StartEXE)
DEFINE_DAT_STRING(StartName)
DEFINE_DAT_STRING(UninstallEnd1)
DEFINE_DAT_STRING(UninstallEnd2)
DEFINE_DAT_STRING(UninstallEnd3)
DEFINE_DAT_STRING(UninstallEndPromptError)
DEFINE_DAT_STRING(UninstallEndPromptErrorTitle)
DEFINE_DAT_STRING(UninstallProgress1)
DEFINE_DAT_STRING(UninstallProgress2)
DEFINE_DAT_STRING(UninstallProgress3)
DEFINE_DAT_STRING(UninstallReboot)
DEFINE_DAT_STRING(UninstallRebootNoMsg)
DEFINE_DAT_STRING(UninstallSureAboutCancel)
DEFINE_DAT_STRING(UninstallTitle)
DEFINE_DAT_STRING(UninstallWelcome1)
DEFINE_DAT_STRING(UninstallWelcome2)
DEFINE_DAT_STRING(UninstallWelcome3)
DEFINE_DAT_STRING(UninstallWelcome4)
DEFINE_DAT_STRING(UpdateExistingFileLabel)
DEFINE_DAT_STRING(UpdateFile)
DEFINE_DAT_STRING(UpdateInstallingFileLabel)
DEFINE_DAT_STRING(UpdatePrompt)
DEFINE_DAT_STRING(UpdateQuery)
DEFINE_DAT_STRING(Welcome1)
DEFINE_DAT_STRING(Welcome2)
DEFINE_DAT_STRING(Welcome3)
DEFINE_DAT_STRING(Welcome4)
DEFINE_DAT_STRING(WindowsClassName)
DEFINE_DAT_STRING(YES)
DEFINE_DAT_STRING(YESTOALL)

extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achDllCount[] = "[DllCount]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achInstallEXEsToRun[] = "[InstallEXEsToRun]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achDCOMComponentsToRun[] = "[DCOMComponentsToRun]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achUninstallEXEsToRun[] = "[UninstallEXEsToRun]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achStrings[] = "[Strings]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achFiles[] = "[FileEntries]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achUninstallFiles[] = "[UninstallFileEntries]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achAddReg[] = "[AddRegistryEntries]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achDelReg[] = "[DelRegistryEntries]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achRegisterOCX[] = "[RegisterOCX]";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achSMWinDir[] = "<windir>";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achSMSysDir[] = "<sysdir>";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achSMAppDir[] = "<appdir>";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achSMieDir[] = "<iedir>";
extern const CHAR __declspec(selectany) __declspec(allocate(".data")) achProgramFilesDir[] = "<programfilesdir>";

class KList
{
	public:
		KList();
		~KList();
		ULONG GetCount() { return m_cElements; };
		bool FetchAt(ULONG i, ULONG cchBuffer, WCHAR szBuffer[]);
		bool FetchAt(ULONG i, ULONG cchKeyBuffer, WCHAR szKey[], ULONG cchValueBuffer, WCHAR szValue[]);
		bool DeleteAt(ULONG i);
		HRESULT HrAppend(LPCWSTR pszStart, LPCWSTR pszOneAfterLast = NULL);
		void MakeEmpty();

		HRESULT HrInsert(LPCOLESTR key, LPCOLESTR value);
		HRESULT HrInsert(LPCSTR aszKey, LPCOLESTR szValue);
		bool Contains(LPCOLESTR key);
		bool DeleteKey(LPCOLESTR key);
		bool DeleteKey(LPCSTR aszKey);
		bool Access(LPCWSTR wszKey, ULONG cchBuffer, WCHAR szOut[]);
		bool Access(LPCSTR aszKey, ULONG cchBuffer, WCHAR szBuffer[]);

		//define linked list structure for internal use
		struct KListNode
		{
			LPOLESTR key;
			LPOLESTR value;
			struct KListNode *next;
		};

		typedef struct KListNode NODE;
		typedef struct KListNode *PNODE;

	private:
		ULONG m_cElements;
		PNODE m_pNode;
};

extern HINSTANCE g_hInst;
extern HWND g_hwndHidden;

extern HWND g_hwndProgress; // current progress hwnd
extern HWND g_hwndProgressItem; // current static text to hold progress data
extern HWND g_hwndProgressLabel;

extern bool g_fHiddenWindowIsUnicode;
extern CWorkItemList *g_pwil;

extern ActionType g_Action;

extern bool g_fIsNT;
extern bool g_fStopProcess;
extern bool g_fInstallUpdateAll;
extern bool g_fInstallKeepAll;
extern bool g_fSilent;
extern bool g_fReinstall;
extern bool g_fRebootRequired;
extern bool g_fRebooted;
extern bool g_fUninstallKeepAllSharedFiles;
extern bool g_fUninstallDeleteAllSharedFiles;
extern bool g_fDeleteMe;

extern WCHAR g_wszDatFile[MSINFHLP_MAX_PATH];		// name of msinfhlp.dat
extern WCHAR g_wszDCOMServerName[_MAX_PATH];
extern WCHAR g_wszApplicationName[_MAX_PATH];
extern WCHAR g_wszThisExe[_MAX_PATH];

extern ULONG g_iNextTemporaryFileIndex;

extern HRESULT g_hrFinishStatus;

//wrapper class for the progress dialog
class KActiveProgressDlg
{
public:
	KActiveProgressDlg()
	{
		m_iCurrentListItem = -1;
		m_iMaxListItem = 0; 
		m_iCurrentStatus = -1;
		m_iMaxStatus = 0;
		m_hWnd = NULL; 
		m_fOperationFailed = false;
	}

	HRESULT HrDestroy()
	{ 
		HRESULT hr = NOERROR;

		for (int i=0; i<m_iMaxPage; i++)
		{
			if (!::DestroyWindow(m_hwndDialog[i]))
			{
				const DWORD dwLastError = ::GetLastError();
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			m_hwndDialog[i] = NULL;
		}

		m_hWnd = NULL;
		m_hMod = NULL;

	Finish:
		return hr;
	}

	HRESULT HrInitializeActiveProgressDialog(HINSTANCE hInst, bool fInstall);

	//methods for setting and getting  member variables
	void VSetModule(HMODULE hmod) { m_hMod = hmod; }
	void VSetHandle(HWND hwnd) { m_hWnd = hwnd; }

	void VOperationFailed() { m_fOperationFailed = true; }
	bool FDidOperationFail() { return m_fOperationFailed; }

	bool FCheckStop();
	HWND HwndGetHandle() { if (m_hwndDialog[m_iCurrentPage]) return m_hwndDialog[m_iCurrentPage]; else return g_hwndHidden;}
	HMODULE HmoduleGetModule() { return m_hMod; }
	void VSetUnselected(int iUnselected) { m_iUnselectedOutputStateImageIndex = iUnselected; }
	void VSetSelected(int iSelected) { m_iSelectedOutputStateImageIndex = iSelected; }
	void VSetX(int iX) { m_iXOutputStateImageIndex = iX; }
	void VSetCurrent(int iCurrent) { m_iCurrentOutputStateImageIndex = iCurrent; }
	int IGetUnselected() { return m_iUnselectedOutputStateImageIndex; }
	int IGetSelected() { return m_iSelectedOutputStateImageIndex; }
	int IGetX() { return m_iXOutputStateImageIndex; }
	int IGetCurrent() { return m_iCurrentOutputStateImageIndex; }

	HRESULT HrResizeParent();

	//methods for stepping through the different (un)installation steps
	HRESULT HrInitializePhase(LPCSTR szPhaseNameKey);
	HRESULT HrStep();	//steps the progress bar
	HRESULT HrStartStep(LPCWSTR szItemName);

	void VHideInstallationStuff();
	void VShowInstallationStuff();
	void VEnableChildren(BOOL fEnable);

	LONG m_lX, m_lY;
	BOOL m_fInstall;
	bool m_fOperationFailed;
	WORD m_wCount;
	HWND m_hWnd;
	HMODULE m_hMod;
	int m_iUnselectedOutputStateImageIndex;
	int m_iSelectedOutputStateImageIndex;
	int m_iXOutputStateImageIndex;
	int m_iCurrentOutputStateImageIndex;

	int m_iMaxStatus;
	int m_iCurrentStatus;	//index as to which installation step we're at
	int m_iCurrentListItem;
	int m_iMaxListItem;


	int m_iCurrentPage;		//the current page that we're on
	int m_iMaxPage;			//the max number of pages that we can handle
	int m_listDialog[6];	//the list of pages in the dialog
	HWND m_hwndDialog[6];	//the list of handles associated with each dialog

};


extern KActiveProgressDlg g_KProgress;	//global instance of the progress dialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\utils.cpp ===
#include "stdinc.h"

static BOOL CALLBACK MsgBoxYesNoAllProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void CanonicalizeFilename(ULONG cchFilenameBuffer, LPWSTR szFilename);

typedef struct _MESSAGEBOXPARAMS {
	LPOLESTR szTitle;
	LPOLESTR szMessage;
	DWORD dwReturn;
} MESSAGEBOXPARAMS, *PMESSAGEBOXPARAMS;


static WCHAR s_wszErrorContext[MSINFHLP_MAX_PATH];

void VClearErrorContext()
{
	s_wszErrorContext[0] = L'\0';
}

void VSetErrorContextVa(LPCSTR szKey, va_list ap)
{
	WCHAR szFormatString[_MAX_PATH];
	g_pwil->VLookupString(szKey, NUMBER_OF(szFormatString), szFormatString);
	::VFormatStringVa(NUMBER_OF(s_wszErrorContext), s_wszErrorContext, szFormatString, ap);
}

void VSetErrorContext(LPCSTR szKey, LPCWSTR szParam0, ...)
{
	va_list ap;
	va_start(ap, szKey);
	::VSetErrorContextVa(szKey, ap);
	va_end(ap);
}

void VErrorMsg(LPCSTR szTitleKey, LPCSTR szMessageKey, ...)
{
	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szFormatString[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];

	g_pwil->VLookupString(szTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(szMessageKey, NUMBER_OF(szFormatString), szFormatString);

	va_list ap;
	va_start(ap, szMessageKey);
	::VFormatStringVa(NUMBER_OF(szMessage), szMessage, szFormatString, ap);
	va_end(ap);

	::VLog(L"Error message: \"%s\"", szMessage);

	if (!g_fSilent)
		NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szMessage, szTitle, MB_OK);
}

void VReportError(LPCSTR szTitleKey, HRESULT hrIn)
{
	if (hrIn == E_ABORT)
	{
		::VLog(L"Not displaying error for E_ABORT");
		return;
	}

	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	if (s_wszErrorContext[0] == L'\0')
		::VFormatError(NUMBER_OF(szBuffer), szBuffer, hrIn);
	else
	{
		WCHAR szBuffer2[MSINFHLP_MAX_PATH];
		::VFormatError(NUMBER_OF(szBuffer2), szBuffer2, hrIn);
		::VFormatString(NUMBER_OF(szBuffer), szBuffer, L"%0\n\n%1", s_wszErrorContext, szBuffer2);
	}

	WCHAR szCaption[MSINFHLP_MAX_PATH];

	if (g_pwil != NULL)
		g_pwil->VLookupString(szTitleKey, NUMBER_OF(szCaption), szCaption);
	else
		lstrcpyW(szCaption, L"Installer Run-Time Error");

	::VLog(L"Run-time error: \"%s\"", szBuffer);

	if (!g_fSilent)
		NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szBuffer, szCaption, MB_OK | MB_ICONERROR);
}

void VFormatError(ULONG cchBuffer, LPWSTR szBuffer, HRESULT hrIn)
{
	assert(cchBuffer > 1);

	if (cchBuffer == 0)
		return;

	szBuffer[0] = L'\0';
	if (hrIn == E_ABORT)
	{
		wcsncpy(szBuffer, L"User-requested abort", cchBuffer);
		szBuffer[cchBuffer - 1] = L'\0';
		return;
	}

	HRESULT hr;
	IErrorInfo *pIErrorInfo = NULL;

	::GetErrorInfo(0, &pIErrorInfo);

	BSTR bstrDescription = NULL;

	if (pIErrorInfo != NULL)
		hr = pIErrorInfo->GetDescription(&bstrDescription);

	if (bstrDescription != NULL)
	{
		wcsncpy(szBuffer, bstrDescription, cchBuffer);
		szBuffer[cchBuffer - 1] = L'\0';
	}
	else if (HRESULT_FACILITY(hrIn) == FACILITY_WIN32)
	{
		LPWSTR szFormattedMessage = NULL;

		DWORD dwResult = NVsWin32::FormatMessageW(
							FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
							0, // lpSource
							(hrIn & 0x0000ffff),
							::GetUserDefaultLCID(),
							(LPWSTR) &szFormattedMessage,
							0,
							NULL);

		if (0 != dwResult)
		{
			wcsncpy(szBuffer, szFormattedMessage, cchBuffer);
			szBuffer[cchBuffer - 1] = L'\0';
		}

		if (NULL != szFormattedMessage)
			::LocalFree(szFormattedMessage);
	}
	else
	{
		switch (hrIn)
		{
		default:
			if (bstrDescription != NULL)
			{
				wcsncpy(szBuffer, bstrDescription, cchBuffer);
				szBuffer[cchBuffer - 1] = L'\0';
			}
			else
			{
				CHAR szKey[1024];
				wsprintfA(szKey, "achHRESULT_0x%08lx", hrIn);
				if (!g_pwil->FLookupString(szKey, cchBuffer, szBuffer))
					wsprintfW(szBuffer, L"Untranslatable HRESULT: 0x%08lx", hrIn);
			}

			break;

		case E_OUTOFMEMORY:
			wcsncpy(szBuffer, L"Application is out of memory; try increating the size of your pagefile", cchBuffer);
			szBuffer[cchBuffer - 1] = L'\0';
			break;

		case E_FAIL:
			wcsncpy(szBuffer, L"Unspecified error (E_FAIL)", cchBuffer);
			szBuffer[cchBuffer - 1] = L'\0';
			break;
		}
	}

	::SetErrorInfo(0, pIErrorInfo);
}

void VMsgBoxOK(LPCSTR szTitleKey, LPCSTR szMessageKey, ...)
{
	assert(!g_fSilent);

	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];
	WCHAR szFormatString[MSINFHLP_MAX_PATH];

	g_pwil->VLookupString(szTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(szMessageKey, NUMBER_OF(szFormatString), szFormatString);

	va_list ap;
	va_start(ap, szMessageKey);
	::VFormatStringVa(NUMBER_OF(szMessage), szMessage, szFormatString, ap);
	va_end(ap);

	NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szMessage, szTitle, MB_OK);
}

//display a message box with YesNo buttons, given the ID for the title and message content.
bool FMsgBoxYesNo(LPCSTR szTitleKey, LPCSTR achMessage, ...)
{
	assert(!g_fSilent);

	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];
	WCHAR szFormattedMessage[MSINFHLP_MAX_PATH];

	g_pwil->VLookupString(szTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(achMessage, NUMBER_OF(szMessage), szMessage);

	va_list ap;
	va_start(ap, achMessage);

	::VFormatStringVa(NUMBER_OF(szFormattedMessage), szFormattedMessage, szMessage, ap);

	va_end(ap);

	return (NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szFormattedMessage, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES);
}

int IMsgBoxYesNoCancel(LPCSTR szTitleKey, LPCSTR achMessage, ...)
{
	assert(!g_fSilent);

	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];
	WCHAR szFormattedMessage[MSINFHLP_MAX_PATH];

	g_pwil->VLookupString(szTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(achMessage, NUMBER_OF(szMessage), szMessage);

	va_list ap;
	va_start(ap, achMessage);
	::VFormatStringVa(NUMBER_OF(szFormattedMessage), szFormattedMessage, szMessage, ap);
	va_end(ap);

	return NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szFormattedMessage, szTitle, MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2);
}



//checks the version of the operating system & sets a global bit to tell
//if we're running on NT or Win95
bool FCheckOSVersion()
{
	OSVERSIONINFO verinfo;

	verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&verinfo) == FALSE)
		return false;

	if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		g_fIsNT = true;
	else
		g_fIsNT = false;

	return true;
}

DWORD DwMsgBoxYesNoAll(LPCSTR szTitleKey, LPCSTR szMessageKey, ...)
{
	assert(!g_fSilent);

	WCHAR szTitle[MSINFHLP_MAX_PATH];
	WCHAR szMessage[MSINFHLP_MAX_PATH];
	WCHAR szFullMessage[MSINFHLP_MAX_PATH];
	WCHAR szFormatString[MSINFHLP_MAX_PATH];

	//if they're not in the list, use what's provided
	g_pwil->VLookupString(szTitleKey, NUMBER_OF(szTitle), szTitle);
	g_pwil->VLookupString(szMessageKey, NUMBER_OF(szFormatString), szFormatString);

	va_list ap;
	va_start(ap, szMessageKey);
	::VFormatStringVa(NUMBER_OF(szMessage), szMessage, szFormatString, ap);
	va_end(ap);

	//let's create the message box & populate it with what's gonna go into the box
	MESSAGEBOXPARAMS messageBoxParams;
	messageBoxParams.szTitle = szTitle;
	messageBoxParams.szMessage = szMessage;
	messageBoxParams.dwReturn = 0;

	//bring up dialog
	int iResult = NVsWin32::DialogBoxParamW(
							g_hInst,
							MAKEINTRESOURCEW(IDD_YESNOALL),
							::HwndGetCurrentDialog(),
							&MsgBoxYesNoAllProc,
							(LPARAM) &messageBoxParams);

	if (iResult == -1)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to create YesNoAll message box; last error = %d", dwLastError);
		iResult = MSINFHLP_YNA_CANCEL;
	}

	return (DWORD) iResult;
}

//TODO:  UNDONE:
//We might need to do a setfonts here to correspond to whatever fonts that we're
//using in the current install machine.  This allows the characters to display
//correctly in the edit box.
BOOL CALLBACK MsgBoxYesNoAllProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	assert(!g_fSilent);

	static UINT rguiControls[] =
	{
		IDC_YNA_YES,
		IDC_YNA_YESTOALL,
		IDC_YNA_NO,
		IDC_YNA_NOTOALL,
		IDC_YNA_CANCEL,
		IDC_YNA_MESSAGE
	};

	//process the message
	switch (uMsg) 
	{
		//************************************
		//initialize dialog
		case WM_INITDIALOG:
		{
			::VSetDialogFont(hwndDlg, rguiControls, NUMBER_OF(rguiControls));

			MESSAGEBOXPARAMS *messageBoxParams = (MESSAGEBOXPARAMS *) lParam;

			(void) ::HrCenterWindow(hwndDlg, ::GetDesktopWindow());
			NVsWin32::SetWindowTextW(hwndDlg, messageBoxParams->szTitle);

			//cannot set text, we complain and end the dialog returning FALSE
			if (!NVsWin32::SetDlgItemTextW( hwndDlg, IDC_YNA_MESSAGE, messageBoxParams->szMessage))
			{
				::VErrorMsg(achInstallTitle, achErrorCreatingDialog);
				::EndDialog(hwndDlg, FALSE);
			}
			else
			{
				static const DialogItemToStringKeyMapEntry s_rgMap[] =
				{
					{ IDC_YNA_YES, achYES },
					{ IDC_YNA_YESTOALL, achYESTOALL },
					{ IDC_YNA_NO, achNO },
					{ IDC_YNA_NOTOALL, achNOTOALL },
					{ IDC_YNA_CANCEL, achCANCEL },
				};

				::VSetDialogItemTextList(hwndDlg, NUMBER_OF(s_rgMap), s_rgMap);
			}

			return TRUE;
		}

		//*************************************
		//close message
		case WM_CLOSE:
		{
			::EndDialog(hwndDlg, MSINFHLP_YNA_CANCEL);
			return TRUE;
		}

		//*************************************
		//process control-related commands
		case WM_COMMAND:
		{
			static struct
			{
				UINT m_uiID;
				DWORD m_dwReturn;
			} s_rgMap[] =
			{
				{ IDC_YNA_YES, MSINFHLP_YNA_YES },
				{ IDC_YNA_YESTOALL, MSINFHLP_YNA_YESTOALL },
				{ IDC_YNA_NO, MSINFHLP_YNA_NO },
				{ IDC_YNA_NOTOALL, MSINFHLP_YNA_NOTOALL },
				{ IDC_YNA_CANCEL, MSINFHLP_YNA_CANCEL }
			};

			DWORD dwReturn = MSINFHLP_YNA_CANCEL;
			for (ULONG i=0; i<NUMBER_OF(s_rgMap); i++)
			{
				if (s_rgMap[i].m_uiID == wParam)
				{
					dwReturn = s_rgMap[i].m_dwReturn;
					break;
				}
			}
			::EndDialog(hwndDlg, dwReturn);
			return TRUE;
		}

		return TRUE;
	}

	return FALSE;
}

void VSetDialogItemText(HWND hwndDlg, UINT uiControlID, LPCSTR szKey, ...)
{
	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	WCHAR szFormatted[MSINFHLP_MAX_PATH];

	if (szKey != NULL)
	{
		g_pwil->VLookupString(szKey, NUMBER_OF(szBuffer), szBuffer);

		va_list ap;
		va_start(ap, szKey);
		::VFormatStringVa(NUMBER_OF(szFormatted), szFormatted, szBuffer, ap);
		va_end(ap);
	}
	else
		szFormatted[0] = L'\0';

	NVsWin32::SetDlgItemTextW(hwndDlg, uiControlID, szFormatted);
}

wchar_t *wcsstr(const wchar_t *pwszString, const char *pszSubstring)
{
	WCHAR szTemp[MSINFHLP_MAX_PATH];
	ULONG cchSubstring = strlen(pszSubstring);
	for (ULONG i=0; i<cchSubstring; i++)
		szTemp[i] = (wchar_t) pszSubstring[i];
	szTemp[i] = L'\0';
	return wcsstr(pwszString, szTemp);
}

wchar_t *wcscpy(wchar_t *pwszString, const char *pszSource)
{
	::MultiByteToWideChar(CP_ACP, 0, pszSource, -1, pwszString, 65535);
	return pwszString;
}

void VFormatString(ULONG cchBuffer, WCHAR szBuffer[], const WCHAR szFormatString[], ...)
{
	va_list ap;
	va_start(ap, szFormatString);
	::VFormatStringVa(cchBuffer, szBuffer, szFormatString, ap);
	va_end(ap);
}

void VFormatStringVa(ULONG cchBuffer, WCHAR szBuffer[], const WCHAR szFormatString[], va_list ap)
{
	LPCWSTR rgpszArguments[10] =
	{
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL
	};

	if (cchBuffer < 2)
	{
		::VLog(L"VFormatStringVa() called with rediculously small buffer: %u bytes", cchBuffer);
		return;
	}

	ULONG cArgsSeen = 0;
	LPCWSTR pwchCurrentInputChar = szFormatString;
	LPWSTR pwchCurrentOutputChar = szBuffer;
	WCHAR wch;

	while ((wch = *pwchCurrentInputChar++) != L'\0')
	{
		if (wch == L'%')
		{
			wch = *pwchCurrentInputChar++;

			if ((wch >= L'0') && (wch <= L'9'))
			{
				ULONG iArg = wch - L'0';

				while (iArg >= cArgsSeen)
					rgpszArguments[cArgsSeen++] = va_arg(ap, LPCWSTR);

				LPCWSTR pszTemp = rgpszArguments[iArg];

				if ((pszTemp != NULL) && !::IsBadStringPtrW(pszTemp, cchBuffer))
				{
					while ((wch = *pszTemp++) != L'\0')
					{
						*pwchCurrentOutputChar++ = wch;
						cchBuffer--;
						if (cchBuffer < 2)
							break;
					}
				}
			}
			else
			{
				*pwchCurrentOutputChar++ = L'%';
				cchBuffer--;

				if (cchBuffer < 2)
					break;

				if (wch == L'\0')
					break;

				*pwchCurrentOutputChar++ = wch;
				cchBuffer--;

				if (cchBuffer < 2)
					break;
			}
		}
		else if (wch == L'\\')
		{
			wch = *pwchCurrentInputChar++;

			switch (wch)
			{
			case L'n':
				wch = L'\n';
				break;

			case L'\\': // no need to assign anything; wch already has the right value
				break;

			default:
				pwchCurrentInputChar--;
				wch = L'\\';
				break;
			}

			*pwchCurrentOutputChar++ = wch;
			cchBuffer--;

			if (cchBuffer < 2)
				break;
		}
		else
		{
			*pwchCurrentOutputChar++ = wch;
			cchBuffer--;

			if (cchBuffer < 2)
				break;
		}
	}

	*pwchCurrentOutputChar = L'\0';
}

HRESULT HrPumpMessages(bool fReturnWhenAllMessagesPumped)
{
	HRESULT hr = NOERROR;
	MSG msg;
	// Main message loop:
	BOOL fIsUnicode;
	BOOL fContinue = TRUE;

	for (;;)
	{
		while (::PeekMessageA(&msg, NULL, 0, 0, PM_NOREMOVE))
		{
			if (msg.message == WM_QUIT)
			{
				::VLog(L"Quit message found in queue; status: 0x%08lx", g_hrFinishStatus);
				g_fStopProcess = true;
				hr = g_hrFinishStatus;
				goto Finish;
			}

			if (msg.message == WM_ENDSESSION)
			{
				::VLog(L"Terminating message pump because the windows session is ending; wParam = 0x%08lx; lParam = 0x%08lx", msg.wParam, msg.lParam);
				g_fStopProcess = true;
				hr = E_ABORT;
				goto Finish;
			}

			if (::IsWindowUnicode(msg.hwnd))
			{
				fIsUnicode = TRUE;
				fContinue = ::GetMessageW(&msg, NULL, 0, 0);
			}
			else
			{
				fIsUnicode = FALSE;
				fContinue = ::GetMessageA(&msg, NULL, 0, 0);
			}

			if (!fContinue)
			{
				::VLog(L"Terminating message pump because ::GetMessage() returned 0x%08lx", fContinue);
				break;
			}

			HWND hwndDialogCurrent = ::HwndGetCurrentDialog();

			bool fHandledMessage = false;

			if (hwndDialogCurrent != NULL)
			{
				if (::IsWindowUnicode(hwndDialogCurrent))
					fHandledMessage = (::IsDialogMessageW(hwndDialogCurrent, &msg) != 0);
				else
					fHandledMessage = (::IsDialogMessageA(hwndDialogCurrent, &msg) != 0);
			}

			if (!fHandledMessage && g_hwndHidden != NULL)
			{
				if (g_fHiddenWindowIsUnicode)
					fHandledMessage = (::IsDialogMessageW(g_hwndHidden, &msg) != 0);
				else
					fHandledMessage = (::IsDialogMessageA(g_hwndHidden, &msg) != 0);
			}

			if (!fHandledMessage)
			{
				::TranslateMessage(&msg);

				if (fIsUnicode)
					::DispatchMessageW(&msg);
				else
					::DispatchMessageA(&msg);
			}
		}

		if (fReturnWhenAllMessagesPumped)
			break;

		// We're here for the long run...
		::WaitMessage();
	}

Finish:
	return hr;
}

HRESULT HrGetFileVersionNumber
(
LPCWSTR szFilename,
DWORD &rdwMSVer,
DWORD &rdwLSVer,
bool &rfSelfRegistering,
bool &rfIsEXE,
bool &rfIsDLL
)
{
	HRESULT hr = NOERROR;
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    LPVOID      lpVerBuffer;
    WCHAR       szNewName[_MAX_PATH];
    BOOL        bToCleanup = FALSE;
	BYTE rgbVersionInfoAuto[MSINFHLP_MAX_PATH];
	BYTE *prgbVersionInfo = rgbVersionInfoAuto;
	BYTE *prgbVersionInfoDynamic = NULL;

    rdwMSVer = 0xffffffff;
	rdwLSVer = 0xffffffff;
	rfIsEXE = false;
	rfIsDLL = false;

    wcscpy(szNewName, szFilename);

    dwVerInfoSize = NVsWin32::GetFileVersionInfoSizeW(const_cast<LPWSTR>(szFilename), &dwHandle);

	if (dwVerInfoSize == 0)
	{
		const DWORD dwLastError = ::GetLastError();

		// If the file was in use, we can make a temporary copy of it and use that.  Otherwise, there
		// might be a really good reason we can't get version information, such as it doesn't
		// have any!

		if (dwLastError == ERROR_SHARING_VIOLATION)
		{
			WCHAR szPath[MSINFHLP_MAX_PATH];
			// due to version.dll bug, file in extended character path will failed version.dll apis.
			// So we copy it to a normal path and get its version info from there then clean it up.
			if (!NVsWin32::GetWindowsDirectoryW( szPath, NUMBER_OF(szPath)))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Error getting windows directory; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!NVsWin32::GetTempFileNameW(szPath, L"_&_", 0, szNewName))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Error getting temp file name; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!NVsWin32::CopyFileW(szFilename, szNewName, FALSE))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Error copying file; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			bToCleanup = TRUE;

			dwVerInfoSize = NVsWin32::GetFileVersionInfoSizeW( szNewName, &dwHandle );
		}
	}

    if (dwVerInfoSize != 0)
    {
		if (dwVerInfoSize > sizeof(rgbVersionInfoAuto))
		{
			prgbVersionInfoDynamic = (LPBYTE) ::GlobalAlloc(GPTR, dwVerInfoSize);
			if (prgbVersionInfoDynamic == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Finish;
			}

			prgbVersionInfo = prgbVersionInfoDynamic;
		}

		// Read version stamping info
        if (NVsWin32::GetFileVersionInfoW(szNewName, dwHandle, dwVerInfoSize, prgbVersionInfo))
        {
            // Get the value for Translation
            if (NVsWin32::VerQueryValueW(prgbVersionInfo, L"\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                             (uiSize != 0))
            {
                rdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                rdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;

				if (lpVSFixedFileInfo->dwFileType == VFT_APP)
					rfIsEXE = true;
				else if (lpVSFixedFileInfo->dwFileType == VFT_DLL)
					rfIsDLL = true;
            }

			VOID *pvData = NULL;

			// Pick a semi-reasonable default language and codepage DWORD value (namely what
			// happens on my US English machine).
			DWORD dwLanguageAndCodePage = 0x040904b0;

            if (NVsWin32::VerQueryValueW(prgbVersionInfo, L"\\VarFileInfo\\Translation", &pvData, &uiSize) &&
                            (uiSize != 0))
            {
				dwLanguageAndCodePage = HIWORD(*((DWORD *) pvData)) |
									    (LOWORD(*((DWORD *) pvData)) << 16);
            }

			WCHAR szValueName[MSINFHLP_MAX_PATH];
			swprintf(szValueName, L"\\StringFileInfo\\%08lx\\OLESelfRegister", dwLanguageAndCodePage);

			rfSelfRegistering = (NVsWin32::VerQueryValueW(prgbVersionInfo, szValueName, &pvData, &uiSize) != 0);
        }
		else
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Error getting file version information; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
		}
    }
	else
	{
		const DWORD dwLastError = ::GetLastError();

		if ((dwLastError != ERROR_SUCCESS) &&
			(dwLastError != ERROR_BAD_FORMAT) && // win95 returns this on non-win32 pe files
			(dwLastError != ERROR_RESOURCE_DATA_NOT_FOUND) &&
			(dwLastError != ERROR_RESOURCE_TYPE_NOT_FOUND) &&
			(dwLastError != ERROR_RESOURCE_NAME_NOT_FOUND) &&
			(dwLastError != ERROR_RESOURCE_LANG_NOT_FOUND))
		{
			hr = HRESULT_FROM_WIN32(dwLastError);
			::VLog(L"Error getting file version information size; last error = %d", dwLastError);
			goto Finish;
		}
	}

	hr = NOERROR;

Finish:
    if (bToCleanup)
	{
        if (!NVsWin32::DeleteFileW(szNewName))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to delete temporary file \"%s\" (for get version) failed; last error = %d", szNewName, dwLastError);
		}
	}

	if (prgbVersionInfoDynamic != NULL)
		::GlobalFree(prgbVersionInfoDynamic);

	return hr;
}

HRESULT HrGetFileDateAndSize(LPCWSTR szFilename, FILETIME &rft, ULARGE_INTEGER &ruliSize)
{
	HRESULT hr = NOERROR;
	HANDLE hFile = INVALID_HANDLE_VALUE;

	hFile = NVsWin32::CreateFileW(szFilename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		VLog(L"CreateFile() failed trying to get date and size information for: \"%s\"; hr = 0x%08lx", szFilename, hr);
		goto Finish;
	}

	if (!::GetFileTime(hFile, NULL, NULL, &rft))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	BY_HANDLE_FILE_INFORMATION bhfi;
	if (!::GetFileInformationByHandle(hFile, &bhfi))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}
		
	ruliSize.HighPart = bhfi.nFileSizeHigh;
	ruliSize.LowPart = bhfi.nFileSizeLow;

Finish:

	if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
		::CloseHandle(hFile);

	return hr;
}

int ICompareVersions(DWORD dwMSVer1, DWORD dwLSVer1, DWORD dwMSVer2, DWORD dwLSVer2)
{
	int iResult = ((LONG) dwMSVer1) - ((LONG) dwMSVer2);
	if (iResult == 0)
		iResult = ((LONG) dwLSVer1) - ((LONG) dwLSVer2);
	return iResult;
}

HRESULT HrMakeSureDirectoryExists(LPCWSTR szFile)
{
	HRESULT hr = NULL;
	WCHAR drive[_MAX_DRIVE];
	WCHAR dir[_MAX_DIR];
	WCHAR path[_MAX_PATH];
	WCHAR pathRunning[_MAX_PATH];
	LPOLESTR lpLastSlash;
	LPOLESTR lpSlash;
	ULONG cch;

	drive[0] = 0;
	dir[0] = 0;

	_wsplitpath(szFile, drive, dir, NULL, NULL);
	_wmakepath(path, drive, dir, NULL, NULL);

	//get rid of the trailing '\'
	cch = wcslen(path);

	if (cch < 3)
	{
		hr = E_INVALIDARG;
		goto Finish;
	}

	if (path[cch - 1] == L'\\')
		path[cch - 1] = 0;

	//if it's a local path (with drive specified), we get the first back-slash as
	//initialization; if it's a UNC path, we get the second back-slash
	if (path[1] == L':')
		lpLastSlash = wcschr(&path[0], L'\\');
	else
		lpLastSlash = &path[1];

	//loop, ensuring that all the directories exist; if they don't, then create them!!!
	while (lpLastSlash)
	{
		lpSlash = wcschr(lpLastSlash + 1, L'\\');

		//if we ran out of slashes, then we test the entire path
		if (lpSlash == NULL)
			wcscpy(pathRunning, path);
		else
		{
			//else, we test the path up to the slash;
			wcsncpy(pathRunning, path, lpSlash - &path[0]);
			pathRunning[lpSlash - &path[0]] = 0;
		}

		//check if the directory exists, and create it if it doesn't
		if (NVsWin32::GetFileAttributesW(pathRunning) == 0xFFFFFFFF)
		{
			if (!NVsWin32::CreateDirectoryW(pathRunning, NULL))
			{
				const DWORD dwLastError = ::GetLastError();
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		lpLastSlash = lpSlash;
	}

	hr = NOERROR;

Finish:
	return hr;
}


//
//pszShortcutFile == path of shortcut target
//pszLink == name of shortcut file
//pszDesc == description of this link
//pszWorkingDir == working directory
//pszArguments == arguments given to the EXE that we run
//
HRESULT HrCreateLink(LPCWSTR pszShortcutFile, LPCWSTR pszLink, LPCWSTR pszDesc, LPCWSTR pszWorkingDir, LPCWSTR pszArguments)
{
	HRESULT hr = NOERROR;
	IShellLinkA *psl;
	CANSIBuffer rgchShortcutFile, rgchLink, rgchDesc, rgchWorkingDir, rgchArguments;
	IPersistFile *ppf = NULL;

	if (!pszShortcutFile || !pszLink)
	{
		hr = E_INVALIDARG;
		goto Finish;
	}

	if (!rgchShortcutFile.FFromUnicode(pszShortcutFile))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (!rgchLink.FFromUnicode(pszLink))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (!rgchDesc.FFromUnicode(pszDesc))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (!rgchWorkingDir.FFromUnicode(pszWorkingDir))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (rgchWorkingDir[strlen(rgchWorkingDir) - 1] == '\\')
		rgchWorkingDir[strlen(rgchWorkingDir) - 1] = '\0';

	if (!rgchArguments.FFromUnicode(pszArguments))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	// Create an IShellLink object and get a pointer to the IShellLink 
	// interface (returned from CoCreateInstance).
	hr = ::CoCreateInstance (
				CLSID_ShellLink,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IShellLinkA,
				(void **)&psl);
	if (FAILED(hr))
		goto Finish;

	// Query IShellLink for the IPersistFile interface for 
	// saving the shortcut in persistent storage.
	hr = psl->QueryInterface (IID_IPersistFile, (void **) &ppf);
	if (FAILED(hr))
		goto Finish;

	// Set the path to the shortcut target.
	hr = psl->SetPath(rgchShortcutFile);
	if (FAILED(hr))
		goto Finish;

	if (pszDesc != NULL)
	{
		// Set the description of the shortcut.
		hr = psl->SetDescription (rgchDesc);
		if (FAILED(hr))
			goto Finish;
	}

	if (pszWorkingDir != NULL)
	{
		// Set the working directory of the shortcut.
		hr = psl->SetWorkingDirectory (rgchWorkingDir);
		if (FAILED(hr))
			goto Finish;
	}

	// Set the arguments of the shortcut.
	if (pszArguments != NULL)
	{
		hr = psl->SetArguments (rgchArguments);
		if (FAILED(hr))
			goto Finish;
	}

	// Save the shortcut via the IPersistFile::Save member function.
	hr = ppf->Save(pszLink, TRUE);
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	// Release the pointer to IPersistFile.
	if (ppf != NULL)
	{
		ppf->Release();
		ppf = NULL;
	}

	// Release the pointer to IShellLink.
	if (psl != NULL)
	{
		psl->Release();
		psl = NULL;
	}

	return hr;
} 

HRESULT HrWriteShortcutEntryToRegistry(LPCWSTR szPifName)
{
	HRESULT hr = NOERROR;

	CVsRegistryKey hkey;
	CVsRegistryKey hkeyWrite;
	WCHAR szSubkey[MSINFHLP_MAX_PATH];

	hr = ::HrGetInstallDirRegkey(hkey.Access(), NUMBER_OF(szSubkey), szSubkey, 0, NULL);
	if (FAILED(hr))
		goto Finish;

	//open key
	hr = hkeyWrite.HrOpenKeyExW(hkey, szSubkey, 0, KEY_WRITE);
	if (FAILED(hr))
		goto Finish;

	//insert length of created directory list
	hr = hkeyWrite.HrSetValueExW(L"ShortcutFilename", 0, REG_SZ, (LPBYTE)szPifName, (wcslen(szPifName) + 1) * sizeof(WCHAR));
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrGetInstallDirRegkey(HKEY &hkeyOut, ULONG cchSubkeyOut, WCHAR szSubkeyOut[], ULONG cchValueNameOut, WCHAR szValueNameOut[])
{
	HRESULT hr = NOERROR;

	LPOLESTR match;
	HKEY hkey;
	WCHAR szRegistry[MSINFHLP_MAX_PATH];
	WCHAR szSubkey[MSINFHLP_MAX_PATH];
	WCHAR szValueName[MSINFHLP_MAX_PATH];
	szRegistry[0] = 0;
	szSubkey[0] = 0;
	szValueName[0] = 0;

	LPCWSTR pszMatch = NULL;

	CWorkItemIter iter(g_pwil);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fAddToRegistry)
			continue;

		//check if there's a match
		pszMatch = wcsstr(iter->m_szSourceFile, L",InstallDir,");
		if (pszMatch != NULL)
		{
			hr = ::HrSplitRegistryLine(iter->m_szSourceFile, hkey, NUMBER_OF(szSubkey), szSubkey, NUMBER_OF(szValueName), szValueName, 0, NULL);
			if (FAILED(hr))
				goto Finish;

			if (wcscmp(szValueName, L"InstallDir") == 0)
				break;

			pszMatch = NULL;
		}
	}

	//copy to output buffers if we found a match
	if (pszMatch != NULL)
	{
		hkeyOut = hkey;

		if ((szSubkeyOut != NULL) && (cchSubkeyOut != 0))
		{
			wcsncpy(szSubkeyOut, szSubkey, cchSubkeyOut);
			szSubkeyOut[cchSubkeyOut - 1] = L'\0';
		}

		if ((szValueNameOut != NULL) && (cchValueNameOut != 0))
		{
			wcsncpy(szValueNameOut, szValueName, cchValueNameOut);
			szValueNameOut[cchValueNameOut - 1] = L'\0';
		}

		hr = NOERROR;
	}
	else
		hr = S_FALSE;

Finish:
	return hr;
}

HRESULT HrSplitRegistryLine
(
LPCWSTR szLine,
HKEY &hkey,
ULONG cchSubkey,
WCHAR szSubkey[],
ULONG cchValueName,
WCHAR szValueName[],
ULONG cchValue,
WCHAR szValue[]
)
{
	HRESULT hr = NOERROR;

	//these are the 3 comma pointers!!!
	LPWSTR first = NULL;
	LPWSTR second = NULL;
	LPWSTR third = NULL;

	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	wcsncpy(szBuffer, szLine, NUMBER_OF(szBuffer));
	szBuffer[NUMBER_OF(szBuffer) - 1] = L'\0';

	//find the locations of the first 3 commas
	//the first comma is required, but not the second or third
	first = wcschr(szBuffer, L',');
	if (first == NULL)
	{
		hr = E_INVALIDARG;
		goto Finish;
	}

	//get second and third commas if they're available
	second = wcschr((first + 1), L',');
	if (second != NULL)
		third = wcschr((second + 1), L',');

	*first = 0;
	if (second)
		*second = 0;
	if (third)
		*third = 0;

	//let's find which HKEY corresponds to the current
	if (!_wcsicmp(szBuffer, L"HKLM") || !_wcsicmp(szBuffer, L"HKEY_LOCAL_MACHINE"))
		hkey = HKEY_LOCAL_MACHINE;
	else if (!_wcsicmp(szBuffer, L"HKCU") || !_wcsicmp(szBuffer, L"HKEY_CURRENT_USER"))
		hkey = HKEY_CURRENT_USER;
	else if (!_wcsicmp(szBuffer, L"HKCR") || !_wcsicmp(szBuffer, L"HKEY_CLASSES_ROOT"))
		hkey = HKEY_CLASSES_ROOT;
	else if (!_wcsicmp(szBuffer, L"HKEY_USERS"))
		hkey = HKEY_USERS;
	else
	{
		hr = E_INVALIDARG;
		goto Finish;
	}

	//copy the keys & values between the commas to the output buffers!!!
	wcsncpy(szSubkey, (first + 1), cchSubkey);
	szSubkey[cchSubkey - 1] = L'\0';

	if ((second != NULL) && (szValueName != NULL) && (cchValueName != 0))
	{
		wcsncpy(szValueName, (second + 1), cchValueName);
		szValueName[cchValueName - 1] = L'\0';
	}

	if ((third != NULL) && (szValue != NULL) && (cchValue != 0))
	{
		wcsncpy(szValue, third + 1, cchValue);
		szValue[cchValue - 1] = L'\0';
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrGetShortcutEntryToRegistry(ULONG cchPifName, WCHAR szPifName[])
{
	HRESULT hr = NOERROR;

	CVsRegistryKey hkey;
	CVsRegistryKey hkeySubkey;
	WCHAR szSubkey[MSINFHLP_MAX_PATH];
	LONG lStatus;

	hr = ::HrGetInstallDirRegkey(hkey.Access(), NUMBER_OF(szSubkey), szSubkey, 0, NULL);
	if (FAILED(hr))
	{
		::VLog(L"Getting the installation directory registry key failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = hkey.HrGetSubkeyStringValueW(szSubkey, L"ShortcutFilename", cchPifName, szPifName);
	if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
	{
		::VLog(L"Unable to find ShortcutFilename value in the application installation registry key");
		hr = E_INVALIDARG;
		goto Finish;
	}

	if (FAILED(hr))
	{
		::VLog(L"Getting the subkey string value failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}



//this method copies a file to the system directory.  If the file is in use, we
//pop up a message saying that the file is in use, asks the user to exit out of
//that process, and then quit.
//TODO:  UNDONE:  HACK:
//To compare the version info between 2 files, use
//"GetFileVersionInfo" and "VerQueryValue"
HRESULT HrCopyFileToSystemDirectory(LPCWSTR szFilename, bool fSilent, bool &rfAlreadyExisted)
{
	HRESULT hr = NOERROR;

	DWORD dwMSVerExisting;
	DWORD dwLSVerExisting;
	DWORD dwMSVerInstalling;
	DWORD dwLSVerInstalling;
	DWORD dwError;
	WCHAR szTemp[_MAX_PATH];
	WCHAR szSysFile[_MAX_PATH];
	HANDLE hFile = INVALID_HANDLE_VALUE;
	bool fSelfRegistering;
	int iResult;

	//if we cannot get the system directory, we resolve it and go on
	::VExpandFilename(L"<SysDir>", NUMBER_OF(szTemp), szTemp);

	::VFormatString(NUMBER_OF(szSysFile), szSysFile, L"%0\\\\%1", szTemp, szFilename);

	::VLog(L"Deciding whether to move file \"%s\" to \"%s\"", szFilename, szSysFile);

	//the file to copy is not found, put up a message & boot
	if (NVsWin32::GetFileAttributesW(szFilename) == 0xFFFFFFFF)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"could not get file attributes of file \"%s\"; last error = %d", szFilename, dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	//if file does NOT exist in system directory, we just copy
	if (NVsWin32::GetFileAttributesW(szSysFile) == 0xFFFFFFFF)
	{
		const DWORD dwLastError = ::GetLastError();
		if (dwLastError != ERROR_FILE_NOT_FOUND)
		{
			::VLog(L"could not get file attributes of file \"%s\"; last error = %d", szSysFile, dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		rfAlreadyExisted = false;
		goto Copy;
	}

	rfAlreadyExisted = true;

	bool fIsEXE, fIsDLL;

	hr = ::HrGetFileVersionNumber(szFilename, dwMSVerInstalling, dwLSVerInstalling, fSelfRegistering, fIsEXE, fIsDLL);
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Version of \"%s\": %08lx %08lx", szFilename, dwMSVerInstalling, dwLSVerInstalling);

	hr = ::HrGetFileVersionNumber(szSysFile, dwMSVerExisting, dwLSVerExisting, fSelfRegistering, fIsEXE, fIsDLL);
	if (FAILED(hr))
		goto Finish;

	::VLog(L"Version of \"%s\": %08lx %08lx", szSysFile, dwMSVerExisting, dwLSVerExisting);

	//now let's compare the version numbers between the 2 files
	iResult = ::ICompareVersions(dwMSVerExisting, dwLSVerExisting, dwMSVerInstalling, dwLSVerInstalling);
	::VLog(L"result of comparison of versions: %d", iResult);
	if (iResult < 0)
	{
		//if file is currently in use, we put up a dialog to complain and quit
		hFile = NVsWin32::CreateFileW(szSysFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			const DWORD dwLastError = ::GetLastError();
			if (dwLastError == ERROR_SHARING_VIOLATION)
				goto Prompt;
			else if (dwLastError != ERROR_FILE_NOT_FOUND)
			{
				::VLog(L"Error opening system file to see if it was busy; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		if (!::CloseHandle(hFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"attempt to close file handle failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		hFile = NULL;

		goto Copy;
	}
	else
	{
		if (iResult == 0)
		{
			// The versions are the same; let's look at the filetimes also...
			FILETIME ft1, ft2;

			hFile = NVsWin32::CreateFileW(
								szFilename,
								GENERIC_READ,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_EXISTING,
								0,
								NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Opening source file to get filetime failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!::GetFileTime(hFile, NULL, NULL, &ft1))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"getting creation date of source file failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!::CloseHandle(hFile))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"closing source file handle failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				hFile = NULL;
				goto Finish;
			}

			hFile = NVsWin32::CreateFileW(
								szSysFile,
								GENERIC_READ,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_EXISTING,
								0,
								NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Opening target file to get filetime failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!::GetFileTime(hFile, NULL, NULL, &ft2))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"getting creation date of target file failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (!::CloseHandle(hFile))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"closing target file handle failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				hFile = NULL;
				goto Finish;
			}

			hFile = NULL;

			if (::CompareFileTime(&ft1, &ft2) > 0)
				goto Copy;
		}

		// Return S_FALSE to indicate that we didn't actually do the copy.
		hr = S_FALSE;

		goto Finish;
	}

//In this section, we complain that the file that we need is in use, and
//exit with a false.
Prompt:
	if (fSilent)
	{
		::VLog(L"Unable to update required file and we're running silent");
		hr = E_UNEXPECTED;
		goto Finish;
	}

	::VMsgBoxOK(achInstallTitle, achUpdatePrompt, szSysFile);

	//after the prompt, we exit anyways
	hr = E_ABORT;
	goto Finish;

Copy:
	//copy file, complain if cannot copy
	if (!NVsWin32::CopyFileW(szFilename, szSysFile, FALSE))
	{
		const DWORD dwLastError = ::GetLastError();

		if (dwLastError == ERROR_SHARING_VIOLATION)
			goto Prompt;
		
		::VLog(L"Failure from copyfile during move of file to system dir; last error = %d", dwLastError);

		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(hFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to close handle at end of move system file failed; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		hFile = NULL;
	}

	hr = NOERROR;

Finish:

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
		::CloseHandle(hFile);

	return hr;
}

static void CanonicalizeFilename(ULONG cchFilenameBuffer, LPWSTR szFilename)
{
	if ((szFilename == NULL) || (cchFilenameBuffer == 0))
		return;

	WCHAR rgwchBuffer[MSINFHLP_MAX_PATH];

	int iResult = NVsWin32::LCMapStringW(
					::GetSystemDefaultLCID(),
					LCMAP_LOWERCASE,
					szFilename,
					-1,
					rgwchBuffer,
					NUMBER_OF(rgwchBuffer));

	if (iResult != 0)
	{
		wcsncpy(szFilename, rgwchBuffer, cchFilenameBuffer);
		// wcsncpy() doesn't necessarily null-terminate; make sure it is.
		szFilename[cchFilenameBuffer - 1] = L'\0';
	}
}

HRESULT HrWriteFormatted(HANDLE hFile, LPCWSTR szFormatString, ...)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH * 2];
	DWORD dwBytesWritten = 0;

	va_list ap;
	va_start(ap, szFormatString);
	int iResult = _vsnwprintf(szBuffer, NUMBER_OF(szBuffer), szFormatString, ap);
	va_end(ap);

	if (iResult < 0)
	{
		hr = E_FAIL;
		goto Finish;
	}

	szBuffer[NUMBER_OF(szBuffer) - 1] = L'\0';

	if (!::WriteFile(hFile, (LPBYTE) szBuffer, iResult * sizeof(WCHAR), &dwBytesWritten, NULL))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}
	
	hr = NOERROR;

Finish:
	return hr;
}

HRESULT HrReadLine(LPCWSTR &rpsz, ULONG cchName, WCHAR szName[], ULONG cchValue, WCHAR szValue[])
{
	HRESULT hr = NOERROR;
	ULONG cch;
	LPCWSTR pszValue, pszColon, pszReturn;

	if (_wcsnicmp(rpsz, L"[END]\r\n", 7) == 0)
	{
		hr = S_FALSE;
		rpsz += 7;
		goto Finish;
	}

	// Skip carriage returns and newlines
	while ((*rpsz == L'\r') || (*rpsz == L'\n'))
		rpsz++;

	pszColon = wcschr(rpsz, L':');
	if (pszColon == NULL)
	{
		WCHAR szBuff[64];
		wcsncpy(szBuff, rpsz, NUMBER_OF(szBuff));
		szBuff[NUMBER_OF(szBuff) - 1] = L'\0';

		VLog(L"Invalid persisted work item (missing colon) - starting at: \"%s\"", szBuff);
		hr = E_FAIL;
		::SetErrorInfo(0, NULL);
		goto Finish;
	}

	pszValue = pszColon + 1;

	while ((*pszValue) == L' ')
		pszValue++;

	// Here we go, bunky!
	pszReturn = wcschr(pszValue, L'\r');
	if (pszReturn == NULL)
	{
		WCHAR szBuff[64];
		wcsncpy(szBuff, rpsz, NUMBER_OF(szBuff));
		szBuff[NUMBER_OF(szBuff) - 1] = L'\0';

		VLog(L"Invalid persisted work item (missing carriage return after found colon) - starting at: \"%s\"", szBuff);
		
		hr = E_FAIL;
		::SetErrorInfo(0, NULL);
		goto Finish;
	}

	// We have the boundaries; let's just copy the name and value.
	cch = pszColon - rpsz;
	if (cch >= cchName)
		cch = cchName - 1;

	memcpy(szName, rpsz, cch * sizeof(WCHAR));
	szName[cch] = L'\0';

	cch = pszReturn - pszValue;
	if (cch >= cchValue)
		cch = cchValue - 1;

	memcpy(szValue, pszValue, cch * sizeof(WCHAR));
	szValue[cch] = L'\0';

	pszReturn++;

	if (*pszReturn == L'\n')
		pszReturn++;

	rpsz = pszReturn;

	hr = NOERROR;

Finish:
	return hr;
}

void VSetDialogItemTextList(HWND hwndDialog, ULONG cEntries, const DialogItemToStringKeyMapEntry rgMap[]) throw ()
{
	ULONG i;
	for (i=0; i<cEntries; i++)
		::VSetDialogItemText(hwndDialog, rgMap[i].m_uiID, rgMap[i].m_pszValueKey);
}

extern void VTrimDirectoryPath(LPCWSTR szPathIn, ULONG cchPathOut, WCHAR szPathOut[]) throw ()
{
	WCHAR const *pszIn = szPathIn;
	WCHAR *pszOut = szPathOut;
	ULONG cSpacesSkipped = 0;
	WCHAR wch;

	while ((wch = *pszIn++) != L'\0')
	{
		if (wch == L' ')
		{
			cSpacesSkipped++;
		}
		else
		{
			if (wch != L'\\')
			{
				while (cSpacesSkipped != 0)
				{
					if ((--cchPathOut) == 0)
						break;

					*pszOut++ = L' ';
					cSpacesSkipped--;
				}
			}

			if (cchPathOut == 0 || ((--cchPathOut) == 0))
				break;

			*pszOut++ = wch;
		}
	}

	while ((pszOut != szPathOut) && (pszOut[-1] == L'\\'))
		pszOut--;

	*pszOut = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\win32wpr.h ===
#pragma once

extern bool g_fUseUnicode;

namespace NVsWin32
{
	STDAPI Initialize();

	class __declspec(novtable) CDelegate
	{
	public:
		virtual int		WINAPI MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) throw () = 0;

		virtual int		WINAPI CompareStringW(LCID lcid, DWORD dwCmdFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2) throw () = 0;
		virtual BOOL	WINAPI CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists) throw () = 0;
		virtual HWND	WINAPI CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam) throw () = 0;
		virtual BOOL	WINAPI CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)=0;
		virtual HANDLE	WINAPI CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa, DWORD dwCreationDistribution, DWORD dwFlagsAndTemplates, HANDLE hTemplateFile) throw () = 0;

		virtual HWND	WINAPI CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam) throw () = 0;

		virtual BOOL	WINAPI DeleteFileW(LPCWSTR szFilename) throw () = 0;
		virtual int		WINAPI DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam) throw () = 0;

		virtual HANDLE	WINAPI FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData) throw () = 0;
		virtual HRSRC	WINAPI FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType) throw () = 0;
		virtual HWND	WINAPI FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName) throw () = 0;
		virtual DWORD	WINAPI FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *pvaArguments) throw () = 0;

		virtual LPOLESTR WINAPI GetCommandLineW() throw () = 0;
		virtual int		WINAPI GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer) throw () = 0;
		virtual BOOL	WINAPI GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puliFreeBytesAvailableToCaller, ULARGE_INTEGER *puliTotalBytes, ULARGE_INTEGER *puliTotalFreeBytes) throw () = 0;
		virtual UINT	WINAPI GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount) throw () = 0;
		virtual DWORD	WINAPI GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[]) throw () = 0;
		virtual DWORD	WINAPI GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize) throw () = 0;
		virtual DWORD	WINAPI GetFileAttributesW(LPCWSTR lpFilename) throw () = 0;
		virtual BOOL	WINAPI GetFileVersionInfoW(  LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) throw () = 0;
		virtual DWORD	WINAPI GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle) throw () = 0;
		virtual DWORD	WINAPI GetFullPathNameW(LPCWSTR szFilename, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart) throw () = 0;
		virtual int		WINAPI GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer) throw () = 0;
		virtual	DWORD	WINAPI GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize) throw () = 0;
		virtual HMODULE WINAPI GetModuleHandleW(LPCWSTR lpModuleName) throw () = 0;
		virtual int		WINAPI GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR szBuffer, int cchBuffer) throw () = 0;
		virtual FARPROC WINAPI GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName) throw () = 0;
		virtual DWORD	WINAPI GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer) throw () = 0;
		virtual UINT	WINAPI GetSystemDirectoryW(WCHAR szSystemDirectory[], UINT uSize) throw () = 0;
		virtual UINT	WINAPI GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName) throw () = 0;
		virtual	DWORD	WINAPI GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[]) throw () = 0;
		virtual int		WINAPI GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer) throw () = 0;
		virtual BOOL	WINAPI GetVolumeInformationW(LPCWSTR szPath, LPWSTR lpVolumeNameBuffer, DWORD cchVolumeNameBuffer, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentNameLength, LPDWORD pdwFileSystemFlags, LPWSTR pszFileSystemNameBuffer, DWORD cchFileSystemNameBuffer) throw () = 0;
		virtual UINT	WINAPI GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize) throw () = 0; 

		virtual BOOL	WINAPI IsDialogMessageW(HWND hDlg, LPMSG lpMsg) throw () = 0;

		virtual int		WINAPI LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchSrc, LPWSTR szOut, int cchDest) throw () = 0;
		virtual BOOL	WINAPI ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem) throw () = 0;		
		virtual int		WINAPI ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem) throw () = 0;

		virtual HINSTANCE WINAPI LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags) throw () = 0;
		virtual HANDLE	WINAPI LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad) throw () = 0;
		virtual HMODULE WINAPI LoadLibraryW(LPCWSTR lpLibFileName) throw () = 0;
		virtual BOOL	WINAPI MoveFileW(LPCWSTR lpFrom, LPCWSTR lpTo) throw () = 0;
		virtual BOOL	WINAPI MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags) throw () = 0;

		virtual ATOM	WINAPI RegisterClassExW(CONST WNDCLASSEXW *lpwcx) throw () = 0;
		virtual LONG	WINAPI RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey) throw () = 0;
		virtual LONG	WINAPI RegDeleteValueW(HKEY hkey, LPCWSTR lpValue) throw () = 0;
		virtual LONG	WINAPI RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime) throw () = 0;
		virtual LONG	WINAPI RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData) throw () = 0;
		virtual LONG	WINAPI RegOpenKeyExW(HKEY hKey, LPCOLESTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) throw () = 0;
		virtual LONG	WINAPI RegQueryValueW(HKEY hKey, LPCOLESTR szValueName, OLECHAR rgchValue[], LONG *pcbValue) throw () = 0;
		virtual LONG	WINAPI RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData) throw () = 0;
		virtual LONG	WINAPI RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,  PHKEY phkResult, LPDWORD lpdwDisposition)=0; 
		virtual LONG	WINAPI RegSetValueExW(HKEY hKey, LPCWSTR lpValueName,DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData)=0;  
		virtual BOOL	WINAPI RemoveDirectoryW(LPCWSTR lpPathName) throw () = 0;


		virtual BOOL	WINAPI SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString) throw () = 0;

		virtual BOOL  WINAPI SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes);
		virtual BOOL  WINAPI SetWindowTextW(HWND window, LPCWSTR string)=0;
		virtual LPITEMIDLIST WINAPI SHBrowseForFolderW(LPBROWSEINFOW lpbi) throw () = 0; 
		virtual DWORD	WINAPI SHGetFileInfoW(LPCWSTR szPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags) throw () = 0;

		virtual BOOL	WINAPI SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath );
		virtual BOOL	WINAPI CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation ) throw () = 0;

		virtual BOOL	WINAPI UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance) throw () = 0;

		virtual BOOL	WINAPI VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen) throw () = 0; 
		virtual BOOL	WINAPI WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName) throw () = 0;

		// not really a win32 thing, but an ansi vs. unicode thing:
		virtual LRESULT LrWmSetText(HWND hwnd, LPCWSTR szText) throw () = 0;

		// This is the global data object which is initialized in Initialize() which will
		// point to the appropriate CDelegate derived class instance to either call the
		// direct Win32 function or do magic to make it work on Win95.
		static CDelegate *ms_pDelegate;
	};

	// Let's try to keep these in alphabetical order as much as possible; otherwise it's
	// becoming hard to find if a Win32 API is already wrapped.  -mgrier 8/2/97

	inline int MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->MessageBoxW(hwnd, lpText, lpCaption, uType); }

	inline int CompareStringW(LCID lcid, DWORD dwCmpFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CompareStringW(lcid, dwCmpFlags, szString1, cchString1, szString2, cchString2); }

	inline BOOL CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CopyFileW(szSource, szDest, fFailIfExists); }

	inline HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CreateDialogParamW(hInstance, szTemplateName, hwndParent, lpDialogProc, dwInitParam); }

	inline BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CreateDirectoryW(lpPathName, lpSecurityAttributes); }

	inline HANDLE CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
							DWORD dwCreationDistribution, DWORD dwFlagsAndTemplates, HANDLE hTemplateFile) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CreateFileW(szFilename, dwDesiredAccess, dwShareMode, lpsa, dwCreationDistribution, dwFlagsAndTemplates, hTemplateFile); }

	inline HWND	WINAPI CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight,
								HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam); }

	inline BOOL DeleteFileW( LPCWSTR lpString) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->DeleteFileW(lpString); }

	inline int DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->DialogBoxParamW(hInstance, szTemplateName, hwndParent, lpDialogProc, dwInitParam); }

	inline HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->FindFirstFileW(lpFileName, lpFindFileData); }

	inline DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *pvaArguments) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, pvaArguments); }

	inline HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->FindResourceW(hModule, lpName, lpType); }

	inline DWORD GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[]) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetCurrentDirectoryW(nBufferLength, lpBuffer); }
	
	inline int GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetDateFormatW(lcid, dwFlags, pst, szFormat, szBuffer, cchBuffer); }

	inline UINT GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puli1, ULARGE_INTEGER *puli2, ULARGE_INTEGER *puli3) throw()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetDiskFreeSpaceExW(lpRootPathName, puli1, puli2, puli3); }

	inline UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount); }

	inline DWORD GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetEnvironmentVariableW(szName, szBuffer, nSize); }

	inline DWORD GetFileAttributesW(LPCWSTR lpFilename) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetFileAttributesW(lpFilename); }

	inline DWORD GetFileVersionInfoW(LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetFileVersionInfoW(lptstrFilename, dwHandle, dwLen, lpData); }

	inline DWORD GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle); }

	inline DWORD GetFullPathNameW(LPCWSTR szFilename, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetFullPathNameW(szFilename, cchBuffer, szBuffer, ppszFilePart); }

	inline HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->FindWindowW(lpClassName, lpWindowName); }

	inline int GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetLocaleInfoW(lcid, lctype, szBuffer, cchBuffer); }

	inline HMODULE GetModuleHandleW(LPCWSTR lpModuleName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetModuleHandleW(lpModuleName); }

	inline int GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR szBuffer, int cchBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetNumberFormatW(lcid, dwFlags, szValue, pFormat, szBuffer, cchBuffer); }

	inline FARPROC GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetProcAddressW(hModule, lpProcName); }

	inline DWORD GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetShortPathNameW(szPath, szBuffer, cchBuffer); }

	inline UINT GetSystemDirectoryW(WCHAR szBuffer[], UINT uSize) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetSystemDirectoryW(szBuffer, uSize); }

	inline UINT GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetTempFileNameW(szPathName,szPrefixString,uUnique,szTempFileName); }

	inline int GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetTimeFormatW(lcid, dwFlags, pst, szFormat, szBuffer, cchBuffer); }

	inline BOOL GetVolumeInformationW(LPCWSTR szPath, LPWSTR lpVolumeNameBuffer, DWORD cchVolumeNameBuffer, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentNameLength, LPDWORD pdwFileSystemFlags, LPWSTR pszFileSystemNameBuffer, DWORD cchFileSystemNameBuffer) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetVolumeInformationW(szPath, lpVolumeNameBuffer, cchVolumeNameBuffer, lpVolumeSerialNumber, lpMaximumComponentNameLength, pdwFileSystemFlags, pszFileSystemNameBuffer, cchFileSystemNameBuffer); }

	inline UINT GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetWindowsDirectoryW(lpBuffer, uSize); }

	inline DWORD GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[]) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetTempPathW(nBufferLength, lpBuffer); }

	inline DWORD GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->GetModuleFileNameW(hModule, lpBuffer, nSize); }

	inline BOOL	IsDialogMessageW(HWND hDlg, LPMSG lpMsg) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->IsDialogMessageW(hDlg, lpMsg); }

	inline int LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchIn, LPWSTR szOut, int cchOut) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->LCMapStringW(lcid, dwMapFlags, szIn, cchIn, szOut, cchOut); }

	inline BOOL	ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->ListView_InsertItemW(hwnd, pitem); }

	inline BOOL	ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->ListView_SetItemW(hwnd, pitem); }

	inline HANDLE LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->LoadImageW(hInstance, szName, uType, cxDesired, cyDesired, fuLoad); }

	inline HMODULE LoadLibraryW(LPCWSTR lpLibFileName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->LoadLibraryW(lpLibFileName); }

	inline HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->LoadLibraryExW(lpLibFileName, hFile, dwFlags); }

	inline BOOL MoveFileW( LPCWSTR lpFrom, LPCWSTR lpTo) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->MoveFileW(lpFrom, lpTo); }

	inline BOOL MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags); }

	inline ATOM RegisterClassExW(CONST WNDCLASSEXW *lpwcx) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegisterClassExW(lpwcx); }

	inline LONG RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegDeleteKeyW(hkey, lpSubKey); }

	inline LONG RegDeleteValueW(HKEY hkey, LPCWSTR lpValue) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegDeleteValueW(hkey, lpValue); }

	inline LONG	RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegEnumKeyExW(hkey, dwIndex, lpName, lpcbName, lpdwReserved, lpClass, lpcbClass, pftLastWriteTime); }

	inline LONG RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegEnumValueW(hkey, dwIndex, lpName, lpcbName, lpdwReserved, lpdwType, lpData, lpcbData); }

	inline LONG RegOpenKeyExW(HKEY hKey, LPCWSTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegOpenKeyExW(hKey, szKey, ulOptions, samDesired, phkResult); }

	inline LONG RegQueryValueW(HKEY hKey, LPCWSTR szValueName, WCHAR rgchValue[], LONG *pcbValue) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegQueryValueW(hKey, szValueName, rgchValue, pcbValue); }

	inline LONG RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbValue) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegQueryValueExW(hKey, szValueName, pdwReserved, pdwType, pbData, pcbValue); }

	inline BOOL RemoveDirectoryW(LPCWSTR lpPathName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RemoveDirectoryW(lpPathName); }

	inline LONG RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,  PHKEY phkResult, LPDWORD lpdwDisposition) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition); }

	inline LONG RegSetValueExW(HKEY hKey, LPCWSTR lpValueName,DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData); }

	inline BOOL SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SetFileAttributesW(szSource, dwFileAttributes); }

	inline BOOL SetWindowTextW(HWND window, LPCWSTR text) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SetWindowTextW(window, text); }

	inline LPITEMIDLIST SHBrowseForFolderW ( LPBROWSEINFOW browseInfo ) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SHBrowseForFolderW(browseInfo); }

	inline DWORD SHGetFileInfoW(LPCWSTR szPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SHGetFileInfoW(szPath, dwFileAttributes, pshfi, cbFileInfo, uFlags); }

	inline BOOL SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath ) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SHGetPathFromIDListW( pidl, pszPath ); }

	inline BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation ) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation ); }

	inline BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->SetDlgItemTextW(hDlg, nIDDlgItem, lpString); }

	inline BOOL UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->UnregisterClassW(lpClassName, hInstance); }

	inline BOOL VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen); }

	inline BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName); }

	inline LRESULT LrWmSetText(HWND hwnd, LPCWSTR szText) throw ()
	{ return NVsWin32::CDelegate::ms_pDelegate->LrWmSetText(hwnd, szText); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\win32wpr.cpp ===
#include "stdinc.h"

#pragma warning(disable: 4514)

//
//	Since there are tons of fixed length buffers, let's make sure they're long enough:
//

#define NUMBER_OF(x)  (sizeof(x) / sizeof((x)[0]))







//**********************************************************************************
//  NVsWin32  namespace declaration & definition




// NVSWin32  namespace declaration & definition
//**********************************************************************************









//********************************************************************************************
// Wrappers for Windows APIs -- and I'm really using this much...



class CWin32ANSI;
class CWin32Unicode;


class CWin32ANSI : public NVsWin32::CDelegate
{
	friend CWin32Unicode;
		virtual int		WINAPI MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

		virtual int		WINAPI CompareStringW(LCID lcid, DWORD dwCmdFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2);
		virtual BOOL	WINAPI CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists);
		virtual HWND	WINAPI CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
		virtual BOOL	WINAPI CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
		virtual HANDLE	WINAPI CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
								DWORD dwCreationDistribution, DWORD dwFlagsAndTemplates, HANDLE hTemplateFile);

		virtual BOOL	WINAPI CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation );

		virtual HWND	WINAPI CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight,
								HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);

		virtual BOOL	WINAPI DeleteFileW(LPCWSTR szFilename);
		virtual int		WINAPI DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

		virtual HANDLE	WINAPI FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
		virtual HRSRC	WINAPI FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
		inline  HWND	WINAPI FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
		virtual DWORD	WINAPI FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *pvaArguments);

		virtual LPOLESTR WINAPI GetCommandLineW();
		virtual DWORD	WINAPI GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[]);

		virtual int		WINAPI GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer);
		virtual BOOL	WINAPI GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puli1, ULARGE_INTEGER *puli2, ULARGE_INTEGER *puli3);
		virtual UINT	WINAPI GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount);
		virtual DWORD	WINAPI GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize);
		virtual DWORD	WINAPI GetFileAttributesW(LPCWSTR lpFilename);
		virtual BOOL	WINAPI GetFileVersionInfoW(  LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
		virtual DWORD	WINAPI GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle);
		virtual DWORD	WINAPI GetFullPathNameW(LPCWSTR szFile, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart);
		virtual int		WINAPI GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer);
		virtual HMODULE WINAPI GetModuleHandleW(LPCWSTR lpModuleName);
		virtual int		WINAPI GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR szBuffer, int cchBuffer);
		virtual FARPROC WINAPI GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName);
		virtual DWORD	WINAPI GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer);
		virtual UINT	WINAPI GetSystemDirectoryW(WCHAR szSystemDirectory[], UINT uSize);
		virtual UINT	WINAPI GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName);
		virtual int		WINAPI GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer);
		virtual BOOL	WINAPI GetVolumeInformationW(LPCWSTR szPath, LPWSTR lpVolumeNameBuffer, DWORD cchVolumeNameBuffer, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentNameLength, LPDWORD pdwFileSystemFlags, LPWSTR pszFileSystemNameBuffer, DWORD cchFileSystemNameBuffer) throw ();
		virtual UINT	WINAPI GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize); 

		virtual	DWORD	WINAPI GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[]);
		virtual	DWORD	WINAPI GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize);

		virtual BOOL	WINAPI IsDialogMessageW(HWND hDlg, LPMSG lpMsg);

		virtual int		WINAPI LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchIn, LPWSTR szOut, int cchOut);
		virtual BOOL	WINAPI ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem);
		virtual int		WINAPI ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem);

		virtual HANDLE	WINAPI LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
		virtual HMODULE WINAPI LoadLibraryW(LPCWSTR lpLibFileName);
		virtual HINSTANCE WINAPI LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
		virtual BOOL	WINAPI MoveFileW(LPCWSTR lpFrom, LPCWSTR lpTo);
		virtual BOOL	WINAPI MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);


		virtual LONG	WINAPI RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey);
		virtual LONG	WINAPI RegDeleteValueW(HKEY hkey, LPCWSTR lpValue);
		virtual ATOM	WINAPI RegisterClassExW(CONST WNDCLASSEXW *lpwcx) ;
		virtual LONG	WINAPI RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime);
		virtual LONG	WINAPI RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData);
		virtual LONG	WINAPI RegOpenKeyExW(HKEY hKey, LPCOLESTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
		virtual LONG	WINAPI RegQueryValueW(HKEY hKey, LPCOLESTR szValueName, OLECHAR rgchValue[], LONG *pcbValue);
		virtual LONG	WINAPI RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData);
		virtual LONG	WINAPI RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,  PHKEY phkResult, LPDWORD lpdwDisposition); 
		virtual LONG	WINAPI RegSetValueExW(HKEY hKey, LPCWSTR lpValueName,DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);  
		virtual BOOL	WINAPI RemoveDirectoryW(LPCWSTR lpPathName);

		virtual BOOL	WINAPI SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString);
		virtual BOOL  WINAPI SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes);
		virtual BOOL  WINAPI SetWindowTextW(HWND window, LPCWSTR string);
		virtual LPITEMIDLIST WINAPI SHBrowseForFolderW(LPBROWSEINFOW lpbi); 
		virtual DWORD	WINAPI SHGetFileInfoW(LPCWSTR szPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags);
		virtual BOOL	WINAPI SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath );
		virtual BOOL	WINAPI UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance);

		virtual BOOL	WINAPI VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen); 

		virtual BOOL	WINAPI WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);

		// not really a win32 function:
		virtual LRESULT LrWmSetText(HWND hwnd, LPCWSTR szText);
};



class CWin32Unicode : public NVsWin32::CDelegate
{
	friend CWin32ANSI;

		virtual int		WINAPI MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

		virtual int		WINAPI CompareStringW(LCID lcid, DWORD dwCmdFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2);
		virtual BOOL	WINAPI CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists);
		virtual HWND	WINAPI CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
		virtual BOOL	WINAPI CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
		virtual HANDLE	WINAPI CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
								DWORD dwCreationDistribution, DWORD dwFlagsAndTemplates, HANDLE hTemplateFile);

		virtual BOOL	WINAPI CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation );

		virtual HWND	WINAPI CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight,
								HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);

		virtual BOOL	WINAPI DeleteFileW(LPCWSTR szFilename);
		virtual int		WINAPI DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

		virtual HANDLE	WINAPI FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
		virtual HRSRC	WINAPI FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
		inline  HWND	WINAPI FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
		virtual DWORD	WINAPI FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *pvaArguments);

		virtual DWORD	WINAPI GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[]);
		virtual LPOLESTR WINAPI GetCommandLineW();
		virtual int		WINAPI GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer);
		virtual BOOL	WINAPI GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puli1, ULARGE_INTEGER *puli2, ULARGE_INTEGER *puli3);
		virtual UINT	WINAPI GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount);
		virtual DWORD	WINAPI GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize);
		virtual DWORD	WINAPI GetFileAttributesW(LPCWSTR lpFilename);
		virtual BOOL	WINAPI GetFileVersionInfoW(  LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
		virtual DWORD	WINAPI GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle);
		virtual DWORD	WINAPI GetFullPathNameW(LPCWSTR szFile, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart);
		virtual int		WINAPI GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer);
		virtual HMODULE WINAPI GetModuleHandleW(LPCWSTR lpModuleName);
		virtual int		WINAPI GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR szBuffer, int cchBuffer);
		virtual FARPROC WINAPI GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName);
		virtual DWORD	WINAPI GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer);
		virtual UINT	WINAPI GetSystemDirectoryW(WCHAR szSystemDirectory[], UINT uSize);
		virtual UINT	WINAPI GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName);
		virtual int		WINAPI GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer);
		virtual BOOL	WINAPI GetVolumeInformationW(LPCWSTR szPath, LPWSTR lpVolumeNameBuffer, DWORD cchVolumeNameBuffer, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentNameLength, LPDWORD pdwFileSystemFlags, LPWSTR pszFileSystemNameBuffer, DWORD cchFileSystemNameBuffer) throw ();
		virtual UINT	WINAPI GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize); 

		virtual	DWORD	WINAPI GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[]);
		virtual	DWORD	WINAPI GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize);

		virtual BOOL	WINAPI IsDialogMessageW(HWND hDlg, LPMSG lpMsg);

		virtual int		WINAPI LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchIn, LPWSTR szOut, int cchOut);
		virtual BOOL	WINAPI ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem);
		virtual int		WINAPI ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem);

		virtual HANDLE	WINAPI LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
		virtual HMODULE WINAPI LoadLibraryW(LPCWSTR lpLibFileName);
		virtual HINSTANCE WINAPI LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
		virtual BOOL	WINAPI MoveFileW(LPCWSTR lpFrom, LPCWSTR lpTo);
		virtual BOOL	WINAPI MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);


		virtual LONG	WINAPI RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey);
		virtual LONG	WINAPI RegDeleteValueW(HKEY hkey, LPCWSTR lpValue);
		virtual ATOM	WINAPI RegisterClassExW(CONST WNDCLASSEXW *lpwcx) ;
		virtual LONG	WINAPI RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime);
		virtual LONG	WINAPI RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData);
		virtual LONG	WINAPI RegOpenKeyExW(HKEY hKey, LPCOLESTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
		virtual LONG	WINAPI RegQueryValueW(HKEY hKey, LPCOLESTR szValueName, OLECHAR rgchValue[], LONG *pcbValue);
		virtual LONG	WINAPI RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData);
		virtual LONG	WINAPI RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,  PHKEY phkResult, LPDWORD lpdwDisposition); 
		virtual LONG	WINAPI RegSetValueExW(HKEY hKey, LPCWSTR lpValueName,DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);  
		virtual BOOL	WINAPI RemoveDirectoryW(LPCWSTR lpPathName);

		virtual BOOL	WINAPI SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString);
		virtual BOOL  WINAPI SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes);
		virtual BOOL  WINAPI SetWindowTextW(HWND window, LPCWSTR string);
		virtual LPITEMIDLIST WINAPI SHBrowseForFolderW(LPBROWSEINFOW lpbi); 
		virtual DWORD	WINAPI SHGetFileInfoW(LPCWSTR szPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags);
		virtual BOOL	WINAPI SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath );
		virtual BOOL	WINAPI UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance);

		virtual BOOL	WINAPI VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen); 
		virtual BOOL	WINAPI WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);

		// not really a win32 function:
		virtual LRESULT LrWmSetText(HWND hwnd, LPCWSTR szText);
};


NVsWin32::CDelegate *NVsWin32::CDelegate::ms_pDelegate;

CWin32Unicode g_w32U;
CWin32ANSI g_w32A;

STDAPI NVsWin32::Initialize() throw ()
{
	if (NVsWin32::CDelegate::ms_pDelegate != NULL)
		return NOERROR;

	bool fUseUnicode = false;

#if 1
	// Remove this code to always use ANSI APIs, even on Windows NT.
	OSVERSIONINFOA osvi;

	osvi.dwOSVersionInfoSize = sizeof(osvi);

	::GetVersionExA(&osvi);

	if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		(osvi.dwMajorVersion >= 4))
		fUseUnicode = true;
#endif

	if (fUseUnicode)
		NVsWin32::CDelegate::ms_pDelegate = &g_w32U;
	else
		NVsWin32::CDelegate::ms_pDelegate = &g_w32A;

	return NOERROR;
}



//****************************************************************************************
//Unicode method definitions -- mostly straight calls to Win APIs


int WINAPI CWin32Unicode::MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
{
	return ::MessageBoxW(hwnd, lpText, lpCaption, uType);
}

LONG WINAPI CWin32Unicode::RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime)
{
	return ::RegEnumKeyExW(hkey, dwIndex, lpName, lpcbName, lpdwReserved, lpClass, lpcbClass, pftLastWriteTime);
}

LONG WINAPI CWin32Unicode::RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData)
{
	return ::RegEnumValueW(hkey, dwIndex, lpName, lpcbName, lpdwReserved, lpdwType, lpData, lpcbData);
}

LONG WINAPI CWin32Unicode::RegOpenKeyExW(HKEY hKey, LPCWSTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	return ::RegOpenKeyExW(hKey, szKey, ulOptions, samDesired, phkResult);
}

LONG WINAPI CWin32Unicode::RegQueryValueW(HKEY hKey, LPCWSTR szValueName, WCHAR rgchValue[], LONG *pcbValue)
{
	return ::RegQueryValueW(hKey, szValueName, rgchValue, pcbValue);
}

LONG WINAPI CWin32Unicode::RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbValue)
{
	// We assert that this is NULL because a runtime decision could make us use the
	// non-trivial ANSI version where it's not known to be safe to have pdwReserved be non-NULL.
	return ::RegQueryValueExW(hKey, szValueName, pdwReserved, pdwType, pbData, pcbValue);
}


UINT WINAPI CWin32Unicode::GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName)
{
	return ::GetTempFileNameW(szPathName,szPrefixString,uUnique,szTempFileName);
}

BOOL WINAPI CWin32Unicode::CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists)
{
	return ::CopyFileW(szSource, szDest, fFailIfExists);
}

BOOL WINAPI CWin32Unicode::SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes)
{
	return ::SetFileAttributesW(szSource, dwFileAttributes);
}

BOOL WINAPI CWin32Unicode::CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
}

BOOL WINAPI CWin32Unicode::RemoveDirectoryW(LPCWSTR lpPathName)
{
	return ::RemoveDirectoryW(lpPathName);
}

HANDLE WINAPI CWin32Unicode::CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
						DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	return ::CreateFileW(szFilename, dwDesiredAccess, dwShareMode, lpsa, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile);
}

HMODULE WINAPI CWin32Unicode::GetModuleHandleW(LPCWSTR lpw)
{
	return ::GetModuleHandleW(lpw);
}

DWORD WINAPI CWin32Unicode::GetFileAttributesW(LPCWSTR lpFilename)
{
	return ::GetFileAttributesW(lpFilename);
}

UINT WINAPI CWin32Unicode::GetSystemDirectoryW(WCHAR szSystemDirectory[], UINT uSize)
{
	return ::GetSystemDirectoryW(szSystemDirectory, uSize);
}

DWORD WINAPI CWin32Unicode::FormatMessageW
(
DWORD dwFlags,
LPCVOID lpSource,
DWORD dwMessageId,
DWORD dwLanguageId,
LPWSTR lpBuffer,
DWORD nSize,
va_list *pvaArguments
)
{
	return ::FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, pvaArguments);
}

int WINAPI CWin32Unicode::GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer)
{
	return ::GetDateFormatW(lcid, dwFlags, pst, szFormat, szBuffer, cchBuffer);
}

int WINAPI CWin32Unicode::GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR szFormat, LPWSTR szBuffer, int cchBuffer)
{
	return ::GetTimeFormatW(lcid, dwFlags, pst, szFormat, szBuffer, cchBuffer);
}

int WINAPI CWin32Unicode::GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR szBuffer, int cchBuffer)
{
	return ::GetNumberFormatW(lcid, dwFlags, szValue, pFormat, szBuffer, cchBuffer);
}

int WINAPI CWin32Unicode::GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer)
{
	return ::GetLocaleInfoW(lcid, lctype, szBuffer, cchBuffer);
}

int WINAPI CWin32Unicode::LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchIn, LPWSTR szOut, int cchOut)
{
	return ::LCMapStringW(lcid, dwMapFlags, szIn, cchIn, szOut, cchOut);
}

HMODULE WINAPI CWin32Unicode::LoadLibraryW(LPCWSTR lpLibFileName)
{
	return ::LoadLibraryW(lpLibFileName);
}

LPITEMIDLIST WINAPI CWin32Unicode::SHBrowseForFolderW
(
	LPBROWSEINFOW lpbi
)
{
	typedef LPITEMIDLIST (WINAPI *PFNSHBROWSEFORFOLDERW)(LPBROWSEINFOW);

	static PFNSHBROWSEFORFOLDERW pfn=NULL;

	if(pfn == NULL)
	{
		HINSTANCE hInstance = ::LoadLibraryA("SHELL32.DLL");

		pfn = reinterpret_cast<PFNSHBROWSEFORFOLDERW>(::GetProcAddress(hInstance, "SHBrowseForFolderW"));
	}

	if (pfn != NULL)
	{
		return (*pfn)(lpbi);
	}

	return g_w32A.SHBrowseForFolderW(lpbi);
}

LONG WINAPI CWin32Unicode::RegCreateKeyExW
(
	HKEY key, 
	LPCWSTR subKey,
	DWORD reserved, 
	LPWSTR keyClass, 
	DWORD options, 
	REGSAM securityDesired,
	LPSECURITY_ATTRIBUTES securityAttributes,  
	PHKEY resultKey, 
	LPDWORD disposition
)
{
	return ::RegCreateKeyExW(key, subKey, reserved, keyClass, options, securityDesired, securityAttributes, resultKey, disposition);
}

LONG WINAPI CWin32Unicode::RegSetValueExW
(
	HKEY key, 
	LPCWSTR valueName,
	DWORD reserved, 
	DWORD type, 
	CONST BYTE *data, 
	DWORD dataSize
)
{
	return ::RegSetValueExW(key, valueName, reserved, type, data, dataSize);
}

BOOL WINAPI CWin32Unicode::DeleteFileW(LPCWSTR szFilename)
{
	return ::DeleteFileW(szFilename);
}

BOOL WINAPI CWin32Unicode::SetWindowTextW(HWND window, LPCWSTR text)
{
	return ::SetWindowTextW(window, text);
}

HANDLE WINAPI CWin32Unicode::LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad)
{
	return ::LoadImageW(hInstance, szName, uType, cxDesired, cyDesired, fuLoad);
}

int WINAPI CWin32Unicode::CompareStringW(LCID lcid, DWORD dwCmpFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2)
{
	return ::CompareStringW(lcid, dwCmpFlags, szString1, cchString1, szString2, cchString2);
}

HANDLE WINAPI CWin32Unicode::FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileDataW)
{
	return ::FindFirstFileW(lpFileName, lpFindFileDataW);
}

int WINAPI CWin32Unicode::DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return ::DialogBoxParamW(hInstance, szTemplateName, hwndParent, lpDialogProc, dwInitParam);
}

HWND WINAPI CWin32Unicode::CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return ::CreateDialogParamW(hInstance, szTemplateName, hwndParent, lpDialogProc, dwInitParam);
}

BOOL WINAPI CWin32Unicode::CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation )
{
	dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
	return ::CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation );
}

HRSRC WINAPI CWin32Unicode::FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
	return ::FindResourceW(hModule, lpName, lpType);
}


DWORD CWin32Unicode::SHGetFileInfoW(LPCWSTR wszPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags) throw ()
{
	typedef DWORD (WINAPI *PFNSHGETFILEINFOW)(LPCWSTR, DWORD, SHFILEINFOW *, UINT, UINT);

	static PFNSHGETFILEINFOW pfn = NULL;

	if (pfn == NULL)
	{
		HINSTANCE hInstance = ::LoadLibraryA("SHELL32.DLL");
//		VSASSERT(hInstance != NULL, L"Unable to LoadLibrary() on SHELL32.DLL!"));

		pfn = reinterpret_cast<PFNSHGETFILEINFOW>(::GetProcAddress(hInstance, "SHGetFileInfoW"));
	}

	if (pfn != NULL)
		return (*pfn)(wszPath, dwFileAttributes, pshfi, cbFileInfo, uFlags);

	return g_w32A.SHGetFileInfoW(wszPath, dwFileAttributes, pshfi, cbFileInfo, uFlags);
}

BOOL CWin32Unicode::SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath ) throw ()
{
	typedef BOOL (WINAPI *PFNSHGETPATHFROMIDLISTW)( LPCITEMIDLIST, LPWSTR );

	static PFNSHGETPATHFROMIDLISTW pfn = NULL;

	if (pfn == NULL)
	{
		HINSTANCE hInstance = ::LoadLibraryA("SHELL32.DLL");
		pfn = reinterpret_cast<PFNSHGETPATHFROMIDLISTW>(::GetProcAddress(hInstance, "SHGetPathFromIDListW"));
	}

	if (pfn != NULL)
	{
		return (*pfn)(pidl, pszPath);
	}
	else
	{
		return g_w32A.SHGetPathFromIDListW(pidl, pszPath);
	}
}

ATOM CWin32Unicode::RegisterClassExW(CONST WNDCLASSEXW *lpwcx)
{
	return ::RegisterClassExW(lpwcx);
}

BOOL CWin32Unicode::UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance)
{
	return ::UnregisterClassW(lpClassName, hInstance);
}

HWND CWin32Unicode::CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight,
							HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
	return ::CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight,
							hWndParent, hMenu, hInstance, lpParam);
}

DWORD CWin32Unicode::GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle)
{
	return ::GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle);
}

BOOL CWin32Unicode::GetVolumeInformationW(LPCWSTR szPath, LPWSTR lpVolumeNameBuffer, DWORD cchVolumeNameBuffer, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentNameLength, LPDWORD pdwFileSystemFlags, LPWSTR pszFileSystemNameBuffer, DWORD cchFileSystemNameBuffer) throw ()
{
	return ::GetVolumeInformationW(szPath, lpVolumeNameBuffer, cchVolumeNameBuffer, lpVolumeSerialNumber, lpMaximumComponentNameLength, pdwFileSystemFlags, pszFileSystemNameBuffer, cchFileSystemNameBuffer);
}

UINT CWin32Unicode::GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize)
{
	return ::GetWindowsDirectoryW(lpBuffer, uSize);
}
UINT CWin32Unicode::GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount)
{
	return ::GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);
}
BOOL CWin32Unicode::SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString)
{
	return ::SetDlgItemTextW(hDlg, nIDDlgItem, lpString);
}
LONG CWin32Unicode::RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey)
{
	return ::RegDeleteKeyW(hkey, lpSubKey);
}

LPOLESTR CWin32Unicode::GetCommandLineW()
{
	//The string that is returned by Win API "GetCommandLine" does NOT need to be freed.
	//In the ANSI case, it does need to be freed.  To minimize confusion & work at the
	//non-wrapper 
	LPSTR szCmdLine = ::GetCommandLineA();
	ULONG cSize = strlen(szCmdLine) + 1;

	LPOLESTR szReturn = new WCHAR [cSize];
	if (szReturn == NULL)
	{
		::SetLastError(E_OUTOFMEMORY);
		return NULL;
	}

	CANSIBuffer rgchCmdLine;

	if (!rgchCmdLine.FSetBufferSize(cSize))
	{
		const DWORD dwLastError = ::GetLastError();
		delete []szReturn;
		::SetLastError(dwLastError);
		return NULL;
	}

	if (!rgchCmdLine.FAddString(szCmdLine))
	{
		const DWORD dwLastError = ::GetLastError();
		delete []szReturn;
		::SetLastError(dwLastError);
		return NULL;
	}

	ULONG cActual;
	rgchCmdLine.ToUnicode(cSize, szReturn, &cActual);
	return szReturn;
}

DWORD CWin32Unicode::GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize)
{
	return ::GetEnvironmentVariableW(szName, szBuffer, nSize);
}

BOOL CWin32Unicode::MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
{ 
	return ::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags); 
}
BOOL CWin32Unicode::MoveFileW( LPCWSTR lpFrom, LPCWSTR lpTo)
{ 
	return ::MoveFileW(lpFrom, lpTo); 
}

LONG CWin32Unicode::RegDeleteValueW(HKEY hkey, LPCWSTR lpValue)
{
	return ::RegDeleteValueW(hkey, lpValue);
}

HMODULE CWin32Unicode::LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
	return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags); 
}

FARPROC CWin32Unicode::GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName)
{
	// This method does NOT have a unicode version, so we use ANSI anyways...

	CANSIBuffer rgchProcName;

	if (!rgchProcName.FFromUnicode(lpProcName))
		return NULL;

	return ::GetProcAddress(hModule, rgchProcName); 
}

BOOL CWin32Unicode::GetFileVersionInfoW(LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
	return ::GetFileVersionInfoW(lptstrFilename, dwHandle, dwLen, lpData); 
}

BOOL CWin32Unicode::VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
	return ::VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen); 
}

BOOL CWin32Unicode::GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puli1, ULARGE_INTEGER *puli2, ULARGE_INTEGER *puli3)
{
	typedef BOOL (WINAPI *PFNGETDISKFREESPACEEXW)(LPCWSTR, ULARGE_INTEGER *, ULARGE_INTEGER *, ULARGE_INTEGER *);

	static PFNGETDISKFREESPACEEXW pfn = NULL;

	if (pfn == NULL)
	{
		HINSTANCE hInstance = ::LoadLibraryA("KERNEL32.DLL");
		pfn = reinterpret_cast<PFNGETDISKFREESPACEEXW>(::GetProcAddress(hInstance, "GetDiskFreeSpaceExW"));
	}

	if (pfn != NULL)
	{
		return (*pfn)(lpRootPathName, puli1, puli2, puli3);
	}

	return g_w32A.GetDiskFreeSpaceExW(lpRootPathName, puli1, puli2, puli3);
}

DWORD CWin32Unicode::GetFullPathNameW(LPCWSTR szFile, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart)
{
	return ::GetFullPathNameW(szFile, cchBuffer, szBuffer, ppszFilePart);
}

HWND CWin32Unicode::FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
{
	return ::FindWindowW(lpClassName, lpWindowName);
}


BOOL CWin32Unicode::ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem)
{
	return (BOOL)::SendMessage(hwnd, LVM_SETITEMW, 0, (LPARAM) pitem);
}

int	CWin32Unicode::ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem)
{
	return (int)::SendMessage(hwnd, LVM_INSERTITEMW, 0, (LPARAM) pitem);
}

DWORD CWin32Unicode::GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[])
{
	return ::GetTempPathW(nBufferLength, lpBuffer);

}

DWORD CWin32Unicode::GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize)
{
	return ::GetModuleFileNameW(hModule, lpBuffer, nSize);
}


BOOL CWin32Unicode::WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
{
	return ::WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);
}

BOOL CWin32Unicode::IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
{
	return ::IsDialogMessageW(hDlg, lpMsg);
}

DWORD CWin32Unicode::GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[])
{
	return ::GetCurrentDirectoryW(nBufferLength, lpBuffer);
}

DWORD CWin32Unicode::GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer)
{
	return ::GetShortPathNameW(szPath, szBuffer, cchBuffer);
}

LRESULT CWin32Unicode::LrWmSetText(HWND hwnd, LPCWSTR szText)
{
	return ::SendMessageW(hwnd, WM_SETTEXT, 0, (LPARAM) szText);
}


//*************************************************************************************************
//ANSI method definitions


int WINAPI CWin32ANSI::MessageBoxW(HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
{
	CANSIBuffer rgchText;
	CANSIBuffer rgchCaption;

	if (!rgchText.FFromUnicode(lpText))
		return 0;

	if (!rgchCaption.FFromUnicode(lpCaption))
		return 0;

	return ::MessageBoxA(hwnd, rgchText, rgchCaption, uType);
}


LONG WINAPI CWin32ANSI::RegOpenKeyExW(HKEY hKey, LPCWSTR szKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	LPSTR lpKey;
	CANSIBuffer rgchKey;

	if (!rgchKey.FFromUnicode(szKey))
		return ::GetLastError();

	if (szKey)
		lpKey = &rgchKey[0];
	else
		lpKey = NULL;

	return ::RegOpenKeyExA(hKey, rgchKey, ulOptions, samDesired, phkResult);
}

LONG WINAPI CWin32ANSI::RegQueryValueW(HKEY hKey, LPCWSTR szValueName, WCHAR rgwchValue[], LONG *pcbValue)
{
	CANSIBuffer rgchValueName;

	if (!rgchValueName.FFromUnicode(szValueName))
		return ::GetLastError();

	CANSIBuffer rgchValue;

	ULONG cbValue = *pcbValue;
	if (!rgchValue.FSetBufferSize(cbValue))
		return ::GetLastError();

	LONG lResult = ::RegQueryValueA(hKey, rgchValueName, rgchValue, pcbValue);
	if (lResult != ERROR_SUCCESS)
		return lResult;

	// Synchronize on where the null character is.
	rgchValue.Sync();

	ULONG cchActual;
	rgchValue.ToUnicode(cbValue, rgwchValue, &cchActual);
	// ToUnicode() returns the length including the NULL character. This function does not count the NULL.
	*pcbValue = cchActual * sizeof(WCHAR);

	return lResult;
}

LONG WINAPI CWin32ANSI::RegQueryValueExW(HKEY hKey, LPCWSTR szValueName, DWORD *pdwReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbValue)
{
//	_ASSERTE(pdwReserved == NULL);
//	_ASSERTE((pbData == NULL) || (pcbValue != NULL));

	CANSIBuffer rgchValueName;
	if (!rgchValueName.FFromUnicode(szValueName))
		return ::GetLastError();

	// Is the user just checking for the existance (and maybe type) of a key?
	if (pbData == NULL
		&& pcbValue == NULL)
	{
	// If so, there is little to do.
		return ::RegQueryValueExA(hKey, rgchValueName, NULL, pdwType, NULL, NULL);
	}

	DWORD dwType;
	DWORD cbData;

	// See what type of value it is and how many bytes it needs.
	LONG lResult = ::RegQueryValueExA(hKey, rgchValueName, NULL, &dwType, NULL, &cbData);
	if (lResult != ERROR_SUCCESS)
		return lResult;

	// If it's a binary key, we don't need to play any games; just call it again.
	if ((dwType != REG_EXPAND_SZ) &&
		(dwType != REG_MULTI_SZ) &&
		(dwType != REG_SZ))
	{
		if (pbData == NULL)
			*pcbValue = cbData;
		else
			lResult = ::RegQueryValueExA(hKey, rgchValueName, pdwReserved, pdwType, pbData, pcbValue);

		return lResult;
	}

	// Ok, it's a string and it takes cbData bytes to hold it.  Let's get ready for it!
	CANSIBuffer rgchValue;
	if (!rgchValue.FSetBufferSize(cbData + 1))
		return ::GetLastError();

	cbData = rgchValue.GetBufferSize();

	// You might say, "but pbData is NULL, so we're not going to return data.  Why did we bother
	// expanding the buffer rgchValue?"  The answer is that we can't really know the byte
	// count of Unicode data unless we actually fetch the ANSI data, and run it through
	// MultiByteToWideChar().
	lResult = ::RegQueryValueExA(hKey, rgchValueName, pdwReserved, pdwType, reinterpret_cast<BYTE *>(static_cast<LPSTR>(rgchValue)), &cbData);
	if (lResult != ERROR_SUCCESS)
		return lResult;

	rgchValue.SetBufferEnd(cbData - 1);

	if (pbData == NULL)
	{
		*pcbValue = (rgchValue.GetUnicodeCch() + 1) * sizeof(WCHAR);
		return lResult;
	}

	ULONG cchActual;
	rgchValue.ToUnicode((*pcbValue) / 2, reinterpret_cast<LPWSTR>(pbData), &cchActual);
	// ToUnicode() returns the length including the NULL character. This function does not count the NULL.
	*pcbValue = cchActual * sizeof(WCHAR);

	return lResult;
}

UINT WINAPI CWin32ANSI::GetSystemDirectoryW(WCHAR szSystemDirectory[], UINT uSize)
{
	CANSIBuffer rgchSystemDirectory;

	if (!rgchSystemDirectory.FSetBufferSize((uSize * 2) + 1))
		return ::GetLastError();

	UINT uReturn = ::GetSystemDirectoryA(rgchSystemDirectory, uSize);
	if (uReturn != 0)
	{
		ULONG cchActual;
		rgchSystemDirectory.Sync();
		rgchSystemDirectory.ToUnicode(uSize, szSystemDirectory, &cchActual);
	}

	return uReturn;
}

UINT WINAPI CWin32ANSI::GetTempFileNameW(LPCWSTR szPathName,LPCWSTR szPrefixString,UINT uUnique,LPWSTR szTempFileName)
{
	CANSIBuffer rgchPathName, rgchPrefixString;
	CANSIBuffer rgchBuffer;
	if (!rgchBuffer.FSetBufferSize((MSINFHLP_MAX_PATH * sizeof(WCHAR)) + 1))
		return 0;
	UINT rv;

	if (!rgchPathName.FFromUnicode(szPathName))
		return 0;

	if (!rgchPrefixString.FFromUnicode(szPrefixString))
		return 0;

	if (0==(rv=::GetTempFileNameA(rgchPathName,rgchPrefixString,uUnique,rgchBuffer)))
		return 0;

	rgchBuffer.Sync();
	ULONG cchActual;
	rgchBuffer.ToUnicode(MSINFHLP_MAX_PATH+1, szTempFileName, &cchActual);
	
	return rv;
}

BOOL WINAPI CWin32ANSI::CopyFileW(LPCWSTR szSource, LPCWSTR szDest, BOOL fFailIfExists)
{
	CANSIBuffer rgchSource, rgchDest;
	if (!rgchSource.FFromUnicode(szSource))
		return FALSE;
	if (!rgchDest.FFromUnicode(szDest))
		return FALSE;
	return ::CopyFileA(rgchSource, rgchDest, fFailIfExists);
}

BOOL WINAPI CWin32ANSI::SetFileAttributesW(LPCWSTR szSource, DWORD dwFileAttributes)
{
	CANSIBuffer rgchSource;
	if (!rgchSource.FFromUnicode(szSource))
		return FALSE;
	return ::SetFileAttributesA(rgchSource, dwFileAttributes);
}

BOOL WINAPI CWin32ANSI::CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
//	_ASSERTE(lpSecurityAttributes == NULL || lpSecurityAttributes->lpSecurityDescriptor == NULL);
//	_ASSERTE(lpSecurityAttributes == NULL || lpSecurityAttributes->nLength == sizeof(*lpSecurityAttributes));
	CANSIBuffer rgchPathName;
	if (!rgchPathName.FFromUnicode(lpPathName))
		return FALSE;
	return ::CreateDirectoryA(rgchPathName, lpSecurityAttributes);
}
BOOL WINAPI CWin32ANSI::RemoveDirectoryW(LPCWSTR lpPathName)
{
	CANSIBuffer rgchPathName;
	if (!rgchPathName.FFromUnicode(lpPathName))
		return FALSE;
	return ::RemoveDirectoryA(rgchPathName);
}

HANDLE WINAPI CWin32ANSI::CreateFileW(LPCWSTR szFilename, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
						DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	CANSIBuffer rgchFilename;

	if (!rgchFilename.FFromUnicode(szFilename))
		return INVALID_HANDLE_VALUE;

	return ::CreateFileA(rgchFilename, dwDesiredAccess, dwShareMode, lpsa, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile);
}

HMODULE WINAPI CWin32ANSI::GetModuleHandleW(LPCWSTR lpw)
{
	CANSIBuffer rgchBuffer;
	if (!rgchBuffer.FFromUnicode(lpw))
		return NULL;
	return ::GetModuleHandleA(rgchBuffer);
}

DWORD WINAPI CWin32ANSI::GetFileAttributesW(LPCWSTR lpFilename)
{
	CANSIBuffer rgchBuffer;

	if (!rgchBuffer.FFromUnicode(lpFilename))
		return 0xffffffff;

	return ::GetFileAttributesA(rgchBuffer);
}


DWORD WINAPI CWin32ANSI::FormatMessageW
(
DWORD dwFlags,
LPCVOID lpSource,
DWORD dwMessageId,
DWORD dwLanguageId,
LPWSTR lpBuffer,
DWORD nSize,
va_list *pvaArguments
)
{
	// I don't want to deal with trying to figure out what exactly a va_list really
	// points to.
//	_ASSERTE((pvaArguments == NULL) || (dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY));

	CANSIBuffer szSource;
	
	LPCVOID lpSource_A = lpSource; // this is the lpSource we'll pass into FormatMessageA()

	// Major branch: is lpSource a string of an HINSTANCE?
	if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
	{
//		_ASSERTE((dwFlags & FORMAT_MESSAGE_FROM_HMODULE) == 0);

		if (!szSource.FFromUnicode((LPCOLESTR) lpSource))
			return 0;

		lpSource_A = (LPCVOID) (static_cast<LPSTR>(szSource));
	}

	CANSIBuffer szBuffer;				// for if it's not FORMAT_MESSAGE_ALLOCATE_BUFFER
	LPSTR szBuffer_LocalAlloc = NULL;	// for it is FORMAT_MESSAGE_ALLOCATE_BUFFER

	LPSTR lpBuffer_A = NULL;

	if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
		lpBuffer_A = (LPSTR) &szBuffer_LocalAlloc;
	else
	{
		if (!szBuffer.FSetBufferSize(nSize))
			return 0;

		lpBuffer_A = szBuffer;
	}

	// Assume that pvaArguents is a pointer to NULL-terminated array of LPCOLESTRs.
	LPCOLESTR *prgszArguments = (LPCOLESTR *) pvaArguments;
	LPSTR *prgszArguments_A = NULL;
	ULONG cArguments = 0;

	if (prgszArguments != NULL)
	{
		for (cArguments = 0; prgszArguments[cArguments] != NULL; cArguments++)
			;

		prgszArguments_A = new LPSTR[cArguments];
		if (NULL == prgszArguments_A)
			return 0;

		ULONG i;

		for (i=0; i<cArguments; i++)
			prgszArguments_A[i] = NULL;

		for (i=0; i<cArguments; i++)
		{
			int iResult = ::WideCharToMultiByte(CP_ACP, 0, prgszArguments[i], -1, NULL, 0, NULL, NULL);
			if (iResult == 0)
				continue;

			prgszArguments_A[i] = new CHAR[iResult];
			// We can't really throw an error; we'll silently continue if the alloc failed.

			// If an allocation fails, don't continue with the rest of the arglist, or we might
			// have an array with "holes" in it.
			if (NULL == prgszArguments_A[i])
				break;

			::WideCharToMultiByte(CP_ACP, 0, prgszArguments[i], -1, prgszArguments_A[i], iResult, NULL, NULL);
		}
	}

	DWORD dwResult = ::FormatMessageA(dwFlags, lpSource_A, dwMessageId, dwLanguageId, lpBuffer_A, nSize, (va_list *) prgszArguments_A);
	if (dwResult != 0)
	{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
		{
			int iResult = ::MultiByteToWideChar(CP_ACP, 0, szBuffer_LocalAlloc, -1, NULL, 0);
//			_ASSERTE(iResult != 0);

			LPWSTR pwstr = reinterpret_cast<LPWSTR>(::LocalAlloc(LMEM_FIXED, iResult * sizeof(WCHAR)));
			if (pwstr != NULL)
				dwResult = ::MultiByteToWideChar(CP_ACP, 0, szBuffer_LocalAlloc, -1, pwstr, iResult) - 1;
			else
			{
				dwResult = 0;
				::SetLastError( ERROR_OUTOFMEMORY );
			}
			*((LPWSTR *) lpBuffer) = pwstr;

			::LocalFree(szBuffer_LocalAlloc);
		}
		else
			dwResult = ::MultiByteToWideChar(CP_ACP, 0, szBuffer, -1, lpBuffer, nSize) - 1;
	}

	if (prgszArguments_A != NULL)
	{
//		CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
		for (ULONG i=0; i<cArguments; i++)
		{
			if (prgszArguments_A[i] != NULL)
			{
				delete []prgszArguments_A[i];
				prgszArguments_A[i] = NULL;
			}
		}

		delete []prgszArguments_A;
		prgszArguments_A = NULL;
	}

	return dwResult;
}

int WINAPI CWin32ANSI::LCMapStringW(LCID lcid, DWORD dwMapFlags, LPCWSTR szIn, int cchIn, LPWSTR szOut, int cchOut)
{
	CANSIBuffer rgchIn;
	CANSIBuffer rgchOut;

	if (!rgchIn.FFromUnicode(szIn, cchIn))
		return 0;

	int iResult = 0;
	int cachIn = -1;

	if (cchIn != -1)
		cachIn = strlen(rgchIn);

	// If cchOut is zero, we need to determine the correct number of Unicode characters; we can't
	// actually do that without getting the ANSI string and converting.
	if (cchOut == 0)
	{
		iResult = ::LCMapStringA(lcid, dwMapFlags, rgchIn, cachIn, NULL, 0);
		if (iResult != 0)
		{
			if (!rgchOut.FSetBufferSize(iResult))
				return 0;

			iResult = ::LCMapStringA(lcid, dwMapFlags, rgchIn, cachIn, rgchOut, rgchOut.GetBufferSize());
			if (iResult != 0)
			{
				rgchOut.SetBufferEnd(iResult);
				iResult = rgchOut.GetUnicodeCch() + 1;
			}
		}
	}
	else
	{
		int cachOut = 0;

		iResult = ::LCMapStringA(lcid, dwMapFlags, rgchIn, cachIn, NULL, 0);
		if (iResult != 0)
		{
			if (!rgchOut.FSetBufferSize(iResult))
				return 0;

			iResult = ::LCMapStringA(lcid, dwMapFlags, rgchIn, cachIn, rgchOut, rgchOut.GetBufferSize());
			if (iResult != 0)
			{
				rgchOut.Sync();
				ULONG cchActual;
				rgchOut.ToUnicode(cchOut, szOut, &cchActual);
				iResult = cchActual + 1;
			}
		}
	}

	return iResult;
}

HMODULE WINAPI CWin32ANSI::LoadLibraryW(LPCWSTR lpLibFileName)
{
	CANSIBuffer rgchLibFileName;
	if (!rgchLibFileName.FFromUnicode(lpLibFileName))
		return NULL;
	return ::LoadLibraryA(rgchLibFileName);
}

LPITEMIDLIST WINAPI CWin32ANSI::SHBrowseForFolderW
(
	LPBROWSEINFOW browseInfoW
)
{
	BROWSEINFOA browseInfoA;

	// this buffer receives output
	CANSIBuffer displayName;
	if (!displayName.FSetBufferSize(MSINFHLP_MAX_PATH+1))
		return NULL;

	// this one is just for input
	CANSIBuffer title;
	if (!title.FFromUnicode(browseInfoW->lpszTitle))
		return NULL;

	browseInfoA.hwndOwner=browseInfoW->hwndOwner;
	browseInfoA.pidlRoot=browseInfoW->pidlRoot;
	browseInfoA.pszDisplayName=displayName;
	browseInfoA.lpszTitle=title;
	browseInfoA.ulFlags=browseInfoW->ulFlags;

/*
Note
There's a callback function here, but it doesn't ever receive chars in the current implementation, so it doesn't need
to be A/W thunked
*/

	browseInfoA.lpfn=browseInfoW->lpfn;
	browseInfoA.lParam=browseInfoW->lParam;
	browseInfoA.iImage=0;

	LPITEMIDLIST returnValue=::SHBrowseForFolderA(&browseInfoA);

	// backpatch the results

	displayName.Sync();
	displayName.ToUnicode(MSINFHLP_MAX_PATH+1, browseInfoW->pszDisplayName, NULL);
	browseInfoW->iImage=browseInfoA.iImage;

	return returnValue;
}

LONG CWin32ANSI::RegCreateKeyExW
(
	HKEY key, 
	LPCWSTR subKeyW,
	DWORD reserved, 
	LPWSTR keyClassW, 
	DWORD options, 
	REGSAM securityDesired,
	LPSECURITY_ATTRIBUTES securityAttributes,  
	PHKEY resultKey, 
	LPDWORD disposition
)
{
	CANSIBuffer subKeyA;
	if (!subKeyA.FFromUnicode(subKeyW))
		return ::GetLastError();

	CANSIBuffer keyClassA;
	if (!keyClassA.FFromUnicode(keyClassW))
		return ::GetLastError();

	// Conservative: We know nothing about classes, so all we can assume about the buffer is that it's large enough to hold
	// what it currently holds
	int len=keyClassW ? wcslen(keyClassW) : 0;

	long returnValue=::RegCreateKeyExA(key, subKeyA, reserved, keyClassA, options, securityDesired, securityAttributes, resultKey, disposition);

	if(keyClassW)
	{
		keyClassA.Sync();
		keyClassA.ToUnicode(len, keyClassW, NULL);
	}

	return returnValue;
}

LONG CWin32ANSI::RegSetValueExW
(
	HKEY key, 
	LPCWSTR valueNameW,
	DWORD reserved, 
	DWORD type, 
	CONST BYTE *dataW, 
	DWORD dataSize
)
{
	CANSIBuffer valueNameA;
	if (!valueNameA.FFromUnicode(valueNameW))
		return ::GetLastError();

	CANSIBuffer dataBufferA;

	CONST BYTE *dataA=dataW;
	switch(type)
	{
		case REG_MULTI_SZ:
			// can't be bothered to wrap this since I don't need it. If you need it, you can wrap it here.
//			_ASSERTE(FALSE);
			break;

		case REG_EXPAND_SZ:
		case REG_SZ:
			if (!dataBufferA.FFromUnicode((LPCWSTR)dataW))
				return ::GetLastError();

			dataA=(LPBYTE)(LPSTR)dataBufferA;
			dataSize/=2;
			break;

		default:
			// do nothing, deliberate
			break;
	}

	return ::RegSetValueExA(key, valueNameA, reserved, type, dataA, dataSize);
}


BOOL WINAPI CWin32ANSI::DeleteFileW(LPCWSTR szFilename)
{
	CANSIBuffer rgchFilename;

	if (!rgchFilename.FFromUnicode(szFilename))
		return FALSE;

	return ::DeleteFileA(rgchFilename);
}

BOOL WINAPI CWin32ANSI::SetWindowTextW(HWND window, LPCWSTR textW)
{
	CANSIBuffer textA;

	if (!textA.FFromUnicode(textW))
		return FALSE;

	return ::SetWindowTextA(window, textA);
}

HANDLE WINAPI CWin32ANSI::LoadImageW(HINSTANCE hInstance, LPCWSTR szName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad)
{
	CANSIBuffer rgchName;
	LPCSTR lpcstrName = NULL;

	if (HIWORD(szName) == 0)
	{
		// It's actually a resource ID; just cast it.
		lpcstrName = (LPCSTR) szName;
	}
	else
	{
		if (!rgchName.FFromUnicode(szName))
			return NULL;

		lpcstrName = rgchName;
	}

	return ::LoadImageA(hInstance, lpcstrName, uType, cxDesired, cyDesired, fuLoad);
}

int WINAPI CWin32ANSI::CompareStringW(LCID lcid, DWORD dwCmpFlags, LPCWSTR szString1, int cchString1, LPCWSTR szString2, int cchString2)
{
	CANSIBuffer rgchString1, rgchString2;

	if (!rgchString1.FFromUnicode(szString1, cchString1))
		return 0;

	if (!rgchString2.FFromUnicode(szString2, cchString2))
		return 0;

	return ::CompareStringA(lcid, dwCmpFlags, rgchString1, strlen(rgchString1), rgchString2, strlen(rgchString2));
}

static void CopyAToW(const LPWIN32_FIND_DATAA ap, LPWIN32_FIND_DATAW wp)
{
// copy the first fields, assuming the reserved ones are A/W independent
	wp->dwFileAttributes = ap->dwFileAttributes;
	wp->ftCreationTime = ap->ftCreationTime; 
	wp->ftLastAccessTime = ap->ftLastAccessTime;
	wp->ftLastWriteTime = ap->ftLastWriteTime; 
	wp->nFileSizeHigh = ap->nFileSizeHigh;
	wp->nFileSizeLow = ap->nFileSizeLow; 
	wp->dwReserved0 = ap->dwReserved0;
	wp->dwReserved1 = ap->dwReserved1;
// copy the two strings.
	::MultiByteToWideChar(
			CP_ACP,
			0,
			ap->cFileName,
			-1,
			wp->cFileName,
			sizeof(wp->cFileName)/sizeof(wp->cFileName[0]));
	::MultiByteToWideChar(
			CP_ACP,
			0,
			ap->cAlternateFileName,
			-1,
			wp->cAlternateFileName,
			sizeof(wp->cAlternateFileName)/sizeof(wp->cAlternateFileName[0]));
}

static void CopyWToA(const LPWIN32_FIND_DATAW wp, LPWIN32_FIND_DATAA ap)
{
// copy the first fields, assuming the reserved ones are A/W independent
	ap->dwFileAttributes = wp->dwFileAttributes;
	ap->ftCreationTime = wp->ftCreationTime; 
	ap->ftLastAccessTime = wp->ftLastAccessTime;
	ap->ftLastWriteTime = wp->ftLastWriteTime; 
	ap->nFileSizeHigh = wp->nFileSizeHigh;
	ap->nFileSizeLow = wp->nFileSizeLow; 
	ap->dwReserved0 = wp->dwReserved0;
	ap->dwReserved1 = wp->dwReserved1;
// copy the two strings.
	::WideCharToMultiByte(
			CP_ACP,
			0,
			wp->cFileName,
			-1,
			ap->cFileName,
			sizeof(ap->cFileName)/sizeof(ap->cFileName[0]),
			NULL,
			NULL);
	::WideCharToMultiByte(
			CP_ACP,
			0,
			wp->cAlternateFileName,
			-1,
			ap->cAlternateFileName,
			sizeof(ap->cAlternateFileName)/sizeof(ap->cAlternateFileName[0]),
			NULL,
			NULL);
}

HANDLE WINAPI CWin32ANSI::FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileDataW)
{
	CANSIBuffer rgFileName;

	if (!rgFileName.FFromUnicode(lpFileName))
		return INVALID_HANDLE_VALUE;

	WIN32_FIND_DATAA findFileDataA; // can be used uninitialized.
	HANDLE h = ::FindFirstFileA(rgFileName, &findFileDataA);
	{
//		CPreserveLastError le; // Preserve current last error setting, and reset upon destruction
		CopyAToW(&findFileDataA, lpFindFileDataW);
	}
	return h;
}

int WINAPI CWin32ANSI::DialogBoxParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	CANSIBuffer rgchTemplateName;
	LPCSTR lpcstrTemplateName = NULL;

	if (HIWORD(szTemplateName) == 0)
		lpcstrTemplateName = reinterpret_cast<LPCSTR>(szTemplateName);
	else
	{
		if (!rgchTemplateName.FFromUnicode(szTemplateName))
			return -1;

		lpcstrTemplateName = rgchTemplateName;
	}

	return ::DialogBoxParamA(hInstance, lpcstrTemplateName, hwndParent, lpDialogProc, dwInitParam);
}

HWND WINAPI CWin32ANSI::CreateDialogParamW(HINSTANCE hInstance, LPCWSTR szTemplateName, HWND hwndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	CANSIBuffer rgchTemplateName;
	LPCSTR lpcstrTemplateName = NULL;

	if (HIWORD(szTemplateName) == 0)
		lpcstrTemplateName = reinterpret_cast<LPCSTR>(szTemplateName);
	else
	{
		if (!rgchTemplateName.FFromUnicode(szTemplateName))
			return NULL;
		lpcstrTemplateName = rgchTemplateName;
	}

	return ::CreateDialogParamA(hInstance, lpcstrTemplateName, hwndParent, lpDialogProc, dwInitParam);
}

BOOL WINAPI CWin32ANSI::CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation )
{
	CANSIBuffer rgchApplicationName, rgchCommandLine, rgchCurrentDirectory, rgchEnvironment;
    STARTUPINFOA si;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

    if (lpApplicationName)
	{
		if (!rgchApplicationName.FFromUnicode(lpApplicationName))
			return FALSE;
	}

    if (lpCommandLine)
	{
		if (!rgchCommandLine.FFromUnicode(lpCommandLine))
			return FALSE;
	}

    if (lpCurrentDirectory)
	{
		if (!rgchCurrentDirectory.FFromUnicode(lpCurrentDirectory))
			return FALSE;
	}
//    VSASSERT(lpEnvironment == NULL, L"Can't handle environment strings yet."));

    // Copy and convert startup info as needed
	CANSIBuffer rgchDesktop, rgchTitle;
    if (lpStartupInfo->lpDesktop)
	{
        if (!rgchDesktop.FFromUnicode(lpStartupInfo->lpDesktop))
			return FALSE;
	}

    si.lpDesktop       = lpStartupInfo->lpDesktop ? rgchDesktop : (char *) NULL;

    if (lpStartupInfo->lpTitle)
	{
		if (!rgchTitle.FFromUnicode(lpStartupInfo->lpTitle))
			return FALSE;
	}

    si.lpTitle         = lpStartupInfo->lpTitle ? rgchTitle : (char *) NULL;
    si.dwX             = lpStartupInfo->dwX;
    si.dwY             = lpStartupInfo->dwY;
    si.dwXSize         = lpStartupInfo->dwXSize;
    si.dwYSize         = lpStartupInfo->dwYSize;
    si.dwXCountChars   = lpStartupInfo->dwXCountChars;
    si.dwYCountChars   = lpStartupInfo->dwYCountChars;
    si.dwFillAttribute = lpStartupInfo->dwFillAttribute;
    si.dwFlags         = lpStartupInfo->dwFlags;
    si.wShowWindow     = lpStartupInfo->wShowWindow;
    si.hStdInput       = lpStartupInfo->hStdInput;
    si.hStdOutput      = lpStartupInfo->hStdOutput;
    si.hStdError       = lpStartupInfo->hStdError;

    dwCreationFlags &= ~(CREATE_UNICODE_ENVIRONMENT);

	return ::CreateProcessA(lpApplicationName ? rgchApplicationName : (char *) NULL,
                            lpCommandLine ? rgchCommandLine : (char *) NULL,
                            lpProcessAttributes, lpThreadAttributes, bInheritHandles,
                            dwCreationFlags,
                            lpEnvironment ? rgchEnvironment : (char *) NULL,
                            lpCurrentDirectory ? rgchCurrentDirectory : (char *) NULL,
                            &si, lpProcessInformation );
}

HRSRC WINAPI CWin32ANSI::FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
//	VsNoThrow();

	LPCSTR lpaName = NULL;
	LPCSTR lpaType = NULL;

	CVsANSIBuffer rgachName;
	CVsANSIBuffer rgachType;

	if (HIWORD(lpName) == 0)
		lpaName = (LPCSTR) lpName;
	else
	{
		if (!rgachName.FFromUnicode(lpName))
			return NULL;

		lpaName = rgachName;
	}

	if (HIWORD(lpType) == 0)
		lpaType = (LPCSTR) lpType;
	else
	{
		if (!rgachType.FFromUnicode(lpType))
			return NULL;

		lpaType = rgachType;
	}

	return ::FindResourceA(hModule, lpaName, lpaType);
}


DWORD CWin32ANSI::SHGetFileInfoW(LPCWSTR wszPath, DWORD dwFileAttributes, SHFILEINFOW *pshfi, UINT cbFileInfo, UINT uFlags) throw ()
{
//	VSASSERT(cbFileInfo == sizeof(SHFILEINFOW), L"Bad SHFILEINFOW size passed in"));

	CANSIBuffer rgchPath;

	if (!rgchPath.FFromUnicode(wszPath))
		return 0;

	SHFILEINFOA shfi;

	DWORD dwResult = ::SHGetFileInfoA(rgchPath, dwFileAttributes, &shfi, sizeof(shfi), uFlags);
	{
		const DWORD dwLastError = ::GetLastError();

		if (uFlags & (SHGFI_DISPLAYNAME | SHGFI_ICONLOCATION))
		{
			if (::MultiByteToWideChar(CP_ACP, 0, shfi.szDisplayName, -1, pshfi->szDisplayName, NUMBER_OF(pshfi->szDisplayName)) == 0)
				return 0;
		}

		if (uFlags & SHGFI_TYPENAME)
		{
			if (::MultiByteToWideChar(CP_ACP, 0, shfi.szTypeName, -1, pshfi->szTypeName, NUMBER_OF(pshfi->szTypeName)) == 0)
				return 0;
		}

		if (uFlags & SHGFI_ICON)
		{
			// The docs claim that SHGFI_ICON gives the HICON, system image list index and the system image list.
			pshfi->hIcon = shfi.hIcon;
			pshfi->iIcon = shfi.iIcon;
		}

		if (uFlags & SHGFI_SYSICONINDEX)
			pshfi->iIcon = shfi.iIcon;

		if (uFlags & SHGFI_ATTRIBUTES)
			pshfi->dwAttributes = shfi.dwAttributes;

		::SetLastError(dwLastError);
	}
	return dwResult;
}

BOOL CWin32ANSI::SHGetPathFromIDListW( LPCITEMIDLIST pidl, LPWSTR pszPath ) throw ()
{
	CANSIBuffer rgchBuffer;

	// Unfortunately, SHGetPathFromIDListA() doesn't reliably return a failure/success code
	// so, we've got to do a little extra work
	::SetLastError(ERROR_SUCCESS);
	BOOL rval = ::SHGetPathFromIDListA( pidl, rgchBuffer );
	if (FALSE == rval && ::GetLastError() != 0)
	{
		::VLog(L"In CWin32ANSI::SHGetPathFromIDListW( ), SHGetPathFromIDListA() call failed, last error = '%d'", ::GetLastError());
	}
	else
	{
		rval = TRUE;
		rgchBuffer.Sync();
		DWORD cchActual;
		rgchBuffer.ToUnicode(_MAX_PATH, pszPath, &cchActual);
	}

	return rval;
}


ATOM CWin32ANSI::RegisterClassExW(CONST WNDCLASSEXW *lpwcx)
{
	CANSIBuffer rgchMenuName;
	CANSIBuffer rgchClassName;

	if (!rgchMenuName.FFromUnicode(lpwcx->lpszMenuName))
		return 0;

	if (!rgchClassName.FFromUnicode(lpwcx->lpszClassName))
		return 0;

	WNDCLASSEXA wc;
	wc.cbSize = sizeof(WNDCLASSEXA);
	wc.style = lpwcx->style;
	wc.lpfnWndProc = (WNDPROC)lpwcx->lpfnWndProc;
	wc.cbClsExtra = lpwcx->cbClsExtra;
	wc.cbWndExtra = lpwcx->cbWndExtra;
	wc.hInstance = lpwcx->hInstance;
	wc.hIcon = lpwcx->hIcon;
	wc.hCursor = lpwcx->hCursor;
	wc.hbrBackground = (HBRUSH)lpwcx->hbrBackground;

	wc.lpszMenuName = rgchMenuName;
	wc.lpszClassName = rgchClassName;
	wc.hIconSm = lpwcx->hIconSm;

	//register this class!!
	return ::RegisterClassExA(&wc);
}

BOOL CWin32ANSI::UnregisterClassW(LPCOLESTR lpClassName, HINSTANCE hInstance)
{
	CANSIBuffer rgchClassName;

	if (!rgchClassName.FFromUnicode(lpClassName))
		return 0;

	return ::UnregisterClassA(rgchClassName, hInstance);
}

HWND CWin32ANSI::CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight,
							HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
	CANSIBuffer rgchClassName;
	CANSIBuffer rgchWindowName;

	if (!rgchClassName.FFromUnicode(lpClassName))
		return NULL;

	if (!rgchWindowName.FFromUnicode(lpWindowName))
		return NULL;

	return ::CreateWindowExA(dwExStyle, rgchClassName, rgchWindowName, dwStyle, x, y, nWidth, nHeight,
							hWndParent, hMenu, hInstance, lpParam);
}
DWORD CWin32ANSI::GetFileVersionInfoSizeW(LPOLESTR lptstrFilename, LPDWORD lpdwHandle)
{
	CANSIBuffer rgchWindowName;
	
	if (!rgchWindowName.FFromUnicode(lptstrFilename))
		return 0;

	return ::GetFileVersionInfoSizeA(rgchWindowName, lpdwHandle);
}
UINT CWin32ANSI::GetWindowsDirectoryW(WCHAR lpBuffer[], UINT uSize)
{
	CANSIBuffer rgchBuffer;
	if (!rgchBuffer.FSetBufferSize((uSize + 1) * sizeof(WCHAR)))
		return 0;

	UINT rv = ::GetWindowsDirectoryA(rgchBuffer, uSize);

	rgchBuffer.Sync();
	ULONG cchActual;
	rgchBuffer.ToUnicode(uSize, lpBuffer, &cchActual);

	return rv;
}

UINT CWin32ANSI::GetDlgItemTextW(HWND hDlg, int nIDDlgItem, WCHAR lpString[], int nMaxCount)
{
	CANSIBuffer rgchBuffer;
	if (!rgchBuffer.FSetBufferSize((nMaxCount + 1) * sizeof(WCHAR)))
		return 0;

	UINT rv = ::GetDlgItemTextA(hDlg, nIDDlgItem, rgchBuffer, nMaxCount);

	rgchBuffer.Sync();
	ULONG cchActual;
	rgchBuffer.ToUnicode(nMaxCount, lpString, &cchActual);

	return rv;

}

BOOL CWin32ANSI::SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCOLESTR lpString)
{
	CANSIBuffer rgchString;
	if (!rgchString.FFromUnicode(lpString))
		return FALSE;

	return ::SetDlgItemTextA(hDlg, nIDDlgItem, rgchString);
}

LONG CWin32ANSI::RegDeleteKeyW(HKEY hkey, LPCWSTR lpSubKey)
{
	CANSIBuffer rgchSubKey;
	if (!rgchSubKey.FFromUnicode(lpSubKey))
		return ::GetLastError();

	return ::RegDeleteKeyA(hkey, rgchSubKey);
}

LONG CWin32ANSI::RegDeleteValueW(HKEY hkey, LPCWSTR lpValue)
{
	CANSIBuffer rgchValue;
	if (!rgchValue.FFromUnicode(lpValue))
		return ::GetLastError();

	return ::RegDeleteValueA(hkey, rgchValue);
}

LPOLESTR CWin32ANSI::GetCommandLineW()
{
	LPSTR szCmdLine = ::GetCommandLineA();
	LPOLESTR szReturn = NULL;

	int iSize = ::MultiByteToWideChar(CP_ACP, 0, szCmdLine, -1, NULL, 0);
	if (iSize > 0)
	{
		szReturn = (LPOLESTR) ::GlobalAlloc(GPTR, iSize * sizeof(WCHAR));
		if (szReturn != NULL)
		{
			::MultiByteToWideChar(CP_ACP, 0, szCmdLine, -1, szReturn, iSize);
		}
	}

	return szReturn;
}

DWORD CWin32ANSI::GetEnvironmentVariableW(LPCWSTR szName, LPWSTR szBuffer, DWORD nSize)
{
	CANSIBuffer rgachName;
	if (!rgachName.FFromUnicode(szName))
		return 0;

	CANSIBuffer rgachBuffer;
	if (!rgachBuffer.FSetBufferSize(nSize * 2))
		return 0;

	DWORD dwResult = ::GetEnvironmentVariableA(rgachName, rgachBuffer, rgachBuffer.GetBufferSize());
	if (dwResult != 0)
	{
		rgachBuffer.Sync();
		rgachBuffer.ToUnicode(nSize, szBuffer, &dwResult);
	}
	return dwResult;
}

BOOL CWin32ANSI::MoveFileExW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
{
	BOOL fResult = FALSE;

	if (!(dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT))
	{
		CANSIBuffer rgchFrom, rgchTo;
		if (!rgchFrom.FFromUnicode(lpExistingFileName))
			return FALSE;

		if (!rgchTo.FFromUnicode(lpNewFileName))
			return FALSE;

		if (dwFlags & MOVEFILE_COPY_ALLOWED)
		{
			if (dwFlags & MOVEFILE_REPLACE_EXISTING)
			{
				fResult = ::CopyFileA(rgchFrom, rgchTo, FALSE);
			}
			else
			{
				fResult = ::CopyFileA(rgchFrom, rgchTo, TRUE);
			}
		}
		else
		{
			if (dwFlags & MOVEFILE_REPLACE_EXISTING)
			{
				::SetLastError(ERROR_FILENAME_EXCED_RANGE);
				fResult = FALSE;
			}
			else
			{
				fResult = ::MoveFileA(rgchFrom, rgchTo);
			}
		}
	}
	else
	{
		// You can't have your cake and eat it too; only renames permitted on reboot.
		if (dwFlags & MOVEFILE_COPY_ALLOWED)
		{
			::SetLastError(ERROR_INVALID_PARAMETER);
			goto Finish;
		}

		WCHAR wszNewShortFName[_MAX_FNAME];
		WCHAR wszNewShortExt[_MAX_EXT];
		WCHAR wszNewLongFName[_MAX_FNAME];
		WCHAR wszNewLongExt[_MAX_EXT];

		WCHAR wszTemp[_MAX_PATH];
		WCHAR wszExistingShort[_MAX_PATH];
		WCHAR wszNewShort[_MAX_PATH];
		LPSTR pszWinInit = NULL;
		LPSTR pszWinInitEnd = NULL;
		LPSTR pszRenameSecInFile = NULL;
		LPSTR pszNewShort = NULL;
		LPSTR pszTemp1 = NULL;
		LPSTR pszTemp2 = NULL;
		CANSIBuffer szExistingShort;
		CANSIBuffer szNewShort;

		DWORD dwAttr = NVsWin32::GetFileAttributesW(lpExistingFileName);
		if (dwAttr == 0xffffffff)
		{
			::VLog(L"Attempt to get file attributes for file \"%s\" failed; last error = %d", lpExistingFileName, ::GetLastError());
			goto Finish;
		}

		if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
		{
			wcsncpy(wszTemp, lpExistingFileName, NUMBER_OF(wszTemp));
			wszTemp[NUMBER_OF(wszTemp) - 1] = L'\0';

			wcscat(wszTemp, L"\\");

			if (!NVsWin32::GetShortPathNameW(wszTemp, wszExistingShort, NUMBER_OF(wszExistingShort)))
			{
				::VLog(L"Attempt to get short name for directory \"%s\" failed; last error = %d", wszTemp, ::GetLastError());
				goto Finish;
			}
		}
		else
		{
			if (!NVsWin32::GetShortPathNameW(lpExistingFileName, wszExistingShort, NUMBER_OF(wszExistingShort)))
			{
				::VLog(L"Attempt to get short path name for \"%s\" failed; last error = %d", lpExistingFileName, ::GetLastError());
				goto Finish;
			}
		}

		::VLog(L"Translated existing filename: \"%s\" to short name: \"%s\"", lpExistingFileName, wszExistingShort);

		if (lpNewFileName != NULL)
		{
			::VLog(L"Getting short path name for destination: \"%s\"", lpNewFileName);

			if (!NVsWin32::GetShortPathNameW(lpNewFileName, wszNewShort, NUMBER_OF(wszNewShort)))
			{
				::VLog(L"Attempt to get short path name failed; last error = %d", ::GetLastError());
				goto Finish;
			}

			_wsplitpath(lpNewFileName, NULL, NULL, wszNewLongFName, wszNewLongExt);
			_wsplitpath(wszNewShort, NULL, NULL, wszNewShortFName, wszNewShortExt);

			// if the target filename is a long name, this just plain won't work.
			if ((_wcsicmp(wszNewLongFName, wszNewShortFName) != 0) ||
				(_wcsicmp(wszNewLongExt, wszNewShortExt) != 0))
			{
				::VLog(L"Target filename on reboot too long; we can't handle this.");
				::SetLastError(ERROR_FILENAME_EXCED_RANGE);
				fResult = FALSE;
				goto Finish;
			}

			if (!szNewShort.FFromUnicode(wszNewShort))
				return FALSE;

			pszNewShort = szNewShort;
		}

		if (!szExistingShort.FFromUnicode(wszExistingShort))
			return FALSE;

		CHAR szRenameLine[MSINFHLP_MAX_PATH];

		int cchRenameLine = wsprintfA(szRenameLine, "%s=%s\r\n", pszNewShort != NULL ? pszNewShort : "NUL", static_cast<LPSTR>(szExistingShort));

		::VLog(L"We're going to add the rename line \"%S\" to wininit.ini...", szRenameLine);

		char szRenameSec[] = "[Rename]\r\n";
		int cchRenameSec = sizeof(szRenameSec) - 1;
		HANDLE hFile = INVALID_HANDLE_VALUE;
		HANDLE hFilemap = INVALID_HANDLE_VALUE;
		DWORD dwFileSize, dwRenameLinePos;
		CHAR szPathnameWinInit[_MAX_PATH];

		// Construct the full pathname of the WININIT.INI file.
		if (::GetWindowsDirectoryA(szPathnameWinInit, NUMBER_OF(szPathnameWinInit)) == 0)
		{
			::VLog(L"Unable to get windows directory; last error = %d", ::GetLastError());
			fResult = FALSE;
			goto Finish;
		}

		// It's almost unbelievable that this strcat() isn't safe.  If the windows directory path
		// plus an 8.3 filename doesn't fit, the OS is probably pretty hosed.  -mgrier
		strcat(szPathnameWinInit, "\\WinInit.Ini");

		// Open/Create the WININIT.INI file.
		hFile = ::CreateFileA(
						szPathnameWinInit,
						GENERIC_READ | GENERIC_WRITE,
						0,
						NULL,
						OPEN_ALWAYS,
						FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			::VLog(L"Unable to open wininit.ini; last error = %d", ::GetLastError());
			goto Finish;
		}

		// Create a file mapping object that is the current size of 
		// the WININIT.INI file plus the length of the additional string
		// that we're about to insert into it plus the length of the section
		// header (which we might have to add).
		dwFileSize = ::GetFileSize(hFile, NULL);
		if (dwFileSize == 0xffffffff)
		{
			::VLog(L"Unable to get filesize of wininit.ini; last error = %d", ::GetLastError());
			goto Finish;
		}

		::VLog(L"Current wininit.ini file size: %d bytes", dwFileSize);

		ULONG cbNewFileSize = dwFileSize + cchRenameLine + cchRenameSec;

		::VLog(L"Requesting file map of size: %d bytes", cbNewFileSize);

		hFilemap = ::CreateFileMapping(
						hFile,
						NULL,
						PAGE_READWRITE,
						0, 
						cbNewFileSize,
						NULL);
		if (hFilemap == NULL)
		{
			::VLog(L"Unable to create file mapping of wininit.ini; last error = %d", ::GetLastError());
			goto InnerFinish;
		}

		// Map the WININIT.INI file into memory.  Note: The contents 
		// of WININIT.INI are always ANSI; never Unicode.
		pszWinInit = (LPSTR) ::MapViewOfFile(hFilemap, FILE_MAP_WRITE, 0, 0, 0);
		if (pszWinInit == NULL)
		{
			::VLog(L"Error mapping view of wininit.ini; last error = %d", ::GetLastError());
			goto InnerFinish;
		}

		pszWinInitEnd = pszWinInit + dwFileSize;

		// Search for the [Rename] section in the file.
		pszRenameSecInFile = pszWinInit;

		for (;;)
		{
			while ((pszRenameSecInFile != pszWinInitEnd) &&
				   (*pszRenameSecInFile != '['))
				pszRenameSecInFile++;

			if (pszRenameSecInFile == pszWinInitEnd)
			{
				pszRenameSecInFile = NULL;
				break;
			}

			if ((pszWinInitEnd - pszRenameSecInFile) >= 8)
			{
				if (_strnicmp(pszRenameSecInFile, "[rename]", 8) == 0)
				{
					pszRenameSecInFile += 8;

					// Advance past the line break (note that there may not be
					// a line break!)
					while ((pszRenameSecInFile != pszWinInitEnd) &&
						   (*pszRenameSecInFile != '\n'))
						pszRenameSecInFile++;

					break;
				}
			}

			pszRenameSecInFile++;
		}

		if (pszRenameSecInFile == NULL)
		{
			// There is no [Rename] section in the WININIT.INI file.
			// We must add the section too.
			dwFileSize += sprintf(&pszWinInit[dwFileSize], "%s", szRenameSec);
			dwRenameLinePos = dwFileSize;
		}
		else
		{
			// We found the [Rename] section, shift all the lines down
			PSTR pszFirstRenameLine = pszRenameSecInFile + 1;
			memmove(
				pszFirstRenameLine + cchRenameLine,
				pszFirstRenameLine,
				dwFileSize - (pszFirstRenameLine - pszWinInit));
			dwRenameLinePos = pszFirstRenameLine - pszWinInit;
		}

		// Insert the new line
		memcpy(
			&pszWinInit[dwRenameLinePos],
			szRenameLine,
			cchRenameLine);

		if (!::UnmapViewOfFile(pszWinInit))
		{
			::VLog(L"Error unmapping view of wininit.ini; last error = %d", ::GetLastError());
		}

		pszWinInit = NULL;

		// Calculate the true, new size of the file.
		dwFileSize += cchRenameLine;

		// Force the end of the file to be the calculated, new size.
		if (::SetFilePointer(hFile, dwFileSize, NULL, FILE_BEGIN) == 0xffffffff)
		{
			::VLog(L"Unable to set file pointer for wininit.ini; last error = %d", ::GetLastError());
			fResult = FALSE;
			goto InnerFinish;
		}

		if (!::SetEndOfFile(hFile))
		{
			::VLog(L"Unable to set end of file for wininit.ini; last error = %d", ::GetLastError());
			fResult = FALSE;
			goto InnerFinish;
		}

		// Hey, we made it this far, it must have worked!
		fResult = TRUE;

	InnerFinish:
		const DWORD dwLastError = ::GetLastError();

		if (pszWinInit != NULL)
		{
			if (!::UnmapViewOfFile(pszWinInit))
			{
				::VLog(L"Unable to unmap view of wininit.ini; last error = %d", ::GetLastError());
			}
		}

		if ((hFilemap != INVALID_HANDLE_VALUE) && (hFilemap != NULL))
		{
			if (!::CloseHandle(hFilemap))
			{
				::VLog(L"Error closing filemap handle for wininit.ini; last error = %d", ::GetLastError());
			}
		}

		if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
		{
			if (!::CloseHandle(hFile))
			{
				::VLog(L"Error closing handle for wininit.ini; last error = %d", ::GetLastError());
			}
		}

		::SetLastError(dwLastError);
	}

Finish:

	return fResult;
}

BOOL CWin32ANSI::MoveFileW( LPCWSTR lpFrom, LPCWSTR lpTo)
{ 
	CANSIBuffer rgchFrom, rgchTo;
	if (!rgchFrom.FFromUnicode(lpFrom))
		return FALSE;

	if (!rgchTo.FFromUnicode(lpTo))
		return FALSE;

	return ::MoveFileA(rgchFrom, rgchTo); 
}



HMODULE CWin32ANSI::LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
	CANSIBuffer rgchLibFileName;
	if (!rgchLibFileName.FFromUnicode(lpLibFileName))
		return NULL;

	return ::LoadLibraryExA(rgchLibFileName, hFile, dwFlags); 
}

FARPROC CWin32ANSI::GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName)
{
	CANSIBuffer rgchProcName;
	if (!rgchProcName.FFromUnicode(lpProcName))
		return NULL;

	return ::GetProcAddress(hModule, rgchProcName); 
}

BOOL CWin32ANSI::GetFileVersionInfoW(LPOLESTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
	CANSIBuffer rgchFilename;
	if (!rgchFilename.FFromUnicode(lptstrFilename))
		return FALSE;

	return ::GetFileVersionInfoA(rgchFilename, dwHandle, dwLen, lpData); 
}

BOOL CWin32ANSI::VerQueryValueW(const LPVOID pBlock, LPOLESTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
	CANSIBuffer rgchSubBlock;
	if (!rgchSubBlock.FFromUnicode(lpSubBlock))
		return FALSE;

	return ::VerQueryValueA(pBlock, rgchSubBlock, lplpBuffer, puLen); 
}

BOOL CWin32ANSI::GetDiskFreeSpaceExW(LPCWSTR lpRootPathName, ULARGE_INTEGER *puli1, ULARGE_INTEGER *puli2, ULARGE_INTEGER *puli3)
{ 
	CANSIBuffer rgchRootPathName;

	if (!rgchRootPathName.FFromUnicode(lpRootPathName))
		return FALSE;

	BOOL fResult;

	typedef BOOL (WINAPI *PFNGETDISKFREESPACEEXA)(LPCSTR, ULARGE_INTEGER *, ULARGE_INTEGER *, ULARGE_INTEGER *);

	static PFNGETDISKFREESPACEEXA pfn = NULL;
	static fGotIt = false;

	if (!fGotIt)
	{
		HINSTANCE hInstance = ::LoadLibraryA("KERNEL32.DLL");
		if (hInstance == NULL)
			return FALSE;

		pfn = reinterpret_cast<PFNGETDISKFREESPACEEXA>(::GetProcAddress(hInstance, "GetDiskFreeSpaceExA"));
		if (pfn == NULL)
		{
			const DWORD dwLastError = ::GetLastError();

			if ((dwLastError != ERROR_FILE_NOT_FOUND) &&
				(dwLastError != ERROR_PROC_NOT_FOUND))
				return FALSE;
		}
	}

	if (pfn != NULL)
	{
		fResult = (*pfn)(rgchRootPathName, puli1, puli2, puli3);
	}
	else
	{
		DWORD dwSectorsPerCluster;
		DWORD dwBytesPerSector;
		DWORD dwNumberOfFreeClusters;
		DWORD dwTotalNumberOfClusters;

		fResult = ::GetDiskFreeSpaceA(rgchRootPathName, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters);
		if (fResult)
		{
			unsigned __int64 i64BytesPerCluster = static_cast<unsigned __int64>(dwSectorsPerCluster) * static_cast<unsigned __int64>(dwBytesPerSector);

			if (puli1 != NULL)
				puli1->QuadPart = i64BytesPerCluster * static_cast<unsigned __int64>(dwNumberOfFreeClusters);

			if (puli2 != NULL)
				puli2->QuadPart = i64BytesPerCluster * static_cast<unsigned __int64>(dwTotalNumberOfClusters);

			if (puli3 != NULL)
				puli3->QuadPart = i64BytesPerCluster * static_cast<unsigned __int64>(dwNumberOfFreeClusters);
		}
	}

	return fResult;
}

HWND CWin32ANSI::FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
{
	CANSIBuffer rgchClassName, rgchWindowName;
	LPSTR szClassName = NULL;
	LPSTR szWindowName = NULL;

	if (!rgchClassName.FFromUnicode(lpClassName))
		return NULL;

	if (!rgchWindowName.FFromUnicode(lpWindowName))
		return NULL;

	if (lpClassName)
		szClassName = &rgchClassName[0];
	if (lpWindowName)
		szWindowName = &rgchWindowName[0];

	return ::FindWindowA(szClassName, szWindowName);
}


BOOL CWin32ANSI::ListView_SetItemW(HWND hwnd, const LV_ITEMW *pitem)
{
	LV_ITEMA lvitem;
	CANSIBuffer rgchText;

	lvitem.mask = pitem->mask;
	lvitem.iItem = pitem->iItem;
	lvitem.iSubItem = pitem->iSubItem;
	lvitem.state = pitem->state;
	lvitem.stateMask = pitem->stateMask;
	lvitem.cchTextMax = pitem->cchTextMax;
	lvitem.iImage = pitem->iImage;
	lvitem.lParam = pitem->lParam;

	if (pitem->pszText)
	{
		if (!rgchText.FFromUnicode(pitem->pszText))
			return FALSE;

		lvitem.pszText = &rgchText[0];
	}
	else
		lvitem.pszText = NULL;

	return (BOOL)::SendMessage(hwnd, LVM_SETITEMA, 0, (LPARAM) &lvitem);
}

int	CWin32ANSI::ListView_InsertItemW(HWND hwnd, const LV_ITEMW *pitem)
{
	LV_ITEMA lvitem;
	CANSIBuffer rgchText;

	lvitem.mask = pitem->mask;
	lvitem.iItem = pitem->iItem;
	lvitem.iSubItem = pitem->iSubItem;
	lvitem.state = pitem->state;
	lvitem.stateMask = pitem->stateMask;
	lvitem.cchTextMax = pitem->cchTextMax;
	lvitem.iImage = pitem->iImage;
	lvitem.lParam = pitem->lParam;

	if (pitem->pszText)
	{
		if (!rgchText.FFromUnicode(pitem->pszText))
			return -1;

		lvitem.pszText = &rgchText[0];
	}
	else
		lvitem.pszText = NULL;

	return (int)::SendMessage(hwnd, LVM_INSERTITEMA, 0, (LPARAM) &lvitem);
}

DWORD CWin32ANSI::GetTempPathW(DWORD nBufferLength, WCHAR lpBuffer[])
{
	DWORD dwReturn;
	CANSIBuffer rgchBuffer;

	if (!rgchBuffer.FSetBufferSize(nBufferLength))
		return 0;

	dwReturn = ::GetTempPathA(nBufferLength, rgchBuffer);
	rgchBuffer.Sync();

	ULONG cActual;
	rgchBuffer.ToUnicode(nBufferLength, lpBuffer, &cActual);
	return dwReturn;
}

DWORD CWin32ANSI::GetModuleFileNameW(HMODULE hModule, WCHAR lpBuffer[], DWORD nSize)
{
	DWORD dwReturn;
	CANSIBuffer rgchBuffer;

	if (!rgchBuffer.FSetBufferSize(nSize))
		return 0;

	dwReturn = ::GetModuleFileNameA(hModule, rgchBuffer, nSize);
	rgchBuffer.Sync();

	ULONG cActual;
	rgchBuffer.ToUnicode(nSize, lpBuffer, &cActual);
	return dwReturn;
}

BOOL CWin32ANSI::WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
{
	CANSIBuffer rgchAppName, rgchKeyName, rgchString, rgchFileName;
	if (!rgchAppName.FFromUnicode(lpAppName))
		return 0;

	if (!rgchKeyName.FFromUnicode(lpKeyName))
		return 0;

	if (!rgchString.FFromUnicode(lpString))
		return 0;

	if (!rgchFileName.FFromUnicode(lpFileName))
		return 0;

	return ::WritePrivateProfileStringA(rgchAppName, rgchKeyName, rgchString, rgchFileName);
}
BOOL CWin32ANSI::IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
{
	return ::IsDialogMessageA(hDlg, lpMsg);
}
DWORD CWin32ANSI::GetCurrentDirectoryW(DWORD nBufferLength, WCHAR lpBuffer[])
{
	CANSIBuffer rgchBuffer;

	if (!rgchBuffer.FSetBufferSize(nBufferLength))
		return 0;

	DWORD dwReturn = ::GetCurrentDirectoryA(nBufferLength, rgchBuffer);
	rgchBuffer.Sync();

	ULONG cActual;
	rgchBuffer.ToUnicode(nBufferLength, lpBuffer, &cActual);
	return dwReturn;
}

DWORD CWin32ANSI::GetFullPathNameW(LPCWSTR szFile, DWORD cchBuffer, LPWSTR szBuffer, LPWSTR *ppszFilePart)
{
	CANSIBuffer rgchFile;
	if (!rgchFile.FFromUnicode(szFile))
		return 0;

	CANSIBuffer rgchBuffer;
	if (!rgchBuffer.FSetBufferSize(cchBuffer * 2 + 1))
		return 0;

	LPSTR pszFilePart;

	DWORD dwResult = ::GetFullPathNameA(rgchFile, rgchBuffer.GetBufferSize(), rgchBuffer, &pszFilePart);

	if ((dwResult != 0) && (dwResult >= rgchBuffer.GetBufferSize()))
	{
		if (!rgchBuffer.FSetBufferSize(dwResult + 1))
			return 0;

		dwResult = ::GetFullPathNameA(rgchFile, rgchBuffer.GetBufferSize(), rgchBuffer, &pszFilePart);
	}

	if (dwResult != 0)
	{
		rgchBuffer.SetBufferEnd(dwResult);
		ULONG cchActual;
		rgchBuffer.ToUnicode(cchBuffer, szBuffer, &cchActual);
		dwResult = cchActual;
	}

	return dwResult;
}

int WINAPI CWin32ANSI::GetDateFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR wszFormat, LPWSTR wszBuffer, int cchBuffer)
{
	CHAR *paszFormat = NULL;
	CANSIBuffer rgachFormat;

	if (wszFormat != NULL)
	{
		if (!rgachFormat.FFromUnicode(wszFormat))
			return 0;

		paszFormat = rgachFormat;
	}

	ULONG cachBuffer = 0;
	CHAR *paszBuffer = NULL;
	CANSIBuffer rgachBuffer;

	if (cchBuffer != 0)
	{
		if (!rgachBuffer.FSetBufferSize(cchBuffer * 2))
			return 0;

		cachBuffer = rgachBuffer.GetBufferSize();
		paszBuffer = rgachBuffer;
	}

	int iResult = ::GetDateFormatA(lcid, dwFlags, pst, paszFormat, paszBuffer, cachBuffer);
	if (iResult != 0)
	{
		if (cchBuffer == 0)
		{
			// They want to know how many unicode characters this will take.  We need to actually
			// get the string and report back that number.
			if (!rgachBuffer.FSetBufferSize(cchBuffer + 1))
				return 0;

			iResult = ::GetDateFormatA(lcid, dwFlags, pst, paszFormat, rgachBuffer, rgachBuffer.GetBufferSize());
			if (iResult != 0)
				iResult = ::MultiByteToWideChar(CP_ACP, 0, rgachBuffer, -1, NULL, 0);
		}
		else
		{
			rgachBuffer.Sync();

			ULONG cchActual;
			rgachBuffer.ToUnicode(cchBuffer, wszBuffer, &cchActual);
			iResult = cchActual;
		}
	}

	return iResult;
}

int WINAPI CWin32ANSI::GetTimeFormatW(LCID lcid, DWORD dwFlags, CONST SYSTEMTIME *pst, LPCWSTR wszFormat, LPWSTR wszBuffer, int cchBuffer)
{
	CHAR *paszFormat = NULL;
	CANSIBuffer rgachFormat;

	if (wszFormat != NULL)
	{
		if (!rgachFormat.FFromUnicode(wszFormat))
			return 0;

		paszFormat = rgachFormat;
	}

	ULONG cachBuffer = 0;
	CHAR *paszBuffer = NULL;
	CANSIBuffer rgachBuffer;

	if (cchBuffer != 0)
	{
		if (!rgachBuffer.FSetBufferSize(cchBuffer * 2))
			return 0;

		cachBuffer = rgachBuffer.GetBufferSize();
		paszBuffer = rgachBuffer;
	}

	int iResult = ::GetTimeFormatA(lcid, dwFlags, pst, paszFormat, paszBuffer, cachBuffer);
	if (iResult != 0)
	{
		if (cchBuffer == 0)
		{
			// They want to know how many unicode characters this will take.  We need to actually
			// get the string and report back that number.
			if (!rgachBuffer.FSetBufferSize(cchBuffer + 1))
				iResult = 0;
			else
			{
				iResult = ::GetTimeFormatA(lcid, dwFlags, pst, paszFormat, rgachBuffer, rgachBuffer.GetBufferSize());
				if (iResult != 0)
					iResult = ::MultiByteToWideChar(CP_ACP, 0, rgachBuffer, -1, NULL, 0);
			}
		}
		else
		{
			rgachBuffer.Sync();

			ULONG cchActual;
			rgachBuffer.ToUnicode(cchBuffer, wszBuffer, &cchActual);
			iResult = cchActual;
		}
	}

	return iResult;
}

int WINAPI CWin32ANSI::GetNumberFormatW(LCID lcid, DWORD dwFlags, LPCWSTR szValue, NUMBERFMTW *pFormat, LPWSTR wszBuffer, int cchBuffer)
{
	CANSIBuffer rgachValue;
	if (!rgachValue.FFromUnicode(szValue))
		return 0;

	ULONG cachBuffer = 0;
	CHAR *paszBuffer = NULL;
	CANSIBuffer rgachBuffer;

	CANSIBuffer rgachDecimalSeparator;
	CANSIBuffer rgachThousandsSeparator;
	NUMBERFMTA nfa;
	NUMBERFMTA *pnfa = NULL;

	if (pFormat != NULL)
	{
		nfa.NumDigits = pFormat->NumDigits;
		nfa.LeadingZero = pFormat->LeadingZero;
		nfa.Grouping = pFormat->Grouping;
		
		if (!rgachDecimalSeparator.FFromUnicode(pFormat->lpDecimalSep))
			return 0;

		nfa.lpDecimalSep = rgachDecimalSeparator;

		if (!rgachThousandsSeparator.FFromUnicode(pFormat->lpThousandSep))
			return 0;

		nfa.lpThousandSep = rgachThousandsSeparator;

		pnfa = &nfa;
	}

	if (cchBuffer != 0)
	{
		if (!rgachBuffer.FSetBufferSize(cchBuffer * 2))
			return 0;

		cachBuffer = rgachBuffer.GetBufferSize();
		paszBuffer = rgachBuffer;
	}

	int iResult = ::GetNumberFormatA(lcid, dwFlags, rgachValue, pnfa, paszBuffer, cachBuffer);
	if (iResult != 0)
	{
		if (cchBuffer == 0)
		{
			// They want to know how many unicode characters this will take.  We need to actually
			// get the string and report back that number.
			if (!rgachBuffer.FSetBufferSize(cchBuffer + 1))
				iResult = 0;
			else
			{
				iResult = ::GetNumberFormatA(lcid, dwFlags, rgachValue, pnfa, rgachBuffer, rgachBuffer.GetBufferSize());
				if (iResult != 0)
					iResult = ::MultiByteToWideChar(CP_ACP, 0, rgachBuffer, -1, NULL, 0);
			}
		}
		else
		{
			rgachBuffer.Sync();
			ULONG cchActual;
			rgachBuffer.ToUnicode(cchBuffer, wszBuffer, &cchActual);
			iResult = cchActual;
		}
	}

	return iResult;
}

int WINAPI CWin32ANSI::GetLocaleInfoW(LCID lcid, LCTYPE lctype, LPWSTR szBuffer, int cchBuffer)
{
	CANSIBuffer rgachBuffer;
	int iResult = 0;

	if (cchBuffer == 0)
	{
		iResult = ::GetLocaleInfoA(lcid, lctype, NULL, 0);
		if (iResult != 0)
		{
			if (!rgachBuffer.FSetBufferSize(iResult + 1))
				iResult = 0;
			else
			{
				iResult = ::GetLocaleInfoA(lcid, lctype, rgachBuffer, rgachBuffer.GetBufferSize());
				if (iResult != 0)
				{
					iResult = ::MultiByteToWideChar(CP_ACP, 0, rgachBuffer, -1, NULL, 0);
				}
			}
		}
	}
	else
	{
		if (!rgachBuffer.FSetBufferSize(cchBuffer * 2))
			iResult = 0;
		else
		{
			iResult = ::GetLocaleInfoA(lcid, lctype, rgachBuffer, rgachBuffer.GetBufferSize());
			if (iResult != 0)
			{
				rgachBuffer.Sync();
				ULONG cchActual;
				rgachBuffer.ToUnicode(cchBuffer, szBuffer, &cchActual);
				iResult = cchActual;
			}
		}
	}

	return iResult;
}

DWORD CWin32ANSI::GetShortPathNameW(LPCWSTR szPath, LPWSTR szBuffer, DWORD cchBuffer)
{
	CANSIBuffer rgachPath;
	CANSIBuffer rgachBuffer;

	if (!rgachPath.FFromUnicode(szPath))
		return 0;
	
	DWORD cchRequired = ::GetShortPathNameA(rgachPath, rgachBuffer, 0);
	if (cchRequired != 0)
	{
		if (!rgachBuffer.FSetBufferSize(cchRequired + 1))
			cchRequired = 0;
		else
			cchRequired = ::GetShortPathNameA(rgachPath, rgachBuffer, rgachBuffer.GetBufferSize());

		if (cchRequired != 0)
		{
			rgachBuffer.Sync();
			ULONG cchActual;
			rgachBuffer.ToUnicode(cchBuffer, szBuffer, &cchActual);
			cchRequired = cchActual;
		}
	}

	return cchRequired;
}

LONG WINAPI CWin32ANSI::RegEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME pftLastWriteTime)
{
	LPSTR paszName = NULL;
	LPDWORD pcachName = NULL;
	DWORD cachName = 0;
	CANSIBuffer rgachName;

	if (lpcbName != NULL)
	{
		// could be up to two bytes per unicode character we want...
		if (!rgachName.FSetBufferSize(*lpcbName * 2))
			return ::GetLastError();

		cachName = rgachName.GetBufferSize();
		paszName = rgachName;
		pcachName = &cachName;
	}

	LPSTR paszClass = NULL;
	DWORD cachClass = 0;
	CANSIBuffer rgachClass;
	LPDWORD pcachClass = NULL;

	if (lpcbClass != NULL)
	{
		if (!rgachClass.FSetBufferSize(*lpcbClass * 2))
			return ::GetLastError();

		cachClass = rgachClass.GetBufferSize();
		paszClass = rgachClass;
		pcachClass = &cachClass;
	}

	LONG lResult = ::RegEnumKeyExA(hkey, dwIndex, paszName, pcachName, lpdwReserved, paszClass, pcachClass, pftLastWriteTime);
	if (lResult == ERROR_SUCCESS)
	{
		if (lpcbName != NULL)
		{
			rgachName.Sync();
			ULONG cchActual;
			rgachName.ToUnicode(*lpcbName, lpName, &cchActual);
			*lpcbName = cchActual;
		}

		if (lpcbClass != NULL)
		{
			rgachClass.Sync();
			ULONG cchActual;
			rgachClass.ToUnicode(*lpcbClass, lpClass, &cchActual);
			*lpcbClass = cchActual;
		}
	}

	return lResult;

}

LONG WINAPI CWin32ANSI::RegEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpcbData)
{
	LPSTR paszName = NULL;
	LPDWORD pcachName = NULL;
	DWORD cachName = 0;
	CANSIBuffer rgachName;

	if (lpcbName != NULL)
	{
		// could be up to two bytes per unicode character we want...
		if (!rgachName.FSetBufferSize(*lpcbName * 2))
			return ::GetLastError();

		cachName = rgachName.GetBufferSize();
		paszName = rgachName;
		pcachName = &cachName;
	}

	LPSTR paszData = NULL;
	DWORD cachData = 0;
	CANSIBuffer rgachData;
	LPDWORD pcachData = NULL;

	if (lpcbData != NULL)
	{
		// lpcbdata is really really bytes, so we don't have to expand by two
		if (!rgachData.FSetBufferSize(*lpcbData))
			return ::GetLastError();

		cachData = rgachData.GetBufferSize();
		paszData = rgachData;
		pcachData = &cachData;
	}

	DWORD dwType;

	LONG lResult = ::RegEnumValueA(hkey, dwIndex, paszName, pcachName, lpdwReserved, &dwType, (LPBYTE) paszData, pcachData);
	if (lResult == ERROR_SUCCESS)
	{
		if (lpcbName != NULL)
		{
			rgachName.Sync();
			ULONG cchActual;
			rgachName.ToUnicode(*lpcbName, lpName, &cchActual);
			*lpcbName = cchActual;
		}

		if (lpcbData != NULL)
		{
			if ((dwType == REG_EXPAND_SZ) ||
				(dwType == REG_SZ))
			{
				rgachData.Sync();
				ULONG cchActual;
				rgachData.ToUnicode((*lpcbData) / 2, (LPWSTR) lpData, &cchActual);
				*lpcbData = (cchActual * 2);
			}
			else
			{
				ULONG cbToCopy = cachData;
				if (cbToCopy > *lpcbData)
					cbToCopy = *lpcbData;

				memcpy(lpData, paszData, cbToCopy);

				*lpcbData = cbToCopy;
			}
		}

		if (lpdwType != NULL)
			*lpdwType = dwType;
	}

	return lResult;

}

BOOL CWin32ANSI::GetVolumeInformationW
(
LPCWSTR szPath, 
LPWSTR lpVolumeNameBuffer, 
DWORD cchVolumeNameBuffer, 
LPDWORD lpVolumeSerialNumber, 
LPDWORD lpMaximumComponentNameLength, 
LPDWORD pdwFileSystemFlags, 
LPWSTR pszFileSystemNameBuffer, 
DWORD cchFileSystemNameBuffer
) throw ()
{
	CANSIBuffer rgachPath;

	if (!rgachPath.FFromUnicode(szPath))
		return FALSE;

	CANSIBuffer rgachVolumeName;
	ULONG cachVolumeName = 0;
	LPSTR paszVolumeName = NULL;

	CANSIBuffer rgachFileSystemName;
	ULONG cachFileSystemName;
	LPSTR paszFileSystemName = NULL;

	if (lpVolumeNameBuffer != NULL)
	{
		if (!rgachVolumeName.FSetBufferSize(cchVolumeNameBuffer * 2))
			return FALSE;

		cachVolumeName = rgachVolumeName.GetBufferSize();
		paszVolumeName = rgachVolumeName;
	}

	if (pszFileSystemNameBuffer != NULL)
	{
		if (!rgachFileSystemName.FSetBufferSize(cchFileSystemNameBuffer * 2))
			return FALSE;

		cachFileSystemName = rgachFileSystemName.GetBufferSize();
		paszFileSystemName = rgachFileSystemName;
	}

	BOOL fResult = ::GetVolumeInformationA(rgachPath, paszVolumeName, cachVolumeName, lpVolumeSerialNumber, lpMaximumComponentNameLength, pdwFileSystemFlags, paszFileSystemName, cachFileSystemName);
	if (fResult)
	{
		ULONG cchActual;

		if (paszVolumeName != NULL)
		{
			rgachVolumeName.Sync();
			rgachVolumeName.ToUnicode(cchVolumeNameBuffer, lpVolumeNameBuffer, &cchActual);
		}

		if (paszFileSystemName != NULL)
		{
			rgachFileSystemName.Sync();
			rgachFileSystemName.ToUnicode(cchFileSystemNameBuffer, pszFileSystemNameBuffer, &cchActual);
		}
	}

	return fResult;
}

LRESULT CWin32ANSI::LrWmSetText(HWND hwnd, LPCWSTR szText)
{
	CANSIBuffer rgachText;

	if (!rgachText.FFromUnicode(szText))
		return FALSE;

	return ::SendMessageA(hwnd, WM_SETTEXT, 0, (LPARAM) static_cast<LPCSTR>(rgachText));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\workitem.h ===
#pragma once

class CWorkItem;
class CWorkItemList;
class CWorkItemIter;

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

//
//	Rather than do the OO thing, we're just going to have a queue of same-shaped work items.
//

class CDiskSpaceRequired
{
public:
	CDiskSpaceRequired()  throw () : m_pPerDisk_Head(NULL), m_cDisks(0) { }
	~CDiskSpaceRequired() throw ()
	{
		PerDisk *pPerDisk = m_pPerDisk_Head;
		while (pPerDisk != NULL)
		{
			PerDisk *pPerDisk_Next = pPerDisk->m_pPerDisk_Next;
			delete pPerDisk;
			pPerDisk = pPerDisk_Next;
		}

		m_pPerDisk_Head = NULL;
	}

	struct PerDisk
	{
		PerDisk *m_pPerDisk_Next;
		ULARGE_INTEGER m_uliBytes;
		ULONG m_ulClusterSize;
		WCHAR m_szPath[_MAX_PATH];
	};

	HRESULT HrAddBytes(LPCWSTR szPath, ULARGE_INTEGER uliBytes) throw ()
	{
		HRESULT hr = NOERROR;

		PerDisk *pPerDisk = m_pPerDisk_Head;

		while (pPerDisk != NULL)
		{
			if (_wcsicmp(szPath, pPerDisk->m_szPath) == 0)
				break;

			pPerDisk = pPerDisk->m_pPerDisk_Next;
		}

		if (pPerDisk == NULL)
		{
			ULARGE_INTEGER uliTotalBytes;
			WCHAR szTempPath[_MAX_PATH];
			WCHAR szFileSystemName[_MAX_PATH];
			DWORD dwFileSystemFlags;

			pPerDisk = new PerDisk;

			if (pPerDisk == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Finish;
			}

			wcsncpy(pPerDisk->m_szPath, szPath, NUMBER_OF(pPerDisk->m_szPath));
			pPerDisk->m_szPath[NUMBER_OF(pPerDisk->m_szPath) - 1] = L'\0';

			wcsncpy(szTempPath, szPath, NUMBER_OF(szTempPath));
			szTempPath[NUMBER_OF(szTempPath) - 1] = L'\0';

			ULONG cchPath = wcslen(szTempPath);
			if ((cchPath != 0) && (cchPath < (NUMBER_OF(szTempPath) - 1)))
			{
				if (szTempPath[cchPath - 1] != L'\\')
				{
					szTempPath[cchPath++] = L'\\';
					szTempPath[cchPath++] = L'\0';
				}
			}

			ULARGE_INTEGER uliFoo, uliBar;

			if (!NVsWin32::GetDiskFreeSpaceExW(szTempPath, &uliFoo, &uliTotalBytes, &uliBar))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"In CDiskSpaceRequired::HrAddBytes(), GetDiskFreeSpaceEx(\"%s\") failed; last error = %d", szTempPath, dwLastError);
				uliTotalBytes.QuadPart = 1023 * 1024 * 1024; // assume a 1gb partition
			}

			if (!NVsWin32::GetVolumeInformationW(
									szTempPath,	// lpRootPathName
									NULL,		// lpVolumeNameBuffer
									0,			// nVolumeNameSize
									NULL,		// lpVolumeSerialNumber
									NULL,		// lpMaximumComponentLength
									&dwFileSystemFlags,		// lpFileSystemFlags
									szFileSystemName,		// lpFileSystemNameBuffer
									NUMBER_OF(szFileSystemName)))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"GetVolumeInformationW(\"%s\", ...) failed; last error = %d", szPath, dwLastError);
				wcscpy(szFileSystemName, L"FAT");
			}
			else
			{
				::VLog(L"For drive \"%s\", file system is \"%s\"", szPath, szFileSystemName);
			}

			pPerDisk->m_ulClusterSize = 0;

			ULONG ulDriveMB = static_cast<ULONG>(uliTotalBytes.QuadPart / (1024 * 1024));

			if (wcscmp(szFileSystemName, L"NTFS") == 0)
			{
				if (ulDriveMB <= 512)
					pPerDisk->m_ulClusterSize = 512;
				else if (ulDriveMB <= 1024)
					pPerDisk->m_ulClusterSize = 1024;
				else if (ulDriveMB <= 2048)
					pPerDisk->m_ulClusterSize = 2048;
				else
					pPerDisk->m_ulClusterSize = 4096;
			}
			else if (wcscmp(szFileSystemName, L"FAT") == 0)
			{
				if (ulDriveMB < 16)
					pPerDisk->m_ulClusterSize = 4096;
				else if (ulDriveMB < 128)
					pPerDisk->m_ulClusterSize = 2048;
				else if (ulDriveMB < 256)
					pPerDisk->m_ulClusterSize = 4096;
				else if (ulDriveMB < 512)
					pPerDisk->m_ulClusterSize = 8192;
				else if (ulDriveMB < 1024)
					pPerDisk->m_ulClusterSize = 16384;
				else if (ulDriveMB < 2048)
					pPerDisk->m_ulClusterSize = 32768;
				else if (ulDriveMB < 4096)
					pPerDisk->m_ulClusterSize = 65536;
				else if (ulDriveMB < 8192)
					pPerDisk->m_ulClusterSize = 128 * 1024;
				else
					pPerDisk->m_ulClusterSize = 256 * 1024;
			}

			// Pick some random reasonable cluster size if we don't know what's going on.
			if (pPerDisk->m_ulClusterSize == 0)
				pPerDisk->m_ulClusterSize = 4096;

			::VLog(L"Using cluster size of %lu for volume \"%s\"", pPerDisk->m_ulClusterSize, szPath);

			pPerDisk->m_uliBytes.QuadPart = 0;

			wcsncpy(pPerDisk->m_szPath, szPath, NUMBER_OF(pPerDisk->m_szPath));
			pPerDisk->m_szPath[NUMBER_OF(pPerDisk->m_szPath) - 1] = L'\0';

			pPerDisk->m_pPerDisk_Next = m_pPerDisk_Head;
			m_pPerDisk_Head = pPerDisk;

			m_cDisks++;
		}

		if (pPerDisk->m_ulClusterSize != 0)
		{
			uliBytes.QuadPart = (uliBytes.QuadPart + (pPerDisk->m_ulClusterSize - 1));
			uliBytes.QuadPart -= (uliBytes.QuadPart % pPerDisk->m_ulClusterSize);
		}

		pPerDisk->m_uliBytes.QuadPart += uliBytes.QuadPart;

	Finish:
		return hr;
	}

	void VReset() throw ()
	{
		PerDisk *pPerDisk = m_pPerDisk_Head;
		while (pPerDisk != NULL)
		{
			PerDisk *pPerDisk_Next = pPerDisk->m_pPerDisk_Next;
			delete pPerDisk;
			pPerDisk = pPerDisk_Next;
		}

		m_pPerDisk_Head = NULL;
		m_cDisks = 0;
	}


	// There should be so few of these that it's almost certainly not worth having a hash or
	// other searching structure (famous last words).  -mgrier 2/28/98

	PerDisk *m_pPerDisk_Head;
	ULONG m_cDisks;
};


class CWorkItem
{
public:
	enum Type
	{
		eWorkItemFile,
		eWorkItemCommand
	};

	struct CommandCondition
	{
		CommandCondition *m_pCommandCondition_Next;
		DWORD m_dwMSVersion;
		DWORD m_dwLSVersion;
		bool m_fCheckVersion;
		WCHAR m_szFilename[_MAX_PATH];
		WCHAR m_szReferenceFilename[_MAX_PATH];
	};

	CWorkItem(Type type) throw ();

	// Sets the source file, canonicalizing it
	HRESULT HrSetSourceFile(LPCWSTR szSourceFile) throw ();
	HRESULT HrSetTargetFile(LPCWSTR szTargetFile) throw ();
	HRESULT HrSetCommandLine(LPCWSTR szCommandLine) throw ();

	HRESULT HrLoad(LPCWSTR &rpszSavedForm) throw ();
	HRESULT HrSave(HANDLE hFile) throw ();

	HRESULT HrWriteBool(HANDLE hFile, LPCWSTR szName, bool fValue) throw ();

	bool FStringToBool(LPCWSTR szValue) throw ();

	CWorkItem *m_pWorkItem_Next;
	CWorkItem *m_pWorkItem_Prev;
	
	Type m_type;

	ULONG m_ulSerialNumber;

	// m_szSourceFile is the name of the file in the temp directory from which we copy.
	// If m_type is eWorkItemCommand, the command is stored in m_szSourceFile_Raw, which
	// is why it's much larger.
	WCHAR m_szSourceFile[MSINFHLP_MAX_PATH];

	// Most Significant and Least Significant DWORDs of the source file's version
	DWORD m_dwMSSourceVersion;
	DWORD m_dwLSSourceVersion;

	// indication of whether the source file has OLESelfRegister set:
	bool m_fSourceSelfRegistering;

	bool m_fSourceIsEXE;
	bool m_fSourceIsDLL;

	DWORD m_dwSourceAttributes;

	// Creation date/time of the source file
	FILETIME m_ftSource;

	// Size of the source file in bytes:
	ULARGE_INTEGER m_uliSourceBytes;

	// m_szTargetFile is the name of the file on the user's filesystem.  Prior to the pass one
	// scan, it contains symbols which need to be substituted (<AppDir> et al.).  Pass one scan
	// replaces this string with the actual physical pathname.
	WCHAR m_szTargetFile[_MAX_PATH];

	// Most Significant and Least Significant DWORDs of the Target file's version
	DWORD m_dwMSTargetVersion;
	DWORD m_dwLSTargetVersion;

	// indication of whether the Target file has OLESelfRegister set:
	bool m_fTargetSelfRegistering;

	bool m_fTargetIsEXE;
	bool m_fTargetIsDLL;

	DWORD m_dwTargetAttributes;

	// Creation date/time of the Target file
	FILETIME m_ftTarget;

	ULARGE_INTEGER m_uliTargetBytes;

	// For pass one copies, all files are moved to temporary names in their destination directories.
	// this is where we store those names when the temporaries are in place.
	WCHAR m_szTemporaryFile[_MAX_PATH];

	// if m_fIsRefCounted is true, m_dwFileReferenceCount will be set to the file's reference
	// count during pass one of both install and uninstall.  If the file had no reference count,
	// we set m_dwFileReferenceCount to 0xffffffff.
	DWORD m_dwFileReferenceCount;

	bool m_fErrorInWorkItem;

	// m_fIsRefCounted is set to true when the file in question is supposed to be reference
	// counted.
	bool m_fIsRefCounted;

	// m_fRefCountUpdated is set to true when the file is ref counted and the ref count has
	// finally been updated.
	bool m_fRefCountUpdated;

	// m_fNeedsUpdate is set to true when during installation, we find that the file either
	// doesn't exist, is an older version, the user is requesting a reinstall and the version
	// on the system isn't newer, or the user chose to install an older version of the file
	// over the newer version.
	bool m_fNeedsUpdate;

	// m_fFileUpdated is set to true on install if the file was actually moved during the installation
	bool m_fFileUpdated;

	// m_fStillExists is set to true on uninstall if the file was to be deleted, but the deletion failed.
	bool m_fStillExists;

	// m_fTemporaryFileReady is set to true on install when the source file has been properly moved to the
	// target device, as specified in m_szTempFile.
	bool m_fTemporaryFileReady;

	// m_fFilesSwapped is set to true on install when the target file and the temporary files have been
	// swapped.
	bool m_fTemporaryFilesSwapped;

	// m_fAlreadyExists is set to true on install if the file already exists in the Target
	// location.  When it is true, m_dwMSTargetVersion, m_dwLSTargetVersion, m_ftTarget
	// and m_uliTargetBytes are valid.
	bool m_fAlreadyExists;

	// m_fDeferredCopy is set to true on install if the Target file is in use and we have to
	// do the copy operation after a reboot.  This is especially important because we can't do
	// registration of files until after the reboot also then.
	bool m_fDeferredRenameRequired;

	// m_fDeferredCopyPending is set to true on install if m_fDeferredCopy was set to true and the
	// deferred copy was requested.  It basically can be used to differentiate between deferred copy
	// requests which have been successfully turned into MoveFileEx()/wininit.ini stuff vs. ones
	// we haven't hit yet.  (This could allow multiple attempts to issue the deferred copy requests
	// starting over at the beginning of the list each time.)
	bool m_fDeferredRenamePending;

	// m_fManualRenameOnReboot is set to true on Win95 when the target file is busy and it has
	// a long file name.  In these cases, it's impossible to use the Win9x wininit.ini mechanism
	// to rename the file on reboot, so we have to do the rename when we're restarted after
	// rebooting.
	bool m_fManualRenameOnRebootRequired;

	// m_fToBeDeleted is set to true on uninstall if either the file is in the list of files to be
	// removed on uninstall, or if it's reference counted and the reference count would hit zero.
	bool m_fToBeDeleted;

	// m_fToBeSaved is set to true on uninstall if the file was up for deletion, but the user chose
	// to keep it.  The enables us to call our HrUninstall_PassNNN() functions repeatedly, without asking
	// the user about files that they've already made decisions about.
	bool m_fToBeSaved;

	// m_fAskOnRefCountZeroDelete is set to true if the user should be given the prompt about deleting
	// shared files on uninstall.
	bool m_fAskOnRefCountZeroDelete;

	// m_fCopyOnInstall is set to true if the file should be copied from the source to the Target
	// locations on installation.
	bool m_fCopyOnInstall;

	// m_fUnconditionalDeleteOnUninstall is set to true if the file should be deleted during uninstall
	// without any reference counting issues.
	bool m_fUnconditionalDeleteOnUninstall;

	// m_fRegisterAsDCOMComponent is set to true if the command should be run with the name of the remote
	// DCOM server as the first and only "%s" replacement.
	bool m_fRegisterAsDCOMComponent;

	// m_fAddToRegistry is set to true if this command work item is actually a registry entry to
	// add.
	bool m_fAddToRegistry;

	// m_fDeleteFromRegistry is to true if this command work item is actually a registry entry to
	// delete on uninstall.
	bool m_fDeleteFromRegistry;

	// m_fTargetInUse is set to true on uninstall in pass three if the uninstaller can't open a write
	// handle to the file.  We don't persist this flag.
	bool m_fTargetInUse;

	// For type == eWorkItemCommand, indicates when to run it:
	bool m_fRunBeforeInstall;
	bool m_fRunAfterInstall;
	bool m_fRunBeforeUninstall;
	bool m_fRunAfterUninstall;

	// Set to true on installation if this is a self-registering thing and the registration succeeded.
	bool m_fAlreadyRegistered;
};

class CWorkItemList
{
	friend CWorkItemIter;

public:
	CWorkItemList() throw ();
	~CWorkItemList() throw ();

	HRESULT HrLoad(LPCWSTR szFilename) throw ();
	HRESULT HrSave(LPCWSTR szFilename) throw ();

	HRESULT HrAddRefCount(LPCOLESTR szLine) throw ();
	HRESULT HrAddPreinstallRun(LPCOLESTR szLine) throw ();
	HRESULT HrAddPostinstallRun(LPCOLESTR szLine) throw ();
	HRESULT HrAddFileCopy(LPCOLESTR szSource, LPCOLESTR szTarget) throw ();
	HRESULT HrAddFileDelete(LPCOLESTR szTarget) throw ();
	HRESULT HrAddAddReg(LPCOLESTR szLine) throw ();
	HRESULT HrAddDelReg(LPCOLESTR szLine) throw ();
	HRESULT HrAddRegisterOCX(LPCOLESTR szLine) throw ();
	HRESULT HrAddPreuninstallRun(LPCOLESTR szLine) throw ();
	HRESULT HrAddPostuninstallRun(LPCOLESTR szLine) throw ();
	HRESULT HrAddDCOMComponent(LPCOLESTR szLine) throw ();

	HRESULT HrRunPreinstallCommands() throw ();
	HRESULT HrRunPostinstallCommands() throw ();
	HRESULT HrRunPreuninstallCommands() throw ();
	HRESULT HrRunPostuninstallCommands() throw ();

	// ScanBeforeInstall_PassOne() gets all the relevant file sizes and sees what already
	// exists on disk.without making any decisions other than marking items which don't have
	// corresponding source files.
	HRESULT HrScanBeforeInstall_PassOne() throw ();

	// ScanBeforeInstall_PassTwo() does all the determination of whether a file needs
	// to be replaced etc.
	HRESULT HrScanBeforeInstall_PassTwo(CDiskSpaceRequired &rdsr) throw ();

	// MoveFiles_PassOne() moves all files to temporary names in their destination directories
	HRESULT HrMoveFiles_MoveSourceFilesToDestDirectories() throw ();

	// MoveFiles_PassTwo() tries to rename the temporary files to the real file names, and the
	// old files to the temporary filenames.
	HRESULT HrMoveFiles_SwapTargetFilesWithTemporaryFiles() throw ();

	HRESULT HrMoveFiles_RequestRenamesOnReboot() throw ();
	HRESULT HrFinishManualRenamesPostReboot() throw ();

	// DeleteTemporaryFiles() cleans up the files left around after MoveFiles_PassTwo().
	HRESULT HrDeleteTemporaryFiles() throw ();

	// Go through files which have OLESelfRegister set and register them.
	HRESULT HrRegisterSelfRegisteringFiles(bool &rfAnyProgress) throw ();

	// Any updated files that are .class files should be registered.
	HRESULT HrRegisterJavaClasses() throw ();

	// Update the target files' reference counts
	HRESULT HrIncrementReferenceCounts() throw ();

	// Do the right thing for DCOM entries
	HRESULT HrProcessDCOMEntries() throw ();

	HRESULT HrAddRegistryEntries() throw ();
	HRESULT HrDeleteRegistryEntries() throw ();

	HRESULT HrCreateShortcuts() throw ();

	// Pass one for uninstall: gather info on each file that's possibly modified:
	HRESULT HrUninstall_InitialScan() throw ();
	
	// Pass two for uninstall: ask the user about shared files that are going to be deleted etc.
	HRESULT HrUninstall_DetermineFilesToDelete() throw ();

	// Pass three for uninstall: determine if we're going to have to reboot.
	HRESULT HrUninstall_CheckIfRebootRequired() throw ();

	// Pass four for uninstall: unregister any COM servers and Java .class files that are
	// going to be deleted.
	HRESULT HrUninstall_Unregister() throw ();

	// Pass five for uninstall: delete the files and shortcuts as appropriate.
	HRESULT HrUninstall_DeleteFiles() throw ();

	// Pass six for uninstall: update the reference counts in the registry
	HRESULT HrUninstall_UpdateRefCounts() throw ();

	HRESULT HrAddString(LPCSTR szKey, LPCWSTR szValue) throw ();
	HRESULT HrAddString(LPCWSTR szLine, LPCWSTR szSeparator) throw ();
	HRESULT HrDeleteString(LPCSTR szKey) throw ();

	bool FLookupString(LPCSTR szKey, ULONG cchBuffer, WCHAR szBuffer[]) throw ();
	void VLookupString(LPCSTR szKey, ULONG cchBuffer, WCHAR szBuffer[]) throw ();

	bool FFormatString(ULONG cchBuffer, WCHAR szBuffer[], LPCSTR szKey, ...) throw ();
	void VFormatString(ULONG cchBuffer, WCHAR szBuffer[], LPCSTR szKey, ...) throw ();

	ULONG UlHashFilename(LPCWSTR szFilename) throw ();
	bool FSameFilename(LPCWSTR szFilename1, LPCWSTR szFilename2) throw ();

	ULONG UlHashString(LPCSTR szKey) throw ();

	HRESULT HrAppend(CWorkItem *pWorkItem, bool fAddToHashTables = true) throw ();

	HRESULT HrRunCommand(LPCWSTR szCommand, bool &rfHasBeenWarnedAboutSubinstallers) throw ();
	HRESULT HrParseCommandCondition(LPCWSTR szCondition, CWorkItem::CommandCondition *&rpCC) throw ();
	HRESULT HrCheckCommandConditions(CWorkItem::CommandCondition *pCC, bool fConditionsAreRequirements, bool &rfDoCommand) throw ();
	HRESULT HrInstallViaJPM(LPCWSTR szCommandLine) throw ();
	HRESULT HrRunProcess(LPCWSTR szCommandLine) throw ();
	HRESULT HrUnregisterJavaClass(LPCWSTR szFile) throw ();

	HRESULT HrAddRunOnce(LPCWSTR szCommandLine, ULONG cchName, WCHAR szRunOnceKey[]) throw ();
	HRESULT HrModifyRunOnce(LPCWSTR szRunOnceKey, LPCWSTR szCommandLine) throw ();
	HRESULT HrDeleteRunOnce(LPCWSTR szRunOnceKey) throw ();

	CWorkItem *PwiFindByTarget(LPCWSTR szFilename) throw ();
	CWorkItem *PwiFindBySource(LPCWSTR szFilename) throw ();

	ULONG m_cWorkItem;
	CWorkItem *m_pWorkItem_First;
	CWorkItem *m_pWorkItem_Last;
	ULONG m_cPreinstallCommands;
	ULONG m_cPostinstallCommands;
	ULONG m_cPreuninstallCommands;
	ULONG m_cPostuninstallCommands;

	struct WorkItemBucket
	{
		WorkItemBucket *m_pWorkItemBucket_Next;
		CWorkItem *m_pWorkItem;
	};

	WorkItemBucket *m_rgpWorkItemBucketTable_Source[512];
	WorkItemBucket *m_rgpWorkItemBucketTable_Target[512];

	struct StringBucket
	{
		StringBucket *m_pStringBucket_Next;
		ULONG m_ulPseudoKey;
		CHAR m_szKey[MSINFHLP_MAX_PATH];
		WCHAR m_wszValue[MSINFHLP_MAX_PATH];
	};

	StringBucket *m_rgpStringBucketTable[512];
};

class CWorkItemIter
{
public:
	CWorkItemIter(CWorkItemList &rwil)  throw () : m_rwil(rwil), m_pwiCurrent(NULL) { }
	CWorkItemIter(CWorkItemList *pwil)  throw () : m_rwil(*pwil), m_pwiCurrent(NULL) { }
	~CWorkItemIter()  throw () { }

	void VReset() throw () { m_pwiCurrent = m_rwil.m_pWorkItem_First; }
	void VNext() throw () { if (m_pwiCurrent != NULL) m_pwiCurrent = m_pwiCurrent->m_pWorkItem_Next; }
	bool FMore() throw () { return m_pwiCurrent != NULL; }

	CWorkItem *operator ->() const throw () { return m_pwiCurrent; }
	operator CWorkItem *() const throw () { return m_pwiCurrent; }

protected:
	CWorkItemList &m_rwil;
	CWorkItem *m_pwiCurrent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\workitem.cpp ===
#include "stdinc.h"

static ULONG gs_ulWorkItemSerialNumber;

CWorkItem::CWorkItem
(
CWorkItem::Type type
) : m_type(type)
{
	m_fErrorInWorkItem = false;
	m_fIsRefCounted = false;
	m_fNeedsUpdate = false;
	m_fFileUpdated = false;
	m_fStillExists = false;
	m_fToBeDeleted = false;
	m_fToBeSaved = false;
	m_fAlreadyExists = false;
	m_fDeferredRenameRequired = false;
	m_fAskOnRefCountZeroDelete = false;
	m_fCopyOnInstall = false;
	m_fUnconditionalDeleteOnUninstall = false;
	m_fRunBeforeInstall = false;
	m_fRunAfterInstall = false;
	m_fRunBeforeUninstall = false;
	m_fRunAfterUninstall = false;
	m_fSourceSelfRegistering = false;
	m_fTargetSelfRegistering = false;
	m_fDeferredRenamePending = false;
	m_fRefCountUpdated = false;
	m_fRegisterAsDCOMComponent = false;
	m_fAddToRegistry = false;
	m_fDeleteFromRegistry = false;
	m_fSourceIsEXE = false;
	m_fSourceIsDLL = false;
	m_fTargetIsEXE = false;
	m_fTargetIsDLL = false;
	m_fTemporaryFileReady = false;
	m_fTemporaryFilesSwapped = false;
	m_fTargetInUse = false;
	m_fManualRenameOnRebootRequired = false;
	m_fAlreadyRegistered = false;

	m_ulSerialNumber = gs_ulWorkItemSerialNumber++;

	m_uliSourceBytes.QuadPart = 0;
	m_uliTargetBytes.QuadPart = 0;
	m_dwSourceAttributes = 0xffffffff;
	m_dwTargetAttributes = 0xffffffff;
	m_dwMSSourceVersion = 0xffffffff;
	m_dwLSSourceVersion = 0xffffffff;
	m_dwMSTargetVersion = 0xffffffff;
	m_dwLSTargetVersion = 0xffffffff;

	m_ftSource.dwLowDateTime = 0xffffffff;
	m_ftSource.dwHighDateTime = 0xffffffff;

	m_ftTarget.dwLowDateTime = 0xffffffff;
	m_ftTarget.dwHighDateTime = 0xffffffff;

	m_szSourceFile[0] = L'\0';
	m_szTargetFile[0] = L'\0';
	m_szTemporaryFile[0] = L'\0';

	m_dwFileReferenceCount = 0xffffffff;
}

HRESULT CWorkItem::HrSetSourceFile(LPCWSTR szSourceFile)
{
	HRESULT hr = NOERROR;

	if (szSourceFile == NULL)
	{
		m_szSourceFile[0] = L'\0';
	}
	else
	{
		wcsncpy(m_szSourceFile, szSourceFile, NUMBER_OF(m_szSourceFile));
		m_szSourceFile[NUMBER_OF(m_szSourceFile) - 1] = L'\0';
	}

	return hr;
}

HRESULT CWorkItem::HrSetTargetFile(LPCWSTR szTargetFile)
{
	if (szTargetFile == NULL)
	{
		m_szTargetFile[0] = L'\0';
	}
	else
	{
		wcsncpy(m_szTargetFile, szTargetFile, NUMBER_OF(m_szTargetFile));
		m_szTargetFile[NUMBER_OF(m_szTargetFile) - 1] = L'\0';
	}

	return NOERROR;
}

HRESULT CWorkItem::HrSetCommandLine(LPCWSTR szCommandLine)
{
	if (szCommandLine == NULL)
	{
		m_szSourceFile[0] = L'\0';
	}
	else
	{
		wcsncpy(m_szSourceFile, szCommandLine, NUMBER_OF(m_szSourceFile));
		m_szSourceFile[NUMBER_OF(m_szSourceFile) - 1] = L'\0';
	}

	return NOERROR;
}

HRESULT CWorkItem::HrSave(HANDLE hFile)
{
	HRESULT hr = NOERROR;

	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	WCHAR szBuffer2[MSINFHLP_MAX_PATH];

	hr = ::HrWriteFormatted(hFile, L"Type: %s\r\n", (m_type == eWorkItemFile) ? L"File" : L"Command");
	if (FAILED(hr))
		goto Finish;

	hr = ::HrWriteFormatted(hFile, L"SerialNumber: %u\r\n", m_ulSerialNumber);
	if (FAILED(hr))
		goto Finish;

	if (m_szSourceFile[0] != L'\0')
	{
		hr = ::HrWriteFormatted(hFile, L"Source: %s\r\n", m_szSourceFile);
		if (FAILED(hr))
			goto Finish;
	}

	if ((m_dwMSSourceVersion != 0xffffffff) || (m_dwLSSourceVersion != 0xffffffff))
	{
		hr = ::HrWriteFormatted(hFile, L"SourceFileVersion: 0x%08lX 0x%08lX\r\n", m_dwMSSourceVersion, m_dwLSSourceVersion);
		if (FAILED(hr))
			goto Finish;
	}

	hr = this->HrWriteBool(hFile, L"SourceSelfRegistering", m_fSourceSelfRegistering);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"SourceIsEXE", m_fSourceIsEXE);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"SourceIsDLL", m_fSourceIsDLL);
	if (FAILED(hr))
		goto Finish;

	if (m_dwSourceAttributes != 0xffffffff)
	{
		hr = ::HrWriteFormatted(hFile, L"SourceAttributes: 0x%08lX\r\n", m_dwSourceAttributes);
		if (FAILED(hr))
			goto Finish;
	}

	if ((m_ftSource.dwHighDateTime != 0xffffffff) || (m_ftSource.dwLowDateTime != 0xffffffff))
	{
		hr = ::HrWriteFormatted(hFile, L"SourceFiletime: 0x%08lX 0x%08lX\r\n", m_ftSource.dwHighDateTime, m_ftSource.dwLowDateTime);
		if (FAILED(hr))
			goto Finish;
	}

	if (m_uliSourceBytes.QuadPart != 0)
	{
		hr = ::HrWriteFormatted(hFile, L"SourceBytes: %I64u\r\n", m_uliSourceBytes.QuadPart);
		if (FAILED(hr))
			goto Finish;
	}

	if (m_szTargetFile[0] != L'\0')
	{
		hr = ::HrWriteFormatted(hFile, L"Target: %s\r\n", m_szTargetFile);
		if (FAILED(hr))
			goto Finish;
	}

	if ((m_dwMSTargetVersion != 0xffffffff) || (m_dwLSTargetVersion != 0xffffffff))
	{
		hr = ::HrWriteFormatted(hFile, L"TargetFileVersion: 0x%08lX 0x%08lX\r\n", m_dwMSTargetVersion, m_dwLSTargetVersion);
		if (FAILED(hr))
			goto Finish;
	}

	hr = this->HrWriteBool(hFile, L"TargetSelfRegistering", m_fTargetSelfRegistering);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"TargetIsEXE", m_fTargetIsEXE);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"TargetIsDLL", m_fTargetIsDLL);
	if (FAILED(hr))
		goto Finish;

	if (m_dwTargetAttributes != 0xffffffff)
	{
		hr = ::HrWriteFormatted(hFile, L"TargetAttributes: 0x%08lX\r\n", m_dwTargetAttributes);
		if (FAILED(hr))
			goto Finish;
	}

	if ((m_ftTarget.dwHighDateTime != 0xffffffff) || (m_ftTarget.dwLowDateTime != 0xffffffff))
	{
		hr = ::HrWriteFormatted(hFile, L"TargetFiletime: 0x%08lX 0x%08lX\r\n", m_ftTarget.dwHighDateTime, m_ftTarget.dwLowDateTime);
		if (FAILED(hr))
			goto Finish;
	}

	if (m_uliTargetBytes.QuadPart != 0)
	{
		hr = ::HrWriteFormatted(hFile, L"TargetBytes: %I64u\r\n", m_uliTargetBytes.QuadPart);
		if (FAILED(hr))
			goto Finish;
	}

	if (m_szTemporaryFile[0] != L'\0')
	{
		hr = ::HrWriteFormatted(hFile, L"TemporaryFile: %s\r\n", m_szTemporaryFile);
		if (FAILED(hr))
			goto Finish;
	}

	hr = this->HrWriteBool(hFile, L"ErrorInWorkItem", m_fErrorInWorkItem);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"IsRefCounted", m_fIsRefCounted);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RefCountUpdated", m_fRefCountUpdated);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"NeedsUpdate", m_fNeedsUpdate);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"FileUpdated", m_fFileUpdated);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"StillExists", m_fStillExists);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"TemporaryFileReady", m_fTemporaryFileReady);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"TemporaryFilesSwapped", m_fTemporaryFilesSwapped);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"AlreadyExists", m_fAlreadyExists);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"DeferredRenameRequired", m_fDeferredRenameRequired);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"DeferredRenamePending", m_fDeferredRenamePending);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"ManualRenameOnRebootRequired", m_fManualRenameOnRebootRequired);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"ToBeDeleted", m_fToBeDeleted);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"ToBeSaved", m_fToBeSaved);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"AskOnRefCountZeroDelete", m_fAskOnRefCountZeroDelete);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"CopyOnInstall", m_fCopyOnInstall);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"UnconditionalDeleteOnUninstall", m_fUnconditionalDeleteOnUninstall);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RegisterAsDCOMComponent", m_fRegisterAsDCOMComponent);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"AddToRegistry", m_fAddToRegistry);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"DeleteFromRegistry", m_fDeleteFromRegistry);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RunBeforeInstall", m_fRunBeforeInstall);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RunAfterInstall", m_fRunAfterInstall);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RunBeforeUninstall", m_fRunBeforeUninstall);
	if (FAILED(hr))
		goto Finish;

	hr = this->HrWriteBool(hFile, L"RunAfterUninstall", m_fRunAfterUninstall);
	if (FAILED(hr))
		goto Finish;

	if (m_dwFileReferenceCount != 0xffffffff)
	{
		hr = ::HrWriteFormatted(hFile, L"ReferenceCount: %u\r\n", m_dwFileReferenceCount);
		if (FAILED(hr))
			goto Finish;
	}

	::HrWriteFormatted(hFile, L"[END]\r\n");
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItem::HrWriteBool(HANDLE hFile, LPCWSTR szName, bool fValue)
{
	HRESULT hr = NOERROR;

	if (fValue)
		hr = ::HrWriteFormatted(hFile, L"%s: true\r\n", szName);

	return hr;
}

HRESULT CWorkItem::HrLoad(LPCWSTR &rpsz)
{
	HRESULT hr = NOERROR;
	WCHAR szName[_MAX_PATH];
	WCHAR szValue[MSINFHLP_MAX_PATH];

	bool fAnyAttributesRead = false;

	for (;;)
	{
		hr = ::HrReadLine(rpsz, NUMBER_OF(szName), szName, NUMBER_OF(szValue), szValue);
		if (FAILED(hr))
		{
			::VLog(L"Failed to read line from mapped file; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (hr == S_FALSE)
		{
			if (fAnyAttributesRead)
				hr = NOERROR;
			
			break;
		}

		if (wcscmp(szName, L"Type") == 0)
		{
			if (wcscmp(szValue, L"File") == 0)
				m_type = eWorkItemFile;
			else if (wcscmp(szValue, L"Command") == 0)
				m_type = eWorkItemCommand;
			else
			{
				::VLog(L"Invalid work item type in persisted work item: \"%s\"", szValue);
				hr = E_FAIL;
				::SetErrorInfo(0, NULL);
				goto Finish;
			}
		}
		else if (wcscmp(szName, L"SerialNumber") == 0)
		{
			WCHAR *pszTemp = NULL;
			m_ulSerialNumber = wcstoul(szValue, &pszTemp, 10);
		}
		else if (wcscmp(szName, L"Source") == 0)
		{
			wcsncpy(m_szSourceFile, szValue, NUMBER_OF(m_szSourceFile));
			m_szSourceFile[NUMBER_OF(m_szSourceFile) - 1] = L'\0';
		}
		else if (wcscmp(szName, L"SourceFileVersion") == 0)
		{
			swscanf(szValue, L"0x%x 0x%x", &m_dwMSSourceVersion, &m_dwLSSourceVersion);
		}
		else if (wcscmp(szName, L"SourceSelfRegistering") == 0)
		{
			m_fSourceSelfRegistering = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"SourceIsEXE") == 0)
		{
			m_fSourceIsEXE = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"SourceIsDLL") == 0)
		{
			m_fSourceIsDLL = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"SourceAttributes") == 0)
		{
			swscanf(szValue, L"0x%x", &m_dwSourceAttributes);
		}
		else if (wcscmp(szName, L"SourceFiletime") == 0)
		{
			swscanf(szValue, L"0x%x 0x%x", &m_ftSource.dwHighDateTime, &m_ftSource.dwLowDateTime);
		}
		else if (wcscmp(szName, L"SourceBytes") == 0)
		{
			swscanf(szValue, L"%I64u", &m_uliSourceBytes.QuadPart);
		}
		else if (wcscmp(szName, L"Target") == 0)
		{
			wcsncpy(m_szTargetFile, szValue, NUMBER_OF(m_szTargetFile));
			m_szTargetFile[NUMBER_OF(m_szTargetFile) - 1] = L'\0';
		}
		else if (wcscmp(szName, L"TargetFileVersion") == 0)
		{
			swscanf(szValue, L"0x%x 0x%x", &m_dwMSTargetVersion, &m_dwLSTargetVersion);
		}
		else if (wcscmp(szName, L"TargetSelfRegistering") == 0)
		{
			m_fTargetSelfRegistering = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"TargetIsEXE") == 0)
		{
			m_fTargetIsEXE = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"TargetIsDLL") == 0)
		{
			m_fTargetIsDLL = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"TargetAttributes") == 0)
		{
			swscanf(szValue, L"0x%x", &m_dwTargetAttributes);
		}
		else if (wcscmp(szName, L"TargetFiletime") == 0)
		{
			swscanf(szValue, L"0x%x 0x%x", &m_ftTarget.dwHighDateTime, &m_ftTarget.dwLowDateTime);
		}
		else if (wcscmp(szName, L"TargetBytes") == 0)
		{
			swscanf(szValue, L"%I64u", &m_uliTargetBytes.QuadPart);
		}
		else if (wcscmp(szName, L"TemporaryFile") == 0)
		{
			wcsncpy(m_szTemporaryFile, szValue, NUMBER_OF(m_szTemporaryFile));
			m_szTemporaryFile[NUMBER_OF(m_szTemporaryFile) - 1] = L'\0';
		}
		else if (wcscmp(szName, L"ErrorInWorkItem") == 0)
		{
			m_fErrorInWorkItem = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"IsRefCounted") == 0)
		{
			m_fIsRefCounted = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RefCountUpdated") == 0)
		{
			m_fRefCountUpdated = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"NeedsUpdate") == 0)
		{
			m_fNeedsUpdate = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"FileUpdated") == 0)
		{
			m_fFileUpdated = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"StillExists") == 0)
		{
			m_fStillExists = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"TemporaryFileReady") == 0)
		{
			m_fTemporaryFileReady = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"TemporaryFilesSwapped") == 0)
		{
			m_fTemporaryFilesSwapped = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"AlreadyExists") == 0)
		{
			m_fAlreadyExists = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"DeferredRenameRequired") == 0)
		{
			m_fDeferredRenameRequired = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"DeferredRenamePending") == 0)
		{
			m_fDeferredRenamePending = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"ManualRenameOnRebootRequired") == 0)
		{
			m_fManualRenameOnRebootRequired = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"ToBeDeleted") == 0)
		{
			m_fToBeDeleted = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"ToBeSaved") == 0)
		{
			m_fToBeSaved = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"AskOnRefCountZeroDelete") == 0)
		{
			m_fAskOnRefCountZeroDelete = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"CopyOnInstall") == 0)
		{
			m_fCopyOnInstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"UnconditionalDeleteOnUninstall") == 0)
		{
			m_fUnconditionalDeleteOnUninstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RegisterAsDCOMComponent") == 0)
		{
			m_fRegisterAsDCOMComponent = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"AddToRegistry") == 0)
		{
			m_fAddToRegistry = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"DeleteFromRegistry") == 0)
		{
			m_fDeleteFromRegistry = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RunBeforeInstall") == 0)
		{
			m_fRunBeforeInstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RunAfterInstall") == 0)
		{
			m_fRunAfterInstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RunBeforeUninstall") == 0)
		{
			m_fRunBeforeUninstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"RunAfterUninstall") == 0)
		{
			m_fRunAfterUninstall = this->FStringToBool(szValue);
		}
		else if (wcscmp(szName, L"ReferenceCount") == 0)
		{
			swscanf(szName, L"%u", m_dwFileReferenceCount);
		}
		else
		{
			::VLog(L"Unexpected work item value name: \"%s\"", szName);
			::SetErrorInfo(0, NULL);
			hr = E_FAIL;
			goto Finish;
		}

		fAnyAttributesRead = true;
	}

Finish:
	return hr;
}

bool CWorkItem::FStringToBool(LPCWSTR szValue)
{
	if (_wcsicmp(szValue, L"true") == 0)
		return true;

	if (_wcsicmp(szValue, L"false") == 0)
		return false;

	::VLog(L"Unrecognizable bool value: \"%s\"", szValue);

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\inc\sxsexpress.h ===
#pragma once

#define SXSEXPRESS_RESOURCE_TYPE            (L"SXSEXPRESSCABINET")
#define SXSEXPRESS_RESOURCE_NAME            (L"SXSEXPRESSBASECABINET")
#define SXSEXPRESS_POSTINSTALL_STEP_TYPE    (L"SXSEXPRESSPOSTINSTALLSTEP")
#define SXSEXPRESS_TARGET_RESOURCE      (3301)
#define INF_SPECIAL_NAME                    "DownlevelInstall.inf"
#ifndef NUMBER_OF
#define NUMBER_OF(q) (sizeof(q)/sizeof(*q))
#endif

//
// hObjectInstance - HINSTANCE of the image in which the cabs in question
//      live.  NULL is an invalid parameter - always call GetModuleHandle,
//      even if you're an EXE
//
BOOL
SxsExpressCore(
    HINSTANCE hObjectInstance
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\dll\dllmain.cpp ===
#include "windows.h"
#include "sxsexpress.h"
#include "stdlib.h"
#include "stdio.h"

HINSTANCE g_hOurInstance = NULL;


BOOL WINAPI 
DllMain(
    HINSTANCE hDllHandle, 
    DWORD dwReason, 
    PVOID pvReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hOurInstance = hDllHandle;
    }

    return TRUE;
}


HRESULT
DllInstall(
    BOOL bInstall,
    PCWSTR pcwszCommandLine
    )
{
    if (bInstall)
    {
        return SxsExpressCore(g_hOurInstance) ? S_OK : HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT
PerformInstallation(
    BOOL bInstall,
    PCSTR pcszCommandLine
    )
{
    return DllInstall(bInstall, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\core\worklist.cpp ===
#include "stdinc.h"
#include "bindstat.h"

typedef WINSHELLAPI HRESULT (WINAPI *SHASYNCINSTALLDISTRIBUTIONUNIT)(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, DWORD, LPCWSTR, IBindCtx *, LPVOID, DWORD);

static HRESULT HrParseJavaPkgMgrInstall(LPCWSTR szCmdLine, ULONG cchFilename, WCHAR szFilename[], DWORD &dwFileType, 
						   DWORD &dwHighVersion, DWORD &dwLowVersion, DWORD &dwBuild, 
						   DWORD &dwPackageFlags, DWORD &dwInstallFlags, ULONG cchNameSpace, WCHAR szNameSpace[]);

static bool ConstantPoolNameEquals(ULONG cCP, LPBYTE *prgpbCP, ULONG iCP, char szString[]);

static void CALLBACK TimerProc_PostRunProcess(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
// Yes, we leak this event handle.  I don't think it's worth the effort to meaningfully clean it up.
// -mgrier 3/24/98
static HANDLE s_hEvent_PostRunProcess = NULL;
static UINT s_uiTimer_PostRunProcess = 0;

//***********************************************************
//let's define some generic class for usage:
//

CWorkItemList::CWorkItemList()
{
	ULONG i;

	m_cWorkItem = 0;
	m_pWorkItem_First = NULL;
	m_pWorkItem_Last = NULL;

	m_cPreinstallCommands = 0;
	m_cPostinstallCommands = 0;
	m_cPreuninstallCommands = 0;
	m_cPostuninstallCommands = 0;

	for (i=0; i<NUMBER_OF(m_rgpWorkItemBucketTable_Source); i++)
		m_rgpWorkItemBucketTable_Source[i] = NULL;

	for (i=0; i<NUMBER_OF(m_rgpWorkItemBucketTable_Target); i++)
		m_rgpWorkItemBucketTable_Target[i] = NULL;

	for (i=0; i<NUMBER_OF(m_rgpStringBucketTable); i++)
		m_rgpStringBucketTable[i] = NULL;
}

CWorkItemList::~CWorkItemList()
{
	CWorkItem *pWorkItem = m_pWorkItem_First;

	while (pWorkItem != NULL)
	{
		CWorkItem *pWorkItem_Next = pWorkItem->m_pWorkItem_Next;
		delete pWorkItem;
		pWorkItem = pWorkItem_Next;
	}

	ULONG i;

	for (i=0; i<NUMBER_OF(m_rgpWorkItemBucketTable_Source); i++)
	{
		WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Source[i];

		while (pWorkItemBucket != NULL)
		{
			WorkItemBucket *pWorkItemBucket_Next = pWorkItemBucket->m_pWorkItemBucket_Next;
			delete pWorkItemBucket;
			pWorkItemBucket = pWorkItemBucket_Next;
		}

		m_rgpWorkItemBucketTable_Source[i] = NULL;
	}

	for (i=0; i<NUMBER_OF(m_rgpWorkItemBucketTable_Target); i++)
	{
		WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Target[i];

		while (pWorkItemBucket != NULL)
		{
			WorkItemBucket *pWorkItemBucket_Next = pWorkItemBucket->m_pWorkItemBucket_Next;
			delete pWorkItemBucket;
			pWorkItemBucket = pWorkItemBucket_Next;
		}

		m_rgpWorkItemBucketTable_Target[i] = NULL;
	}

	for (i=0; i<NUMBER_OF(m_rgpStringBucketTable); i++)
	{
		StringBucket *pStringBucket = m_rgpStringBucketTable[i];

		while (pStringBucket != NULL)
		{
			StringBucket *pStringBucket_Next = pStringBucket->m_pStringBucket_Next;
			delete pStringBucket;
			pStringBucket = pStringBucket_Next;
		}

		m_rgpStringBucketTable[i] = NULL;
	}
}

HRESULT CWorkItemList::HrLoad(LPCWSTR szFilename)
{
	HRESULT hr = NOERROR;
	WCHAR szUnicodeFileSignature[1] = { 0xfeff };
	LPCWSTR pszFileMap = NULL;
	LPCWSTR pszFileCurrent = NULL;
	HANDLE hFilemap = NULL;
	ULARGE_INTEGER uliSize;
	WCHAR szNameBuffer[_MAX_PATH];
	WCHAR szValueBuffer[MSINFHLP_MAX_PATH];
	CHAR aszNameBuffer[_MAX_PATH];

	::VLog(L"Loading work item list from \"%s\"", szFilename);

	HANDLE hFile = NVsWin32::CreateFileW(szFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to open file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}
	uliSize.QuadPart = 0;

	::SetLastError(NO_ERROR);

	uliSize.LowPart = ::GetFileSize(hFile, &uliSize.HighPart);

	// If we failed, lowpart will be 0xffffffff.  But the file could just be of that
	// size, so we also have to check the last error.
	if (uliSize.LowPart == 0xffffffff)
	{
		const DWORD dwLastError = ::GetLastError();
		if (dwLastError != NO_ERROR)
		{
			::VLog(L"Unable to get file size; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	if (uliSize.QuadPart < 2)
	{
		VLog(L"File is too small to be a list of work items");
		::SetErrorInfo(0, NULL);
		hr = E_FAIL;
		goto Finish;
	}

	hFilemap = ::CreateFileMapping(hFile, NULL, PAGE_READONLY, uliSize.HighPart, uliSize.LowPart, NULL);
	if (hFilemap == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to create file mapping object; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	pszFileMap = (LPCWSTR) ::MapViewOfFile(hFilemap, FILE_MAP_READ, 0, 0, 0);
	if (pszFileMap == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to map view of file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (pszFileMap[0] != szUnicodeFileSignature[0])
	{
		VLog(L"Missing Unicode signature reading file");
		hr = E_FAIL;
		::SetErrorInfo(0, NULL);
		goto Finish;
	}

	pszFileCurrent = pszFileMap + 1;

	for (;;)
	{
		int iResult;

		hr = ::HrReadLine(pszFileCurrent, NUMBER_OF(szNameBuffer), szNameBuffer, NUMBER_OF(szValueBuffer), szValueBuffer);
		if (FAILED(hr))
		{
			::VLog(L"Unexpected error reading line from file; hresult = 0x%08lx", hr);
			goto Finish;
		}

		// If we hit the [END] line, move on to the next section...
		if (hr == S_FALSE)
		{
			::VLog(L"Hit end of strings in string table");
			break;
		}

		iResult = ::WideCharToMultiByte(CP_ACP, 0, szNameBuffer, -1, aszNameBuffer, NUMBER_OF(aszNameBuffer), NULL, NULL);
		if (iResult == -1)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to convert key from Unicode to CP_ACP; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		hr = this->HrAddString(aszNameBuffer, szValueBuffer);
		if (FAILED(hr))
		{
			::VLog(L"Unable to add string to string table; hresult = 0x%08lx", hr);
			goto Finish;
		}
	}

	::VLog(L"Done string table load; starting work item load");

	for (;;)
	{
		CWorkItem *pWorkItem = new CWorkItem(CWorkItem::eWorkItemFile);

		if (pWorkItem == NULL)
		{
			::VLog(L"Out of memory loading work item list");

			::SetErrorInfo(0, NULL);
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrLoad(pszFileCurrent);
		if (FAILED(hr))
		{
			::VLog(L"Loading work item failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (hr == S_FALSE)
		{
			::VLog(L"End of work item list hit");
			delete pWorkItem;
			break;
		}

		hr = this->HrAppend(pWorkItem);
		if (FAILED(hr))
		{
			::VLog(L"Failed to append newly de-persisted work item; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (pWorkItem->m_fRunBeforeInstall)
			m_cPreinstallCommands++;

		if (pWorkItem->m_fRunAfterInstall)
			m_cPostinstallCommands++;

		if (pWorkItem->m_fRunBeforeUninstall)
			m_cPreuninstallCommands++;

		if (pWorkItem->m_fRunAfterUninstall)
			m_cPostuninstallCommands++;
	}

	hr = NOERROR;

Finish:
	if (pszFileMap != NULL)
		::UnmapViewOfFile(pszFileMap);

	if (hFilemap != NULL)
		::CloseHandle(hFilemap);

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
		::CloseHandle(hFile);

	return hr;
}

HRESULT CWorkItemList::HrSave(LPCWSTR szFilename)
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	WCHAR szUnicodeFileSignature[1] = { 0xfeff };
	DWORD dwBytesWritten = 0;
	bool fFirst = true;
	ULONG i;

	HANDLE hFile = NVsWin32::CreateFileW(szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (!::WriteFile(hFile, (LPBYTE) szUnicodeFileSignature, NUMBER_OF(szUnicodeFileSignature) * sizeof(WCHAR), &dwBytesWritten, NULL))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	// Write out all the strings:
	for (i=0; i<NUMBER_OF(m_rgpStringBucketTable); i++)
	{
		StringBucket *pStringBucket = m_rgpStringBucketTable[i];

		while (pStringBucket != NULL)
		{
			hr = ::HrWriteFormatted(hFile, L"%S: %s\r\n", pStringBucket->m_szKey, pStringBucket->m_wszValue);
			if (FAILED(hr))
				goto Finish;

			pStringBucket = pStringBucket->m_pStringBucket_Next;
		}
	}

	hr = ::HrWriteFormatted(hFile, L"[END]\r\n");
	if (FAILED(hr))
		goto Finish;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!fFirst)
		{
			WCHAR szLineSeparator[2] = { L'\r', L'\n' };

			if (!::WriteFile(hFile, (LPBYTE) szLineSeparator, sizeof(szLineSeparator), &dwBytesWritten, NULL))
			{
				const DWORD dwLastError = ::GetLastError();
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}
		else
			fFirst = false;

		hr = iter->HrSave(hFile);
		if (FAILED(hr))
			goto Finish;
	}

	if (!::WriteFile(hFile, (LPBYTE) L"[END]\r\n", 7 * sizeof(WCHAR), &dwBytesWritten, NULL))
	{
		const DWORD dwLastError = ::GetLastError();
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

Finish:
	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
		::CloseHandle(hFile);

	return hr;
}

ULONG CWorkItemList::UlHashFilename(LPCWSTR szFilename)
{
	ULONG ulPK = 0;

	LPCWSTR pszCurrent = szFilename;
	WCHAR wch;

	while ((wch = *pszCurrent++) != L'\0')
	{
		if (iswupper(wch))
			wch = towlower(wch);

		ulPK = (ulPK * 65599) + wch;
	}

	return ulPK;
}

bool CWorkItemList::FSameFilename(LPCWSTR szFile1, LPCWSTR szFile2)
{
	return (_wcsicmp(szFile1, szFile2) == 0);
}

CWorkItem *CWorkItemList::PwiFindBySource(LPCWSTR szSourceFile)
{
	CWorkItem *pResult = NULL;

	ULONG ulPK = this->UlHashFilename(szSourceFile);
	ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Source);
	WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Source[iWorkItemBucket];

	while (pWorkItemBucket != NULL)
	{
		if (this->FSameFilename(szSourceFile, pWorkItemBucket->m_pWorkItem->m_szSourceFile))
			break;

		pWorkItemBucket = pWorkItemBucket->m_pWorkItemBucket_Next;
	}

	if (pWorkItemBucket != NULL)
		return pWorkItemBucket->m_pWorkItem;

	return NULL;
}

CWorkItem *CWorkItemList::PwiFindByTarget(LPCWSTR szTargetFile)
{
	CWorkItem *pResult = NULL;

	ULONG ulPK = this->UlHashFilename(szTargetFile);
	ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Target);
	WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Target[iWorkItemBucket];

	while (pWorkItemBucket != NULL)
	{
		if (this->FSameFilename(szTargetFile, pWorkItemBucket->m_pWorkItem->m_szTargetFile))
			break;

		pWorkItemBucket = pWorkItemBucket->m_pWorkItemBucket_Next;
	}

	if (pWorkItemBucket != NULL)
		return pWorkItemBucket->m_pWorkItem;

	return NULL;
}

HRESULT CWorkItemList::HrAppend(CWorkItem *pWorkItem, bool fAddToTables)
{
	HRESULT hr = NOERROR;

	WorkItemBucket *pWorkItemBucket_1 = NULL;
	WorkItemBucket *pWorkItemBucket_2 = NULL;

	assert(pWorkItem != NULL);

	if (pWorkItem == NULL)
	{
		::SetErrorInfo(0, NULL);
		hr = E_INVALIDARG;
		goto Finish;
	}

	if (fAddToTables)
	{
		// First let's see if we've screwed up somehow and this is a duplicate
		if (pWorkItem->m_szSourceFile[0] != L'\0')
		{
			ULONG ulPK = this->UlHashFilename(pWorkItem->m_szSourceFile);
			ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Source);
			WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Source[iWorkItemBucket];

			while (pWorkItemBucket != NULL)
			{
				assert(pWorkItemBucket->m_pWorkItem != pWorkItem);

				if (this->FSameFilename(pWorkItem->m_szSourceFile, pWorkItemBucket->m_pWorkItem->m_szSourceFile))
					break;

				pWorkItemBucket = pWorkItemBucket->m_pWorkItemBucket_Next;
			}

			if (pWorkItemBucket != NULL)
			{
				pWorkItemBucket_1 = new WorkItemBucket;
				if (pWorkItemBucket_1 == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto Finish;
				}
			}
		}

		if (pWorkItem->m_szTargetFile[0] != L'\0')
		{
			ULONG ulPK = this->UlHashFilename(pWorkItem->m_szTargetFile);
			ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Target);
			WorkItemBucket *pWorkItemBucket = m_rgpWorkItemBucketTable_Target[iWorkItemBucket];

			while (pWorkItemBucket != NULL)
			{
				assert(pWorkItemBucket->m_pWorkItem != pWorkItem);

				if (this->FSameFilename(pWorkItem->m_szTargetFile, pWorkItemBucket->m_pWorkItem->m_szTargetFile))
					break;

				pWorkItemBucket = pWorkItemBucket->m_pWorkItemBucket_Next;
			}

			if (pWorkItemBucket == NULL)
			{
				pWorkItemBucket_2 = new WorkItemBucket;
				if (pWorkItemBucket_2 == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto Finish;
				}
			}
		}

		// Let's insert it into whichever tables it's not in...
		if (pWorkItemBucket_1 != NULL)
		{
			ULONG ulPK = this->UlHashFilename(pWorkItem->m_szSourceFile);
			ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Source);

			pWorkItemBucket_1->m_pWorkItemBucket_Next = m_rgpWorkItemBucketTable_Source[iWorkItemBucket];
			pWorkItemBucket_1->m_pWorkItem = pWorkItem;
			m_rgpWorkItemBucketTable_Source[iWorkItemBucket] = pWorkItemBucket_1;
			pWorkItemBucket_1 = NULL;
		}

		if (pWorkItemBucket_2 != NULL)
		{
			ULONG ulPK = this->UlHashFilename(pWorkItem->m_szTargetFile);
			ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Target);

			pWorkItemBucket_2->m_pWorkItemBucket_Next = m_rgpWorkItemBucketTable_Target[iWorkItemBucket];
			pWorkItemBucket_2->m_pWorkItem = pWorkItem;
			m_rgpWorkItemBucketTable_Target[iWorkItemBucket] = pWorkItemBucket_2;
			pWorkItemBucket_2 = NULL;
		}
	}

	pWorkItem->m_pWorkItem_Next = NULL;
	pWorkItem->m_pWorkItem_Prev = m_pWorkItem_Last;

	if (m_pWorkItem_Last != NULL)
		m_pWorkItem_Last->m_pWorkItem_Next = pWorkItem;
	else
		m_pWorkItem_First = pWorkItem;

	m_pWorkItem_Last = pWorkItem;

	m_cWorkItem++;

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrAddPreinstallRun(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	LPCWSTR pszCurrent = szLine;
	CWorkItem *pWorkItem = NULL;
	
	for (;;)
	{
		const LPCWSTR pszSemicolon = wcschr(pszCurrent, L';');
		const LPCWSTR pszEnd = (pszSemicolon == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszSemicolon;

		ULONG cch = pszEnd - pszCurrent;

		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);

		if (pWorkItem == NULL)
		{
			::SetErrorInfo(0, NULL);
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetCommandLine(szBuffer);
		if (FAILED(hr))
			goto Finish;

		pWorkItem->m_fRunBeforeInstall = true;

		hr = this->HrAppend(pWorkItem, false);
		if (FAILED(hr))
			goto Finish;

		m_cPreinstallCommands++;

		pWorkItem = NULL;

		if (pszSemicolon == NULL)
			break;

		pszCurrent = pszSemicolon + 1;
	}

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddPreuninstallRun(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	LPCWSTR pszCurrent = szLine;
	CWorkItem *pWorkItem = NULL;
	
	for (;;)
	{
		const LPCWSTR pszSemicolon = wcschr(pszCurrent, L';');
		const LPCWSTR pszEnd = (pszSemicolon == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszSemicolon;

		ULONG cch = pszEnd - pszCurrent;

		if (cch >= (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		CWorkItem *pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);

		if (pWorkItem == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetCommandLine(szBuffer);
		if (FAILED(hr))
			goto Finish;

		pWorkItem->m_fRunBeforeUninstall = true;

		hr = this->HrAppend(pWorkItem, false);
		if (FAILED(hr))
			goto Finish;

		m_cPreuninstallCommands++;
		pWorkItem = NULL;

		if (pszSemicolon == NULL)
			break;

		pszCurrent = pszSemicolon + 1;
	}

	hr = NOERROR;

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;

	return hr;
}

HRESULT CWorkItemList::HrAddPostinstallRun(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	LPCWSTR pszCurrent = szLine;
	CWorkItem *pWorkItem = NULL;
	
	for (;;)
	{
		const LPCWSTR pszSemicolon = wcschr(pszCurrent, L';');
		const LPCWSTR pszEnd = (pszSemicolon == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszSemicolon;

		ULONG cch = pszEnd - pszCurrent;

		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);

		if (pWorkItem == NULL)
		{
			::SetErrorInfo(0, NULL);
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetCommandLine(szBuffer);
		if (FAILED(hr))
			goto Finish;

		pWorkItem->m_fRunAfterInstall = true;

		hr = this->HrAppend(pWorkItem, false);
		if (FAILED(hr))
			goto Finish;

		m_cPostinstallCommands++;
		pWorkItem = NULL;

		if (pszSemicolon == NULL)
			break;

		pszCurrent = pszSemicolon + 1;
	}

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddPostuninstallRun(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	LPCWSTR pszCurrent = szLine;
	CWorkItem *pWorkItem = NULL;
	
	for (;;)
	{
		const LPCWSTR pszSemicolon = wcschr(pszCurrent, L';');
		const LPCWSTR pszEnd = (pszSemicolon == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszSemicolon;

		ULONG cch = pszEnd - pszCurrent;

		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);

		if (pWorkItem == NULL)
		{
			::SetErrorInfo(0, NULL);
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetCommandLine(szBuffer);
		if (FAILED(hr))
			goto Finish;

		pWorkItem->m_fRunAfterUninstall = true;

		hr = this->HrAppend(pWorkItem, false);
		if (FAILED(hr))
			goto Finish;

		m_cPostuninstallCommands++;
		pWorkItem = NULL;

		if (pszSemicolon == NULL)
			break;

		pszCurrent = pszSemicolon + 1;
	}

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddRegisterOCX(LPCWSTR szLine)
{
	return NOERROR;
}

HRESULT CWorkItemList::HrAddDelReg(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;

	CWorkItem *pWorkItem = NULL;

	pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);
	if (pWorkItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	hr = pWorkItem->HrSetCommandLine(szLine);
	if (FAILED(hr))
		goto Finish;

	pWorkItem->m_fDeleteFromRegistry = true;

	hr = this->HrAppend(pWorkItem);
	if (FAILED(hr))
		goto Finish;

	pWorkItem = NULL;
	hr = NOERROR;

Finish:
	delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddAddReg(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;

	CWorkItem *pWorkItem = NULL;

	pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);
	if (pWorkItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	hr = pWorkItem->HrSetCommandLine(szLine);
	if (FAILED(hr))
		goto Finish;

	pWorkItem->m_fAddToRegistry = true;

	hr = this->HrAppend(pWorkItem);
	if (FAILED(hr))
		goto Finish;

	pWorkItem = NULL;
	hr = NOERROR;

Finish:
	delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddDCOMComponent(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;

	CWorkItem *pWorkItem = NULL;

	pWorkItem = new CWorkItem(CWorkItem::eWorkItemCommand);
	if (pWorkItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Finish;
	}

	hr = pWorkItem->HrSetCommandLine(szLine);
	if (FAILED(hr))
		goto Finish;

	pWorkItem->m_fRegisterAsDCOMComponent = true;

	hr = this->HrAppend(pWorkItem);
	if (FAILED(hr))
		goto Finish;

	pWorkItem = NULL;
	hr = NOERROR;

Finish:
	delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddRefCount(LPCWSTR szLine)
{
	HRESULT hr = NOERROR;

	LPCWSTR pszVBar = wcschr(szLine, L'|');
	LPCWSTR pszFilename = szLine;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];

	bool fLoudDecrement = false;

	if (pszVBar != NULL)
	{
		if (pszVBar[1] == L'1')
			fLoudDecrement = true;

		ULONG cch = pszVBar - szLine;

		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, szLine, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';
		pszFilename = szBuffer;
	}

	CWorkItem *pWorkItem = NULL;

	pWorkItem = this->PwiFindByTarget(pszFilename);
	if (pWorkItem == NULL)
	{
		pWorkItem = new CWorkItem(CWorkItem::eWorkItemFile);
		if (pWorkItem == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetTargetFile(pszFilename);
		if (FAILED(hr))
			goto Finish;

		hr = this->HrAppend(pWorkItem);
		if (FAILED(hr))
			goto Finish;
	}

	pWorkItem->m_fIsRefCounted = true;
	pWorkItem->m_fAskOnRefCountZeroDelete = fLoudDecrement;

	pWorkItem = NULL;
	hr = NOERROR;

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;

	return hr;
}

HRESULT CWorkItemList::HrAddFileCopy(LPCWSTR szSource, LPCWSTR szTarget)
{
	HRESULT hr = NOERROR;

	CWorkItem *pWorkItem = NULL;

	pWorkItem = this->PwiFindByTarget(szTarget);
	if (pWorkItem == NULL)
	{
		pWorkItem = new CWorkItem(CWorkItem::eWorkItemFile);
		if (pWorkItem == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetSourceFile(szSource);
		if (FAILED(hr))
			goto Finish;

		hr = pWorkItem->HrSetTargetFile(szTarget);
		if (FAILED(hr))
			goto Finish;

		hr = this->HrAppend(pWorkItem);
		if (FAILED(hr))
			goto Finish;
	}
	else
	{
		if (this->PwiFindBySource(szSource) == NULL)
		{
			WorkItemBucket *pWorkItemBucket = new WorkItemBucket;
			if (pWorkItemBucket == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Finish;
			}

			hr = pWorkItem->HrSetSourceFile(szSource);
			if (FAILED(hr))
				goto Finish;

			ULONG ulPK = this->UlHashFilename(szSource);
			ULONG iWorkItemBucket = ulPK % NUMBER_OF(m_rgpWorkItemBucketTable_Source);

			pWorkItemBucket->m_pWorkItemBucket_Next = m_rgpWorkItemBucketTable_Source[iWorkItemBucket];
			pWorkItemBucket->m_pWorkItem = pWorkItem;
			m_rgpWorkItemBucketTable_Source[iWorkItemBucket] = pWorkItemBucket;
		}
	}

	pWorkItem->m_fCopyOnInstall = true;
	pWorkItem = NULL;

	hr = NOERROR;

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;
	return hr;
}

HRESULT CWorkItemList::HrAddFileDelete(LPCWSTR szTarget)
{
	HRESULT hr = NOERROR;

	CWorkItem *pWorkItem = NULL;

	pWorkItem = this->PwiFindByTarget(szTarget);
	if (pWorkItem == NULL)
	{
		pWorkItem = new CWorkItem(CWorkItem::eWorkItemFile);
		if (pWorkItem == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		hr = pWorkItem->HrSetTargetFile(szTarget);
		if (FAILED(hr))
			goto Finish;

		hr = this->HrAppend(pWorkItem);
		if (FAILED(hr))
			goto Finish;
	}

	pWorkItem->m_fUnconditionalDeleteOnUninstall = true;
	pWorkItem = NULL;
	hr = NOERROR;

Finish:
	if (pWorkItem != NULL)
		delete pWorkItem;

	return hr;
}

HRESULT CWorkItemList::HrRunPreinstallCommands()
{
	bool fAnyRun = false;
	HRESULT hr = NOERROR;
	// run all the pre-installation commands
	CWorkItemIter iter(this);

	bool fHasBeenWarnedAboutSubinstallers = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fRunBeforeInstall)
			continue;

		WCHAR szBuffer[_MAX_PATH];

		wcsncpy(szBuffer, iter->m_szSourceFile, NUMBER_OF(szBuffer));
		szBuffer[NUMBER_OF(szBuffer) - 1] = L'\0';

		WCHAR *pwchVBar = wcschr(szBuffer, L'|');
		if (pwchVBar != NULL)
			*pwchVBar = L'\0';

		hr = g_KProgress.HrStartStep(szBuffer);
		if (FAILED(hr))
			goto Finish;

		// Hack to deal with VB setups.  If this was foo.exe, let's look for foo.cab and foo.dat being
		// installed to the appdir.  If they are there, then we need to hide them, as well as make
		// sure that they all have the same actual base name.
		WCHAR szUnquotedCommandLine[MSINFHLP_MAX_PATH];
		WCHAR szFName[_MAX_FNAME];
		WCHAR szExt[_MAX_EXT];

		szUnquotedCommandLine[0] = L'\0';

		if (iter->m_szSourceFile[0] == L'"')
		{
			ULONG cch = wcslen(&iter->m_szSourceFile[1]);

			if (iter->m_szSourceFile[cch] == L'"')
			{
				cch--;

				if (cch < NUMBER_OF(szUnquotedCommandLine))
				{
					memcpy(szUnquotedCommandLine, &iter->m_szSourceFile[1], cch * sizeof(WCHAR));
					szUnquotedCommandLine[cch] = L'\0';
				}
			}
		}
		else
		{
			wcsncpy(szUnquotedCommandLine, iter->m_szSourceFile, NUMBER_OF(szUnquotedCommandLine));
			szUnquotedCommandLine[NUMBER_OF(szUnquotedCommandLine) - 1] = L'\0';
		}

		WCHAR *pwszEqualsEquals = wcsstr(szUnquotedCommandLine, L"==");

		if (pwszEqualsEquals != NULL)
		{
			*pwszEqualsEquals = L'\0';
			_wsplitpath(pwszEqualsEquals + 2, NULL, NULL, szFName, szExt);
		}
		else
			_wsplitpath(szUnquotedCommandLine, NULL, NULL, szFName, szExt);

		if (_wcsicmp(szExt, L".EXE") == 0)
		{
			CWorkItem *pCWorkItem_Cabinet = NULL;
			CWorkItem *pCWorkItem_DataFile = NULL;

			WCHAR szCabinetFile[_MAX_PATH];
			WCHAR szDataFile[_MAX_PATH];
			WCHAR szTempDir[_MAX_PATH];

			// When we're running, the filenames in the work item list haven't been expanded, so
			// we need to use the unexpanded forms:
			_snwprintf(szDataFile, NUMBER_OF(szDataFile), L"<AppDir>\\%s.LST", szFName);
			szDataFile[NUMBER_OF(szDataFile) - 1] = L'\0';

			pCWorkItem_DataFile = this->PwiFindByTarget(szDataFile);

			if (pCWorkItem_DataFile != NULL)
			{
				CHAR aszCurDir[_MAX_PATH];
				CHAR aszLstFile[_MAX_PATH];
				CHAR aszCabinetFile[_MAX_PATH];

				if (!::GetCurrentDirectoryA(NUMBER_OF(aszCurDir), aszCurDir))
				{
					const DWORD dwLastError = ::GetLastError();
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}

				_snprintf(aszLstFile, NUMBER_OF(aszLstFile), "%s\\%S", aszCurDir, pCWorkItem_DataFile->m_szSourceFile);

				::GetPrivateProfileStringA(
					"Bootstrap",
					"CabFile",
					"",
					aszCabinetFile,
					NUMBER_OF(aszCabinetFile),
					aszLstFile);

				_snwprintf(szCabinetFile, NUMBER_OF(szCabinetFile), L"<AppDir>\\%S", aszCabinetFile);

				pCWorkItem_Cabinet = this->PwiFindByTarget(szCabinetFile);

				if (pCWorkItem_Cabinet != NULL)
				{
					pCWorkItem_DataFile->m_fCopyOnInstall = false;
					pCWorkItem_DataFile->m_fIsRefCounted = false;

					pCWorkItem_Cabinet->m_fCopyOnInstall = false;
					pCWorkItem_Cabinet->m_fIsRefCounted = false;

					// Pick a good temporary directory name to rename all three files to, since they may have
					// unrelated filenames in the temporary directory

					WCHAR szTempExeName[_MAX_PATH];
					WCHAR szTempCabName[_MAX_PATH];
					WCHAR szTempLstName[_MAX_PATH];

					for (;;)
					{
						static int iTempFileSeq = 1;

						_snwprintf(szTempDir, NUMBER_OF(szTempDir), L"%S\\S%d\\", aszCurDir, iTempFileSeq);

						_snwprintf(szTempExeName, NUMBER_OF(szTempExeName), L"S%d\\%s.EXE", iTempFileSeq, szFName);
						_snwprintf(szTempCabName, NUMBER_OF(szTempCabName), L"S%d\\%S", iTempFileSeq, aszCabinetFile);
						_snwprintf(szTempLstName, NUMBER_OF(szTempLstName), L"S%d\\%s.LST", iTempFileSeq, szFName);

						iTempFileSeq++;

						if (NVsWin32::GetFileAttributesW(szTempDir) != 0xffffffff)
							continue;
						else
						{
							const DWORD dwLastError = ::GetLastError();
							if (dwLastError != ERROR_FILE_NOT_FOUND)
							{
								hr = HRESULT_FROM_WIN32(dwLastError);
								goto Finish;
							}
						}

						break;
					}

					if (!NVsWin32::CreateDirectoryW(szTempDir, NULL))
					{
						const DWORD dwLastError = ::GetLastError();
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}

					if (!NVsWin32::MoveFileW(szUnquotedCommandLine, szTempExeName))
					{
						const DWORD dwLastError = ::GetLastError();
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}

					if (!NVsWin32::MoveFileW(pCWorkItem_Cabinet->m_szSourceFile, szTempCabName))
					{
						const DWORD dwLastError = ::GetLastError();
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}

					if (!NVsWin32::MoveFileW(pCWorkItem_DataFile->m_szSourceFile, szTempLstName))
					{
						const DWORD dwLastError = ::GetLastError();
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}

					// Fix up the source files so that we run the right executable, and so that if the
					// user re-tries this step it'll still work right.  Note that this will also remove the
					// == from the source, since we've already performed the rename if it was present.

					iter->m_szSourceFile[0] = L'"';
					wcsncpy(&iter->m_szSourceFile[1], szTempExeName, NUMBER_OF(iter->m_szSourceFile)-2);
					iter->m_szSourceFile[NUMBER_OF(iter->m_szSourceFile) - 3] = L'\0';
					ULONG cch = wcslen(iter->m_szSourceFile);
					iter->m_szSourceFile[cch++] = L'"';
					iter->m_szSourceFile[cch++] = L'\0';

					wcsncpy(pCWorkItem_Cabinet->m_szSourceFile, szTempCabName, NUMBER_OF(pCWorkItem_Cabinet->m_szSourceFile));
					pCWorkItem_Cabinet->m_szSourceFile[NUMBER_OF(pCWorkItem_Cabinet->m_szSourceFile) - 1] = L'\0';

					wcsncpy(pCWorkItem_DataFile->m_szSourceFile, szTempLstName, NUMBER_OF(pCWorkItem_DataFile->m_szSourceFile));
					pCWorkItem_DataFile->m_szSourceFile[NUMBER_OF(pCWorkItem_DataFile->m_szSourceFile) - 1] = L'\0';
				}
			}
		}
		else if (_wcsicmp(szExt, L".CAB") == 0)
		{
			::VLog(L"Installing nested cab: \"%s\"", szUnquotedCommandLine);
			WCHAR szCommandLine1[MSINFHLP_MAX_PATH];
			WCHAR szCommandLine2[MSINFHLP_MAX_PATH];
			_snwprintf(szCommandLine1, NUMBER_OF(szCommandLine1), L"rundll32 <SysDir>\\msjava.dll,JavaPkgMgr_Install %s,0,0,0,0,1,0,,,1", szUnquotedCommandLine);
			::VExpandFilename(szCommandLine1, NUMBER_OF(szCommandLine2), szCommandLine2);
			hr = this->HrInstallViaJPM(szCommandLine2);
			if (FAILED(hr))
				goto Finish;
		}

		hr = this->HrRunCommand(iter->m_szSourceFile, fHasBeenWarnedAboutSubinstallers);
		if (FAILED(hr))
			goto Finish;

		hr = g_KProgress.HrStep();
		if (FAILED(hr) || (hr == S_FALSE))
			goto Finish;

		fAnyRun = true;
	}

	if (fAnyRun)
		hr = NOERROR;
	else
		hr = S_FALSE;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrRunPostinstallCommands()
{
	bool fAnyRun = false;
	HRESULT hr = NOERROR;
	// run all the pre-installation commands
	CWorkItemIter iter(this);

	bool fHasBeenWarnedAboutSubinstallers = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fRunAfterInstall)
			continue;

		hr = this->HrRunCommand(iter->m_szSourceFile, fHasBeenWarnedAboutSubinstallers);
		if (FAILED(hr))
			break;

		fAnyRun = true;
	}

	if (fAnyRun)
		hr = NOERROR;
	else
		hr = S_FALSE;

	return hr;
}

HRESULT CWorkItemList::HrRunPreuninstallCommands()
{
	bool fAnyRun = false;
	HRESULT hr = NOERROR;
	// run all the pre-installation commands
	CWorkItemIter iter(this);

	bool fHasBeenWarnedAboutSubinstallers = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fRunBeforeUninstall)
			continue;

		hr = this->HrRunCommand(iter->m_szSourceFile, fHasBeenWarnedAboutSubinstallers);
		if (FAILED(hr))
			goto Finish;

		fAnyRun = true;
	}

	if (fAnyRun)
		hr = NOERROR;
	else
		hr = S_FALSE;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrRunPostuninstallCommands()
{
	bool fAnyRun = false;
	HRESULT hr = NOERROR;
	// run all the pre-installation commands
	CWorkItemIter iter(this);

	bool fHasBeenWarnedAboutSubinstallers = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fRunAfterUninstall)
			continue;

		hr = this->HrRunCommand(iter->m_szSourceFile, fHasBeenWarnedAboutSubinstallers);
		if (FAILED(hr))
			break;

		fAnyRun = true;
	}

	if (fAnyRun)
		hr = NOERROR;
	else
		hr = S_FALSE;

	return hr;
}

HRESULT CWorkItemList::HrScanBeforeInstall_PassOne()
{
	// Let's see what's up with all these files before we do *anything*
	CWorkItemIter iter(this);
	HRESULT hr = NOERROR;

	WCHAR szTemp[MSINFHLP_MAX_PATH];

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		::VExpandFilename(iter->m_szSourceFile, NUMBER_OF(szTemp), szTemp);
		VLog(L"Expanded source \"%s\" to \"%s\"", iter->m_szSourceFile, szTemp);
		wcsncpy(iter->m_szSourceFile, szTemp, NUMBER_OF(iter->m_szSourceFile));
		iter->m_szSourceFile[NUMBER_OF(iter->m_szSourceFile) - 1] = L'\0';

		::VExpandFilename(iter->m_szTargetFile, NUMBER_OF(szTemp), szTemp);
		VLog(L"Expanded target \"%s\" to \"%s\"", iter->m_szTargetFile, szTemp);
		wcsncpy(iter->m_szTargetFile, szTemp, NUMBER_OF(iter->m_szTargetFile));
		iter->m_szTargetFile[NUMBER_OF(iter->m_szTargetFile) - 1] = L'\0';

		if (!iter->m_fCopyOnInstall)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		iter->m_dwSourceAttributes = NVsWin32::GetFileAttributesW(iter->m_szSourceFile);
		if (iter->m_dwSourceAttributes == 0xffffffff)
		{
			const DWORD dwLastError = ::GetLastError();
			VLog(L"When scanning work item %d, GetFileAttributes(\"%s\") failed; last error = 0x%08lx", iter->m_ulSerialNumber, iter->m_szSourceFile, dwLastError);

			iter->m_fErrorInWorkItem = true;

			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = ::HrGetFileVersionNumber(
					iter->m_szSourceFile,
					iter->m_dwMSSourceVersion,
					iter->m_dwLSSourceVersion,
					iter->m_fSourceSelfRegistering,
					iter->m_fSourceIsEXE,
					iter->m_fSourceIsDLL);
		if (FAILED(hr))
		{
			::VLog(L"Error getting file version number from \"%s\"; hresult = 0x%08lx", iter->m_szSourceFile, hr);
			goto Finish;
		}

		hr = ::HrGetFileDateAndSize(iter->m_szSourceFile, iter->m_ftSource, iter->m_uliSourceBytes);
		if (FAILED(hr))
		{
			::VLog(L"Error getting file date and size from \"%s\"; hresult = 0x%08lx", iter->m_szSourceFile, hr);
			goto Finish;
		}

		// Now we're getting interested.  Let's see if the target already exists
		iter->m_dwTargetAttributes = NVsWin32::GetFileAttributesW(iter->m_szTargetFile);
		if (iter->m_dwTargetAttributes == 0xffffffff)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"GetFileAttributes(\"%s\") failed during pass one scan; last error = %d", iter->m_szTargetFile, dwLastError);
			if ((dwLastError == ERROR_PATH_NOT_FOUND) ||
				(dwLastError == ERROR_FILE_NOT_FOUND))
			{
				::VLog(L"Concluding that the target file does not exist yet");

				hr = g_KProgress.HrStep();
				if (FAILED(hr))
					goto Finish;

				continue;
			}

			// We weren't able to get the file's attributes, but it wasn't because the
			// directory or file didn't exist.  I think something's fishy.  Bail out.

			hr = HRESULT_FROM_WIN32(dwLastError);
			VLog(L"GetFileAttributes(\"%s\") failed; last error = 0x%08lx", iter->m_szTargetFile, dwLastError);
			goto Finish;
		}

		hr = ::HrGetFileVersionNumber(
					iter->m_szTargetFile,
					iter->m_dwMSTargetVersion,
					iter->m_dwLSTargetVersion,
					iter->m_fTargetSelfRegistering,
					iter->m_fTargetIsEXE,
					iter->m_fTargetIsDLL);
		if (FAILED(hr))
		{
			::VLog(L"Failure getting target file version number from \"%s\"; hresult = 0x%08lx", iter->m_szTargetFile, hr);
			goto Finish;
		}

		hr = ::HrGetFileDateAndSize(iter->m_szTargetFile, iter->m_ftTarget, iter->m_uliTargetBytes);
		if (FAILED(hr))
		{
			::VLog(L"Failure getting target file date and size from \"%s\"; hresult = 0x%08lx", iter->m_szTargetFile, hr);
			goto Finish;
		}

		iter->m_fAlreadyExists = true;

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrScanBeforeInstall_PassTwo
(
CDiskSpaceRequired &rdsr
)
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	// Pass two: now we're going to look at all these files and figure out what versions match etc.

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fCopyOnInstall)
		{
			// This isn't a file we're installing.  Skip it.
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		::VLog(L"Pass two scan on target: \"%s\"; already exists: %s", iter->m_szTargetFile, iter->m_fAlreadyExists ? L"true" : L"false");

		WCHAR szTargetDrive[_MAX_PATH];

		_wsplitpath(iter->m_szTargetFile, szTargetDrive, NULL, NULL, NULL);

		if (!iter->m_fAlreadyExists)
		{
			hr = rdsr.HrAddBytes(szTargetDrive, iter->m_uliSourceBytes);
			if (FAILED(hr))
				goto Finish;

			iter->m_fNeedsUpdate = true;
		}
		else
		{
			// It's already there; what's up with the version numbers?
			int iVersionCompare = ::ICompareVersions(iter->m_dwMSSourceVersion, iter->m_dwLSSourceVersion,
													iter->m_dwMSTargetVersion, iter->m_dwLSTargetVersion);

			// And the filetimes?
			LONG lFiletimeCompare = ::CompareFileTime(&iter->m_ftSource, &iter->m_ftTarget);

			// and the size...
			bool bSameSize = iter->m_uliSourceBytes.QuadPart == iter->m_uliTargetBytes.QuadPart;

			if (g_fInstallUpdateAll ||
				(iVersionCompare < 0) ||
				(lFiletimeCompare > 0) ||
				(g_fReinstall && (iVersionCompare == 0) && (lFiletimeCompare == 0)))
				iter->m_fNeedsUpdate = true;
			else
			{
				// the version on the user's system isn't the same as the one we're installing;
				// if this is a silent install we just don't update; otherwise we ask.
				if (g_fSilent || g_fInstallKeepAll || ((!g_fReinstall) && (iVersionCompare == 0) && (lFiletimeCompare == 0)))
				{
					iter->m_fNeedsUpdate = false;
				}
				else
				{
					UpdateFileResults ufr = eUpdateFileResultCancel;

					hr = ::HrPromptUpdateFile(
							achInstallTitle,
							achUpdateFile,
							iter->m_szTargetFile,
							iter->m_dwMSTargetVersion,
							iter->m_dwLSTargetVersion,
							iter->m_uliTargetBytes,
							iter->m_ftTarget,
							iter->m_dwMSSourceVersion,
							iter->m_dwLSSourceVersion,
							iter->m_uliSourceBytes,
							iter->m_ftSource,
							ufr);

					if (FAILED(hr))
						goto Finish;

					switch (ufr)
					{
					default:
						assert(false);
						// fall through to safe choice

					case eUpdateFileResultCancel:
					case eUpdateFileResultKeep:
						iter->m_fNeedsUpdate = false;
						break;

					case eUpdateFileResultKeepAll:
						g_fInstallKeepAll = true;
						iter->m_fNeedsUpdate = false;
						break;

					case eUpdateFileResultReplace:
						iter->m_fNeedsUpdate = true;
						break;

					case eUpdateFileResultReplaceAll:
						iter->m_fNeedsUpdate = true;
						g_fInstallUpdateAll = true;
						break;
					}
				}
			}

			if (iter->m_fNeedsUpdate)
			{
				// It may be possible to use less, but it may not.  Just assume we need the entire
				// size of the target file.
				hr = rdsr.HrAddBytes(szTargetDrive, iter->m_uliTargetBytes);
				if (FAILED(hr))
					goto Finish;
			}
		}

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrMoveFiles_MoveSourceFilesToDestDirectories()
{
	HRESULT hr = NOERROR;

	//
	//	The job of MoveFiles_PassOne() is to try to move/copy all the files
	//	to their destinations with temporary names, in preparation for the big
	//	rename ectc. 

	CWorkItemIter iter(this);

	WCHAR szTitleBuffer[MSINFHLP_MAX_PATH];
	WCHAR szContentsBuffer[MSINFHLP_MAX_PATH];
	DWORD dwMoveFileExFlags = 0;

	WCHAR szSourceDrive[_MAX_DRIVE];
	// Temporarily abuse the title buffer:
	if (NVsWin32::GetCurrentDirectoryW(NUMBER_OF(szTitleBuffer), szTitleBuffer) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"In MoveSourceFilesToDestDirectories(), GetCurrentDirectory failed; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	_wsplitpath(szTitleBuffer, szSourceDrive, NULL, NULL, NULL);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fNeedsUpdate)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		// first we need to create the target directory if it's not there.
		hr = ::HrMakeSureDirectoryExists(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		WCHAR szTargetDrive[_MAX_DRIVE];
		WCHAR szTargetDir[_MAX_DIR];

		_wsplitpath(iter->m_szTargetFile, szTargetDrive, szTargetDir, NULL, NULL);

		bool fSameDrive = (_wcsicmp(szSourceDrive, szTargetDrive) == 0);

		WCHAR szTempPath[_MAX_PATH];

	PickTempFilename:

		for (;;)
		{
			WCHAR szTempFName[_MAX_FNAME];

			swprintf(szTempFName, L"T%d", g_iNextTemporaryFileIndex++);

			_wmakepath(szTempPath, szTargetDrive, szTargetDir, szTempFName, L".DST");

			DWORD dwAttr = NVsWin32::GetFileAttributesW(szTempPath);
			if (dwAttr != 0xffffffff)
			{
				hr = g_KProgress.HrStep();
				if (FAILED(hr))
					goto Finish;

				continue;
			}

			DWORD dwLastError = ::GetLastError();
			if (dwLastError == ERROR_FILE_NOT_FOUND)
			{
				_wmakepath(szTempPath, szTargetDrive, szTargetDir, szTempFName, L".SRC");

				dwAttr = NVsWin32::GetFileAttributesW(szTempPath);
				if (dwAttr != 0xffffffff)
				{
					hr = g_KProgress.HrStep();
					if (FAILED(hr))
						goto Finish;

					continue;
				}

				dwLastError = ::GetLastError();
				if (dwLastError == ERROR_FILE_NOT_FOUND)
					break;
			}

			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		DWORD dwMoveFileExFlags = 0;

		if (!fSameDrive)
			dwMoveFileExFlags |= MOVEFILE_COPY_ALLOWED;

		::VLog(L"Moving source file \"%s\" to temporary file \"%s\"", iter->m_szSourceFile, szTempPath);

	TryCopy:
		if (!NVsWin32::MoveFileExW(iter->m_szSourceFile, szTempPath, dwMoveFileExFlags))
		{
			const DWORD dwLastError = ::GetLastError();

			::VLog(L"Call to MoveFileExW(\"%s\", \"%s\", 0x%08lx) failed; last error = %d", iter->m_szSourceFile, szTempPath, dwMoveFileExFlags, hr);

			// Allow retries on out of space, etc.  Otherwise, we don't have much hope.
			if (!g_fSilent)
			{
				if (dwLastError == ERROR_HANDLE_DISK_FULL)
				{
					g_pwil->VLookupString(achInstallTitle, NUMBER_OF(szTitleBuffer), szTitleBuffer);
					g_pwil->VFormatString(NUMBER_OF(szContentsBuffer), szContentsBuffer, achErrorDiskFull, szTargetDrive);

					if (NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szContentsBuffer, szTitleBuffer, MB_ICONERROR | MB_RETRYCANCEL) == IDRETRY)
						goto TryCopy;
				}
			}

			// Someone started using the same name... pretty strange, but let's just pick another name.
			if (dwLastError == ERROR_SHARING_VIOLATION)
			{
				goto PickTempFilename;
			}

			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		// The temporary file is there; let's set the file date and time etc.
		DWORD dwAttr = NVsWin32::GetFileAttributesW(szTempPath);
		if (dwAttr == 0xffffffff)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Unable to get file attributes in try copy section; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		if (dwAttr & FILE_ATTRIBUTE_READONLY)
		{
			// SetFileAttributes() seems to fail even when it succeeds sometimes.  Clearing
			// the last error code allows us to detect a pseudo-failure.
			::SetLastError(ERROR_SUCCESS);
			if (!NVsWin32::SetFileAttributesW(szTempPath, dwAttr & (~FILE_ATTRIBUTE_READONLY)))
			{
				const DWORD dwLastError = ::GetLastError();
				if (dwLastError != ERROR_SUCCESS)
				{
					::VLog(L"Attempt to turn off readonly attribute for file \"%s\" failed; last error = %d", szTempPath, dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		HANDLE hFile = NVsWin32::CreateFileW(szTempPath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to open existing file \"%s\" for generic write failed; last error = %d", szTempPath, dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		if (!::SetFileTime(hFile, &iter->m_ftSource, &iter->m_ftSource, &iter->m_ftSource))
		{
			const DWORD dwLastError = ::GetLastError();
			::CloseHandle(hFile);
			::VLog(L"Attempt to set file time on file \"%s\" failed; last error = %d", szTempPath, dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		::CloseHandle(hFile);

		// Restore the original file attributes:
		if (dwAttr & FILE_ATTRIBUTE_READONLY)
		{
			// SetFileAttributes() seems to fail even when it succeeds sometimes.  Clearing
			// the last error code allows us to detect a pseudo-failure.
			::SetLastError(ERROR_SUCCESS);
			if (!NVsWin32::SetFileAttributesW(szTempPath, dwAttr))
			{
				const DWORD dwLastError = ::GetLastError();
				if (dwLastError != ERROR_SUCCESS)
				{
					::VLog(L"Attempt to restore readonly attribute to file \"%s\" failed; last error = %d", szTempPath, dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		wcscpy(iter->m_szTemporaryFile, szTempPath);
		iter->m_fTemporaryFileReady = true;

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrMoveFiles_SwapTargetFilesWithTemporaryFiles()
{
	HRESULT hr = NOERROR;

	//
	//	MoveFiles_PassTwo() attempts to swap the target and temporary files in the
	//	target directories.

	CWorkItemIter iter(this);

	WCHAR szTitleBuffer[MSINFHLP_MAX_PATH];
	WCHAR szContentsBuffer[MSINFHLP_MAX_PATH];
	DWORD dwMoveFileExFlags = 0;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fTemporaryFileReady)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		::VLog(L"Starting swap for target \"%s\"; already exists: %s", iter->m_szTargetFile, iter->m_fAlreadyExists ? L"true" : L"false");

		bool fOldFileRenamed = false;
		WCHAR szTempDestPath[_MAX_PATH];

		if (iter->m_fAlreadyExists)
		{
			WCHAR szTemporaryDrive[_MAX_DRIVE];
			WCHAR szTemporaryDir[_MAX_DIR];
			WCHAR szTemporaryFName[_MAX_FNAME];
			WCHAR szTemporaryExt[_MAX_EXT];

			_wsplitpath(iter->m_szTemporaryFile, szTemporaryDrive, szTemporaryDir, szTemporaryFName, szTemporaryExt);

			// Switcheroo!
			// Let's move the existing file to the .DST form of the temp name, and then rename the .SRC
			// (as stored in iter->m_szTemporaryFile) to the actual target.
			//
			// There's a reasonably big assumption here that the rename of the current target will
			// fail if it's busy.  Sounds reasonable...
			//

			_wmakepath(szTempDestPath, szTemporaryDrive, szTemporaryDir, szTemporaryFName, L".DST");

		SeeIfFileBusy:

			// Let's see if we can open the file; if we can't, it's busy and let's give the user a chance
			// to stop using it.
			HANDLE hFile = NULL;

			::VLog(L"Testing if target file \"%s\" is busy", iter->m_szTargetFile);

			DWORD dwAttr = NVsWin32::GetFileAttributesW(iter->m_szTargetFile);
			if (dwAttr == 0xffffffff)
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Error getting attributes when seeing if target is busy; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			if (dwAttr & FILE_ATTRIBUTE_READONLY)
			{
				::VLog(L"Clearing readonly bit for target file");
				::SetLastError(ERROR_SUCCESS);
				if (!NVsWin32::SetFileAttributesW(iter->m_szTargetFile, dwAttr & ~FILE_ATTRIBUTE_READONLY))
				{
					const DWORD dwLastError = ::GetLastError();
					if (dwLastError != ERROR_SUCCESS)
					{
						::VLog(L"Failed to remove readonly for file; last error = %d", dwLastError);
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}
				}
			}

			hFile = NVsWin32::CreateFileW(
								iter->m_szTargetFile,
								GENERIC_READ | GENERIC_WRITE,
								0, // don't allow any sharing
								NULL, // lpSecurityAttributes
								OPEN_EXISTING, // dwCreationDisposition
								FILE_ATTRIBUTE_NORMAL, // shouldn't be used since we're just opening a file
								NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				const DWORD dwLastError = ::GetLastError();

				::VLog(L"Failed to open handle on file; last error = %d", dwLastError);

				if (dwLastError == 0)
				{
					// hmmm... the file isn't there.  Pretty shady, but we'll go with it.
					VLog(L"The target file \"%s\" has disappeared mysteriously...", iter->m_szTargetFile);
					iter->m_fAlreadyExists = false;
				}
				else if (dwLastError == ERROR_SHARING_VIOLATION)
				{
					if (!g_fSilent)
					{
						// aha someone has it open!
						g_pwil->VLookupString(achInstallTitle, NUMBER_OF(szTitleBuffer), szTitleBuffer);
						g_pwil->VFormatString(NUMBER_OF(szContentsBuffer), szContentsBuffer, achFileMoveBusyRetry, iter->m_szTargetFile);

						if (NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szContentsBuffer, szTitleBuffer, MB_ICONQUESTION | MB_YESNO) == IDYES)
							goto SeeIfFileBusy;
					}

					iter->m_fDeferredRenameRequired = true;
					g_fRebootRequired = true;
				}
				else
				{
					::VLog(L"Attempt to open target file \"%s\" failed; last error = %d", iter->m_szTargetFile, dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}

			// Ok we either got access or we're going to have to reboot.  That's all we wanted to know.
			// close the file if it's still open.
			if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE) && !::CloseHandle(hFile))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Attempt to close handle on file \"%s\" failed; last error = %d", iter->m_szTargetFile, dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		if (iter->m_fAlreadyExists && !iter->m_fDeferredRenameRequired)
		{
		TryFirstMove:
			::VLog(L"Moving destination file \"%s\" to temporary name \"%s\"", iter->m_szTargetFile, szTempDestPath);

			if (NVsWin32::MoveFileW(iter->m_szTargetFile, szTempDestPath))
			{
				// The first rename worked.
				fOldFileRenamed = true;
			}
			else
			{
				const DWORD dwLastError = ::GetLastError();

				// Rename can usually be permitted even if the file is open which is why we do the
				// createfile call above.  Just in case we get here and there's no access, let's
				// just see if the user wants to shut some app down and try again.
				if (dwLastError == ERROR_SHARING_VIOLATION)
				{
					::VLog(L"Sharing violation renaming destination file to temporary name");
					if (!g_fSilent)
					{
						g_pwil->VLookupString(achInstallTitle, NUMBER_OF(szTitleBuffer), szTitleBuffer);
						g_pwil->VFormatString(NUMBER_OF(szContentsBuffer), szContentsBuffer, achFileMoveBusyRetry, iter->m_szTargetFile);

						if (NVsWin32::MessageBoxW(::HwndGetCurrentDialog(), szContentsBuffer, szTitleBuffer, MB_ICONQUESTION | MB_YESNO) == IDYES)
							goto TryFirstMove;
					}

					iter->m_fDeferredRenameRequired = true;
					g_fRebootRequired = true;
				}
				else
				{
					::VLog(L"MoveFileW(\"%s\", \"%s\") failed; last error = %d", iter->m_szTargetFile, szTempDestPath, dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		if (!iter->m_fDeferredRenameRequired)
		{
			::VLog(L"Moving temporary source file \"%s\" to final destination: \"%s\"", iter->m_szTemporaryFile, iter->m_szTargetFile);

			if (NVsWin32::MoveFileW(iter->m_szTemporaryFile, iter->m_szTargetFile))
			{
				if (fOldFileRenamed)
				{
					wcscpy(iter->m_szTemporaryFile, szTempDestPath);
					iter->m_fTemporaryFilesSwapped = true;
				}
				else
					iter->m_fFileUpdated = true;
			}
			else
			{
				const DWORD dwLastError = ::GetLastError();

				::VLog(L"MoveFile(\"%s\", \"%s\") failed; last error = %d", iter->m_szTemporaryFile, iter->m_szTargetFile, dwLastError);

				if (fOldFileRenamed)
				{
					// The move failed; let's try to restore order.
				TryRecover:
					if (NVsWin32::MoveFileW(szTempDestPath, iter->m_szTargetFile))
					{
						::VLog(L"Recovery movefile succeeded!");
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}
					else
					{
						const DWORD dwLastError2 = ::GetLastError();
						::VLog(L"Recovery movefile failed; last error = %d", dwLastError2);

						if (g_fSilent)
						{
							hr = HRESULT_FROM_WIN32(dwLastError);
							goto Finish;
						}

						// We're in deep doo-doo.  In the words of Zathras, "very bad".
						::VFormatString(
							NUMBER_OF(szContentsBuffer),
							szContentsBuffer,
							L"Failure while renaming the file \"%0\" to \"%1\".\n"
							L"Is it possible that your system may not boot correctly unless this file can be successfully renamed.\n"
							L"Please write down these file names so that you can try to perform the rename manually after using either your Emergency Repair Disk or Startup Disk if your system fails to boot.",
							szTempDestPath,
							iter->m_szTargetFile);

						int iResult = NVsWin32::MessageBoxW(
											::HwndGetCurrentDialog(),
											L"Critical File Rename Failed",
											szContentsBuffer,
											MB_RETRYCANCEL | MB_ICONERROR);

						switch (iResult)
						{
						default:
							assert(false);
							// fall through

						case IDRETRY:
							goto TryRecover;

						case 0: // out of memory; that's not that interesting an error, use the rename failure status
						case IDCANCEL:
							// hey they picked it.
							hr = HRESULT_FROM_WIN32(dwLastError);
							goto Finish;
						}
					}
				}
				else
				{
					::VLog(L"Rename of temporary source to final destination filed; last error = %d", dwLastError);

					// There was no old file, but the rename failed.  Very fishy.  Let's just bail out.
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}
	
	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrMoveFiles_RequestRenamesOnReboot()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fDeferredRenameRequired || iter->m_fDeferredRenamePending)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		::VLog(L"Requesting deferred rename from \"%s\" to \"%s\"", iter->m_szTemporaryFile, iter->m_szTargetFile);

		if (NVsWin32::MoveFileExW(iter->m_szTemporaryFile, iter->m_szTargetFile, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING))
		{
			iter->m_fDeferredRenamePending = true;
		}
		else
		{
			const DWORD dwLastError = ::GetLastError();

			if (dwLastError == ERROR_FILENAME_EXCED_RANGE)
			{
				::VLog(L"Long target filename (\"%s\") requires msinfhlp.exe to complete renames after reboot", iter->m_szTargetFile);
				// oh no, we're on Win9x the target is busy (or we wouldn't be here) and it's a long
				// filename target.  we'll try renaming it when we finish rebooting.
				iter->m_fManualRenameOnRebootRequired = true;
			}
			else
			{
				::VLog(L"Deferred file move from \"%s\" to \"%s\" failed; last error = %d", iter->m_szTemporaryFile, iter->m_szTargetFile, dwLastError);

				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrFinishManualRenamesPostReboot()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fManualRenameOnRebootRequired)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		hr = g_KProgress.HrStartStep(iter->m_szTargetFile);
		if (FAILED(hr))
			goto Finish;

		// Switcheroo all over again:
		WCHAR szTemporaryDrive[_MAX_DRIVE];
		WCHAR szTemporaryDir[_MAX_DIR];
		WCHAR szTemporaryFName[_MAX_FNAME];
		WCHAR szTemporaryExt[_MAX_EXT];
		WCHAR szTempDestPath[_MAX_PATH];

		_wsplitpath(iter->m_szTemporaryFile, szTemporaryDrive, szTemporaryDir, szTemporaryFName, szTemporaryExt);

		// Switcheroo!
		// Let's move the existing file to the .DST form of the temp name, and then rename the .SRC
		// (as stored in iter->m_szTemporaryFile) to the actual target.
		//
		// There's a reasonably big assumption here that the rename of the current target will
		// fail if it's busy.  Sounds reasonable...
		//

		_wmakepath(szTempDestPath, szTemporaryDrive, szTemporaryDir, szTemporaryFName, L".DST");

		::VLog(L"About to move \"%s\" to \"%s\"", iter->m_szTargetFile, szTempDestPath);

		if (!NVsWin32::MoveFileW(iter->m_szTargetFile, szTempDestPath))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Post-reboot manual rename of \"%s\" to \"%s\" failed; last error = %d", iter->m_szTargetFile, szTempDestPath, dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		::VLog(L"About to move \"%s\" to \"%s\"", iter->m_szTemporaryFile, iter->m_szTargetFile);

		if (!NVsWin32::MoveFileW(iter->m_szTemporaryFile, iter->m_szTargetFile))
		{
			const DWORD dwLastError = ::GetLastError();

			::VLog(L"Attempt to move temporary source file \"%s\" to target \"%s\" failed; last error = %d", iter->m_szTemporaryFile, iter->m_szTargetFile, dwLastError);

			if (!NVsWin32::MoveFileW(szTempDestPath, iter->m_szTargetFile))
			{
				const DWORD dwLastError2 = ::GetLastError();
				// hosed
				::VLog(L"massively hosed renaming \"%s\" to \"%s\"; last error = %d", szTempDestPath, iter->m_szTargetFile, dwLastError2);
			}

			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		iter->m_fTemporaryFilesSwapped = true;

		wcsncpy(iter->m_szTemporaryFile, szTempDestPath, NUMBER_OF(iter->m_szTemporaryFile));
		iter->m_szTemporaryFile[NUMBER_OF(iter->m_szTemporaryFile) - 1] = L'\0';

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrDeleteTemporaryFiles()
{
	HRESULT hr = NOERROR;

	CWorkItemIter iter(this);

	WCHAR szTitleBuffer[MSINFHLP_MAX_PATH];
	WCHAR szContentsBuffer[MSINFHLP_MAX_PATH];

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fTemporaryFilesSwapped || iter->m_fDeferredRenamePending)
		{
			hr = g_KProgress.HrStep();
			if (FAILED(hr))
				goto Finish;

			continue;
		}

		// at this point, the iter->m_szTemporaryFile is the file that the
		// destination got renamed to.  Delete it!

		::VLog(L"Cleaning up temporary file: \"%s\"", iter->m_szTemporaryFile);

		hr = g_KProgress.HrStartStep(iter->m_szTemporaryFile);
		if (FAILED(hr))
			goto Finish;

		if (iter->m_dwTargetAttributes & FILE_ATTRIBUTE_READONLY)
		{
			// The target used to be readonly; the rename probably worked, but
			// in order to delete the old file, we need to make it writable.
			::SetLastError(ERROR_SUCCESS);
			if (!NVsWin32::SetFileAttributesW(iter->m_szTemporaryFile, iter->m_dwTargetAttributes & ~FILE_ATTRIBUTE_READONLY))
			{
				const DWORD dwLastError = ::GetLastError();
				if (dwLastError != ERROR_SUCCESS)
				{
					::VLog(L"Attempt to remove readonly attribute from file \"%s\" failed; last error = %d", iter->m_szTemporaryFile, dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		if (!NVsWin32::DeleteFileW(iter->m_szTemporaryFile))
		{
			const DWORD dwLastError = ::GetLastError();

			VLog(L"Attempt to delete temporary file \"%s\" failed; last error = %d", iter->m_szTemporaryFile, dwLastError);

			// If the file's missing, then there really isn't any reason to fail.
			if ((dwLastError != ERROR_FILE_NOT_FOUND) &&
				(dwLastError != ERROR_PATH_NOT_FOUND))
			{
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		hr = g_KProgress.HrStep();
		if (FAILED(hr))
			goto Finish;
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrRunCommand(LPCWSTR szCommand, bool &rfHasBeenWarnedAboutSubinstallers)
{
	HRESULT hr = NOERROR;
	bool fDoCommand = true;
	CWorkItem::CommandCondition *pCommandCondition = NULL;
	WCHAR szStrippedCommandLine[MSINFHLP_MAX_PATH];
	LPCWSTR pszVBar = wcschr(szCommand, L'|');
	bool fConditionsAreRequirements = false;

	VLog(L"Running command: \"%s\"", szCommand);

	if (pszVBar != NULL)
	{
		ULONG cchCommand = pszVBar - szCommand;

		// Prevent buffer overflow
		if (cchCommand > (NUMBER_OF(szStrippedCommandLine) - 2))
			cchCommand = NUMBER_OF(szStrippedCommandLine) - 2;

		memcpy(szStrippedCommandLine, szCommand, cchCommand * sizeof(WCHAR));
		szStrippedCommandLine[cchCommand] = L'\0';
	}
	else
	{
		wcsncpy(szStrippedCommandLine, szCommand, NUMBER_OF(szStrippedCommandLine));
		szStrippedCommandLine[NUMBER_OF(szStrippedCommandLine) - 1] = L'\0';

		WCHAR *pwchEqualsEquals = wcsstr(szStrippedCommandLine, L"==");
		if (pwchEqualsEquals != NULL)
		{
			*pwchEqualsEquals = L'\0';
			::VLog(L"Renaming subinstaller \"%s\" to \"%s\"", szStrippedCommandLine, pwchEqualsEquals + 2);

			if (!NVsWin32::MoveFileW(szStrippedCommandLine, pwchEqualsEquals + 2))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"MoveFileW() failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}

			// The == style command lines do not have quotes around them, so we have to put them
			// there in case the .exe has a space in its name.
			const ULONG cch = wcslen(pwchEqualsEquals + 2);
			szStrippedCommandLine[0] = L'"';
			memmove(&szStrippedCommandLine[1], pwchEqualsEquals + 2, cch * sizeof(WCHAR));
			szStrippedCommandLine[cch + 1] = L'"';
			szStrippedCommandLine[cch + 2] = L'\0';
		}
	}

	// Let's see if we really need to do this command.  The command format is
	//	command-string[|filename[=w1,w2,w3,w4]]...

	if (pszVBar != NULL)
	{
		LPCWSTR pszCurrent = pszVBar + 1;

		do
		{
			WCHAR szCondition[MSINFHLP_MAX_PATH];
			pszVBar = wcschr(pszCurrent, L'|');
			LPCWSTR pszCurrentEnd = (pszVBar == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszVBar;
			ULONG cchCondition = pszCurrentEnd - pszCurrent;
			if (cchCondition > (NUMBER_OF(szCondition) - 2))
				cchCondition = NUMBER_OF(szCondition) - 2;
			memcpy(szCondition, pszCurrent, cchCondition * sizeof(WCHAR));
			szCondition[cchCondition] = L'\0';

			CWorkItem::CommandCondition *pCC_New = NULL;

			hr = this->HrParseCommandCondition(szCondition, pCC_New);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to parse command condition \"%s\" failed; hresult = 0x%08lx", szCondition, hr);
				goto Finish;
			}

			pCC_New->m_pCommandCondition_Next = pCommandCondition;
			pCommandCondition = pCC_New;

			pszCurrent = pszCurrentEnd + 1;
		} while (pszVBar != NULL);
	}

	// Sleazy assumption: if this is a Java package manager installation, the conditions
	// are requirements that must be met in order to even attempt the installation
	// rather than abilities to short-circuit it.
	if (wcsstr(szStrippedCommandLine, L"JavaPkgMgr_Install") != NULL)
		fConditionsAreRequirements = true;

	// Ok, we have a list; let's see what's up with it.
	hr = this->HrCheckCommandConditions(pCommandCondition, fConditionsAreRequirements, fDoCommand);
	if (FAILED(hr))
	{
		::VLog(L"Command condition check failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	if (fDoCommand)
	{
		// somewhat sleazy recognition of installation to the java package manager via msjava.dll:
		if (wcsstr(szStrippedCommandLine, L"JavaPkgMgr_Install") != NULL)
		{
			hr = this->HrInstallViaJPM(szStrippedCommandLine);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to install \"%s\" via the Java package manager failed; hresult = 0x%08lx", szStrippedCommandLine, hr);
				goto Finish;
			}
		}
		else
		{
			if (!rfHasBeenWarnedAboutSubinstallers)
			{
				if (!g_fSilent)
				{
					if (g_Action == eActionInstall)
						::VMsgBoxOK(achInstallTitle, achRerunSetup);

					rfHasBeenWarnedAboutSubinstallers = true;
				}
			}

		TryRunProcess:
			hr = this->HrRunProcess(szStrippedCommandLine);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to run process \"%s\" failed; hresult = 0x%08lx", szStrippedCommandLine, hr);
				
				WCHAR szBuffer[_MAX_PATH];
				::VFormatError(NUMBER_OF(szBuffer), szBuffer, hr);

				switch (g_fSilent ? IDNO : ::IMsgBoxYesNoCancel(achInstallTitle, achErrorRunningEXE, szStrippedCommandLine, szBuffer))
				{
				default:
					assert(false);
					// fall through

				case IDCANCEL:
					hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
					goto Finish;

				case IDYES:
					goto TryRunProcess;

				case IDNO:
					hr = E_ABORT;
					goto Finish;
				}
			}
			else
			{
				if (s_hEvent_PostRunProcess == NULL)
				{
					s_hEvent_PostRunProcess = ::CreateEvent(NULL, FALSE, FALSE, NULL);

					if (s_hEvent_PostRunProcess == NULL)
					{
						const DWORD dwLastError = ::GetLastError();
						::VLog(L"Failed to create event for two second end-of-process-reboot wait; last error = %d", dwLastError);
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}
				}

				s_uiTimer_PostRunProcess = ::SetTimer(NULL, 0, 2000, &TimerProc_PostRunProcess);

				for (;;)
				{
					bool fDone = false;

					DWORD dwResult = ::MsgWaitForMultipleObjects(
						1,
						&s_hEvent_PostRunProcess,
						FALSE,						// fWaitAll
						INFINITE,
						QS_ALLEVENTS);

					switch (dwResult)
					{
					case WAIT_OBJECT_0:
						// I guess we're done!
						fDone = true;
						break;

					case WAIT_OBJECT_0 + 1:
						hr = ::HrPumpMessages(true);
						if (FAILED(hr))
							goto Finish;
						break;

					case 0xffffffff:
						{
							const DWORD dwLastError = ::GetLastError();
							::VLog(L"MsgWaitForMultipleObjects() waiting for end-of-process timer failed; last error = %d", dwLastError);
							hr = HRESULT_FROM_WIN32(dwLastError);
							goto Finish;
						}

					default:
						break;
					}

					if (fDone)
						break;
				}
			}
		}
	}
	else
	{
		// A required file was missing; let the user know.
		if (fConditionsAreRequirements)
		{
			VErrorMsg(achInstallTitle, achErrorUpdateIE);
			hr = E_ABORT;
			goto Finish;
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrRunProcess(LPCWSTR szCommandLine)
{
	HRESULT hr = NOERROR;
	DWORD dwStatus;
	STARTUPINFOW si;
	PROCESS_INFORMATION pi;
	memset(&si, 0,sizeof(si));

	bool fIgnoreProcessReturnCode = false;

	if (_wcsnicmp(szCommandLine, L"mdac_typ.exe ", 13) == 0)
		fIgnoreProcessReturnCode = true;

	// We have to make a copy of the command line because CreateProcess() wants to modify its second argument
	// with the name of the actual program run.
	WCHAR szCommandLineCopy[MSINFHLP_MAX_PATH];
	wcsncpy(szCommandLineCopy, szCommandLine, NUMBER_OF(szCommandLineCopy));
	szCommandLineCopy[NUMBER_OF(szCommandLineCopy) - 1] = L'\0';

	pi.hProcess = INVALID_HANDLE_VALUE;
	if (NVsWin32::CreateProcessW(NULL, szCommandLineCopy, NULL, NULL, false, DETACHED_PROCESS, NULL, NULL, &si, &pi))
	{
		DWORD dwError;

		if (!::GetExitCodeProcess(pi.hProcess, &dwStatus))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Attempt to get exit code for process %08lx failed; last error = %d", pi.hProcess, dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}

		if (dwStatus == STILL_ACTIVE)
		{
			hr = ::HrWaitForProcess(pi.hProcess);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to wait for process %08lx to complete has failed; hresult = 0x%08lx", pi.hProcess, hr);
				goto Finish;
			}

			if (!::GetExitCodeProcess(pi.hProcess, &dwStatus))
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"Getting the exit code for process %08lx failed; last error = %d", pi.hProcess, dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		::VLog(L"Process terminated; process exit status 0x%08lx", dwStatus);

		if ((!fIgnoreProcessReturnCode) && (dwStatus != 0))
		{
			// If the exit status is a Win32 facility HRESULT, let's use it.
			if ((dwStatus & 0x80000000) &&
				((HRESULT_FACILITY(dwStatus) == FACILITY_WIN32) ||
				 (HRESULT_FACILITY(dwStatus) == FACILITY_NULL) ||
				 (HRESULT_FACILITY(dwStatus) == FACILITY_RPC)))
				hr = dwStatus;
			else
				hr = E_FAIL;
