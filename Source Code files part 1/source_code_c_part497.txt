ailnews\news\newsutil.h ===
#ifndef _INC_NEWSUTIL_H
#define _INC_NEWSUTIL_H

class CGetNewGroups : public IStoreCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        CGetNewGroups(HWND hwnd, FOLDERID idFolder, LPCSTR pszAcctId, FILETIME *pft);
        ~CGetNewGroups(void);

        HRESULT Close(void);
        HRESULT HandleGetNewGroups(void);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;

        HWND        m_hwnd;
        FOLDERID    m_idFolder;
        char        m_szAcctId[CCHMAX_ACCOUNT_NAME];
        FILETIME    m_ft;
};

BOOL NewsUtil_FCanCancel(FOLDERID idFolder, LPMESSAGEINFO pInfo);
HRESULT NewsUtil_HrCancelPost(HWND hwnd, FOLDERID idGroup, LPMESSAGEINFO pInfo);
DWORD NewsUtil_GetNotDownloadCount(FOLDERINFO *pInfo);
HRESULT NewsUtil_CheckForNewGroups(HWND hwnd, FOLDERID idFolder, CGetNewGroups **ppGroups);
HRESULT HrDownloadArticleDialog(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg);

#endif // _INC_NEWSUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\order.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Order.cpp
//
//  PURPOSE:    Implements the order articles dialog.  Allows the user to
//              sequence multipart articles for decoding.
//

#include "pch.hxx"
#include "storutil.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "resource.h"
#include "shlwapip.h" 
#include "thormsgs.h"
#include "order.h"
#include "error.h"
#include "demand.h"
#include "imsgsite.h"
#include "note.h"
#include "xputil.h"

// NOTE - The drag list control requires us to register a message and use that
//        for notifications sent from the list to the dialog.  This message
//        is defined only for this dialog. -- SteveSer.

static UINT g_mDragList = 0;

#define CND_GETNEXTARTICLE  (WM_USER + 101)
#define CND_OPENNOTE        (WM_USER + 102)
#define CND_MESSAGEAVAIL    (WM_USER + 103)

CCombineAndDecode::CCombineAndDecode()
{
    m_cRef = 1;

    m_hwndParent = NULL;

    m_pTable = NULL;
    m_rgRows = NULL;
    m_cRows = 0;

    m_pszBuffer = NULL;
    m_iItemToMove = -1;

    m_cLinesTotal = 0;
    m_cCurrentLine = 0;
    m_cPrevLine = 0;
    m_dwCurrentArt = 0;
    m_pMsgParts = NULL;
    m_pCancel = 0;
    m_hTimeout = 0;
    m_hwndDlg = 0;
}


CCombineAndDecode::~CCombineAndDecode()
{
    SafeRelease(m_pTable);
    SafeRelease(m_pMsgParts);
    SafeRelease(m_pCancel);
    CallbackCloseTimeout(&m_hTimeout);
}


HRESULT STDMETHODCALLTYPE CCombineAndDecode::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CCombineAndDecode::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CCombineAndDecode::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//  FUNCTION:   CCombineAndDecode::Start()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in] hwndParent
//      [in] pTable
//      [in] rgRows
//      [in] cRows
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CCombineAndDecode::Start(HWND hwndParent, IMessageTable *pTable, 
                                 ROWINDEX *rgRows, DWORD cRows, FOLDERID idFolder)
{
    int nResult = -1;

    TraceCall("CCombineAndDecode::Start");

    // Verify we got everything we needed
    if (!IsWindow(hwndParent) || !pTable || !rgRows || 0 == cRows)
        return (E_INVALIDARG);

    // Keep these for later
    m_hwndParent = hwndParent;
    m_pTable = pTable;
    m_pTable->AddRef();

    m_rgRows = rgRows;
    m_cRows = cRows;

    m_idFolder = idFolder;
    // Create the order dialog and get to work
    nResult = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddOrderMessages), 
                             m_hwndParent, OrderDlgProc, (LPARAM) this);

    // If the user pressed OK, then we go ahead and decode
    if (nResult == IDOK)
    {
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCombineAndDecode), m_hwndParent,
                       CombineDlgProc, (LPARAM) this);
    }

    return (S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OrderDlgProc()
//
//  PURPOSE:    Public callback function for the message ordering dialog proc
//
INT_PTR CALLBACK CCombineAndDecode::OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCombineAndDecode *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CCombineAndDecode *) lParam;
    }
    else
        pThis = (CCombineAndDecode *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->_OrderDlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);

}


//
//  FUNCTION:   CCombineAndDecode::_OrderDlgProc()
//
//  PURPOSE:    Private callback function for the message ordering dialog proc
//
INT_PTR CALLBACK CCombineAndDecode::_OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _Order_OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _Order_OnCommand);
            return (TRUE);
        
        case WM_CLOSE:
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, _Order_OnClose);
            return (TRUE);
        
        default:
            if (uMsg == g_mDragList)
                return (_Order_OnDragList(hwnd, (int) wParam, (DRAGLISTINFO*) lParam));
    }
    
    return (FALSE);
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnInitDialog()
//
//  PURPOSE:    Initializes the order dialog by filling in the message headers.
//
BOOL CCombineAndDecode::_Order_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND        hwndList;
    HDC         hdc;
    SIZE        size;
    int         cx = 0;
    HFONT       hfontOld;
    HFONT       hfont;
    int         cxScrollBar;
    LPMESSAGEINFO pInfo;
    int         iItem;
    LPSTR       pszSubject = NULL;
    CHAR        szNoSubject[CCHMAX_STRINGRES] = "";
   
    CenterDialog(hwnd);

    // Get some drawing information about the ListBox so we can set the scroll
    // bar width correctly later.
    hwndList = GetDlgItem(hwnd, IDC_MESSAGE_LIST);
    hdc = GetDC(hwndList);
    hfont = (HFONT) SendMessage(hwndList, WM_GETFONT, 0, 0L);
    hfontOld = (HFONT) SelectObject(hdc, hfont);
    cxScrollBar = GetSystemMetrics(SM_CXHTHUMB);

    // Fill the listbox with the article subjects
    for (DWORD i = 0; i < m_cRows; i++)
    {
        // Get the message header from the table
        if (SUCCEEDED(m_pTable->GetRow(m_rgRows[i], &pInfo)))
        {
            if(pInfo->pszSubject)
                pszSubject = pInfo->pszSubject;
            else
            {
                LoadString(g_hLocRes, idsEmptySubjectRO, szNoSubject, sizeof(szNoSubject));
                pszSubject = szNoSubject;
            }

            Assert(pszSubject);

            // Figure out which string is widest before inserting
            GetTextExtentPoint32(hdc, pszSubject, lstrlen(pszSubject), &size);
            if (cx < size.cx)
                cx = size.cx;

            // Add the string
            iItem = (int) SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) pszSubject);
            if (LB_ERR != iItem)
                SendMessage(hwndList, LB_SETITEMDATA, iItem, (LPARAM) m_rgRows[i]);

            // Free the memory
            m_pTable->ReleaseRow(pInfo);
        }
    }
    
    // Clean up the GDI objects
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwndList, hdc);
    
    // Make sure there are scroll bars if needed.
    SendMessage(hwndList, LB_SETHORIZONTALEXTENT, cx + cxScrollBar, 0L);
    
    // Make the list box a drag list box
    if (MakeDragList(hwndList))
        g_mDragList = RegisterWindowMessage(DRAGLISTMSGSTRING);
    
    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
    
    return (FALSE);
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnCommand()
//
//  PURPOSE:    Handle the commands generated by the buttons on the dialog.
//
void CCombineAndDecode::_Order_OnCommand(HWND hwnd, int id, HWND hwndCtl, 
                                         UINT codeNotify)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_MESSAGE_LIST);

    switch (id)
    {
        case IDOK:
        {
            // Get the info we need out of the ListBox
            for (DWORD i = 0; i < m_cRows; i++)
            {
                m_rgRows[i] = (ROWINDEX) ListBox_GetItemData(hwndList, i);
            }

            EndDialog(hwnd, 1);
            break;
        }
        
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;
        
        case IDC_MOVE_UP:
        case IDC_MOVE_DOWN:
        {
            LPTSTR  pszBuffer;
            DWORD   cch;
            UINT    index;
            LPARAM  lpData;
        
            // Get the currently selected item
            index = (DWORD) SendMessage(hwndList, LB_GETCURSEL, 0, 0);

            // If nothing is selected the listbox returns LB_ERR
            if (index == LB_ERR)
                return;
        
            // Check the bounds
            if ((id == IDC_MOVE_UP && index == 0) ||
                (id == IDC_MOVE_DOWN && (int) index == (ListBox_GetCount(hwndList) - 1)))
                return;
        
            // Move the item in the listbox
            cch = (DWORD) SendMessage(hwndList, LB_GETTEXTLEN, index, 0L);
            if (!MemAlloc((LPVOID*) &pszBuffer, sizeof(TCHAR) * (cch + 1)))
                return;
        
            // Get the source string and data
            SendMessage(hwndList, LB_GETTEXT, index, (LPARAM) pszBuffer);
            lpData = SendMessage(hwndList, LB_GETITEMDATA, index, 0);

            // Delete the source
            SendMessage(hwndList, LB_DELETESTRING, index, 0L);

            // Insert the new one
            if (id == IDC_MOVE_UP)
                index--;
            else
                index++;

            SendMessage(hwndList, LB_INSERTSTRING, index, (LPARAM) pszBuffer);
            SendMessage(hwndList, LB_SETITEMDATA, index, lpData);
            SendMessage(hwndList, LB_SETCURSEL, index, 0L);

            MemFree(pszBuffer);
            break;
        }
    }
}


//
//  FUNCTION:   Order_OnDragList()
//
//  PURPOSE:    Handles the drag list notifications which reorder the messages.
//
//  PARAMETERS:
//      hwnd    - handle of the parent of the drag list
//      idCtl   - identifer of the drag list sending the notification
//      lpdli   - pointer to a DRAGLISTINFO struct with info about the
//                notification.
//
//  RETURN VALUE:
//      Dependant on the notification.
//
//  COMMENTS:
//      This function uses the SetDlgMsgResult() macro defined in WINDOWSX.H to
//      set the return value for each message since the parent window is a
//      dialog.
//
LRESULT CCombineAndDecode::_Order_OnDragList(HWND hwnd, int idCtl, LPDRAGLISTINFO lpdli)
{
    UINT    iItem;
    UINT    cch;
    
    Assert(((int) m_iItemToMove) >= 0);
    
    switch (lpdli->uNotification)
    {
        // The user has started dragging one of the list control's items
        case DL_BEGINDRAG:
        {
            // Find out which item is being dragged
            m_iItemToMove = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);

            // Allocate a buffer for the string
            Assert(m_pszBuffer == NULL);
            cch = ListBox_GetTextLen(lpdli->hWnd, m_iItemToMove) + 1;
            MemAlloc((LPVOID *) &m_pszBuffer, cch);
            SendMessage(lpdli->hWnd, LB_GETTEXT, m_iItemToMove, (LPARAM) m_pszBuffer);
            m_lpData = SendMessage(lpdli->hWnd, LB_GETITEMDATA, m_iItemToMove, 0);
        
            DOUT("DL_BEGINDRAG: iItem = %d, text = %100s\r\n", m_iItemToMove, m_pszBuffer);
        
            // Draw the insert icon
            DrawInsert(hwnd, lpdli->hWnd, m_iItemToMove);
        
            // Set the return value to allow the drag to contine
            SetDlgMsgResult(hwnd, g_mDragList, TRUE);
            return TRUE;
        }
        
        case DL_CANCELDRAG:
        {
            DOUT("DL_CANCELDRAG\r\n");
            DrawInsert(hwnd, lpdli->hWnd, -1);
            SafeMemFree(m_pszBuffer);
            return 0;   // Return value is ignored
        }
        
        // The user is in the process of dragging, update the position
        // and move the insert icon
        case DL_DRAGGING:
        {
            // Find out where the cursor is now
            iItem = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);
        
            // Dump some debug info
            DOUT("DL_DRAGGING: iItem = %d\r\n", iItem);
        
            // Update the insert icon position
            DrawInsert(hwnd, lpdli->hWnd, iItem);
        
            // If the cursor is over a valid position set the cursor to
            // DL_MOVECURSOR, otherwise use the DL_STOPCURSOR
            if (-1 != iItem)
                SetDlgMsgResult(hwnd, g_mDragList, DL_MOVECURSOR);
            else
                SetDlgMsgResult(hwnd, g_mDragList, DL_STOPCURSOR);
        
            return (LRESULT) TRUE;
        }

        // The user has dropped the item somewhere, if valid update it's
        // position
        case DL_DROPPED:
        {
            // Where are we now.
            iItem = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);
            DOUT("DL_DROPPED: iItem = %d\r\n", iItem);
        
            // If the drop was somewhere valid
            if (iItem != -1)
            {
                // Remove the insert icon
                DrawInsert(hwnd, lpdli->hWnd, -1);
            
                // Move the item in the listbox
                if (m_iItemToMove != iItem)
                {
                    SendMessage(lpdli->hWnd, LB_DELETESTRING, m_iItemToMove, 0L);
                    SendMessage(lpdli->hWnd, LB_INSERTSTRING, iItem, (LPARAM) m_pszBuffer);
                    SendMessage(lpdli->hWnd, LB_SETITEMDATA, iItem, m_lpData);
                    SendMessage(lpdli->hWnd, LB_SETCURSEL, iItem, 0L);
                }
            }
        
            m_iItemToMove = (UINT) -1;
            SafeMemFree(m_pszBuffer);
            m_lpData = -1;

            // Set the return value to reset the cursor
            SetDlgMsgResult(hwnd, g_mDragList, DL_CURSORSET);
            return 0;
        }
    }
    
    return TRUE;
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnClose()
//
//  PURPOSE:    This get's called when the user clicks on the "x" button in the
//              title bar.
//
void CCombineAndDecode::_Order_OnClose(HWND hwnd)
{
    SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
}



/////////////////////////////////////////////////////////////////////////////
//
// Combine and Decode Progress dialog
//
/////////////////////////////////////////////////////////////////////////////


INT_PTR CALLBACK CCombineAndDecode::CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCombineAndDecode *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CCombineAndDecode *) lParam;
    }
    else
        pThis = (CCombineAndDecode *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->_CombineDlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}

INT_PTR CALLBACK CCombineAndDecode::_CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _Combine_OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _Combine_OnCommand);
            return (TRUE);
        
        case WM_DESTROY:
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, _Combine_OnDestroy);
            return (TRUE);

        case CND_GETNEXTARTICLE:
            _Combine_GetNextArticle(hwnd);
            return (TRUE);

        case CND_OPENNOTE:
            _Combine_OpenNote(hwnd);
            return (TRUE);

        case CND_MESSAGEAVAIL:
            _Combine_OnMsgAvail(m_hwndDlg);
            return (TRUE);
    
    }
    
    return (FALSE);
}



//
//  FUNCTION:   CCombineAndDecode::_Combine_OnInitDialog()
//
//  PURPOSE:    Initializes the progress dialog by figuring out how many lines
//              will be downloaded, etc.  To finish, we post a message to start
//              the first message downloading.
//
BOOL CCombineAndDecode::_Combine_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HRESULT         hr = S_OK;
    LPMESSAGEINFO   pInfo;

    m_hwndDlg = hwnd;

    // Create the CNewsMsgList for Opie's groovy combiner
    hr = MimeOleCreateMessageParts(&m_pMsgParts);
    if (FAILED(hr))
    {
        EndDialog(hwnd, 0);
        return (FALSE);
    }
    
    // Get a sum of the lines we need to download for the total messages
    m_cLinesTotal = 0;
    for (DWORD i = 0; i < m_cRows; i++)
    {
        // Get the message header from the table
        if (SUCCEEDED(m_pTable->GetRow(m_rgRows[i], &pInfo)))
        {
            m_cLinesTotal += pInfo->cbMessage;
            m_pTable->ReleaseRow(pInfo);
        }
    }
    
    // Set the initial state of the progress bar
    SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETRANGE, 0, MAKELONG(0, 100));
    SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETPOS, 0, 0);
    
    // Set up the animation
    if (Animate_Open(GetDlgItem(hwnd, IDC_DOWNLOAD_AVI), MAKEINTRESOURCE(idanDecode)))
    {
        Animate_Play(GetDlgItem(hwnd, IDC_DOWNLOAD_AVI), 0, -1, -1);
    }
    
    // Start the download
    m_dwCurrentArt = 0;
    m_cCurrentLine = 0;
    
    PostMessage(hwnd, CND_GETNEXTARTICLE, 0, 0L);
    
    CenterDialog(hwnd);
    ShowWindow(hwnd, SW_SHOW);

    return (TRUE);
}


//
//  FUNCTION:   CCombineAndDecode::_Combine_OnCommand()
//
//  PURPOSE:    When the user hit's the Cancel button, we in turn tell the store
//              to stop downloading.
//
void CCombineAndDecode::_Combine_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (id == IDCANCEL && m_pCancel)
        m_pCancel->Cancel(CT_CANCEL);
}


void CCombineAndDecode::_Combine_OnDestroy(HWND hwnd)
{

}


//
//  FUNCTION:   CCombineAndDecode::_Combine_GetNextArticle()
//
//  PURPOSE:    Called when we can start downloading another message.  
//
void CCombineAndDecode::_Combine_GetNextArticle(HWND hwnd)
{
    LPMIMEMESSAGE pMsg = NULL;
    LPMESSAGEINFO pInfo;
    TCHAR         szProg[CCHMAX_STRINGRES];
    TCHAR         szBuf[CCHMAX_STRINGRES];
    HRESULT       hr;
    
    if (SUCCEEDED(m_pTable->GetRow(m_rgRows[m_dwCurrentArt], &pInfo)))
    {
        // Set the progress for the current article
        AthLoadString(idsProgDLMessage, szProg, ARRAYSIZE(szProg));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szProg, pInfo->pszSubject);
        SetDlgItemText(hwnd, IDC_GENERAL_TEXT, szBuf);
    
        // Reset the line count
        m_cPrevLine = 0;
    
        // Check to see if the message is cached
        if (!(pInfo->dwFlags & ARF_HASBODY))
        {
            // Request the message
            hr = m_pTable->OpenMessage(m_rgRows[m_dwCurrentArt], 0, &pMsg, (IStoreCallback *) this);
            if (FAILED(hr) && hr != E_PENDING)
            {
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCantCombineNotConnected),
                              0, MB_OK | MB_ICONSTOP);
                EndDialog(m_hwndDlg, 0);
            }
        }
        else
            _Combine_OnMsgAvail(hwnd);
    
        if (pMsg)
            pMsg->Release();

        m_pTable->ReleaseRow(pInfo);
    }
}


//
//  FUNCTION:   CCombineAndDecode::_Combine_OnMsgAvail()
//
//  PURPOSE:    Called once we've finished downloading an article.
//
void CCombineAndDecode::_Combine_OnMsgAvail(HWND hwnd)
{
    LPMIMEMESSAGE   pMsg = NULL;
    DWORD           increment;
    TCHAR           szProg[CCHMAX_STRINGRES];
    HRESULT         hr;
    
    // Mark it read
    m_pTable->Mark(&(m_rgRows[m_dwCurrentArt]), 1, APPLY_CHILDREN, MARK_MESSAGE_READ, (IStoreCallback *) this);
    
    // Get the message now that it's available and add it to the combine list
    if (SUCCEEDED(hr = m_pTable->OpenMessage(m_rgRows[m_dwCurrentArt], 0, &pMsg, (IStoreCallback *) this)))
    {
        // Add this to the pMsgList    
        m_pMsgParts->AddPart(pMsg);
        pMsg->Release();
    }
    
    // Update the progress
    LPMESSAGEINFO pInfo;
    if (SUCCEEDED(m_pTable->GetRow(m_rgRows[m_dwCurrentArt], &pInfo)))
    {
        increment = pInfo->cbMessage - m_cPrevLine;
        m_cCurrentLine += increment;
        m_pTable->ReleaseRow(pInfo);
    }
    
    if (m_cLinesTotal)
    {
        increment = m_cCurrentLine * 100 / m_cLinesTotal;
        SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETPOS, increment, 0);
    }

    // Increment the number of messages we've retrieved
    m_dwCurrentArt++;

    // If there are more to get, go get 'em
    if (m_dwCurrentArt < m_cRows)
    {
        PostMessage(hwnd, CND_GETNEXTARTICLE, 0, 0L);
    }
    else
    {
        PostMessage(hwnd, CND_OPENNOTE, 0, 0);
    }
}

void CCombineAndDecode::_Combine_OpenNote(HWND hwnd)
{
    LPMIMEMESSAGE   pMsgComb;
    LPMIMEMESSAGE   pMsg = NULL;
    DWORD           increment;
    TCHAR           szProg[CCHMAX_STRINGRES];
    HRESULT         hr;
    
    // Update the progress
    AthLoadString(idsProgCombiningMsgs, szProg, ARRAYSIZE(szProg));
    SetDlgItemText(hwnd, IDC_GENERAL_TEXT, szProg);
    SetDlgItemText(hwnd, IDC_SPECIFIC_TEXT, TEXT(""));
    
    // All the articles are downloaded.  Merge the message list
    // and open the note.        
    hr = m_pMsgParts->CombineParts(&pMsgComb);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                      MAKEINTRESOURCEW(idsGenericError), 0, MB_OK | MB_ICONSTOP);
    }
    else
    {
        FOLDERINFO info;
        INIT_MSGSITE_STRUCT initStruct;
        DWORD               dwCreateFlags = 0;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &info)))
        {
            // If this is a find folder, we need to put the account on the message
            if (!!(info.dwFlags & FOLDER_FINDRESULTS))
            {
                FOLDERID id;
                if (SUCCEEDED(m_pTable->GetRowFolderId(*m_rgRows, &id)))
                {
                    FOLDERINFO fiServer = {0};

                    if (SUCCEEDED(GetFolderServer(id, &fiServer)))
                    {
                        HrSetAccount(pMsgComb, fiServer.pszName);
                        g_pStore->FreeRecord(&fiServer);
                    }
                }
            }

            g_pStore->FreeRecord(&info);
        }

        // Initialize note struct
        initStruct.dwInitType = OEMSIT_MSG;
        initStruct.folderID   = m_idFolder;
        initStruct.pMsg       = pMsgComb;

        // Decide whether it is news or mail
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            FOLDERINFO rServer;
            if (SUCCEEDED(GetFolderServer(m_idFolder, &rServer)))
            {
                HrSetAccount(pMsgComb, rServer.pszAccountId);
                g_pStore->FreeRecord(&rServer);
            }

            dwCreateFlags = OENCF_NEWSFIRST;
        }

        // Create and Open Note
        hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwndParent);
        pMsgComb->Release();
    }

    EndDialog(m_hwndDlg, 0);
}

//
//  FUNCTION:   CCombineAndDecode::OnBegin()
//
//  PURPOSE:    Called when the store starts downloading an article.
//
HRESULT CCombineAndDecode::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnProgress()
//
//  PURPOSE:    Called while the messages are downloading to give us some 
//              progress.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    int increment;
    TCHAR szProg[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];

    Assert(m_hwndDlg != NULL);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Connection progress
    if (tyOperation == SOT_CONNECTION_STATUS)
    {
        Assert(dwCurrent < IXP_LAST);

        // Create some lovely status text
        int ids = XPUtil_StatusToString((IXPSTATUS) dwCurrent);
        AthLoadString(ids, szBuf, ARRAYSIZE(szBuf));
        SetDlgItemText(m_hwndDlg, IDC_GENERAL_TEXT, szBuf);
    }

    AthLoadString(idsProgDLGetLines, szProg, ARRAYSIZE(szProg));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szProg, dwCurrent, dwMax);
    SetDlgItemText(m_hwndDlg, IDC_SPECIFIC_TEXT, szBuf);

    increment = dwCurrent - m_cPrevLine;
    m_cCurrentLine += increment;
    m_cPrevLine = dwCurrent;

    if (m_cLinesTotal)
    {
        increment = m_cCurrentLine * 100 / m_cLinesTotal;
        SendDlgItemMessage(m_hwndDlg, IDC_DOWNLOAD_PROG, PBM_SETPOS, increment, 0);
    }

    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnTimeout()
//
//  PURPOSE:    If a timeout occurs, we call through to the default timeout handler.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}


//
//  FUNCTION:   CCombineAndDecode::OnTimeoutResponse()
//
//  PURPOSE:    Called when the user responds to a timeout dialog.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


//
//  FUNCTION:   CCombineAndDecode::CanConnect()
//
//  PURPOSE:    Called if the store needs to connect to download the requested
//              messages.  We just call through to the default handlers.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent, TRUE);
}



//
//  FUNCTION:   CCombineAndDecode::OnLogonPrompt()
//
//  PURPOSE:    If the user needs to logon, we present them with the default
//              logon UI.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}


//
//  FUNCTION:   CCombineAndDecode::OnComplete()
//
//  PURPOSE:    When we finish downloading a message, this get's hit.  We add
//              this message to the list for the combiner and then request the
//              next message.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
        EndDialog(m_hwndDlg, 0);
    }
    else
    {
        if (tyOperation == SOT_GET_MESSAGE)
            PostMessage(m_hwndDlg, CND_MESSAGEAVAIL, 0, 0);
    }
    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnPrompt()
//
//  PURPOSE:    Last time I checked, this was SSL related goo.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}


//
//  FUNCTION:   CCombineAndDecode::GetParentWindow()
//
//  PURPOSE:    Called if the store needs to show UI.  We return our dialog
//              window handle.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}



#if 0
BOOL CALLBACK CombineAndDecodeProg(HWND hwnd, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    PORDERPARAMS    pop = (PORDERPARAMS) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR           szProg[CCHMAX_STRINGRES];
    TCHAR           szBuf[CCHMAX_STRINGRES];
    LPMIMEMESSAGE   pMsg=0;
    DWORD           increment;
    HRESULT         hr;
    
    switch (uMsg)
    {
        case IMC_BODYAVAIL:
        {
            LPMIMEMESSAGE pMsg = NULL;
            BOOL          fCached = FALSE;
            
            Assert(pop->pGroup);
            if (SUCCEEDED(wParam) && SUCCEEDED(pop->pGroup->GetArticle(pop->rgpMsgs[pop->dwCurrentArt], &pMsg, hwnd, &fCached, FALSE, GETMSG_INSECURE)) && fCached)
            {
                Assert(pMsg);
                Order_OnMsgAvail(hwnd, pop, pMsg);
            }
            else
            {
                if ((HRESULT)wParam != hrUserCancel)
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                    MAKEINTRESOURCEW(idsErrNewsCantOpen), 0, MB_OK | MB_ICONSTOP);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
            
            if (pMsg)
                pMsg->Release();
            return (TRUE);
        }
        
        
    }

    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\newsutil.cpp ===
#include "pch.hxx"
#include "storutil.h"
#include <mailutil.h>
#include "range.h"
#include "shlwapip.h" 
#include <xpcomm.h>
#include <subscr.h>
#include "newsstor.h"
#include <storecb.h>
#include "newsutil.h"

ASSERTDATA

static const char c_szCancelFmt[] = "cancel %s";

//
//  FUNCTION:   NewsUtil_FCanCancel
//
//  PURPOSE:    This function determines whether cancel should be allowed
//
//  PARAMETERS: szDisplayFrom   - the display portion of the From: field
//              szEmailFrom     - the address portion of the From: field
//
//  RETURN VALUE: TRUE if cancel should be allowed
//
BOOL NewsUtil_FCanCancel(FOLDERID idFolder, LPMESSAGEINFO pInfo)
{
    HRESULT hr;
    BOOL fRet;
    FOLDERINFO info;
    char sz[CCHMAX_DISPLAY_NAME];
    IImnAccount *pAcct;
    
    Assert(pInfo != NULL);
    Assert(CCHMAX_EMAIL_ADDRESS <= CCHMAX_DISPLAY_NAME);

    fRet = FALSE;

    hr = g_pStore->GetFolderInfo(idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_NEWS &&
            0 == (pInfo->dwFlags & ARF_ARTICLE_EXPIRED) &&
            pInfo->pszAcctId != NULL &&
            pInfo->pszDisplayFrom != NULL &&
            pInfo->pszEmailFrom != NULL)
        {
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
            if (SUCCEEDED(hr))
            {
                // make sure the display name and the email address match
                if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, sz, ARRAYSIZE(sz))))
                {
                    if (!lstrcmp(pInfo->pszDisplayFrom, sz))
                    {
                        if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, sz, ARRAYSIZE(sz))))
                            fRet = (0 == lstrcmp(pInfo->pszEmailFrom, sz));
                    }
                }
    
                pAcct->Release();
            }
        }

        g_pStore->FreeRecord(&info);
    }

    return(fRet);
}

//
//  FUNCTION:   NewsUtil_HrCancelPost
//
//  PURPOSE:    This function cancels the specified article
//
//  PARAMETERS: hwnd        - the hwnd for ui
//              pszAccount  - the account to use to cancel the article
//              szMsgId     - the Message-ID:   of the article to cancel
//              szFrom      - the From:         of the article to cancel
//              szSubj      - the Subject:      of the article to cancel
//              szGroups    - the Newsgroups:   of the article to cancel
//              szDistrib   - the Distribution: of the article to cancel
//
//  RETURN VALUE: HRESULT
//
HRESULT NewsUtil_HrCancelPost(HWND hwnd, FOLDERID idGroup, LPMESSAGEINFO pInfo)
{
    HRESULT         hr;
    FOLDERINFO      info;
    LPMIMEMESSAGE   pMsg;
    LPSTR           pszCancel;
    IImnAccount    *pAcct;

    Assert(pInfo != NULL);
    
    if (!NewsUtil_FCanCancel(idGroup, pInfo) && DwGetOption(OPT_CANCEL_ALL_NEWS))
    {
        if (AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsVerifyCancel),
                          NULL,
                          MB_YESNO) == IDNO)
        {
            return (FALSE);
        }
    }


    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
    if (FAILED(hr))
        return(hr);

    int cch = lstrlen(pInfo->pszMessageId) + 20;
    if (!MemAlloc((void **)&pszCancel, cch))
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pStore->GetFolderInfo(idGroup, &info);
        if (SUCCEEDED(hr))
        {
            hr = HrCreateMessage(&pMsg);
            if (SUCCEEDED(hr))
            {
                wnsprintf(pszCancel, cch, c_szCancelFmt, pInfo->pszMessageId);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CONTROL), NOFLAGS, pszCancel);
                
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), PDF_ENCODED | PDF_SAVENOENCODE, pInfo->pszFromHeader);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pInfo->pszSubject);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, info.pszName);
                
                HrSetAccountByAccount(pMsg, pAcct);
    
                hr = pMsg->Commit(0);
                if (SUCCEEDED(hr))
                {
                    hr = HrSendMailToOutBox(hwnd, pMsg, TRUE, FALSE, FALSE);
                    if (SUCCEEDED(hr))
                    {
                        DoDontShowMeAgainDlg(hwnd, c_szDSCancelNews, 
                            MAKEINTRESOURCE(idsAthena), 
                            MAKEINTRESOURCE(idsDelSentToServer), 
                            MB_OK);
                    }
                    else
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                            MAKEINTRESOURCEW(idsCancelFailed), NULL, MB_OK);
                    }
                }

                pMsg->Release();
            }
    
            g_pStore->FreeRecord(&info);
        }
    
        MemFree(pszCancel);
    }

    pAcct->Release();

    return(hr);
}

DWORD NewsUtil_GetNotDownloadCount(FOLDERINFO *pInfo)
{
    DWORD dw, curr, cOverlap, dwMax;
    CRangeList *pRange;

    Assert(pInfo != NULL);

    dw = 0;

    if (pInfo->dwServerHigh != 0 &&
        pInfo->dwServerLow <= pInfo->dwServerHigh)
    {
        pRange = new CRangeList;
        if (pRange != NULL)
        {
            dw = pInfo->dwServerCount;

            if (pInfo->Requested.cbSize > 0)
            {
                pRange->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

                dwMax = pRange->Max();

                Assert(pInfo->dwServerHigh >= dwMax);
                if ((pInfo->dwServerHigh - dwMax) >= dw)
                {
                    dw = 0;
                }
                else
                {
                    dw -= pInfo->dwServerHigh - dwMax;

                    curr = pInfo->dwServerLow - 1;
                    cOverlap = 0;

                    while (-1 != (curr = pRange->Next(curr)))
                        cOverlap++;
                    if (cOverlap < dw)
                        dw -= cOverlap;
                    else
                        dw = 0;
                }

                Assert(dwMax >= pInfo->dwClientHigh);
                if (pInfo->dwServerHigh > dwMax)
                    dw += pInfo->dwServerHigh - dwMax;
            }

            pRange->Release();
        }
    }

    return(dw);
}

HRESULT NewsUtil_CheckForNewGroups(HWND hwnd, FOLDERID idFolder, CGetNewGroups **ppGroups)
    {
    HRESULT     hr;
    FILETIME    ftLast;
    FILETIME    ftNow;
    SYSTEMTIME  stNow, stLast;
    BOOL        fUpdate;
    IImnAccount *pAcct;
    DWORD       dwSize;
    FOLDERINFO  info;
    CGetNewGroups *pGroups;

    Assert(ppGroups != NULL);
    Assert(*ppGroups == NULL);

    hr = GetFolderServer(idFolder, &info);
    if (FAILED(hr))
        return(hr);

    Assert(info.tyFolder == FOLDER_NEWS);
    if (FHasChildren(&info, FALSE))
    {
        fUpdate = FALSE;

        // Get the current  time
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &ftNow);

        // Get the account object for this server
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, info.pszAccountId, &pAcct)))
        {
            dwSize = sizeof(ftLast);
            if (SUCCEEDED(pAcct->GetProp(AP_LAST_UPDATED, (LPBYTE)&ftLast, &dwSize)))
            {
                FileTimeToSystemTime(&ftLast, &stLast);
                fUpdate = (stNow.wYear > stLast.wYear ||
                            stNow.wMonth > stLast.wMonth ||
                            stNow.wDay > stLast.wDay);
            }
            else
            {
                pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&ftNow, sizeof(ftNow));
                pAcct->SaveChanges();
            }

            pAcct->Release();
        }

        if (fUpdate)
        {
            pGroups = new CGetNewGroups(hwnd, info.idFolder, info.pszAccountId, &ftNow);
            if (pGroups == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = g_pStore->GetNewGroups(info.idFolder, &stLast, (IStoreCallback *)pGroups);
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                }
                else
                {
                    pGroups->Release();
                    pGroups = NULL;
                }
            }

            *ppGroups = pGroups;
        }
    }

    g_pStore->FreeRecord(&info);

    return(hr);
}

CGetNewGroups::CGetNewGroups(HWND hwnd, FOLDERID idFolder, LPCSTR pszAcctId, FILETIME *pft)
{
    Assert(hwnd != NULL);
    Assert(idFolder != FOLDERID_INVALID);
    Assert(pszAcctId != NULL);
    Assert(pft != NULL);

    m_cRef = 1;
    m_hr = E_FAIL;
    m_fComplete = FALSE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;

    m_hwnd = hwnd;
    m_idFolder = idFolder;
    StrCpyN(m_szAcctId, pszAcctId, ARRAYSIZE(m_szAcctId));
    m_ft = *pft;
}

CGetNewGroups::~CGetNewGroups()
{
    if (m_pCancel != NULL)
    {
        m_pCancel->Cancel(CT_ABORT);
        m_pCancel->Release();
    }
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGetNewGroups::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGetNewGroups::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CGetNewGroups::Close()
{
    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_ABORT);

    return(S_OK);
}

HRESULT CGetNewGroups::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation == SOT_GET_NEW_GROUPS);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(!m_fComplete);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Call into general OnLogonPrompt Utility
    return(S_FALSE);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwnd != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    PostMessage(m_hwnd, NVM_GETNEWGROUPS, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwnd != NULL);

    *phwndParent = m_hwnd;

    return(S_OK);
}

HRESULT CGetNewGroups::HandleGetNewGroups()
{
    FOLDERINFO info;
    IImnAccount *pAcct;
    HRESULT hr;

    Assert(m_fComplete);

    if (m_hr == S_OK)
    {
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAcctId, &pAcct)))
        {
            pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&m_ft, sizeof(m_ft));
            pAcct->SaveChanges();
            pAcct->Release();

            if (DwGetOption(OPT_NOTIFYGROUPS))
            {
                hr = g_pStore->GetFolderInfo(m_idFolder, &info);
                if (FAILED(hr))
                    return(hr);

                if (!!(info.dwFlags & FOLDER_HASNEWGROUPS))
                {
                    // If there are new groups, ask the user if they care.
                    if (IDYES == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena),
                                   MAKEINTRESOURCEW(idsNewGroups), 0,
                                   MB_ICONINFORMATION | MB_YESNO))
                    {
                        DoSubscriptionDialog(m_hwnd, TRUE, m_idFolder, TRUE);
                    }
                }

                g_pStore->FreeRecord(&info);
            }
        }
    }

    return(S_OK);
}

class CDownloadArticleCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CDownloadArticleCB(void);
        ~CDownloadArticleCB(void);

        HRESULT Download(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg);

        static INT_PTR CALLBACK DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndDlg;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
        LPCSTR      m_pszArticle;
        LPSTREAM    m_pStream;
        CNewsStore *m_pNewsStore;
};

INT_PTR CALLBACK CDownloadArticleCB::DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    CDownloadArticleCB *pThis = (CDownloadArticleCB *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            // replace some strings in the group download dialog
            AthLoadString(idsDownloadArtTitle, szRes, sizeof(szRes));
            SetWindowText(hwnd, szRes);
            AthLoadString(idsDownloadArtMsg, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
    
            CenterDialog(hwnd);
            Assert(lParam);
            pThis = (CDownloadArticleCB *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            pThis->m_hwndDlg = hwnd;

            Animate_Open(GetDlgItem(hwnd, idcAnimation), idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);
            AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, 0);
            SetDlgItemText(hwnd, idcProgText, szBuffer);
            
            hr = pThis->m_pNewsStore->GetArticle(pThis->m_pszArticle, pThis->m_pStream, (IStoreCallback *)pThis);
            if (hr == E_PENDING)
                SetForegroundWindow(hwnd);
            else
                EndDialog(hwnd, 0);
            return (TRUE);
            
        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
            {                
                Animate_Stop(GetDlgItem(hwnd, idcAnimation));
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_ABORT);
                return TRUE;
            }
            break;
            
        case WM_STORE_COMPLETE:
            EndDialog(hwnd, 0);
            return(0);
    }

    return FALSE;        
}

CDownloadArticleCB::CDownloadArticleCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = FALSE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_pszArticle = NULL;
    m_pNewsStore = NULL;
    m_pStream = NULL;
}

CDownloadArticleCB::~CDownloadArticleCB()
{
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();

}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CDownloadArticleCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CDownloadArticleCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CDownloadArticleCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];

    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (tyOperation == SOT_GET_MESSAGE)
    {
        AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer),szRes, dwCurrent);
        SetDlgItemText(m_hwndDlg, idcProgText, szBuffer);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwndDlg,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}

HRESULT CDownloadArticleCB::Download(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    FOLDERID    idServer;
    HRESULT     hr;
    LPMIMEMESSAGE pMsg;

    Assert(pszAccountId != NULL);
    Assert(pszArticle != NULL);
    Assert(ppMsg != NULL);

    hr = g_pStore->FindServerId(pszAccountId, &idServer);
    if (FAILED(hr))
        return(hr);

    m_pNewsStore = new CNewsStore;
    if (m_pNewsStore == NULL)
        return(E_OUTOFMEMORY);

    hr = m_pNewsStore->Initialize(idServer, pszAccountId);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr = HrCreateMessage(&pMsg)))
        {
            if (SUCCEEDED(hr = MimeOleCreateVirtualStream(&m_pStream)))
            {
                m_pszArticle = pszArticle;
                DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddDownloadGroups), NULL, 
                                DownloadArticleDlg, (LPARAM)this);
                if (m_hr == S_OK)
                {
                    pMsg->Load(m_pStream);
                    *ppMsg = pMsg;
                    (*ppMsg)->AddRef();
                }

                hr = m_hr;

                m_pStream->Release();
            }

            pMsg->Release();
        }

        m_pNewsStore->Close(MSGSVRF_HANDS_OFF_SERVER);
    }

    m_pNewsStore->Release();

    return hr;
}

HRESULT HrDownloadArticleDialog(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    CDownloadArticleCB *pCB;
    HRESULT hr;

    pCB = new CDownloadArticleCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Download(pszAccountId, pszArticle, ppMsg);

    pCB->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\rangetst.h ===
#define idcAddRange                     1000
#define idcDeleteRange                  1001
#define idcIsInRange                    1002
#define idcNextInRange                  1003
#define idcPrevInRange                  1004
#define idcClear                        1005
#define idcInput1                       1006
#define idcInput2                       1007
#define idcResult                       1008
#define idcPrint                        1009

INT_PTR CALLBACK RangeTestDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\range.cpp ===
//
// RANGE.CPP
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
//

// -*- C -*-
//
//  Copyright 1992 Software Innovations, Inc.
//
//  $Source: D:\CLASS\SOURCE\range.c-v $
//  $Author: martin $
//  $Date: 92/07/15 05:09:24 $
//  $Revision: 1.1 $
//
//

#include "pch.hxx"
#include "range.h"
#include "rangetst.h"

// QUANTUM defines the number of m_rangeTable cells to be allocated at
//   one time.  Whenever the m_rangeTable becomes full, it is expanded
//   by QUANTUM range cells.  m_rangeTable's never shrink.
const int QUANTUM = 64;

inline int inRange(RangeType r, ULONG x) { return ((x>=r.low) && (x<=r.high)); };

CRangeList::CRangeList()
{
    m_cRef = 1;
    m_numRanges = 0;
    m_rangeTableSize = 0;
    m_rangeTable = NULL;
}

#if 0
/*
CRangeList::CRangeList(CRangeList& r)
{
    m_numRanges = r.m_numRanges;
    m_rangeTableSize = r.m_rangeTableSize;
    m_rangeTable = new RangeType[m_rangeTableSize];
    CopyMemory(m_rangeTable, r.m_rangeTable, m_numRanges * sizeof(RangeType));
}
*/
#endif

CRangeList::~CRangeList()
{
    if (m_rangeTable)
        MemFree(m_rangeTable);
}

ULONG CRangeList::AddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&m_cRef);
}

ULONG CRangeList::Release(void)
{    
    ULONG cRefT = (ULONG)InterlockedDecrement((LPLONG)&m_cRef);

    if (cRefT == 0)
        delete this;

    return (cRefT);
}

BOOL CRangeList::IsInRange(const ULONG value) const
{
    for (int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return TRUE;
    return FALSE;
}

ULONG CRangeList::MinOfRange(const ULONG value) const
{
    if (RANGE_ERROR == value)
        return RANGE_ERROR;
    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return m_rangeTable[i].low;
    return RANGE_ERROR;
}

ULONG CRangeList::MaxOfRange(const ULONG value) const
{
    if (RANGE_ERROR == value)
        return RANGE_ERROR;
    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return m_rangeTable[i].high;
    return RANGE_ERROR;
}

ULONG CRangeList::Max() const
{
    if (m_numRanges==0)
        return RANGE_ERROR;
    return m_rangeTable[m_numRanges-1].high;
}

ULONG CRangeList::Min() const
{
    if (m_numRanges==0)
        return RANGE_ERROR;
    return m_rangeTable[0].low;
}

BOOL CRangeList::Save(LPBYTE *const ppb, ULONG *const pcb) const
{
    Assert(ppb);
    Assert(pcb);

    *pcb = m_numRanges * sizeof(RangeType);
    if (*pcb)
        {
        if (!MemAlloc((LPVOID*)ppb, *pcb))
            return FALSE;
        CopyMemory(*ppb, m_rangeTable, *pcb);
        }
    else
        *ppb = NULL;
    return TRUE;
}

BOOL CRangeList::Load(const LPBYTE pb, const ULONG cb)
{
    RangeType *pRangeTable;

    Assert(pb != NULL);
    Assert(cb > 0);

    if (!MemAlloc((void **)&pRangeTable, cb))
        return(FALSE);

    m_numRanges = m_rangeTableSize = cb / sizeof(RangeType);
    if (m_rangeTable)
        MemFree(m_rangeTable);
    CopyMemory(pRangeTable, pb, cb);
    m_rangeTable = pRangeTable;

    return TRUE;
}

BOOL CRangeList::NextLowerAntiRange(const ULONG value, RangeType *const rt) const
{
    if (RANGE_ERROR == value || m_numRanges < 2 || !rt)
        return FALSE;

    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            {
            if (0 == i)
                return FALSE;
            rt->high = m_rangeTable[i].low-1;
            rt->low = m_rangeTable[i-1].high+1;
            return TRUE;
            }
    return FALSE;
}

BOOL CRangeList::NextHigherAntiRange(const ULONG value, RangeType *const rt) const
{
    if (RANGE_ERROR == value || m_numRanges < 2 || !rt)
        return FALSE;

    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            {
            if (m_numRanges-1 == i)
                return FALSE;
            rt->low = m_rangeTable[i].high+1;
            rt->high = m_rangeTable[i+1].low-1;
            return TRUE;
            }
    return FALSE;
}

BOOL CRangeList::HighestAntiRange(RangeType *const rt) const
{
    if (m_numRanges < 2 || !rt)
        return FALSE;
    rt->high = m_rangeTable[m_numRanges-1].low-1;
    rt->low = m_rangeTable[m_numRanges-2].high+1;
    return TRUE;
}

BOOL CRangeList::LowestAntiRange(RangeType *const rt) const
{
    if (m_numRanges < 2 || !rt)
        return FALSE;
    rt->high = m_rangeTable[1].low-1;
    rt->low = m_rangeTable[0].high+1;
    return TRUE;
}

BOOL CRangeList::AddRange(const ULONG value)
{
    RangeType r = { value, value };
    return AddRange(r);
}

BOOL CRangeList::AddRange(const ULONG low, const ULONG high)
{
    RangeType r = { low, high };
    return AddRange(r);
}

BOOL CRangeList::AddRange(CRangeList& r)
{
    for (int i=0 ; i<r.m_numRanges ; ++i)
        if (!AddRange(r.m_rangeTable[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::AddRange(RangeType *rt, int count)
{
    for (int i=0 ; i<count ; ++i)
        if (!AddRange(rt[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::AddRange(const RangeType range)
{
    int  possibleLoc;
    int  insertPosition;

    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to AddRange()");
        return FALSE;
        }

    if (m_numRanges==0) 
        {
        if (m_rangeTableSize == 0)
            if (!Expand())
                return FALSE;
        m_numRanges = 1;
        CopyMemory(&m_rangeTable[0], &range, sizeof(RangeType));
        } 
    else 
        {
        possibleLoc = BinarySearch(range.low);
        if (!((possibleLoc > -1) &&
              (inRange(m_rangeTable[possibleLoc], range.low)) &&
              (inRange(m_rangeTable[possibleLoc], range.high)))) 
            {
            insertPosition = possibleLoc + 1;
            if (m_numRanges == m_rangeTableSize)
                if (!Expand())
                    return FALSE;
            ShiftRight(insertPosition, 1);
            CopyMemory(&m_rangeTable[insertPosition], &range, sizeof(RangeType));
            if (insertPosition > 0)
                SubsumeDown(insertPosition);
            if (insertPosition < m_numRanges)
                SubsumeUpwards(insertPosition);
            }
        }
    return TRUE;
}

BOOL CRangeList::DeleteRange(const ULONG value)
{
    RangeType r = { value, value };
    return DeleteRange(r);
}

BOOL CRangeList::DeleteRange(const ULONG low, const ULONG high)
{
    RangeType r = { low, high };
    return DeleteRange(r);
}

BOOL CRangeList::DeleteRange(CRangeList& r)
{
    for (int i=0 ; i<r.m_numRanges ; ++i)
        if (!DeleteRange(r.m_rangeTable[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::DeleteRange(const RangeType range)
{
    int lowEndChange;
    int highEndChange;

    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to DeleteRange()");
        return FALSE;
        }

    lowEndChange = BinarySearch(range.low);
    highEndChange = BinarySearch(range.high);

    if ((lowEndChange != -1) && (highEndChange == lowEndChange))  
        {
        if (inRange(m_rangeTable[lowEndChange], range.low)) 
            {
            if (inRange(m_rangeTable[lowEndChange], range.high)) 
                {
                if ((m_rangeTable[lowEndChange].low == range.low) &&
                    (m_rangeTable[lowEndChange].high == range.high)) 
                    {
                    if (lowEndChange == (m_numRanges-1))  
                        {
                        m_numRanges--;
                        } 
                    else 
                        {
                        ShiftLeft(lowEndChange + 1, 1);
                        }
                    } 
                else 
                    {
                    if (m_rangeTable[lowEndChange].low == range.low)  
                        {
                        m_rangeTable[lowEndChange].low = range.high + 1;
                        } 
                    else 
                        {
                        if (m_rangeTable[lowEndChange].high == range.high) 
                            {
                            Assert(range.low > 0);
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            } 
                        else 
                            {
                            // the range to be deleted is properly contained in 
                            //  m_rangeTable[lowEndChange]
                            if (m_numRanges == m_rangeTableSize)
                                if (!Expand())
                                    return FALSE;
                            ShiftRight(lowEndChange + 1, 1);
                            m_rangeTable[lowEndChange + 1].low = range.high + 1;
                            m_rangeTable[lowEndChange + 1].high = m_rangeTable[lowEndChange].high;
                            Assert(range.low > 0);    
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            }
                        }
                    }
                } 
            else 
                {
                // range.low is in m_rangeTable[lowEndChange], but range.high
                //  is not
                if (m_rangeTable[lowEndChange].low == range.low) 
                    {
                    ShiftLeft(lowEndChange + 1, 1);
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }  // of the cases where range.low actually in m_rangeTable[lowEndChange]
        } 
    else 
        { // of the cases where highEndChange == lowEndChange
        if (lowEndChange != -1)  
            {
            if (inRange(m_rangeTable[lowEndChange], range.low))  
                {
                if (range.low == m_rangeTable[lowEndChange].low) 
                    {
                    lowEndChange = lowEndChange - 1;
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }
        if (highEndChange != -1)  
            {
            if (inRange(m_rangeTable[highEndChange], range.high))  
                {
                if (range.high == m_rangeTable[highEndChange].high)  
                    {
                    highEndChange = highEndChange + 1;
                    } 
                else 
                    {
                    m_rangeTable[highEndChange].low = range.high + 1;
                    }
                } 
            else 
                {
                highEndChange++;
                }
            }
        if (!(lowEndChange > highEndChange)) 
            {
            // (0 <= lowEndChange < m_numRanges => m_rangeTable[lowEndChange] has received
            //                 any requisite adjustments and is to be kept)
            //  and (0 <= highEndChange < m_numRanges => m_rangeTable[highEndChange]
            //                 has received any requistie adjs. and is a keeper)
            //  and "forall" i [ lowEndChange < i < highEndChange => 
            //                   m_rangeTable[i] is to be overwritten]
            if (highEndChange >= m_numRanges)  
                {
                m_numRanges = lowEndChange + 1;
                } 
            else 
                {
                if ((highEndChange - lowEndChange - 1) > 0)  
                    {
                    ShiftLeft(highEndChange, (highEndChange-lowEndChange-1));
                    }
                }
            } //  else there's a problem with this code...
        }
    return TRUE;
}


ULONG CRangeList::Next(const ULONG current) const
{
    int loc;

    if (m_numRanges == 0)
        return RANGE_ERROR;

    if ((loc = BinarySearch(current)) == -1)
        return m_rangeTable[0].low;
    else if (loc == (m_numRanges-1))
        {
        if (inRange(m_rangeTable[m_numRanges-1], current))
            {
            if (inRange(m_rangeTable[m_numRanges-1], current + 1))
                return current + 1;
            else
                return RANGE_ERROR;
            }
        else
            return RANGE_ERROR;
        }
    else // case where loc == m_numRanges-1
        {
        // 1 <= loc < m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (inRange(m_rangeTable[loc], current + 1))
                return current + 1;
            else
                return m_rangeTable[loc + 1].low;
            }
        else
            return m_rangeTable[loc + 1].low;
        }
}

ULONG CRangeList::Prev(const ULONG current) const
{
    int loc;

    if (m_numRanges == 0)
        return RANGE_ERROR;

    if ((loc = BinarySearch(current)) == -1) 
        {
        return RANGE_ERROR;
        } 
    else if (loc == 0)
        {
        if (inRange(m_rangeTable[0], current))
            {
            if (current > 0 && inRange(m_rangeTable[0], current - 1))
                return current - 1;
            else
                return RANGE_ERROR;
            }
        else
            return m_rangeTable[0].high;
        }
    else
        {
        // 1 < loc <= m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (current > 0 && inRange(m_rangeTable[loc], current - 1))
                return current - 1;
            else
                return m_rangeTable[loc-1].high;
            }
        else
            return m_rangeTable[loc].high;
        }
}

ULONG CRangeList::Cardinality(void) const
{
    ULONG card = 0;

    for (int i=0 ; i<m_numRanges ; i++)
        card += (m_rangeTable[i].high - m_rangeTable[i].low + 1);
    return card;
}



int CRangeList::BinarySearch(const ULONG value) const
{
//  We are looking for `value' in the m_rangeTable.  If value is in the
//  set of valid ranges, we return the array subscript of the range
//  containing `value'.  If `value' is not contained in any of the 
//  ranges then return `loc' where
//        (0 <= loc < m_numRanges =>
//                 (m_rangeTable[loc].low < rangeNum)
//           "and" (m_rangeTable[loc + 1].low > rangeNum))
//    "and" (loc = m_numRanges => rangeNum > m_rangeTable[m_numRanges].low)
//    "and" (loc = -1 =>     m_numRanges = 0
//                     "or" rangeNum < m_rangeTable[0].low) }
    long low, high, mid;
    int loc=-1;

    if (m_numRanges == 0)
        return -1;

    if (value < m_rangeTable[0].low)
        return -1;

    low = 0;
    high = m_numRanges - 1;
    while (low <= high) {
        // inv: low < high - 1, and if rngNum is any where in m_rangeTable, it is in
        //      the range from m_rangeTable[low] to m_rangeTable[high]
        mid = (low + high) / 2;
        if ((value >= m_rangeTable[mid].low) && 
            ((mid == (m_numRanges-1)) || (value < m_rangeTable[mid + 1].low))) 
            {
            loc = mid;
            high = low - 1;
            } 
        else 
            {
            if (value > m_rangeTable[mid].low)
                low = mid + 1;
            else
                high = mid - 1;
            }
    }
    return loc;
}

// Expand() will grow the m_rangeTable by QUANTUM range cells.
BOOL CRangeList::Expand()
{
    RangeType *newRangeTable;

    if (!MemAlloc((LPVOID*)&newRangeTable, (m_rangeTableSize + QUANTUM) * sizeof(RangeType)))
        return FALSE;

    m_rangeTableSize += QUANTUM;
    if (m_rangeTable) 
        {
        if (m_numRanges > 0)
            CopyMemory(newRangeTable, m_rangeTable, m_numRanges * sizeof(RangeType));
        MemFree(m_rangeTable);
        }
    m_rangeTable = newRangeTable;
    return TRUE;
}

void CRangeList::ShiftLeft(int low, int distance)
{
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low-distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges -= distance;
}

void CRangeList::ShiftRight(int low, int distance)
{
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low+distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges += distance;
}

// pre: (m_rangeTable[anchorPosition] has probably just been added to m_rangeTable.)
//          1 <= anchorPosition <= m_numRanges
//      and (   anchorPosition = 1
//           or (m_rangeTable[anchorPosition].low >
//                 m_rangeTable[anchorPosition - 1].high) )
// post: No overlapping or contiguous ranges from 1 to m_numRanges. }
void CRangeList::SubsumeUpwards(const int anchor)
{
    int posOfLargerLow;
    int copyDownDistance;
    int copyPos;

    posOfLargerLow = anchor + 1;
    while ((posOfLargerLow < m_numRanges) && 
           (m_rangeTable[posOfLargerLow].low <= m_rangeTable[anchor].high + 1))
        posOfLargerLow++;

    if (posOfLargerLow == m_numRanges) 
        {
        if (m_rangeTable[m_numRanges-1].high > m_rangeTable[anchor].high)
            m_rangeTable[anchor].high = m_rangeTable[m_numRanges-1].high;
        m_numRanges = anchor + 1;
        } 
    else 
        {
        // posOfLargerLow now indexes the first element of m_rangeTable, looking from
        // m_rangeTable[anchor], with .low > m_rangeTable[anchor].high + 1
        if (posOfLargerLow > (anchor + 1)) 
            {
            if (m_rangeTable[posOfLargerLow - 1].high > m_rangeTable[anchor].high) 
                m_rangeTable[anchor].high = m_rangeTable[posOfLargerLow - 1].high;
            copyDownDistance = posOfLargerLow - anchor - 1;
            copyPos = posOfLargerLow;
            while (copyPos < m_numRanges) 
                {
                m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
                copyPos = copyPos + 1;
                }
            m_numRanges -= copyDownDistance;
            }
        }
}

void CRangeList::SubsumeDown(int& anchor)
{
    int posOfSmallerHigh;
    int copyDownDistance;
    int copyPos;

    posOfSmallerHigh = anchor - 1;
    while ((posOfSmallerHigh >= 0) &&
           (m_rangeTable[posOfSmallerHigh].high + 1 >= m_rangeTable[anchor].low)) 
        {
        posOfSmallerHigh--;
        }

    if (posOfSmallerHigh < 0) 
        {
        if (m_rangeTable[0].low < m_rangeTable[anchor].low)
            m_rangeTable[anchor].low = m_rangeTable[0].low;
        }

    // posOfSmallerHigh either has value 0 or subscripts the first element of
    //  m_rangeTable, looking down from anchor, with a .high that is
    //  less than m_rangeTable[anchor].low - 1.
    if (m_rangeTable[posOfSmallerHigh + 1].low < m_rangeTable[anchor].low)
        m_rangeTable[anchor].low = m_rangeTable[posOfSmallerHigh + 1].low;
    copyDownDistance = anchor - posOfSmallerHigh - 1;
    if (copyDownDistance > 0) 
        {
        copyPos = anchor;
        while (copyPos < m_numRanges) 
            {
            m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
            copyPos++;
            }
        m_numRanges -= copyDownDistance;
        anchor -= copyDownDistance;
        }
}



#if 0
/* 
 * We might need these ones again if we decide to import .newsrc files
 *
void CRangeList::AddRange(const char *s)
{
    char *token, *q;
    char *p = new char[strlen(s)+1];

    strcpy(p, s);

    if ((token = strtok(p, ","))==NULL)
        return;
    while (token!=NULL) {
        if ((q = strchr(token, '-'))==NULL) {  // no dash - single value
            AddRange(atol(token));
        } else {
            long low, high;
            low = atol(token);
            high = atol(q+1);
            if (low<=high)
                AddRange(low, high);
        }
        token = strtok(NULL, ",");
    }
}

void CRangeList::DeleteRange(const char *s)
{
    char *token, *q;
    char *p = new char[strlen(s)+1];

    strcpy(p, s);

    if ((token = strtok(p, ","))==NULL)
        return;
    while (token!=NULL) {
        if ((q = strchr(token, '-'))==NULL) {  // no dash - single value
            DeleteRange(atol(token));
        } else {
            long low, high;
            low = atol(token);
            high = atol(q+1);
            if (low<=high)
                DeleteRange(low, high);
        }
        token = strtok(NULL, ",");
    }
}
*/
#endif

#ifdef DEBUG

#define WORK_BUFSIZ 256

LPTSTR CRangeList::RangeToString()
{
    LPTSTR  p, buffer;
    TCHAR   temp[20];
    int     buffsize = m_numRanges ? WORK_BUFSIZ : 1;

    if (!MemAlloc((LPVOID*)&buffer, buffsize * sizeof(TCHAR)))
        return NULL;
    *buffer = '\0';

    // nothing to do?
    if (m_numRanges == 0) 
        return buffer;

    // dump the ranges as a string: "low-high, low-high, singleton, low-high\n"
    for (int i=0; i<m_numRanges; i++) 
        {
        if (m_rangeTable[i].low == m_rangeTable[i].high)
            wnsprintf(temp, ARRAYSIZE(temp), "%ld", m_rangeTable[i].low);
        else
            wnsprintf(temp, ARRAYSIZE(temp), "%ld-%ld", m_rangeTable[i].low, m_rangeTable[i].high);

        if ((lstrlen(temp) + lstrlen(buffer) + 2) > buffsize) 
            {
            // buffer is about to overflow... double its size
            if (!MemAlloc((LPVOID*)&p, 2 * buffsize))
                {
                MemFree(buffer);
                return NULL;
                }
            buffsize *= 2;
            StrCpyN(p, buffer, buffsize);
            MemFree(buffer);
            buffer = p;
            }
        StrCatBuff(buffer, temp, buffsize);
        if (i < (m_numRanges-1))
            StrCatBuff(buffer, ",", buffsize);
        }

    // save some space, trim the buffer down
    buffsize = lstrlen(buffer)+1;
    if (MemAlloc((LPVOID*)&p, buffsize * sizeof(TCHAR)))
        {
        StrCpyN(p, buffer, buffsize);
        MemFree(buffer);
        buffer = p;
        }
    return buffer;
}

void CRangeList::DebugOutput(LPTSTR szComment)
{
    LPTSTR  szRange = RangeToString();
    OutputDebugString(szComment);
    if (szRange)
        {
        OutputDebugString(szRange);
        MemFree(szRange);
        }
    OutputDebugString("\r\n");
}

#endif

#ifdef DEBUG
INT_PTR CALLBACK RangeTestDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CRangeList *pRL = (CRangeList *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg)
        {
        case WM_INITDIALOG:
            {
            pRL = new CRangeList();
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pRL);
            break;
            }

        case WM_COMMAND:
            {
            int     i1 = GetDlgItemInt(hwnd, idcInput1, NULL, FALSE);
            int     i2 = GetDlgItemInt(hwnd, idcInput2, NULL, FALSE);
            BOOL    fRet;
            LPTSTR  szRange;

            switch(GET_WM_COMMAND_ID(wp,lp))
                {
                case IDOK:
                case IDCANCEL:
                    delete pRL;
                    SetWindowLongPtr(hwnd, DWLP_USER, 0);
                    EndDialog(hwnd, TRUE);
                    return TRUE;
                case idcAddRange:
                    fRet = pRL->AddRange(i1, i2);
                    szRange = pRL->RangeToString();
                    SetDlgItemText(hwnd, idcPrint, szRange);
                    if (szRange)
                        MemFree(szRange);
                    SetDlgItemInt(hwnd, idcResult, fRet, FALSE);
                    return TRUE;
                case idcDeleteRange:
                    fRet = pRL->DeleteRange(i1, i2);
                    szRange = pRL->RangeToString();
                    SetDlgItemText(hwnd, idcPrint, szRange);
                    if (szRange)
                        MemFree(szRange);
                    SetDlgItemInt(hwnd, idcResult, fRet, FALSE);
                    return TRUE;
                case idcIsInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->IsInRange(i1), FALSE);
                    return TRUE;
                case idcNextInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->Next(i1), TRUE);
                    return TRUE;
                case idcPrevInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->Prev(i1), TRUE);
                    return TRUE;
                case idcClear:
                    pRL->Clear();
                    SetDlgItemText(hwnd, idcPrint, NULL);
                    SetDlgItemInt(hwnd, idcResult, TRUE, FALSE);
                    return TRUE;
                }
            }
            break;
        }
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\basedisp.cpp ===
/*
 *    b a s e d i s p . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "privunk.h"
#include "basedisp.h"
#include "dllmain.h"

CBaseDisp::CBaseDisp(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_pTypeInfo = NULL; 
    m_pUnkInvoke = NULL;
}      

CBaseDisp::~CBaseDisp()
{
    ReleaseObj(m_pTypeInfo);
}

HRESULT CBaseDisp::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
    else
        if (IsEqualIID(riid, IID_ISupportErrorInfo))
            *lplpObj = (LPVOID)(ISupportErrorInfo *)this;
        else
            return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseDisp::InterfaceSupportsErrorInfo(REFIID riid)
{
    return S_FALSE;
}


    // *** IDispatch ***
HRESULT CBaseDisp::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

HRESULT CBaseDisp::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    if (itinfo)
        return DISP_E_BADINDEX;

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;
    return S_OK;
}

HRESULT CBaseDisp::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

HRESULT CBaseDisp::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispInvoke(m_pUnkInvoke, m_pTypeInfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

HRESULT CBaseDisp::EnsureTypeLibrary(LPVOID *pUnkInvoke, REFIID riid)
{
    TCHAR               szDll[MAX_PATH];
    LPWSTR              pszW;
    HRESULT             hr = E_FAIL;

    // BUGBUG: this is weird. I want to defer the type library loading inside OE 
    // until the first MOM object is created. Every MOM object deriving from
    // CBaseDisp must call CBaseDisp::EnsureTypeLibrary. This check to see if the 
    // global ITypeLib object has been created (protected with a CS)

    AssertSz(pUnkInvoke, "You need to pass me a this pointer to callback on");

    EnterCriticalSection(&g_csOETypeLib);

    if (!g_pOETypeLib)
        {
        GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));
        pszW = PszToUnicode(GetACP(), szDll);
        if (pszW)
            {
            LoadTypeLib(pszW, &g_pOETypeLib);
            MemFree(pszW);
            }
        }
    
    if (g_pOETypeLib &&
        g_pOETypeLib->GetTypeInfoOfGuid(riid, &m_pTypeInfo)==S_OK)
        {
        m_pUnkInvoke = pUnkInvoke;
        hr = S_OK;
        }

    LeaveCriticalSection(&g_csOETypeLib);

    return hr;
}



HRESULT CBaseDisp::ReportError(REFCLSID rclsid, LONG ids)
{
    ICreateErrorInfo    *pICEI;
    IErrorInfo          *pErrInfo;
    TCHAR               rgch[CCHMAX_STRINGRES];
    LPWSTR              pszW;

    if (CreateErrorInfo(&pICEI)==S_OK)
        {
        pICEI->SetGUID(rclsid);
        pICEI->SetSource(L"OE Mail Object Model");
        
        if (LoadString(g_hLocRes, ids, rgch, ARRAYSIZE(rgch)))
            {
            pszW = PszToUnicode(GetACP(), rgch);
            if (pszW)
                {
                pICEI->SetDescription(pszW);
                MemFree(pszW);     // CoTaskMemFree
                }
            }
        if (pICEI->QueryInterface(IID_IErrorInfo, (LPVOID *)&pErrInfo)==S_OK)
            {
            SetErrorInfo(0, pErrInfo);
            pErrInfo->Release();
            }
        pICEI->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\pickgrp.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     PickGrp.cpp
//
//  PURPOSE:    Dialog to allow the user to select groups to post to in the
//              send note window.
//

#include "pch.hxx"
#include <iert.h>
#include "pickgrp.h"
#include "grplist2.h"
#include "shlwapip.h" 
#include "resource.h"
#include "strconst.h"
#include "demand.h"

CPickGroupDlg::CPickGroupDlg()
{
    m_cRef = 1;
    m_ppszGroups = 0;
    m_hwndPostTo = 0;
    m_fPoster = FALSE;
    m_hIcon = NULL;
    m_pGrpList = NULL;
    m_pszAcct = NULL;
    m_idAcct = FOLDERID_INVALID;
}

CPickGroupDlg::~CPickGroupDlg()
{
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));
    if (m_pGrpList != NULL)
        m_pGrpList->Release();
}    

HRESULT STDMETHODCALLTYPE CPickGroupDlg::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IGroupListAdvise *)this;
    else if (IsEqualIID(riid, IID_IGroupListAdvise))
        *ppvObj = (void*) (IGroupListAdvise *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CPickGroupDlg::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CPickGroupDlg::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//  FUNCTION:   CPickGroupsDlg::FCreate()
//
//  PURPOSE:    Handles initialization of the data and creation of the pick
//              groups dialog.
//
//  PARAMETERS:
//      hwndOwner         - Window that will own this dialog.
//      pszAccount        - account to use initially.
//      ppszGroups        - This is where we return the last selected group
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//
BOOL CPickGroupDlg::FCreate(HWND hwndOwner, FOLDERID idServer, LPSTR *ppszGroups, BOOL fPoster)
{
    int iret;
    HRESULT hr;
    FOLDERID idAcct;
    FOLDERINFO info;
    char szAcct[CCHMAX_ACCOUNT_NAME];

    Assert(ppszGroups != NULL);
     
    m_pGrpList = new CGroupList;
    if (m_pGrpList == NULL)
        return(FALSE);
    
    m_ppszGroups = ppszGroups;
    m_fPoster = fPoster;
    
    hr = g_pStore->GetFolderInfo(idServer, &info);
    if (FAILED(hr))
        return(FALSE);

    StrCpyN(szAcct, info.pszName, ARRAYSIZE(szAcct));

    g_pStore->FreeRecord(&info);

    m_pszAcct = szAcct;
    m_idAcct = idServer;

    // Now create the dialog.
    iret = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPickGroup), hwndOwner, PickGrpDlgProc, (LPARAM)this);

    return(iret == IDOK);
}
    
INT_PTR CALLBACK CPickGroupDlg::PickGrpDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet;
    CPickGroupDlg *pThis;

    fRet = TRUE;

    pThis = (CPickGroupDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            Assert(pThis == NULL);
            Assert(lParam != NULL);
            pThis = (CPickGroupDlg *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pThis);

            fRet = pThis->_OnInitDialog(hwnd);
            break;

        case WM_CLOSE:
            pThis->_OnClose(hwnd);
            break;

        case WM_COMMAND:
            pThis->_OnCommand(hwnd, LOWORD(wParam), (HWND)lParam, HIWORD(wParam));
            break;

        case WM_NOTIFY:
            pThis->_OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_TIMER:
            pThis->_OnTimer(hwnd, (UINT)wParam);
            break;

        case WM_PAINT:
            pThis->_OnPaint(hwnd);
            break;

        case NVM_CHANGESERVERS:
            pThis->_OnChangeServers(hwnd);
            break;

        default:
            fRet = FALSE;
            break;
    }

    return(fRet);
}

//
//  FUNCTION:   CPickGroupDlg::OnInitDialog()
//
//  PURPOSE:    Handles initializing the PickGroup dialog.  Initializes the
//              dependant classes, list view, buttons, etc.
//
//  PARAMETERS:
//      hwnd      - Handle of the dialog box.
//      hwndFocus - Handle of the control that will get focus if TRUE is returned.
//      lParam    - Contains a pointer to a string of newsgroups the user has
//                  already selected.
//
//  RETURN VALUE:
//      Returns TRUE to set the focus to hwndFocus, or FALSE otherwise.
//
BOOL CPickGroupDlg::_OnInitDialog(HWND hwnd)
{
    char szTitle[256];
    LV_COLUMN lvc;
    RECT rc;
    LONG cx;
    HDC hdc;
    TEXTMETRIC tm;
    HIMAGELIST himl;
    HRESULT hr;
    HWND hwndList;
    CColumns *pColumns;
    
    m_hwnd = hwnd;
    m_hwndPostTo = GetDlgItem(hwnd, idcPostTo);
    
    hwndList = GetDlgItem(hwnd, idcGroupList);

    pColumns = new CColumns;
    if (pColumns == NULL)
    {
        EndDialog(hwnd, IDCANCEL);
        return(FALSE);
    }

    pColumns->Initialize(hwndList, COLUMN_SET_PICKGRP);
    pColumns->ApplyColumns(COLUMN_LOAD_DEFAULT, 0, 0);

    Assert(m_pGrpList != NULL);
    hr = m_pGrpList->Initialize((IGroupListAdvise *)this, pColumns, hwndList, FOLDER_NEWS);
    Assert(SUCCEEDED(hr));

    pColumns->Release();

    // Bug #21471 - Add the server name to the dialog box title    
    GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle));
    Assert(m_pszAcct);
    StrCatBuff(szTitle, m_pszAcct, ARRAYSIZE(szTitle));
    SetWindowText(hwnd, szTitle);
    
    GetClientRect(m_hwndPostTo, &rc);
    
    // Set the image lists for the listview
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
    Assert(himl);
    
    // Group name column
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.cx = rc.right;
    lvc.iSubItem = 0;
    
    ListView_InsertColumn(m_hwndPostTo, 0, &lvc);
    
    // Make the second listview have images too
    ListView_SetImageList(m_hwndPostTo, himl, LVSIL_SMALL);
    
    hdc = GetDC(hwndList);
    if (GetTextMetrics(hdc, &tm))
    {
        cx = tm.tmAveCharWidth * 150;
        ListView_SetColumnWidth(hwndList, 0, cx);
        ListView_SetColumnWidth(m_hwndPostTo, 0, cx);
    }
    ReleaseDC(hwndList, hdc);

    SendDlgItemMessage(hwnd, idcShowFavorites, BM_SETCHECK, TRUE, 0L);    
    
    if (!m_fPoster)    
        ShowWindow(GetDlgItem(hwnd, idcEmailAuthor), SW_HIDE);
    
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiNewsGroup), IMAGE_ICON, 16, 16, 0);
    SendDlgItemMessage(hwnd, idcShowFavorites, BM_SETIMAGE, IMAGE_ICON, (LPARAM)m_hIcon); 
    
    PostMessage(hwnd, NVM_CHANGESERVERS, 0, 0L);
    
    return(FALSE);    
}

BOOL CPickGroupDlg::_OnFilter(HWND hwnd)
{
    UINT cch;
    LPSTR pszText;
    HRESULT hr;
    BOOL fSub;
    HWND hwndEdit;

    pszText = NULL;

    hwndEdit = GetDlgItem(hwnd, idcFindText);

    cch = GetWindowTextLength(hwndEdit);
    if (cch > 0)
    {
        cch++;
        if (!MemAlloc((void **)&pszText, cch + 1))
            return(FALSE);

        GetWindowText(hwndEdit, pszText, cch);
    }

    fSub = (IsDlgButtonChecked(hwnd, idcShowFavorites));

    hr = m_pGrpList->Filter(pszText, fSub ? SUB_TAB_SUBSCRIBED : SUB_TAB_ALL, FALSE);
    Assert(SUCCEEDED(hr));

    if (pszText != NULL)
        MemFree(pszText);

    return(TRUE);    
}

void CPickGroupDlg::_OnChangeServers(HWND hwnd)
{
    LPSTR pszTok, pszToken;
    UINT index;
    HRESULT hr;
    FOLDERINFO Folder;

    // TODO: we need to fix the initialization so the filtering is only performed
    // once (we should call IGroupList::Filter once and then IGroupList::SetServer once
    // during creation of the dialog)

    UpdateWindow(hwnd);

    _OnFilter(hwnd);

    hr = m_pGrpList->SetServer(m_idAcct);
    Assert(SUCCEEDED(hr));

    if (m_ppszGroups)
    {
        pszTok = *m_ppszGroups;
        pszToken = StrTokEx(&pszTok, c_szDelimiters);

        while (pszToken != NULL)
            {
            if (m_fPoster && 0 == lstrcmpi(pszToken, c_szPosterKeyword))
                CheckDlgButton(hwnd, idcEmailAuthor, TRUE);
                
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.idParent = m_idAcct;
            Folder.pszName = pszToken;
            
            if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                _InsertList(Folder.idFolder);

                g_pStore->FreeRecord(&Folder);
            }

            pszToken = StrTokEx(&pszTok, c_szDelimiters);    
            }
        
        MemFree(*m_ppszGroups);
        *m_ppszGroups = 0;    
    }

    // Bug #17674 - Make sure the post-to listview has an initial selection.    
    ListView_SetItemState(m_hwndPostTo, 0, LVIS_SELECTED, LVIS_SELECTED);
    _UpdateStateUI(hwnd);    
}

//
//  FUNCTION:   CPickGroupDlg::OnCommand()
//
//  PURPOSE:    Processes the WM_COMMAND messages for the pick group dialog.
//
//  PARAMETERS:
//      hwnd        - Handle of the dialog window.
//      id          - ID of the control which sent the message.
//      hwndCtl     - Handle of the control sending the message.
//      codeNotify  - Notification code being sent.
//
void CPickGroupDlg::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case idcAddGroup:
            _AddGroup();
            break;
            
        case idcRemoveGroup:
            _RemoveGroup();
            break;
            
        case IDOK:
            if (_OnOK(hwnd))
                EndDialog(hwnd, IDOK);
            break;
            
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;

        case idcShowFavorites:
            _OnFilter(hwnd);
            _UpdateStateUI(hwnd);
            break;

        case idcFindText:
            // This is generated when someone types in the find text edit box.
            // We set a timer and when that timer expires we assume the user is
            // done typing and go ahead and perform the query.
            if (EN_CHANGE == codeNotify)
                {
                KillTimer(hwnd, idtFindDelay);
                SetTimer(hwnd, idtFindDelay, dtFindDelay, NULL);
                }
            break;
    }
}

HRESULT CPickGroupDlg::ItemUpdate(void)
    {
    _UpdateStateUI(m_hwnd);

    return(S_OK);
    }

HRESULT CPickGroupDlg::ItemActivate(FOLDERID id)
{
    _AddGroup();

    return(S_OK);
}

//
//  FUNCTION:   CPickGroupDlg::OnNotify()
//
//  PURPOSE:    Handles notification messages from the group list listview.
//
//  PARAMETERS:
//      hwnd   - Handle of the pick group dialog.
//      idFrom - ID of the control sending the notification.
//      pnmhdr - Pointer to the NMHDR struct with the notification info.
//
//  RETURN VALUE:
//      Dependent on the notification.
//
LRESULT CPickGroupDlg::_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    HRESULT hr;
    LRESULT lRes;

    hr = m_pGrpList->HandleNotify(hwnd, idFrom, pnmhdr, &lRes);
    if (hr == S_OK)
        return(lRes);

    switch (pnmhdr->code)
    {
        case NM_DBLCLK:
            if (pnmhdr->hwndFrom == m_hwndPostTo)
                _RemoveGroup();    
            break;    
            
        case LVN_ITEMCHANGED:
            _UpdateStateUI(hwnd);
            break;
    }

    return(0);    
}

void CPickGroupDlg::_OnTimer(HWND hwnd, UINT id)
    {
    KillTimer(hwnd, id);

    _OnFilter(hwnd);
    _UpdateStateUI(hwnd);
    }

void CPickGroupDlg::_OnClose(HWND hwnd)
{
    int iReturn;
    
    iReturn = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews), 
                MAKEINTRESOURCEW(idsDoYouWantToSave), 0, 
                MB_YESNOCANCEL | MB_ICONEXCLAMATION );
    if (iReturn == IDYES)
        _OnCommand(hwnd, IDOK, 0, 0);
    else if (iReturn == IDNO)
        _OnCommand(hwnd, IDCANCEL, 0, 0);   
}

//
//  FUNCTION:   CPickGroupDlg::OnOK()
//
//  PURPOSE:    This function copies the group names from the dialog that
//              the user has selected and returns them in the pointer the
//              caller provided.
//
//  RETURN VALUE:
//      Returns TRUE if the copy was successful, or FALSE otherwise.
//
//  COMMENTS:
//      Note - 1000 characters is a good maximum line length (specified by the 
//             Son-of-RFC 1036 doc) so we limit the number of groups based on
//             this line limit.
//
//
BOOL CPickGroupDlg::_OnOK(HWND hwnd)
{
    // OK, we've got the entire sorted list.  Create a string with all the groups
    // and put it in the edit control.
    char szGroups[c_cchLineMax], szGroup[256];
    int cGroups;
    LPSTR psz;
    LV_ITEM lvi;
    int cchGroups = 0, cch;
    
    szGroups[0] = 0;
    
    if (m_fPoster && IsDlgButtonChecked(hwnd, idcEmailAuthor))
    {
        StrCatBuff(szGroups, c_szPosterKeyword, ARRAYSIZE(szGroups));
        cchGroups += lstrlen(c_szPosterKeyword);
    }
    
    if (cGroups = ListView_GetItemCount(m_hwndPostTo))
    {
        lvi.mask = LVIF_TEXT;
        lvi.iSubItem = 0;
        lvi.pszText = szGroup;
        lvi.cchTextMax = ARRAYSIZE(szGroup);
        for (lvi.iItem = 0; lvi.iItem < cGroups; lvi.iItem++)
        {
            // Get the item
            ListView_GetItem(m_hwndPostTo, &lvi);
            
            // Make sure the length of this next group doesn't push us over
            // the max line length.
            cch = lstrlen(lvi.pszText);
            if ((cch + cchGroups + 2) > c_cchLineMax)
            {
                // Bug #24156 - If we have to truncate, then let the user know.
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews), 
                    MAKEINTRESOURCEW(idsErrNewsgroupLineTooLong), 0, MB_OK | MB_ICONINFORMATION);
                return (FALSE);
            }                
            
            if (cchGroups)
            {
                StrCatBuff(szGroups, ", ", ARRAYSIZE(szGroups));
            }
            StrCatBuff(szGroups, lvi.pszText, ARRAYSIZE(szGroups));
            cchGroups += (cch + 2);
        }
    }
    
    // Now that we're done building this marvelous string, copy it to
    // the buffer for returning.
    if (!MemAlloc((LPVOID *)&psz, cchGroups + 1))
        return(FALSE);
    StrCpyN(psz, szGroups, cchGroups + 1);
    *m_ppszGroups = psz;
    
    return(TRUE);
}

//
//  FUNCTION:   CPickGroupDlg::AddGroup()
//
//  PURPOSE:    Takes the group names selected in the ListView and adds them
//              to the selected groups Post To list.
//
void CPickGroupDlg::_AddGroup(void)
{
    FOLDERID *pid;
    DWORD cid, i;
    HCURSOR hcur;
    HRESULT hr;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    SetWindowRedraw(m_hwndPostTo, FALSE);
    
    hr = m_pGrpList->GetSelectedCount(&cid);
    if (SUCCEEDED(hr) && cid > 0)
    {
        if (MemAlloc((void **)&pid, cid * sizeof(FOLDERID)))
        {
            hr = m_pGrpList->GetSelected(pid, &cid);
            if (SUCCEEDED(hr))
            {
                for (i = 0; i < cid; i++)
                {
                    _InsertList(pid[i]);
                }
            }

            MemFree(pid);
        }
    }

    if (-1 == ListView_GetNextItem(m_hwndPostTo, -1, LVNI_ALL | LVNI_SELECTED))
        ListView_SetItemState(m_hwndPostTo, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    
    SetWindowRedraw(m_hwndPostTo, TRUE);
    InvalidateRect(m_hwndPostTo, NULL, TRUE);

    SetCursor(hcur);    
}

//
//  FUNCTION:   CPickGroupDlg::InsertList()
//
//  PURPOSE:    Given a index into the CGroupList's newsgroup list, that group
//              is inserted into the Post To list.
//
//  PARAMETERS:
//      index - Index of a newsgroup in the CGroupList newsgroup list.
//
void CPickGroupDlg::_InsertList(FOLDERID id)
{
    LV_ITEM lvi;
    int count;
    FOLDERINFO info;
    HRESULT hr;

    count = ListView_GetItemCount(m_hwndPostTo);
    
    // First make sure this isn't a duplicate.
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    
    for (lvi.iItem = 0; lvi.iItem < count; lvi.iItem++)
    {
        ListView_GetItem(m_hwndPostTo, &lvi);
        if (id == (FOLDERID)lvi.lParam)
            return;
    }
    
    hr = g_pStore->GetFolderInfo(id, &info);
    if (SUCCEEDED(hr))
    {
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.pszText = info.pszName;
        if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
        {
            lvi.iImage = iNewsGroup;
            lvi.mask |= LVIF_IMAGE;
        }
        lvi.lParam = (LPARAM)id;
        ListView_InsertItem(m_hwndPostTo, &lvi);

        g_pStore->FreeRecord(&info);
    }
}    

void CPickGroupDlg::_RemoveGroup(void)
{
    int index, count, iItemFocus;
    HCURSOR hcur;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    SetWindowRedraw(m_hwndPostTo, FALSE);
    
    count = ListView_GetItemCount(m_hwndPostTo);
    iItemFocus = ListView_GetNextItem(m_hwndPostTo, -1, LVNI_FOCUSED);

    // Loop through all the selected items and remove them from the ListView
    for (index = count; index >= 0; index--)
    {
        if (ListView_GetItemState(m_hwndPostTo, index, LVIS_SELECTED))
            ListView_DeleteItem(m_hwndPostTo, index);
    }
    
    // Bug #22189 - Make sure the focus/selection goes somewhere after we delete.
    iItemFocus--;
    if (iItemFocus < 0 || ListView_GetItemCount(m_hwndPostTo) < iItemFocus)
        iItemFocus = 0;
    ListView_SetItemState(m_hwndPostTo, iItemFocus, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    SetWindowRedraw(m_hwndPostTo, TRUE);
    InvalidateRect(m_hwndPostTo, NULL, TRUE);
    SetCursor(hcur);    
}

void CPickGroupDlg::_UpdateStateUI(HWND hwnd)
{
    DWORD cid;
    HRESULT hr;

    hr = m_pGrpList->GetSelectedCount(&cid);
    if (FAILED(hr))
        return;

    EnableWindow(GetDlgItem(hwnd, idcAddGroup), cid > 0);
    EnableWindow(GetDlgItem(hwnd, idcRemoveGroup), ListView_GetSelectedCount(m_hwndPostTo));
}

void CPickGroupDlg::_OnPaint(HWND hwnd)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    HFONT hf;
    char szBuffer[CCHMAX_STRINGRES];

    hdc = BeginPaint(hwnd, &ps); 
    // Only do this if the button is available
    if (IsWindow(GetDlgItem(hwnd, idcShowFavorites)))    
    {
        // Get the position of the toggle button
        GetClientRect(GetDlgItem(hwnd, idcShowFavorites), &rc);
        MapWindowPoints(GetDlgItem(hwnd, idcShowFavorites), hwnd, (LPPOINT) &rc, 1);
        rc.left += (rc.right + 4);
        rc.right = rc.left + 300;
        rc.top += 1;
        rc.bottom += rc.top;
        AthLoadString(idsShowFavorites, szBuffer, ARRAYSIZE(szBuffer));
        
        hf = (HFONT) SelectObject(hdc, (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        DrawText(hdc, szBuffer, lstrlen(szBuffer),
                 &rc, DT_SINGLELINE | DT_VCENTER | DT_NOCLIP);        
        SelectObject(hdc, hf);     
    }

    EndPaint(hwnd, &ps);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\pickgrp.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     PickGrp.h
//
//  PURPOSE:    Contains id's and prototypes for the pick group dialog.
//

#ifndef __PICKGRP_H__
#define __PICKGRP_H__

#include <grplist2.h>

#define c_cchLineMax    1000
#define idtFindDelay    1
#define dtFindDelay     600

class CPickGroupDlg : public IGroupListAdvise
    {
public:    
    /////////////////////////////////////////////////////////////////////////
    // Initialization
    
    CPickGroupDlg();
    ~CPickGroupDlg();
    
    // IUnknown 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IGroupListAdvise
    HRESULT STDMETHODCALLTYPE ItemUpdate(void);
    HRESULT STDMETHODCALLTYPE ItemActivate(FOLDERID id);

    BOOL FCreate(HWND hwndOwner, FOLDERID idServer, LPSTR *ppszGroups, BOOL fPoster);

    static INT_PTR CALLBACK PickGrpDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


private:
    /////////////////////////////////////////////////////////////////////////
    // Message Handlers

    BOOL _OnInitDialog(HWND hwnd);
    BOOL _OnFilter(HWND hwnd);
    void _OnChangeServers(HWND hwnd);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT _OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void _OnClose(HWND hwnd);
    void _OnPaint(HWND hwnd);
    void _OnTimer(HWND hwnd, UINT id);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions

    void _UpdateStateUI(HWND hwnd);
    BOOL _OnOK(HWND hwnd);
    void _AddGroup(void);
    void _InsertList(FOLDERID id);
    void _RemoveGroup(void);
    
    /////////////////////////////////////////////////////////////////////////
    // Class Data
    ULONG           m_cRef;
    LPSTR          *m_ppszGroups;
    HWND            m_hwnd;
    HWND            m_hwndPostTo;
    BOOL            m_fPoster;
    HICON           m_hIcon;
    CGroupList     *m_pGrpList;
    LPCSTR          m_pszAcct;
    FOLDERID        m_idAcct;
    };

/////////////////////////////////////////////////////////////////////////////
// Dialog Control ID's
// 
#define idcAddGroup                                 1004
#define idcSelectedGroups                           1005
#define idcRemoveGroup                              1006
#define idcPostTo                                   1007
#define idcEmailAuthor                              1008
#define idcGroupList                                2001            // Group list listview
#define idcFindText                                 2002            // Find query edit box
#define idcShowFavorites                            2003            // Filter favorites toggle

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\basedisp.h ===
// --------------------------------------------------------------------------------
// basedisp.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __BASEDISP_H
#define __BASEDISP_H

#include "privunk.h"
//class CPrivateUnknown;

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CBaseDisp : 
    public IDispatch,
    public ISupportErrorInfo,
    public CPrivateUnknown
{
protected:
    LPTYPEINFO       m_pTypeInfo;
    LPVOID          *m_pUnkInvoke;

public:

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CBaseDisp(IUnknown *pUnkOuter=NULL);
    virtual ~CBaseDisp();

    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CPrivateUnknown::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // *** ISupportErrorInfo ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);


    virtual HRESULT EnsureTypeLibrary(LPVOID *pUnkInvoke, REFIID riid);

protected:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID *lplpObj);

    virtual HRESULT ReportError(REFCLSID rclsid, LONG ids);

};

#endif // __BASEDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\range.h ===
//
// RANGE.H
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
// 8-96:    Functions added to facilitate finding of "anti" lists 
//

// -*- C -*-
//--------------------------------------------------------------------------------------
//
// Module:       range.h
//
// Description:  Definition of a class to manipulate range lists
//               (e.g. 1-6,7,10-11,19,24,33-40 ...)
//
// Copyright Microsoft Corporation 1995, All Rights Reserved
//
//--------------------------------------------------------------------------------------

#ifndef _RANGE_H
#define _RANGE_H
//
//  Copyright 1992 Software Innovations, Inc
//      All Rights Reserved
//
//  $Source: D:\CLASS\INCLUDE\range.h-v $
//  $Author: martin $
//  $Date: 92/07/15 04:56:38 $
//  $Revision: 1.1 $
//

#define RANGE_ERROR ((ULONG)-1)
#define rlLAST_MESSAGE ((ULONG)-2)

//  a CRangeList is a dynamic array of these...
typedef struct {
    ULONG low;
    ULONG high;
} RangeType;

class CRangeList
{
public:
    CRangeList();
    //CRangeList(CRangeList&);
    ~CRangeList();

    ULONG AddRef(void);
    ULONG Release(void);

    void Clear() { m_numRanges = 0; };
    BOOL IsInRange(const ULONG value) const;    // is `value' in one of the ranges
                                                // in this CRangeList?

    ULONG Min(void) const;    // return the minimum in-range value
    ULONG Max(void) const;    // return the maximum in-range value

    BOOL Save(LPBYTE *const, ULONG *const) const;
    BOOL Load(const LPBYTE, const ULONG);

    // void AddRange(const char *);
                                     // a string in the form "low-high,..."
                                     //  or just "value,..."
    BOOL AddRange(const ULONG low, const ULONG high);
    BOOL AddRange(const ULONG value);
    BOOL AddRange(const RangeType);
    BOOL AddRange(RangeType*, int);
    BOOL AddRange(CRangeList&);

    // void DeleteRange(const char *);
                                     // (same form as for AddRange(char *)
    BOOL DeleteRange(const ULONG low, const ULONG high);
    BOOL DeleteRange(const ULONG value);
    BOOL DeleteRange(const RangeType);
    BOOL DeleteRange(CRangeList&);

    // finds the range "value" is in and returns the min/max of that
    ULONG MinOfRange(const ULONG value) const;
    ULONG MaxOfRange(const ULONG value) const;

    // computes a range of values not in the RangeList
    BOOL HighestAntiRange(RangeType *const rt) const;
    BOOL LowestAntiRange(RangeType *const rt) const;

    // finds the range containing "value" and computes the next range of missing values
    BOOL NextHigherAntiRange(const ULONG value, RangeType *const rt) const;
    BOOL NextLowerAntiRange(const ULONG value, RangeType *const rt) const;


#ifdef DEBUG    
    LPTSTR RangeToString();   // return a string representing the rangelist
    void   DebugOutput(LPTSTR);
#endif

    // next() returns the smallest in-range value greater than `current', or -1
    ULONG Next(const ULONG current) const;
    // prev() returns the largest in-range value less than `current', or -1
    ULONG Prev(const ULONG current) const;

    ULONG Cardinality(void) const;  // return the cardinality of the set of
                                    //    in-range values

private:
    BOOL Expand();
    int  BinarySearch(const ULONG value) const;
    void ShiftLeft(int low, int distance);
    void ShiftRight(int low, int distance);
    void SubsumeDown(int&);
    void SubsumeUpwards(const int);

protected:
    ULONG      m_cRef;              // Ref count
    int        m_numRanges;         // number of ranges in the rangeTable
    int        m_rangeTableSize;    // range table has room for this many ranges
    RangeType *m_rangeTable;        // the array of ranges
};

#endif // _RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\folders.cpp ===
/*
 *    f o l d e r s . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Folder' object and 'FolderCollection'
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "folders.h"
#include "instance.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COEFolderCollection::COEFolderCollection() : CBaseDisp()
{
    Assert (g_pInstance);
    m_pEnumChildren = 0;
    CoIncrementInit("COEFolderCollection::COEFolderCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COEFolderCollection::~COEFolderCollection()
{
    Assert (g_pInstance);
    CoDecrementInit("COEFolderCollection::COEFolderCollection", NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//              Constructor that can fail
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::Init(FOLDERID idFolder)
{
    m_idFolder = idFolder;
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEFolderCollection *)this, IID_IOEFolderCollection);
}


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//              Exposes supported interfaces
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return CBaseDisp::PrivateQueryInterface(riid, lplpObj);

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     get_folders
//
//  Synopsis:   
//              Returns the a folder collection, representing
//              the child folders of the current folder collection.
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(m_idFolder, p);
}

//+---------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   
//              returns the number of elements in the collection
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get_length(long *p)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pEnumChildren->Count((ULONG *)p);

exit:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     get__newEnum
//
//  Synopsis:   
//              Returns a folder enumerator
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get__newEnum(IUnknown **p)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = E_NOTIMPL;

exit:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::item(VARIANT name, VARIANT index, IDispatch **ppdisp)
{
    HRESULT         hr;
    FOLDERID        idFolder;
    IOEFolder       *pFolder=NULL;

    if (!ppdisp)
        return E_INVALIDARG;

    *ppdisp = NULL;

    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    switch(name.vt)
        {
        case VT_BSTR:
            hr = _FindFolder(name.bstrVal, NULL, &idFolder);
            break;

        case VT_I4:
            hr = _FindFolder(NULL, name.lVal, &idFolder);
            break;
        }

    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = CreateOEFolder(idFolder, &pFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    ReleaseObj(pFolder);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::add(BSTR bstrName, IDispatch **ppDisp)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = E_NOTIMPL;

exit:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     InterfaceSupportsErrorInfo
//
//  Synopsis:   
//              Override CBaseDisp's method to provide error
//              information
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (IsEqualIID(riid, IID_IOEFolderCollection))
        return S_OK;

    return CBaseDisp::InterfaceSupportsErrorInfo(riid);
}


//+---------------------------------------------------------------
//
//  Member:     _EnsureInit
//
//  Synopsis:   
//              Make sure the folder enumerator is up and running
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::_EnsureInit()
{

    if (g_pStore == NULL)
        return E_UNEXPECTED;

    SafeRelease(m_pEnumChildren);

    return g_pStore->EnumChildren(m_idFolder, TRUE, &m_pEnumChildren);
}




//+---------------------------------------------------------------
//
//  Member:     _FindFolder
//
//  Synopsis:   
//              find a folder by name or index
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::_FindFolder(BSTR bstr, LONG lIndex, FOLDERID *pidFolder)
{
    HRESULT         hr=E_FAIL;
    LONG            c=0;
    FOLDERINFO      fi;
    LPSTR           pszFolder=0;


    *pidFolder = NULL;

    if (bstr)
        pszFolder = PszToANSI(CP_ACP, bstr);

    m_pEnumChildren->Reset();

    hr = m_pEnumChildren->Next(1, &fi, NULL);
    while (hr == S_OK)
    {
        // walk immediate children
        if (bstr)
        {
            if (lstrcmpi(fi.pszName, pszFolder)==0)
            {
                *pidFolder = fi.idFolder;
                break;
            }
        }
        else
        {
            if (lIndex == c++)
            {
                *pidFolder = fi.idFolder;
                break;
            }
        }
        hr = m_pEnumChildren->Next(1, &fi, NULL);
    }

    SafeMemFree(pszFolder);
    return *pidFolder ? S_OK : E_FAIL;
}











//+---------------------------------------------------------------
//
//  Member:     CreateFolderCollection
//
//  Synopsis:   
//              helper function to create an OE Folder Collection
//
//---------------------------------------------------------------
HRESULT CreateFolderCollection(FOLDERID idFolder, IOEFolderCollection **ppFolderCollection)
{
    // Locals
    COEFolderCollection  *pNew=NULL;
    HRESULT     hr=S_OK;

    if (ppFolderCollection == NULL)
        return E_INVALIDARG;

    *ppFolderCollection=NULL;

    pNew = new COEFolderCollection();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(idFolder);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IOEFolderCollection, (LPVOID *)ppFolderCollection);

error:
    ReleaseObj(pNew);
    return hr;
}











HRESULT CreateOEFolder(FOLDERID idFolder, IOEFolder **ppFolder)
{
    COEFolder *pNew;
    HRESULT     hr;

    if (!ppFolder)
        return E_INVALIDARG;

    *ppFolder =NULL;

    pNew = new COEFolder();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(idFolder);
    if (FAILED(hr))
        goto error;

    *ppFolder = pNew;
    pNew = NULL;

error:
    ReleaseObj(pNew);
    return hr;
}


COEFolder::COEFolder() : CBaseDisp()
{
    m_idFolder = FOLDERID_INVALID;
    CoIncrementInit("COEFolder::COEFolder", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEFolder::~COEFolder()
{
    CoDecrementInit("COEFolder::COEFolder", NULL);
}

HRESULT COEFolder::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolder))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolder::Init(FOLDERID idFolder)
{
    HRESULT hr;

    m_idFolder = idFolder;

    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEFolder *)this, IID_IOEFolder);

exit:
    return hr;
}

HRESULT COEFolder::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(m_idFolder, p);
}

// *** COEFolder**
HRESULT COEFolder::get_messages(IOEMessageCollection **p)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_name(BSTR *pbstr)
{
    if (pbstr == NULL)
        return E_INVALIDARG;

    *pbstr = NULL;

    return HrLPSZToBSTR(m_fi.pszName, pbstr);
}

HRESULT COEFolder::put_name(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_size(LONG *pl)
{
    *pl = 1000;
    return S_OK;
}

HRESULT COEFolder::get_unread(LONG *pl)
{

    *pl = m_fi.cUnread;
    return S_OK;
}

HRESULT COEFolder::get_id(LONG *pl)
{
    *pl = (LONG)m_fi.idFolder;
    return S_OK;
}

HRESULT COEFolder::get_count(LONG *pl)
{
    *pl = m_fi.cMessages;
    return S_OK;
}


HRESULT COEFolder::_EnsureInit()
{
    return g_pStore->GetFolderInfo(m_idFolder, &m_fi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\message.h ===
/*
 *    m e s s a g e 
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MESSAGE_H
#define _MESSAGE_H

#include "privunk.h"
#include "basedisp.h"

interface IOEMessageCollection;
interface IOEMessage;

typedef struct OEMSGDATA_tag
{
    LPSTR       pszSubj,
                pszTo,
                pszCc,
                pszFrom;
    MESSAGEID   msgid;
    FILETIME    ftReceived;
} OEMSGDATA, *POEMSGDATA;

class COEMessageCollection:
    public IOEMessageCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEMessageCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEMessageCollection();

    HRESULT COEMessageCollection::Init(FOLDERID idFolder);

private:
    ULONG           m_cRef;
    FOLDERID        m_idFolder;
    IMessageTable   *m_pTable;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT _FindMessageByIndex(LONG l, IDispatch** ppdisp);
};



class COEMessage:
    public IOEMessage,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEMessage**
    virtual HRESULT STDMETHODCALLTYPE get_subject(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_subject(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_to(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_to(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_cc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_cc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_sender(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sender(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_text(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_html(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_date(BSTR *pbstr);

    virtual HRESULT STDMETHODCALLTYPE get_url(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE send();

    COEMessage();
    virtual ~COEMessage();

    HRESULT Init(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData);
    HRESULT BindToMessage();

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    OEMSGDATA       *m_pMsgData;
    FOLDERID        m_idFolder;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};

HRESULT CreateOEMessage(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp);

#endif //_MESSAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\folders.h ===
/*
 *    f o l d e r s
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _FOLDERS_H
#define _FOLDERS_H

#include "privunk.h"
#include "basedisp.h"

interface IOEFolderCollection;
interface IOEFolder;

HRESULT CreateInstance_OEFolderCollection(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COEFolderCollection:
    public IOEFolderCollection,
    public CBaseDisp
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CBaseDisp::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CBaseDisp::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CBaseDisp::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection ***
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);
	virtual HRESULT STDMETHODCALLTYPE add(BSTR bstrName, IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);

    // *** Override CBaseDisp ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);

    COEFolderCollection();
    virtual ~COEFolderCollection();

    HRESULT Init(FOLDERID idFolder);

private:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT _EnsureInit();
    HRESULT _FindFolder(BSTR bstr, LONG lIndex, FOLDERID *pidFolder);

    FOLDERID            m_idFolder;
    IEnumerateFolders   *m_pEnumChildren;
};


HRESULT CreateFolderCollection(FOLDERID idFolder, IOEFolderCollection **ppFolderCollection);


class COEFolder:
    public IOEFolder,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolder**
    virtual HRESULT STDMETHODCALLTYPE get_messages(IOEMessageCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_name(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_name(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_size(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_unread(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_count(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_id(LONG *pl);

    COEFolder();
    virtual ~COEFolder();

    HRESULT Init(FOLDERID idFolder);

private:
    ULONG           m_cRef;
    FOLDERID        m_idFolder;
    FOLDERINFO      m_fi;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    HRESULT _EnsureInit();

};


HRESULT CreateOEFolder(FOLDERID idFolder, IOEFolder **ppFolder);

#endif //_FOLDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\session.h ===
/*
 *    s e s s i o n. c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Session' object 
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _SESSION_H
#define _SESSION_H

#include "privunk.h"
#include "basedisp.h"

interface IOESession;
interface IOEFolder;
interface IOEMessage;
interface IOEFolderCollection;

HRESULT CreateInstance_OESession(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COESession:
    public IOESession,
    public CBaseDisp
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CBaseDisp::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CBaseDisp::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CBaseDisp::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOESession ***
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_version(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE get_inbox(IOEFolder **ppFolder);
    virtual HRESULT STDMETHODCALLTYPE openFolder(LONG idFolder, IOEFolder **ppFolder);
    virtual HRESULT STDMETHODCALLTYPE openMessage(LONG idFolder, LONG idMessage, IOEMessage **ppOEMsg);
    virtual HRESULT STDMETHODCALLTYPE createMessage(IOEMessage **ppNewMsg);

    // *** Override CBaseDisp ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);

    COESession(IUnknown *pUnkOuter=NULL);
    virtual ~COESession();

    HRESULT Init();

private:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    IOESession *m_pFolders;
};


#endif //_SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\oedocs.h ===
/*
 *    o e d o c s . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _OEDOCS_H
#define _OEDOCS_H

#include "basedisp.h"
#include "msoeobj.h"
#include "simpdata.h"
#include "dispex.h"
#include "msdatsrc.h"

interface IMimeMessage;
interface IMessageTable;


class COEMessageCollection;
 
typedef struct OEMSGDATA_tag
{
    LPSTR       pszSubj,
                pszTo,
                pszCc,
                pszFrom;
    MESSAGEID   msgid;
    FILETIME    ftReceived;
} OEMSGDATA, *POEMSGDATA;


class COEFolderCollection:
    public IOEFolderCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEFolderCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEFolderCollection();

    HRESULT Init();

private:
    ULONG   m_cRef;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT FindFolderByName(BSTR bstrName, IDispatch** ppdisp);
    HRESULT FindFolderByIndex(LONG l, IDispatch** ppdisp);

};



class COEFolder:
    public IOEFolder,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolder**
    virtual HRESULT STDMETHODCALLTYPE get_messages(IOEMessageCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_name(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_name(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_size(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_unread(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_count(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_id(LONG *pl);

    COEFolder();
    virtual ~COEFolder();

    HRESULT Init(IMessageFolder *pFolder);

private:
    ULONG           m_cRef;
    IMessageFolder *m_pFolder;
    IOEMessageCollection *m_pMessages;
    FOLDERINFO      m_fi;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};


class COEMessageCollection:
    public IOEMessageCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEMessageCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEMessageCollection();

    HRESULT Init(IMessageFolder *pFolder);

private:
    ULONG   m_cRef;
    IMessageFolder *m_pFolder;
    IMessageTable   *m_pTable;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT FindMessageByIndex(LONG l, IDispatch** ppdisp);
};



class COEMessage:
    public IOEMessage,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEMessage**
    virtual HRESULT STDMETHODCALLTYPE get_subject(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_subject(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_to(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_to(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_cc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_cc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_sender(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sender(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_text(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_html(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_date(BSTR *pbstr);

    virtual HRESULT STDMETHODCALLTYPE get_url(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE send();

    COEMessage();
    virtual ~COEMessage();

    HRESULT Init(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData);
    HRESULT BindToMessage();

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    OEMSGDATA       *m_pMsgData;
    IMessageFolder  *m_pFolder;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};



HRESULT CreateInstance_OEMail(IUnknown *pUnkOuter, IUnknown **ppUnknown);

HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown);


class COEMsgTable:
    public OLEDBSimpleProvider,
    public CBaseDisp,
    public IOEMsgList,
    public IDispatchEx
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };
        
    // OLEDBSimpleProvider        
    virtual HRESULT STDMETHODCALLTYPE getRowCount(long *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(long *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(long iRow, long iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar);        
    virtual HRESULT STDMETHODCALLTYPE setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(long iRow, long cRows, long *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(long iRow, long cRows, long *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(long *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer();
        
    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IDispatchEx ***
    virtual HRESULT STDMETHODCALLTYPE GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID(DISPID id);
    virtual HRESULT STDMETHODCALLTYPE GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    virtual HRESULT STDMETHODCALLTYPE GetMemberName(DISPID id, BSTR *pbstrName);
    virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent(IUnknown **ppunk);

    // ** IOEMsgList **
    virtual HRESULT STDMETHODCALLTYPE put_sortColumn(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_sortColumn(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sortDirection(VARIANT_BOOL v);
    virtual HRESULT STDMETHODCALLTYPE get_sortDirection(VARIANT_BOOL *pv);
    virtual HRESULT STDMETHODCALLTYPE test();

    COEMsgTable();
    virtual ~COEMsgTable();

    HRESULT Init();

private:
    ULONG                           m_cRef;
    IMessageTable                   *m_pTable;
    OLEDBSimpleProviderListener     *m_pDSListen;
    DataSourceListener              *m_pDataSrcListener;
    BOOL                            m_fAsc;
    COLUMN_ID                       m_col;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

};

#endif //_OEDOCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\session.cpp ===
/*
 *    s e s s i o n  . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Session' object
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "session.h"
#include "folders.h"
#include "instance.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COESession::COESession(IUnknown *pUnkOuter) : CBaseDisp(pUnkOuter)
{
    Assert (g_pInstance);
    CoIncrementInit("COESession::COESession", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COESession::~COESession()
{
    Assert (g_pInstance);
    CoDecrementInit("COESession::COESession", NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//              Constructor that can fail
//
//---------------------------------------------------------------
HRESULT COESession::Init()
{
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOESession *)this, IID_IOESession);
}


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//              Exposes supported interfaces
//
//---------------------------------------------------------------
HRESULT COESession::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOESession *)this;
    else if (IsEqualIID(riid, IID_IOESession))
        *lplpObj = (LPVOID)(IOESession *)this;
    else
        return CBaseDisp::PrivateQueryInterface(riid, lplpObj);

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     get_folders
//
//  Synopsis:   
//              Returns the rootnode folder collection, representing
//              the top-most part of the OE heirarchy.
//
//---------------------------------------------------------------
HRESULT COESession::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(FOLDERID_ROOT, p);
}

//+---------------------------------------------------------------
//
//  Member:     get_version
//
//  Synopsis:   
//              Returns version information for OE.
//
//---------------------------------------------------------------
HRESULT COESession::get_version(BSTR *pbstr)
{
    // BUGBUG: build from OE string and APPVER
    *pbstr = SysAllocString(L"Outlook Express 6.0");
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     createMessage
//
//  Synopsis:   
//              Creates a new message object not associcated with 
//              any folder, until it is saved or sent
//
//---------------------------------------------------------------
HRESULT COESession::createMessage(IOEMessage **ppNewMsg)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     get_inbox
//
//  Synopsis:   
//              Allows fast access to the default inbox folder
//
//---------------------------------------------------------------
HRESULT COESession::get_inbox(IOEFolder **ppFolder)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     openFolder
//
//  Synopsis:   
//              Quick access to a folder by ID
//
//---------------------------------------------------------------
HRESULT COESession::openFolder(LONG idFolder, IOEFolder **ppFolder)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     openMessage
//
//  Synopsis:   
//              Quick access to a message by ID and folder
//
//---------------------------------------------------------------
HRESULT COESession::openMessage(LONG idFolder, LONG idMessage, IOEMessage **ppOEMsg)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     InterfaceSupportsErrorInfo
//
//  Synopsis:   
//              Override CBaseDisp's method to provide error
//              information
//
//---------------------------------------------------------------
HRESULT COESession::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (IsEqualIID(riid, IID_IOESession))
        return S_OK;

    return CBaseDisp::InterfaceSupportsErrorInfo(riid);
}




//+---------------------------------------------------------------
//
//  Member:     CreateInstance_OESession
//
//  Synopsis:   
//              Class Factory helper for OE Session object
//
//---------------------------------------------------------------
HRESULT CreateInstance_OESession(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COESession  *pNew=NULL;
    HRESULT     hr=S_OK;

    pNew = new COESession(pUnkOuter);
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init();
    if (FAILED(hr))
        goto error;

    *ppUnknown = (IUnknown *)(IOESession *)pNew;
    pNew=NULL;  // don't release

error:
    ReleaseObj(pNew);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\oedocs.cpp ===
/*
 *    o e d o c s . c p p
 *    
 *    Purpose:
 *      sample code for demo of OE object model. Implements a very limited
 *      subset of funcitonality
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include <strconst.h>
#include "demand.h"
#include "dllmain.h"
#include "msoert.h"
#include "msoeobj.h"
#include "oedocs.h"


#include "instance.h"
#include "msgfldr.h"
#include "msgtable.h"
#include "mailutil.h"
#include "oleutil.h"
#include "mshtmdid.h"
#include "shlwapi.h"

static ITypeLib    *g_pTypeLib=NULL;

HRESULT CreateOEFolder(IMessageFolder *pFolder, IDispatch **ppdisp);
HRESULT CreateOEMessage(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp);
HRESULT FindFolder(BSTR bstr, LONG lIndex, IMessageFolder **ppFolder);
void FreeOEMsgData(POEMSGDATA pMsgData);
HRESULT EnsureTypeLib();
LPWSTR StringFromColIndex(DWORD dw);
DWORD ColIndexFromString(LPWSTR pszW);

/*
 *  C O E M a i l
 */

COEMail::COEMail(IUnknown *pUnkOuter)
{
    m_cRef=1;
    m_pFolders = NULL;
    CoIncrementInit("COEMail::COEMail", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMail::~COEMail()
{
    ReleaseObj(m_pFolders);
    CoDecrementInit("COEMail::COEMail", NULL);
}

HRESULT COEMail::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMail *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMail))
        *lplpObj = (LPVOID)(IOEMail *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


// *** IOEMail **
HRESULT COEMail::get_folders(IOEFolderCollection **p)
{
    COEFolderCollection *pNew=NULL;
    HRESULT             hr=S_OK;

    if (!m_pFolders)
        {
        pNew = new COEFolderCollection(NULL);
        if (!pNew)
            return E_OUTOFMEMORY;

        hr = pNew->Init();
        if (FAILED(hr))
            goto error;

        m_pFolders = (IOEFolderCollection *)pNew;
        pNew = NULL;    // don't free
        }

    *p = m_pFolders;
    m_pFolders->AddRef();

error:
    ReleaseObj(pNew);
    return hr;
}

HRESULT COEMail::get_version(BSTR *pbstr)
{
    *pbstr = SysAllocString(L"Outlook Express v5.0");
    return S_OK;
}

HRESULT COEMail::get_newMsg(IDispatch **ppDisp)
{
    COEMessage      *pNew=NULL;
    HRESULT         hr;
    IMimeMessage    *pMsg=NULL;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
        goto error;

    hr = pNew->Init(pMsg, NULL, NULL);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppDisp);

error:
    ReleaseObj(pNew);
    ReleaseObj(pMsg);
    return hr;
}


HRESULT COEMail::Init()
{
    return InitBaseDisp((LPVOID *)(IOEMail *)this, IID_IOEMail, g_pTypeLib);
}

HRESULT EnsureTypeLib()
{
    TCHAR               szDll[MAX_PATH];
    LPWSTR              pszW;

    // BUG BUG BUG: hack to get typelib loaded quickly. NOT THREAD SAFE
    if (!g_pTypeLib)
        {
        GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));
        pszW = PszToUnicode(GetACP(), szDll);
        if (pszW)
            {
            LoadTypeLib(pszW, &g_pTypeLib);
            MemFree(pszW);
            }
        }

    if (!g_pTypeLib)
        return E_FAIL;

    // BUG BUG BUG: hack to get typelib loaded quickly. NOT THREAD SAFE
    return S_OK;
}

HRESULT CreateInstance_OEMail(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMail             *pMail=NULL;
    HRESULT             hr=S_OK;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMail = new COEMail(NULL);
    if (!pMail)
        return E_OUTOFMEMORY;

    hr = EnsureTypeLib();
    if (FAILED(hr))
        goto error;

    hr = pMail->Init();
    if (FAILED(hr))
        goto error;

    *ppUnknown = (IUnknown *)(IOEMail *)pMail;
    pMail->AddRef();

error:
    ReleaseObj(pMail);
    return hr;
}



/*
 *  C O E F o l d e r C o l l e c t i o n
 */
COEFolderCollection::COEFolderCollection(IUnknown *pUnkOuter)
{
    m_cRef=1;
    CoIncrementInit("COEFolderCollection::COEFolderCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEFolderCollection::~COEFolderCollection()
{
    CoDecrementInit("COEFolderCollection::COEFolderCollection", NULL);
}

HRESULT COEFolderCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolderCollection::Init()
{
    return InitBaseDisp((LPVOID *)(IOEFolderCollection *)this, IID_IOEFolderCollection, g_pTypeLib);
}

// *** COEFolderCollection **


HRESULT COEFolderCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEFolderCollection::get_length(long * p)
{
    FOLDERINFO      fi;
    *p = 0;

    Assert(g_pStore);

    if (!FAILED(g_pStore->GetFolderInfo(FOLDERID_LOCAL_STORE, &fi)))
        *p = fi.cChildren;

    return S_OK;
}

HRESULT COEFolderCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEFolderCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    switch(name.vt)
        {
        case VT_BSTR:
            return FindFolderByName(name.bstrVal, ppdisp);
        case VT_I4:
            return FindFolderByIndex(name.lVal, ppdisp);
        }
    return E_NOTIMPL;
}


HRESULT COEFolderCollection::FindFolderByName(BSTR bstrName, IDispatch** ppdisp)
{
    HRESULT         hr=E_FAIL;
    IMessageFolder  *pFolder;

    if (FindFolder(bstrName, NULL, &pFolder)==S_OK)
        {
        hr = CreateOEFolder(pFolder, ppdisp);
        pFolder->Release();
        }
    return hr;
}

HRESULT COEFolderCollection::FindFolderByIndex(LONG lIndex, IDispatch **ppdisp)
{
    HRESULT         hr=E_FAIL;
    IMessageFolder  *pFolder;

    *ppdisp=NULL;

    if (FindFolder(NULL, lIndex, &pFolder)==S_OK)
        {
        hr = CreateOEFolder(pFolder, ppdisp);
        pFolder->Release();
        }
    return hr;
}


/*
 *  C O E F o l d e r
 */

HRESULT CreateOEFolder(IMessageFolder *pFolder, IDispatch **ppdisp)
{
    COEFolder *pNew;
    HRESULT     hr;

    pNew = new COEFolder();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pFolder);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);

error:
    ReleaseObj(pNew);
    return hr;
}


COEFolder::COEFolder()
{
    m_cRef=1;
    m_pFolder = NULL;
    m_pMessages=NULL;
    CoIncrementInit("COEFolder::COEFolder", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEFolder::~COEFolder()
{
    ReleaseObj(m_pFolder);
    ReleaseObj(m_pMessages);
    CoDecrementInit("COEFolder::COEFolder", NULL);
}

HRESULT COEFolder::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolder))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolder::Init(IMessageFolder *pFolder)
{
    FOLDERID    dwFolder;

    ReplaceInterface(m_pFolder, pFolder);

    if (FAILED(pFolder->GetFolderId(&dwFolder)) ||
        FAILED(g_pStore->GetFolderInfo(dwFolder, &m_fi)))
        return E_FAIL;

    return InitBaseDisp((LPVOID *)(IOEFolder *)this, IID_IOEFolder, g_pTypeLib);
}

// *** COEFolder**
HRESULT COEFolder::get_messages(IOEMessageCollection **p)
{
    COEMessageCollection    *pNew=NULL;
    HRESULT                 hr=S_OK;

    *p = NULL;

    if (!m_pMessages)
        {
        pNew = new COEMessageCollection(NULL);
        if (!pNew)
            return E_OUTOFMEMORY;

        hr = pNew->Init(m_pFolder);
        if (FAILED(hr))
            goto error;

        m_pMessages = (IOEMessageCollection *)pNew;
        pNew = NULL;    // don't free
        } 

    *p = m_pMessages;
    m_pMessages->AddRef();

error:
    ReleaseObj(pNew);
    return S_OK;
}

HRESULT COEFolder::get_name(BSTR *pbstr)
{
    *pbstr = NULL;
    return HrLPSZToBSTR(m_fi.szName, pbstr);
}

HRESULT COEFolder::put_name(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_size(LONG *pl)
{
    
    
    *pl = 999;//;m_fi.cbUsed;
    return S_OK;
}

HRESULT COEFolder::get_unread(LONG *pl)
{
    *pl = m_fi.cUnread;
    return S_OK;
}

HRESULT COEFolder::get_id(LONG *pl)
{
    *pl = (LONG)m_fi.idFolder;
    return S_OK;
}

HRESULT COEFolder::get_count(LONG *pl)
{
    *pl = m_fi.cMessages;
    return S_OK;
}

HRESULT FindFolder(BSTR bstr, LONG lIndex, IMessageFolder **ppFolder)
{
    FOLDERID        idFolder=0;
    HRESULT         hr=E_FAIL;
    TCHAR           szFolder[MAX_PATH]; 
    LONG            c=0;
    FOLDERINFO      fi;

    if (bstr)
        WideCharToMultiByte(CP_ACP, 0, (WCHAR*)bstr, -1, szFolder, MAX_PATH, NULL, NULL);

    if (!FAILED(g_pStore->GetFolderInfo(FOLDERID_LOCAL_STORE, &fi)) &&
        !FAILED(g_pStore->GetFolderInfo(fi.idChild, &fi)))
        {
        do
            {
            // walk immediate children
            if (bstr)
                {
                if (lstrcmp(fi.szName, szFolder)==0)
                    {
                    idFolder = fi.idFolder;
                    break;
                    }
                }
            else
                {
                if (lIndex == c++)
                    {
                    idFolder = fi.idFolder;
                    break;
                    }
                }
            }
            while (!FAILED(g_pStore->GetFolderInfo(fi.idSibling, &fi)));
        }

    if (idFolder)
        hr = g_pStore->OpenFolder(idFolder, ppFolder);

    return hr;
}






/*
 *  C O E M e s s a g e C o l l e c t i o n
 */
COEMessageCollection::COEMessageCollection(IUnknown *pUnkOuter)
{
    m_cRef=1;
    m_pFolder=NULL;
    m_pTable=0;
    CoIncrementInit("COEMessageCollection::COEMessageCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMessageCollection::~COEMessageCollection()
{
    ReleaseObj(m_pFolder);
    ReleaseObj(m_pTable);
    CoDecrementInit("COEMessageCollection::COEMessageCollection", NULL);
}

HRESULT COEMessageCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
 
HRESULT COEMessageCollection::Init(IMessageFolder *pFolder)
{
    FOLDERID        idFolder;
    CMessageTable   *pNew=NULL;
    HRESULT         hr;

    if (!pFolder)
        return E_INVALIDARG;

    ReplaceInterface(m_pFolder, pFolder);

    pFolder->GetFolderId(&idFolder);

    pNew = new CMessageTable();
    if (pNew == NULL)
        return E_OUTOFMEMORY;

    hr = pNew->Initialize(idFolder, FALSE);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    hr = InitBaseDisp((LPVOID *)(IOEMessageCollection *)this, IID_IOEMessageCollection, g_pTypeLib);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}

// *** COEMessageCollection **


HRESULT COEMessageCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::get_length(long * pl)
{
    *pl = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pl);

    return S_OK;
}

HRESULT COEMessageCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    if (name.vt == VT_I4)
        return FindMessageByIndex(name.lVal, ppdisp);

    return E_NOTIMPL;
}


HRESULT COEMessageCollection::FindMessageByIndex(LONG l, IDispatch** ppdisp)
{
    HRESULT         hr = E_FAIL;
    MESSAGEINFO     msginfo;
    POEMSGDATA      pMsgData;

    if (m_pTable->GetRow(l, &msginfo)==S_OK)
        {
        if (!MemAlloc((LPVOID *)&pMsgData, sizeof(OEMSGDATA)))
            return E_OUTOFMEMORY;
   
        pMsgData->pszSubj = PszDup(msginfo.pszSubject);
        pMsgData->pszTo = PszDup(msginfo.pszDisplayTo);
        pMsgData->pszCc = PszDup("<not available>");
        pMsgData->pszFrom = PszDup(msginfo.pszDisplayFrom);
        pMsgData->ftReceived = msginfo.ftReceived;
        pMsgData->msgid = msginfo.idMessage;

        //m_pFolder->OpenMessage(msginfo.dwMsgId, FALSE, NULL, &pMsg)==S_OK)

        // OEMessage frees the data object
        hr = CreateOEMessage(NULL, m_pFolder, pMsgData, ppdisp);
        if (FAILED(hr))
            FreeOEMsgData(pMsgData);
        
        }
    return hr;
}

void FreeOEMsgData(POEMSGDATA pMsgData)
{
    if (pMsgData)
        {
        MemFree(pMsgData->pszSubj);
        MemFree(pMsgData->pszTo);
        MemFree(pMsgData->pszCc);
        MemFree(pMsgData->pszFrom);
        MemFree(pMsgData);
        }
}

/*
 *  C O E M e s s a g e
 */

HRESULT CreateOEMessage(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp)
{
    COEMessage *pNew;
    HRESULT     hr;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pMsg, pFolder, pMsgData);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}


COEMessage::COEMessage()
{
    m_cRef=1;
    m_pMsg = NULL;
    m_pMsgData = NULL;
    m_pFolder = NULL;
    CoIncrementInit("COEMessage::COEMessage", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMessage::~COEMessage()
{
    FreeOEMsgData(m_pMsgData);
    ReleaseObj(m_pMsg);
    ReleaseObj(m_pFolder);
    CoDecrementInit("COEMessage::COEMessage", NULL);
}

HRESULT COEMessage::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessage))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEMessage::Init(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData)
{
    ReplaceInterface(m_pFolder, pFolder);
    ReplaceInterface(m_pMsg, pMsg);
    m_pMsgData = pMsgData;

    return InitBaseDisp((LPVOID *)(IOEMessage *)this, IID_IOEMessage, g_pTypeLib);
}

// *** COEMessage **


HRESULT COEMessage::get_subject(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszSubj, pbstr);
        return S_OK;
        }

    if (MimeOleGetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        return S_OK;
        }
    return E_FAIL;
}

HRESULT COEMessage::put_subject(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_to(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszTo, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_to(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();
    
    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_cc(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszCc, pbstr);
        return S_OK;
        }

    *pbstr = NULL;
    if (m_pMsg->GetAddressFormat(IAT_CC, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_cc(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CC), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_sender(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszFrom, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_sender(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_text(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_text(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_html(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_html(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_HTML, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_url(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    // BUGBUGBUG: this is a terrible hack also. We can't get a persistent URL moniker to 
    // the MHTML document (not yet investigated), so for the purpose of this demo-code
    // we'll use a tmp file
    if (m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
        WriteStreamToFile(pstm, "c:\\oe_temp$.eml", CREATE_ALWAYS, GENERIC_WRITE);
        pstm->Release();
        }

    *pbstr = SysAllocString(L"c:\\oe_temp$.eml");
    return S_OK;
}

HRESULT COEMessage::get_date(BSTR *pbstr)
{
    PROPVARIANT     pv;
    TCHAR           rgch[MAX_PATH];
    FILETIME        *pft=0;

    *pbstr = NULL;

    if (!m_pMsg)
        {
        pft = &m_pMsgData->ftReceived;
        }
    else
        {
        // Get Receive Time
        pv.vt = VT_FILETIME;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &pv)))
            pft = &pv.filetime;
        }

    if (pft)
        {
        *rgch=0;
        CchFileTimeToDateTimeSz(pft, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
        HrLPSZToBSTR(rgch, pbstr);
        }
    return S_OK;
}



HRESULT COEMessage::send()
{
    TCHAR   sz[MAX_PATH];

    // use default account to send
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, sz, ARRAYSIZE(sz))))
        {
        PROPVARIANT rUserData;
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = sz;
        m_pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNT), NOFLAGS, &rUserData);
        }

    HrSendMailToOutBox(g_hwndInit, m_pMsg, TRUE, TRUE);
    return S_OK;
}



HRESULT COEMessage::BindToMessage()
{
    if (m_pMsg)
        return S_OK; 

    Assert (m_pFolder && m_pMsgData);
    return m_pFolder->OpenMessage(m_pMsgData->msgid, NULL, &m_pMsg, NULL);
}






COEMsgTable::COEMsgTable()
{
    m_cRef=1;
    m_pTable=0;
    m_pDSListen=0;
    m_fAsc=TRUE;
    m_col=COLUMN_RECEIVED;
    m_pDataSrcListener=0;
    CoIncrementInit("COEMsgTable::COEMsgTable", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMsgTable::~COEMsgTable()
{
    ReleaseObj(m_pTable);
    ReleaseObj(m_pDSListen);
    ReleaseObj(m_pDataSrcListener);
    CoDecrementInit("COEMsgTable::COEMsgTable", NULL);
}

HRESULT COEMsgTable::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IDispatchEx))
        *lplpObj = (LPVOID)(IDispatchEx *)this;
    else if (IsEqualIID(riid, IID_IOEMsgList))
        *lplpObj = (LPVOID)(IOEMsgList *)this;
    else
        {
        DbgPrintInterface(riid, "COEMsgTable::", 1024);
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

HRESULT COEMsgTable::Init()
{
    FOLDERINFO    fi;
    HRESULT         hr;

    g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fi);

//    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    hr = m_pTable->Initialize(fi.idFolder, FALSE);
    if (FAILED(hr))
        goto error;

    hr = EnsureTypeLib();
    if (FAILED(hr))
        goto error;

    hr = InitBaseDisp((LPVOID *)(IOEMsgList *)this, IID_IOEMsgList, g_pTypeLib);

error:
    return hr;
}


HRESULT COEMsgTable::getRowCount(long *pcRows)
{
    *pcRows = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pcRows);

        
    return S_OK;
}

HRESULT COEMsgTable::getColumnCount(long *pcColumns)
{
    *pcColumns=COLUMN_MAX;
    return S_OK;
}

HRESULT COEMsgTable::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}

HRESULT COEMsgTable::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar)
{
    MESSAGEINFO     msginfo;
    LPSTR           pszData = NULL;
    TCHAR           rgch[MAX_PATH];

    pVar->vt = VT_NULL;

    if (iRow == 0)
        {
        // return headings if row==0
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(StringFromColIndex(iColumn-1));
        return S_OK;
        }

    if (m_pTable->GetRow(iRow-1, &msginfo)==S_OK)
        {
        switch (iColumn-1)
            {
            case COLUMN_MSGID:
                wnsprintf(rgch,ARRAYSIZE(rgch), "%d", msginfo.idMessage);
                pszData = rgch;
                break;

            case COLUMN_SUBJECT:
                pszData = msginfo.pszSubject;
                break;

            case COLUMN_TO:
                pszData = msginfo.pszDisplayTo;
                break;

            case COLUMN_FROM:
                pszData = msginfo.pszDisplayFrom;
                break;

            case COLUMN_RECEIVED:
                pszData = rgch;
                *rgch=0;
                CchFileTimeToDateTimeSz(&msginfo.ftReceived, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
                break;

            default:
                pVar->vt = VT_NULL;
                pVar->lVal = NULL;
                return S_OK;
                
            }
        }
    if (pszData)
        {
        pVar->vt = VT_BSTR;
        HrLPSZToBSTR(pszData, &pVar->bstrVal);
        }
    else
        AssertSz(0, "bad");
    return S_OK;
}

HRESULT COEMsgTable::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::getLocale(BSTR *pbstrLocale)
{
    nyi("DATABINDING::getLocale");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::insertRows(long iRow, long cRows, long *pcRowsInserted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound)
{
    nyi("DATABINDING::find");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    ReplaceInterface(m_pDSListen, pospIListener);

    if (pospIListener)
        pospIListener->transferComplete(OSPXFER_COMPLETE);
    return S_OK;
}

HRESULT COEMsgTable::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    SafeRelease(m_pDSListen);
    return S_OK;
}

HRESULT COEMsgTable::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = FALSE;
    return S_OK;
}

HRESULT COEMsgTable::getEstimatedRows(long *piRows)
{
    return getRowCount(piRows);
}

HRESULT COEMsgTable::stopTransfer()
{
    return S_OK;
}


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMsgTable     *pMsgTable=NULL;
    HRESULT         hr;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMsgTable = new COEMsgTable();
    if (!pMsgTable)
        return E_OUTOFMEMORY;

    hr = pMsgTable->Init();
    if (FAILED(hr))
        goto error;

    hr = pMsgTable->QueryInterface(IID_IUnknown, (LPVOID *)ppUnknown);

error:
    ReleaseObj(pMsgTable);
    return hr;
}


HRESULT COEMsgTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    return DispGetIDsOfNames(m_pTypeInfo, &bstrName, 1, pid);
}

HRESULT COEMsgTable::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    switch (id)
        {
        case DISPID_MSDATASRCINTERFACE:
            pvarRes->vt = VT_UNKNOWN;
            pvarRes->punkVal = (OLEDBSimpleProvider *)this;
            AddRef();
            return S_OK;
        
        case DISPID_ADVISEDATASRCCHANGEEVENT:
            if (pdp->cArgs == 1 && pdp->rgvarg[0].vt == VT_UNKNOWN)
                {
                ReplaceInterface(m_pDataSrcListener, (DataSourceListener *)pdp->rgvarg[0].punkVal);
                return S_OK;
                }
            else
                return E_INVALIDARG;

        default:
            return DispInvoke(m_pUnkInvoke, m_pTypeInfo, id, wFlags, pdp, pvarRes, pei, NULL);
        }
    
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNameSpaceParent(IUnknown **ppunk)
{
    return E_NOTIMPL;
}


HRESULT COEMsgTable::put_sortColumn(BSTR bstr)
{
    FOLDERSORTINFO  fsi={0};

    m_col = (COLUMN_ID)ColIndexFromString(bstr);

    fsi.idSort = m_col;
    fsi.dwFlags = m_fAsc ? SORT_ASCENDING : 0;
    fsi.fForceSort = FALSE;

    if (m_pTable)
        m_pTable->SetSortInfo(&fsi);

    return S_OK;
}

HRESULT COEMsgTable::get_sortColumn(BSTR *pbstr)
{
 
    *pbstr = SysAllocString(StringFromColIndex(m_col));
    return S_OK;
}

HRESULT COEMsgTable::put_sortDirection(VARIANT_BOOL v)
{
    FOLDERSORTINFO  fsi;

    m_fAsc = (v == VARIANT_TRUE);

    fsi.idSort = m_col;
    fsi.dwFlags = m_fAsc ? SORT_ASCENDING : 0;
    fsi.fForceSort = FALSE;

    if (m_pTable)
        m_pTable->SetSortInfo(&fsi);

    return S_OK;
}

HRESULT COEMsgTable::get_sortDirection(VARIANT_BOOL *pv)
{
    *pv = m_fAsc ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

 
HRESULT COEMsgTable::test()
{
    if (m_pDataSrcListener)
        m_pDataSrcListener->dataMemberChanged(NULL);
    return S_OK;
}


static const WCHAR  c_szOESubjW[]       = L"oeSubj",
                    c_szOEToW[]         = L"oeTo",
                    c_szOEFromW[]       = L"oeFrom",
                    c_szOEMsgIdW[]      = L"oeMsgId",
                    c_szOEReceivedW[]   = L"oeDate";

DWORD ColIndexFromString(LPWSTR pszW)
{
    if (StrCmpIW(c_szOESubjW, pszW)==0)
        return COLUMN_SUBJECT;
    else
        if (StrCmpIW(c_szOEToW, pszW)==0)
            return COLUMN_TO;
        else
            if (StrCmpIW(c_szOEReceivedW, pszW)==0)
                return COLUMN_RECEIVED;
            else
                if (StrCmpIW(c_szOEFromW, pszW)==0)
                    return COLUMN_FROM;
                else
                    if (StrCmpIW(c_szOEMsgIdW, pszW)==0)
                        return COLUMN_MSGID;


    return (DWORD)-1;
}
 

LPWSTR StringFromColIndex(DWORD dw)
{
    switch (dw)
        {
        case COLUMN_MSGID:
            return (LPWSTR)c_szOEMsgIdW;

        case COLUMN_SUBJECT:
            return (LPWSTR)c_szOESubjW;

        case COLUMN_TO:
            return (LPWSTR)c_szOEToW;

        case COLUMN_FROM:
            return (LPWSTR)c_szOEFromW;
        
        case COLUMN_RECEIVED:
            return (LPWSTR)c_szOEReceivedW;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\table.cpp ===
/*
 *    t a b l e . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM DataBinding Table object
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"
#include "mshtmdid.h"

#include "table.h"
#include "instance.h"


COEMsgTable::COEMsgTable() : CBaseDisp()
{
    m_pTable=0;
    m_pDSListen=0;
    m_fAsc=TRUE;
    m_col=COLUMN_RECEIVED;
    m_pDataSrcListener=0;
    CoIncrementInit("COEMsgTable::COEMsgTable", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMsgTable::~COEMsgTable()
{
    ReleaseObj(m_pTable);
    ReleaseObj(m_pDSListen);
    ReleaseObj(m_pDataSrcListener);
    CoDecrementInit("COEMsgTable::COEMsgTable", NULL);
}

HRESULT COEMsgTable::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IDispatchEx))
        *lplpObj = (LPVOID)(IDispatchEx *)this;
    else if (IsEqualIID(riid, IID_IOEMsgList))
        *lplpObj = (LPVOID)(IOEMsgList *)this;
    else
        {
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

HRESULT COEMsgTable::Init()
{
    FOLDERINFO      fi;
    HRESULT         hr;

    g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fi);

    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    // Tell the table which folder to look at
    hr = m_pTable->Initialize(fi.idFolder, NULL, FALSE, NULL);
    if (FAILED(hr))
        goto error;

    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMsgList *)this, IID_IOEMsgList);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT COEMsgTable::getRowCount(long *pcRows)
{
    *pcRows = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pcRows);

        
    return S_OK;
}

HRESULT COEMsgTable::getColumnCount(long *pcColumns)
{
    *pcColumns=COLUMN_MAX;
    return S_OK;
}

HRESULT COEMsgTable::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}

HRESULT COEMsgTable::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar)
{
    LPMESSAGEINFO   pmsginfo;
    LPSTR           pszData = NULL;
    TCHAR           rgch[MAX_PATH];

    pVar->vt = VT_NULL;

    if (iRow == 0)
        {
        // return headings if row==0
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(_PszFromColIndex(iColumn-1));
        return S_OK;
        }

        if (m_pTable->GetRow(iRow-1, &pmsginfo)==S_OK)
        {
        switch (iColumn-1)
            {
            case COLUMN_MSGID:
                wnsprintf(rgch,ARRAYSIZE(rgch), "%d", pmsginfo->idMessage);
                pszData = rgch;
                break;

            case COLUMN_SUBJECT:
                pszData = pmsginfo->pszSubject;
                break;

            case COLUMN_TO:
                pszData = pmsginfo->pszDisplayTo;
                break;

            case COLUMN_FROM:
                pszData = pmsginfo->pszDisplayFrom;
                break;

            case COLUMN_RECEIVED:
                pszData = rgch;
                *rgch=0;
                CchFileTimeToDateTimeSz(&pmsginfo->ftReceived, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
                break;

            default:
                pVar->vt = VT_NULL;
                pVar->lVal = NULL;
                return S_OK;
                
            }
        }
    if (pszData)
        {
        pVar->vt = VT_BSTR;
        HrLPSZToBSTR(pszData, &pVar->bstrVal);
        }
    else
        AssertSz(0, "bad");
    return S_OK;
}

HRESULT COEMsgTable::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::getLocale(BSTR *pbstrLocale)
{
    nyi("DATABINDING::getLocale");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::insertRows(long iRow, long cRows, long *pcRowsInserted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound)
{
    nyi("DATABINDING::find");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    ReplaceInterface(m_pDSListen, pospIListener);

    if (pospIListener)
        pospIListener->transferComplete(OSPXFER_COMPLETE);
    return S_OK;
}

HRESULT COEMsgTable::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    SafeRelease(m_pDSListen);
    return S_OK;
}

HRESULT COEMsgTable::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = FALSE;
    return S_OK;
}

HRESULT COEMsgTable::getEstimatedRows(long *piRows)
{
    return getRowCount(piRows);
}

HRESULT COEMsgTable::stopTransfer()
{
    return S_OK;
}


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMsgTable     *pMsgTable=NULL;
    HRESULT         hr;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMsgTable = new COEMsgTable();
    if (!pMsgTable)
        return E_OUTOFMEMORY;

    hr = pMsgTable->Init();
    if (FAILED(hr))
        goto error;

    hr = pMsgTable->QueryInterface(IID_IUnknown, (LPVOID *)ppUnknown);

error:
    ReleaseObj(pMsgTable);
    return hr;
}


HRESULT COEMsgTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    return DispGetIDsOfNames(m_pTypeInfo, &bstrName, 1, pid);
}

HRESULT COEMsgTable::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    switch (id)
        {
        case DISPID_MSDATASRCINTERFACE:
            pvarRes->vt = VT_UNKNOWN;
            pvarRes->punkVal = (OLEDBSimpleProvider *)this;
            AddRef();
            return S_OK;
        
        case DISPID_ADVISEDATASRCCHANGEEVENT:
            if (pdp->cArgs == 1 && pdp->rgvarg[0].vt == VT_UNKNOWN)
                {
                ReplaceInterface(m_pDataSrcListener, (DataSourceListener *)pdp->rgvarg[0].punkVal);
                return S_OK;
                }
            else
                return E_INVALIDARG;

        default:
            return DispInvoke(m_pUnkInvoke, m_pTypeInfo, id, wFlags, pdp, pvarRes, pei, NULL);
        }
    
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNameSpaceParent(IUnknown **ppunk)
{
    return E_NOTIMPL;
}


HRESULT COEMsgTable::put_sortColumn(BSTR bstr)
{
    return S_OK;
}

HRESULT COEMsgTable::get_sortColumn(BSTR *pbstr)
{
 
    *pbstr = SysAllocString(_PszFromColIndex(m_col));
    return S_OK;
}

HRESULT COEMsgTable::put_sortDirection(VARIANT_BOOL v)
{
    return S_OK;
}

HRESULT COEMsgTable::get_sortDirection(VARIANT_BOOL *pv)
{
    *pv = m_fAsc ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

HRESULT COEMsgTable::test()
{
    if (m_pDataSrcListener)
        m_pDataSrcListener->dataMemberChanged(NULL);
    return S_OK;
}


static const WCHAR  c_szOESubjW[]       = L"oeSubj",
                    c_szOEToW[]         = L"oeTo",
                    c_szOEFromW[]       = L"oeFrom",
                    c_szOEMsgIdW[]      = L"oeMsgId",
                    c_szOEReceivedW[]   = L"oeDate";

DWORD COEMsgTable::_colIndexFromString(LPWSTR pszW)
{
    if (StrCmpIW(c_szOESubjW, pszW)==0)
        return COLUMN_SUBJECT;
    else
        if (StrCmpIW(c_szOEToW, pszW)==0)
            return COLUMN_TO;
        else
            if (StrCmpIW(c_szOEReceivedW, pszW)==0)
                return COLUMN_RECEIVED;
            else
                if (StrCmpIW(c_szOEFromW, pszW)==0)
                    return COLUMN_FROM;
                else
                    if (StrCmpIW(c_szOEMsgIdW, pszW)==0)
                        return COLUMN_MSGID;


    return (DWORD)-1;
}
 

LPWSTR COEMsgTable::_PszFromColIndex(DWORD dw)
{
    switch (dw)
        {
        case COLUMN_MSGID:
            return (LPWSTR)c_szOEMsgIdW;

        case COLUMN_SUBJECT:
            return (LPWSTR)c_szOESubjW;

        case COLUMN_TO:
            return (LPWSTR)c_szOEToW;

        case COLUMN_FROM:
            return (LPWSTR)c_szOEFromW;
        
        case COLUMN_RECEIVED:
            return (LPWSTR)c_szOEReceivedW;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\message.cpp ===
/*
 *    m e s s a g e . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Message' object and 'MessageCollection'
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "message.h"
#include "instance.h"

void FreeOEMsgData(POEMSGDATA pMsgData);

COEMessageCollection::COEMessageCollection(IUnknown *pUnkOuter) : CBaseDisp()
{
    m_pTable=NULL;
    m_idFolder = FOLDERID_INVALID;

    CoIncrementInit("COEMessageCollection::COEMessageCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMessageCollection::~COEMessageCollection()
{
    ReleaseObj(m_pTable);
    CoDecrementInit("COEMessageCollection::COEMessageCollection", NULL);
}

HRESULT COEMessageCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessageCollection))
        *lplpObj = (LPVOID)(IOEMessageCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
 
HRESULT COEMessageCollection::Init(FOLDERID idFolder)
{
    HRESULT         hr;

    m_idFolder = idFolder;

    // Create a Message Table
//    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER, IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto exit;

    // Tell the table which folder to look at
    hr = m_pTable->Initialize(idFolder, NULL, FALSE, NULL);
    if (FAILED(hr))
        goto exit;
    
    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMessageCollection *)this, IID_IOEMessageCollection);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}

// *** COEMessageCollection **
HRESULT COEMessageCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::get_length(long * pl)
{
    *pl = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pl);

    return S_OK;
}

HRESULT COEMessageCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    if (name.vt == VT_I4)
        return _FindMessageByIndex(name.lVal, ppdisp);

    return E_NOTIMPL;
}


HRESULT COEMessageCollection::_FindMessageByIndex(LONG l, IDispatch** ppdisp)
{
    HRESULT         hr = E_FAIL;
    LPMESSAGEINFO   pmsginfo;
    POEMSGDATA      pMsgData;

    if (m_pTable->GetRow(l, &pmsginfo)==S_OK)
        {
        if (!MemAlloc((LPVOID *)&pMsgData, sizeof(OEMSGDATA)))
            return E_OUTOFMEMORY;
   
        pMsgData->pszSubj = PszDup(pmsginfo->pszSubject);
        pMsgData->pszTo = PszDup(pmsginfo->pszDisplayTo);
        pMsgData->pszCc = PszDup("<not available>");
        pMsgData->pszFrom = PszDup(pmsginfo->pszDisplayFrom);
        pMsgData->ftReceived = pmsginfo->ftReceived;
        pMsgData->msgid = pmsginfo->idMessage;

        //m_pFolder->OpenMessage(msginfo.dwMsgId, FALSE, NULL, &pMsg)==S_OK)

        // OEMessage frees the data object
        hr = CreateOEMessage(NULL, m_idFolder, pMsgData, ppdisp);
        if (FAILED(hr))
            FreeOEMsgData(pMsgData);
        
        }
    return hr;
}

void FreeOEMsgData(POEMSGDATA pMsgData)
{
    if (pMsgData)
        {
        MemFree(pMsgData->pszSubj);
        MemFree(pMsgData->pszTo);
        MemFree(pMsgData->pszCc);
        MemFree(pMsgData->pszFrom);
        MemFree(pMsgData);
        }
}

/*
 *  C O E M e s s a g e
 */

HRESULT CreateOEMessage(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp)
{
    COEMessage *pNew;
    HRESULT     hr;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pMsg, idFolder, pMsgData);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}


COEMessage::COEMessage()
{
    m_cRef=1;
    m_pMsg = NULL;
    m_pMsgData = NULL;
    CoIncrementInit("COEMessage::COEMessage", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMessage::~COEMessage()
{
    FreeOEMsgData(m_pMsgData);
    ReleaseObj(m_pMsg);
    CoDecrementInit("COEMessage::COEMessage", NULL);
}

HRESULT COEMessage::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessage))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEMessage::Init(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData)
{
    m_idFolder = idFolder;
    ReplaceInterface(m_pMsg, pMsg);
    m_pMsgData = pMsgData;
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMessage *)this, IID_IOEMessage);
}

// *** COEMessage **
HRESULT COEMessage::get_subject(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszSubj, pbstr);
        return S_OK;
        }

    if (MimeOleGetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        return S_OK;
        }
    return E_FAIL;
}

HRESULT COEMessage::put_subject(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_to(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszTo, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_to(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();
    
    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_cc(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszCc, pbstr);
        return S_OK;
        }

    *pbstr = NULL;
    if (m_pMsg->GetAddressFormat(IAT_CC, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_cc(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CC), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_sender(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszFrom, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_sender(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_text(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_text(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_html(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_html(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_HTML, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_url(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    // BUGBUGBUG: this is a terrible hack also. We can't get a persistent URL moniker to 
    // the MHTML document (not yet investigated), so for the purpose of this demo-code
    // we'll use a tmp file
    if (m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
        WriteStreamToFile(pstm, "c:\\oe_temp$.eml", CREATE_ALWAYS, GENERIC_WRITE);
        pstm->Release();
        }

    *pbstr = SysAllocString(L"c:\\oe_temp$.eml");
    return S_OK;
}

HRESULT COEMessage::get_date(BSTR *pbstr)
{
    PROPVARIANT     pv;
    TCHAR           rgch[MAX_PATH];
    FILETIME        *pft=0;

    *pbstr = NULL;

    if (!m_pMsg)
        {
        pft = &m_pMsgData->ftReceived;
        }
    else
        {
        // Get Receive Time
        pv.vt = VT_FILETIME;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &pv)))
            pft = &pv.filetime;
        }

    if (pft)
        {
        *rgch=0;
        CchFileTimeToDateTimeSz(pft, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
        HrLPSZToBSTR(rgch, pbstr);
        }
    return S_OK;
}



HRESULT COEMessage::send()
{
/*
    TCHAR   sz[MAX_PATH];

    // use default account to send
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountId(ACCT_MAIL, sz, ARRAYSIZE(sz))))
        {
        PROPVARIANT rUserData;
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = sz;
        m_pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rUserData);
        }

    HrSendMailToOutBox(g_hwndInit, m_pMsg, TRUE, TRUE);
*/
    return E_FAIL;
}



HRESULT COEMessage::BindToMessage()
{
    if (m_pMsg)
        return S_OK; 

    //Assert (m_pFolder && m_pMsgData);
    //return m_pFolder->OpenMessage(m_pMsgData->msgid, NULL, &m_pMsg, NULL);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\syncenum.h ===
/*
    File:   SyncEnum.h
    Private Header File for OneStop ENUMERATOR
*/
#ifndef _SYNCENUM_H
#define _SYNCENUM_H

#include <objbase.h>
#include <syncmgr.h>

#include "onestop.h"

class CEnumOfflineItems : public ISyncMgrEnumItems
{
public:
	CEnumOfflineItems(LPSYNCMGRHANDLERITEMS pOfflineItems, DWORD cOffset);
	~CEnumOfflineItems();

	//IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();
	
	//IEnumOfflineItems members
	STDMETHODIMP Next(ULONG celt, LPSYNCMGRITEM rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(ISyncMgrEnumItems **ppenum);

private:
	LONG  m_cRef;
	DWORD m_cOffset;
	LPSYNCMGRHANDLERITEMS m_pOfflineItems; // array of offline items, same format as give to OneStop
	LPSYNCMGRHANDLERITEM  m_pNextItem;
};

typedef CEnumOfflineItems *LPCEnumOfflineItems;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\syncenum.cpp ===
/*
    File:   enum.cpp
    Implementation of OneStop Enumerator

    Based on sample code from OneStop.
*/
#include "pch.hxx"
#include "syncenum.h"

CEnumOfflineItems::CEnumOfflineItems(LPSYNCMGRHANDLERITEMS pOfflineItems, DWORD cOffset):
    m_cRef(1), m_pOfflineItems(pOfflineItems), m_cOffset(cOffset)
{
    DWORD dwItemIndex;
    TraceCall("CEnumOfflineItems::CEnumOfflineItems()");

	OHIL_AddRef(m_pOfflineItems);

	// Set the current item to point to next record.
	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	dwItemIndex = cOffset;
	
	Assert(dwItemIndex <= m_pOfflineItems->dwNumOfflineItems);

	while(dwItemIndex--)
	{
		m_pNextItem = m_pNextItem->pNextOfflineItem;
		++m_cOffset;
	}
}

CEnumOfflineItems::~CEnumOfflineItems()
{
	OHIL_Release(m_pOfflineItems);
}

STDMETHODIMP CEnumOfflineItems::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("CEnumOfflineItems::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_ISyncMgrEnumItems))
        *ppvObj = SAFECAST(this, ISyncMgrEnumItems *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::AddRef()
{
    TraceCall("CEnumOfflineItems::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::Release()
{
    TraceCall("CEnumOfflineItems::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    // OHIL released in destructor
    delete this;
    return 0;
}

STDMETHODIMP CEnumOfflineItems::Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched)
{
    HRESULT hr = NOERROR;
    ULONG ulFetchCount = celt;
    LPSYNCMGRITEM pOfflineItem;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		ulFetchCount = m_pOfflineItems->dwNumOfflineItems - m_cOffset;
		hr = S_FALSE;
	}

	pOfflineItem = rgelt;

	while (ulFetchCount--)
	{
		*pOfflineItem = m_pNextItem->offlineItem;
		m_pNextItem = m_pNextItem->pNextOfflineItem;
		++m_cOffset;
		++pOfflineItem;
	}

	return hr;
}

STDMETHODIMP CEnumOfflineItems::Skip(ULONG celt)
{
    HRESULT hr;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		m_cOffset = m_pOfflineItems->dwNumOfflineItems;
		m_pNextItem = NULL;
		hr = S_FALSE;
	}
	else
	{
		while (celt--)
		{
			++m_cOffset;
			m_pNextItem = m_pNextItem->pNextOfflineItem;
		}

		hr = NOERROR;
	}

	return hr;
}

STDMETHODIMP CEnumOfflineItems::Reset()
{
	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	return NOERROR;
}

STDMETHODIMP CEnumOfflineItems::Clone(ISyncMgrEnumItems **ppenum)
{
    *ppenum = new  CEnumOfflineItems(m_pOfflineItems,m_cOffset);
	return *ppenum ? NOERROR : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\synchndl.cpp ===
/*
    PLEASE NOTE!
    OneStop and MultiUser do not get along well.  This code does some hacks to get stuff to work, and
    mobsync should not be invoked from the shell while OE is running.

    Some assumptions:
    There will never be a user 0
*/

/*
    File:   SyncHndl.cpp
    Implementation of OneStop Sync Handler
*/
#include "pch.hxx"
#include "resource.h"
#include "synchndl.h"
#include "syncenum.h"
#include "syncprop.h"
#include "spoolapi.h"
#include "imnact.h"
#include "multiusr.h"
#include "instance.h"

HRESULT CreateInstance_OneStopHandler(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr = S_OK;
    TraceCall("CreateInstance_OneStopHandler");
    
    // We don't support aggregation and our factory knows it
    Assert(NULL == pUnkOuter);

    // Shouldn't be getting bad args from the factory either
    Assert(NULL != ppUnknown);

    *ppUnknown = new COneStopHandler;

    if (NULL == *ppUnknown)
    	hr = E_OUTOFMEMORY;

    return hr;
}

COneStopHandler::COneStopHandler(): 
    m_cRef(1), m_pOfflineHandlerItems(NULL), m_pOfflineSynchronizeCallback(NULL),
    m_dwSyncFlags(0), m_fInOE(FALSE), m_dwUserID(0)
{ 
    Assert(g_pInstance);
    if (SUCCEEDED(CoIncrementInit("COneStopHandler::COneStopHandler", MSOEAPI_START_COMOBJECT, NULL, NULL)))
        m_fInit = 1;
    else
        m_fInit = 0;
}

COneStopHandler::~COneStopHandler()
{ 
    Assert(g_pInstance);

    if (m_pOfflineHandlerItems)
        OHIL_Release(m_pOfflineHandlerItems);

    if(m_fInit)
        g_pInstance->CoDecrementInit("COneStopHandler::COneStopHandler", NULL);
}

STDMETHODIMP COneStopHandler::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("COneStopHandler::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronize))
        *ppvObj = SAFECAST(this, ISyncMgrSynchronize *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) COneStopHandler::AddRef()
{
    TraceCall("COneStopHandler::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COneStopHandler::Release()
{
    TraceCall("COneStopHandler::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    delete this;
    return 0;
}

BOOL CreateOneStopItems(IImnEnumAccounts *pEnum, LPSYNCMGRHANDLERITEMS pOfflineHandlerItems, DWORD dwUserID, HICON *hicn)
{
    BOOL                bAnything   = FALSE;
    IImnAccount         *pAccount   = NULL;
    LPWSTR              pwsz        = NULL;
    SYNCMGRHANDLERITEM  *pItem      = NULL;
    CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
    CHAR                szAcctName[CCHMAX_ACCOUNT_NAME];
    WCHAR               wszItemName[MAX_SYNCMGRITEMNAME];
    DWORD               dwAvail;
    int                 cDiff;
    ACCTTYPE            accttype;
    ULONG               cb;
    HRESULT             hr;

    // Iterate through the accounts
    pEnum->SortByAccountName();
    while(SUCCEEDED(pEnum->GetNext(&pAccount)) && 
          SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID,   szAcctID,   ARRAYSIZE(szAcctID))) &&
          SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcctName, ARRAYSIZE(szAcctName))) )
    {
        if (!(pwsz = PszToUnicode(CP_ACP, szAcctName)))
            break;
        
        // Safe to allocate this item, we have enough info to make the node
        if (pItem = OHIL_AddItem(pOfflineHandlerItems))
        {
            StrCpyNA(pItem->szAcctName, szAcctName, ARRAYSIZE(pItem->szAcctName));
            StrCpyNW(pItem->offlineItem.wszItemName, pwsz, ARRAYSIZE(pItem->offlineItem.wszItemName));
            StrCpyNA(pItem->szAcctID, szAcctID, ARRAYSIZE(pItem->szAcctID));
            
            // Handle the Account GUID
            cb = sizeof(SYNCMGRITEMID);
            if (FAILED(pAccount->GetProp(AP_UNIQUE_ID, (LPBYTE)&(pItem->offlineItem.ItemID), &cb)))
            {
                if (FAILED(CoCreateGuid(&(pItem->offlineItem.ItemID))) ||
                    FAILED(pAccount->SetProp(AP_UNIQUE_ID, (LPBYTE)(&(pItem->offlineItem.ItemID)), sizeof(SYNCMGRITEMID))) ||
                    FAILED(pAccount->SaveChanges()))
                    ZeroMemory(&(pItem->offlineItem.ItemID), sizeof(SYNCMGRITEMID));
            }
            
            // Need to do something with this...
            pItem->offlineItem.wszStatus[0] = 0;
            
            if (SUCCEEDED(pAccount->GetAccountType(&accttype)))
            {
                if (ACCT_MAIL == accttype)
                    pItem->offlineItem.hIcon = hicn[1];
                else
                    pItem->offlineItem.hIcon = hicn[2];

                pItem->accttype = accttype;
            }
            else
            {
                pItem->offlineItem.hIcon = hicn[0];
                pItem->accttype = ACCT_LAST;
            }

            // Default to syncing the server, no folders synced by default
            if (SUCCEEDED(pAccount->GetPropDw(AP_AVAIL_OFFLINE, &dwAvail)))
                pItem->offlineItem.dwItemState = dwAvail ? SYNCMGRITEMSTATE_CHECKED : 0;
            else
                // Default to checked
                pItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

            // Default to not roaming for now...
            pItem->offlineItem.dwFlags = SYNCMGRITEM_HASPROPERTIES;

            pItem->dwUserID = dwUserID;
            
            pItem->offlineItem.cbSize = sizeof(SYNCMGRITEM);
            bAnything = TRUE;
        }
        MemFree(pwsz);
        pAccount->Release();
    }

    return bAnything;
}

STDMETHODIMP COneStopHandler::Initialize(DWORD dwReserved, DWORD dwSyncFlags, 
                                         DWORD cbCookie, BYTE const*lpCookie)
{
    HRESULT             hr          = S_FALSE;
    IImnEnumAccounts    *pEnum      = NULL;
    HKEY                hkey        = NULL;
    HICON               hicn[3]     = {NULL, NULL, NULL};
    DWORD               dwIndex     = 0;
    DWORD               dwItemID    = 0;
    ULONG               ulCount     = 0;
    ULONG               ulTemp      = 0;
    BOOL                bAnything   = FALSE;
    BOOL                fMultiUser;
    TCHAR               szSubKey[80];
    TCHAR               szFullKey[MAX_PATH], szFullKey2[MAX_PATH];
    FILETIME            dummy;
    DWORD               cb;
    DWORD               dwUserID;

    Assert(g_hLocRes);
    Assert(g_pAcctMan);
    
    if (!m_fInit)
        return E_FAIL;

    // Allocate memory for the list
    if (!(m_pOfflineHandlerItems = OHIL_Create()))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Preload the icons for mail and news
    hicn[0] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiMailNews));
    hicn[1] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiMail));
    hicn[2] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiNews));
    
    // Save the flags away - they are good for the life of this sync
    m_dwSyncFlags = dwSyncFlags;

    // Were we invoked by OE with the UserID of the current user?
    if (m_fInOE = (lpCookie && (sizeof(DWORD) == cbCookie)))
    {
        // We only care about the current user
        if (SUCCEEDED(g_pAcctMan->InitUser(NULL, NULL, 0)))
        {
            if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
            {
                GetCurrentUserID(&m_dwUserID);
                CreateOneStopItems(pEnum, m_pOfflineHandlerItems, m_dwUserID, hicn);
                pEnum->Release();
            }
        }

        // Always want to handle if OE called us
        return S_OK;
    }

    // Need to enumerate all users in the current profile

    // Flush any changes
    SaveCurrentUserSettings();

    // Are there even any OE users in this profile to worry about?
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_PROFILE_ROOT, c_szRegLM, NULL, KEY_ENUMERATE_SUB_KEYS, &hkey))
        goto exit;

    hr = E_UNEXPECTED;

    cb = ARRAYSIZE(szSubKey);
    while (ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex++, szSubKey, &cb, 0, NULL, NULL, &dummy))
    {
        cb = ARRAYSIZE(szSubKey);
        
        // Tell Acct Manager where to look
        wnsprintf(szFullKey, ARRAYSIZE(szFullKey), c_szPathFileFmt, c_szRegLM, szSubKey);
        wnsprintf(szFullKey2, ARRAYSIZE(szFullKey2), c_szPathFileFmt, szFullKey, c_szIAM);
        if (FAILED(g_pAcctMan->InitUser(NULL, szFullKey2, 0)))
            continue;
        
        // Does this user have any relevant accounts?
        if (FAILED(g_pAcctMan->GetAccountCount(ACCT_NEWS, &ulTemp)))
            continue;
        else 
        {    
            ulCount = ulTemp;
            if (FAILED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &ulTemp)))
                continue;
            ulCount += ulTemp;
            
            if (0 == ulCount)
            {
                continue;
            }
        }
        
        if (FAILED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
            continue;

        GetCurrentUserID(&dwUserID);
        bAnything = CreateOneStopItems(pEnum, m_pOfflineHandlerItems, dwUserID, hicn) || bAnything;
        
        pEnum->Release();
        pEnum = NULL;
    }

    RegCloseKey(hkey);
    hkey = NULL;

    // If there is nothing to enumerate, don't worry about this sync event
    if (!bAnything)
    {
        hr = S_FALSE;
        goto exit;
    }

    return S_OK;

exit:
    if (hkey)
        RegCloseKey(hkey);
    if (m_pOfflineHandlerItems)
        OHIL_Release(m_pOfflineHandlerItems);
    SafeRelease(pEnum);
    return hr;
}


STDMETHODIMP COneStopHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    SYNCMGRHANDLERINFO SMHI, *pSMHI;
    TCHAR szName[MAX_SYNCMGRHANDLERNAME];
    LPWSTR pwsz;
    
    if (!ppSyncMgrHandlerInfo)
        return E_INVALIDARG;
    
    *ppSyncMgrHandlerInfo = NULL;
    
    if (LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMailNews)) &&
        LoadString(g_hLocRes, idsAthena, szName, MAX_SYNCMGRHANDLERNAME))
    {
        if (MemAlloc((LPVOID *)&pSMHI, sizeof(SYNCMGRHANDLERINFO)))
        {
#ifdef UNICODE
            StrCpyN(pSMHI->wszHandlerName, szName, ARRAYSIZE(pSMHI->wszHandlerName));
#else
            if (pwsz = PszToUnicode(CP_ACP, szName))
            {
                StrCpyNW(pSMHI->wszHandlerName, pwsz, MAX_SYNCMGRHANDLERNAME);
                MemFree(pwsz);
            }
            else
            {
                MemFree(ppSyncMgrHandlerInfo);
                return E_OUTOFMEMORY;
            }
#endif
            pSMHI->cbSize = sizeof(SYNCMGRHANDLERINFO);
            *ppSyncMgrHandlerInfo = pSMHI;
            return S_OK;
        }
        else
            return E_OUTOFMEMORY;
    }
    else
        return E_UNEXPECTED;
}

STDMETHODIMP COneStopHandler::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{

	if (m_pOfflineHandlerItems)
	{
		*ppenumOffineItems = new CEnumOfflineItems(m_pOfflineHandlerItems, 0);
	}
	else
	{
		*ppenumOffineItems = NULL;
	}

	return *ppenumOffineItems ? NOERROR: E_OUTOFMEMORY;
}


STDMETHODIMP COneStopHandler::GetItemObject(REFSYNCMGRITEMID ItemID, REFIID riid, void** ppv)
{
    // Not implemented in OneStop v1 Spec
    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowProperties(HWND hwnd, REFSYNCMGRITEMID ItemID)
{
    DWORD dwLastUser=0;
    SYNCMGRHANDLERITEM  *pItem;
    BOOL fOkToEdit = TRUE;
    
    // We didn't provide any items, how can OneStop ask us about them?
    if (!m_pOfflineHandlerItems)
        return E_UNEXPECTED;

    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;

    // This is slow, but shouldn't be many accounts...
    while (pItem)
    {
        if (IsEqualGUID(ItemID, pItem->offlineItem.ItemID))
            break;
        else
            pItem = pItem->pNextOfflineItem;
    }
    
    if (pItem)
    {
        if (dwLastUser != pItem->dwUserID)
        {
            if (fOkToEdit = SUCCEEDED(SwitchContext(pItem->dwUserID)))
            {
                dwLastUser = pItem->dwUserID;
            }
        }

        if (fOkToEdit)
            ShowPropSheet(hwnd, pItem->szAcctID, pItem->szAcctName, pItem->accttype);
    }
    else
        // Gave us an ItemID we don't know about!
        return E_INVALIDARG;

	return S_OK;
}


STDMETHODIMP COneStopHandler::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    LPSYNCMGRSYNCHRONIZECALLBACK pCallbackCurrent = m_pOfflineSynchronizeCallback;

	m_pOfflineSynchronizeCallback = lpCallBack;

	if (m_pOfflineSynchronizeCallback)
		m_pOfflineSynchronizeCallback->AddRef();

	if (pCallbackCurrent)
		pCallbackCurrent->Release();

	return NOERROR;
}


STDMETHODIMP COneStopHandler::PrepareForSync(ULONG cbNumItems, SYNCMGRITEMID* pItemIDs, 
                                             HWND hwndParent, DWORD dwReserved)
{
    HRESULT hr;
    SYNCMGRHANDLERITEM  *pItem, *pPrev, *pTemp;
    IImnAccount *pAccount;
    DWORD dwLastUser;

    Assert(g_pAcctMan);

    if (cbNumItems > m_pOfflineHandlerItems->dwNumOfflineItems)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (!m_pOfflineHandlerItems)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (!m_pOfflineSynchronizeCallback)
    {
        hr = E_FAIL;
        goto exit;
    }
    
#if 0
    if (FAILED(hr = g_pSpooler->Init(NULL, FALSE)))
    {
        if (FACILITY_ITF == HRESULT_FACILITY(hr))
            hr = E_FAIL;
        goto exit;
    }
#endif

    if (m_fInOE)
        dwLastUser = m_dwUserID;
    else
        dwLastUser = 0;
    
    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;
    pPrev = NULL;

    // Go through all the servers that we know about
    while (pItem)
    {
        ULONG i=0;
        BOOL fOKToWrite = TRUE;

        // Is current server one that the user asked to sync?
        while (i < cbNumItems)
        {
            if (IsEqualGUID(pItemIDs[i], pItem->offlineItem.ItemID))
                break;
            else
                i++;
        }

        // No match?
        if (cbNumItems == i)
            pItem->offlineItem.dwItemState = 0;
        else
            pItem->offlineItem.dwItemState = 1;

        // Make sure the account manager is looking at the right user
        if (pItem->dwUserID != dwLastUser)
        {
            if (fOKToWrite = SUCCEEDED(InitUser(pItem->dwUserID)))
                dwLastUser = pItem->dwUserID;
        }

        // Only save changes if we know the registry is in sync with the account manager
        if (fOKToWrite)
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pItem->szAcctID, &pAccount)))
            {
                if (SUCCEEDED(pAccount->SetPropDw(AP_AVAIL_OFFLINE, pItem->offlineItem.dwItemState)))
                    pAccount->SaveChanges();
                pAccount->Release();
            }
        }

        // Can we delete this item from the list?
        if (0 == pItem->offlineItem.dwItemState)
        {
            if (pPrev)
                pPrev->pNextOfflineItem = pItem->pNextOfflineItem;
            else
                m_pOfflineHandlerItems->pFirstOfflineItem = pItem->pNextOfflineItem;

            m_pOfflineHandlerItems->dwNumOfflineItems--;

            // Move on to next item
            pTemp = pItem;
            pItem = pItem->pNextOfflineItem;
            MemFree(pTemp);
        }
        else
        {    
            // Move on to next item
            pPrev = pItem;
            pItem = pItem->pNextOfflineItem;
        }

    }

    Assert(m_pOfflineHandlerItems->dwNumOfflineItems == cbNumItems);
    
    hr = S_OK;

exit:
    m_pOfflineSynchronizeCallback->PrepareForSyncCompleted(hr);
    return hr;
}


STDMETHODIMP COneStopHandler::Synchronize(HWND hwndParent)
{
    HRESULT hr;
    SYNCMGRHANDLERITEM  *pItem;
    DWORD dwLastUser;
    
    Assert(g_pSpooler);

    if (!m_pOfflineSynchronizeCallback)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    if (!m_pOfflineHandlerItems)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (m_fInOE)
        dwLastUser = m_dwUserID;
    else
        dwLastUser = 0;

    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;
    while (pItem)
    {
        BOOL fOkToSync = TRUE;

        if (dwLastUser != pItem->dwUserID)
        {
            if (fOkToSync = SUCCEEDED(SwitchContext(pItem->dwUserID)))
                dwLastUser = pItem->dwUserID;
        }

        if (fOkToSync)
            g_pSpooler->StartDelivery(hwndParent, pItem->szAcctID, FOLDERID_INVALID,
                DELIVER_UPDATE_ALL | DELIVER_NODIAL);

        pItem = pItem->pNextOfflineItem;
    }

    hr = S_OK;

exit:
    m_pOfflineSynchronizeCallback->SynchronizeCompleted(hr);
    return hr;
}

STDMETHODIMP COneStopHandler::SetItemStatus(REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus)
{
    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowError(HWND hWndParent, REFSYNCMGRERRORID ErrorID, 
                                        ULONG *pcbNumItems, SYNCMGRITEMID **ppItemIDs)
{
	// Can show any synchronization conflicts. Also gives a chance
	// to display any errors that occured during synchronization
	return E_NOTIMPL;
}

HRESULT SwitchContext(DWORD dwUserID)
{
    HRESULT hr = S_OK;
    char szUsername[CCH_USERNAME_MAX_LENGTH];

    Assert(g_pAcctMan);
    
    if (UserIdToUsername(dwUserID, szUsername, ARRAYSIZE(szUsername)) &&
        SwitchToUser(szUsername, FALSE) )
    {
        // Reinitialize AcctMan
        if (FAILED(hr = g_pAcctMan->InitUser(NULL, NULL, 0)) &&
            FACILITY_ITF == HRESULT_FACILITY(hr) )
            hr = E_FAIL;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT InitUser(DWORD dwUserID)
{
    HRESULT hr = S_OK;
    TCHAR   szFullKey[MAX_PATH], szFullKey2[MAX_PATH];
    TCHAR   szSubKey[80];

    Assert(g_pAcctMan);
    
    wnsprintf(szSubKey, ARRAYSIZE(szSubKey), "%08lx", dwUserID);

    // Figure out the full path to the Account Info for the current user
    wnsprintf(szFullKey, ARRAYSIZE(szFullKey), c_szPathFileFmt, c_szRegLM, szSubKey);
    wnsprintf(szFullKey2, ARRAYSIZE(szFullKey2), c_szPathFileFmt, szFullKey, c_szIAM);

    // Point account manager to an OE multiuser
    // Safe even if acct manager was already inited before - will reload accounts
    if (FAILED(hr = (g_pAcctMan->InitUser(NULL, szFullKey, 0))) &&
        (FACILITY_ITF == HRESULT_FACILITY(hr)))
        hr = E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\synchndl.h ===
#ifndef _SYNCHNDL_H
#define _SYNCHNDL_H
/*
    File:   Synchndl.h
    Private Header file for Synchronization HANDLER
*/
#include <objbase.h>
#include <syncmgr.h>

#include "onestop.h"
#include "imnact.h"

class COneStopHandler : public ISyncMgrSynchronize
{
public:
    // === IUnknown
	STDMETHODIMP		    QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// === IOfflineSynchronize
	STDMETHODIMP	Initialize          (DWORD dwReserved, DWORD dwSyncFlags, DWORD cbCookie, const BYTE *lpCooke);
	STDMETHODIMP	GetHandlerInfo      (LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
	STDMETHODIMP	EnumSyncMgrItems    (ISyncMgrEnumItems **ppenumOffineItems);
	STDMETHODIMP	GetItemObject       (REFSYNCMGRITEMID ItemID, REFIID riid,void** ppv);
	STDMETHODIMP	ShowProperties      (HWND hwnd, REFSYNCMGRITEMID ItemID);
	STDMETHODIMP	SetProgressCallback (ISyncMgrSynchronizeCallback *lpCallBack);
	STDMETHODIMP	PrepareForSync      (ULONG cbNumItems, SYNCMGRITEMID* pItemIDs, HWND hWndParent, DWORD dwReserved);
	STDMETHODIMP	Synchronize         (HWND hwnd);
	STDMETHODIMP    SetItemStatus       (REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus);
	STDMETHODIMP	ShowError           (HWND hWndParent, REFSYNCMGRERRORID ErrorID, ULONG *pcbNumItems, SYNCMGRITEMID **ppItemIDs);
    
    // === Constructor / Destructor
    COneStopHandler();
    virtual ~COneStopHandler();

    // === Get / Set
	inline LPSYNCMGRHANDLERITEMS GetOfflineItemsHolder() { return m_pOfflineHandlerItems; };
	inline void SetOfflineItemsHolder(LPSYNCMGRHANDLERITEMS pOfflineHandlerItems) 
				{ m_pOfflineHandlerItems = pOfflineHandlerItems; };
	inline LPSYNCMGRSYNCHRONIZECALLBACK GetOfflineSynchronizeCallback() 
					{ return m_pOfflineSynchronizeCallback; };

private:
    LONG                            m_cRef;
	LPSYNCMGRHANDLERITEMS           m_pOfflineHandlerItems;
	LPSYNCMGRSYNCHRONIZECALLBACK    m_pOfflineSynchronizeCallback;
    DWORD                           m_dwSyncFlags;
    BOOL                            m_fInOE:1;
    BOOL                            m_fInit:1;
    DWORD                           m_dwUserID;
};

typedef COneStopHandler *LPCOneStopHandler;

HRESULT SwitchContext(DWORD dwUserID);
HRESULT InitUser(DWORD dwUserID);

#endif // _SYNCHNDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\onestop.h ===
#ifndef _ONESTOP_H
#define _ONESTOP_H
/*
    File: OneStop.h
    Public Header for OE's OneStop Implementation
*/

#include <syncmgr.h>
#include "imnact.h"

// ================================= DATA TYPES
// Base structure for an OfflineHandler item (one line in the listview)
// Specific implementations allocate extra space on the end for their specific data.
typedef struct  _SYNCMGRHANDLERITEM
{
    _SYNCMGRHANDLERITEM *pNextOfflineItem;
    SYNCMGRITEM         offlineItem;
    CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
    CHAR                szAcctName[CCHMAX_ACCOUNT_NAME];
    DWORD               dwUserID;
    ACCTTYPE            accttype;
}  SYNCMGRHANDLERITEM;

typedef SYNCMGRHANDLERITEM *LPSYNCMGRHANDLERITEM;

// structure for keeping track of items as a whole 
typedef struct  _tagSYNCMGRHANDLERITEMS
{
    LONG  cRefs;			            
    DWORD dwNumOfflineItems;		    
    LPSYNCMGRHANDLERITEM pFirstOfflineItem; 
} SYNCMGRHANDLERITEMS;

typedef SYNCMGRHANDLERITEMS *LPSYNCMGRHANDLERITEMS;


// ================================= FUNCTIONS
// Class Factory Entry Point
HRESULT CreateInstance_OneStopHandler(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// OfflineHandlerItemList Manipulation
DWORD                   OHIL_AddRef(LPSYNCMGRHANDLERITEMS lpOfflineItem);
DWORD                   OHIL_Release(LPSYNCMGRHANDLERITEMS lpOfflineItem);
LPSYNCMGRHANDLERITEMS   OHIL_Create();
LPSYNCMGRHANDLERITEM    OHIL_AddItem(LPSYNCMGRHANDLERITEMS pOfflineItemsList);

void InvokeSyncMgr(HWND hwnd, ISyncMgrSynchronizeInvoke ** ppSyncMgr, BOOL bPrompt);

#endif  // _ONESTOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\om\table.h ===
/*
 *    t a b l e . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _TABLE_H
#define _TABLE_H

#include "privunk.h"
#include "basedisp.h"
#include "simpdata.h"
#include "dispex.h"
#include "msdatsrc.h"


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COEMsgTable:
    public OLEDBSimpleProvider,
    public CBaseDisp,
    public IOEMsgList,
    public IDispatchEx
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };
        
    // OLEDBSimpleProvider        
    virtual HRESULT STDMETHODCALLTYPE getRowCount(long *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(long *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(long iRow, long iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar);        
    virtual HRESULT STDMETHODCALLTYPE setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(long iRow, long cRows, long *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(long iRow, long cRows, long *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(long *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer();
        
    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IDispatchEx ***
    virtual HRESULT STDMETHODCALLTYPE GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID(DISPID id);
    virtual HRESULT STDMETHODCALLTYPE GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    virtual HRESULT STDMETHODCALLTYPE GetMemberName(DISPID id, BSTR *pbstrName);
    virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent(IUnknown **ppunk);

    // ** IOEMsgList **
    virtual HRESULT STDMETHODCALLTYPE put_sortColumn(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_sortColumn(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sortDirection(VARIANT_BOOL v);
    virtual HRESULT STDMETHODCALLTYPE get_sortDirection(VARIANT_BOOL *pv);
    virtual HRESULT STDMETHODCALLTYPE test();

    COEMsgTable();
    virtual ~COEMsgTable();

    HRESULT Init();

private:
    ULONG                           m_cRef;
    IMessageTable                   *m_pTable;
    OLEDBSimpleProviderListener     *m_pDSListen;
    DataSourceListener              *m_pDataSrcListener;
    BOOL                            m_fAsc;
    COLUMN_ID                       m_col;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    LPWSTR _PszFromColIndex(DWORD dw);
    DWORD _colIndexFromString(LPWSTR pszW);

};

#endif //_TABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\offsync.cpp ===
/*
    File:   offsync.cpp
    Miscellaneous code not in the handler or the enumerator

    Based on sample code from OneStop
*/
#include "pch.hxx"
#include "onestop.h"
#include "multiusr.h"
#include "demand.h"

LPSYNCMGRHANDLERITEMS OHIL_Create()
{
    LPSYNCMGRHANDLERITEMS lpOffline;
    
    if (MemAlloc((LPVOID *)&lpOffline, sizeof(SYNCMGRHANDLERITEMS)))
	{
        lpOffline->cRefs = 0;
        lpOffline->dwNumOfflineItems=NULL;		    
        lpOffline->pFirstOfflineItem=NULL;
        OHIL_AddRef(lpOffline);

		// do any specific itemlist initialization here.
	}

	return lpOffline;
}

DWORD OHIL_AddRef(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
	return ++(lpOfflineItem->cRefs);
}

DWORD OHIL_Release(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
	DWORD cRefs = --lpOfflineItem->cRefs;
    LPSYNCMGRHANDLERITEM lpCurrent, lpDelete;

	if (0 == cRefs)
	{
		lpCurrent = lpOfflineItem->pFirstOfflineItem;
        while (lpCurrent)
        {
            lpDelete = lpCurrent;
            lpCurrent = lpCurrent->pNextOfflineItem;
            MemFree(lpDelete);
        }
        MemFree(lpOfflineItem);
	}

	return cRefs;
}

// allocates space for a new offline and adds it to the list,
// if successfull returns pointer to new item so caller can initialize it. 
LPSYNCMGRHANDLERITEM OHIL_AddItem(LPSYNCMGRHANDLERITEMS pOfflineItemsList)
{
    LPSYNCMGRHANDLERITEM pOfflineItem;
    
	if (MemAlloc((LPVOID *)&pOfflineItem, sizeof(SYNCMGRHANDLERITEM)))
	{
        // Add new node to the front
        pOfflineItem->pNextOfflineItem = pOfflineItemsList->pFirstOfflineItem;
	    pOfflineItemsList->pFirstOfflineItem = pOfflineItem;

	    ++pOfflineItemsList->dwNumOfflineItems;
	}

	return pOfflineItem;
}

// Only called from OE, so assumes OE init of dll vars has occurred
void InvokeSyncMgr(HWND hwnd, ISyncMgrSynchronizeInvoke ** ppSyncMgr, BOOL bPrompt)
{
    HRESULT hr;
    uCLSSPEC ucs;
    static s_fSyncAvail = FALSE;
    DWORD dwDummy=1;
    
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_MobilityFeature;

    // Try to fault in the Mobility pack if it is not around
    if (!s_fSyncAvail && FAILED(hr = FaultInIEFeature(hwnd, &ucs, NULL, FIEF_FLAG_FORCE_JITUI)))
    {
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsJITErrDenied), NULL, MB_OK);
        return;
    }

    AssertSz(S_FALSE != hr, "InvokeSyncMgr: URLMON Thinks that the Offline pack is not an IE feature!");

    // Avoid expensive URLMON call next time
    s_fSyncAvail = TRUE;

    if (!*ppSyncMgr)
    {
        // We've never grabbed the sync mgr invoker before
        if (FAILED(CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISyncMgrSynchronizeInvoke, (LPVOID *)ppSyncMgr)))
        {
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSYNCMGRErr), NULL, MB_OK);
            return;
        }
    }

    // Against all odds, the following call will create a new PROCESS!
    (*ppSyncMgr)->UpdateItems(bPrompt ? 0 : SYNCMGRINVOKE_STARTSYNC, CLSID_OEOneStopHandler, sizeof(dwDummy), (LPCBYTE)&dwDummy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\syncprop.cpp ===
#include "pch.hxx"
#include "syncprop.h"
#include "imnact.h"
#include "grplist2.h"

static CSyncPropDlg *s_pSyncPropDlg = NULL;

CSyncPropDlg::CSyncPropDlg():
    m_cRef(1), m_pGrpList(NULL), m_pColumns(NULL), m_pszAcctName(NULL)
{
    IF_DEBUG(m_fInit = FALSE;)
}

CSyncPropDlg::~CSyncPropDlg()
{
    // We handed this out, so release it
    SafeRelease(m_pColumns);

    if (m_pGrpList)
        delete m_pGrpList;
    
    if (m_pszAcctName)
        MemFree(m_pszAcctName);
}

STDMETHODIMP CSyncPropDlg::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("CSyncPropDlg::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_IGroupListAdvise))
        *ppvObj = SAFECAST(this, IGroupListAdvise *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CSyncPropDlg::AddRef()
{
    TraceCall("CSyncPropDlg::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSyncPropDlg::Release()
{
    TraceCall("CSyncPropDlg::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSyncPropDlg::ItemUpdate(void)
{
    return S_OK;
}

STDMETHODIMP CSyncPropDlg::ItemActivate(FOLDERID id)
{
    return S_OK;
}

BOOL CSyncPropDlg::Initialize(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype)
{
    Assert(g_hLocRes);
    
    Assert(pszAcctID);
    Assert(pszAcctName);

    if (!(m_pColumns = new CColumns) || !(m_pGrpList = new CGroupList))
        return FALSE;

    ZeroMemory(&m_pspage, sizeof(PROPSHEETPAGE));
    ZeroMemory(&m_pshdr,  sizeof(PROPSHEETHEADER));

    m_accttype = accttype;
    
    ULONG cchAcctName = lstrlen(pszAcctName)+1;
    if (MemAlloc((LPVOID*) &m_pszAcctName, cchAcctName))
    {
        StrCpyNA(m_pszAcctName, pszAcctName, cchAcctName);
    }
    else
        m_pszAcctName = NULL;

    // BUGBUG: Need to get some sync icons here...
    switch (accttype)
    {
    case ACCT_MAIL:
        m_dwIconID = idiMail;
        break;
    case ACCT_NEWS:
        m_dwIconID = idiDLNews;
        break;
    default:
        m_dwIconID = idiPhone;
    }

    m_pspage.dwSize       = sizeof(PROPSHEETPAGE);
    m_pspage.hInstance    = g_hLocRes;
    m_pspage.pszTemplate  = MAKEINTRESOURCE(iddSyncSettings);
    m_pspage.pfnDlgProc   = DlgProc;
        
    m_pshdr.dwSize        = sizeof(PROPSHEETHEADER);
    m_pshdr.dwFlags       = PSH_USEICONID | PSH_PROPSHEETPAGE | PSH_USEPAGELANG;
    m_pshdr.hwndParent    = hwnd;
    m_pshdr.hInstance     = g_hLocRes;
    m_pshdr.pszCaption    = (LPCSTR) m_pszAcctName;
    m_pshdr.nPages        = 1;
    m_pshdr.nStartPage    = 0;
    m_pshdr.ppsp          = &m_pspage;
    m_pshdr.pszIcon       = MAKEINTRESOURCE(m_dwIconID);
 
    IF_DEBUG(m_fInit = TRUE;)

    return TRUE;
}

void CSyncPropDlg::Show()
{
    Assert(m_fInit);

    // Stash our this pointer somewhere where the static dlgproc can access it
    s_pSyncPropDlg = this;

    // Actually show the dlg (modal)
    PropertySheet(&m_pshdr);
}

BOOL CSyncPropDlg::InitDlg(HWND hwnd)
{
    COLUMN_SET_TYPE set;
    m_hwndList = GetDlgItem(hwnd, idcList);
    
    m_pColumns->Initialize(m_hwndList, COLUMN_SET_OFFLINE);
    m_pColumns->ApplyColumns(COLUMN_LOAD_DEFAULT, NULL, 0);

    if (FAILED(m_pGrpList->Initialize((IGroupListAdvise *)this, m_pColumns, m_hwndList, m_accttype, FALSE)))
        return FALSE;

    SendDlgItemMessage (hwnd, idcIcon,        STM_SETICON, (WPARAM)LoadIcon(g_hLocRes, MAKEINTRESOURCE(m_dwIconID)), 0);
    SendDlgItemMessageA(hwnd, idcAccountName, WM_SETTEXT,  0, (LPARAM)m_pszAcctName);
    
    return TRUE;
}

BOOL CALLBACK CSyncPropDlg::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandledRet = TRUE;
    CSyncPropDlg *pThis = (CSyncPropDlg*)GetWindowLong(hwnd, GWL_USERDATA);
    
    switch (msg)
    {
    case WM_INITDIALOG:
        // Let the dlg know which CSyncPropDlg controls it
        Assert(s_pSyncPropDlg);
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)(pThis = s_pSyncPropDlg));
        s_pSyncPropDlg = NULL;
        
        fHandledRet = pThis->InitDlg(hwnd);    
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
        }
        break;

    default:
        return FALSE;

    }

    return fHandledRet;
}

// Normal way to get a sync properties dlg
void ShowPropSheet(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype)
{
    CSyncPropDlg *pDlg;

    if (pDlg = new CSyncPropDlg())
    {
        if (pDlg->Initialize(hwnd, pszAcctID, pszAcctName, accttype))
            pDlg->Show();
        delete pDlg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\resdummy\makefile.inc ===
ATHENA_RC_DEPENDS = thor.rcv		    \
                    ..\inc\resource.h

$O\mailnews.res : $(ATHENA_RC_DEPENDS)

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\actions.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Actions.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ACTIONS_H_
#define _ACTIONS_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

class COEActions : public IOEActions, IPersistStream
{
    private:
        enum {ACT_COUNT_MIN = 0, ACT_COUNT_MAX = 0x1000};

        enum {CCH_ACT_ORDER = 4};
        
        enum {ACT_VERSION = 0x00050000};
        
    private:
        LONG        m_cRef;
        ACT_ITEM *  m_rgItems;
        ULONG       m_cItems;
        ULONG       m_cItemsAlloc;
        DWORD       m_dwState;
        
    public:
        // Constructor/destructor
        COEActions() : m_cRef(0), m_rgItems(NULL), m_cItems(0), m_cItemsAlloc(0), m_dwState(0) {}
        ~COEActions();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEActions members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP GetActions(DWORD dwFlags, PACT_ITEM * ppItem, ULONG * pcItem);
        STDMETHODIMP SetActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem);
        STDMETHODIMP Validate(DWORD dwFlags);
        
        STDMETHODIMP AppendActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended);
        
        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOEActions ** ppIActions);
                                
        // IPersistStream members
        STDMETHODIMP GetClassID(CLSID * pclsid);
        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(IStream * pStm);
        STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }
};

HRESULT HrCreateActions(IOEActions ** ppIActions);
#endif  // !_ACTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\actions.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Actions.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "actions.h"
#include "storutil.h"
#include "ruleutil.h"

static const int ACT_GROW = 16;

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateActions
//
//  This creates an actions container.
//
//  ppIActions - pointer to return the criteria container
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the IOEActions object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateActions(IOEActions ** ppIActions)
{
    COEActions *    pActions = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppIActions)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIActions = NULL;

    // Create the rules manager object
    pActions = new COEActions;
    if (NULL == pActions)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pActions->QueryInterface(IID_IOEActions, (void **) ppIActions);
    if (FAILED(hr))
    {
        goto exit;
    }

    pActions = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pActions)
    {
        delete pActions;
    }
    
    return hr;
}

COEActions::~COEActions()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    Reset();
}

STDMETHODIMP_(ULONG) COEActions::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COEActions::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COEActions::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEActions))
    {
        *ppvObject = static_cast<IOEActions *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::Reset(void)
{
    HRESULT     hr = S_OK;

    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    RuleUtil_HrFreeActionsItem(m_rgItems, m_cItems);
    SafeMemFree(m_rgItems);
    m_cItems = 0;
    m_cItemsAlloc = 0;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    DWORD       dwState = ACT_STATE_NULL;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init the outgoing param
    *pdwState = ACT_STATE_NULL;
    
    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    // Walk through the actions to figure out the state
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if ((ACT_STATE_NULL == dwState) &&
                ((ACT_TYPE_DELETESERVER ==  m_rgItems[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD ==  m_rgItems[ulIndex].type)))
        {
            dwState = ACT_STATE_SERVER;
        }
        else
        {
            dwState = ACT_STATE_LOCAL;
        }
    }

    // Set the outgoing param
    *pdwState = dwState;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::GetActions(DWORD dwFlags, PACT_ITEM * ppItem, ULONG * pcItem)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming params
    if ((NULL == ppItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the out params
    *ppItem = NULL;
    if (NULL != pcItem)
    {
        *pcItem = 0;
    }
    
    // If we don't have any criteria, then return
    if (0 == m_cItems)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupActionsItem(m_rgItems, m_cItems, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    *ppItem = pItemNew;
    pItemNew = NULL;
    if (NULL != pcItem)
    {
        *pcItem = m_cItems;
    }
    
exit:
    RuleUtil_HrFreeActionsItem(pItemNew, m_cItems);
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COEActions::SetActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // If we have any criteria already, then reset
    if (0 != m_cItems)
    {
        Reset();
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupActionsItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    m_rgItems = pItemNew;
    pItemNew = NULL;
    m_cItems = cItem;
    m_cItemsAlloc = cItem;
    
exit:
    RuleUtil_HrFreeActionsItem(pItemNew, cItem);
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ValidateActions
//
//  This verifies each of the action values
//
//  Returns:    S_OK, if the actions were valid
//              S_FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COEActions::Validate(DWORD dwFlags)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    LPSTR               pszText = NULL;
    FOLDERINFO          Folder={0};
    RULEFOLDERDATA *    prfdData = NULL;

    // If we don't have any actions, then we must be valid
    if (0 == m_cItems)
    {
        hr = S_OK;
        goto exit;
    }

    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        switch(m_rgItems[ulIndex].type)
        {
            // These ones are always valid
            case ACT_TYPE_DELETESERVER:
            case ACT_TYPE_DONTDOWNLOAD:
            case ACT_TYPE_FLAG:
            case ACT_TYPE_READ:
            case ACT_TYPE_MARKDOWNLOAD:
            case ACT_TYPE_DELETE:
            case ACT_TYPE_JUNKMAIL:
            case ACT_TYPE_STOP:
                if (VT_EMPTY != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_HIGHLIGHT:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_WATCH:
            case ACT_TYPE_SHOW:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                if (ACT_DATA_NULL == m_rgItems[ulIndex].propvar.ulVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_COPY:
            case ACT_TYPE_MOVE:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (m_rgItems[ulIndex].propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }        
                else
                    g_pStore->FreeRecord(&Folder);
                break;
                
            case ACT_TYPE_REPLY:
            case ACT_TYPE_NOTIFYSND:
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                Assert(lstrlen(m_rgItems[ulIndex].propvar.pszVal) <= MAX_PATH)
                    if (0xFFFFFFFF == GetFileAttributes(m_rgItems[ulIndex].propvar.pszVal))
                    {
                        hr = S_FALSE;
                        goto exit;
                    }
                    break;
                    
            case ACT_TYPE_FWD:
            {
                LPWSTR  pwszVal = NULL,
                        pwszText = NULL;
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    AssertSz(VT_LPWSTR != m_rgItems[ulIndex].propvar.vt, "We are getting UNICODE here.");
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Update the display string
                pwszVal = PszToUnicode(CP_ACP, m_rgItems[ulIndex].propvar.pszVal);
                if (!pwszVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
                MemFree(pwszText);
                MemFree(pwszVal);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // If either always encrypt or always sign is turned on
                // we can't do anything
                if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            }
                
            default:
                hr = S_FALSE;
                goto exit;
                break;
        }
    }

    // If we got here, the we must be AOK
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

STDMETHODIMP COEActions::AppendActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming parameters
    if ((0 != dwFlags) || (NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's init our outgoing parameters
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = 0;
    }

    // Do we have to add more items?
    if (m_cItems == m_cItemsAlloc)
    {
        hr = HrRealloc((LPVOID *) &m_rgItems, sizeof(ACT_ITEM) * (m_cItemsAlloc + ACT_GROW));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(m_rgItems + m_cItemsAlloc, sizeof(ACT_ITEM) * ACT_GROW);
        m_cItemsAlloc += ACT_GROW;
    }

    // Let's duplicate the items that need to be added
    hr = RuleUtil_HrDupActionsItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Let's add them to the criteria array
    CopyMemory(m_rgItems + m_cItems, pItemNew, sizeof(ACT_ITEM) * cItem);
    m_cItems += cItem;
    
    // Set the proper outgoing parameter
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = cItem;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  LoadReg
//
//  This loads in the actions from the registry.  It loads in the actions
//  order from the Order value.  The string contains space delimitied values
//  and each value contains the subkey name for each action.  Each action 
//  is loaded in the order that is contained in the Order value.  The actions
//  are loaded with the Actions Type.  The Actions Value Type is loaded if it exists.
//  If an Action Value Type exists, then the corresponding Action Value is loaded in.
//
//  pszRegPath  - the path to load the actions from
//
//  Returns:    S_OK, if the actions were loaded without problems
//              E_OUTOFMEMORY, if we couldn't allocate memory to hold the actions
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COEActions::LoadReg(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = 0;
    HKEY            hkeyRoot = NULL;
    ULONG           cbData = 0;
    LPSTR           pszOrder = NULL;
    ULONG           cOrder = 0;
    LPSTR           pszWalk = NULL;
    ACT_ITEM *      pItems = NULL;
    LPSTR           pszNext = NULL;
    ULONG           ulOrder = 0;
    HKEY            hkeyAction = NULL;
    ACT_TYPE        typeAct;
    PROPVARIANT     propvar = {0};
    DWORD           dwType = 0;
    BYTE *          pbData = NULL;
    DWORD           dwFlags = ACT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & ACT_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the actions order
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szActionsOrder, NULL, (BYTE **) &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Make sure we actually have something to load
    if ('\0' == *pszOrder)
    {
        AssertSz(FALSE, "The order string for the actions is mis-formatted in the registry");
        hr = E_FAIL;
        goto exit;
    }
    
    // Convert the actions string to a more useful format
    pszWalk = pszOrder;
    cOrder = 1;
    for (pszWalk = StrStr(pszOrder, g_szSpace); NULL != pszWalk; pszWalk = StrStr(pszWalk, g_szSpace))
    {
        // Terminate the order item
        *pszWalk = '\0';
        pszWalk++;
        cOrder++;
    }


    // Allocate the space to hold all the actions
    cbData = cOrder * sizeof(ACT_ITEM);
    hr = HrAlloc((void **) &pItems, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pItems, cbData);
    
    // For each action in the order string
    pszWalk = pszOrder;
    for (ulOrder = 0, pszWalk = pszOrder; ulOrder < cOrder; ulOrder++, pszWalk += lstrlen(pszWalk) + 1)
    {
        // Open up the action reg key
        lErr = RegOpenKeyEx(hkeyRoot, pszWalk, 0, KEY_READ, &hkeyAction);
        if (ERROR_SUCCESS != lErr)
        {
            AssertSz(FALSE, "Part of the criteria is mis-formatted in the registry");
            hr = E_FAIL;
            goto exit;
        }

        // Get the action type
        cbData = sizeof(typeAct);
        lErr = RegQueryValueEx(hkeyAction, c_szActionsType, 0, NULL,
                                        (BYTE *) &(typeAct), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the action flags
        cbData = sizeof(dwFlags);
        lErr = RegQueryValueEx(hkeyAction, c_szActionsFlags, 0, NULL,
                                        (BYTE *) &(dwFlags), &cbData);
        if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
        {
            hr = E_FAIL;
            goto exit;
        }

        // If it didn't exist then assign it to the default
        if (ERROR_FILE_NOT_FOUND == lErr)
        {
            dwFlags = ACT_FLAG_DEFAULT;
        }

        // Does a action value type exist
        lErr = RegQueryValueEx(hkeyAction, c_szActionsValueType, 0, NULL, NULL, &cbData);
        if ((ERROR_SUCCESS == lErr) && (0 != cbData))
        {
            // Load the action value in
            cbData = sizeof(dwType);
            lErr = RegQueryValueEx(hkeyAction, c_szActionsValueType, 0, NULL,
                                            (BYTE *) &dwType, &cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            propvar.vt = (VARTYPE) dwType;
            
            switch (propvar.vt)
            {
                case VT_UI4:
                    // Get the action value
                    cbData = sizeof(propvar.ulVal);
                    lErr = RegQueryValueEx(hkeyAction, c_szActionsValue, 0, NULL,
                        (BYTE * ) &(propvar.ulVal), &cbData);
                    if (ERROR_SUCCESS != lErr)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                    break;
                    
                case VT_LPSTR:
                case VT_BLOB:
                    // Get the criteria value
                    hr = RuleUtil_HrGetRegValue(hkeyAction, c_szActionsValue, NULL, (BYTE **) &pbData, &cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Save the space so we can free it
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    
                    pbData = NULL;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we loading in an invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
        }

        // Save the value into the criteria array
        pItems[ulOrder].type = typeAct;
        pItems[ulOrder].dwFlags = dwFlags;
        pItems[ulOrder].propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
        
        // Close the action
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyAction));
        hkeyAction = NULL;        
    }
    
    // Free up the current actions
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cOrder;

    // Make sure we clear the dirty bit
    m_dwState &= ~ACT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= ACT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pbData);
    PropVariantClear(&propvar);
    RuleUtil_HrFreeActionsItem(pItems, cOrder);
    SafeMemFree(pItems);
    SafeMemFree(pszOrder);
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEActions::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LPSTR       pszOrder = NULL;
    ULONG       ulIndex = 0;
    ACT_ITEM *  pItem = NULL;
    CHAR        rgchTag[CCH_ACT_ORDER];
    HKEY        hkeyAction = NULL;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If there's nothing to save, then fail
    if (NULL == m_rgItems)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
    Assert(m_cItems < ACT_COUNT_MAX);

    // Allocate space to hold the order
    DWORD cchSize = (m_cItems * CCH_ACT_ORDER);
    hr = HrAlloc((void **) &pszOrder, cchSize * sizeof(*pszOrder));
    if (FAILED(hr))
    {
        goto exit;
    }
    pszOrder[0] = '\0';
    
    // Write out each of the actions
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Get the new action tag
        wnsprintf(rgchTag, ARRAYSIZE(rgchTag), "%03X", ulIndex);

        // Add the new tag to the order
        if (0 != ulIndex)
        {
            StrCatBuff(pszOrder, g_szSpace, cchSize);
        }
        StrCatBuff(pszOrder, rgchTag, cchSize);
        
        // Create the new action
        lErr = RegCreateKeyEx(hkeyRoot, rgchTag, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAction, &dwDisp);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        Assert(REG_CREATED_NEW_KEY == dwDisp);
        
        // Write out the action type
        lErr = RegSetValueEx(hkeyAction, c_szActionsType, 0, REG_DWORD,
                                        (BYTE *) &(pItem->type), sizeof(pItem->type));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the action type
        lErr = RegSetValueEx(hkeyAction, c_szActionsFlags, 0, REG_DWORD,
                                        (BYTE *) &(pItem->dwFlags), sizeof(pItem->dwFlags));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Do we have an action value?
        if (VT_EMPTY != pItem->propvar.vt)
        {
            // Write out the criteria value type
            dwDisp = pItem->propvar.vt;
            lErr = RegSetValueEx(hkeyAction, c_szActionsValueType, 0, REG_DWORD, (BYTE *) &dwDisp, sizeof(dwDisp));
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
            
            // Write out the action value
            switch (pItem->propvar.vt)
            {
                case VT_UI4:
                    dwDisp = REG_DWORD;
                    pbData = (BYTE * ) &(pItem->propvar.ulVal);
                    cbData = sizeof(pItem->propvar.ulVal);
                    break;
                    
                case VT_LPSTR:
                    dwDisp = REG_SZ;
                    pbData = (BYTE * ) (pItem->propvar.pszVal);
                    cbData = lstrlen(pItem->propvar.pszVal) + 1;
                    break;
                    
                case VT_BLOB:
                    dwDisp = REG_BINARY;
                    pbData = pItem->propvar.blob.pBlobData;
                    cbData = pItem->propvar.blob.cbSize;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in an invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
            
            // Write out the action value
            lErr = RegSetValueEx(hkeyAction, c_szActionsValue, 0, dwDisp, pbData, cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
        }

        // Close the action
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyAction));
        hkeyAction = NULL;        
    }

    // Write out the order string.
    lErr = RegSetValueEx(hkeyRoot, c_szActionsOrder, 0, REG_SZ,
                                    (BYTE *) pszOrder, lstrlen(pszOrder) + 1);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~ACT_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEActions::Clone(IOEActions ** ppIActions)
{
    HRESULT         hr = S_OK;
    COEActions *    pActions = NULL;
    
    // Check incoming params
    if (NULL == ppIActions)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIActions = NULL;
    
    // Create a new actions
    pActions = new COEActions;
    if (NULL == pActions)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the list of actions
    hr = pActions->SetActions(0, m_rgItems, m_cItems);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions interface
    hr = pActions->QueryInterface(IID_IOEActions, (void **) ppIActions);
    if (FAILED(hr))
    {
        goto exit;
    }

    pActions = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pActions)
    {
        delete pActions;
    }
    return hr;
}

STDMETHODIMP COEActions::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OEActions;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (ACT_STATE_DIRTY == (m_dwState & ACT_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COEActions::Load(IStream * pStm)
{
    HRESULT         hr = S_OK;
    ULONG           cbData = 0;
    ULONG           cbRead = 0;
    DWORD           dwData = 0;
    ULONG           cItems = 0;
    ACT_ITEM *      pItems = NULL;
    ULONG           ulIndex = 0;
    ACT_ITEM *      pItem = NULL;
    ACT_TYPE        typeAct;
    PROPVARIANT     propvar = {0};
    BYTE *          pbData = NULL;
    DWORD           dwFlags = ACT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != ACT_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the number of actions
    hr = pStm->Read(&cItems, sizeof(cItems), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(cItems)) || (0 == cItems))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space to hold all the actions
    hr = HrAlloc( (void **) &pItems, cItems * sizeof(*pItems));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the actions to a known value
    ZeroMemory(pItems, cItems * sizeof(*pItems));
    
    // for each action
    for (ulIndex = 0, pItem = pItems; ulIndex < cItems; ulIndex++, pItem++)
    {
        // Read in the action type
        hr = pStm->Read(&typeAct, sizeof(typeAct), &cbRead);
        if (FAILED(hr))
        {
            goto exit;
        }

        if (cbRead != sizeof(typeAct))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the action flags
        hr = pStm->Read(&dwFlags, sizeof(dwFlags), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwFlags)))
        {
            goto exit;
        }

        // Read in the action value type
        hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
        {
            goto exit;
        }

        propvar.vt = (VARTYPE) dwData;
        
        if (VT_EMPTY != propvar.vt)
        {
            // Get the size of the action value
            hr = pStm->Read(&cbData, sizeof(cbData), &cbRead);
            if (FAILED(hr))
            {
                goto exit;
            }

            if (cbRead != sizeof(cbData))
            {
                hr = E_FAIL;
                goto exit;
            }

            // Allocate space to hold the action value data
            switch (propvar.vt)
            {
                case VT_UI4:
                    pbData = (BYTE * ) &(propvar.ulVal);
                    break;
                    
                case VT_BLOB:
                case VT_LPSTR:
                    hr = HrAlloc((void **) &pbData, cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in a invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }

            // Read in the action value
            hr = pStm->Read(pbData, cbData, &cbRead);
            if (FAILED(hr))
            {
                goto exit;
            }

            if (cbRead != cbData)
            {
                hr = E_FAIL;
                goto exit;
            }

        }

        pItem->type = typeAct;
        pItem->dwFlags = dwFlags;
        pItem->propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
    }

    // Free up the current actions
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cItems;

    // Make sure we clear the dirty bit
    m_dwState &= ~ACT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= ACT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    PropVariantClear(&propvar);
    RuleUtil_HrFreeActionsItem(pItems, cItems);
    SafeMemFree(pItems);
    return hr;
}

STDMETHODIMP COEActions::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    ULONG       cbData = 0;
    ULONG       cbWritten = 0;
    DWORD       dwData = 0;
    ULONG       ulIndex = 0;
    ACT_ITEM *  pItem = NULL;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Write out the version
    dwData = ACT_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the count of actions
    hr = pStm->Write(&m_cItems, sizeof(m_cItems), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(m_cItems));
    
    // Loop through each of the actions
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Write out the action type
        hr = pStm->Write(&(pItem->type), sizeof(pItem->type), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->type));

        // Write out the actions flags
        hr = pStm->Write(&(pItem->dwFlags), sizeof(pItem->dwFlags), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->dwFlags));
        
        // Write out the value type
        dwData = pItem->propvar.vt;
        hr = pStm->Write(&(dwData), sizeof(dwData), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(dwData));
        
        if (VT_EMPTY == pItem->propvar.vt)
        {
            continue;
        }
        
        // Figure out the size of the action value
        switch (pItem->propvar.vt)
        {
            case VT_UI4:
                pbData = (BYTE * ) &(pItem->propvar.ulVal);
                cbData = sizeof(pItem->propvar.ulVal);
                break;
                
            case VT_LPSTR:
                pbData = (BYTE * ) (pItem->propvar.pszVal);
                cbData = lstrlen(pItem->propvar.pszVal) + 1;
                break;
                
            case VT_BLOB:
                pbData = pItem->propvar.blob.pBlobData;
                cbData = pItem->propvar.blob.cbSize;
                break;
                
            default:
                AssertSz(FALSE, "Why are we trying to save in a invalid action type?");
                hr = E_FAIL;
                goto exit;
                break;                
        }
        
        // Write out the action value size
        hr = pStm->Write(&cbData, sizeof(cbData), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(cbData));
        
        // Write out the action value
        hr = pStm->Write(pbData, cbData, &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == cbData);            
    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~ACT_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\onestop\syncprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     syncprop.h
//
//  PURPOSE:    Defines constants for Sync settings prop sheet
//

#ifndef __SYNCPROP_H__
#define __SYNCPROP_H__

#include "grplist2.h"

class CSyncPropDlg:
    public IGroupListAdvise
{
public:    
    // === IUnknown
	STDMETHODIMP		    QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    // === IGroupListAdvise
    STDMETHODIMP            ItemUpdate(void);
    STDMETHODIMP            ItemActivate(FOLDERID id);
    
    // === Constructors, destructors and initialization
    CSyncPropDlg();
    ~CSyncPropDlg();
    BOOL Initialize(HWND hwndOwner, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype);
    void Show();

private:
    static BOOL CALLBACK DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hwnd);

    LONG             m_cRef;

    PROPSHEETPAGE    m_pspage;
    PROPSHEETHEADER  m_pshdr;
    DWORD            m_dwIconID;
    LPSTR            m_pszAcctName;
    CColumns        *m_pColumns;
    CGroupList      *m_pGrpList;
    ACCTTYPE         m_accttype;
    HWND             m_hwndList;
    IF_DEBUG(BOOL    m_fInit;)

};

void ShowPropSheet(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype);

////////////////////////////////////////////////////////////////////////////
// Control IDs for iddSyncSettings

#define idcIcon                                     1001
#define idcAccount                                  1002
#define idcAccountName                              1003
#define idcList                                     1004
#define idcSynchronize                              1005
#define idcMode                                     1006
#define idcDownload                                 1007

#endif // __SYNCPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\addrrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  AddrRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

// Type definitions
typedef struct tagRULEADDRLIST
{
    DWORD   dwFlags;
    LPSTR   pszAddr;
} RULEADDRLIST, * PRULEADDRLIST;

// Interface definitions
interface IOENondlgUnk
{
    virtual STDMETHODIMP NondlgQueryInterface(const IID & riid, void ** ppvObject) = 0;
    virtual STDMETHODIMP_(ULONG) NondlgAddRef() = 0;
    virtual STDMETHODIMP_(ULONG) NondlgRelease() = 0;
};

interface IOERuleAddrList : IUnknown
{
    virtual STDMETHODIMP GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList) = 0;
    virtual STDMETHODIMP SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList) = 0;
    virtual STDMETHODIMP Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg) = 0;
    
    virtual STDMETHODIMP IsDirty() = 0;
    virtual STDMETHODIMP LoadList(LPCSTR pszRegPath) = 0;
    virtual STDMETHODIMP SaveList(LPCSTR pszRegPath, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP Clone(IOERuleAddrList ** ppIAddrList) = 0;
};

// Constants
const DWORD RALF_MAIL       = 0x00000001;
const DWORD RALF_NEWS       = 0x00000002;
const DWORD RALF_MAILNEWS   = RALF_MAIL | RALF_NEWS;

class COERuleAddrList : public IOERuleAddrList, IOENondlgUnk
{
    private:  
        enum
        {
            STATE_UNINIT   = 0x00000000,
            STATE_INIT     = 0x00000001,
            STATE_LOADED   = 0x00000002,
            STATE_DIRTY    = 0x00000004
        };    

        enum {RULEADDRLIST_VERSION  = 0x00050000};
        
        enum {CCH_EXCPT_KEYNAME_MAX = 9};
        
    private:
        LONG            m_cRef;
        DWORD           m_dwState;
        DWORD           m_dwFlags;
        RULEADDRLIST *  m_pralList;
        ULONG           m_cralList;
        IUnknown *      m_pIUnkOuter;
    
    public:
        // Constructor/destructor
        COERuleAddrList() : m_cRef(0), m_dwState(0), m_dwFlags(0), m_pralList(NULL),
                            m_cralList(0), m_pIUnkOuter(NULL) {}
        ~COERuleAddrList();

        // IUnknown members
        virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject)
                { return m_pIUnkOuter->QueryInterface(riid, ppvObject); }
        virtual STDMETHODIMP_(ULONG) AddRef(void)
                { return m_pIUnkOuter->AddRef(); }
        virtual STDMETHODIMP_(ULONG) Release(void)
                { return m_pIUnkOuter->Release(); }

        // IOENondlgUnk
        virtual STDMETHODIMP NondlgQueryInterface(REFIID riid, void ** ppvObject);
        virtual STDMETHODIMP_(ULONG) NondlgAddRef(void);
        virtual STDMETHODIMP_(ULONG) NondlgRelease(void);
                
        // IOERuleAddrList members
        virtual STDMETHODIMP GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList);
        virtual STDMETHODIMP SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList);
        virtual STDMETHODIMP Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg);
    
        virtual STDMETHODIMP IsDirty() {return ((0 != (m_dwState & STATE_DIRTY)) ? S_OK : S_FALSE);}
        virtual STDMETHODIMP LoadList(LPCSTR pszRegPath);
        virtual STDMETHODIMP SaveList(LPCSTR pszRegPath, BOOL fClearDirty);
        virtual STDMETHODIMP Clone(IOERuleAddrList ** ppIAddrList);

        // COERuleAddrList members
        HRESULT HrInit(DWORD dwFlags, IUnknown * pIUnkOuter);

};

HRESULT HrCreateAddrList(IUnknown * pIUnkOuter, const IID & riid, void ** ppvObject);
VOID FreeRuleAddrList(RULEADDRLIST * pralList, ULONG cralList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\addrrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  AddrRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "addrrule.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateAddrList
//
//  This creates an address list.
//
//  ppIRule - pointer to return the address list
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Address List object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateAddrList(IUnknown * pIUnkOuter, const IID & riid, void ** ppvObject)
{
    COERuleAddrList *   pral = NULL;
    HRESULT             hr = S_OK;

    // Check the incoming params
    if ((NULL == ppvObject) || ((NULL != pIUnkOuter) && (IID_IUnknown != riid)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppvObject = NULL;

    // Create the rules address list object
    pral = new COERuleAddrList;
    if (NULL == pral)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule address list
    hr = pral->HrInit(0, pIUnkOuter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules address list interface
    hr = pral->NondlgQueryInterface(riid, (void **) ppvObject);
    if (FAILED(hr))
    {
        goto exit;
    }

    pral = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pral)
    {
        delete pral;
    }
    
    return hr;
}

VOID FreeRuleAddrList(RULEADDRLIST * pralList, ULONG cralList)
{
    ULONG   ulIndex = 0;
    
    // Check incoming param
    if (NULL == pralList)
    {
        goto exit;
    }
    
    for (ulIndex = 0; ulIndex < cralList; ulIndex++, pralList++)
    {
        SafeMemFree(pralList->pszAddr);
        pralList->dwFlags = 0;
    }

exit:
    return;
}

HRESULT _HrLoadExcptFromReg(HKEY hkeyRoot, LPSTR pszKeyname, RULEADDRLIST * pralItem)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyItem = NULL;
    DWORD       dwFlags = 0;
    ULONG       cbData = 0;
    LPSTR       pszExcpt = NULL;

    Assert(NULL != hkeyRoot);
    Assert(NULL != pszKeyname);
    Assert(NULL != pralItem);

    // Open up the entry
    lErr = RegOpenKeyEx(hkeyRoot, pszKeyname, 0, KEY_READ, &hkeyItem);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Get the flags
    cbData = sizeof(dwFlags);
    lErr = RegQueryValueEx(hkeyItem, c_szExcptFlags, NULL, NULL, (BYTE *) &dwFlags, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Get the size of the exception
    lErr = RegQueryValueEx(hkeyItem, c_szException, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Allocate space to hold the exception
    hr = HrAlloc((VOID **) &pszExcpt, cbData * sizeof(*pszExcpt));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the exception
    lErr = RegQueryValueEx(hkeyItem, c_szException, NULL, NULL, (BYTE *) pszExcpt, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Verify the values
    if (('\0' == pszExcpt[0]) || ((0 == (dwFlags & RALF_MAIL)) && (0 == (dwFlags & RALF_NEWS))))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the values into the item
    pralItem->dwFlags = dwFlags;
    pralItem->pszAddr = pszExcpt;
    pszExcpt = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszExcpt);
    if (NULL != hkeyItem)
    {
        RegCloseKey(hkeyItem);
    }
    return hr;
}

HRESULT _HrSaveExcptIntoReg(HKEY hkeyRoot, LPSTR pszKeyname, RULEADDRLIST * pralItem)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyItem = NULL;
    DWORD       dwDisp = 0;
    ULONG       cbData = 0;

    Assert(NULL != hkeyRoot);
    Assert(NULL != pszKeyname);
    Assert(NULL != pralItem);

    // Verify the values
    if (('\0' == pralItem->pszAddr[0]) ||
                ((0 == (pralItem->dwFlags & RALF_MAIL)) &&
                            (0 == (pralItem->dwFlags & RALF_NEWS))))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Create the entry
    lErr = RegCreateKeyEx(hkeyRoot, pszKeyname, 0, NULL,
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyItem, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the flags
    cbData = sizeof(pralItem->dwFlags);
    lErr = RegSetValueEx(hkeyItem, c_szExcptFlags, NULL,
                REG_DWORD, (CONST BYTE *) &(pralItem->dwFlags), cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the exception
    cbData = lstrlen(pralItem->pszAddr) + 1;
    lErr = RegSetValueEx(hkeyItem, c_szException, NULL,
                REG_SZ, (CONST BYTE *) (pralItem->pszAddr), cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyItem)
    {
        RegCloseKey(hkeyItem);
    }
    return hr;
}

COERuleAddrList::~COERuleAddrList()
{    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");

    FreeRuleAddrList(m_pralList, m_cralList);

    SafeMemFree(m_pralList);
    m_cralList = 0;
}

STDMETHODIMP_(ULONG) COERuleAddrList::NondlgAddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COERuleAddrList::NondlgRelease()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COERuleAddrList::NondlgQueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    if (riid == IID_IUnknown)
    {
        *ppvObject = static_cast<IOENondlgUnk *>(this);
    }
    else if (riid == IID_IOERuleAddrList)
    {
        *ppvObject = static_cast<IOERuleAddrList *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERuleAddrList::GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList)
{
    HRESULT         hr = S_OK;
    RULEADDRLIST *  pralListNew = NULL;
    ULONG           ulIndex = 0;
    RULEADDRLIST *  pralListWalk = NULL;
    
    // Check the incoming params
    if ((NULL == ppralList) || (NULL == pcralList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Do we have anything to copy
    if (0 != m_cralList)
    {
        // Create space to hold all the new items
        hr = HrAlloc((VOID **) &pralListNew, m_cralList * (sizeof(*pralListNew)));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the memory
        ZeroMemory(pralListNew, m_cralList * (sizeof(*pralListNew)));

        // Copy over each new address
        for (ulIndex = 0, pralListWalk = m_pralList; ulIndex < m_cralList; ulIndex++, pralListWalk++)
        {
            // Copy over the flags
            pralListNew[ulIndex].dwFlags = pralListWalk->dwFlags;

            // Copy over the address
            pralListNew[ulIndex].pszAddr = PszDupA(pralListWalk->pszAddr);
            if (NULL == pralListNew[ulIndex].pszAddr)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    // Save off the new items
    *ppralList = pralListNew;
    pralListNew = NULL;
    *pcralList = m_cralList;

    // Set the return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralListNew, m_cralList);
    SafeMemFree(pralListNew);
    return hr;
}

STDMETHODIMP COERuleAddrList::SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList)
{
    HRESULT         hr = S_OK;
    RULEADDRLIST *  pralListNew = NULL;
    ULONG           ulIndex = 0;
    
    // Check the incoming params
    if ((NULL == pralList) && (0 != cralList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Do we have anything to copy
    if (0 != cralList)
    {
        // Create space to hold all the new items
        hr = HrAlloc((VOID **) &pralListNew, cralList * (sizeof(*pralListNew)));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the memory
        ZeroMemory(pralListNew, cralList * (sizeof(*pralListNew)));

        // Copy over each new address
        for (ulIndex = 0; ulIndex < cralList; ulIndex++, pralList++)
        {
            // Copy over the flags
            pralListNew[ulIndex].dwFlags = pralList->dwFlags;

            // Copy over the address
            pralListNew[ulIndex].pszAddr = PszDupA(pralList->pszAddr);
            if (NULL == pralListNew[ulIndex].pszAddr)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    // Free up the old items
    FreeRuleAddrList(m_pralList, m_cralList);
    SafeMemFree(m_pralList);

    // Save off the new items
    m_pralList = pralListNew;
    pralListNew = NULL;
    m_cralList = cralList;

    // Mark the list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralListNew, cralList);
    SafeMemFree(pralListNew);
    return hr;
}

STDMETHODIMP COERuleAddrList::Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pMsgInfo) && (NULL == pIMMsg))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we haven't been initialized yet
    if (0 == (m_dwState & STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Search through each address for a match
    for (ulIndex = 0; ulIndex < m_cralList; ulIndex++)
    {
        // Is this the same type?
        if (0 != (dwFlags & m_pralList[ulIndex].dwFlags))
        {
            // If it exists in the Message info
            if (S_OK == RuleUtil_HrMatchSender(m_pralList[ulIndex].pszAddr, pMsgInfo, pIMMsg, NULL))
            {                
                break;
            }
        }
    }

    // Set the proper return value
    hr = (ulIndex < m_cralList) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP COERuleAddrList::LoadList(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = ERROR_SUCCESS;
    HKEY            hkeyRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           dwVer = 0;
    ULONG           cbData = 0;
    ULONG           cExcpts = 0;
    RULEADDRLIST *  pralList = NULL;
    CHAR            rgchKeyname[CCH_EXCPT_KEYNAME_MAX];
    ULONG           ulIndex = 0;
    
    // Check incoming params
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & STATE_LOADED), "We're already loaded!!!");
    
    // Open the registry location
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the version
    cbData = sizeof(dwVer);
    lErr = RegQueryValueEx(hkeyRoot, c_szExcptVersion, NULL, NULL, (BYTE *) &dwVer, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the version if it didn't exist
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwVer = RULEADDRLIST_VERSION;
        lErr = RegSetValueEx(hkeyRoot, c_szExcptVersion, 0, REG_DWORD, (CONST BYTE *) &dwVer, sizeof(dwVer));
        if (ERROR_SUCCESS != lErr)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            goto exit;
        }
    }

    Assert(RULEADDRLIST_VERSION == dwVer);
    
    // Get the total number of entries
    cbData = sizeof(cExcpts);
    lErr = RegQueryInfoKey(hkeyRoot, NULL, NULL, NULL, &cExcpts, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Is there something to do...
    if (0 != cExcpts)
    {
        // Allocate space to hold the entries
        hr = HrAlloc((VOID **) &pralList, cExcpts * sizeof(*pralList));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the Exception List
        ZeroMemory(pralList, cExcpts * sizeof(*pralList));
        
        // For each entry
        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            // Get the key for the entry
            cbData = sizeof(rgchKeyname);
            lErr = RegEnumKeyEx(hkeyRoot, ulIndex, rgchKeyname, &cbData, NULL, NULL, NULL, NULL);
            if ((ERROR_SUCCESS != lErr) && (ERROR_NO_MORE_ITEMS != lErr))
            {
                hr = HRESULT_FROM_WIN32(lErr);
                goto exit;
            }

            // If we've ran out of entries, we're done
            if (ERROR_NO_MORE_ITEMS == lErr)
            {
                break;
            }
            
            // Load the item
            hr = _HrLoadExcptFromReg(hkeyRoot, rgchKeyname, &(pralList[ulIndex]));
            if (FAILED(hr))
            {
                goto exit;
            }
        }
    }
    
    // Free up any old items
    FreeRuleAddrList(m_pralList, m_cralList);
    SafeMemFree(m_pralList);
    m_cralList = 0;

    // Save off the list
    m_pralList = pralList;
    pralList = NULL;
    m_cralList = cExcpts;
    
    // Make sure we clear the dirty bit
    m_dwState &= ~STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= STATE_LOADED;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralList, cExcpts);
    SafeMemFree(pralList);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERuleAddrList::SaveList(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwVer = 0;
    ULONG       ulIndex = 0;
    ULONG       cExcpts = 0;
    ULONG       cbData = 0;
    CHAR        rgchKeyname[CCH_EXCPT_KEYNAME_MAX];

    // Check incoming params
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the registry location
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the version
    dwVer = RULEADDRLIST_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szExcptVersion, 0, REG_DWORD, (CONST BYTE *) &dwVer, sizeof(dwVer));
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }
    
    // Get the total number of sub keys
    cbData = sizeof(cExcpts);
    lErr = RegQueryInfoKey(hkeyRoot, NULL, NULL, NULL, &cExcpts, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Delete any old entries
    for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
    {
        // Get the name of the next sub key
        cbData = sizeof(rgchKeyname);
        lErr = RegEnumKeyEx(hkeyRoot, ulIndex, rgchKeyname, &cbData, NULL, NULL, NULL, NULL);        
        if (ERROR_NO_MORE_ITEMS == lErr)
        {
            break;
        }

        // If the key exists
        if (ERROR_SUCCESS == lErr)
        {
            // Delete the sub key
            SHDeleteKey(hkeyRoot, rgchKeyname);
        }
    }
    
    // For each entry
    for (ulIndex = 0; ulIndex < m_cralList; ulIndex++)
    {
        // Get the key for the entry
        wnsprintf(rgchKeyname, ARRAYSIZE(rgchKeyname), "%08X", ulIndex);

        // Load the item
        hr = _HrSaveExcptIntoReg(hkeyRoot, rgchKeyname, &(m_pralList[ulIndex]));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Should we clear out the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERuleAddrList::Clone(IOERuleAddrList ** ppIAddrList)
{
    HRESULT             hr = S_OK;
    COERuleAddrList *   pAddrList = NULL;
    
    // Check incoming params
    if (NULL == ppIAddrList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIAddrList = NULL;
    
    // Create a new Address list
    pAddrList = new COERuleAddrList;
    if (NULL == pAddrList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule address list
    hr = pAddrList->HrInit(m_dwFlags, m_pIUnkOuter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Copy over the list of addresses
    hr = pAddrList->SetList(0, m_pralList, m_cralList);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the Address list interface
    hr = pAddrList->QueryInterface(IID_IOERuleAddrList, (void **) ppIAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }

    pAddrList = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pAddrList)
    {
        delete pAddrList;
    }
    return hr;
}

HRESULT COERuleAddrList::HrInit(DWORD dwFlags, IUnknown * pIUnkOuter)
{
    HRESULT             hr = S_OK;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // Deal with the IUnknown
    if (NULL == pIUnkOuter)
    {
        m_pIUnkOuter = reinterpret_cast<IUnknown *>
                            (static_cast<IOENondlgUnk *> (this));
    }
    else
    {
        m_pIUnkOuter = pIUnkOuter;
    }
    
    // Mark it as initialized
    m_dwState |= STATE_INIT;
    
    // Set the proper return value
    hr = S_OK;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\aplyrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  AplyRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "aplyrule.h"
#include "ruledesc.h"
#include "rulesui.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <newfldr.h>
#include <storutil.h>
#include "shlwapip.h" 
#include <xpcomm.h>
#include <demand.h>

// Global data
const static HELPMAP g_rgCtxMapApplyMail[] = {
                        {idlvRulesApplyList,        idhRulesList},
                        {idcApplyRulesAll,          idhApplyRulesAll},
                        {idcApplyRulesNone,         idhApplyRulesNone},
                        {idredtApplyDescription,    idhApplyDescription},
                        {idcApplyFolder,            idhApplyFolder},
                        {idcBrowseApplyFolder,      idhBrowseApplyFolder},
                        {idcRulesApplySubfolder,    idhApplySubfolder},
                        {idcRulesApply,             idhApplyNow},
                        {0, 0}};

COEApplyRulesUI::~COEApplyRulesUI()
{
    RULENODE *  prnodeWalk = NULL;
    
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }

    // Free up any rules
    while (NULL != m_prnodeList)
    {
        prnodeWalk = m_prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        m_prnodeList = m_prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }
}

HRESULT COEApplyRulesUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, RULENODE * prnode, IOERule * pIRuleDef)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_typeRule = typeRule;

    m_pIRuleDef = pIRuleDef;
    
    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // We own the list now...
    m_prnodeList = prnode;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEApplyRulesUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRuleApplyTo),
                                        m_hwndOwner, COEApplyRulesUI::FOEApplyRulesDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEApplyRulesUI::FOEApplyRulesDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEApplyRulesUI *       pApplyRulesUI = NULL;
    HWND                    hwndRE = 0;

    pApplyRulesUI = (COEApplyRulesUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pApplyRulesUI = (COEApplyRulesUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pApplyRulesUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtApplyDescription);

            if (!hwndRE || (FALSE == pApplyRulesUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pApplyRulesUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_DESTROY:
            fRet = pApplyRulesUI->FOnDestroy();
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapApplyMail);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the mail rules UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    TCHAR               szRes[CCHMAX_STRINGRES];
    FOLDERID            idDefault;
    FOLDERINFO          fldinfo = {0};
    BOOL                fEnable = FALSE;
    IEnumerateFolders * pChildren=NULL;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvRulesApplyList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtApplyDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }

    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, RDF_READONLY | RDF_APPLYDLG)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Figure out the default folder to select
    if (RULE_TYPE_MAIL == m_typeRule)
    {
        if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fldinfo)))
        {
        
            idDefault = fldinfo.idFolder;
        }
        else
        {
            idDefault = FOLDERID_LOCAL_STORE;
        }
    }
    else
    {
        // Get default news server from accoutn manager
        if (FAILED(GetDefaultServerId(ACCT_NEWS, &idDefault)))
        {
                idDefault = FOLDERID_ROOT;
                m_dwState |= STATE_NONEWSACCT;
        }
        else
        {
            if ((SUCCEEDED(g_pStore->EnumChildren(idDefault, TRUE, &pChildren))) &&
                    (S_OK == pChildren->Next(1, &fldinfo, NULL)))
            {
                idDefault = fldinfo.idFolder;
            }
        }
    }

    if (FAILED(InitFolderPickerEdit(GetDlgItem(m_hwndDlg, idcApplyFolder), idDefault)))
    {
        fRet = FALSE;
        goto exit;
    }

    // What should the default subfolder state be?
    fEnable = TRUE;
    if ((FOLDERID_ROOT == idDefault) || (FOLDERID_LOCAL_STORE == idDefault) || (0 != (fldinfo.dwFlags & FOLDER_SERVER)))
    {
        CheckDlgButton(m_hwndDlg, idcRulesApplySubfolder, BST_CHECKED);
        fEnable = FALSE;
    }
    else if (0 == (fldinfo.dwFlags & FOLDER_HASCHILDREN))
    {
        CheckDlgButton(m_hwndDlg, idcRulesApplySubfolder, BST_UNCHECKED);
        fEnable = FALSE;
    }
                    
    // Should the subfolder button be enabled?
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApplySubfolder, fEnable);
    
    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Get the proper title string
    AthLoadString((RULE_TYPE_MAIL == m_typeRule) ? idsRulesApplyMail : idsRulesApplyNews, szRes, ARRAYSIZE(szRes));
    
    // Set the proper window text
    SetWindowText(m_hwndDlg, szRes);
    
    // Note that we've been loaded
    m_dwState |= STATE_LOADED;

    // Everything's AOK
    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&fldinfo);
    SafeRelease(pChildren);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL                fRet = FALSE;
    FOLDERINFO          fldinfo;
    HWND                hwndFolder = NULL;
    FOLDERID            idFolder;
    BOOL                fEnable;
    FOLDERDIALOGFLAGS   dwFlags = 0;
    INT                 cItems = 0;
    INT                 iSelected = 0;
    CHAR                rgchTitle[CCHMAX_STRINGRES];

    switch (iCtl)
    {
        case IDCANCEL:
            if (FALSE != _FOnClose())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;
            
        case idcBrowseApplyFolder:
            if (BN_CLICKED == uiNotify )
            {
                dwFlags = TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_NONEWFOLDERS;
                if (RULE_TYPE_MAIL == m_typeRule)
                {
                    dwFlags |= TREEVIEW_NONEWS;
                }
                else
                {
                    dwFlags |= TREEVIEW_NOLOCAL;
                }

                AthLoadString(idsApplyRuleTitle, rgchTitle, sizeof(rgchTitle));
                
                if (SUCCEEDED(PickFolderInEdit(m_hwndDlg, GetDlgItem(m_hwndDlg, idcApplyFolder), dwFlags, rgchTitle, NULL, &idFolder)))
                {
                    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &fldinfo)))
                    {
                        if ((0 != (fldinfo.dwFlags & FOLDER_SERVER)) || (FOLDERID_ROOT == fldinfo.idFolder))
                        {
                            SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder,
                                        BM_SETCHECK, (WPARAM) BST_CHECKED, (LPARAM) 0);
                        }
                        else if (0 == (fldinfo.dwFlags & FOLDER_HASCHILDREN))
                        {
                            SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder,
                                        BM_SETCHECK, (WPARAM) BST_UNCHECKED, (LPARAM) 0);
                        }
                    
                        fEnable = (0 != (fldinfo.dwFlags & FOLDER_HASCHILDREN)) &&
                                            (0 == (fldinfo.dwFlags & FOLDER_SERVER)) && (FOLDERID_ROOT != fldinfo.idFolder);

                        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApplySubfolder, fEnable);
                    
                        g_pStore->FreeRecord(&fldinfo);
                    
                        fRet = TRUE;
                    }
                }
            }
            break;

        case idcRulesApply:
            // Check to see if we should handle this
            if (0 != (m_dwState & STATE_NONEWSACCT))
            {
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), 
                              MAKEINTRESOURCEW(idsApplyRulesNoNewsFolders), NULL, MB_OK | MB_ICONERROR);
                fRet = FALSE;
            }
            else
            {
                fRet = _FOnApplyRules();
            }
            break;

        case idcApplyRulesAll:
        case idcApplyRulesNone:
            if (NULL != m_hwndList)
            {
                cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
                if (LB_ERR != cItems)
                {
                    fEnable = (idcApplyRulesAll == iCtl);
                    SendMessage(m_hwndList, LB_SELITEMRANGE, (WPARAM) fEnable, (LPARAM) MAKELPARAM(0, cItems));

                    // Set the focus on the first item
                    SendMessage(m_hwndList, LB_SETCARETINDEX, (WPARAM) 0, (LPARAM) MAKELPARAM(FALSE, 0));

                    // Enable the buttons
                    _EnableButtons(0);
                }
            }
            break;

        case idlvRulesApplyList:
            if (LBN_SELCHANGE == uiNotify)
            {
                iSelected = (INT) SendMessage(hwndCtl, LB_GETCARETINDEX, (WPARAM) 0, (LPARAM) 0);

                // Enable the buttons
                _EnableButtons(iSelected);
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnDestroy(VOID)
{
    BOOL		fRet = FALSE;
    INT			cRules = 0;
    INT			iIndex = 0;
    DWORD_PTR	dwData = 0;

    Assert(m_hwndList);
    
    // Get the number of rules in the list view
    cRules = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Release each of the rules from the list view
    for (iIndex = 0; iIndex < cRules; iIndex++)
    {        
        // Get the rule interface
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) iIndex, (LPARAM) 0);
        if ((LB_ERR == dwData) || (NULL == dwData))
        {
            continue;
        }
        
        // Release the rule
        ((IOERule *) (dwData))->Release();
    }

exit:
    return fRet;
}

BOOL COEApplyRulesUI::_FOnClose(VOID)
{
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULENODE *      prnodeWalk = NULL;
    INT             iDefault = 0;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add each filter to the list
    dwListIndex = 0;

    while (NULL != m_prnodeList)
    {
        // Add rule to the list
        if (NULL != m_prnodeList->pIRule)
        {
            if (FALSE != _FAddRuleToList(dwListIndex, m_prnodeList->pIRule))
            {
                if (m_pIRuleDef == m_prnodeList->pIRule)
                {
                    iDefault = dwListIndex;
                }
                dwListIndex++;
            }

            m_prnodeList->pIRule->Release();
        }

        prnodeWalk = m_prnodeList;
        
        m_prnodeList = m_prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }

    if (0 != dwListIndex)
    {
        // Select the default 
        SendMessage(m_hwndList, LB_SETSEL, (WPARAM) TRUE, (LPARAM) iDefault);

        // Set the focus on the item also
        SendMessage(m_hwndList, LB_SETCARETINDEX, (WPARAM) iDefault, (LPARAM) MAKELPARAM(FALSE, 0));
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != dwListIndex) ? iDefault : -1);

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FAddRuleToList(DWORD dwIndex, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Insert the rule name
    dwIndex = (DWORD) SendMessage(m_hwndList, LB_INSERTSTRING, (WPARAM) dwIndex, (LPARAM) propvar.pszVal);
    if (LB_ERR == dwIndex)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the rule into the item
    if (LB_ERR == SendMessage(m_hwndList, LB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) pIRule))
    {
        fRet = FALSE;
        goto exit;
    }

    // Hold a reference to the rule object
    pIRule->AddRef();
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Mail rules UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEApplyRulesUI::_EnableButtons(INT iSelected)
{
    BOOL    fRet = FALSE;
    INT     cRules = 0;
    INT     cRulesSel = 0;
    
    // How many rules do we have?
    cRules = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRules)
    {
        fRet = TRUE;
        goto exit;
    }
    
    if (0 != cRules)
    {
        // How many rules are selected?
        cRulesSel = (INT) SendMessage(m_hwndList, LB_GETSELCOUNT, (WPARAM) 0, (LPARAM) 0);
        if (LB_ERR == cRulesSel)
        {
            fRet = TRUE;
            goto exit;
        }
    }
    
    // Load the description field
    _LoadRule(iSelected);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApply, cRulesSel != 0);

    // Enable the selection buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcApplyRulesNone, cRules != 0);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcApplyRulesAll, cRules != 0);

    // Set the return value
    fRet = TRUE;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadRule
//
//  This loads the selected rule into the description field.
//  If there isn't a selected rule, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEApplyRulesUI::_LoadRule(INT iSelected)
{
    DWORD_PTR   dwData = 0;
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) iSelected, (LPARAM) 0);
        if (LB_ERR != dwData)
        {
            pIRule = (IOERule *) (dwData);
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(m_typeRule, pIRule);

    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnApplyTo
//
//  This applies the rules into a folder
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FOnApplyRules(VOID)
{
    BOOL                fRet = FALSE;
    FOLDERID            idFolder = 0;
    INT                 cRulesAlloc = 0;
    INT *               piItems = NULL;
    INT                 cRules = 0;
    INT                 iIndex = 0;
    DWORD_PTR           dwData = 0;
    RULENODE *          prnodeList = NULL;
    RULENODE *          prnodeWalk = NULL;
    RULENODE *          prnodeNew = NULL;
    CExecRules *        pExecRules = NULL;
    IOEExecRules *      pIExecRules = NULL;
    RECURSEAPPLY        rapply;
    DWORD               dwFlags;
    CProgress *         pProgress = NULL;
    ULONG               cMsgs = 0;
    FOLDERINFO          infoFolder = {0};
    CHAR                rgchTmpl[CCHMAX_STRINGRES];
    LPSTR               pszText = NULL;
    HRESULT             hr = S_OK;
#ifdef DEBUG
    DWORD               dwTime = 0;
#endif  // DEBUG
    
    Assert(NULL != m_hwndList);
    
    idFolder = _FldIdGetFolderSel();
    
    // Get the count of rules
    cRulesAlloc = (INT) SendMessage(m_hwndList, LB_GETSELCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRulesAlloc)
    {
        fRet = FALSE;
        goto exit;
    }

    // Is there anything to do?
    if (0 == cRulesAlloc)
    {
        fRet = TRUE;
        goto exit;
    }

    // Allocate space tp hold the list of items
    if (FAILED(HrAlloc((VOID **) &piItems, sizeof(*piItems) * cRulesAlloc)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab the list of items
    cRules = (INT) SendMessage(m_hwndList, LB_GETSELITEMS, (WPARAM) cRulesAlloc, (LPARAM) piItems);
    if (LB_ERR == cRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab each of the enabled rules
    for (iIndex = 0; iIndex < cRules; iIndex++)
    {
        // Get the rule from the list
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) piItems[iIndex], (LPARAM) 0);
        if ((LB_ERR == dwData) || (NULL == dwData))
        {
            continue;
        }
        
        // Save the rule
        prnodeNew = new RULENODE;
        if (NULL == prnodeNew)
        {
            continue;
        }

        prnodeNew->pIRule = (IOERule *) dwData;
        prnodeNew->pIRule->AddRef();

        if (NULL == prnodeWalk)
        {
            prnodeList = prnodeNew;
            prnodeWalk = prnodeList;
        }
        else
        {
            prnodeWalk->pNext = prnodeNew;
            prnodeWalk = prnodeWalk->pNext;
        }
        prnodeNew = NULL;
        prnodeWalk->pNext = NULL;
    }
    
    // If we don't have any rules then just return
    if (NULL == prnodeList)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Create the executor object
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize it with the list of rules
    if (FAILED(pExecRules->_HrInitialize(0, prnodeList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab the executor interface
    if (FAILED(pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules)))
    {
        fRet = FALSE;
        goto exit;
    }
    pExecRules = NULL;
    
    // Apply to rule to the folder
    rapply.pIExecRules = pIExecRules;

    dwFlags = RECURSE_INCLUDECURRENT;

    if (RULE_TYPE_MAIL == m_typeRule)
    {
        dwFlags |= RECURSE_ONLYLOCAL;
    }
    else
    {
        dwFlags |= RECURSE_ONLYNEWS;
    }
                
    if (BST_CHECKED == SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder, BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
    {
        dwFlags |= RECURSE_SUBFOLDERS;
    }
    
    if (FAILED(RecurseFolderHierarchy(idFolder, dwFlags, 0, (DWORD_PTR)&cMsgs, (PFNRECURSECALLBACK)RecurseFolderCounts)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        fRet = FALSE;
        goto exit;
    }

    pProgress->Init(m_hwndDlg, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cMsgs, 0, TRUE, FALSE);

    // Show the progress dialog
    pProgress->Show(0);

    rapply.pProgress = pProgress;
    rapply.hwndOwner = pProgress->GetHwnd();

#ifdef DEBUG
    dwTime = GetTickCount();
#endif  // DEBUG

    // Set up the timer
    hr = RecurseFolderHierarchy(idFolder, dwFlags, 0, (DWORD_PTR) &rapply, (PFNRECURSECALLBACK)_HrRecurseApplyFolder);

#ifdef DEBUG
    // Time to Apply Rules
    TraceInfo(_MSG("Applying Rules Time: %d Milli-Seconds", GetTickCount() - dwTime));
#endif  // DEBUG

    // Close the progress window
    pProgress->Close();

    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the template string
    AthLoadString(idsApplyRulesFinished, rgchTmpl, sizeof(rgchTmpl));

    // Get the name of the folder
    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &infoFolder)))
    {
        // Allocate space to hold the final string
        DWORD cchSize = (sizeof(rgchTmpl) * lstrlen(infoFolder.pszName));
        if (SUCCEEDED(HrAlloc((VOID **) &pszText, cchSize * sizeof(*pszText))))
        {
            // Build up the final string
            wnsprintf(pszText, cchSize, rgchTmpl, infoFolder.pszName);
            
            // Show confirmation dialog
            AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthena), pszText, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pProgress);
    SafeRelease(pIExecRules);
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; //MemFree(prnodeNew);
    }
    SafeMemFree(piItems);
    if (FALSE == fRet)
    {
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsRulesApplyFail), NULL, MB_OK | MB_ICONERROR);
    }
    return fRet;
}

FOLDERID COEApplyRulesUI::_FldIdGetFolderSel(VOID)
{
    return(GetFolderIdFromEdit(GetDlgItem(m_hwndDlg, idcApplyFolder)));
}

// --------------------------------------------------------------------------------
HRESULT COEApplyRulesUI::_HrRecurseApplyFolder(FOLDERINFO * pfldinfo, BOOL fSubFolders,
    DWORD cIndent, DWORD_PTR dwpCookie)
{
    HRESULT             hr = S_OK;
    RECURSEAPPLY *      prapply = NULL;
    IMessageFolder *    pFolder = NULL;

    prapply = (RECURSEAPPLY *) dwpCookie;

    if (NULL == prapply)
    {
        goto exit;
    }

    // If not hidden
    if ((0 != (pfldinfo->dwFlags & FOLDER_HIDDEN)) || (FOLDERID_ROOT == pfldinfo->idFolder))
    {
        goto exit;
    }

    // Not Subscribed
    if (0 == (pfldinfo->dwFlags & FOLDER_SUBSCRIBED))
    {
        goto exit;
    }

    // Server node
    if (0 != (pfldinfo->dwFlags & FOLDER_SERVER))
    {
        goto exit;
    }

    hr = g_pStore->OpenFolder(pfldinfo->idFolder, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the struct to insert
    hr = RuleUtil_HrApplyRulesToFolder(RULE_APPLY_SHOWUI, (FOLDER_LOCAL != pfldinfo->tyFolder) ? DELETE_MESSAGE_NOTRASHCAN : 0,
                    prapply->pIExecRules, pFolder, prapply->hwndOwner, prapply->pProgress);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the user hit cancel then we're done
    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    
exit:
    SafeRelease(pFolder);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\junkrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  JunkRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "msoejunk.h"
#include "addrrule.h"

class COEJunkRule : public IOERule
{
    private:  
        enum
        {
            RULE_STATE_UNINIT       = 0x00000000,
            RULE_STATE_INIT         = 0x00000001,
            RULE_STATE_LOADED       = 0x00000002,
            RULE_STATE_DIRTY        = 0x00000004,
            RULE_STATE_DISABLED     = 0x00000008,
            RULE_STATE_INVALID      = 0x00000010,
            RULE_STATE_EXCPT_WAB    = 0x00000020,
            RULE_STATE_DATA_LOADED  = 0x00000040
        };    

        enum {RULE_VERSION = 0x00050000};
        
    private:
        LONG                m_cRef;
        DWORD               m_dwState;
        HINSTANCE           m_hinst;
        IOEJunkFilter *     m_pIJunkFilter;
        DWORD               m_dwJunkPct;
        IOERuleAddrList *   m_pIAddrList;
        IUnknown *          m_pIUnkInner;
        LPSTR               m_pszJunkDll;
        LPSTR               m_pszDataFile;
    
    public:
        // Constructor/destructor
        COEJunkRule() : m_cRef(0), m_dwState(RULE_STATE_NULL), m_hinst(NULL),
                        m_pIJunkFilter(NULL), m_dwJunkPct(2), m_pIAddrList(NULL),
                        m_pIUnkInner(NULL), m_pszJunkDll(NULL), m_pszDataFile(NULL) {}
        ~COEJunkRule();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IRule members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP Validate(DWORD dwFlags) {return S_OK;}
        
        STDMETHODIMP GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult);
        STDMETHODIMP SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarValue);

        STDMETHODIMP Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions);

        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOERule ** ppIRule);                            

        HRESULT HrInit(LPCSTR pszJunkDll, LPCSTR pszDataFile);

    private:
        HRESULT _HrGetDefaultActions(ACT_ITEM * pAct, ULONG cAct);
        HRESULT _HrSetSpamThresh(VOID);
        HRESULT _HrGetSpamFlags(LPCSTR pszAcct, IMimeMessage * pIMMsg, DWORD * pdwFlags);
        HRESULT _HrIsSenderInWAB(IMimeMessage * pIMMsg);
        HRESULT _HrLoadJunkFilter(VOID);
};

HRESULT HrCreateJunkRule(IOERule ** ppIRule);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\junkrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  JunkRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "junkrule.h"
#include "msoejunk.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"
#include <ipab.h>
#include <shlwapip.h>

typedef HRESULT (WINAPI * TYP_HrCreateJunkFilter) (DWORD dwFlags, IOEJunkFilter ** ppIJunkFilter);

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateJunkRule
//
//  This creates a junk rule.
//
//  ppIRule - pointer to return the junk rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the JunkRule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateJunkRule(IOERule ** ppIRule)
{
    COEJunkRule *   pRule = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIRule = NULL;

    // Create the rules manager object
    pRule = new COEJunkRule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Note that we have a reference
    pRule->AddRef();
    
    // Initialize the junk rule
    hr = pRule->HrInit(c_szJunkDll, c_szJunkFile);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules manager interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pRule);    
    return hr;
}

COEJunkRule::~COEJunkRule()
{
    IUnknown *  pIUnkOuter = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");

    // Prevent recursive destruction on the next
    // AddRef/Release pair
    if (NULL != m_pIAddrList)
    {
        m_cRef = 1;

        // Counter the Release call in the creation function
        pIUnkOuter = this;
        pIUnkOuter->AddRef();

        // Release the aggregated interface
        m_pIAddrList->Release();
        m_pIAddrList = NULL;
    }
    
    SafeRelease(m_pIUnkInner);
    SafeRelease(m_pIJunkFilter);
    SafeMemFree(m_pszJunkDll);
    SafeMemFree(m_pszDataFile);
    if (NULL != m_hinst)
    {
        FreeLibrary(m_hinst);
    }
}

STDMETHODIMP_(ULONG) COEJunkRule::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COEJunkRule::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COEJunkRule::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERule))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_IOERule)
    {
        *ppvObject = static_cast<IOERule *>(this);
    }
    else if (riid == IID_IOERuleAddrList)
    {
        *ppvObject = m_pIAddrList;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::Reset(void)
{
    HRESULT     hr = S_OK;

    // Set the current state
    m_dwState |= RULE_STATE_INIT;

    // Clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Set the return value
    hr = S_OK;
    
    return hr;
}

STDMETHODIMP COEJunkRule::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we're not enabled
    if ((0 != (m_dwState & RULE_STATE_DISABLED)) || (0 != (m_dwState & RULE_STATE_INVALID)))
    {
        *pdwState = RULE_STATE_NULL;
    }
    else
    {
        *pdwState = CRIT_STATE_ALL | ACT_STATE_LOCAL;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    LPSTR       pszName = NULL;
    CRIT_ITEM * pCrit = NULL;
    ACT_ITEM *  pAct = NULL;
    ULONG       cItem = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    
    switch(prop)
    {
      case RULE_PROP_NAME:
        // Get the name
        szRes[0] = '\0';
        LoadString(g_hLocRes, idsJunkMail, szRes, ARRAYSIZE(szRes));
        
        pszName = PszDupA(szRes);
        pvarResult->vt = VT_LPSTR;
        pvarResult->pszVal = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(m_dwState & RULE_STATE_DISABLED);
        break;
        
      case RULE_PROP_CRITERIA:
        pCrit = new CRIT_ITEM;
        if (NULL == pCrit)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        ZeroMemory(pCrit, sizeof(*pCrit));
        
        pCrit->type = CRIT_TYPE_JUNK;
        pCrit->logic = CRIT_LOGIC_AND;
        pCrit->dwFlags = CRIT_FLAG_DEFAULT;
        pCrit->propvar.vt = VT_EMPTY;

        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = sizeof(CRIT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pCrit;
        pCrit = NULL;
        break;
        
      case RULE_PROP_ACTIONS:
        pAct = new ACT_ITEM;
        if (NULL == pAct)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = _HrGetDefaultActions(pAct, 1);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = sizeof(ACT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pAct;
        pAct = NULL;
        break;
        
      case RULE_PROP_JUNKPCT:
        pvarResult->vt = VT_UI4;
        pvarResult->ulVal = m_dwJunkPct;
        break;
        
      case RULE_PROP_EXCPT_WAB:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(0 != (m_dwState & RULE_STATE_EXCPT_WAB));
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    RuleUtil_HrFreeCriteriaItem(pCrit, 1);
    SafeMemFree(pCrit);
    RuleUtil_HrFreeActionsItem(pAct, cItem);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COEJunkRule::SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    switch(prop)
    {
      case RULE_PROP_DISABLED:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_DISABLED;
        }
        else
        {
            Assert(0 == (m_dwState & RULE_STATE_INVALID));
            m_dwState &= ~RULE_STATE_DISABLED;
        }
        break;

      case RULE_PROP_JUNKPCT:
        if (VT_UI4 != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        m_dwJunkPct = pvarResult->ulVal;
        break;
                
      case RULE_PROP_EXCPT_WAB:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_EXCPT_WAB;
        }
        else
        {
            m_dwState &= ~RULE_STATE_EXCPT_WAB;
        }
        break;

      default:
        hr = E_INVALIDARG;
        goto exit;
    }

    // Mark the rule as dirty
    m_dwState |= RULE_STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT             hr = S_OK;
    DOUBLE              dblProb = 0.0;
    ACT_ITEM *          pAct = NULL;
    ULONG               cAct = 0;
    DWORD               dwFlags = 0;
    IMimeMessage *      pIMMsgNew = NULL;
    
    // Check incoming variables
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || ((NULL == pIMMsg) && ((NULL == pMsgInfo) || (NULL == pFolder))) ||
                (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set outgoing params to default
    *ppActions = NULL;
    *pcActions = 0;

    // Load up the junk mail filter
    hr = _HrLoadJunkFilter();
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Set the spam threshold
    hr = _HrSetSpamThresh();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (NULL != pIMMsg)
    {
        // Hold onto the message
        pIMMsgNew = pIMMsg;
        pIMMsgNew->AddRef();
    }
    else
    {
        // Get the message
        hr = pFolder->OpenMessage(pMsgInfo->idMessage, 0, &pIMMsgNew, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Do we need to see if this is in the WAB
    if (0 != (m_dwState & RULE_STATE_EXCPT_WAB))
    {
        if (S_OK == _HrIsSenderInWAB(pIMMsgNew))
        {
            hr = S_FALSE;
            goto exit;
        }
    }
    
    // Check to see if it's in the exceptions list
    if (NULL != m_pIAddrList)
    {
        hr = m_pIAddrList->Match(RALF_MAIL, pMsgInfo, pIMMsgNew);
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we found a match then we are done
        if (S_OK == hr)
        {
            hr = S_FALSE;
            goto exit;
        }
    }
    
    // Figure out the proper flags
    hr = _HrGetSpamFlags(pszAcct, pIMMsgNew, &dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Is it Spam?
    hr = m_pIJunkFilter->CalcJunkProb(dwFlags, pIMPropSet, pIMMsgNew, &dblProb);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // If we didn't match then just return
    if (S_FALSE == hr)
    {
        goto exit;
    }

    // Create an action
    pAct = new ACT_ITEM;
    if (NULL == pAct)
    {
        hr = E_FAIL;
        goto exit;
    }

    cAct = 1;
    
    // Grab the actions and return them to the caller
    hr = _HrGetDefaultActions(pAct, cAct);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing parameters
    *ppActions = pAct;
    pAct = NULL;
    *pcActions = cAct;
    
    // Set proper return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pAct, cAct);
    SafeMemFree(pAct);
    SafeRelease(pIMMsgNew);
    return hr;
}

STDMETHODIMP COEJunkRule::LoadReg(LPCSTR pszRegPath)
{
    HRESULT             hr = S_OK;
    LONG                lErr = 0;
    HKEY                hkeyRoot = NULL;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    BOOL                fDisabled = FALSE;
    LPSTR               pszRegPathNew = NULL;
    ULONG               cchRegPath = 0;
    
    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & RULE_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    DWORD cchSize = (cchRegPath + lstrlen(c_szRulesExcpts) + 2);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchSize)))
    {
        goto exit;
    }

    // Build reg path to criteria
    StrCpyN(pszRegPathNew, pszRegPath, cchSize);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        StrCatBuff(pszRegPathNew, g_szBackSlash, cchSize);
        cchRegPath++;
    }

    StrCatBuff(pszRegPathNew, c_szRulesExcpts, cchSize);
    
    // Get the Exceptions List
    hr = m_pIAddrList->LoadList(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the enabled state
    if (FALSE != DwGetOption(OPT_FILTERJUNK))
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }

    // Get the junk percent
    m_dwJunkPct = DwGetOption(OPT_JUNKPCT);

    // Get the WAB Exception state
    if (FALSE != DwGetOption(OPT_EXCEPTIONS_WAB))
    {
        m_dwState |= RULE_STATE_EXCPT_WAB;
    }
    else
    {
        m_dwState &= ~RULE_STATE_EXCPT_WAB;
    }

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEJunkRule::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LPSTR       pszRegPathNew = NULL;
    ULONG       cchRegPath = 0;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't save out a rule if we don't have criteria or actions
    // or a rule name
    if (NULL == m_pIAddrList)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
   
    // Set the enabled state
    SetDwOption(OPT_FILTERJUNK, (DWORD) !(0 != (m_dwState & RULE_STATE_DISABLED)), NULL, 0);

    // Set the junk percent
    SetDwOption(OPT_JUNKPCT, m_dwJunkPct, NULL, 0);

    // Set the WAB Exception state
    SetDwOption(OPT_EXCEPTIONS_WAB, (DWORD) (0 != (m_dwState & RULE_STATE_EXCPT_WAB)), NULL, 0);

    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    DWORD cchSize = (cchRegPath + lstrlen(c_szRulesExcpts) + 2);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchSize)))
    {
        goto exit;
    }

    // Build reg path to criteria
    StrCpyN(pszRegPathNew, pszRegPath, cchSize);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        StrCatBuff(pszRegPathNew, g_szBackSlash, cchSize);
        cchRegPath++;
    }

    StrCatBuff(pszRegPathNew, c_szRulesExcpts, cchSize);
    
    // Write out the Exceptions List
    hr = m_pIAddrList->SaveList(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEJunkRule::Clone(IOERule ** ppIRule)
{
    HRESULT             hr = S_OK;
    COEJunkRule *       pRule = NULL;
    IOERuleAddrList *   pIAddrList = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               cralList = 0;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIRule = NULL;
    
    // Create a new rule
    pRule = new COEJunkRule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Note that we have a reference
    pRule->AddRef();
    
    // Initialize the junk rule
    hr = pRule->HrInit(c_szJunkDll, c_szJunkFile);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the WAB Exception state
    if (0 != (m_dwState & RULE_STATE_DISABLED))
    {
        pRule->m_dwState |= RULE_STATE_DISABLED;
    }
    else
    {
        pRule->m_dwState &= ~RULE_STATE_DISABLED;
    }
    
    // Set the junk percent
    pRule->m_dwJunkPct = m_dwJunkPct;
    
    // Set the WAB Exception state
    if (0 != (m_dwState & RULE_STATE_EXCPT_WAB))
    {
        pRule->m_dwState |= RULE_STATE_EXCPT_WAB;
    }
    else
    {
        pRule->m_dwState &= ~RULE_STATE_EXCPT_WAB;
    }
    
    // Do we have an Exceptions List?
    if (NULL != m_pIAddrList)
    {
        // Get the interface from the new object
        hr = pRule->QueryInterface(IID_IOERuleAddrList, (void **) &pIAddrList);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the list of exceptions
        hr = m_pIAddrList->GetList(0, &pralList, &cralList);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Set the list of exceptions
        hr = pIAddrList->SetList(0, pralList, cralList);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Get the rule interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralList, cralList);
    SafeMemFree(pralList);
    SafeRelease(pIAddrList);
    SafeRelease(pRule);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the junk rule.
//
//  ppIRule - pointer to return the junk rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the JunkRule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRule::HrInit(LPCSTR pszJunkDll, LPCSTR pszDataFile)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pIUnkOuter = NULL;
    IUnknown *              pIUnkInner = NULL;
    IOERuleAddrList *       pIAddrList = NULL;
    
    // Check the incoming params
    if ((NULL == pszJunkDll) || (NULL == pszDataFile))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we've already been initialized
    if (0 != (m_dwState & RULE_STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    Assert(NULL == m_hinst);

    // Safe off the paths
    m_pszJunkDll = PszDupA(pszJunkDll);
    if (NULL == m_pszJunkDll)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    m_pszDataFile = PszDupA(pszDataFile);
    if (NULL == m_pszDataFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Create an address list object
    pIUnkOuter = static_cast<IUnknown *> (this);
    hr = HrCreateAddrList(pIUnkOuter, IID_IUnknown, (void **) &pIUnkInner);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the Rule Address list interface
    hr = pIUnkInner->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Save off the address list
    m_pIAddrList = pIAddrList;

    // Save off the inner IUnknown
    m_pIUnkInner = pIUnkInner;
    pIUnkInner = NULL;
    
    // Note that wab exceptions is on by default
    m_dwState |= RULE_STATE_EXCPT_WAB;
    
    // Note that we have been initialized
    m_dwState |= RULE_STATE_INIT;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pIAddrList)
    {
        SafeRelease(pIUnkOuter);
    }
    SafeRelease(pIUnkInner);
    return hr;
}

HRESULT COEJunkRule::_HrGetDefaultActions(ACT_ITEM * pAct, ULONG cAct)
{
    HRESULT             hr = S_OK;
    FOLDERINFO          fldinfo = {0};
    RULEFOLDERDATA *    prfdData = NULL;
    STOREUSERDATA       UserData = {0};

    // Check incoming vars
    if ((NULL == pAct) || (0 == cAct))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    ZeroMemory(pAct, cAct * sizeof(*pAct));
    
    // Fill up the action
    pAct->type = ACT_TYPE_JUNKMAIL;
    pAct->dwFlags = ACT_FLAG_DEFAULT;
    pAct->propvar.vt = VT_EMPTY;

    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEJunkRule::_HrSetSpamThresh(VOID)
{
    HRESULT hr = S_OK;
    ULONG   ulThresh = 0;

    // If we haven't been loaded
    if (0 == (m_dwState & RULE_STATE_DATA_LOADED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    // Get the threshold
    switch (m_dwJunkPct)
    {
        case 0:
            ulThresh = STF_USE_MOST;
            break;
            
        case 1:
            ulThresh = STF_USE_MORE;
            break;
            
        case 2:
            ulThresh = STF_USE_DEFAULT;
            break;
            
        case 3:
            ulThresh = STF_USE_LESS;
            break;
            
        case 4:
            ulThresh = STF_USE_LEAST;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }

    // Set the threshold
    hr = m_pIJunkFilter->SetSpamThresh(ulThresh);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEJunkRule::_HrGetSpamFlags(LPCSTR pszAcct, IMimeMessage * pIMMsg, DWORD * pdwFlags)
{
    HRESULT         hr = S_OK;
    IImnAccount *   pAccount = NULL;
    CHAR            szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    CHAR            szReplyToAddress[CCHMAX_EMAIL_ADDRESS];
    ADDRESSLIST     rAddrList ={0};
    ULONG           ulIndex = 0;
    BOOL            fFound = FALSE;

    Assert(NULL != g_pAcctMan);

    // Initialize the flags
    *pdwFlags = 0;
    
    // Get the account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcct, &pAccount);
    
    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Get the default address on the account
    if (FAILED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, sizeof(szEmailAddress))))
    {
        szEmailAddress[0] = '\0';
    }

    // Get the reply to address on the account
    if (FAILED(pAccount->GetPropSz(AP_SMTP_REPLY_EMAIL_ADDRESS, szReplyToAddress, sizeof(szReplyToAddress))))
    {
        szReplyToAddress[0] = '\0';
    }

    // Get the addresses
    hr = pIMMsg->GetAddressTypes(IAT_TO | IAT_CC | IAT_BCC, IAP_EMAIL, &rAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search through the address list
    for (ulIndex = 0; ulIndex < rAddrList.cAdrs; ulIndex++)
    {
        // Skip blank addresses
        if (NULL == rAddrList.prgAdr[ulIndex].pszEmail)
        {
            continue;
        }

        // Search for the email address
        if ('\0' != szEmailAddress[0])
        {
            fFound = !!(0 == lstrcmpi(rAddrList.prgAdr[ulIndex].pszEmail, szEmailAddress));
        }

        // Search for the reply to address
        if ((FALSE == fFound) && ('\0' != szReplyToAddress[0]))
        {
            fFound = !!(0 == lstrcmpi(rAddrList.prgAdr[ulIndex].pszEmail, szReplyToAddress));
        }

        if (FALSE != fFound)
        {
            break;
        }
    }
    
    // If we found something
    if (FALSE != fFound)
    {
        *pdwFlags |= CJPF_SENT_TO_ME;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    g_pMoleAlloc->FreeAddressList(&rAddrList);
    SafeRelease(pAccount);
    return hr;
}

HRESULT COEJunkRule::_HrIsSenderInWAB(IMimeMessage * pIMMsg)
{
    HRESULT             hr = S_OK;
    IMimeAddressTable * pIAddrTable = NULL;
    ADDRESSPROPS        rSender = {0};
    LPWAB               pWAB = NULL;
    LPADRBOOK           pAddrBook = NULL;
    LPWABOBJECT         pWabObject = NULL;
    ULONG               cbeidWAB = 0;
    LPENTRYID           peidWAB = NULL;
    ULONG               ulDummy = 0;
    LPABCONT            pabcWAB = NULL;
    ADRLIST *           pAddrList = NULL;
    FlagList            rFlagList = {0};
    
    Assert(NULL != pIMMsg);
    
    // Get the address table from the message
    hr = pIMMsg->GetAddressTable(&pIAddrTable);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the sender of the message
    rSender.dwProps = IAP_EMAIL;
    hr = pIAddrTable->GetSender(&rSender);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }

    // If the sender is empty,
    // then we are done...
    if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get the WAB
    hr = HrCreateWabObject(&pWAB);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the AB object
    hr = pWAB->HrGetAdrBook(&pAddrBook);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWAB->HrGetWabObject(&pWabObject);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the PAB
    hr = pAddrBook->GetPAB(&cbeidWAB, &peidWAB);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the address container
    hr = pAddrBook->OpenEntry(cbeidWAB, peidWAB, NULL, 0, &ulDummy, (IUnknown **) (&pabcWAB));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Allocate space to hold the address list
    hr = pWabObject->AllocateBuffer(sizeof(ADRLIST), (VOID **)&(pAddrList));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the Address list
    Assert(NULL != pAddrList);
    pAddrList->cEntries = 1;
    pAddrList->aEntries[0].ulReserved1 = 0;
    pAddrList->aEntries[0].cValues = 1;

    // Allocate space to hold the address props
    hr = pWabObject->AllocateBuffer(sizeof(SPropValue), (VOID **)&(pAddrList->aEntries[0].rgPropVals));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the address props
    pAddrList->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS;
    pAddrList->aEntries[0].rgPropVals[0].Value.LPSZ = rSender.pszEmail;
    
    // Resolve the sender address
    rFlagList.cFlags = 1;
    hr = pabcWAB->ResolveNames(NULL, WAB_RESOLVE_ALL_EMAILS, pAddrList, &rFlagList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Check to see if it was found
    if ((MAPI_RESOLVED == rFlagList.ulFlag[0]) || (MAPI_AMBIGUOUS == rFlagList.ulFlag[0]))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
        
exit:
    if (pAddrList)
    {
        for (ULONG ul = 0; ul < pAddrList->cEntries; ul++)
            pWabObject->FreeBuffer(pAddrList->aEntries[ul].rgPropVals);
        pWabObject->FreeBuffer(pAddrList);
    }
    SafeRelease(pabcWAB);
    if (NULL != peidWAB)
    {
        pWabObject->FreeBuffer(peidWAB);
    }
    SafeRelease(pWAB);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pIAddrTable);
    return hr;
}

HRESULT COEJunkRule::_HrLoadJunkFilter(VOID)
{
    HRESULT                 hr = S_OK;
    ULONG                   cbData = 0;
    LPSTR                   pszPath = NULL;
    ULONG                   cchPath = 0;
    TYP_HrCreateJunkFilter  pfnHrCreateJunkFilter = NULL;
    IOEJunkFilter *         pIJunk = NULL;
    LPSTR                   pszFirst = NULL;
    LPSTR                   pszLast = NULL;
    LPSTR                   pszCompany = NULL;

    // If we haven't been initialized yet
    if (0 == (m_dwState & RULE_STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we've already been loaded, we're done
    if (0 != (m_dwState & RULE_STATE_DATA_LOADED))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    Assert(NULL != m_pszJunkDll);
    Assert(NULL != m_pszDataFile);
    
    // Get the size of the path to Outlook Express
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, NULL, &cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    // How much room do we need to build up the path
    cbData += max(lstrlen(m_pszJunkDll), lstrlen(m_pszDataFile)) + 2;

    // Allocate space to hold the path
    hr = HrAlloc((VOID **) &pszPath, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the path to Outlook Express
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, (BYTE *) pszPath, &cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Build up the path to the Junk DLL
    StrCatBuff(pszPath, g_szBackSlash, cbData);
    cchPath = lstrlen(pszPath);
    StrCpyN(&(pszPath[cchPath]), m_pszJunkDll, (cbData-cchPath));
    
    // Load the Dll
    Assert(NULL == m_hinst);
    m_hinst = LoadLibrary(pszPath);
    if (NULL == m_hinst)
    {
        AssertSz(FALSE, "Can't find the Dll");
        hr = E_FAIL;
        goto exit;
    }
    
    // Find the entry points
    pfnHrCreateJunkFilter = (TYP_HrCreateJunkFilter) GetProcAddress(m_hinst, c_szHrCreateJunkFilter);
    if (NULL == pfnHrCreateJunkFilter)
    {
        AssertSz(FALSE, "Can't find the function HrCreateJunkFilter");
        hr = E_FAIL;
        goto exit;
    }

    // Get the junk filter
    hr = pfnHrCreateJunkFilter(0, &pIJunk);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the path to the Junk DLL data file
    StrCpyN(&(pszPath[cchPath]), m_pszDataFile, (cbData-cchPath));
    
    // Load the test file
    hr = pIJunk->LoadDataFile(pszPath);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get user specifics
    RuleUtil_HrGetUserData(0, &pszFirst, &pszLast, &pszCompany);
    
    // Set the user specifics
    hr = pIJunk->SetIdentity(pszFirst, pszLast, pszCompany);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save of the data
    m_pIJunkFilter = pIJunk;
    pIJunk = NULL;

    // Note that we've loaded the data
    m_dwState |= RULE_STATE_DATA_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszCompany);
    SafeMemFree(pszLast);
    SafeMemFree(pszFirst);
    SafeRelease(pIJunk);
    SafeMemFree(pszPath);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\aplyrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  AplyRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "rulesmgr.h"

// Forward declarations
class CProgress;
class CRuleDescriptUI;

class COEApplyRulesUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_LOADED        = 0x00000002,
            STATE_NONEWSACCT    = 0x00000004
        };

        enum
        {
            RULE_PAGE_MAIL      = 0x00000000,
            RULE_PAGE_NEWS      = 0x00000001,
            RULE_PAGE_MAX       = 0x00000002,
            RULE_PAGE_MASK      = 0x000000FF
        };
        
        struct RECURSEAPPLY
        {
            IOEExecRules *  pIExecRules;
            HWND            hwndOwner;
            CProgress *     pProgress;
        };
        
    private:
        HWND                    m_hwndOwner;
        DWORD                   m_dwFlags;
        DWORD                   m_dwState;
        HWND                    m_hwndDlg;
        HWND                    m_hwndList;
        HWND                    m_hwndDescript;
        CRuleDescriptUI *       m_pDescriptUI;
        RULENODE *              m_prnodeList;
        RULE_TYPE               m_typeRule;
        IOERule *               m_pIRuleDef;

    public:
        // Constructor/destructor
        COEApplyRulesUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                            m_hwndDlg(NULL), m_hwndList(NULL), m_hwndDescript(NULL),
                            m_pDescriptUI(NULL), m_prnodeList(NULL), m_typeRule(RULE_TYPE_MAIL),
                            m_pIRuleDef(NULL) {}
        ~COEApplyRulesUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, RULENODE * prnode, IOERule * pIRuleDef);
        HRESULT HrShow(VOID);
        
        // Dialog methods
        static INT_PTR CALLBACK FOEApplyRulesDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnDestroy(VOID);
        
        static HRESULT _HrRecurseApplyFolder(FOLDERINFO * pFolder, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);

    private:
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddRuleToList(DWORD dwIndex, IOERule * pIRule);
        VOID _EnableButtons(INT iSelected);

        // For dealing with the description field
        VOID _LoadRule(INT iSelected);

        // Functions to deal with the basic actions
        BOOL _FOnClose(VOID);
        BOOL _FOnApplyRules(VOID);
        FOLDERID _FldIdGetFolderSel(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\criteria.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Criteria.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CRITERIA_H_
#define _CRITERIA_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

class COECriteria : public IOECriteria, IPersistStream
{
    private:
        enum {CRIT_COUNT_MIN = 0, CRIT_COUNT_MAX = 0x1000};

        enum {CCH_CRIT_ORDER = 4};
        
        enum {CRIT_VERSION = 0x00050000};
        
    private:
        LONG        m_cRef;
        CRIT_ITEM * m_rgItems;
        ULONG       m_cItems;
        ULONG       m_cItemsAlloc;
        DWORD       m_dwState;
        
    public:
        // Constructor/destructor
        COECriteria() : m_cRef(0), m_rgItems(NULL), m_cItems(0), m_cItemsAlloc(0), m_dwState(0) {}
        ~COECriteria();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOECriteria members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP GetCriteria(DWORD dwFlags, PCRIT_ITEM * ppItem, ULONG * pcItem);
        STDMETHODIMP SetCriteria(DWORD dwFlags, CRIT_ITEM * pItem, ULONG cItem);
        
        STDMETHODIMP Validate(DWORD dwFlags);
        STDMETHODIMP AppendCriteria(DWORD dwFlags, CRIT_LOGIC logic, CRIT_ITEM * pItem,
                                    ULONG cItem, ULONG * pcItemAppended);
        STDMETHODIMP MatchMessage(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                            IMimeMessage * pIMMsg, ULONG cbMsgSize);

        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOECriteria ** ppICriteria);
                                
        // IPersistStream members
        STDMETHODIMP GetClassID(CLSID * pclsid);
        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(IStream * pStm);
        STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }
};

HRESULT HrCreateCriteria(IOECriteria ** ppICriteria);
#endif  // !_CRITERIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\criteria.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Criteria.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "criteria.h"
#include "ruleutil.h"
#include <xpcomm.h>
#include <flagconv.h>
#include <bodyutil.h>
#include <demand.h>

static const int CRIT_GROW = 16;

BOOL FMatchCritItem(CRIT_ITEM * pItem, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                        IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                        IMimeMessage * pIMMsg, ULONG cbMsgSize);
                        
BOOL FCritLoad_Account(IStream * pIStm, PROPVARIANT * ppropvar);
BOOL FCritSave_Account(IStream * pIStm, PROPVARIANT * ppropvar);

BOOL FCritLoad_Default(IStream * pIStm, PROPVARIANT * ppropvar);
BOOL FCritSave_Default(IStream * pIStm, PROPVARIANT * ppropvar);

DWORD DwGetFlagsFromMessage(IMimeMessage * pIMMsg);

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateCriteria
//
//  This creates a criteria container.
//
//  ppICriteria - pointer to return the criteria container
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Criteria object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateCriteria(IOECriteria ** ppICriteria)
{
    COECriteria *   pCriteria = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppICriteria)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppICriteria = NULL;

    // Create the rules manager object
    pCriteria = new COECriteria;
    if (NULL == pCriteria)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pCriteria->QueryInterface(IID_IOECriteria, (void **) ppICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }

    pCriteria = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pCriteria)
    {
        delete pCriteria;
    }
    
    return hr;
}

COECriteria::~COECriteria()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    Reset();
}

STDMETHODIMP_(ULONG) COECriteria::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COECriteria::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COECriteria::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOECriteria))
    {
        *ppvObject = static_cast<IOECriteria *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::Reset(void)
{
    HRESULT     hr = S_OK;

    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    RuleUtil_HrFreeCriteriaItem(m_rgItems, m_cItems);
    SafeMemFree(m_rgItems);
    m_cItems = 0;
    m_cItemsAlloc = 0;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    DWORD       dwState = CRIT_STATE_NULL;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init the outgoing param
    *pdwState = CRIT_STATE_NULL;
    
    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    // Walk through the actions to figure out the state
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if ((CRIT_TYPE_SECURE == m_rgItems[ulIndex].type) ||
                (CRIT_TYPE_BODY == m_rgItems[ulIndex].type) ||
                (CRIT_TYPE_ATTACH == m_rgItems[ulIndex].type))
        {
            dwState = CRIT_STATE_ALL;
        }
        else if (CRIT_STATE_ALL != dwState)
        {
            dwState = CRIT_STATE_HEADER;
        }
    }

    // Set the outgoing param
    *pdwState = dwState;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::GetCriteria(DWORD dwFlags, PCRIT_ITEM * ppItem, ULONG * pcItem)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming params
    if ((NULL == ppItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the out params
    *ppItem = NULL;
    if (NULL != pcItem)
    {
        *pcItem = 0;
    }
    
    // If we don't have any criteria, then return
    if (0 == m_cItems)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupCriteriaItem(m_rgItems, m_cItems, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    *ppItem = pItemNew;
    pItemNew = NULL;
    if (NULL != pcItem)
    {
        *pcItem = m_cItems;
    }
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItemNew, m_cItems);
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COECriteria::SetCriteria(DWORD dwFlags, CRIT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // If we have any criteria already, then reset
    if (0 != m_cItems)
    {
        Reset();
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupCriteriaItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    m_rgItems = pItemNew;
    pItemNew = NULL;
    m_cItems = cItem;
    m_cItemsAlloc = cItem;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItemNew, cItem);
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ValidateCriteria
//
//  This verifies each of the criteria values
//
//  Returns:    S_OK, if the criteria were valid
//              S_FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COECriteria::Validate(DWORD dwFlags)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    LPSTR               pszText = NULL;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    LPTSTR              pszWalk = NULL;
    ULONG               cchText = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    // If we don't have any criteria, then we must be valid
    if (0 == m_cItems)
    {
        hr = S_OK;
        goto exit;
    }

    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if (0 != (m_rgItems[ulIndex].dwFlags & ~(CRIT_FLAG_INVERT | CRIT_FLAG_MULTIPLEAND)))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        switch(m_rgItems[ulIndex].type)
        {
            case CRIT_TYPE_NEWSGROUP:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (m_rgItems[ulIndex].propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Does the folder exist
                hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }        
                
                // Are we subscribed?
                if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
                {
                    hr = S_FALSE;
                    goto exit;
                }                    
                break;
                
            case CRIT_TYPE_ALL:
            case CRIT_TYPE_JUNK:
            case CRIT_TYPE_READ:
            case CRIT_TYPE_REPLIES:
            case CRIT_TYPE_DOWNLOADED:
            case CRIT_TYPE_DELETED:
            case CRIT_TYPE_ATTACH:
            case CRIT_TYPE_FLAGGED:
                if (VT_EMPTY != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_SUBJECT:
            case CRIT_TYPE_BODY:
            case CRIT_TYPE_TO:
            case CRIT_TYPE_CC:
            case CRIT_TYPE_TOORCC:
            case CRIT_TYPE_FROM:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize) ||
                    (NULL == m_rgItems[ulIndex].propvar.blob.pBlobData) ||
                    ('\0' == m_rgItems[ulIndex].propvar.blob.pBlobData[0]))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Spin through each item making sure it is perfect
                cchText = 0;
                for (pszWalk = (LPTSTR) m_rgItems[ulIndex].propvar.blob.pBlobData;
                '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
                {
                    cchText += lstrlen(pszWalk) + 1;
                }
                
                // For the terminator
                if ('\0' == pszWalk[0])
                {
                    cchText++;
                }
                if ('\0' == pszWalk[1])
                {
                    cchText++;
                }
                
                if (cchText != m_rgItems[ulIndex].propvar.blob.cbSize)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_SIZE:
            case CRIT_TYPE_THREADSTATE:
            case CRIT_TYPE_LINES:
            case CRIT_TYPE_PRIORITY:
            case CRIT_TYPE_AGE:
            case CRIT_TYPE_SECURE:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_ACCOUNT:
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                Assert(g_pAcctMan);
                if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_rgItems[ulIndex].propvar.pszVal, &pAccount)))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                SafeRelease(pAccount);
                break;
                
            case CRIT_TYPE_SENDER:
            {
                LPWSTR  pwszText = NULL,
                        pwszVal = NULL;

                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    AssertSz(VT_LPWSTR != m_rgItems[ulIndex].propvar.vt, "We are getting UNICODE here.");
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Verify the email string
                pwszVal = PszToUnicode(CP_ACP, m_rgItems[ulIndex].propvar.pszVal);
                if (!pwszVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
                MemFree(pwszText);
                MemFree(pwszVal);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            }
                
            default:
                hr = S_FALSE;
                goto exit;
                break;
        }
    }

    // If we got here, then we must be AOK
    hr = S_OK;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    return hr;
}

STDMETHODIMP COECriteria::AppendCriteria(DWORD dwFlags, CRIT_LOGIC logic,
                            CRIT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming parameters
    if ((0 != dwFlags) || (CRIT_LOGIC_NULL == logic) || (NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's init our outgoing parameters
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = 0;
    }

    // Do we have to add more items?
    if (m_cItems == m_cItemsAlloc)
    {
        hr = HrRealloc((LPVOID *) &m_rgItems, sizeof(CRIT_ITEM) * (m_cItemsAlloc + CRIT_GROW));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(m_rgItems + m_cItemsAlloc, sizeof(CRIT_ITEM) * CRIT_GROW);
        m_cItemsAlloc += CRIT_GROW;
    }

    // Let's duplicate the items that need to be added
    hr = RuleUtil_HrDupCriteriaItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Let's add them to the criteria array
    if (0 != m_cItems)
    {
        m_rgItems[m_cItems - 1].logic = logic;
    }
    CopyMemory(m_rgItems + m_cItems, pItemNew, sizeof(CRIT_ITEM) * cItem);
    m_cItems += cItem;
    
    // Set the proper outgoing parameter
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = cItem;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COECriteria::MatchMessage(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                        IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    BOOL        fResult = FALSE;
    BOOL        fResultNew = FALSE;
    CRIT_LOGIC  logic;

    // Check incoming parameters
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || (0 == cbMsgSize))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's go through the criteria and see if we match
    fResult = FALSE;
    logic = CRIT_LOGIC_OR;
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        // Call matching function for this criteria item
        fResultNew = FMatchCritItem(&(m_rgItems[ulIndex]), pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize);
        
        // Slap it together with the old result
        if (CRIT_LOGIC_AND == logic)
        {
            fResult = (fResult && fResultNew);
        }
        else
        {
            Assert(CRIT_LOGIC_OR == logic);
            fResult = (fResult || fResultNew);
        }
        
        // Save of the next logical operation
        logic = m_rgItems[ulIndex].logic;
    }
    
    // Set the proper return value
    hr = (FALSE != fResult) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  LoadReg
//
//  This loads in the criteria from the registry.  It loads in the criteria
//  order from the Order value.  The string contains space delimitied values
//  and each value contains the subkey name for each criterion.  Each criterion 
//  is loaded in the order that is contained in the Order value.  The criterion
//  are loaded with the Criterion Type and Logical Operator.  The Criterion Value
//  Type is loaded if it exists.  If a Criterion Value Type exists, then the 
//  corresponding Criterion Value is loaded in.
//
//  pszRegPath  - the path to load the criteria from
//
//  Returns:    S_OK, if the criteria was loaded without problems
//              E_OUTOFMEMORY, if we couldn't allocate memory to hold the criteria
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COECriteria::LoadReg(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = 0;
    HKEY            hkeyRoot = NULL;
    ULONG           cbData = 0;
    LPSTR           pszOrder = NULL;
    ULONG           cOrder = 0;
    LPSTR           pszWalk = NULL;
    CRIT_ITEM *     pItems = NULL;
    LPSTR           pszNext = NULL;
    ULONG           ulOrder = 0;
    HKEY            hkeyCriteria = NULL;
    CRIT_TYPE       typeCrit;
    CRIT_LOGIC      logicCrit;
    PROPVARIANT     propvar;
    DWORD           dwType = 0;
    BYTE *          pbData = NULL;
    DWORD           dwFlags = CRIT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & CRIT_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the criteria order
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szCriteriaOrder, NULL, (BYTE **) &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Make sure we actually have something to load
    if ('\0' == *pszOrder)
    {
        AssertSz(FALSE, "The order string for the criteria is mis-formatted in the registry");
        hr = E_FAIL;
        goto exit;
    }
    
    // Convert the criteria string to a more useful format
    pszWalk = pszOrder;
    cOrder = 1;
    for (pszWalk = StrStr(pszOrder, g_szSpace); NULL != pszWalk; pszWalk = StrStr(pszWalk, g_szSpace))
    {
        // Terminate the order item
        *pszWalk = '\0';
        pszWalk++;
        cOrder++;
    }


    // Allocate the space to hold all the criteria
    hr = HrAlloc((void **) &pItems, cOrder * sizeof(CRIT_ITEM));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pItems, cOrder * sizeof(CRIT_ITEM));
    
    // For each criteria in the order string
    pszWalk = pszOrder;
    for (ulOrder = 0, pszWalk = pszOrder; ulOrder < cOrder; ulOrder++, pszWalk += lstrlen(pszWalk) + 1)
    {
        // Open up the criteria reg key
        lErr = RegOpenKeyEx(hkeyRoot, pszWalk, 0, KEY_READ, &hkeyCriteria);
        if (ERROR_SUCCESS != lErr)
        {
            AssertSz(FALSE, "Part of the criteria is mis-formatted in the registry");
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria type
        cbData = sizeof(typeCrit);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaType, 0, NULL,
                                        (BYTE *) &(typeCrit), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria logicial op
        cbData = sizeof(logicCrit);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaLogic, 0, NULL,
                                        (BYTE *) &(logicCrit), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria flags
        cbData = sizeof(dwFlags);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaFlags, 0, NULL,
                                        (BYTE *) &(dwFlags), &cbData);
        if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
        {
            hr = E_FAIL;
            goto exit;
        }

        // If it didn't exist then assign it to the default
        if (ERROR_FILE_NOT_FOUND == lErr)
        {
            dwFlags = CRIT_FLAG_DEFAULT;
        }

        // Initialize the new space to a known value
        ZeroMemory(&propvar, sizeof(propvar));
        
        // Does a criteria value type exist
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValueType, 0, NULL, NULL, &cbData);
        if ((ERROR_SUCCESS == lErr) && (0 != cbData))
        {
            
            // Load the criteria value in
            cbData = sizeof(dwType);
            lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValueType, 0, NULL,
                                            (BYTE *) &dwType, &cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            propvar.vt = (VARTYPE) dwType;
            
            switch (propvar.vt)
            {
                case VT_UI4:
                    // Get the criteria value
                    cbData = sizeof(propvar.ulVal);
                    lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValue, 0, NULL,
                        (BYTE * ) &(propvar.ulVal), &cbData);
                    if (ERROR_SUCCESS != lErr)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                    break;
                    
                case VT_LPSTR:
                case VT_BLOB:
                    // Get the criteria value
                    hr = RuleUtil_HrGetRegValue(hkeyCriteria, c_szCriteriaValue, NULL, (BYTE **) &pbData, &cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Save the space so we can free it
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    
                    pbData = NULL;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we loading in a invalid criteria type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }

        }

        // Save the value into the criteria array
        pItems[ulOrder].type = typeCrit;
        pItems[ulOrder].dwFlags = dwFlags;
        pItems[ulOrder].logic = logicCrit;
        pItems[ulOrder].propvar = propvar;
        
        // Close the criteria
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyCriteria));
        hkeyCriteria = NULL;        
    }
    
    // Free up the current criteria
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cOrder;

    // Make sure we clear the dirty bit
    m_dwState &= ~CRIT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= CRIT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pbData);
    RuleUtil_HrFreeCriteriaItem(pItems, cOrder);
    SafeMemFree(pItems);
    SafeMemFree(pszOrder);
    if (NULL != hkeyCriteria)
    {
        RegCloseKey(hkeyCriteria);
    }
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COECriteria::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LPSTR       pszOrder = NULL;
    ULONG       ulIndex = 0;
    CRIT_ITEM * pItem = NULL;
    CHAR        rgchTag[CCH_CRIT_ORDER];
    HKEY        hkeyCriteria = NULL;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If there's nothing to save, then fail
    if (NULL == m_rgItems)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
    Assert(m_cItems < CRIT_COUNT_MAX);

    // Allocate space to hold the order
    DWORD cchSize = (m_cItems * CCH_CRIT_ORDER);
    hr = HrAlloc((void **) &pszOrder, cchSize * sizeof(*pszOrder));
    if (FAILED(hr))
    {
        goto exit;
    }
    pszOrder[0] = '\0';
    
    // Write out each of the criteria
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Get the new criteria tag
        wnsprintf(rgchTag, ARRAYSIZE(rgchTag), "%03X", ulIndex);

        // Add the new tag to the order
        if (0 != ulIndex)
        {
            StrCatBuff(pszOrder, g_szSpace, cchSize);
        }
        StrCatBuff(pszOrder, rgchTag, cchSize);
        
        // Create the new criteria
        lErr = RegCreateKeyEx(hkeyRoot, rgchTag, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyCriteria, &dwDisp);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        Assert(REG_CREATED_NEW_KEY == dwDisp);
        
        // Write out the criteria type
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaType, 0, REG_DWORD,
                                        (BYTE *) &(pItem->type), sizeof(pItem->type));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the criteria logicial op
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaLogic, 0, REG_DWORD,
                                        (BYTE *) &(pItem->logic), sizeof(pItem->logic));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the criteria flags
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaFlags, 0, REG_DWORD,
                                        (BYTE *) &(pItem->dwFlags), sizeof(pItem->dwFlags));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Do we have a criteria value?
        if (VT_EMPTY != pItem->propvar.vt)
        {
            // Write out the criteria value type
            dwDisp = pItem->propvar.vt;
            lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwDisp, sizeof(dwDisp));
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
            
            // Write out the criteria value
            switch (pItem->propvar.vt)
            {
                case VT_UI4:
                    dwDisp = REG_DWORD;
                    pbData = (BYTE * ) &(pItem->propvar.ulVal);
                    cbData = sizeof(pItem->propvar.ulVal);
                    break;
                    
                case VT_LPSTR:
                    dwDisp = REG_SZ;
                    pbData = (BYTE * ) (pItem->propvar.pszVal);
                    cbData = lstrlen(pItem->propvar.pszVal) + 1;
                    break;
                    
                case VT_BLOB:
                    dwDisp = REG_BINARY;
                    pbData = pItem->propvar.blob.pBlobData;
                    cbData = pItem->propvar.blob.cbSize;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
            
            // Write out the criteria value
            lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaValue, 0, dwDisp, pbData, cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
        }

        // Close the criteria
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyCriteria));
        hkeyCriteria = NULL;        
    }

    // Write out the order string.
    lErr = RegSetValueEx(hkeyRoot, c_szCriteriaOrder, 0, REG_SZ,
                                    (BYTE *) pszOrder, lstrlen(pszOrder) + 1);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~CRIT_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyCriteria)
    {
        RegCloseKey(hkeyCriteria);
    }
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COECriteria::Clone(IOECriteria ** ppICriteria)
{
    HRESULT         hr = S_OK;
    COECriteria *   pCriteria = NULL;
    
    // Check incoming params
    if (NULL == ppICriteria)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppICriteria = NULL;
    
    // Create a new criteria
    pCriteria = new COECriteria;
    if (NULL == pCriteria)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the list of criteria
    hr = pCriteria->SetCriteria(0, m_rgItems, m_cItems);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria interface
    hr = pCriteria->QueryInterface(IID_IOECriteria, (void **) ppICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }

    pCriteria = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pCriteria)
    {
        delete pCriteria;
    }
    return hr;
}

STDMETHODIMP COECriteria::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OECriteria;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (CRIT_STATE_DIRTY == (m_dwState & CRIT_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COECriteria::Load(IStream * pStm)
{
    HRESULT         hr = S_OK;
    ULONG           cbData = 0;
    ULONG           cbRead = 0;
    DWORD           dwData = 0;
    ULONG           cItems = 0;
    CRIT_ITEM *     pItems = NULL;
    ULONG           ulIndex = 0;
    CRIT_ITEM *     pItem = NULL;
    CRIT_TYPE       typeCrit;
    CRIT_LOGIC      logicCrit;
    DWORD           dwFlags = CRIT_FLAG_DEFAULT;
    PROPVARIANT     propvar = {0};
    BYTE *          pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != CRIT_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the number of criteria
    hr = pStm->Read(&cItems, sizeof(cItems), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(cItems)) || (0 == cItems))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space to hold all the criteria
    hr = HrAlloc( (void **) &pItems, cItems * sizeof(*pItems));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the criteria to a known value
    ZeroMemory(pItems, cItems * sizeof(*pItems));
    
    // for each criteria
    for (ulIndex = 0, pItem = pItems; ulIndex < cItems; ulIndex++, pItem++)
    {
        // Read in the criteria type
        hr = pStm->Read(&typeCrit, sizeof(typeCrit), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(typeCrit)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the criteria logical op
        hr = pStm->Read(&logicCrit, sizeof(logicCrit), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(logicCrit)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the criteria flags
        hr = pStm->Read(&dwFlags, sizeof(dwFlags), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwFlags)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the proper criteria value
        switch(typeCrit)
        {
            case CRIT_TYPE_ACCOUNT:
                if (FALSE == FCritLoad_Account(pStm, &propvar))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
                
            default:
                if (FALSE == FCritLoad_Default(pStm, &propvar))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
        }

        // Assign the values
        pItem->type = typeCrit;
        pItem->logic = logicCrit;
        pItem->dwFlags = dwFlags;
        pItem->propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
    }

    // Free up the current criteria
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cItems;

    // Make sure we clear the dirty bit
    m_dwState &= ~CRIT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= CRIT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItems, cItems);
    SafeMemFree(pItems);
    PropVariantClear(&propvar);
    return hr;
}

STDMETHODIMP COECriteria::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    ULONG       cbData = 0;
    ULONG       cbWritten = 0;
    DWORD       dwData = 0;
    ULONG       ulIndex = 0;
    CRIT_ITEM * pItem = NULL;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Write out the version
    dwData = CRIT_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the count of criteria
    hr = pStm->Write(&m_cItems, sizeof(m_cItems), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(m_cItems));
    
    // Loop through each of the criteria
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Write out the criteria type
        hr = pStm->Write(&(pItem->type), sizeof(pItem->type), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->type));

        // Write out the criteria logical op
        hr = pStm->Write(&(pItem->logic), sizeof(pItem->logic), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->logic));

        // Write out the criteria flags
        hr = pStm->Write(&(pItem->dwFlags), sizeof(pItem->dwFlags), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->dwFlags));
        
        // Write out the proper criteria value
        switch(pItem->type)
        {
            case CRIT_TYPE_ACCOUNT:
                if (FALSE == FCritSave_Account(pStm, &(pItem->propvar)))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
                
            default:
                if (FALSE == FCritSave_Default(pStm, &(pItem->propvar)))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
        }

    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~CRIT_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

BOOL CritFunc_Query(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet);
BOOL CritFunc_Text(CRIT_ITEM * pItem, LPSTR pszText);
BOOL CritFunc_Sender(CRIT_ITEM * pItem, LPSTR pszAddr);
BOOL CritFunc_Priority(CRIT_ITEM * pItem, WORD wPriority);
BOOL CritFunc_Secure(CRIT_ITEM * pItem, DWORD dwFlags);
BOOL CritFunc_Age(CRIT_ITEM * pItem, FILETIME * pftSent);
BOOL CritFunc_Body(CRIT_ITEM * pItem, IMimeMessage * pIMMsg);
BOOL _FMatchBlobString(CRIT_ITEM * pItem, LPSTR pszText);
BOOL _FQueryBlobString(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet);

BOOL FMatchCritItem(CRIT_ITEM * pItem, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                        IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                        IMimeMessage * pIMMsg, ULONG cbMsgSize)
{
    BOOL                fRet = FALSE;
    ULONG               ulIndex = 0;
    PROPVARIANT         propvar = {0};
    ADDRESSLIST         addrList = {0};
    FOLDERID            idFolder = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    Assert((NULL != pItem) && ((NULL != pMsgInfo) || (NULL != pIMPropSet)) && (0 != cbMsgSize))

    switch (pItem->type)
    {
        case CRIT_TYPE_ALL:
            Assert(VT_EMPTY == pItem->propvar.vt);
            fRet = TRUE;
            break;

        case CRIT_TYPE_ACCOUNT:
            Assert(VT_LPSTR == pItem->propvar.vt);
            fRet = FALSE;
            if ((NULL != pszAcct) && (NULL != pItem->propvar.pszVal))
            {
                fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAcct));
            }
            break;

        case CRIT_TYPE_NEWSGROUP:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            if ((NULL != pFolder) && (0 != pItem->propvar.blob.cbSize))
            {
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (pItem->propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    fRet = FALSE;
                }
                else if (SUCCEEDED(pFolder->GetFolderId(&idFolder)))
                {
                    fRet = (idFolder == prfdData->idFolder);
                }
            }
            break;

        case CRIT_TYPE_SIZE:
            Assert(VT_UI4 == pItem->propvar.vt);
            // Set the size of the message to Kilobytes
            cbMsgSize = cbMsgSize / 1024;
            
            fRet = (cbMsgSize > pItem->propvar.ulVal);
            break;

        case CRIT_TYPE_LINES:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            if (NULL != pMsgInfo)
            {
                fRet = (pMsgInfo->cLines > pItem->propvar.ulVal);
            }
            break;

        case CRIT_TYPE_AGE:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Age(pItem, &(pMsgInfo->ftSent));
            }
            else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &propvar))))
            {
                fRet = CritFunc_Age(pItem, &(propvar.filetime));
            }
            break;

        case CRIT_TYPE_ATTACH:
            Assert(VT_EMPTY == pItem->propvar.vt);
            fRet = TRUE;
            
            if (NULL != pMsgInfo)
            {
                fRet = (0 != (pMsgInfo->dwFlags & ARF_HASATTACH));
            }
            else if (NULL != pIMMsg)
            {
                fRet = (0 != (DwGetFlagsFromMessage(pIMMsg) & ARF_HASATTACH));
            }
            break;

        case CRIT_TYPE_PRIORITY:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Priority(pItem, pMsgInfo->wPriority);
            }
            else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &propvar))))
            {
                fRet = CritFunc_Priority(pItem, (WORD) (propvar.ulVal));
            }
            break;

        case CRIT_TYPE_SECURE:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Secure(pItem, pMsgInfo->dwFlags);
            }
            else if (NULL != pIMMsg)
            {
                fRet = CritFunc_Secure(pItem, DwGetFlagsFromMessage(pIMMsg));
            }
            break;

        case CRIT_TYPE_TOORCC:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pIMPropSet)
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_TO), pIMPropSet);

                if (((0 != (pItem->dwFlags & CRIT_FLAG_INVERT)) && (FALSE != fRet)) ||
                            ((0 == (pItem->dwFlags & CRIT_FLAG_INVERT)) && (FALSE == fRet)))
                {
                    fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_CC), pIMPropSet);
                }
            }
            break;

        case CRIT_TYPE_SENDER:
            Assert(VT_LPSTR == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((NULL == pItem->propvar.pszVal) || ('\0' == pItem->propvar.pszVal[0]))
            {
                Assert(FALSE);
            }
            else if (S_OK == RuleUtil_HrMatchSender(pItem->propvar.pszVal, pMsgInfo, pIMMsg, pIMPropSet))
            {                
                fRet = TRUE;
            }
            break;

        case CRIT_TYPE_SUBJECT:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszSubject))
            {
                fRet = _FMatchBlobString(pItem, pMsgInfo->pszSubject);
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_SUBJECT), pIMPropSet);
            }
            break;

        case CRIT_TYPE_BODY:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if (NULL != pIMMsg)
            {
                fRet = CritFunc_Body(pItem, pIMMsg);
            }
            break;

        case CRIT_TYPE_FROM:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszFromHeader))
            {
                fRet = _FMatchBlobString(pItem, pMsgInfo->pszFromHeader);
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_FROM), pIMPropSet);
            }
            break;

        case CRIT_TYPE_TO:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_TO), pIMPropSet);
            }
            break;
            
        case CRIT_TYPE_CC:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_CC), pIMPropSet);
            }
            break;
            
        default:
            fRet = FALSE;
            break;
    }
    
    PropVariantClear(&propvar);
    return fRet;
}

BOOL CritFunc_Query(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    LPSTR           pszAddr = NULL;
    LPSTR           pszTerm = NULL;
    HRESULT         hr = S_OK;

    if (NULL == pIMPropSet)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Dup the string
    pszAddr = PszDupA(pItem->propvar.pszVal);
    if (NULL == pszAddr)
    {
        fRet = FALSE;
        goto exit;
    }

    pszWalk = pszAddr;
    pszTerm = pszWalk;
    while (NULL != pszTerm)
    {
        pszTerm = StrStr(pszWalk, g_szComma);
        if (NULL != pszTerm)
        {
            pszTerm[0] = '\0';
        }

        fRet = (S_OK == pIMPropSet->QueryProp(pszQuery, pszWalk, TRUE, FALSE));
        
        if (FALSE == fRet)
        {
            break;
        }

        pszWalk = pszWalk + lstrlen(pszWalk) + 1;
    }

exit:
    SafeMemFree(pszAddr);
    return fRet;
}

BOOL CritFunc_Priority(CRIT_ITEM * pItem, WORD wPriority)
{
    BOOL    fRet = FALSE;

    Assert(NULL != pItem);
    Assert(VT_UI4 == pItem->propvar.vt);
    
    if (CRIT_DATA_HIPRI == pItem->propvar.ulVal)
    {
        fRet = (wPriority == (WORD) IMSG_PRI_HIGH);
    }
    else if (CRIT_DATA_LOPRI == pItem->propvar.ulVal)
    {
        fRet = (wPriority == (WORD) IMSG_PRI_LOW);
    }
    else
    {
        fRet = (wPriority == (WORD) IMSG_PRI_NORMAL);
    }

    return fRet;
}

BOOL CritFunc_Secure(CRIT_ITEM * pItem, DWORD dwFlags)
{
    BOOL    fRet = FALSE;

    Assert(NULL != pItem);
    Assert(VT_UI4 == pItem->propvar.vt);
    
    // Should we be checking signed messages
    if (0 != (pItem->propvar.ulVal & CRIT_DATA_SIGNEDSECURE))
    {
        fRet = (0 != (dwFlags & ARF_SIGNED));
    }
    else if (0 != (pItem->propvar.ulVal & CRIT_DATA_ENCRYPTSECURE))
    // Should we be checking encrypted messages
    {
        fRet = (0 != (dwFlags & ARF_ENCRYPTED));
    }
    else
    {
        fRet = (0 == (dwFlags & (ARF_ENCRYPTED | ARF_SIGNED)));
    }

    return fRet;
}

BOOL CritFunc_Age(CRIT_ITEM * pItem, FILETIME * pftSent)
{
    BOOL        fRet = FALSE;
    SYSTEMTIME  sysTime = {0};
    FILETIME    ftTime = {0};
    ULONG       ulSeconds;

    Assert(VT_UI4 == pItem->propvar.vt);
    
    if ((NULL == pftSent) || ((0 == pftSent->dwLowDateTime) && (0 == pftSent->dwHighDateTime)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the current time
    GetSystemTime(&sysTime);
    SystemTimeToFileTime(&sysTime, &ftTime);

    ulSeconds = UlDateDiff(pftSent, &ftTime);
    fRet = ((ulSeconds / SECONDS_INA_DAY) > pItem->propvar.ulVal);

exit:
    return fRet;
}

BOOL CritFunc_Sender(CRIT_ITEM * pItem, LPSTR pszAddr)
{
    BOOL    fRet = FALSE;
    ULONG   cchVal = 0;
    ULONG   cchEmail = 0;
    CHAR    chTest = 0;

    Assert(VT_LPSTR == pItem->propvar.vt);
    
    // Check to make sure that there's something to match
    if ((NULL == pszAddr) || ('\0' == pszAddr[0]))
    {
        fRet = FALSE;
        goto exit;
    }

    // Check to see if it is an address
    if (NULL != StrStr(pItem->propvar.pszVal, "@"))
    {
        fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAddr));
    }
    else
    {
        cchVal = lstrlen(pItem->propvar.pszVal);
        cchEmail = lstrlen(pszAddr);
        if (cchVal <= cchEmail)
        {
            fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAddr + (cchEmail - cchVal)));
            if ((FALSE != fRet) && (cchVal != cchEmail))
            {
                chTest = *(pszAddr + (cchEmail - cchVal - 1));
                if (('@' != chTest) && ('.' != chTest))
                {
                    fRet = FALSE;
                }
            }
        }
    }

exit:
    return fRet;
}

BOOL _FMatchBlobString(CRIT_ITEM * pItem, LPSTR pszText)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    
    // Walk each of the strings looking for a match    
    for (pszWalk = (LPSTR) (pItem->propvar.blob.pBlobData); '\0' != pszWalk[0];
                pszWalk = pszWalk + lstrlen(pszWalk) + 1)
    {
        // Do the comparison
        fRet = (NULL != StrStrI(pszText, pszWalk));

        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

    return fRet;
}

BOOL _FQueryBlobString(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;

    if (NULL == pIMPropSet)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Walk each of the strings looking for a match    
    for (pszWalk = (LPSTR) (pItem->propvar.blob.pBlobData); '\0' != pszWalk[0];
                pszWalk = pszWalk + lstrlen(pszWalk) + 1)
    {
        // Do the comparison
        fRet = (S_OK == pIMPropSet->QueryProp(pszQuery, pszWalk, TRUE, FALSE));

        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

exit:
    return fRet;
}

BOOL CritFunc_Text(CRIT_ITEM * pItem, LPSTR pszText)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    LPSTR           pszAddr = NULL;
    LPSTR           pszTerm = NULL;
    
    // Dup the string
    pszAddr = PszDupA(pItem->propvar.pszVal);
    if (NULL == pszAddr)
    {
        fRet = FALSE;
        goto exit;
    }

    pszWalk = pszAddr;
    pszTerm = pszWalk;
    while (NULL != pszTerm)
    {
        pszTerm = StrStr(pszWalk, g_szComma);
        if (NULL != pszTerm)
        {
            pszTerm[0] = '\0';
        }
        
        fRet = (NULL != StrStrI(pszText, pszWalk));

        if (FALSE == fRet)
        {
            break;
        }

        pszWalk = pszWalk + lstrlen(pszWalk) + 1;
    }

exit:
    SafeMemFree(pszAddr);
    return fRet;
}

BOOL CritFunc_Body(CRIT_ITEM * pItem, IMimeMessage * pIMMsg)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    IStream *       pStream = NULL;
    IStream *       pStreamHtml = NULL;
    
    pszWalk = (LPTSTR) (pItem->propvar.blob.pBlobData);
    if (NULL == pszWalk)
    {
        fRet = FALSE;
        goto exit;
    }

    // Try to Get the Plain Text Stream
    if (FAILED(pIMMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
    {
        // Try to get the HTML stream and convert it to text...
        if (SUCCEEDED(pIMMsg->GetTextBody(TXT_HTML, IET_DECODED, &pStreamHtml, NULL)))
        {
            if (FAILED(HrConvertHTMLToPlainText(pStreamHtml, &pStream, CF_TEXT)))
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }

    if (NULL == pStream)
    {
        fRet = FALSE;
        goto exit;
    }
    
    for (; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        fRet = StreamSubStringMatch(pStream, pszWalk);
        
        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

exit:
    SafeRelease(pStreamHtml);
    SafeRelease(pStream);
    return fRet;
}

BOOL FCrit_GetAcctInfo(DWORD dwServerTypes, DWORD * pdwServerType, DWORD * pdwPropTag)
{
    BOOL    fRet = FALSE;

    Assert((NULL != pdwServerType) && (NULL != pdwPropTag));
    
    // Figure out the type of the account
    // and the server property
    if (0 != (dwServerTypes & SRV_NNTP))
    {
        *pdwServerType = SRV_NNTP;
        *pdwPropTag = AP_NNTP_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_IMAP))
    {
        *pdwServerType = SRV_IMAP;
        *pdwPropTag = AP_IMAP_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_POP3))
    {
        *pdwServerType = SRV_POP3;
        *pdwPropTag = AP_POP3_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_HTTPMAIL))
    {
        *pdwServerType = SRV_HTTPMAIL;
        *pdwPropTag = AP_HTTPMAIL_SERVER;
    }
    else
    {
        Assert(FALSE);
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL FCritLoad_Account(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    DWORD               dwData = 0;
    DWORD               dwPropTag = 0;
    ULONG               cbRead = 0;
    BYTE *              pbData = NULL;
    ULONG               cbData = 0;
    IImnEnumAccounts *  pIEnumAcct = NULL;
    IImnAccount *       pAccount = NULL;
    CHAR                szAccount[CCHMAX_SERVER_NAME];
    LPSTR               pszAcct = NULL;
    BOOL                fFound = FALSE;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the outgoing param
    ZeroMemory(ppropvar, sizeof(*ppropvar));
    
    // Read in the account server type
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the type of the account
    // and the server property
    fRet = FCrit_GetAcctInfo(dwData, &dwData, &dwPropTag);
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Get the size of the server name
    hr = pIStm->Read(&cbData, sizeof(cbData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(cbData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate the space to hold the server name
    hr = HrAlloc((VOID **) &pbData, cbData);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Read in the server name
    hr = pIStm->Read(pbData, cbData, &cbRead);
    if ((FAILED(hr)) || (cbRead != cbData))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get an account enumerator
    Assert(g_pAcctMan);
    if (FAILED(g_pAcctMan->Enumerate(dwData, &pIEnumAcct)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Search each account for the server name
    while(SUCCEEDED(pIEnumAcct->GetNext(&pAccount)))
    {
        // We can get back NULL accounts
        if (NULL == pAccount)
        {
            break;
        }
        
        // Get the server name
        if (FAILED(pAccount->GetPropSz(dwPropTag, szAccount, sizeof(szAccount))))
        {
            SafeRelease(pAccount);
            continue;
        }

        // Do we have a match?
        if (0 == lstrcmpi(szAccount, (LPSTR) pbData))
        {
            fFound = TRUE;
            break;
        }

        // We have a match

        // Release it
        SafeRelease(pAccount);
    }

    // Did we find anything?
    if (FALSE == fFound)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the account 
    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
    {
        fRet = FALSE;
        goto exit;
    }

    // Save off the account ID
    pszAcct = PszDupA(szAccount);
    if (NULL == pszAcct)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the outgoing param
    ppropvar->vt = VT_LPSTR;
    ppropvar->pszVal = pszAcct;
    pszAcct = NULL;
    
    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszAcct);
    SafeRelease(pAccount);
    SafeRelease(pIEnumAcct);
    SafeMemFree(pbData);
    return fRet;
}

BOOL FCritSave_Account(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    IImnAccount *   pAccount = NULL;
    DWORD           dwServerTypes = 0;
    DWORD           dwPropTag = 0;
    LPSTR           pszServer = NULL;
    ULONG           cbWritten = 0;
    ULONG           cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(g_pAcctMan);
    if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, ppropvar->pszVal, &pAccount)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Get the server type
    if (FAILED(pAccount->GetServerTypes(&dwServerTypes)))
    {
        fRet = FALSE;
        goto exit;
    }        

    // Figure out the type of the account
    // and the server property
    fRet = FCrit_GetAcctInfo(dwServerTypes, &dwServerTypes, &dwPropTag);
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Allocate space to hold the server name
    if (FAILED(HrAlloc((void **) &pszServer, CCHMAX_SERVER_NAME + 1)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the server name
    if (FAILED(pAccount->GetPropSz(dwPropTag, pszServer, CCHMAX_SERVER_NAME)))
    {
        fRet = FALSE;
        goto exit;
    }        

    // Write out the server type
    hr = pIStm->Write(&(dwServerTypes), sizeof(dwServerTypes), &cbWritten);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    Assert(cbWritten == sizeof(dwServerTypes));

    // Write out the count of chars in the name
    cbData = lstrlen(pszServer) + 1;
    hr = pIStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));
    
    // Write out the server name
    hr = pIStm->Write((BYTE *) pszServer, cbData, &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == cbData); 

    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszServer);
    SafeRelease(pAccount);
    return fRet;
}

BOOL FCritLoad_Default(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    DWORD   dwData = 0;
    ULONG   cbRead = 0;
    BYTE *  pbData = NULL;
    ULONG   cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the outgoing param
    ZeroMemory(ppropvar, sizeof(*ppropvar));
    
    // Read in the criteria value type
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have any more data to get
    if (dwData != VT_EMPTY)
    {
        ppropvar->vt = (VARTYPE) dwData;
        
        // Get the size of the criteria value
        hr = pIStm->Read(&cbData, sizeof(cbData), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(cbData)))
        {
            fRet = FALSE;
            goto exit;
        }

        // Allocate space to hold the criteria value data
        switch (ppropvar->vt)
        {
            case VT_UI4:
                pbData = (BYTE * ) &(ppropvar->ulVal);
                break;

            case VT_BLOB:
            case VT_LPSTR:
                // Allocate the space to hold the data
                hr = HrAlloc((void **) &pbData, cbData);
                if (FAILED(hr))
                {
                    fRet = FALSE;
                    goto exit;
                }

                // Make sure we don't lose the allocated memory
                if (VT_LPSTR == ppropvar->vt)
                {
                    ppropvar->pszVal = (LPSTR) pbData;
                }
                else
                {
                    ppropvar->blob.cbSize = cbData;
                    ppropvar->blob.pBlobData = pbData;
                }
                break;

            default:
                AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
                fRet = FALSE;
                goto exit;
                break;                
        }

        // Read in the criteria value
        hr = pIStm->Read(pbData, cbData, &cbRead);
        if ((FAILED(hr)) || (cbRead != cbData))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    // Set the return value
    fRet = TRUE;

exit:
    return fRet;
}

BOOL FCritSave_Default(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    DWORD   dwData = 0;
    ULONG   cbWritten = 0;
    BYTE *  pbData = NULL;
    ULONG   cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Write out the value type
    dwData = ppropvar->vt;
    hr = pIStm->Write(&(dwData), sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));

    // We don't have to save out the criteria value
    // if we don't have one
    if (VT_EMPTY == ppropvar->vt)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Figure out the size of the criteria value
    switch (ppropvar->vt)
    {
        case VT_UI4:
            pbData = (BYTE * ) &(ppropvar->ulVal);
            cbData = sizeof(ppropvar->ulVal);
            break;
            
        case VT_LPSTR:
            pbData = (BYTE * ) (ppropvar->pszVal);
            cbData = lstrlen(ppropvar->pszVal) + 1;
            break;
            
        case VT_BLOB:
            pbData = ppropvar->blob.pBlobData;
            cbData = ppropvar->blob.cbSize;
            break;
            
        default:
            AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
            fRet = FALSE;
            goto exit;
            break;                
    }
    
    // Write out the criteria value size
    hr = pIStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));
    
    // Write out the criteria value
    hr = pIStm->Write(pbData, cbData, &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == cbData); 
    
    // Set the return value
    fRet = TRUE;

exit:
    return fRet;
}

DWORD DwGetFlagsFromMessage(IMimeMessage * pIMMsg)
{
    DWORD           dwFlags = 0;
    DWORD           dwImf = 0;

    Assert(NULL != pIMMsg);
    
    if (SUCCEEDED(pIMMsg->GetFlags(&dwImf)))
    {
        dwFlags = ConvertIMFFlagsToARF(dwImf);
    }

    return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Rule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rule.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRule
//
//  This creates a rule.
//
//  ppIRule - pointer to return the rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRule(IOERule ** ppIRule)
{
    COERule *   pRule = NULL;
    HRESULT     hr = S_OK;

    // Check the incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIRule = NULL;

    // Create the rules manager object
    pRule = new COERule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRule = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pRule)
    {
        delete pRule;
    }
    
    return hr;
}

COERule::COERule()
{
    m_cRef = 0;
    m_dwState = RULE_STATE_NULL;
    m_pszName = NULL;
    m_pICrit = NULL;
    m_pIAct = NULL;
    m_dwVersion = 0;
}

COERule::~COERule()
{
    ULONG   ulIndex = 0;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);
}

STDMETHODIMP_(ULONG) COERule::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COERule::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COERule::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERule))
    {
        *ppvObject = static_cast<IOERule *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::Reset(void)
{
    HRESULT     hr = S_OK;
    LPSTR       pszKeyPath = NULL;
    LPCSTR       pszKeyStart = NULL;

    // Release the criteria
    SafeRelease(m_pICrit);

    // Release the actions
    SafeRelease(m_pIAct);

    // Free up the rule name
    SafeMemFree(m_pszName);
    
    // Set the current state
    m_dwState |= RULE_STATE_INIT;

    // Clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Set the return value
    hr = S_OK;
    
    return hr;
}

STDMETHODIMP COERule::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we're not enabled
    if ((0 != (m_dwState & RULE_STATE_DISABLED)) || (0 != (m_dwState & RULE_STATE_INVALID)))
    {
        *pdwState = RULE_STATE_NULL;
    }
    else
    {
        *pdwState = m_dwState;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::Validate(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    BOOL        fValid = FALSE;

    // If we don't have a criteria or actions object then we fail
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Validate the criteria 
    hr = m_pICrit->Validate(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    fValid = TRUE;
    if (S_OK != hr)
    {
        fValid = FALSE;
    }
    
    // Validate the actions 
    hr = m_pIAct->Validate(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK != hr)
    {
        fValid = FALSE;
    }
    
    // If the rule is invalid, make sure we disable it
    if (FALSE == fValid)
    {
        m_dwState |= RULE_STATE_INVALID;
    }
    else
    {
        m_dwState &= ~RULE_STATE_INVALID;
    }
    
    // Set the proper return value
    hr = fValid ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP COERule::GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    LPSTR       pszName = NULL;
    CRIT_ITEM * pCrit = NULL;
    ACT_ITEM *  pAct = NULL;
    ULONG       cItem = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    
    switch(prop)
    {
      case RULE_PROP_NAME:
        if (NULL == m_pszName)
        {
            pszName = PszDupA("");
        }
        else
        {
            pszName = PszDupA(m_pszName);
        }
        pvarResult->vt = VT_LPSTR;
        pvarResult->pszVal = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(m_dwState & RULE_STATE_DISABLED);
        break;
        
      case RULE_PROP_VERSION:
        pvarResult->vt = VT_UI4;
        pvarResult->ulVal = m_dwVersion;
        break;
        
      case RULE_PROP_CRITERIA:
        if (NULL == m_pICrit)
        {
            cItem = 0;
            pCrit = NULL;
        }
        else
        {
            hr = m_pICrit->GetCriteria(0, &pCrit, &cItem);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = cItem * sizeof(CRIT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pCrit;
        pCrit = NULL;
        break;
        
      case RULE_PROP_ACTIONS:
        if (NULL == m_pIAct)
        {
            cItem = 0;
            pAct = NULL;
        }
        else
        {
            hr = m_pIAct->GetActions(0, &pAct, &cItem);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = cItem * sizeof(ACT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pAct;
        pAct = NULL;
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    RuleUtil_HrFreeCriteriaItem(pCrit, cItem);
    SafeMemFree(pCrit);
    RuleUtil_HrFreeActionsItem(pAct, cItem);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COERule::SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    LPSTR       pszName = NULL;
    DWORD       dwState = 0;
    ULONG       cItems = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    switch(prop)
    {
      case RULE_PROP_NAME:
        if ((VT_LPSTR != pvarResult->vt) || (NULL == pvarResult->pszVal))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Create a new copy
        pszName = PszDupA(pvarResult->pszVal);
        if (NULL == pszName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Free up any old value
        SafeMemFree(m_pszName);
        
        // Set the new value
        m_pszName = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_DISABLED;
        }
        else
        {
            Assert(0 == (m_dwState & RULE_STATE_INVALID));
            m_dwState &= ~RULE_STATE_DISABLED;
        }
        break;

      case RULE_PROP_VERSION:
        if (VT_UI4 != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        m_dwVersion = pvarResult->ulVal;
        break;
        
      case RULE_PROP_CRITERIA:
        if ((VT_BLOB != pvarResult->vt) || (0 == pvarResult->blob.cbSize) ||
                            (NULL == pvarResult->blob.pBlobData))
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        if (NULL == m_pICrit)
        {
            hr = HrCreateCriteria(&m_pICrit);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        
        cItems = pvarResult->blob.cbSize / sizeof(CRIT_ITEM);
        Assert(cItems * sizeof(CRIT_ITEM) == pvarResult->blob.cbSize);
        
        hr = m_pICrit->SetCriteria(0, (CRIT_ITEM *) pvarResult->blob.pBlobData, cItems);
        if (FAILED(hr))
        {
            goto exit;
        }

        hr = m_pICrit->GetState(&dwState);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
        break;
        
      case RULE_PROP_ACTIONS:
        if ((VT_BLOB != pvarResult->vt) || (0 == pvarResult->blob.cbSize) ||
                            (NULL == pvarResult->blob.pBlobData))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        if (NULL == m_pIAct)
        {
            hr = HrCreateActions(&m_pIAct);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        
        cItems = pvarResult->blob.cbSize / sizeof(ACT_ITEM);
        Assert(cItems * sizeof(ACT_ITEM) == pvarResult->blob.cbSize);
        
        hr = m_pIAct->SetActions(0, (ACT_ITEM *) pvarResult->blob.pBlobData, cItems);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        hr = m_pIAct->GetState(&dwState);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_dwState = (m_dwState & ~ACT_STATE_MASK) | (dwState & ACT_STATE_MASK);
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }

    // Mark the rule as dirty
    m_dwState |= RULE_STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    return hr;
}

STDMETHODIMP COERule::Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pAct = NULL;
    ULONG       cAct = 0;
    
    // Check incoming variables
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || (0 == cbMsgSize) ||
                (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set outgoing params to default
    *ppActions = NULL;
    *pcActions = 0;

    // If we don't have a criteria or actions object then we fail
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = S_FALSE;
        goto exit;
    }

    // If we ain't valid then we can just bail
    if (0 != (m_dwState & RULE_STATE_INVALID))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Do we match??
    hr = m_pICrit->MatchMessage(pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we didn't match then just return
    if (S_FALSE == hr)
    {
        goto exit;
    }

    // Grab the actions and return them to the caller
    hr = m_pIAct->GetActions(0, &pAct, &cAct);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing parameters
    *ppActions = pAct;
    pAct = NULL;
    *pcActions = cAct;
    
    // Set proper return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pAct, cAct);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COERule::LoadReg(LPCSTR pszRegPath)
{
    HRESULT             hr = S_OK;
    LONG                lErr = 0;
    HKEY                hkeyRoot = NULL;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    LPSTR               pszName = NULL;
    BOOL                fDisabled = FALSE;
    IOECriteria *       pICriteria = NULL;
    IOEActions *        pIActions = NULL;
    LPSTR               pszRegPathNew = NULL;
    ULONG               cchRegPath = 0;
    DWORD               dwState = 0;
    
    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & RULE_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the rule name
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szRuleName, NULL, (BYTE **) &pszName, NULL);
    if (FAILED(hr))
    {
        SafeMemFree(pszName);
    }

    // Get the enabled state
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRuleEnabled, 0, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    Assert(cbData == sizeof(dwData));
    
    fDisabled = ! (BOOL) dwData;

    // Get the version of the rule
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = 0;
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    m_dwVersion = dwData;
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    Assert(lstrlen(c_szRuleCriteria) >= lstrlen(c_szRuleActions));
    DWORD cchSize = (cchRegPath + lstrlen(c_szRuleCriteria) + 2);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchSize)))
    {
        goto exit;
    }

    // Build reg path to criteria
    StrCpyN(pszRegPathNew, pszRegPath, cchSize);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        StrCatBuff(pszRegPathNew, g_szBackSlash, cchSize);
        cchRegPath++;
    }

    StrCatBuff(pszRegPathNew, c_szRuleCriteria, cchSize);
    
    // Create a new criteria object
    hr = HrCreateCriteria(&pICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria
    hr = pICriteria->LoadReg(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the state of the criteria
    hr = pICriteria->GetState(&dwState);
    if (FAILED(hr))
    {
        goto exit;
    }

    m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
    
    // Build reg path to actions
    StrCpyN(pszRegPathNew + cchRegPath, c_szRuleActions, (cchSize - cchRegPath));

    // Create a new actions object
    hr = HrCreateActions(&pIActions);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions
    hr = pIActions->LoadReg(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the state of the actions
    hr = pIActions->GetState(&dwState);
    if (FAILED(hr))
    {
        goto exit;
    }

    m_dwState = (m_dwState & ~ACT_STATE_MASK) | (dwState & ACT_STATE_MASK);
    
    // Free up the current values
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);

    // Save the new values
    m_pszName = pszName;
    pszName = NULL;
    if (FALSE == fDisabled)
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }
    m_pICrit = pICriteria;
    pICriteria = NULL;
    m_pIAct = pIActions;
    pIActions = NULL;

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    SafeRelease(pIActions);
    SafeRelease(pICriteria);
    SafeMemFree(pszName);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERule::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LPSTR       pszRegPathNew = NULL;
    ULONG       cchRegPath = 0;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't save out a rule if we don't have criteria or actions
    // or a rule name
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);

    // Write out the rule name
    if (NULL != m_pszName)
    {
        lErr = RegSetValueEx(hkeyRoot, c_szRuleName, 0, REG_SZ,
                                        (BYTE *) m_pszName, lstrlen(m_pszName) + 1);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Write out the disabled state
    dwData = !(m_dwState & RULE_STATE_DISABLED);
    lErr = RegSetValueEx(hkeyRoot, c_szRuleEnabled, 0, REG_DWORD,
                                    (BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    Assert(lstrlen(c_szRuleCriteria) >= lstrlen(c_szRuleActions));
    DWORD cchSize = (cchRegPath + lstrlen(c_szRuleCriteria) + 2);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchSize)))
    {
        goto exit;
    }

    // Build reg path to criteria
    StrCpyN(pszRegPathNew, pszRegPath, cchSize);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        StrCatBuff(pszRegPathNew, g_szBackSlash, cchSize);
        cchRegPath++;
    }

    StrCatBuff(pszRegPathNew, c_szRuleCriteria, cchSize);
    
    // Write out the criteria
    hr = m_pICrit->SaveReg(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build reg path to actions
    StrCpyN(pszRegPathNew + cchRegPath, c_szRuleActions, (cchSize - cchRegPath));

    // Write out the actions
    hr = m_pIAct->SaveReg(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bump up the version
    if (0 != (m_dwState & RULE_STATE_DIRTY))
    {
        m_dwVersion++;
    }
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (BYTE *) &m_dwVersion, sizeof(m_dwVersion));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERule::Clone(IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    COERule *   pRule = NULL;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIRule = NULL;
    
    // Create a new rule
    pRule = new COERule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the rule name
    if (NULL != m_pszName)
    {
        pRule->m_pszName = PszDupA(m_pszName);
        if (NULL == pRule->m_pszName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    
    // Copy over the enabled state
    pRule->m_dwState = m_dwState;

    // Copy over the version
    pRule->m_dwVersion = m_dwVersion;

    // Clone the criteria
    if (FAILED(m_pICrit->Clone(&(pRule->m_pICrit))))
    {
        goto exit;
    }

    // Clone the actions
    if (FAILED(m_pIAct->Clone(&(pRule->m_pIAct))))
    {
        goto exit;
    }

    // Get the rule interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRule = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pRule)
    {
        delete pRule;
    }
    return hr;
}

STDMETHODIMP COERule::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OERule;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (RULE_STATE_DIRTY == (m_dwState & RULE_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COERule::Load(IStream * pStm)
{
    HRESULT             hr = S_OK;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    LPSTR               pszName = NULL;
    BOOL                fDisabled = FALSE;
    IOECriteria *       pICriteria = NULL;
    IPersistStream *    pIPStm = NULL;
    IOEActions *        pIActions = NULL;
    
    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != RULE_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the size of the rule name
    hr = pStm->Read(&cbData, sizeof(cbData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (cbRead != sizeof(cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (0 != cbData)
    {
        // Allocate space to hold the rule name
        hr = HrAlloc((void **) &pszName, cbData);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the rule name
        hr = pStm->Read(pszName, cbData, &cbRead);
        if (FAILED(hr))
        {
            goto exit;
        }

        if (cbRead != cbData)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Get the enabled state
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (cbRead != sizeof(dwData))
    {
        hr = E_FAIL;
        goto exit;
    }

    fDisabled = ! (BOOL) dwData;

    // Create a new criteria object
    hr = HrCreateCriteria(&pICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the persistance interface for the criteria
    hr = pICriteria->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria
    hr = pIPStm->Load(pStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create a new actions object
    hr = HrCreateActions(&pIActions);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the persistance interface for the actions
    pIPStm->Release();
    pIPStm = NULL;
    hr = pIActions->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions
    hr = pIPStm->Load(pStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Free up the current values
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);

    // Save the new values
    m_pszName = pszName;
    pszName = NULL;
    if (FALSE == fDisabled)
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }
    m_pICrit = pICriteria;
    pICriteria = NULL;
    m_pIAct = pIActions;
    pIActions = NULL;

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIActions);
    SafeRelease(pICriteria);
    SafeRelease(pIPStm);
    SafeMemFree(pszName);
    return hr;
}

STDMETHODIMP COERule::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT             hr = S_OK;
    ULONG               cbData = 0;
    ULONG               cbWritten = 0;
    DWORD               dwData = 0;
    ULONG               ulIndex = 0;
    IPersistStream *    pIPStm = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't write out a rule if we don't have criteria or actions
    // or a rule name
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Write out the version
    dwData = RULE_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the size of the rule name
    if (NULL != m_pszName)
    {
        cbData = lstrlen(m_pszName) + 1;
    }
    else
    {
        cbData = 0;
    }
    
    hr = pStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));

    if (NULL != m_pszName)
    {
        // Write out the rule name
        hr = pStm->Write(m_pszName, cbData, &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == cbData);
    }
    
    // Write out the enabled state
    dwData = !(m_dwState & RULE_STATE_DISABLED);
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));

    // Get the persistance interface for the criteria
    hr = m_pICrit->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the criteria
    hr = pIPStm->Save(pStm, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the persistance interface for the actions
    pIPStm->Release();
    pIPStm = NULL;
    hr = m_pIAct->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the actions
    hr = pIPStm->Save(pStm, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIPStm);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\editrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  EditRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include "shlwapip.h" 
#include <instance.h>
#include <demand.h>

// Constants
static const int c_cCritItemGrow = 16;
static const int c_cActItemGrow = 16;
                         
const static HELPMAP g_rgCtxMapEditRule[] = {
                        {idlvCriteria,              idhCriteriaRule},
                        {idlvActions,               idhActionsRule},
                        {idredtDescription,         idhDescriptionRule},
                        {idedtRuleName,             idhRuleName},
                       {0, 0}};
                       
const static HELPMAP g_rgCtxMapEditView[] = {
                        {idlvCriteria,              idhCriteriaView},
                        {idredtDescription,         idhDescriptionView},
                        {idedtRuleName,             idhViewName},
                       {0, 0}};
                       
// The methods for the Rules Editor UI

CEditRuleUI::CEditRuleUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
            m_typeRule(RULE_TYPE_MAIL), m_hwndCrit(NULL), m_hwndAct(NULL), m_hwndDescript(NULL),
            m_hwndName(NULL), m_pIRule(NULL), m_pDescriptUI(NULL)
{
    ZeroMemory(m_rgfCritEnabled, sizeof(m_rgfCritEnabled));
    ZeroMemory(m_rgfActEnabled, sizeof(m_rgfActEnabled));
}

CEditRuleUI::~CEditRuleUI()
{    
    SafeRelease(m_pIRule);
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//  pIRule      - the rule to edit
//  pmsginfo    - the message to create the rule from
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditRuleUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule, MESSAGEINFO * pmsginfo)
{
    HRESULT         hr = S_OK;
    
    // If we're already initialized, then fail
    if ((0 != (m_dwState & STATE_INITIALIZED)) || (NULL == pIRule))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // Save off the type of rule to edit
    m_typeRule = typeRule;

    Assert(NULL == m_pDescriptUI);
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Save off the rule
    Assert(NULL == m_pIRule);
    m_pIRule = pIRule;
    pIRule->AddRef();
        
    // We're done
    m_dwState |= STATE_INITIALIZED;

    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the rules editor UI
//
//  Returns:    S_OK, if IDOK was selected
//              otherwise, S_FALSE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditRuleUI::HrShow(void)
{
    HRESULT hr = S_OK;
    int     iRet = 0;

    // If we aren't initialized, then fail
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, (RULE_TYPE_FILTER == m_typeRule) ?
                    MAKEINTRESOURCE(iddEditView) : MAKEINTRESOURCE(iddEditRule),
                    m_hwndOwner, CEditRuleUI::FEditRuleDlgProc, (LPARAM)this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditRuleDlgProc
//
//  This is the main dialog proc for the rules editor dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditRuleUI::FEditRuleDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CEditRuleUI *   pEditRuleUI = NULL;
    LPNMHDR         pnmhdr = NULL;
    LPNMLISTVIEW    pnmlv = NULL;
    LVHITTESTINFO   lvh;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    int             nIndex = 0;
    HWND            hwndRE = 0;

    pEditRuleUI = (CEditRuleUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pEditRuleUI = (CEditRuleUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pEditRuleUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtDescription);

            if (!hwndRE || (FALSE == pEditRuleUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idedtRuleName:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        pEditRuleUI->FOnNameChange((HWND) lParam);
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;
                
                case IDOK:
                    if (FALSE != pEditRuleUI->FOnOK())
                    {
                        EndDialog(hwndDlg, IDOK);
                        fRet = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR) lParam;
            
            switch (((LPNMHDR)lParam)->code)
            {
                case NM_CLICK:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlv = (LPNMLISTVIEW) lParam;
                        pEditRuleUI->FOnListClick(pnmhdr->hwndFrom, pnmlv);
                    }
                    break;

                case NM_DBLCLK:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlv = (LPNMLISTVIEW) lParam;
                    
                        ZeroMemory(&lvh, sizeof(lvh));
                        lvh.pt = pnmlv->ptAction;
                        ListView_HitTest(pnmhdr->hwndFrom, &lvh);
                        if ((-1 != pnmlv->iItem) && (0 != (lvh.flags & LVHT_ONITEMLABEL)))
                        {                  
                            pEditRuleUI->HandleEnabledState(pnmhdr->hwndFrom, pnmlv->iItem);
                        }
                    }
                    break;
                
                case LVN_KEYDOWN:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlvkd = (NMLVKEYDOWN *) lParam;
                        if (VK_SPACE == pnmlvkd->wVKey)
                        {
                            nIndex = ListView_GetNextItem(pnmhdr->hwndFrom, -1, LVNI_SELECTED);
                            if (0 <= nIndex)
                            {
                                pEditRuleUI->HandleEnabledState(pnmhdr->hwndFrom, nIndex);
                            }
                        }
                    }
                    break;
            }
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = pEditRuleUI->FOnHelp(uMsg, wParam, lParam);
            break;
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This is the initialization routine for the rules editor dialog
//
//  hwndDlg - handle to the rules editor dialog
//
//  Returns:    TRUE, if the dialog was initialized successfully
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    INT         iSelect = 0;

    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndCrit = GetDlgItem(m_hwndDlg, idlvCriteria);
    if (RULE_TYPE_FILTER != m_typeRule)
    {
        m_hwndAct = GetDlgItem(hwndDlg, idlvActions);
    }
    m_hwndDescript = GetDlgItem(hwndDlg, idredtDescription);
    m_hwndName = GetDlgItem(hwndDlg, idedtRuleName);
    if ((NULL == m_hwndCrit) || ((RULE_TYPE_FILTER != m_typeRule) && (NULL == m_hwndAct)) ||
                (NULL == m_hwndDescript) || (NULL == m_hwndName))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize criteria listbox control
    if (FALSE == _FInitializeCritListCtrl())
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize criteria listbox control
    if (RULE_TYPE_FILTER != m_typeRule)
    {
        if (FALSE == _FInitializeActListCtrl())
        {
            fRet = FALSE;
            goto exit;
        }
    }

    // Load the criteria listbox control
    if (FALSE == _FLoadCritListCtrl(&iSelect))
    {
        fRet = FALSE;
        goto exit;
    }

    _SetTitleText();
    
    // Select the default item in the criteria list
    ListView_SetItemState(m_hwndCrit, iSelect, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    // Make sure the default item is visible
    ListView_EnsureVisible(m_hwndCrit, iSelect, FALSE);
    
    // Initialize the description field
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    if (FAILED(m_pDescriptUI->HrSetRule(m_typeRule, m_pIRule)))
    {
        fRet = FALSE;
        goto exit;
    }

    // If we are a filter and are new
    if ((RULE_TYPE_FILTER == m_typeRule) && (0 != (m_dwFlags & ERF_ADDDEFAULTACTION)))
    {
        // Set the default action
        if (FAILED(m_pDescriptUI->HrEnableActions(ACT_TYPE_SHOW, TRUE)))
        {
            goto exit;
        }
    }

    m_pDescriptUI->ShowDescriptionString();

    // Initialize the name field
    if (FAILED(m_pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    if ((VT_LPSTR != propvar.vt) || (NULL == propvar.pszVal) || ('\0' == propvar.pszVal[0]))
    {
        fRet = FALSE;
        goto exit;
    }

    Edit_SetText(m_hwndName, propvar.pszVal);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnListClick
//
//  This handles clicking on either of the lists
//
//  Returns:    TRUE, we handled the click message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnListClick(HWND hwndList, LPNMLISTVIEW pnmlv)
{
    BOOL            fRet = FALSE;
    int             iIndex = 0;
    int             iSelected = 0;
    LVHITTESTINFO   lvh;

    Assert(NULL != m_hwndCrit);
    
    if ((NULL == hwndList) || (NULL == pnmlv))
    {
        fRet = FALSE;
        goto exit;
    }
    
    ZeroMemory(&lvh, sizeof(lvh));
    lvh.pt = pnmlv->ptAction;
    iIndex = ListView_HitTest(hwndList, &lvh);
    if (-1 == iIndex)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Let's make sure this item is already selected
    iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (iSelected != iIndex)
    {
        ListView_SetItemState(hwndList, iIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if ((lvh.flags & LVHT_ONITEMSTATEICON) &&
                    !(lvh.flags & LVHT_ONITEMLABEL))
    {
        HandleEnabledState(hwndList, iIndex);
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnOK
//
//  This handles clicking on the links in the description field
//
//  Returns:    TRUE, we handled the click message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnOK(void)
{
    BOOL            fRet = FALSE;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar;
    HRESULT         hr = S_OK;
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;
    BOOL            fNewRule = FALSE;
    LPSTR           pszName = NULL;
    ULONG           cchName = 0;
    
    ZeroMemory(&propvar, sizeof(propvar));
    
    if (NULL == m_pIRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // First let's validate the name and all the criteria and actions

    // Get the name from the edit well
    cchName = Edit_GetTextLength(m_hwndName) + 1;
    if (FAILED(HrAlloc((void **) &pszName, cchName * sizeof(*pszName))))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pszName[0] = '\0';
    cchName = Edit_GetText(m_hwndName, pszName, cchName);
    
    // Check to see if the name is valid
    if (0 == UlStripWhitespace(pszName, TRUE, TRUE, NULL))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoName) : MAKEINTRESOURCEW(idsViewsErrorNoName),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }

    
    // Let's make sure they have the right parts

    // Get the criteria for the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have any criteria
    if (0 == cCritItem)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoCriteria) : MAKEINTRESOURCEW(idsViewsErrorNoCriteria),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Do we have any criteria
    if (0 == cActItem)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoActions) : MAKEINTRESOURCEW(idsViewsErrorNoActions),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }

    // Let's check to see if we really need to do anything
    hr = m_pDescriptUI->HrIsDirty();
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_FALSE == hr))
    {
        fRet = TRUE;
        goto exit;
    }
    
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRulesErrorFix), NULL,
                        MB_OK | MB_ICONINFORMATION);
        m_pDescriptUI->ShowDescriptionString();
        fRet = FALSE;
        goto exit;
    }

    // Set the criteria on the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = m_pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions on the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = m_pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the rule name
    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    hr = m_pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();

    // Note that we saved
    m_dwState &= ~STATE_DIRTY;
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    PropVariantClear(&propvar);
    SafeMemFree(pszName);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnHelp
//
//  This handles the WM_HELP message for the rules edit UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnHelp(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(OnContextHelp(m_hwndDlg, uiMsg, wParam, lParam, (RULE_TYPE_FILTER == m_typeRule) ? g_rgCtxMapEditView : g_rgCtxMapEditRule));
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNameChange
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnNameChange(HWND hwndName)
{
    BOOL    fRet = FALSE;

    Assert(NULL != m_hwndName);
    Assert(hwndName == m_hwndName);

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
    // Disable the OK button if the name is empty
    fRet = RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndName));

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HandleEnabledState
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  nIndex      - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CEditRuleUI::HandleEnabledState(HWND hwndList, int nItem)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi;
    BOOL        fEnabled = FALSE;
    INT         iIndex = 0;
    LONG        lItem = 0;
    INT         cItems = 0;

    // Grab the list view item
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE | LVIF_PARAM;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.iItem = nItem;
    if (FALSE == ListView_GetItem(hwndList, &lvi))
    {
        goto exit;
    }

    lItem = (LONG) lvi.lParam;
    
    if (INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) == lvi.state)
    {
        goto exit;
    }
    
    // Get the new enabled value
    fEnabled = (lvi.state != INDEXTOSTATEIMAGEMASK(iiconStateChecked+1));

    // Build up the description string
    if (hwndList == m_hwndCrit)
    {
        if (FALSE == _FAddCritToList(nItem, fEnabled))
        {
            goto exit;
        }
    }
    else
    {
        // Set the UI to the opposite enabled state
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_STATE;
        lvi.iItem = nItem;
        lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateChecked+1) :
                                INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        ListView_SetItem(hwndList, &lvi);

        // Figure out the number of items in the list
        cItems = ListView_GetItemCount(hwndList);

        Assert(hwndList == m_hwndAct);
        m_pDescriptUI->HrEnableActions(c_rgEditActList[lItem].typeAct, fEnabled);
        
        // Do we need to go through and update all the items?
        if (0 != (c_rgEditActList[lItem].dwFlags & STATE_EXCLUSIVE))
        {
            for (iIndex = 0; iIndex < cItems; iIndex++)
            {
                // We already handled this one
                if (iIndex == nItem)
                {
                    continue;
                }
                
                // Change the state
                lvi.mask = LVIF_STATE;
                lvi.iItem = iIndex;
                lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) :
                                        INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                ListView_SetItem(hwndList, &lvi);

                if (FALSE != fEnabled)
                {
                    // Figure out which action the item corresponds to
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = iIndex;
                    if ((FALSE != ListView_GetItem(hwndList, &lvi)) && 
                            (lvi.lParam >= 0) && (lvi.lParam < c_cEditActList))
                    {
                        m_pDescriptUI->HrEnableActions(c_rgEditActList[lvi.lParam].typeAct, FALSE);
                    }
                }
            }
        }
    }

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitializeCritListCtrl
//
//  This initializes the criteria list view with the list of criteria
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FInitializeCritListCtrl(void)
{
    BOOL                fRet = FALSE;
    LVCOLUMN            lvc = {0};
    RECT                rc = {0};
    HIMAGELIST          himl = NULL;
    LVITEM              lvi = {0};
    TCHAR               szRes[CCHMAX_STRINGRES];
    UINT                uiEditCritList = 0;
    const CRIT_LIST *   pCritList = NULL;
    UINT                cchRes = 0;
    LPTSTR              pszMark = NULL;

    Assert(NULL != m_hwndCrit);

    // Initialize the list view column structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndCrit, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndCrit, 0, &lvc);

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndCrit, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndCrit, LVS_EX_FULLROWSELECT);

    // Initialize the list view item structure
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
    lvi.pszText = szRes;
    
    // Add each criteria to the list view
    for (uiEditCritList = 0; uiEditCritList < ARRAYSIZE(c_rgEditCritList); uiEditCritList++)
    {
        pCritList = &(c_rgEditCritList[uiEditCritList]);

        // Is this item editable
        if (0 != (pCritList->dwFlags & STATE_NOEDIT))
        {
            continue;
        }
        
        // Is this criteria valid for this type of rule?
        if (((RULE_TYPE_MAIL == m_typeRule) && (0 == (pCritList->dwFlags & STATE_MAIL))) ||
                    ((RULE_TYPE_NEWS == m_typeRule) && (0 == (pCritList->dwFlags & STATE_NEWS))) ||
                    ((RULE_TYPE_FILTER == m_typeRule) && (0 == (pCritList->dwFlags & STATE_FILTER))))
        {
            continue;
        }
                    
        // Load up the string to use.
        cchRes = LoadString(g_hLocRes, pCritList->uiText, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            continue;
        }

        // Parse out the string mark
        pszMark = StrStr(szRes, c_szRuleMarkStart);
        
        while (NULL != pszMark)
        {
            // Remove the mark start
            StrCpyN(pszMark, pszMark + lstrlen(c_szRuleMarkStart), (DWORD)(ARRAYSIZE(szRes) - (pszMark - szRes)));

            // Search for the mark end
            pszMark = StrStr(pszMark, c_szRuleMarkEnd);
            if (NULL == pszMark)
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Remove the mark end
            StrCpyN(pszMark, pszMark + lstrlen(c_szRuleMarkEnd), (DWORD)(ARRAYSIZE(szRes) - (pszMark - szRes)));
            
            // Search for the mark start
            pszMark = StrStr(pszMark, c_szRuleMarkStart);
        }
        
        lvi.cchTextMax = lstrlen(szRes);
        lvi.lParam = (LONG) uiEditCritList;

        if (-1 != ListView_InsertItem(m_hwndCrit, &lvi))
        {
            lvi.iItem++;
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadCritListCtrl
//
//  This load the criteria list view with the list of criteria
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FLoadCritListCtrl(INT * piSelect)
{
    BOOL                fRet = FALSE;
    PROPVARIANT         propvar = {0};
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    BOOL                fExclusive = FALSE;
    INT                 cItems = 0;
    LVITEM              lvi = {0};
    ULONG               ulIndex = 0;
    INT                 iSelect = 0;
    DWORD               dwState = 0;
    TCHAR               szRes[CCHMAX_STRINGRES];
    INT                 iItem = 0;
    
    Assert(NULL != m_hwndCrit);
    Assert(NULL != piSelect);

    // Initialize the outgoing param
    *piSelect = 0;

    // Make sure we have something to do...
    if (NULL == m_pIRule)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Get the criteria from the rule
    if (FAILED(m_pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        fRet = TRUE;
        goto exit;
    }

    Assert(NULL != propvar.blob.pBlobData);
    cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
    
    // Do we have any exclusive criteria set?
    if (1 == cCritItem)
    {
        // Find the criteria item in the list
        for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditCritList); ulIndex++)
        {
            // Is this the criteria item?
            if ((pCritItem->type == c_rgEditCritList[ulIndex].typeCrit) &&
                    (0 != (c_rgEditCritList[ulIndex].dwFlags & STATE_EXCLUSIVE)))
            {
                fExclusive = TRUE;
                break;
            }
        }
    }
    
    // Figure out how many items are in the list control
    cItems = ListView_GetItemCount(m_hwndCrit);
    iSelect = cItems;
    
    // Initialize the list view item structure
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    
    // If we're exclusive
    if (FALSE != fExclusive)
    {
        // Disable each of the items
        // except for the exclusive one
        for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
        {
            if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
            {
                continue;
            }

            // Is this the criteria item?
            if (pCritItem->type == c_rgEditCritList[lvi.lParam].typeCrit)
            {
                dwState = INDEXTOSTATEIMAGEMASK(iiconStateChecked+1);
                
                // Is this the first item we found in the list
                if (iSelect > lvi.iItem)
                {
                    iSelect = lvi.iItem;
                }
            }
            else
            {
                dwState = INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1);
            }

            // Set the state
            ListView_SetItemState(m_hwndCrit, lvi.iItem, dwState, LVIS_STATEIMAGEMASK);
        }
    }
    else
    {
        // Add each criteria to the list view
        for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
        {
            // Find the criteria item in the list
            for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
            {
                if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
                {
                    continue;
                }

                // Is this the criteria item?
                if ((pCritItem[ulIndex].type == c_rgEditCritList[lvi.lParam].typeCrit) &&
                        (INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1) == lvi.state))
                {
                    break;
                }
            }

            // Did we find anything?
            if (lvi.iItem >= cItems)
            {
                fRet = FALSE;
                goto exit;
            }

            // Save off the item
            iItem = lvi.iItem;
            
            // Is this the first item we found in the list
            if (iSelect > iItem)
            {
                iSelect = iItem;
            }

#ifdef NEVER
            // Can we add multiple items?
            if (0 == (c_rgEditCritList[lvi.lParam].dwFlags & STATE_NODUPS))
            {
                // Regrab the item
                lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                lvi.pszText = szRes;
                lvi.cchTextMax = sizeof(szRes);

                if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
                {
                    continue;
                }

                // Add the item to the list
                
                // Fix up the item to insert into the list
                lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);

                // Insert the item into the list
                lvi.iItem++;
                if (-1 == ListView_InsertItem(m_hwndCrit, &lvi))
                {
                    fRet = FALSE;
                    goto exit;
                }

                // Add one since we just added an item
                cItems++;
            }
#endif  // NEVER
            
            // Set the state
            ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateChecked+1), LVIS_STATEIMAGEMASK);
        }
    }

    // Set the outgoing param
    *piSelect = iSelect;
    
    // Set the return value
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the view passed in to the list view
//
//  dwIndex - the index on where to add the view to into the list
//  pIRule  - the actual view
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FAddCritToList(INT iItem, BOOL fEnable)
{
    BOOL                fRet = FALSE;
    LVITEM              lvitem = {0};
    TCHAR               szRes[CCHMAX_STRINGRES];
    INT                 cItems = 0;
    LVITEM              lvi = {0};
    DWORD               dwState = 0;

    Assert(NULL != m_hwndCrit);

    // If there's nothing to do...
    if (-1 == iItem)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view item structure
    lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvitem.iItem = iItem;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.pszText = szRes;
    lvitem.cchTextMax = sizeof(szRes);
    
    // Get the item from the list
    if (FALSE == ListView_GetItem(m_hwndCrit, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }

    if (INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) == lvitem.state)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Do we need to go through and update all the items?
    if (0 != (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_EXCLUSIVE))
    {
        // Figure out how many items are in the list control
        cItems = ListView_GetItemCount(m_hwndCrit);
        
        // Initialize the list view item structure
        lvi.mask = LVIF_PARAM | LVIF_STATE;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        
        // For each item in the list
        for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
        {
            // Get the item from the list
            if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
            {
                fRet = FALSE;
                goto exit;
            }

            // We'll handle this item later
            if (lvitem.lParam == lvi.lParam)
            {
                iItem = lvi.iItem;
                continue;
            }
            
            // If it's enabled
            if (INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) == lvi.state)
            {
                // Remove it from the criteria
                if (FAILED(m_pDescriptUI->HrEnableCriteria(c_rgEditCritList[lvi.lParam].typeCrit, FALSE)))
                {
                    fRet = FALSE;
                    goto exit;
                }
    
#ifdef NEVER
                // if it allows dups
                if (0 == (c_rgEditCritList[lvi.lParam].dwFlags & STATE_NODUPS))
                {
                    // remove it
                    if (FALSE == ListView_DeleteItem(m_hwndCrit, lvi.iItem))
                    {
                        fRet = FALSE;
                        goto exit;
                    }

                    // Subtract the item
                    cItems--;
                    lvi.iItem--;
                }
                else
#endif  // NEVER
                {
                    // disable
                    ListView_SetItemState(m_hwndCrit, lvi.iItem, INDEXTOSTATEIMAGEMASK(iiconStateDisabled + 1), LVIS_STATEIMAGEMASK);
                }
            }
            else
            {
                if (FALSE == fEnable)
                {
                    dwState = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                }
                else
                {
                    dwState = INDEXTOSTATEIMAGEMASK(iiconStateDisabled + 1);
                }
                
                // uncheck/disable it
                ListView_SetItemState(m_hwndCrit, lvi.iItem, dwState, LVIS_STATEIMAGEMASK);
            }
                                
        }
    }

    // Add/Remove the item from the description
    if (FAILED(m_pDescriptUI->HrEnableCriteria(c_rgEditCritList[lvitem.lParam].typeCrit, fEnable)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FALSE != fEnable)
    {
#ifdef NEVER
        // Can we add another one?
        if (0 == (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_NODUPS))
        {
            // Fix up the item to insert into the list
            lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);

            // Insert the item into the list
            lvitem.iItem++;
            if (-1 == ListView_InsertItem(m_hwndCrit, &lvitem))
            {
                fRet = FALSE;
                goto exit;
            }
        }
#endif  // NEVER
        
        // Set the item to enabled
        ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateChecked+1), LVIS_STATEIMAGEMASK);
    }
    else
    {
#ifdef NEVER
        // Can we remove this one?
        if (0 == (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_NODUPS))
        {
            // Remove the inserted item
            if (FALSE == ListView_DeleteItem(m_hwndCrit, iItem))
            {
                fRet = FALSE;
                goto exit;
            }
        }
        else
#endif  // NEVER
        {
            // Set the item to enabled
            ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1), LVIS_STATEIMAGEMASK);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitializeActListCtrl
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FInitializeActListCtrl(void)
{
    BOOL                fRet = FALSE;
    LVCOLUMN            lvc;
    RECT                rc;
    HIMAGELIST          himl = NULL;
    HRESULT             hr = S_OK;
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               ulIndex = 0;
    UINT                uiEditActList = 0;
    DWORD               dwIndex = 0;
    const ACT_LIST *    pActList = NULL;
    LVITEM              lvi;
    TCHAR               szRes[CCHMAX_STRINGRES];
    UINT                cchRes = 0;
    LPTSTR              pszMark = NULL;
    BOOL                fEnabled = FALSE;
    BOOL                fExclusive = FALSE;
    PROPVARIANT         propvar;

    Assert(NULL != m_hwndAct);

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndAct, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndAct, 0, &lvc);

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndAct, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndAct, LVS_EX_FULLROWSELECT);

    // Get the list of actions from the rule
    hr = m_pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (SUCCEEDED(hr) && (0 != propvar.blob.cbSize))
    {
        cActItem = propvar.blob.cbSize / sizeof(ACT_ITEM);
        pActItem = (ACT_ITEM *) (propvar.blob.pBlobData);
        propvar.blob.pBlobData = NULL;
        propvar.blob.cbSize = 0;

    }
    
    // Do we have any exclusive actions
    for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
    {
        for (uiEditActList = 0; uiEditActList < ARRAYSIZE(c_rgEditActList); uiEditActList++)
        {
            pActList = &(c_rgEditActList[uiEditActList]);
            if ((pActItem[ulIndex].type == pActList->typeAct) && 
                            (0 != (pActList->dwFlags & STATE_EXCLUSIVE)))
            {
                fExclusive = TRUE;
                break;
            }
        }
    }
        
    // Add the actions to the list view
    for (uiEditActList = 0; uiEditActList < ARRAYSIZE(c_rgEditActList); uiEditActList++)
    {
        pActList = &(c_rgEditActList[uiEditActList]);
        
        // Is this item editable
        if (0 != (pActList->dwFlags & STATE_NOEDIT))
        {
            continue;
        }
        
        // Is this action valid for this type of rule?
        if (((RULE_TYPE_MAIL == m_typeRule) && (0 == (pActList->dwFlags & STATE_MAIL))) ||
                    ((RULE_TYPE_NEWS == m_typeRule) && (0 == (pActList->dwFlags & STATE_NEWS))) ||
                    ((RULE_TYPE_FILTER == m_typeRule) && (0 == (pActList->dwFlags & STATE_FILTER))) ||
                    ((RULE_TYPE_MAIL == m_typeRule) && (0 != (pActList->dwFlags & STATE_JUNK))
                    && (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
             ))
        {
            continue;
        }
                    
                    
        // Is this action enabled?
        fEnabled = FALSE;
        for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
        {
            if (pActItem[ulIndex].type == pActList->typeAct)
            {
                fEnabled = TRUE;
                break;
            }
        }
        
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lvi.iItem = dwIndex;
        lvi.iSubItem = 0;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        if (FALSE != fEnabled)
        {
            lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateChecked+1);
        }
        else
        {
            lvi.state = fExclusive ? INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1)
                                : INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
        }

        // Load up the string to use.
        cchRes = LoadString(g_hLocRes, pActList->uiText, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            continue;
        }

        // Parse out the string mark
        pszMark = StrStr(szRes, c_szRuleMarkStart);
        
        while (NULL != pszMark)
        {
            // Remove the mark start
            StrCpyN(pszMark, pszMark + lstrlen(c_szRuleMarkStart), (DWORD)(ARRAYSIZE(szRes) - (pszMark - szRes)));

            // Search for the mark end
            pszMark = StrStr(pszMark, c_szRuleMarkEnd);
            if (NULL == pszMark)
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Remove the mark end
            StrCpyN(pszMark, pszMark + lstrlen(c_szRuleMarkEnd), (DWORD)(ARRAYSIZE(szRes) - (pszMark - szRes)));
            
            // Search for the mark start
            pszMark = StrStr(pszMark, c_szRuleMarkStart);
        }
        
        lvi.pszText = szRes;
        lvi.cchTextMax = lstrlen(szRes);
        lvi.lParam = (LONG) uiEditActList;

        if (-1 != ListView_InsertItem(m_hwndAct, &lvi))
        {
            dwIndex++;
        }
    }
    
    ListView_SetItemState(m_hwndAct, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

VOID CEditRuleUI::_SetTitleText(VOID)
{
    CHAR    rgchTitle[CCHMAX_STRINGRES];
    UINT    uiID = 0;
    
    // Figure out which string to load
    switch (m_typeRule)
    {
        case RULE_TYPE_MAIL:
            if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewMailRuleTitle;
            }
            else
            {
                uiID = idsEditMailRuleTitle;
            }
            break;

        case RULE_TYPE_NEWS:
            if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewNewsRuleTitle;
            }
            else
            {
                uiID = idsEditNewsRuleTitle;
            }
            break;

        case RULE_TYPE_FILTER:
            if (0 != (m_dwFlags & ERF_CUSTOMIZEVIEW))
            {
                uiID = idsCustomizeViewTitle;
            }
            else if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewViewTitle;
            }
            else
            {
                uiID = idsEditViewTitle;
            }
            break;
    }

    // Is there anything to do?
    if (0 == uiID)
    {
        goto exit;
    }
    
    // Load the string
    AthLoadString(uiID, rgchTitle, sizeof(rgchTitle));
    
    // Set the title
    SetWindowText(m_hwndDlg, rgchTitle);

exit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\editrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  EditRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "ruledesc.h"

static const int c_cchNameMax = 257;

typedef struct tagCRIT_LIST
{
    CRIT_TYPE   typeCrit;
    DWORD       dwFlags;
    UINT        uiText;
    UINT        uiTextAlt;
} CRIT_LIST, * PCRIT_LIST;

typedef struct tagACT_LIST
{
    ACT_TYPE    typeAct;
    DWORD       dwFlags;
    UINT        uiText;
    UINT        uiTextAlt;
} ACT_LIST, * PACT_LIST;

static const int STATE_DEFAULT      = 0x00000000;
static const int STATE_INITIALIZED  = 0x00000001;
static const int STATE_DIRTY        = 0x00000002;
static const int STATE_EXCLUSIVE    = 0x00000004;
static const int STATE_MAIL         = 0x00000008;
static const int STATE_NEWS         = 0x00000010;
static const int STATE_FILTER       = 0x00000020;
static const int STATE_NOEDIT       = 0x00000040;
static const int STATE_JUNK         = 0x00000080;
static const int STATE_ALL          = STATE_MAIL | STATE_NEWS | STATE_FILTER;
static const int STATE_NOFILTER     = STATE_MAIL | STATE_NEWS;
static const int STATE_NOMAIL       = STATE_NEWS | STATE_FILTER;
static const int STATE_NONEWS       = STATE_MAIL | STATE_FILTER;


static const CRIT_LIST c_rgEditCritList[] =
{
    {CRIT_TYPE_NEWSGROUP,    STATE_NEWS,                        idsCriteriaNewsgroup,       idsCriteriaNewsgroup},
    {CRIT_TYPE_FROM,        STATE_ALL,                          idsCriteriaFrom,            idsCriteriaFromNot},
    {CRIT_TYPE_SUBJECT,     STATE_ALL,                          idsCriteriaSubject,         idsCriteriaSubjectNot},
    {CRIT_TYPE_BODY,        STATE_MAIL,                         idsCriteriaBody,            idsCriteriaBodyNot},
    {CRIT_TYPE_TO,          STATE_MAIL,                         idsCriteriaTo,              idsCriteriaToNot},
    {CRIT_TYPE_CC,          STATE_MAIL,                         idsCriteriaCC,              idsCriteriaCCNot},
    {CRIT_TYPE_TOORCC,      STATE_MAIL,                         idsCriteriaToOrCC,          idsCriteriaToOrCCNot},
    {CRIT_TYPE_PRIORITY,    STATE_NONEWS,                       idsCriteriaPriority,        idsCriteriaPriority},
    {CRIT_TYPE_ACCOUNT,     STATE_ALL,                          idsCriteriaAccount,         idsCriteriaAccount},
    {CRIT_TYPE_AGE,         STATE_NOMAIL,                       idsCriteriaAge,             idsCriteriaAge},
    {CRIT_TYPE_SIZE,        STATE_MAIL,                         idsCriteriaSize,            idsCriteriaSize},
    {CRIT_TYPE_LINES,       STATE_NOMAIL,                       idsCriteriaLines,           idsCriteriaLines},
    {CRIT_TYPE_ATTACH,      STATE_NONEWS,                       idsCriteriaAttachment,      idsCriteriaAttachment},
//    {CRIT_TYPE_DATE,        idsCriteriaDate},
//    {CRIT_TYPE_HEADER,      idsCriteriaHeader},
    {CRIT_TYPE_JUNK,        STATE_NOEDIT,                       idsCriteriaJunk,            idsCriteriaJunk},
    {CRIT_TYPE_SENDER,      STATE_NOEDIT,                       idsCriteriaSender,          idsCriteriaSender},
    {CRIT_TYPE_READ,        STATE_FILTER,                       idsCriteriaRead,            idsCriteriaNotRead},
//    {CRIT_TYPE_REPLIES,     STATE_FILTER,                       idsCriteriaReplies,         idsCriteriaReplies},
    {CRIT_TYPE_DOWNLOADED,  STATE_FILTER,                       idsCriteriaDownloaded,      idsCriteriaNotDownloaded},
//    {CRIT_TYPE_DELETED,     STATE_FILTER,                       idsCriteriaDeleted,         idsCriteriaNotDeleted},
    {CRIT_TYPE_FLAGGED,     STATE_FILTER,                       idsCriteriaFlagged,         idsCriteriaNotFlagged},
    {CRIT_TYPE_THREADSTATE, STATE_FILTER,                       idsCriteriaThreadState,     idsCriteriaThreadState},
    {CRIT_TYPE_SECURE,      STATE_NONEWS,                       idsCriteriaSecure,          idsCriteriaSecure},
    {CRIT_TYPE_ALL,         STATE_EXCLUSIVE | STATE_ALL,        idsCriteriaAll,             idsCriteriaAll}
};

static const ULONG c_cEditCritList = sizeof(c_rgEditCritList)/sizeof(c_rgEditCritList[0]);

static const ACT_LIST c_rgEditActList[] =
{
    {ACT_TYPE_MOVE,         STATE_MAIL,                         idsActionsMove,             idsActionsMove},
    {ACT_TYPE_COPY,         STATE_MAIL,                         idsActionsCopy,             idsActionsCopy},
    {ACT_TYPE_DELETE,       STATE_NOFILTER,                     idsActionsDelete,           idsActionsDelete},
    {ACT_TYPE_FWD,          STATE_MAIL,                         idsActionsFwd,              idsActionsFwd},
    {ACT_TYPE_JUNKMAIL,     STATE_MAIL | STATE_JUNK,            idsActionsJunkMail,         idsActionsJunkMail},
//    {ACT_TYPE_NOTIFYMSG,    idsActionsNotifyMsg},
//    {ACT_TYPE_NOTIFYSND,    STATE_NOFILTER,                     idsActionsNotifySound,      idsActionsNotifySound},
    {ACT_TYPE_HIGHLIGHT,    STATE_NOFILTER,                     idsActionsHighlight,        idsActionsHighlight},
    {ACT_TYPE_FLAG,         STATE_NOFILTER,                     idsActionsFlag,             idsActionsFlag},
    {ACT_TYPE_READ,         STATE_NOFILTER,                     idsActionsRead,             idsActionsRead},
    {ACT_TYPE_WATCH,        STATE_NOFILTER,                     idsActionsWatch,            idsActionsWatch},
    {ACT_TYPE_REPLY,        STATE_MAIL,                         idsActionsReply,            idsActionsReply},
    {ACT_TYPE_MARKDOWNLOAD, STATE_NEWS,                         idsActionsDownload,         idsActionsDownload},
    {ACT_TYPE_STOP,         STATE_NOFILTER,                     idsActionsStop,             idsActionsStop},
    {ACT_TYPE_DONTDOWNLOAD, STATE_EXCLUSIVE | STATE_MAIL,       idsActionsDontDownload,     idsActionsDontDownload},
    {ACT_TYPE_DELETESERVER, STATE_EXCLUSIVE | STATE_MAIL,       idsActionsDelServer,        idsActionsDelServer},
    {ACT_TYPE_SHOW,         STATE_EXCLUSIVE | STATE_FILTER,     idsActionsShow,             idsActionsShow}
};

static const ULONG c_cEditActList = sizeof(c_rgEditActList)/sizeof(c_rgEditActList[0]);

const int ERF_ADDDEFAULTACTION  = 0x00000001;
const int ERF_NEWRULE           = 0x00000002;
const int ERF_CUSTOMIZEVIEW     = 0x00000004;
const int ERF_CREATERULE        = 0x00000008;

class CEditRuleUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    HWND                m_hwndDlg;
    RULE_TYPE           m_typeRule;
    HWND                m_hwndCrit;
    HWND                m_hwndAct;
    HWND                m_hwndDescript;
    HWND                m_hwndName;
    IOERule *           m_pIRule;
    CRuleDescriptUI *   m_pDescriptUI;
    BOOL                m_rgfCritEnabled[c_cEditCritList];
    BOOL                m_rgfActEnabled[c_cEditActList];
    
  public:
    CEditRuleUI();
    ~CEditRuleUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule, MESSAGEINFO * pmsginfo);
    HRESULT HrShow(void);
            
    // The Rules Manager dialog function
    static INT_PTR CALLBACK FEditRuleDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

    // Message handling functions
    BOOL FOnInitDialog(HWND hwndDlg);
    BOOL FOnListClick(HWND hwndList, LPNMLISTVIEW pnmlv);
    BOOL FOnHelp(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    BOOL FOnOK(void);
    BOOL FOnNameChange(HWND hwndName);

    // Utility functions
    BOOL _FInitializeCritListCtrl(VOID);
    BOOL _FLoadCritListCtrl(INT * piSelect);
    BOOL _FAddCritToList(INT iItem, BOOL fEnable);
    BOOL _FInitializeActListCtrl(VOID);
    VOID _SetTitleText(VOID);
    void HandleEnabledState(HWND hwndList, int nItem);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rulesmgr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesMgr.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rulesmgr.h"
#include "ruleutil.h"
#include "rule.h"
#include "junkrule.h"
#include <msgfldr.h>
#include <goptions.h>
#include <instance.h>
#include "demand.h"

CRulesManager::CRulesManager() : m_cRef(0), m_dwState(STATE_LOADED_INIT),
                m_pMailHead(NULL), m_pNewsHead(NULL), m_pFilterHead(NULL),
                m_pIRuleSenderMail(NULL),m_pIRuleSenderNews(NULL),
                m_pIRuleJunk(NULL)
{
    // Thread Safety
    InitializeCriticalSection(&m_cs);
}

CRulesManager::~CRulesManager()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    if (NULL != m_pMailHead)
    {
        _HrFreeRules(RULE_TYPE_MAIL);
    }

    if (NULL != m_pNewsHead)
    {
        _HrFreeRules(RULE_TYPE_NEWS);
    }

    if (NULL != m_pFilterHead)
    {
        _HrFreeRules(RULE_TYPE_FILTER);
    }

    SafeRelease(m_pIRuleSenderMail);
    SafeRelease(m_pIRuleSenderNews);
    SafeRelease(m_pIRuleJunk);

    // Thread Safety
    DeleteCriticalSection(&m_cs);
}

STDMETHODIMP_(ULONG) CRulesManager::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CRulesManager::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CRulesManager::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERulesManager))
    {
        *ppvObject = static_cast<IOERulesManager *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CRulesManager::Initialize(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CRulesManager::GetRule(RULEID ridRule, RULE_TYPE type, DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    IOERule *   pIRule = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (RULEID_INVALID == ridRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the ougoing params
    if (NULL != ppIRule)
    {
        *ppIRule = NULL;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Check the special types
    if (RULEID_SENDERS == ridRule)
    {
        if (RULE_TYPE_MAIL == type)
        {
            pIRule = m_pIRuleSenderMail;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            pIRule = m_pIRuleSenderNews;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }
    else if (RULEID_JUNK == ridRule)
    {
        
        if (RULE_TYPE_MAIL != type)
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        pIRule = m_pIRuleJunk;
    }
    else
    {
        // Walk the proper list
        if (RULE_TYPE_MAIL == type)
        {
            pNodeWalk = m_pMailHead;
        }
        else if (RULE_TYPE_NEWS == type)

        {
            pNodeWalk = m_pNewsHead;
        }
        else if (RULE_TYPE_FILTER == type)
        {
            pNodeWalk = m_pFilterHead;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        for (; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
        {
            if (ridRule == pNodeWalk->ridRule)
            {
                pIRule = pNodeWalk->pIRule;
                break;
            }
        }
    }

    // Did we find something?
    if (NULL == pIRule)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the outgoing param
    if (NULL != ppIRule)
    {
        *ppIRule = pIRule;
        (*ppIRule)->AddRef();
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::FindRule(LPCSTR pszRuleName, RULE_TYPE type, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    PROPVARIANT propvar;

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if ((NULL == pszRuleName) || (NULL == ppIRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the ougoing params
    *ppIRule = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Walk the proper list
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        pNodeWalk = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    while (NULL != pNodeWalk)
    {
        // Check to see if the name of the rule is the same
        hr = pNodeWalk->pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
        if (FAILED(hr))
        {
            continue;
        }

        if (0 == lstrcmpi(propvar.pszVal, pszRuleName))
        {
            *ppIRule = pNodeWalk->pIRule;
            (*ppIRule)->AddRef();
            break;
        }

        // Move to the next one
        PropVariantClear(&propvar);
        pNodeWalk = pNodeWalk->pNext;
    }
    
    // Set the proper return value
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
    
exit:
    PropVariantClear(&propvar);
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::GetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO ** ppinfoRule, ULONG * pcpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       cpinfoRule = 0;
    RULEINFO *  pinfoRuleAlloc = NULL;
    IOERule *   pIRuleSender = NULL;
    RULENODE *  prnodeList = NULL;
    RULENODE *  prnodeWalk = NULL;
    ULONG       ulIndex = 0;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check the incoming params
    if (NULL == ppinfoRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppinfoRule = NULL;
    if (NULL != pcpinfoRule)
    {
        *pcpinfoRule = 0;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out which type of rules to work on
    switch (typeRule)
    {
        case RULE_TYPE_MAIL:
            prnodeList = m_pMailHead;
            break;

        case RULE_TYPE_NEWS:
            prnodeList = m_pNewsHead;
            break;

        case RULE_TYPE_FILTER:
            prnodeList = m_pFilterHead;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Count the number of rules
    prnodeWalk = prnodeList;
    for (cpinfoRule = 0; NULL != prnodeWalk; prnodeWalk = prnodeWalk->pNext)
    {
        // Check to see if we should add this item
        if (RULE_TYPE_FILTER == typeRule)
        {
            if (0 != (dwFlags & GETF_POP3))
            {
                if (RULEID_VIEW_DOWNLOADED == prnodeWalk->ridRule)
                {
                    continue;
                }
            }
        }
        
        cpinfoRule++;
    }

    // Allocate space to hold the rules
    if (0 != cpinfoRule)
    {
        hr = HrAlloc((VOID **) &pinfoRuleAlloc, cpinfoRule * sizeof(*pinfoRuleAlloc));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize it to known values
        ZeroMemory(pinfoRuleAlloc, cpinfoRule * sizeof(*pinfoRuleAlloc));

        // Fill up the info
        for (ulIndex = 0, prnodeWalk = prnodeList; NULL != prnodeWalk; prnodeWalk = prnodeWalk->pNext)
        {
            // Check to see if we should add this item
            if (RULE_TYPE_FILTER == typeRule)
            {
                if (0 != (dwFlags & GETF_POP3))
                {
                    if (RULEID_VIEW_DOWNLOADED == prnodeWalk->ridRule)
                    {
                        continue;
                    }
                }
            }
            
            pinfoRuleAlloc[ulIndex].ridRule = prnodeWalk->ridRule;
            
            pinfoRuleAlloc[ulIndex].pIRule = prnodeWalk->pIRule;
            pinfoRuleAlloc[ulIndex].pIRule->AddRef();
            ulIndex++;
        }
    }

    // Set the outgoing values
    *ppinfoRule = pinfoRuleAlloc;
    pinfoRuleAlloc = NULL;
    if (NULL != pcpinfoRule)
    {
        *pcpinfoRule = cpinfoRule;
    }

    // Set the proper return type
    hr = S_OK;
    
exit:
    SafeMemFree(pinfoRuleAlloc);
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return S_OK;
}

STDMETHODIMP CRulesManager::SetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    IOERule *   pIRuleSender = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if ((NULL == pinfoRule) && (0 != cpinfoRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Do we have to free all the current rules
    if (0 != (dwFlags & SETF_SENDER))
    {
        if (RULE_TYPE_MAIL == typeRule)
        {
            SafeRelease(m_pIRuleSenderMail);
            m_pIRuleSenderMail = pinfoRule->pIRule;
            if (NULL != m_pIRuleSenderMail)
            {
                m_pIRuleSenderMail->AddRef();
            }
        }
        else if (RULE_TYPE_NEWS == typeRule)
        {
            SafeRelease(m_pIRuleSenderNews);
            m_pIRuleSenderNews = pinfoRule->pIRule;
            if (NULL != m_pIRuleSenderNews)
            {
                m_pIRuleSenderNews->AddRef();
            }
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }
    else if (0 != (dwFlags & SETF_JUNK))
    {
        if (RULE_TYPE_MAIL != typeRule)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        SafeRelease(m_pIRuleJunk);
        m_pIRuleJunk = pinfoRule->pIRule;
        if (NULL != m_pIRuleJunk)
        {
            m_pIRuleJunk->AddRef();
        }
    }
    else
    {
        if (0 != (dwFlags & SETF_CLEAR))
        {
            _HrFreeRules(typeRule);
        }

        // for each new rule
        for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
        {        
            if (0 != (dwFlags & SETF_REPLACE))
            {
                // Add the rule to the list
                hr = _HrReplaceRule(pinfoRule[ulIndex].ridRule, pinfoRule[ulIndex].pIRule, typeRule);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
            else
            {
                // Add the rule to the list
                hr = _HrAddRule(pinfoRule[ulIndex].ridRule, pinfoRule[ulIndex].pIRule, typeRule);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
        }
    }
    
    // Save the rules
    hr = _HrSaveRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((0 == (dwFlags & SETF_SENDER)) && (0 == (dwFlags & SETF_JUNK)))
    {
        // Fix up the rule ids
        hr = _HrFixupRuleInfo(typeRule, pinfoRule, cpinfoRule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::EnumRules(DWORD dwFlags, RULE_TYPE type, IOEEnumRules ** ppIEnumRules)
{
    HRESULT         hr = S_OK;
    CEnumRules *    pEnumRules = NULL;
    RULENODE        rnode;
    RULENODE *      prnode = NULL;
    IOERule *       pIRuleSender = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (NULL == ppIEnumRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIEnumRules = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rules enumerator object
    pEnumRules = new CEnumRules;
    if (NULL == pEnumRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rules enumerator
    if (0 != (dwFlags & ENUMF_SENDER))
    {
        if (RULE_TYPE_MAIL == type)
        {
            pIRuleSender = m_pIRuleSenderMail;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            pIRuleSender = m_pIRuleSenderNews;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        if (NULL != pIRuleSender)
        {
            ZeroMemory(&rnode, sizeof(rnode));

            rnode.pIRule = pIRuleSender;
            prnode = &rnode;
        }
        else
        {
            prnode = NULL;
        }
    }
    else
    {
        if (RULE_TYPE_MAIL == type)
        {
            prnode = m_pMailHead;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            prnode = m_pNewsHead;
        }
        else if (RULE_TYPE_FILTER == type)
        {
            prnode = m_pFilterHead;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    hr = pEnumRules->_HrInitialize(0, type, prnode);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules enumerator interface
    hr = pEnumRules->QueryInterface(IID_IOEEnumRules, (void **) ppIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pEnumRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pEnumRules)
    {
        delete pEnumRules;
    }
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::ExecRules(DWORD dwFlags, RULE_TYPE type, IOEExecRules ** ppIExecRules)
{
    HRESULT         hr = S_OK;
    CExecRules *    pExecRules = NULL;
    RULENODE        rnode;
    RULENODE *      prnodeList = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (NULL == ppIExecRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIExecRules = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rules enumerator object
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (RULE_TYPE_MAIL == type)
    {
        prnodeList = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        prnodeList = m_pNewsHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the rules enumerator
    hr = pExecRules->_HrInitialize(ERF_ONLY_ENABLED | ERF_ONLY_VALID, prnodeList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the rules enumerator interface
    hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) ppIExecRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pExecRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::ExecuteRules(RULE_TYPE typeRule, DWORD dwFlags, HWND hwndUI, IOEExecRules * pIExecRules,
                    MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder, IMimeMessage * pIMMsg)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  prnodeHead = NULL;
    PROPVARIANT propvar = {0};
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ACT_ITEM *  pActionsList = NULL;
    ULONG       cActionsList = 0;
    ACT_ITEM *  pActionsNew = NULL;
    ULONG       cActionsNew = 0;
    BOOL        fStopProcessing = FALSE;
    BOOL        fMatch = FALSE;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pMsgInfo))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out which list to use
    switch (typeRule)
    {
        case RULE_TYPE_MAIL:
            prnodeHead = m_pMailHead;
            break;

        case RULE_TYPE_NEWS:
            prnodeHead = m_pNewsHead;
            break;

        default:
            Assert(FALSE);
            hr = E_INVALIDARG;
            goto exit;
    }

    // For each rule
    for (; NULL != prnodeHead; prnodeHead = prnodeHead->pNext)
    {
        // Skip if we don't have a rule
        if (NULL == prnodeHead)
        {
            continue;
        }
        
        // Skip if it isn't enabled
        hr = prnodeHead->pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
        Assert(VT_BOOL == propvar.vt);
        if (FAILED(hr) || (FALSE != propvar.boolVal))
        {
            continue;
        }
        
        // Execute rule
        hr = prnodeHead->pIRule->Evaluate(pMsgInfo->pszAcctId, pMsgInfo, pFolder,
                                NULL, pIMMsg, pMsgInfo->cbMessage, &pActions, &cActions);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Did we have a match
        if (S_OK == hr)
        {
            // We've matched at least once
            fMatch = TRUE;

            // If these are server actions
            if ((1 == cActions) && ((ACT_TYPE_DELETESERVER == pActions[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD == pActions[ulIndex].type)))
            {
                // If this is our only action
                if (0 == cActionsList)
                {
                    // Save the action
                    pActionsList = pActions;
                    pActions = NULL;
                    cActionsList = cActions;

                    // We are done
                    fStopProcessing = TRUE;
                }
                else
                {
                    // We already have to do something with it
                    // so skip over this action
                    RuleUtil_HrFreeActionsItem(pActions, cActions);
                    SafeMemFree(pActions);
                    continue;
                }
            }
            else
            {
                // Should we stop after merging these?
                for (ulIndex = 0; ulIndex < cActions; ulIndex++)
                {
                    if (ACT_TYPE_STOP == pActions[ulIndex].type)
                    {
                        fStopProcessing = TRUE;
                        break;
                    }
                }
                
                // Merge these items with the previous ones
                hr = RuleUtil_HrMergeActions(pActionsList, cActionsList, pActions, cActions, &pActionsNew, &cActionsNew);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Free up the previous ones
                RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
                SafeMemFree(pActionsList);
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);

                // Save off the new ones
                pActionsList = pActionsNew;
                pActionsNew = NULL;
                cActionsList = cActionsNew;
            }

            // Should we continue...
            if (FALSE != fStopProcessing)
            {
                break;
            }
        }
    }

    // Apply the actions if need be
    if ((FALSE != fMatch) && (NULL != pActionsList) && (0 != cActionsList))
    {
        if (FAILED(RuleUtil_HrApplyActions(hwndUI, pIExecRules, pMsgInfo, pFolder, pIMMsg,
                        (RULE_TYPE_MAIL != typeRule) ? DELETE_MESSAGE_NOTRASHCAN : 0, pActionsList, cActionsList, NULL, NULL)))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Set the return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    // Thread Safety
    RuleUtil_HrFreeActionsItem(pActionsNew, cActionsNew);
    SafeMemFree(pActionsNew);
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
    SafeMemFree(pActionsList);
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT CRulesManager::_HrLoadRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszSubKey = NULL;
    LPSTR       pszOrderAlloc = NULL;
    LPSTR       pszOrder = NULL;
    LPSTR       pszWalk = NULL;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LONG        lErr = 0;
    ULONG       cbData = 0;
    IOERule *   pIRule = NULL;
    DWORD       dwData = 0;
    CHAR        rgchRulePath[MAX_PATH];
    ULONG       cchRulePath = 0;
    PROPVARIANT propvar = {0};
    RULEID      ridRule = RULEID_INVALID;
    CHAR        rgchTagBuff[CCH_INDEX_MAX + 2];

    // Check to see if we're already initialized
    if (RULE_TYPE_MAIL == type)
    {
        if (0 != (m_dwState & STATE_LOADED_MAIL))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Make sure we loaded the sender rules
        _HrLoadSenders();
    
        // Make sure we loaded the junk rule
        if (0 != (g_dwAthenaMode & MODE_JUNKMAIL))
        {
            _HrLoadJunk();
        }
        
        // Set the key path
        pszSubKey = c_szRulesMail;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        if (0 != (m_dwState & STATE_LOADED_NEWS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Make sure we loaded the sender rules
        _HrLoadSenders();
        
        // Set the key path
        pszSubKey = c_szRulesNews;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        if (0 != (m_dwState & STATE_LOADED_FILTERS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszSubKey = c_szRulesFilter;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if the Rule node already exists
    lErr = AthUserCreateKey(pszSubKey, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the current version
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, NULL, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        // Push out the correct rules manager version
        dwData = RULESMGR_VERSION;
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
        if (ERROR_SUCCESS != lErr)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            goto exit;
        }
    }

    Assert(RULESMGR_VERSION == dwData);
    
    // Create the default rules if needed
    hr = RuleUtil_HrUpdateDefaultRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }
        
    // Figure out the size of the order
    lErr = AthUserGetValue(pszSubKey, c_szRulesOrder, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (ERROR_FILE_NOT_FOUND != lErr)
    {
        // Allocate the space to hold the order
        hr = HrAlloc((void **) &pszOrderAlloc, cbData);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the order from the registry
        lErr = AthUserGetValue(pszSubKey, c_szRulesOrder, NULL, (LPBYTE) pszOrderAlloc, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Build up the rule registry path
        StrCpyN(rgchRulePath, pszSubKey, ARRAYSIZE(rgchRulePath));
        StrCatBuff(rgchRulePath, g_szBackSlash, ARRAYSIZE(rgchRulePath));
        cchRulePath = lstrlen(rgchRulePath);

        // Initialize the rule tag buffer
        rgchTagBuff[0] = '0';
        rgchTagBuff[1] = 'X';
        
        // Parse the order string to create the rules
        pszOrder = pszOrderAlloc;
        while ('\0' != *pszOrder)
        {
            SafeRelease(pIRule);
            
            // Create a new rule
            hr = HrCreateRule(&pIRule);
            if (FAILED(hr))
            {
                goto exit;
            }

            // Find the name of the new rule
            pszWalk = StrStr(pszOrder, g_szSpace);
            if (NULL != pszWalk)
            {
                *pszWalk = '\0';
                pszWalk++;
            }

            // Build the path to the rule
            StrCpyN(rgchRulePath + cchRulePath, pszOrder, ARRAYSIZE(rgchRulePath) - cchRulePath);
            
            // Load the rule
            hr = pIRule->LoadReg(rgchRulePath);
            if (SUCCEEDED(hr))
            {
                // Build the correct hex string
                StrCpyN(rgchTagBuff + 2, pszOrder, ARRAYSIZE(rgchTagBuff) - 2);
                
                // Get the new rule handle
                ridRule = ( ( RULEID  ) 0);
                SideAssert(FALSE != StrToIntEx(rgchTagBuff, STIF_SUPPORT_HEX, (INT *) &ridRule));
                
                // Add the new rule to the manager
                hr = _HrAddRule(ridRule, pIRule, type);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
            
            // Move to the next item in the order
            if (NULL == pszWalk)
            {
                pszOrder += lstrlen(pszOrder);
            }
            else
            {
                pszOrder = pszWalk;
            }
        }
    }
       
    // We've loaded the rules successfully
    if (RULE_TYPE_MAIL == type)
    {
        m_dwState |= STATE_LOADED_MAIL;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        m_dwState |= STATE_LOADED_NEWS;
    }
    else
    {
        m_dwState |= STATE_LOADED_FILTERS;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszOrderAlloc);
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrLoadSenders(VOID)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    ULONG       cbData = 0;
    IOERule *   pIRule = NULL;
    CHAR        rgchSenderPath[MAX_PATH];

    // Do we have anything to do?
    if (0 != (m_dwState & STATE_LOADED_SENDERS))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Let's get access to the sender root key
    lErr = AthUserCreateKey(c_szSenders, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Are the senders the correct version?
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szSendersVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = RULESMGR_VERSION;
        cbData = sizeof(dwData);
        lErr = RegSetValueEx(hkeyRoot, c_szSendersVersion, 0, REG_DWORD, (BYTE *) &dwData, cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    Assert(dwData == RULESMGR_VERSION);

    // Is there anything to do?
    if (REG_CREATED_NEW_KEY != dwDisp)
    {
        // Create the path to the sender
        StrCpyN(rgchSenderPath, c_szSenders, ARRAYSIZE(rgchSenderPath));
        StrCatBuff(rgchSenderPath, g_szBackSlash, ARRAYSIZE(rgchSenderPath));
        StrCatBuff(rgchSenderPath, c_szMailDir, ARRAYSIZE(rgchSenderPath));
        
        // Create the mail sender rule
        hr = RuleUtil_HrLoadSender(rgchSenderPath, 0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Save the loaded rule
        if (S_OK == hr)
        {
            m_pIRuleSenderMail = pIRule;
            pIRule = NULL;
        }
        
        // Create the path to the sender
        StrCpyN(rgchSenderPath, c_szSenders, ARRAYSIZE(rgchSenderPath));
        StrCatBuff(rgchSenderPath, g_szBackSlash, ARRAYSIZE(rgchSenderPath));
        StrCatBuff(rgchSenderPath, c_szNewsDir, ARRAYSIZE(rgchSenderPath));
        
        // Create the news sender rule
        hr = RuleUtil_HrLoadSender(rgchSenderPath, 0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Save the loaded rule
        if (S_OK == hr)
        {
            m_pIRuleSenderNews = pIRule;
            pIRule = NULL;
        }
    }
    
    // Note that we've loaded the senders
    m_dwState |= STATE_LOADED_SENDERS;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrLoadJunk(VOID)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    ULONG       cbData = 0;
    LONG        lErr = 0;
    IOERule *   pIRule = NULL;

    // Do we have anything to do?
    if (0 != (m_dwState & STATE_LOADED_JUNK))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Let's get access to the Junk mail root key
    lErr = AthUserCreateKey(c_szRulesJunkMail, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Is the junk mail the correct version?
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = RULESMGR_VERSION;
        cbData = sizeof(dwData);
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (BYTE *) &dwData, cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    Assert(dwData == RULESMGR_VERSION);

    // Create the rule
    hr = HrCreateJunkRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Load the junk rule
    hr = pIRule->LoadReg(c_szRulesJunkMail);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    m_pIRuleJunk = pIRule;
    pIRule = NULL;
    
    // Note that we've loaded the junk rule
    m_dwState |= STATE_LOADED_JUNK;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszRegPath = NULL;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    RULENODE *  pRuleNode = NULL;
    RULENODE *  pNodeWalk = NULL;
    ULONG       cpIRule = 0;
    LPSTR       pszOrder = NULL;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchOrder[CCH_INDEX_MAX];
    ULONG       cchOrder = 0;
    CHAR        rgchRulePath[MAX_PATH];
    ULONG       cchRulePath = 0;
    BOOL        fNewRule = FALSE;
    ULONG       ulRuleID = 0;
    HKEY        hkeyDummy = NULL;
    LONG        cSubKeys = 0;

    // Make sure we loaded the sender rules
    _HrSaveSenders();
    
    // Make sure we loaded the junk rules
    if (0 != (g_dwAthenaMode & MODE_JUNKMAIL))
    {
        _HrSaveJunk();
    }
    
    // Check to see if we have anything to save
    if (RULE_TYPE_MAIL == type)
    {
        if (0 == (m_dwState & STATE_LOADED_MAIL))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Set the key path
        pszRegPath = c_szRulesMail;

        pRuleNode = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        if (0 == (m_dwState & STATE_LOADED_NEWS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszRegPath = c_szRulesNews;

        pRuleNode = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        if (0 == (m_dwState & STATE_LOADED_FILTERS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszRegPath = c_szRulesFilter;

        pRuleNode = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the rules version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the number of rules
    cpIRule = 0;
    for (pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
    {
        cpIRule++;
    }

    // Allocate space to hold the order
    DWORD cchSize = ((cpIRule * CCH_INDEX_MAX) + 1);
    hr = HrAlloc((void **) &pszOrder, cchSize);
    if (FAILED(hr))
    {
        goto exit;
    }

    pszOrder[0] = '\0';

    // Delete all the old rules
    lErr = SHQueryInfoKey(hkeyRoot, (LPDWORD) (&cSubKeys), NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Delete all the old rules
    for (cSubKeys--; cSubKeys >= 0; cSubKeys--)
    {
        cchOrder = sizeof(rgchOrder);
        lErr = SHEnumKeyEx(hkeyRoot, cSubKeys, rgchOrder, &cchOrder);
        
        if (ERROR_NO_MORE_ITEMS == lErr)
        {
            break;
        }

        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        SHDeleteKey(hkeyRoot, rgchOrder);
    }

    // Delete the old order string
    RegDeleteValue(hkeyRoot, c_szRulesOrder);
    
    // Build up the rule registry path
    StrCpyN(rgchRulePath, pszRegPath, ARRAYSIZE(rgchRulePath));
    StrCatBuff(rgchRulePath, g_szBackSlash, ARRAYSIZE(rgchRulePath));
    cchRulePath = lstrlen(rgchRulePath);
    
    // Write out the rules with good tags
    for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
    {        
        if (RULEID_INVALID == pNodeWalk->ridRule)
        {
            fNewRule = TRUE;
            continue;
        }
        
        // Get a new index from the order
        wnsprintf(rgchOrder, ARRAYSIZE(rgchOrder), "%03X", pNodeWalk->ridRule);
        
        // Build the path to the rule
        StrCpyN(rgchRulePath + cchRulePath, rgchOrder, ARRAYSIZE(rgchRulePath) - cchRulePath);
            
        // Save the rule
        hr = pNodeWalk->pIRule->SaveReg(rgchRulePath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Fill in the new tags
    if (FALSE != fNewRule)
    {
        ulRuleID = 0;
        
        // Write out the updated rule
        for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
        {        
            if (RULEID_INVALID != pNodeWalk->ridRule)
            {
                continue;
            }

            // Find the first open entry
            for (; ulRuleID < PtrToUlong(RULEID_JUNK); ulRuleID++)
            {
                // Get a new index from the order
                wnsprintf(rgchOrder, ARRAYSIZE(rgchOrder), "%03X", ulRuleID);
                
                lErr = RegOpenKeyEx(hkeyRoot, rgchOrder, 0, KEY_READ, &hkeyDummy);
                if (ERROR_SUCCESS == lErr)
                {
                    RegCloseKey(hkeyDummy);
                }
                else 
                {
                    break;
                }
            }

            if (ERROR_FILE_NOT_FOUND != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            // Set the rule tag
            pNodeWalk->ridRule = (RULEID) IntToPtr(ulRuleID);

            // Build the path to the rule
            StrCpyN(rgchRulePath + cchRulePath, rgchOrder, ARRAYSIZE(rgchRulePath) - cchRulePath);
            
            // Save the rule
            hr = pNodeWalk->pIRule->SaveReg(rgchRulePath, TRUE);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
    }
    
    //  Write out the new order string
    for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
    {        
        // Get a new index from the order
        wnsprintf(rgchOrder, ARRAYSIZE(rgchOrder), "%03X", pNodeWalk->ridRule);
        
        // Add rule to the order
        if ('\0' != pszOrder[0])
        {
            StrCatBuff(pszOrder, g_szSpace, cchSize);
        }
        StrCatBuff(pszOrder, rgchOrder, cchSize);
    }

    // Save the order string
    if (ERROR_SUCCESS != AthUserSetValue(pszRegPath, c_szRulesOrder, REG_SZ, (CONST BYTE *) pszOrder, lstrlen(pszOrder) + 1))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveSenders(VOID)
{
    HRESULT     hr = S_OK;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchSenderPath[MAX_PATH];

    // Check to see if we have anything to save
    if (0 == (m_dwState & STATE_LOADED_SENDERS))
    {
        hr = S_FALSE;
        goto exit;
    }

    lErr = AthUserCreateKey(c_szSenders, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the senders version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szSendersVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Delete the old sender list
    SHDeleteKey(hkeyRoot, c_szMailDir);
    
    // Build up the sender registry path
    StrCpyN(rgchSenderPath, c_szSenders, ARRAYSIZE(rgchSenderPath));
    StrCatBuff(rgchSenderPath, g_szBackSlash, ARRAYSIZE(rgchSenderPath));
    StrCatBuff(rgchSenderPath, c_szMailDir, ARRAYSIZE(rgchSenderPath));
    
    // Save the rule
    if (NULL != m_pIRuleSenderMail)
    {
        hr = m_pIRuleSenderMail->SaveReg(rgchSenderPath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Delete the old sender list
    SHDeleteKey(hkeyRoot, c_szNewsDir);
    
    // Build up the sender registry path
    StrCpyN(rgchSenderPath, c_szSenders, ARRAYSIZE(rgchSenderPath));
    StrCatBuff(rgchSenderPath, g_szBackSlash, ARRAYSIZE(rgchSenderPath));
    StrCatBuff(rgchSenderPath, c_szNewsDir, ARRAYSIZE(rgchSenderPath));
    
    // Save the rule
    if (NULL != m_pIRuleSenderNews)
    {
        hr = m_pIRuleSenderNews->SaveReg(rgchSenderPath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveJunk(VOID)
{
    HRESULT     hr = S_OK;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchSenderPath[MAX_PATH];

    // Check to see if we have anything to save
    if (0 == (m_dwState & STATE_LOADED_JUNK))
    {
        hr = S_FALSE;
        goto exit;
    }

    lErr = AthUserCreateKey(c_szRulesJunkMail, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the senders version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save the rule
    if (NULL != m_pIRuleJunk)
    {
        hr = m_pIRuleJunk->SaveReg(c_szRulesJunkMail, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
        
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrFreeRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodeNext = NULL;

    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
        pNodeNext = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
        pNodeNext = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        pNodeWalk = m_pFilterHead;
        pNodeNext = m_pFilterHead;
    }
    else
    {
        hr = E_FAIL;
        goto exit;
    }

    // Walk the list and free each item
    while (NULL != pNodeWalk)
    {
        // Save off the next item
        pNodeNext = pNodeWalk->pNext;

        // Release the rule
        AssertSz(NULL != pNodeWalk->pIRule, "Where the heck is the rule???");
        pNodeWalk->pIRule->Release();
        
        // Free up the node
        delete pNodeWalk;

        // Move to the next item
        pNodeWalk = pNodeNext;
    }

    // Clear out the list head
    if (RULE_TYPE_MAIL == type)
    {
        m_pMailHead = NULL;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        m_pNewsHead = NULL;
    }
    else
    {
        m_pFilterHead = NULL;
    }

exit:
    // Set the return param
    return hr;
}

HRESULT CRulesManager::_HrAddRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pRuleNode = NULL;
    RULENODE *  pNodeWalk = NULL;
    
    // Check incoming params
    if (NULL == pIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a new rule node
    pRuleNode = new RULENODE;
    if (NULL == pRuleNode)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the node
    pRuleNode->pNext = NULL;
    pRuleNode->ridRule = ridRule;
    pRuleNode->pIRule = pIRule;
    pRuleNode->pIRule->AddRef();

    // Add the node to the proper list
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    if (NULL == pNodeWalk)
    {
        if (RULE_TYPE_MAIL == type)
        {
            m_pMailHead = pRuleNode;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            m_pNewsHead = pRuleNode;
        }
        else
        {
            m_pFilterHead = pRuleNode;
        }
        pRuleNode = NULL;
    }
    else
    {
        while (NULL != pNodeWalk->pNext)
        {
            pNodeWalk = pNodeWalk->pNext;
        }

        pNodeWalk->pNext = pRuleNode;
        pRuleNode = NULL;
    }

    // Set return values
    hr = S_OK;
    
exit:
    if (NULL != pRuleNode)
    {
        pRuleNode->pIRule->Release();
        delete pRuleNode;
    }
    return hr;
}

HRESULT CRulesManager::_HrReplaceRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodePrev = NULL;

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    // Walk the list and free each item
    for (; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
    {
        if (pNodeWalk->ridRule == ridRule)
        {
            // We found it
            break;
        }
    }

    // Couldn't find the rule in the list
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Replace the rule
    SafeRelease(pNodeWalk->pIRule);
    pNodeWalk->pIRule = pIRule;
    pNodeWalk->pIRule->AddRef();

    // Set the return param
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT CRulesManager::_HrRemoveRule(IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodePrev = NULL;

    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    // Walk the list and free each item
    pNodePrev = NULL;
    while (NULL != pNodeWalk)
    {
        if (pNodeWalk->pIRule == pIRule)
        {
            // We found it
            break;
        }
        
        // Save off the next item
        pNodePrev = pNodeWalk;

        // Move to the next item
        pNodeWalk = pNodeWalk->pNext;
    }

    // Couldn't find the rule in the list
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL == pNodePrev)
    {
        // Clear out the list head
        if (RULE_TYPE_MAIL == type)
        {
            m_pMailHead = pNodeWalk->pNext;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            m_pNewsHead = pNodeWalk->pNext;
        }
        else
        {
            m_pFilterHead = pNodeWalk->pNext;
        }
    }
    else
    {
        pNodePrev->pNext = pNodeWalk->pNext;
    }
    
    // Free up the node
    pNodeWalk->pIRule->Release();
    pNodeWalk->pNext = NULL;
    delete pNodeWalk;

    // Set the return param
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT CRulesManager::_HrFixupRuleInfo(RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  pNodeHead = NULL;
    RULENODE *  pNodeWalk = NULL;

    // Check incoming args
    if ((NULL == pinfoRule) && (0 != cpinfoRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Walk the proper list
    if (RULE_TYPE_MAIL == typeRule)
    {
        pNodeHead = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == typeRule)
    {
        pNodeHead = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == typeRule)
    {
        pNodeHead = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Search the rule info list for an unknown ruleid
    for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
    {
        // If the rule id is invalid try to find it
        if (RULEID_INVALID == pinfoRule[ulIndex].ridRule)
        {
            
            for (pNodeWalk = pNodeHead; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
            {
                // Check to see if the rule is the same
                if (pNodeWalk->pIRule == pinfoRule[ulIndex].pIRule)
                {
                    pinfoRule[ulIndex].ridRule = pNodeWalk->ridRule;
                    break;
                }
            }

            if (NULL == pNodeWalk)
            {
                hr = E_FAIL;
                goto exit;
            }
        }
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

CEnumRules::CEnumRules()
{
    m_cRef = 0;
    m_pNodeHead = NULL;
    m_pNodeCurr = NULL;
    m_dwFlags = 0;
    m_typeRule = RULE_TYPE_MAIL;
}

CEnumRules::~CEnumRules()
{
    RULENODE *  pNodeNext = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    
    // Walk the list and free each item
    while (NULL != m_pNodeHead)
    {
        // Save off the next item
        pNodeNext = m_pNodeHead->pNext;

        // Release the rule
        AssertSz(NULL != m_pNodeHead->pIRule, "Where the heck is the rule???");
        m_pNodeHead->pIRule->Release();
        
        // Free up the node
        delete m_pNodeHead;

        // Move to the next item
        m_pNodeHead = pNodeNext;
    }

}

STDMETHODIMP_(ULONG) CEnumRules::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumRules::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CEnumRules::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEEnumRules))
    {
        *ppvObject = static_cast<IOEEnumRules *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CEnumRules::Next(ULONG cpIRule, IOERule ** rgpIRule, ULONG * pcpIRuleFetched)
{
    HRESULT     hr = S_OK;
    ULONG       cpIRuleRet = 0;

    // Check incoming params
    if (NULL == rgpIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *rgpIRule = NULL;
    if (NULL != pcpIRuleFetched)
    {
        *pcpIRuleFetched = 0;
    }

    // If we're at the end then just return
    if (NULL == m_pNodeCurr)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (cpIRuleRet = 0; cpIRuleRet < cpIRule; cpIRuleRet++)
    {
        rgpIRule[cpIRuleRet] = m_pNodeCurr->pIRule;
        (rgpIRule[cpIRuleRet])->AddRef();
        
        m_pNodeCurr = m_pNodeCurr->pNext;

        if (NULL == m_pNodeCurr)
        {
            cpIRuleRet++;
            break;
        }
    }

    // Set outgoing params
    if (NULL != pcpIRuleFetched)
    {
        *pcpIRuleFetched = cpIRuleRet;
    }

    // Set return value
    hr = (cpIRuleRet == cpIRule) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP CEnumRules::Skip(ULONG cpIRule)
{
    HRESULT     hr = S_OK;
    ULONG       cpIRuleWalk = 0;

    for (cpIRuleWalk = 0; cpIRuleWalk < cpIRule; cpIRuleWalk++)
    {
        if (NULL == m_pNodeCurr)
        {
            break;
        }

        m_pNodeCurr = m_pNodeCurr->pNext;
    }

    hr = (cpIRuleWalk == cpIRule) ? S_OK : S_FALSE;
    return hr;
}

STDMETHODIMP CEnumRules::Reset(void)
{
    HRESULT     hr = S_OK;

    m_pNodeCurr = m_pNodeHead;
    
    return hr;
}

STDMETHODIMP CEnumRules::Clone(IOEEnumRules ** ppIEnumRules)
{
    HRESULT         hr = S_OK;
    CEnumRules *    pEnumRules = NULL;

    // Check incoming params
    if (NULL == ppIEnumRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIEnumRules = NULL;

    pEnumRules = new CEnumRules;
    if (NULL == pEnumRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rules enumerator
    hr = pEnumRules->_HrInitialize(m_dwFlags, m_typeRule, m_pNodeHead);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the state of the new one to match the current one
    pEnumRules->m_pNodeCurr = m_pNodeHead;
    
    // Get the rules enumerator interface
    hr = pEnumRules->QueryInterface(IID_IOEEnumRules, (void **) ppIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pEnumRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pEnumRules)
    {
        delete pEnumRules;
    }
    return hr;
}

HRESULT CEnumRules::_HrInitialize(DWORD dwFlags, RULE_TYPE typeRule, RULENODE * pNodeHead)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeNew = NULL;
    RULENODE *  pNodeWalk = NULL;

    if (NULL == pNodeHead)
    {
        hr = S_FALSE;
        goto exit;
    }

    m_dwFlags = dwFlags;
    m_typeRule = typeRule;
    
    for (pNodeWalk = m_pNodeHead; NULL != pNodeHead; pNodeHead = pNodeHead->pNext)
    {
        // Check to see if we should add this item
        if (RULE_TYPE_FILTER == m_typeRule)
        {
            if (0 != (dwFlags & ENUMF_POP3))
            {
                if (RULEID_VIEW_DOWNLOADED == pNodeHead->ridRule)
                {
                    continue;
                }
            }
        }
        
        pNodeNew = new RULENODE;
        if (NULL == pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize new node
        pNodeNew->pNext = NULL;
        pNodeNew->pIRule = pNodeHead->pIRule;
        pNodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == pNodeWalk)
        {
            m_pNodeHead = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        else
        {
            pNodeWalk->pNext = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        pNodeNew = NULL;
    }

    // Set the current to the front of the chain
    m_pNodeCurr = m_pNodeHead;
    
    // Set return value
    hr = S_OK;
    
exit:
    if (pNodeNew)
        delete pNodeNew;
    return hr;
}

// The Rule Executor object
CExecRules::~CExecRules()
{
    RULENODE *  pNodeNext = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    
    // Walk the list and free each item
    while (NULL != m_pNodeHead)
    {
        // Save off the next item
        pNodeNext = m_pNodeHead->pNext;

        // Release the rule
        AssertSz(NULL != m_pNodeHead->pIRule, "Where the heck is the rule???");
        m_pNodeHead->pIRule->Release();
        
        // Free up the node
        delete m_pNodeHead;

        // Move to the next item
        m_pNodeHead = pNodeNext;
    }

    // Free up the cached objects
    _HrReleaseFolderObjects();
    _HrReleaseFileObjects();
    _HrReleaseSoundFiles();

    // Free the folder list
    SafeMemFree(m_pRuleFolder);
    m_cRuleFolderAlloc = 0;

    // Free the file list
    SafeMemFree(m_pRuleFile);
    m_cRuleFileAlloc = 0;
    
    // Free the file list
    SafeMemFree(m_ppszSndFile);
    m_cpszSndFileAlloc = 0;
}

STDMETHODIMP_(ULONG) CExecRules::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CExecRules::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CExecRules::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEExecRules))
    {
        *ppvObject = static_cast<IOEExecRules *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::GetState(DWORD * pdwState)
{
    HRESULT hr = S_OK;
    
    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pdwState = m_dwState;

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::ExecuteRules(DWORD dwFlags, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                                    IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                                    IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                    ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  pNodeWalk = NULL;
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ACT_ITEM *  pActionsList = NULL;
    ULONG       cActionsList = 0;
    ACT_ITEM *  pActionsNew = NULL;
    ULONG       cActionsNew = 0;
    BOOL        fStopProcessing = FALSE;
    BOOL        fMatch = FALSE;
    DWORD       dwState = 0;

    // Check incoming params
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) ||
                    (0 == cbMsgSize) || (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppActions = NULL;
    *pcActions = 0;
    
    // Should we skip partial messages?
    if ((NULL != pIMPropSet) &&
                (S_OK == pIMPropSet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL)) &&
                (0 != (dwFlags & ERF_SKIPPARTIALS)))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Walk the list of rules executing each one
    pNodeWalk = m_pNodeHead;
    while (NULL != pNodeWalk)
    {
        Assert(NULL != pNodeWalk->pIRule);
        
        // If we are only checking server rules
        // Bail if we need more information...
        if (0 != (dwFlags & ERF_ONLYSERVER))
        {
            hr = pNodeWalk->pIRule->GetState(&dwState);
            if (FAILED(hr))
            {
                goto exit;
            }

            // Do we need more information...
            if (0 != (dwState & CRIT_STATE_ALL))
            {
                hr = S_FALSE;
                break;
            }
        }
        
        // Evaluate the rule
        hr = pNodeWalk->pIRule->Evaluate(pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize, &pActions, &cActions);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Did we have a match
        if (S_OK == hr)
        {
            // We've matched at least once
            fMatch = TRUE;
            ulIndex = 0;

            // If these are server actions
            if ((1 == cActions) && ((ACT_TYPE_DELETESERVER == pActions[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD == pActions[ulIndex].type)))
            {
                // If this is our only action
                if (0 == cActionsList)
                {
                    // Save the action
                    pActionsList = pActions;
                    pActions = NULL;
                    cActionsList = cActions;

                    // We are done
                    fStopProcessing = TRUE;
                }
                else
                {
                    // We already have to do something with it
                    // so skip over this action
                    RuleUtil_HrFreeActionsItem(pActions, cActions);
                    SafeMemFree(pActions);

                    // Move to the next rule
                    pNodeWalk = pNodeWalk->pNext;
                    continue;
                }
            }
            else
            {
                // Should we stop after merging these?
                for (ulIndex = 0; ulIndex < cActions; ulIndex++)
                {
                    if (ACT_TYPE_STOP == pActions[ulIndex].type)
                    {
                        fStopProcessing = TRUE;
                        break;
                    }
                }
                
                // Merge these items with the previous ones
                hr = RuleUtil_HrMergeActions(pActionsList, cActionsList, pActions, cActions, &pActionsNew, &cActionsNew);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Free up the previous ones
                RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
                SafeMemFree(pActionsList);
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);

                // Save off the new ones
                pActionsList = pActionsNew;
                pActionsNew = NULL;
                cActionsList = cActionsNew;
            }
            
            // Should we continue...
            if (FALSE != fStopProcessing)
            {
                break;
            }
        }

        // Move to the next rule
        pNodeWalk = pNodeWalk->pNext;
    }
    
    // Set outgoing param
    *ppActions = pActionsList;
    pActionsList = NULL;
    *pcActions = cActionsList;
    
    // Set the return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    RuleUtil_HrFreeActionsItem(pActionsNew, cActionsNew);
    SafeMemFree(pActionsNew);
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
    SafeMemFree(pActionsList);
    return hr;
}

STDMETHODIMP CExecRules::ReleaseObjects(VOID)
{
    // Free up the folders
    _HrReleaseFolderObjects();

    // Free up the files
    _HrReleaseFileObjects();

    // Free up the sound files
    _HrReleaseSoundFiles();
    
    return S_OK;
}

STDMETHODIMP CExecRules::GetRuleFolder(FOLDERID idFolder, DWORD_PTR * pdwFolder)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULE_FOLDER *        pRuleFolderWalk = NULL;
    IMessageFolder     *pFolder = NULL;
    
    // Check incoming param
    if ((FOLDERID_INVALID == idFolder) || (NULL == pdwFolder))
    {
        hr =E_INVALIDARG;
        goto exit;
    }
    
    // Initialize outgoing param
    *pdwFolder = NULL;

    // Let's search for the folder
    for (ulIndex = 0; ulIndex < m_cRuleFolder; ulIndex++)
    {
        pRuleFolderWalk = &(m_pRuleFolder[ulIndex]);
        if (idFolder == pRuleFolderWalk->idFolder)
        {
            Assert(NULL != pRuleFolderWalk->pFolder);
            break;
        }
    }

    // If we didn't find it then let's open it and lock it...
    if (ulIndex >= m_cRuleFolder)
    {
        // Do we need to alloc any more spaces
        if (m_cRuleFolder >= m_cRuleFolderAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_pRuleFolder, sizeof(*m_pRuleFolder) * (m_cRuleFolderAlloc + RULE_FOLDER_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule folders
            ZeroMemory(m_pRuleFolder + m_cRuleFolderAlloc, sizeof(*m_pRuleFolder) * RULE_FOLDER_ALLOC);
            for (ulIndex = m_cRuleFolderAlloc; ulIndex < (m_cRuleFolderAlloc + RULE_FOLDER_ALLOC); ulIndex++)
            {
                m_pRuleFolder[ulIndex].idFolder = FOLDERID_INVALID;
            }
            m_cRuleFolderAlloc += RULE_FOLDER_ALLOC;
        }

        // Open the folder
        hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_pRuleFolder[m_cRuleFolder].idFolder = idFolder;
        m_pRuleFolder[m_cRuleFolder].pFolder = pFolder;
        pFolder = NULL;
        pRuleFolderWalk = &(m_pRuleFolder[m_cRuleFolder]);
        m_cRuleFolder++;
    }
        
    *pdwFolder = (DWORD_PTR) (pRuleFolderWalk->pFolder);

    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pFolder)
        pFolder->Release();
    return hr;
}

STDMETHODIMP CExecRules::GetRuleFile(LPCSTR pszFile, IStream ** ppstmFile, DWORD * pdwType)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULE_FILE *         pRuleFileWalk = NULL;
    IStream *           pIStmFile = NULL;
    LPSTR               pszExt = NULL;
    DWORD               dwType = RFT_FILE;
    
    // Check incoming param
    if ((NULL == pszFile) || (NULL == ppstmFile) || (NULL == pdwType))
    {
        hr =E_INVALIDARG;
        goto exit;
    }
    
    // Initialize outgoing param
    *ppstmFile = NULL;
    *pdwType = NULL;

    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cRuleFile; ulIndex++)
    {
        pRuleFileWalk = &(m_pRuleFile[ulIndex]);
        if (0 == lstrcmpi(pRuleFileWalk->pszFile, pszFile))
        {
            Assert(NULL != pRuleFileWalk->pstmFile);
            break;
        }
    }

    // If we didn't find it then let's open it...
    if (ulIndex >= m_cRuleFile)
    {
        // Do we need to alloc any more space
        if (m_cRuleFile >= m_cRuleFileAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_pRuleFile, sizeof(*m_pRuleFile) * (m_cRuleFileAlloc + RULE_FILE_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule file
            ZeroMemory(m_pRuleFile + m_cRuleFileAlloc, sizeof(*m_pRuleFile) * RULE_FILE_ALLOC);
            m_cRuleFileAlloc += RULE_FILE_ALLOC;
        }

        // Open a stream on the file
        hr = CreateStreamOnHFile((LPTSTR) pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pIStmFile);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Lets split the file name and get the extension
        pszExt = PathFindExtension(pszFile);
        if ((0 == lstrcmpi(pszExt, c_szHtmExt)) || (0 == lstrcmpi(pszExt, c_szHtmlExt)))
        {
            dwType = RFT_HTML;
        }
        // Text File...
        else if (0 == lstrcmpi(pszExt, c_szTxtExt))
        {
            dwType = RFT_TEXT;
        }
        // Else .nws or .eml file...
        else if ((0 == lstrcmpi(pszExt, c_szEmlExt)) || (0 == lstrcmpi(pszExt, c_szNwsExt)))
        {
            dwType = RFT_MESSAGE;
        }
        // Otherwise, its an attachment
        else
        {
            dwType = RFT_FILE;
        }
        
        // Save off the info
        m_pRuleFile[m_cRuleFile].pszFile = PszDupA(pszFile);
        if (NULL == m_pRuleFile[m_cRuleFile].pszFile)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        m_pRuleFile[m_cRuleFile].pstmFile = pIStmFile;
        pIStmFile = NULL;
        m_pRuleFile[m_cRuleFile].dwType = dwType;
        
        pRuleFileWalk = &(m_pRuleFile[m_cRuleFile]);
        m_cRuleFile++;
    }
        
    *ppstmFile = pRuleFileWalk->pstmFile;
    (*ppstmFile)->AddRef();
    *pdwType = pRuleFileWalk->dwType;

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIStmFile);
    return hr;
}

STDMETHODIMP CExecRules::AddSoundFile(DWORD dwFlags, LPCSTR pszSndFile)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    
    // Check incoming param
    if (NULL == pszSndFile)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        if (0 == lstrcmpi(m_ppszSndFile[ulIndex], pszSndFile))
        {
            break;
        }
    }

    // If we didn't find it then let's open it...
    if (ulIndex >= m_cpszSndFile)
    {
        // Do we need to alloc any more space
        if (m_cpszSndFile >= m_cpszSndFileAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_ppszSndFile, sizeof(*m_ppszSndFile) * (m_cpszSndFileAlloc + SND_FILE_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule file
            ZeroMemory(m_ppszSndFile + m_cpszSndFileAlloc, sizeof(*m_ppszSndFile) * SND_FILE_ALLOC);
            m_cpszSndFileAlloc += SND_FILE_ALLOC;
        }

        // Save off the info
        m_ppszSndFile[m_cpszSndFile] = PszDupA(pszSndFile);
        if (NULL == m_ppszSndFile[m_cpszSndFile])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Should we play it?
        if (0 != (dwFlags & ASF_PLAYIFNEW))
        {
            sndPlaySound(m_ppszSndFile[m_cpszSndFile], SND_NODEFAULT | SND_SYNC);
        }
        
        m_cpszSndFile++;

    }
        
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::PlaySounds(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        sndPlaySound(m_ppszSndFile[ulIndex], SND_NODEFAULT | SND_SYNC);
    }

    return hr;
}

HRESULT CExecRules::_HrReleaseFolderObjects(VOID)
{
    RULE_FOLDER *    pRuleFolder = NULL;
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cRuleFolder; ulIndex++)
    {
        pRuleFolder = &(m_pRuleFolder[ulIndex]);
        
        Assert(FOLDERID_INVALID != pRuleFolder->idFolder);
        
        // If we have the folder opened then close it
        SafeRelease(pRuleFolder->pFolder);

        // Reset the folder list
        pRuleFolder->idFolder = FOLDERID_INVALID;
    }

    // Let's clear out the number of messages
    m_cRuleFolder = 0;

    return S_OK;
}

HRESULT CExecRules::_HrReleaseFileObjects(VOID)
{
    RULE_FILE *     pRuleFile = NULL;
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cRuleFile; ulIndex++)
    {
        pRuleFile = &(m_pRuleFile[ulIndex]);
        
        Assert(NULL != pRuleFile->pszFile);
        
        // If we have the file opened then close it
        SafeRelease(pRuleFile->pstmFile);

        // Clear the file
        SafeMemFree(pRuleFile->pszFile);
        pRuleFile->dwType = RFT_FILE;
    }

    // Let's clear out the number of file
    m_cRuleFile = 0;

    return S_OK;
}

HRESULT CExecRules::_HrReleaseSoundFiles(VOID)
{
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        
        // Clear the file
        SafeMemFree(m_ppszSndFile[ulIndex]);
    }

    // Let's clear out the number of file
    m_cpszSndFile = 0;

    return S_OK;
}

HRESULT CExecRules::_HrInitialize(DWORD dwFlags, RULENODE * pNodeHead)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeNew = NULL;
    RULENODE *  pNodeWalk = NULL;
    DWORD       dwState = 0;
    PROPVARIANT propvar;

    if (NULL == pNodeHead)
    {
        hr = S_FALSE;
        goto exit;
    }  
    
    for (pNodeWalk = m_pNodeHead; NULL != pNodeHead; pNodeHead = pNodeHead->pNext)
    {
        // Skip rules that are disabled
        if (0 != (dwFlags & ERF_ONLY_ENABLED))
        {
            hr = pNodeHead->pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
            Assert(VT_BOOL == propvar.vt);
            if (FAILED(hr) || (FALSE != propvar.boolVal))
            {
                continue;
            }
        }
        
        // Skip rules that are invalid
        if (0 != (dwFlags & ERF_ONLY_VALID))
        {
            hr = pNodeHead->pIRule->Validate(dwFlags);
            if (FAILED(hr) || (S_FALSE == hr))
            {
                continue;
            }
        }
        
        pNodeNew = new RULENODE;
        if (NULL == pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize new node
        pNodeNew->pNext = NULL;
        pNodeNew->pIRule = pNodeHead->pIRule;
        pNodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == pNodeWalk)
        {
            m_pNodeHead = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        else
        {
            pNodeWalk->pNext = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        pNodeNew = NULL;

        // Calculate state from message
        if (SUCCEEDED(pNodeWalk->pIRule->GetState(&dwState)))
        {
            // Let's set the proper Criteria state
            if ((m_dwState & CRIT_STATE_MASK) < (dwState & CRIT_STATE_MASK))
            {
                m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
            }
            
            // Let's set the proper Action state
            if (0 != (dwState & ACT_STATE_MASK))
            {
                m_dwState |= (dwState & ACT_STATE_MASK);
            }
        }        
    }
    
    // Set return value
    hr = S_OK;
    
exit:
    if (pNodeNew)
        delete pNodeNew;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Rule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

class COERule : public IOERule, IPersistStream
{
  private:  
    enum
    {
        RULE_STATE_UNINIT   = 0x00000000,
        RULE_STATE_INIT     = 0x00000001,
        RULE_STATE_LOADED   = 0x00000002,
        RULE_STATE_DIRTY    = 0x00000004,
        RULE_STATE_DISABLED = 0x00000008,
        RULE_STATE_INVALID  = 0x00000010
    };    

    enum {RULE_VERSION = 0x00050000};
        
  private:
    LONG            m_cRef;
    DWORD           m_dwState;
    LPSTR           m_pszName;
    IOECriteria *   m_pICrit;
    IOEActions *    m_pIAct;
    DWORD           m_dwVersion;
    
  public:
    // Constructor/destructor
    COERule();
    ~COERule();

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IRule members
    STDMETHODIMP Reset(void);
    STDMETHODIMP GetState(DWORD * pdwState);
    STDMETHODIMP Validate(DWORD dwFlags);
    
    STDMETHODIMP GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult);
    STDMETHODIMP SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarValue);

    STDMETHODIMP Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder, 
                            IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                            ACT_ITEM ** ppActions, ULONG * pcActions);

    STDMETHODIMP LoadReg(LPCSTR szRegPath);
    STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
    STDMETHODIMP Clone(IOERule ** ppIRule);
                            
    // IPersistStream members
    STDMETHODIMP GetClassID(CLSID * pclsid);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream * pStm);
    STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }    
};

HRESULT HrCreateRule(IOERule ** ppIRule);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rulesmgr.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesMgr.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RULESMGR_H_
#define _RULESMGR_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

typedef struct tagRULENODE
{
    RULEID                  ridRule;
    IOERule *               pIRule;
    struct tagRULENODE *    pNext;        
} RULENODE, * PRULENODE;
        
const int CCH_REGKEY_MAX    = 4;
const int CCH_RULENAME_MAX  = 256;

class CRulesManager : public IOERulesManager
{
    private:
        enum
        {
            STATE_LOADED_INIT       = 0x00000000,
            STATE_LOADED_MAIL       = 0x00000001,
            STATE_LOADED_NEWS       = 0x00000002,
            STATE_LOADED_SENDERS    = 0x00000004,
            STATE_LOADED_JUNK       = 0x00000008,
            STATE_LOADED_FILTERS    = 0x00000010
        };

        enum
        {
            RTF_INIT            = 0x00000000,
            RTF_DISABLED        = 0x00000001
        };
        
        enum
        {
            ARTF_PREPEND        = 0x00000001,
            ARTF_SENDER         = 0x00000002
        };
        
    private:
        LONG                m_cRef;
        BOOL                m_dwState;
        RULENODE *          m_pMailHead;
        RULENODE *          m_pNewsHead;
        RULENODE *          m_pFilterHead;
        IOERule *           m_pIRuleSenderMail;
        IOERule *           m_pIRuleSenderNews;
        IOERule *           m_pIRuleJunk;
        CRITICAL_SECTION    m_cs;
        
    public:
        // Constructor/destructor
        CRulesManager();
        ~CRulesManager();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOERulesManager members
        STDMETHODIMP Initialize(DWORD dwFlags);
        STDMETHODIMP GetRule(RULEID ridRule, RULE_TYPE type, DWORD dwFlags, IOERule ** ppIRule);
        STDMETHODIMP FindRule(LPCSTR pszRuleName, RULE_TYPE type, IOERule ** ppIRule);
        STDMETHODIMP GetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO ** ppinfoRule, ULONG * pcpinfoRule);
        STDMETHODIMP SetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule);
        STDMETHODIMP EnumRules(DWORD dwFlags, RULE_TYPE type, IOEEnumRules ** ppIEnumRules);
        
        STDMETHODIMP GetState(RULE_TYPE type, DWORD dwFlags, DWORD * pdwState) { return E_NOTIMPL; }

        STDMETHODIMP ExecRules(DWORD dwFlags, RULE_TYPE type, IOEExecRules ** ppIExecRules);

        STDMETHODIMP ExecuteRules(RULE_TYPE typeRule, DWORD dwFlags, HWND hwndUI,
                            IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimeMessage * pIMMsg);
                            
    private:
        HRESULT _HrLoadRules(RULE_TYPE type);
        HRESULT _HrLoadSenders(VOID);
        HRESULT _HrLoadJunk(VOID);
        HRESULT _HrSaveRules(RULE_TYPE type);
        HRESULT _HrSaveSenders(VOID);
        HRESULT _HrSaveJunk(VOID);
        HRESULT _HrFreeRules(RULE_TYPE type);
        HRESULT _HrAddRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrReplaceRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrRemoveRule(IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrFixupRuleInfo(RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule);
};

class CEnumRules : public IOEEnumRules
{
    private:
        LONG        m_cRef;
        RULENODE *  m_pNodeHead;
        RULENODE *  m_pNodeCurr;
        DWORD       m_dwFlags;
        RULE_TYPE   m_typeRule;
        
    public:
        // Constructor/destructor
        CEnumRules();
        ~CEnumRules();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEEnumRules members
        STDMETHODIMP Next(ULONG cpIRule, IOERule ** rgpIRule, ULONG * pcpIRuleFetched);
        STDMETHODIMP Skip(ULONG cpIRule);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IOEEnumRules ** ppIEnumRules);

        HRESULT _HrInitialize(DWORD dwFlags, RULE_TYPE typeRule, RULENODE * pNodeHead);
};

const DWORD ERF_ONLY_ENABLED    = 0x00000001;
const DWORD ERF_ONLY_VALID      = 0x00000002;

class CExecRules : public IOEExecRules
{
    private:
        enum
        {
            RULE_FOLDER_ALLOC = 16   
        };

        struct RULE_FOLDER
        {
            FOLDERID            idFolder;
            IMessageFolder *    pFolder;
        };
        
        enum
        {
            RULE_FILE_ALLOC = 16   
        };

        struct RULE_FILE
        {
            LPSTR       pszFile;
            IStream *   pstmFile;
            DWORD       dwType;
        };
        
        enum
        {
            SND_FILE_ALLOC = 16   
        };

    private:
        LONG            m_cRef;
        RULENODE *      m_pNodeHead;
        ULONG           m_cNode;
        DWORD           m_dwState;
        RULE_FOLDER *   m_pRuleFolder;
        ULONG           m_cRuleFolder;
        ULONG           m_cRuleFolderAlloc;
        RULE_FILE *     m_pRuleFile;
        ULONG           m_cRuleFile;
        ULONG           m_cRuleFileAlloc;
        LPSTR *         m_ppszSndFile;
        ULONG           m_cpszSndFile;
        ULONG           m_cpszSndFileAlloc;
        
    public:
        // Constructor/destructor
        CExecRules() : m_cRef(0), m_pNodeHead(NULL), m_cNode(0), m_dwState(RULE_STATE_NULL),
                        m_pRuleFolder(NULL), m_cRuleFolder(0), m_cRuleFolderAlloc(0),
                        m_pRuleFile(NULL), m_cRuleFile(0), m_cRuleFileAlloc(0),
                        m_ppszSndFile(NULL), m_cpszSndFile(0), m_cpszSndFileAlloc(0) {}
        ~CExecRules();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEExecRules members
        STDMETHODIMP GetState(DWORD * pdwState);

        STDMETHODIMP ExecuteRules(DWORD dwFlags, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                            IMimeMessage * pIMMsg, ULONG cbMsgSize,
                            ACT_ITEM ** ppActions, ULONG * pcActions);
        STDMETHODIMP ReleaseObjects(VOID);
                                            
        STDMETHODIMP GetRuleFolder(FOLDERID idFolder, DWORD_PTR * pdwFolder);
        STDMETHODIMP GetRuleFile(LPCSTR pszFile, IStream ** pstmFile, DWORD * pdwType);
        
        STDMETHODIMP AddSoundFile(DWORD dwFlags, LPCSTR pszSndFile);
        STDMETHODIMP PlaySounds(DWORD dwFlags);

        HRESULT _HrInitialize(DWORD dwFlags, RULENODE * pNodeHead);

    private:
        HRESULT _HrReleaseFolderObjects(VOID);
        HRESULT _HrReleaseFileObjects(VOID);
        HRESULT _HrReleaseSoundFiles(VOID);
};
#endif  // !_RULESMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\ruledesc.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleDesc.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

#define NM_RULE_CHANGED   (WMN_FIRST + 1)

typedef struct tagRULEDESCRIPT_LIST
{
    ULONG                           ulIndex;
    BOOL                            fError;
    ULONG                           ulStart;
    ULONG                           ulEnd;
    LPSTR                           pszText;
    DWORD                           dwFlags;
    PROPVARIANT                     propvar;
    ULONG                           ulStartLogic;
    ULONG                           ulEndLogic;
    struct tagRULEDESCRIPT_LIST *   pNext;
} RULEDESCRIPT_LIST, * PRULEDESCRIPT_LIST;

const int RDF_READONLY      = 0x00000001;
const int RDF_APPLYDLG      = 0x00000002;

// Class definitions
class CRuleDescriptUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002,
        STATE_READONLY      = 0x00000004,
        STATE_HASRULE       = 0x00000008,
        STATE_APPLYDLG      = 0x00000010,
        STATE_ENABLED       = 0x00000020
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    RULE_TYPE           m_typeRule;
    RULEDESCRIPT_LIST * m_pDescriptListCrit;
    ULONG               m_cDescriptListCrit;
    RULEDESCRIPT_LIST * m_pDescriptListAct;
    ULONG               m_cDescriptListAct;
    HFONT               m_hfont;
    WNDPROC             m_wpcOld;
    CRIT_LOGIC          m_logicCrit;
    BOOL                m_fErrorLogic;
    
  public:
    CRuleDescriptUI();
    ~CRuleDescriptUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
    HRESULT HrIsDirty(void) { return (0 == (m_dwState & STATE_DIRTY)) ? S_FALSE : S_OK; }
    HRESULT HrClearDirty(void)
    {
        HRESULT hr = (0 == (m_dwState & STATE_DIRTY)) ? S_FALSE : S_OK;
        m_dwState &= ~STATE_DIRTY;
        return hr;
    }
    HRESULT HrIsReadOnly(void) { return (0 == (m_dwState & STATE_READONLY)) ? S_FALSE : S_OK; }
    HRESULT HrSetReadOnly(BOOL fSet)
    {
        if (fSet)
        {
            m_dwState |= STATE_READONLY;
        }
        else
        {
            m_dwState &= ~STATE_READONLY;
        }
        return S_OK;
    }

    HRESULT HrIsEnabled(void) { return (0 == (m_dwState & STATE_ENABLED)) ? S_FALSE : S_OK; }
    HRESULT HrSetEnabled(BOOL fSet)
    {
        if (fSet)
        {
            m_dwState |= STATE_ENABLED;
        }
        else
        {
            m_dwState &= ~STATE_ENABLED;
        }
        return S_OK;
    }

    HRESULT HrSetRule(RULE_TYPE typeRule, IOERule * pIRule);
    HRESULT HrVerifyRule(void);
    
    HRESULT HrEnableCriteria(CRIT_TYPE type, BOOL fEnable);
    HRESULT HrEnableActions(ACT_TYPE type, BOOL fEnable);
            
    HRESULT HrGetCriteria(CRIT_ITEM ** ppCritList, ULONG * pcCritList);
    HRESULT HrGetActions(ACT_ITEM ** ppActList, ULONG * pcActList);
    
    // Message handling functions
    void ShowDescriptionString(VOID);

  private:
    // Utility functions
    void _ShowLinkedString(ULONG ulText, RULEDESCRIPT_LIST * pruilist,  BOOL fFirst, BOOL fCrit);
    
    BOOL _FChangeLogicValue(RULEDESCRIPT_LIST * pDescriptList);
    
    HRESULT _HrBuildCriteriaList(IOERule * pIRule, RULEDESCRIPT_LIST ** ppDescriptList,
            ULONG * pcDescriptList, CRIT_LOGIC * plogicCrit);
    BOOL _FChangeCriteriaValue(RULEDESCRIPT_LIST * pCritList);
    BOOL _FBuildCriteriaText(CRIT_TYPE type, DWORD dwFlags, PROPVARIANT * ppropvar, LPSTR * ppszText);
    BOOL _FVerifyCriteria(RULEDESCRIPT_LIST * pDescriptList);
    
    HRESULT _HrBuildActionList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList);
    BOOL _FChangeActionValue(RULEDESCRIPT_LIST * pActList);
    BOOL _FBuildActionText(ACT_TYPE type, PROPVARIANT * ppropvar, LPSTR * ppszText);
    BOOL _FVerifyAction(RULEDESCRIPT_LIST * pDescriptList);
    
    void _UpdateRanges(LONG lDiff, ULONG ulStart);
    void _InsertDescription(RULEDESCRIPT_LIST ** ppDescriptList, RULEDESCRIPT_LIST * pDescriptListNew);
    BOOL _FRemoveDescription(RULEDESCRIPT_LIST ** ppDescriptList, ULONG ulIndex,
            RULEDESCRIPT_LIST ** ppDescriptListRemove);
    void _FreeDescriptionList(RULEDESCRIPT_LIST * pDescriptList);

    BOOL _FOnDescriptClick(UINT uiMsg, RULEDESCRIPT_LIST * pDescriptList, BOOL fCrit, BOOL fLogic);
    BOOL _FInLink(int chPos, RULEDESCRIPT_LIST ** ppDescriptList, BOOL * pfCrit, BOOL * pfLogic);
    BOOL _FMoveToLink(UINT uiKeyCode);
    
    static LRESULT CALLBACK _DescriptWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    
    // The Change Subject dialog function
    static INT_PTR CALLBACK _FSelectTextDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAddrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAcctDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectColorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectSizeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectLinesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAgeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectPriorityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectSecureDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectThreadStateDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectShowDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectLogicDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectFlagDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectDownloadedDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectReadDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectWatchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rulesui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "rulesmgr.h"

// Rules Manager UI Page Base Class
class COERulesPageUI
{
    protected:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    protected:
        UINT    m_uiDlgRscId;
        UINT    m_uiTabLabelId;
        DWORD   m_dwFlags;
        DWORD   m_dwState;
        
    public:
        COERulesPageUI();
        COERulesPageUI(UINT uiDlgRscId, UINT uiTabLabelId, DWORD dwFlags, DWORD dwState) :
                    m_uiDlgRscId(uiDlgRscId), m_uiTabLabelId(uiTabLabelId), m_dwFlags(dwFlags), m_dwState(dwState) {}
        virtual ~COERulesPageUI() {};

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags) = 0;
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty) = 0;

        // Accessor functions
        UINT UiGetDlgRscId(VOID) {return m_uiDlgRscId;}
        UINT UiGetTabLabelId(VOID) {return m_uiTabLabelId;}
        virtual DLGPROC DlgProcGetPageDlgProc(VOID) = 0;
        BOOL FIsDirty(VOID) {return (0 != (m_dwState & STATE_DIRTY));}
        virtual BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode) = 0;
};

enum RULEMGR_FLAGS
{
    RMF_MAIL    = 0x00000000,
    RMF_NEWS    = 0x00000001,
    RMF_JUNK    = 0x00000002,
    RMF_SENDERS = 0x00000003
};

// Rules Manager UI Class
class COERulesMgrUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001
        };

        enum
        {
            RULE_DIALOG_PAD     = 0x00000004
        };
        
        enum
        {
            RULE_PAGE_MAIL      = 0x00000000,
            RULE_PAGE_NEWS      = 0x00000001,
            RULE_PAGE_JUNK      = 0x00000002,
            RULE_PAGE_SENDERS   = 0x00000003,
            RULE_PAGE_MAX       = 0x00000004,
            RULE_PAGE_MASK      = 0x000000FF
        };
        
    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndTab;

        COERulesPageUI *    m_rgRuleTab[RULE_PAGE_MAX];
        
    public:
        // Constructor/destructor
        COERulesMgrUI();
        ~COERulesMgrUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(VOID);
        
        // Dialog methods
        static INT_PTR CALLBACK FOERuleMgrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);
        BOOL FOnGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
    private:
        BOOL _FOnOK(VOID);
        BOOL _FOnCancel(VOID);
        BOOL _FInitTabCtrl(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\ruleutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rulesui.h"
#include "editrule.h"
#include "spamui.h"
#include "viewsui.h"
#include "rule.h"
#include <msoeobj.h>
#include <xpcomm.h>
#include <ipab.h>
#include <pop3task.h>
#include <msgfldr.h>
#include <mimeolep.h>
#include <storecb.h>
#include <menures.h>
#include <hotlinks.h>
#include <menuutil.h>
#include <mru.h>
#include <options.h>
#include <mailutil.h>
#include <secutil.h>
#include "shlwapip.h"
#include "reutil.h"
#include <demand.h>

// Typedefs
typedef enum tagDEF_CRIT_TYPE
{
    DEF_CRIT_ALLMSGS    = 0,
    DEF_CRIT_READ,
    DEF_CRIT_DWNLDMSGS,
    DEF_CRIT_IGNTHDS
} DEF_CRIT_TYPE;

typedef enum tagDEF_ACT_TYPE
{
    DEF_ACT_SHOWMSGS    = 0,
    DEF_ACT_HIDEMSGS
} DEF_ACT_TYPE;

typedef struct tagDEFAULT_RULE
{
    // The rule handle
    RULEID              ridRule;
    // The rule name
    UINT                idName;
    // Which type of criteria for the rule
    DEF_CRIT_TYPE       critType;
    // Which type of actions for the rule
    DEF_ACT_TYPE        actType;
    // The current version number for the rule
    DWORD               dwVersion;
} DEFAULT_RULE, * PDEFAULT_RULE;

// Constants
static const ULONG CDEF_CRIT_ITEM_MAX = 2;
static const ULONG CDEF_ACT_ITEM_MAX = 1;

static const DWORD DEFAULT_RULE_VERSION = 0x00000004;

static const DEFAULT_RULE   g_defruleFilters[] =
{
    {RULEID_VIEW_ALL,           idsViewAllMessages, DEF_CRIT_ALLMSGS,       DEF_ACT_SHOWMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_UNREAD,        idsViewUnread,      DEF_CRIT_READ,          DEF_ACT_HIDEMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_DOWNLOADED,    idsViewDownloaded,  DEF_CRIT_DWNLDMSGS,     DEF_ACT_SHOWMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_IGNORED,       idsViewNoIgnored,   DEF_CRIT_IGNTHDS,       DEF_ACT_HIDEMSGS,   DEFAULT_RULE_VERSION}
};

static const CHAR g_szOrderFilterDef[] =    "FFA FFB FFC FFF";

static const ULONG RULE_FILE_VERSION =      0x00050000;

static const char c_szLeftParen[] =         "(";
static const char c_szRightParen[] =        ")";
static const char c_szDoubleQuote[] =       "\"";
static const char c_szLogicalAnd[] =        " && ";
static const char c_szLogicalOr[] =         " || ";

static const char c_szFilterRead[] =            "(0 != (MSGCOL_FLAGS & ARF_READ))";
static const char c_szFilterNotRead[] =         "(0 == (MSGCOL_FLAGS & ARF_READ))";
static const char c_szFilterDeleted[] =         "(0 != (MSGCOL_FLAGS & ARF_ENDANGERED))";
static const char c_szFilterNotDeleted[] =      "(0 == (MSGCOL_FLAGS & ARF_ENDANGERED))";
static const char c_szFilterDownloaded[] =      "(0 != (MSGCOL_FLAGS & ARF_HASBODY))";
static const char c_szFilterNotDownloaded[] =   "(0 == (MSGCOL_FLAGS & ARF_HASBODY))";
static const char c_szFilterWatched[] =         "(0 != (MSGCOL_FLAGS & ARF_WATCH))";
static const char c_szFilterIgnored[] =         "(0 != (MSGCOL_FLAGS & ARF_IGNORE))";
static const char c_szFilterAttach[] =          "(0 != (MSGCOL_FLAGS & ARF_HASATTACH))";
static const char c_szFilterSigned[] =          "(0 != (MSGCOL_FLAGS & ARF_SIGNED))";
static const char c_szFilterEncrypt[] =         "(0 != (MSGCOL_FLAGS & ARF_ENCRYPTED))";
static const char c_szFilterFlagged[] =         "(0 != (MSGCOL_FLAGS & ARF_FLAGGED))";
static const char c_szFilterNotFlagged[] =      "(0 == (MSGCOL_FLAGS & ARF_FLAGGED))";
static const char c_szFilterPriorityHi[] =      "(MSGCOL_PRIORITY == IMSG_PRI_HIGH)";
static const char c_szFilterPriorityLo[] =      "(MSGCOL_PRIORITY == IMSG_PRI_LOW)";
static const char c_szFilterReplyPost[] =       "(0 != IsReplyPostVisible)";
static const char c_szFilterNotReplyPost[] =    "(0 == IsReplyPostVisible)";
static const char c_szFilterShowAll[] =         "(0 == 0)";
static const char c_szFilterHideAll[] =         "(0 != 0)";

static const char c_szFilterHide[] =            "0 == ";
static const char c_szFilterShow[] =            "0 != ";

static const char c_szEmailFromAddrPrefix[] =   "(MSGCOL_EMAILFROM containsi ";
static const char c_szEmailSubjectPrefix[] =    "(MSGCOL_SUBJECT containsi ";
static const char c_szEmailAcctPrefix[] =       "(MSGCOL_ACCOUNTID containsi ";
static const char c_szEmailFromPrefix[] =       "(MSGCOL_DISPLAYFROM containsi ";
static const char c_szEmailLinesPrefix[] =      "(MSGCOL_LINECOUNT > ";
static const char c_szFilterReplyChild[] =      "(0 != (MSGCOL_FLAGS & ARF_HASCHILDREN))";
static const char c_szFilterReplyRoot[] =       "(0 != MSGCOL_PARENT)";
static const char c_szEmailAgePrefix[] =        "(MessageAgeInDays > ";

void DoMessageRulesDialog(HWND hwnd, DWORD dwFlags)
{
    COERulesMgrUI *   pRulesMgrUI = NULL;

    if (NULL == hwnd)
    {
        goto exit;
    }

    // Create the rules UI object
    pRulesMgrUI = new COERulesMgrUI;
    if (NULL == pRulesMgrUI)
    {
        goto exit;
    }

    if (FAILED(pRulesMgrUI->HrInit(hwnd, dwFlags)))
    {
        goto exit;
    }

    pRulesMgrUI->HrShow();
    
exit:
    if (NULL != pRulesMgrUI)
    {
        delete pRulesMgrUI;
    }
    return;
}

HRESULT HrDoViewsManagerDialog(HWND hwnd, DWORD dwFlags, RULEID * pridRule, BOOL * pfApplyAll)
{
    HRESULT             hr = S_OK;
    COEViewsMgrUI *     pViewsMgrUI = NULL;

    if ((NULL == hwnd) || (NULL == pfApplyAll))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the rules UI object
    pViewsMgrUI = new COEViewsMgrUI;
    if (NULL == pViewsMgrUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pViewsMgrUI->HrInit(hwnd, dwFlags, pridRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pViewsMgrUI->HrShow(pfApplyAll);
    
exit:
    if (NULL != pViewsMgrUI)
    {
        delete pViewsMgrUI;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRuleFromMessage
//
//  This creates a rules editor of the proper type.
//
//  hwnd        - The owner dialog
//  dwFlags     - What type of editor to bring up
//  pmsginfo    - The message information
//  pMsgList    - The owner of the message
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRuleFromMessage(HWND hwnd, DWORD dwFlags, MESSAGEINFO * pmsginfo, IMimeMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CEditRuleUI *   pEditRuleUI = NULL;
    IOERule *       pIRule = NULL;
    UINT            uiStrId = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    RULE_TYPE       typeRule = RULE_TYPE_MAIL;
    IOERule *       pIRuleFound = NULL;
    PROPVARIANT     propvar = {0};
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    RULEINFO        infoRule = {0};
    BYTE *          pBlobData = NULL;
    ULONG           cbSize = 0;

    Assert(NULL != g_pMoleAlloc);
    Assert(NULL != g_pRulesMan);
    
    // Check incoming params
    if ((NULL == hwnd) || (NULL == pmsginfo))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create a new rule object
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

   // Figure out the string Id
    if (0 != (dwFlags & CRFMF_NEWS))
    {
        uiStrId = idsRuleNewsDefaultName;
        typeRule = RULE_TYPE_NEWS;
    }
    else
    {
        uiStrId = idsRuleMailDefaultName;
        typeRule = RULE_TYPE_MAIL;
    }
    
    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, uiStrId, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        hr = E_FAIL;
        goto exit;
    }

    ulIndex = 1;
    wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);
    
    // Make sure the name is unique
    while (S_OK == g_pRulesMan->FindRule(szName, typeRule, &pIRuleFound))
    {
        pIRuleFound->Release();
        pIRuleFound = NULL;
        ulIndex++;
        wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);
    }

    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    // Set the rule name
    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((NULL == pmsginfo->pszEmailFrom) || (FALSE != FIsEmpty(pmsginfo->pszEmailFrom)))
    {
        // Get the load interface from the preview pane object
        if (NULL != pMessage)
        {
            rSender.dwProps = IAP_EMAIL;
            pMessage->GetSender(&rSender);
            Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
            pszEmailFrom = rSender.pszEmail;
        }
    }
    else
    {
        pszEmailFrom = pmsginfo->pszEmailFrom;
    }

    if (NULL != pszEmailFrom)
    {
        // Create space to hold the email address
        if (FALSE == FIsEmpty(pszEmailFrom))
        {
            cbSize = lstrlen(pszEmailFrom) + 3;
            
            if (SUCCEEDED(HrAlloc((VOID **) &pBlobData, cbSize)))
            {
                StrCpyN((LPSTR) pBlobData, pszEmailFrom, cbSize);
                pBlobData[cbSize - 2] = '\0';
                pBlobData[cbSize - 1] = '\0';
            }
            else
            {
                cbSize = 0;
            }
        }
    }
    
    if (0 != cbSize)
    {
        CRIT_ITEM       citemFrom;
        
        // Set the default criteria on the rule
        ZeroMemory(&citemFrom, sizeof(citemFrom));
        citemFrom.type = CRIT_TYPE_FROM;
        citemFrom.logic = CRIT_LOGIC_NULL;
        citemFrom.dwFlags = CRIT_FLAG_DEFAULT;
        citemFrom.propvar.vt = VT_BLOB;
        citemFrom.propvar.blob.cbSize = cbSize;
        citemFrom.propvar.blob.pBlobData = pBlobData;

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(citemFrom);
        propvar.blob.pBlobData = (BYTE *) &citemFrom;

        hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Initialize the editor object
    hr = pEditRuleUI->HrInit(hwnd, ERF_NEWRULE, typeRule, pIRule, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Initialize the rule info
        infoRule.pIRule = pIRule;
        infoRule.ridRule = RULEID_INVALID;
        
        // Add the rule to the list of rules
        hr = g_pRulesMan->SetRules(SETF_APPEND, typeRule, &infoRule, 1);
        
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    SafeMemFree(pBlobData);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    if (S_OK == hr)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsRuleAdded), NULL, MB_OK | MB_ICONINFORMATION);
    }
    else if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsCreateRuleError), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

HRESULT HrBlockSendersFromFolder(HWND hwnd, DWORD dwFlags, FOLDERID idFolder, LPSTR * ppszSender, ULONG cpszSender)
{
    HRESULT             hr = S_OK;
    IMessageFolder *    pFolder = NULL;
    FOLDERINFO          infoFolder = {0};
    CProgress *         pProgress = NULL;
    IOERule *           pIRule = NULL;
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               ulIndex = 0;
    PROPVARIANT         propvar = {0};
    CExecRules *        pExecRules = NULL;
    RULENODE            rnode = {0};
    IOEExecRules *      pIExecRules = NULL;
    CHAR                rgchTmpl[CCHMAX_STRINGRES];
    LPSTR               pszText = NULL;

    // Check incoming params
    if ((NULL == hwnd) || (FOLDERID_INVALID == idFolder) || (NULL == ppszSender) || (0 == cpszSender))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Open up the folder
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = g_pStore->GetFolderInfo(idFolder, &infoFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Create the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena), MAKEINTRESOURCE(idsSendersApplyProgress), infoFolder.cMessages, 0, TRUE, FALSE);

    // Create the Block Sender rule
    hr = RuleUtil_HrCreateSendersRule(0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Allocate space to hold all the senders
    hr = HrAlloc((VOID **) &pCritItem, sizeof(*pCritItem) * cpszSender);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it
    ZeroMemory(pCritItem, sizeof(*pCritItem) * cpszSender);

    // Add in each of the criteria
    for (ulIndex = 0; ulIndex < cpszSender; ulIndex++, ppszSender++)
    {
        if ((NULL != *ppszSender) && ('\0' != (*ppszSender)[0]))
        {
            pCritItem[cCritItem].type = CRIT_TYPE_SENDER;
            pCritItem[cCritItem].logic = CRIT_LOGIC_OR;
            pCritItem[cCritItem].dwFlags = CRIT_FLAG_DEFAULT;
            pCritItem[cCritItem].propvar.vt = VT_LPSTR;
            pCritItem[cCritItem].propvar.pszVal = *ppszSender;
            cCritItem++;
        }
    }

    // Do we need to do anything?
    if (0 == cCritItem)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the senders into the rule
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(*pCritItem) * cCritItem;
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rule executor
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule executor
    rnode.pIRule = pIRule;
    hr = pExecRules->_HrInitialize(0, &rnode);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the rule executor interface
    hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pExecRules = NULL;

    // Show dialog in 2 second
    pProgress->Show(0);

    hr = RuleUtil_HrApplyRulesToFolder(RULE_APPLY_SHOWUI, (FOLDER_LOCAL != infoFolder.tyFolder) ? DELETE_MESSAGE_NOTRASHCAN : 0,
                    pIExecRules, pFolder, pProgress->GetHwnd(), pProgress);
    // Close the progress window
    pProgress->Close();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show confirmation dialog
    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSendersApplySuccess), NULL, MB_OK | MB_ICONINFORMATION);

    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    SafeRelease(pIExecRules);
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    SafeMemFree(pCritItem);
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pFolder);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSendersApplyFail), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRulesManager
//
//  This creates a rules manager.
//
//  pIUnkOuter  - For aggregation, it must be NULL
//  ppIUnknown  - The interface the was created
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRulesManager(IUnknown * pIUnkOuter, IUnknown ** ppIUnknown)
{
    HRESULT             hr = S_OK;
    CRulesManager *     pRulesManager = NULL;
    IOERulesManager *   pIRulesMgr = NULL;

    // Check the incoming params
    if (NULL == ppIUnknown)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    Assert(NULL == pIUnkOuter);
    
    // Initialize outgoing params
    *ppIUnknown = NULL;

    // Create the rules manager object
    pRulesManager = new CRulesManager;
    if (NULL == pRulesManager)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pRulesManager->QueryInterface(IID_IOERulesManager, (void **) &pIRulesMgr);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRulesManager = NULL;

    *ppIUnknown = static_cast<IUnknown *>(pIRulesMgr);
    pIRulesMgr = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRulesMgr);
    if (NULL != pRulesManager)
    {
        delete pRulesManager;
    }
    
    return hr;
}

HRESULT RuleUtil_HrBuildEmailString(LPWSTR pwszText, ULONG cchText, LPWSTR * ppwszEmail, ULONG * pcchEmail)
{
    HRESULT     hr = S_OK;
    WCHAR       wszParseSep[16];
    LPWSTR      pwszAddr = NULL,
                pwszTerm = NULL,
                pwszWalk = NULL,
                pwszStrip = NULL;
    ULONG       cchParse = 0;

    // Check incoming params
    if ((NULL == pwszText) || (NULL == ppwszEmail))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppwszEmail = NULL;
    if (NULL != pcchEmail)
    {
        *pcchEmail = 0;
    }

    // Grab the terminator
    cchParse = LoadStringWrapW(g_hLocRes, idsEmailParseSep, wszParseSep, ARRAYSIZE(wszParseSep));
    Assert(cchParse != 0);
    
    // The output string is at least as long as the imput string
    pwszAddr = PszDupW(pwszText);
    if (NULL == pwszAddr)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    DWORD cchSizeAddr = (lstrlenW(pwszAddr) + 1);
    DWORD cchSizeWalk = cchSizeAddr;

    pwszAddr[0] = L'\0';
    pwszTerm = pwszText;
    pwszWalk = pwszAddr;
    while (NULL != pwszTerm)
    {
        pwszStrip = pwszWalk;
        pwszTerm = StrStrW(pwszText, wszParseSep);
        if (L'\0' != pwszAddr[0])
        {
            StrCpyNW(pwszWalk, g_wszComma, cchSizeWalk);
            pwszStrip++;
        }

        if (NULL == pwszTerm)
        {
            StrCatBuffW(pwszWalk, pwszText, cchSizeWalk);
        }
        else
        {
            StrNCatW(pwszWalk, pwszText, (int)(pwszTerm - pwszText + 1));
            pwszTerm += cchParse;
            pwszText = pwszTerm;
        }
        
        if (0 == UlStripWhitespaceW(pwszStrip, TRUE, TRUE, NULL))
        {
            *pwszWalk = '\0';
        }

        cchSizeWalk -= lstrlenW(pwszWalk);
        pwszWalk += lstrlenW(pwszWalk);
    }
    
    // Set the outgoing params
    if (NULL != pcchEmail)
    {
        *pcchEmail = lstrlenW(pwszAddr);
    }
    
    *ppwszEmail = pwszAddr;
    pwszAddr = NULL;

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pwszAddr);
    return hr;
}

HRESULT RuleUtil_HrParseEmailString(LPWSTR pwszEmail, ULONG cchEmail, LPWSTR *ppwszOut, ULONG * pcchOut)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwszText = NULL,
                pwszTerm = NULL;
    ULONG       cchText = 0;
    ULONG       ulIndex = 0;
    ULONG       ulTerm = 0;
    WCHAR       wszSep[16];
    ULONG       cchSep = 0;

    // Check incoming params
    if ((NULL == pwszEmail) || (NULL == ppwszOut))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppwszOut = NULL;
    if (NULL != pcchOut)
    {
        *pcchOut = 0;
    }

    // Make sure we know how big the input string is
    if (0 == cchEmail)
    {
        cchEmail = (ULONG) lstrlenW(pwszEmail);
    }

    cchText = cchEmail;
    pwszTerm = pwszEmail;
    // Figure out the space needed to hold the new addresses
    while (NULL != pwszTerm)
    {
        pwszTerm = StrStrW(pwszTerm, g_wszComma);
        if (NULL != pwszTerm)
        {
            cchText++;
            pwszTerm++;
        }
    }
    
    // Grab the terminator
    LoadStringWrapW(g_hLocRes, idsEmailSep, wszSep, ARRAYSIZE(wszSep));
    cchSep = lstrlenW(wszSep);
    
    // The output string is at least as long as the imput string
    hr = HrAlloc((void **) &pwszText, (cchText + 1)*sizeof(*pwszText));
    if (FAILED(hr))
    {
        goto exit;
    }

    pwszText[0] = L'\0';
    pwszTerm = pwszEmail;
    cchText++;
    while (NULL != pwszTerm)
    {
        pwszTerm = StrStrW(pwszEmail, g_wszComma);
        if (NULL != pwszTerm)
        {
            pwszTerm++;
            StrNCatW(pwszText, pwszEmail, (int)(pwszTerm - pwszEmail));
            StrCatBuffW(pwszText, wszSep, cchText);
            pwszEmail = pwszTerm;
        }
        else
        {
            StrCatBuffW(pwszText, pwszEmail, cchText);
        }
    }
    
    // Terminate the string
    cchText = lstrlenW(pwszText);

    // Set the outgoing param
    *ppwszOut = pwszText;
    pwszText = NULL;
    if (NULL != pcchOut)
    {
        *pcchOut = cchText;
    }

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pwszText);
    return hr;
}

HRESULT RuleUtil_HrBuildTextString(LPTSTR pszIn, ULONG cchIn, LPTSTR * ppszText, ULONG * pcchText)
{
    HRESULT     hr = S_OK;
    LPTSTR      pszText = NULL;
    LPTSTR      pszTerm = NULL;
    LPTSTR      pszWalk = NULL;
    LPTSTR      pszStrip = NULL;
    ULONG       cchSpace = 0;

    // Check incoming params
    if ((NULL == pszIn) || (NULL == ppszText))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = 0;
    }

    // The output string is at least as long as the imput string
    pszText = PszDupA(pszIn);
    if (NULL == pszText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pszText[0] = '\0';
    pszTerm = pszIn;
    pszWalk = pszText;
    cchSpace = lstrlen(g_szSpace);
    DWORD cchSize = lstrlen(pszIn)+1;

    while ('\0' != *pszTerm)
    {
        pszStrip = pszWalk;
        pszTerm = pszIn;
        while(('\0' != *pszTerm) && (FALSE == FIsSpaceA(pszTerm)))
        {
            pszTerm = CharNext(pszTerm);
        }
        
        if ('\0' != pszText[0])
        {
            StrCpyN(pszWalk, g_szSpace, cchSize);
            pszStrip += cchSpace;
        }

        if ('\0' == *pszTerm)
        {
            StrCatBuff(pszWalk, pszIn, cchSize);
        }
        else
        {
            pszTerm = CharNext(pszTerm);
            StrNCat(pszWalk, pszIn, (int)(pszTerm - pszIn));
            pszIn = pszTerm;
        }
        
        if (0 == UlStripWhitespace(pszStrip, TRUE, TRUE, NULL))
        {
            *pszWalk = '\0';
        }

        cchSize -= lstrlen(pszWalk);
        pszWalk += lstrlen(pszWalk);
    }
    
    // Set the outgoing params
    if (NULL != pcchText)
    {
        *pcchText = lstrlen(pszText);
    }
    
    *ppszText = pszText;
    pszText = NULL;

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

// -------------------------------------------------------------------------------------------
// HrDlgRuleGetString
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrGetDlgString(HWND hwndDlg, UINT uiCtlId, LPTSTR *ppszText, ULONG * pcchText)
{
    HRESULT         hr = S_OK;
    HWND            hwndCtl = NULL;
    LPTSTR          pszText = NULL;
    ULONG           cchText = 0;

    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppszText))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));
    
    // Init the output params
    *ppszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = 0;
    }
    
    // Get the dialog control
    hwndCtl = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndCtl)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get text length
    cchText = (ULONG) SendMessage(hwndCtl, WM_GETTEXTLENGTH, 0, 0);
    
    hr = HrAlloc((void **) &pszText, cchText + 1);
    if (FAILED(hr))
    {
        goto exit;
    }

    GetDlgItemText(hwndDlg, uiCtlId, pszText, cchText + 1);

    // Set the output params
    *ppszText = pszText;
    pszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = cchText;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

HRESULT RuleUtil_HrGetRegValue(HKEY hkey, LPCSTR pszValueName, DWORD * pdwType, BYTE ** ppbData, ULONG * pcbData)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming params
    if (NULL == ppbData)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Figure out the space to hold the criteria order
    lErr = SHQueryValueEx(hkey, pszValueName, 0, pdwType, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }
    
    // Allocate the space to hold the criteria order
    hr = HrAlloc((void **) &pbData, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the criteria order
    lErr = SHQueryValueEx(hkey, pszValueName, 0, pdwType, pbData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Return the values
    *ppbData = pbData;
    pbData = NULL;
    if (NULL != pcbData)
    {
        *pcbData = cbData;
    }
    
exit:
    SafeMemFree(pbData);
    return hr;
}

// -------------------------------------------------------------------------------------------
// RuleUtil_HrGetAddressesFromWAB
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrGetAddressesFromWAB(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs)
{
    HRESULT     hr = S_OK;
    CWabal     *pWabal = NULL,
               *pWabalExpand = NULL;
    LPWSTR      pwszText = NULL,
                pwszLoop = NULL;
    BOOL        fFound = FALSE,
                fBadAddrs = FALSE;
    ULONG       cchText = 0;
    ADRINFO     adrInfo = {0};

    
    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppwszAddrs))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));

    // Create Wabal Object
    hr = HrCreateWabalObject(&pWabal);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we have a string then add it to the wabal object
    if (NULL != *ppwszAddrs)
    {
        for (pwszLoop = *ppwszAddrs; L'\0' != pwszLoop[0]; pwszLoop += lstrlenW(pwszLoop) + 1)
            pWabal->HrAddEntry(pwszLoop, pwszLoop, lRecipType);
    }

    // Let's go pick some new names
    hr = pWabal->HrRulePickNames(hwndDlg, lRecipType, idsRuleAddrCaption, idsRuleAddrWell, uidsWellButton);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the space needed to hold the new addresses

    // Create the expanded Wabal Object
    hr = HrCreateWabalObject(&pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    //Expand the groups to addresses...
    hr = pWabal->HrExpandTo(pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    SafeRelease(pWabal);
    
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if ((NULL != adrInfo.lpwszAddress) && (L'\0' != adrInfo.lpwszAddress[0]))
        {
            cchText += lstrlenW(adrInfo.lpwszAddress) + 1;
        }
        else
        {
            fBadAddrs = TRUE;
        }

        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Add space for the terminator
    cchText += 2;
        
    // Allocate the new space
    hr = HrAlloc((void **) &pwszText, cchText*sizeof(WCHAR));
    if (FAILED(hr))
    {
        goto exit;
    }
    pwszText[0] = L'\0';

    // Build up the new string
    pwszLoop = pwszText;
    DWORD cchLoop = cchText;

    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if ((NULL != adrInfo.lpwszAddress) && (L'\0' != adrInfo.lpwszAddress[0]))
        {
            StrCpyNW(pwszLoop, adrInfo.lpwszAddress, cchLoop);
            cchLoop -= (lstrlenW(adrInfo.lpwszAddress) + 1);
            pwszLoop += (lstrlenW(adrInfo.lpwszAddress) + 1);
        }
        else
        {
            fBadAddrs = TRUE;
        }
        
        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Terminate the string
    pwszLoop[0] = L'\0';
    pwszLoop[1] = L'\0';
    
    // Set the outgoing param
    if (NULL != *ppwszAddrs)
    {
        MemFree(*ppwszAddrs);
    }
    *ppwszAddrs = pwszText;
    pwszText = NULL;

    // Set the proper return value
    hr = S_OK;

exit:
    if (FALSE != fBadAddrs)
    {
        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesWarnEmptyEmail), NULL, MB_ICONINFORMATION | MB_OK);
    }
    MemFree(pwszText);
    ReleaseObj(pWabal);
    ReleaseObj(pWabalExpand);
    return hr;
}

// -------------------------------------------------------------------------------------------
// FPickEMailNames
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrPickEMailNames(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs)
{
    HRESULT     hr = S_OK;
    CWabal     *pWabal = NULL,
               *pWabalExpand = NULL;
    LPWSTR      pwszText = NULL,
                pwszNames = NULL,
                pwszLoop = NULL,
                pwszTerm = NULL;
    ULONG       cchText = 0,
                cchSep = 0;
    BOOL        fFound = FALSE,
                fAddSep = FALSE,
                fBadAddrs = FALSE;
    ADRINFO     adrInfo;

    
    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppwszAddrs))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));

    // Create Wabal Object
    hr = HrCreateWabalObject(&pWabal);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we have a string then add it to the wabal object
    if ((NULL != *ppwszAddrs) && (L'\0' != **ppwszAddrs))
    {
        pwszNames = PszDupW(*ppwszAddrs);
        pwszTerm = pwszNames;
        for (pwszLoop = pwszNames; NULL != pwszTerm; pwszLoop += lstrlenW(pwszLoop) + 1)
        {
            // Terminate the address
            pwszTerm = StrStrW(pwszLoop, g_wszComma);
            if (NULL != pwszTerm)
            {
                *pwszTerm = L'\0';
            }
            
            pWabal->HrAddEntry(pwszLoop, pwszLoop, lRecipType);
        }
        
        SafeMemFree(pwszNames);
    }

    // Let's go pick some new names
    hr = pWabal->HrRulePickNames(hwndDlg, lRecipType, idsRuleAddrCaption, idsRuleAddrWell, uidsWellButton);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the space needed to hold the new addresses

    // Create the expanded Wabal Object
    hr = HrCreateWabalObject(&pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    //Expand the groups to addresses...
    hr = pWabal->HrExpandTo(pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    SafeRelease(pWabal);
    
    // Load the email seperator
    cchSep = lstrlenW(g_wszComma);
    
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if (NULL != adrInfo.lpwszAddress)
        {
            cchText += lstrlenW(adrInfo.lpwszAddress) + cchSep;
        }
        else
        {
            fBadAddrs = TRUE;
        }

        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Allocate the new space
    hr = HrAlloc((void **) &pwszText, (cchText + 1)*sizeof(*pwszText));
    if (FAILED(hr))
    {
        goto exit;
    }
    pwszText[0] = L'\0';

    // Build up the new string
    DWORD cchBufSize = cchText+1;
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if (NULL != adrInfo.lpwszAddress)
        {
            if (FALSE == fAddSep)
            {
                fAddSep = TRUE;
            }
            else
            {
                StrCatBuffW(pwszText, g_wszComma, cchBufSize);
                cchText += cchSep;
            }

            StrCatBuffW(pwszText, adrInfo.lpwszAddress, cchBufSize);
            cchText += lstrlenW(adrInfo.lpwszAddress);
        }
        else
        {
            fBadAddrs = TRUE;
        }
        
        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Set the outgoing param
    if (NULL != *ppwszAddrs)
    {
        MemFree(*ppwszAddrs);
    }
    *ppwszAddrs = pwszText;
    pwszText = NULL;

    // Set the proper return value
    hr = S_OK;

exit:
    if (FALSE != fBadAddrs)
    {
        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesWarnEmptyEmail), NULL, MB_ICONINFORMATION | MB_OK);
    }
    SafeMemFree(pwszText);
    SafeRelease(pWabal);
    SafeRelease(pWabalExpand);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_FEnDisDialogItem
//
//  This enables or disables a control in a dialog.
//  The real special thing this function does is make sure
//  the focus of the dialog isn't stuck in a disabled control
//
//  Returns:    TRUE, if the enabled state was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL RuleUtil_FEnDisDialogItem(HWND hwndDlg, UINT idcItem, BOOL fEnable)
{
    BOOL    fRet = FALSE;
    HWND    hwndFocus = NULL;
    HWND    hwndItem = NULL;

    // check params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    hwndItem = GetDlgItem(hwndDlg, idcItem);
    
    // Make sure we aren't disabling the window with the focus
    if ((FALSE == fEnable) && (hwndItem == GetFocus()))
    {        
        SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM) 0, (LPARAM) LOWORD(FALSE)); 
    }

    // Enable or disable the window
    EnableWindow(hwndItem, fEnable);

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_AppendRichEditText
//
//  This sets a string into a richedit control with the proper style.
//
//  Returns:    S_OK, if the string was set
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_AppendRichEditText(HWND hwndRedit, ULONG ulStart, LPCWSTR pwszText, CHARFORMAT *pchfmt)
{
    CHARFORMAT  chFmtDef = {0};
    HRESULT     hr = S_OK;
    ULONG       cchText = 0;
    CHARRANGE   chrg = {0};

    // check params
    Assert(hwndRedit);
    Assert(pwszText);

    // Set the string into the richedit control
    chrg.cpMin = ulStart;
    chrg.cpMax = ulStart;
    RichEditExSetSel(hwndRedit, &chrg);

    // Figure out the string length
    cchText = lstrlenW(pwszText);
    SetRichEditText(hwndRedit, (LPWSTR)pwszText, TRUE, NULL, TRUE);

    chrg.cpMax = ulStart + cchText;
    RichEditExSetSel(hwndRedit, &chrg);

    // If we have a style to set on the string let's do it
    if (pchfmt)
    {
        SendMessage(hwndRedit, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM)pchfmt);

        // Reset default settings for CHARFORMAT
        chrg.cpMin = ulStart + cchText;
        RichEditExSetSel(hwndRedit, &chrg);
        chFmtDef.cbSize = sizeof(chFmtDef);
        chFmtDef.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
        chFmtDef.dwEffects = CFE_AUTOCOLOR;
        SendMessage(hwndRedit, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM)&chFmtDef);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrShowLinkedString
//
//  This writes a format string into a richedit control
//
//  Returns:    S_OK, if it was successfully written
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrShowLinkedString(HWND hwndEdit, BOOL fError, BOOL fReadOnly, 
                                LPWSTR pwszFmt, LPCWSTR pwszData, ULONG ulStart,
                                ULONG * pulStartLink, ULONG * pulEndLink, ULONG * pulEnd)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      chfmt = {0};
    COLORREF        clr = 0;
    LPWSTR          pwszMark = NULL;
    ULONG           ulStartLink = 0;
    ULONG           ulEndLink = 0;

    if ((NULL == hwndEdit) || (NULL == pwszFmt) || (L'\0' == *pwszFmt))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    if (pulStartLink)
    {
        *pulStartLink = 0;
    }
    if (pulEndLink)
    {
        *pulEndLink = 0;
    }
    if (pulEnd)
    {
        *pulEnd = 0;
    }
    
    // Find the underline mark
    pwszMark = StrStrW(pwszFmt, c_wszRuleMarkStart);
    if (NULL != pwszMark)
    {
        *pwszMark = L'\0';
    }

    // Write out the normal string
    RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszFmt, NULL);
    ulStart += lstrlenW(pwszFmt);
    
    // If we didn't have anything to underline
    // then we're done.
    if (NULL == pwszMark)
    {
        // Save off the new end
        if (NULL != pulEnd)
        {
            *pulEnd = ulStart;
        }

        // Return
        hr = S_OK;
        goto exit;
    }
    
    // Skip over the mark
    pwszFmt = pwszMark + lstrlenW(c_wszRuleMarkStart);

    // Find the mark end
    pwszMark = StrStrW(pwszFmt, c_wszRuleMarkEnd);
    if (NULL == pwszMark)
    {
        hr = E_FAIL;
        goto exit;
    }

    // If we don't have some data then 
    // just underline the original string
    if (NULL == pwszData)
    {
        *pwszMark = L'\0';
        pwszData = pwszFmt;
    }
    
    // Save off the character positions
    ulStartLink = ulStart;
    ulEndLink = ulStart + lstrlenW(pwszData);

    // If readonly, then don't add links
    if (fReadOnly)
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszData, NULL);
    else
    {
        if (fError)
            clr = RGB(255, 0, 0);
        else
            LookupLinkColors(&clr, NULL);

        // Which color should we use for underlining
        chfmt.crTextColor = clr;

        chfmt.cbSize = sizeof(chfmt);
        chfmt.dwMask = CFM_UNDERLINE | CFM_COLOR;
        chfmt.dwEffects = CFE_UNDERLINE;
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszData, &chfmt);
    }

    // Write out the linked string
    ulStart = ulEndLink;

    // Move to the next part of the string
    pwszFmt = pwszMark + lstrlenW(c_wszRuleMarkEnd);

    // If we have more of the string to write out
    if (L'\0' != *pwszFmt)
    {
        // Write out the rest of the string string
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszFmt, NULL);
        ulStart += lstrlenW(pwszFmt);
    }
    
    // Set the outgoing param
    if (pulStartLink)
    {
        *pulStartLink = ulStartLink;
    }
    if (pulEndLink)
    {
        *pulEndLink = ulEndLink;
    }
    if (pulEnd)
    {
        *pulEnd = ulStart;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrDupCriteriaItem(CRIT_ITEM * pItemIn, ULONG cItemIn, CRIT_ITEM ** ppItemOut)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    CRIT_ITEM *     pItem = NULL;

    // Check incoming params
    if ((NULL == pItemIn) || (NULL == ppItemOut) || (0 == cItemIn))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppItemOut = NULL;
    
    // Allocate the initial list of criteria
    hr = HrAlloc((void **) &pItem, cItemIn * sizeof(*pItem));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the entire new criteria list
    ZeroMemory(pItem, cItemIn * sizeof(*pItem));
    
    // Walk over the list of criteria and set up the propvar for each one
    for (ulIndex = 0; ulIndex < cItemIn; ulIndex++)
    {
        // Copy over the criteria info
        pItem[ulIndex].type = pItemIn[ulIndex].type;
        pItem[ulIndex].dwFlags = pItemIn[ulIndex].dwFlags;
        pItem[ulIndex].logic = pItemIn[ulIndex].logic;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pItem[ulIndex].propvar), &(pItemIn[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Set the outgoing param
    *ppItemOut = pItem;
    pItem = NULL;
    
    // Set proper return value
    hr = S_OK;

exit:
    if (NULL != pItem)
    {
        RuleUtil_HrFreeCriteriaItem(pItem, cItemIn);
        MemFree(pItem);
    }
    return hr;
}

HRESULT RuleUtil_HrFreeCriteriaItem(CRIT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Walk over the list of criteria and free each one
    for (ulIndex = 0; ulIndex < cItem; ulIndex++)
    {
        PropVariantClear(&(pItem[ulIndex].propvar));
    }

    // Set proper return value
    hr = S_OK;

exit:
    return hr;
}

HRESULT RuleUtil_HrDupActionsItem(ACT_ITEM * pItemIn, ULONG cItemIn, ACT_ITEM ** ppItemOut)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    ACT_ITEM *      pItem = NULL;

    // Check incoming params
    if ((NULL == pItemIn) || (NULL == ppItemOut) || (0 == cItemIn))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppItemOut = NULL;
    
    // Allocate the initial list of actions
    hr = HrAlloc((void **) &pItem, cItemIn * sizeof(*pItem));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the entire new actions list
    ZeroMemory(pItem, cItemIn * sizeof(*pItem));
    
    // Walk over the list of actions and set up the propvar for each one
    for (ulIndex = 0; ulIndex < cItemIn; ulIndex++)
    {
        // Copy over the actions info
        pItem[ulIndex].type = pItemIn[ulIndex].type;
        pItem[ulIndex].dwFlags = pItemIn[ulIndex].dwFlags;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pItem[ulIndex].propvar), &(pItemIn[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Set the outgoing param
    *ppItemOut = pItem;
    pItem = NULL;
    
    // Set proper return value
    hr = S_OK;

exit:
    SafeMemFree(pItem);
    return hr;
}

HRESULT RuleUtil_HrFreeActionsItem(ACT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Walk over the list of criteria and free each one
    for (ulIndex = 0; ulIndex < cItem; ulIndex++)
    {
        PropVariantClear(&(pItem[ulIndex].propvar));
    }

    // Set proper return value
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrAddBlockSender
//
//  This adds the address/domain name to the list of senders we will block
//
//  hwndOwner   - the window the owns this UI
//  pszAddr     - the address/domain name to add
//  dwFlags     - modifiers on how to add the address/domain name 
//
//  Returns:    S_OK, if the address/domain name was added
//              S_FALSE, if the address/domain name was already in the list
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrAddBlockSender(RULE_TYPE type, LPCSTR pszAddr)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRuleOrig = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    ACT_ITEM        aitem;
    CRIT_ITEM *     pcitem = NULL;
    ULONG           ccitem = 0;
    ULONG           ulIndex = 0;
    BOOL            fFound = FALSE;
    LPSTR           pszAddrNew = NULL;
    RULEINFO        infoRule = {0};

    // Check incoming params
    if ((NULL == pszAddr) || ('\0' == pszAddr[0]))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the block sender rule from the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, type, 0, &pIRuleOrig);
    if (FAILED(hr))
    {
        // Create the new rule
        hr = RuleUtil_HrCreateSendersRule(0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    // If the block sender rule exist
    else
    {
        // Clone it so we can make a change
        hr = pIRuleOrig->Clone(&pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        SafeRelease(pIRuleOrig);
    }

    // Get the criteria list from the rules object
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    Assert(VT_BLOB == propvar.vt);
    ccitem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pcitem = (CRIT_ITEM *) propvar.blob.pBlobData;
    ZeroMemory(&propvar, sizeof(propvar));
    
    // Search for the address/domain name in the criteria list
    if (NULL != pcitem)
    {
        for (ulIndex = 0; ulIndex < ccitem; ulIndex++)
        {
            Assert(CRIT_TYPE_SENDER == pcitem[ulIndex].type)
            Assert(CRIT_LOGIC_OR == pcitem[ulIndex].logic)
            if ((VT_LPSTR != pcitem[ulIndex].propvar.vt) || (NULL == pcitem[ulIndex].propvar.pszVal))
            {
                continue;
            }
            
            if (0 == lstrcmpi(pszAddr, pcitem[ulIndex].propvar.pszVal))
            {
                fFound = TRUE;
                break;
            }
        }
    }
    
    // Did we find it?
    if (FALSE != fFound)
    {
        hr = S_FALSE;
        goto exit;
    }
    // Allocate space to hold the new criteria
    hr = HrRealloc((void **) &pcitem, (ccitem + 1) * sizeof(CRIT_ITEM));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Copy over the name
    pszAddrNew = PszDupA(pszAddr);
    if (NULL == pszAddrNew)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Add in to the end of the criteria list
    pcitem[ccitem].type =  CRIT_TYPE_SENDER;  
    pcitem[ccitem].dwFlags = CRIT_FLAG_DEFAULT;
    pcitem[ccitem].logic =  CRIT_LOGIC_OR;  
    pcitem[ccitem].propvar.vt =  VT_LPSTR;
    pcitem[ccitem].propvar.pszVal =  pszAddrNew;
    pszAddrNew = NULL;
    ccitem++;

    // Set the criteria back into the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = ccitem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pcitem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = pIRule;
    
    // Set the rule back into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, type, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszAddrNew);
    RuleUtil_HrFreeCriteriaItem(pcitem, ccitem);
    SafeMemFree(pcitem);
    PropVariantClear(&propvar);
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return hr;
}

HRESULT RuleUtil_HrMergeActions(ACT_ITEM * pActionsOrig, ULONG cActionsOrig,
                                ACT_ITEM * pActionsNew, ULONG cActionsNew,
                                ACT_ITEM ** ppActionsDest, ULONG * pcActionsDest)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ULONG       ulIndex = 0;
    ULONG       ulAction = 0;
    ULONG       cActionsAdded = 0;
    ULONG       ulAdd = 0;
    
    // Verify incoming params
    if (((NULL == pActionsOrig) && (0 != cActionsOrig)) || (NULL == pActionsNew) || (0 == cActionsNew) ||
            (NULL == ppActionsDest) || (NULL == pcActionsDest))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppActionsDest = NULL;
    *pcActionsDest = 0;
    
    // Allocate the maximum space to hold the destination actions
    hr = HrAlloc((VOID **) &pActions, (cActionsOrig + cActionsNew) * sizeof(*pActions));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the destination actions list
    ZeroMemory(pActions, (cActionsOrig + cActionsNew) * sizeof(*pActions));
    
    // Copy over the original list to the destination actions list
    for (ulIndex = 0; ulIndex < cActionsOrig; ulIndex++)
    {
        // Copy over the actions info
        pActions[ulIndex].type = pActionsOrig[ulIndex].type;
        pActions[ulIndex].dwFlags = pActionsOrig[ulIndex].dwFlags;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pActions[ulIndex].propvar), &(pActionsOrig[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // For each item in the new actions list
    cActionsAdded = cActionsOrig;
    for (ulIndex = 0; ulIndex < cActionsNew; ulIndex++)
    {

        // if it's a copy, fwd or reply
        if ((ACT_TYPE_COPY == pActionsNew->type) ||
                (ACT_TYPE_FWD == pActionsNew->type) ||
                (ACT_TYPE_REPLY == pActionsNew->type))
        {
            // Append it to the list
            ulAdd = cActionsAdded;
        }
        else
        {
            // Find the item in the new list
            for (ulAction = 0; ulAction < cActionsAdded; ulAction++)
            {
                // If we have a match, the replace it
                if (pActionsNew[ulIndex].type == pActions[ulAction].type)
                {
                    break;
                }
                // else, if we have some type of move operation
                // then replace it
                else if (((ACT_TYPE_MOVE == pActionsNew[ulIndex].type) ||
                        (ACT_TYPE_DELETE == pActionsNew[ulIndex].type) ||
                        (ACT_TYPE_JUNKMAIL == pActionsNew[ulIndex].type)) &&
                            ((ACT_TYPE_MOVE == pActions[ulAction].type) ||
                            (ACT_TYPE_DELETE == pActions[ulAction].type) ||
                            (ACT_TYPE_JUNKMAIL == pActions[ulAction].type)))
                {
                    break;
                }
            }

            // Did we find anything
            if (ulAction >= cActionsAdded)
            {
                ulAdd = cActionsAdded;
            }
            else
            {
                ulAdd = ulAction;
            }
        }

        // Replace the item
        pActions[ulAdd].type = pActionsNew[ulIndex].type;
        pActions[ulAdd].dwFlags = pActionsNew[ulIndex].dwFlags;

        // Clear out the old propvar
        PropVariantClear(&(pActions[ulAdd].propvar));
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pActions[ulAdd].propvar), &(pActionsNew[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we added something
        if (ulAdd == cActionsAdded)
        {
            cActionsAdded++;
        }
    }
    
    // Set the outgoing params
    *ppActionsDest = pActions;
    pActions = NULL;
    *pcActionsDest = cActionsAdded;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrGetOldFormatString(HKEY hkeyRoot, LPCSTR pszValue, LPCSTR pszSep, LPSTR * ppszString, ULONG * pcchString)
{
    HRESULT     hr = S_OK;
    DWORD       dwType = 0;
    LPSTR       pszData = NULL;
    ULONG       cbData = 0;
    LPSTR       pszWalk = NULL;
    ULONG       ulIndex = 0;
    LPSTR       pszTerm = NULL;
    ULONG       cchLen = 0;
    ULONG       cchString = 0;
    LPSTR       pszString = NULL;
    LPSTR       pszOld = NULL;

    // Check incoming params
    if ((NULL == hkeyRoot) || (NULL == pszValue) || (NULL == pszSep) || (NULL == ppszString))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppszString = NULL;
    if (NULL != pcchString)
    {
        *pcchString = 0;
    }

    // Get the old value from the registry
    hr = RuleUtil_HrGetRegValue(hkeyRoot, pszValue, &dwType, (BYTE **) &pszData, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the number of bytes needed
    pszWalk = pszData;
    cchString = 0;
    for (ulIndex = 0; ulIndex < cbData; ulIndex += cchLen, pszWalk += cchLen)
    {
        // Search for terminator
        pszTerm = StrStr(pszWalk, pszSep);

        // If we have a terminator
        if (NULL != pszTerm)
        {
            cchLen = (ULONG)(pszTerm - pszWalk + 1);
        }
        else
        {
            cchLen = lstrlen(pszWalk) + 1;
        }

        // If this isn't a null string
        if (1 != cchLen)
        {
            // Add the number of characters    
            cchString += cchLen;
        }
    }

    // Add in space to hold the terminator
    cchString += 2;

    // Allocate space to hold the final string
    hr = HrAlloc((VOID **) &pszString, cchString * sizeof(*pszString));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Copy over each string
    pszWalk = pszString;
    pszOld = pszData;
    for (ulIndex = 0; ulIndex < cbData; ulIndex += cchLen, pszOld += cchLen)
    {
        // Search for terminator
        pszTerm = StrStr(pszOld, pszSep);

        // If we have a terminator
        if (NULL != pszTerm)
        {
            cchLen = (ULONG)(pszTerm - pszOld + 1);
        }
        else
        {
            cchLen = lstrlen(pszOld) + 1;
        }

        // If this isn't a null string
        if (1 != cchLen)
        {
            // Copy over the string
            StrCpyN(pszWalk, pszOld, cchLen);
            
            // Move to the next string
            pszWalk += lstrlen(pszWalk) + 1;
        }
    }

    // Terminate the string
    pszWalk[0] = '\0';
    pszWalk[1] = '\0';
    
    // Set the outgoing params
    *ppszString = pszString;
    pszString = NULL;
    if (NULL != pcchString)
    {
        *pcchString = cchString;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszData);
    return hr;
}

// ------------------------------------------------------------------------------------
// _FIsLoopingAddress
// ------------------------------------------------------------------------------------
BOOL _FIsLoopingAddress(LPCSTR pszAddressTo)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTR               pszAddress=NULL;
    CHAR                szFrom[CCHMAX_EMAIL_ADDRESS];
    BOOL                fResult=FALSE;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;

    // Check State
    Assert(pszAddressTo);

    // Enumerate the user's SMTP and POP3 Accounts
    CHECKHR(hr = g_pAcctMan->Enumerate(SRV_POP3 | SRV_SMTP, &pEnum));

    // Duplicate the To Address
    CHECKALLOC(pszAddress = PszDupA(pszAddressTo));

    // Make it lower case
    CharLower(pszAddress);

    // Enumerate
    while(SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get Email Address
        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szFrom, ARRAYSIZE(szFrom))))
        {
            // Lower it
            CharLower(szFrom);

            // Is this to myself
            if (StrStr(pszAddress, szFrom) || StrStr(szFrom, pszAddress))
            {
                fResult = TRUE;
                goto exit;
            }
        }

        // Done
        SafeRelease(pAccount);
    }

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(pszAddress);

    // Done
    return fResult;
}

// ------------------------------------------------------------------------------------
// _HrAutoForwardMessage
// ------------------------------------------------------------------------------------
HRESULT _HrAutoForwardMessage(HWND hwndUI, LPCSTR pszForwardTo, LPCSTR pszAcctId, IStream *pstmMsg, BOOL *pfLoop)
{
    // Locals
    HRESULT              hr=S_OK;
    IMimeMessage        *pMessage=NULL;
    PROPVARIANT          rUserData;
    IMimeAddressTable   *pAddrTable=NULL;
    CHAR                 szDisplayName[CCHMAX_DISPLAY_NAME];
    CHAR                 szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    HTMLOPT              rHtmlOpt;
    PLAINOPT             rPlainOpt;
    BOOL                 fHTML;
    IImnAccount         *pAccount=NULL;
    PROPVARIANT          rOption;
    CHAR                 szId[CCHMAX_ACCOUNT_NAME];
    BOOL                 fUseDefaultAcct = FALSE;
    BOOL                 fSendImmediate = FALSE;

    // check Params
    Assert(pstmMsg && pszForwardTo && pfLoop);

    // Init
    *pfLoop = FALSE;

    // Is the new recipient the same as my current email address
    if (NULL == pszForwardTo || _FIsLoopingAddress(pszForwardTo))
    {
        *pfLoop = TRUE;
        return TrapError(E_FAIL);
    }

    // Open the Account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount);

    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        CHECKHR(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount));
        fUseDefaultAcct = TRUE;
    }

    // Create a Message
    CHECKHR(hr = HrCreateMessage(&pMessage));

    // Lets rewind pstmReplyWith
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Load String into my message object
    CHECKHR(hr = pMessage->Load(pstmMsg));

    // Get the wabal
    CHECKHR(hr = pMessage->GetAddressTable(&pAddrTable));

    // Remove all of the recipients...
    CHECKHR(hr = pAddrTable->DeleteTypes(IAT_ALL));

    // Get Originator Display Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName)));

    // Get Originator Email Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress)));

    // Add Sender...
    CHECKHR(hr = pAddrTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL));

    // Add Recipient
    CHECKHR(hr = pAddrTable->AppendRfc822(IAT_TO, IET_DECODED, pszForwardTo));

    // Save the AccountID
    rUserData.vt = VT_LPSTR;
    if (FALSE == fUseDefaultAcct)
    {
        rUserData.pszVal = (LPSTR) pszAcctId;
    }
    else
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
        {
            rUserData.pszVal = szId;
        }
        else
        {
            rUserData.pszVal = (LPSTR) pszAcctId;
        }
    }
    pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

    // Save the Account
    CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szId, sizeof(szId)))
    rUserData.pszVal = szId;
    pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
    
    // Raid-33842: Set the date
    CHECKHR(hr = HrSetSentTimeProp(pMessage, NULL));

    // Get Mail Options
    GetDefaultOptInfo(&rHtmlOpt, &rPlainOpt, &fHTML, FMT_MAIL);

    // Store the options on the messaage
    CHECKHR(hr = HrSetMailOptionsOnMessage(pMessage, &rHtmlOpt, &rPlainOpt, NULL, fHTML));

    // Raid-63259: MIMEOLE - Creating message ID causes autodialer to fire
    // Raid-50793: Athena: Should be setting message-ID's in email
#if 0
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pMessage->SetOption(OID_GENERATE_MESSAGE_ID, &rOption);
#endif

    // Should we send it immediately?
    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    // Send the message
    CHECKHR(hr = HrSendMailToOutBox(hwndUI, pMessage, fSendImmediate, TRUE));

exit:
    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pAddrTable);
    SafeRelease(pAccount);

    // done
    return hr;
}

// ------------------------------------------------------------------------------------
// _HrAutoReplyMessage
// ------------------------------------------------------------------------------------
HRESULT _HrAutoReplyMessage(HWND hwndUI, DWORD dwType, LPCSTR pszFilename, IStream * pstmFile,
    LPCSTR pszAcctId, IMimeMessage *pMsgIn, BOOL *pfLoop)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRe[20];
    IMimeMessage       *pMsgOut=NULL;
    LPSTR               pszNewSubj=NULL,
                        pszCurSubj=NULL,
                        pszNormal;
    IMimeAddressTable  *pTable=NULL;
    ADDRESSPROPS        rSender;
    HBODY               hBody;
    CHAR                szDisplayName[CCHMAX_DISPLAY_NAME];
    CHAR                szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    PROPVARIANT         rUserData;
    HTMLOPT             rHtmlOpt;
    PLAINOPT            rPlainOpt;
    BOOL                fHTML;
    IImnAccount         *pAccount=NULL;
    PROPVARIANT         rOption;
    CHAR                szId[CCHMAX_ACCOUNT_NAME];
    BOOL                fUseDefaultAcct = FALSE;
    BOOL                fSendImmediate = FALSE;

    // Problems
    // PMsgIn can be NULL in here (Access Dineied for S/MIME messages.
    // shoul return immediatelly
    if(!pMsgIn)
        return(hr);

    Assert(pszFilename && pstmFile && pMsgIn && pfLoop);

    // Init
    *pfLoop = FALSE;

    // Init
    ZeroMemory(&rSender, sizeof(ADDRESSPROPS));

    // Open the Account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount);

    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        CHECKHR(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount));
        fUseDefaultAcct = TRUE;
    }

    // Create a Message
    CHECKHR(hr = HrCreateMessage(&pMsgOut));

    // Lets rewind pstmFile
    CHECKHR(hr = HrRewindStream(pstmFile));

    // RW_HTML
    switch (dwType)
    {
        case RFT_HTML:
            // Use the stream as the message body
            CHECKHR(hr = pMsgOut->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmFile, NULL));
            break;

        case RFT_TEXT:
            // Use the stream as the message body
            CHECKHR(hr = pMsgOut->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, pstmFile, NULL));
            break;

        case RFT_MESSAGE:
            // Use the stream as a message attachment
            CHECKHR(hr = pMsgOut->AttachObject(IID_IStream, pstmFile, &hBody));

            // Note that the attachment is a message
            MimeOleSetBodyPropA(pMsgOut, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, STR_MIME_MSG_RFC822);
            break;

        case RFT_FILE:
            // Attach File
            CHECKHR(hr = pMsgOut->AttachFile(pszFilename, pstmFile, NULL));
            break;

        default:
            Assert(FALSE);
            hr = E_FAIL;
            goto exit;
            break;
    }
    
    // Get Re:
    AthLoadString(idsPrefixReply, szRe, ARRAYSIZE(szRe));

    // Get the normalized subject
    if (SUCCEEDED(MimeOleGetBodyPropA(pMsgIn, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &pszCurSubj)))
        pszNormal = pszCurSubj;

    // Fixup if null...
    pszNormal = pszNormal ? pszNormal : (LPTSTR)c_szEmpty;

    // Allocate the subject...
    DWORD cchSize = (lstrlen(szRe) + lstrlen(pszNormal) + 5);
    CHECKALLOC(pszNewSubj = PszAllocA(cchSize));

    // Build the subject
    wnsprintf(pszNewSubj, cchSize, "%s%s", szRe, pszNormal);

    // Set the subject
    CHECKHR(hr = MimeOleSetBodyPropA(pMsgOut, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pszNewSubj));

    // Get the message Wabal
    rSender.dwProps = IAP_EMAIL | IAP_FRIENDLY;
    CHECKHR(hr = pMsgIn->GetSender(&rSender));
    Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));

    // Is the new recipient the same as my current email address
    if (_FIsLoopingAddress(rSender.pszEmail))
    {
        *pfLoop = TRUE;
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Add to recipient list of autgen message
    CHECKHR(hr = pMsgOut->GetAddressTable(&pTable));

    // Modify rSender Address Type
    rSender.dwAdrType = IAT_TO;
    FLAGSET(rSender.dwProps, IAP_ADRTYPE);

    // Append Sender as the recipient
    CHECKHR(hr = pTable->Insert(&rSender, NULL));

    // Get Originator Display Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName)));

    // Get Originator Email Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress)));

    // Append Sender
    CHECKHR(hr = pTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL));

    // Save the AccountID
    rUserData.vt = VT_LPSTR;
    if (FALSE == fUseDefaultAcct)
    {
        rUserData.pszVal = (LPSTR) pszAcctId;
    }
    else
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
        {
            rUserData.pszVal = szId;
        }
        else
        {
            rUserData.pszVal = (LPSTR) pszAcctId;
        }
    }
    pMsgOut->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

    // Save the Account
    CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szId, sizeof(szId)))
    rUserData.pszVal = szId;
    pMsgOut->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
    
    // Raid-33842: Set the date
    CHECKHR(hr = HrSetSentTimeProp(pMsgOut, NULL));

    // Get Mail Options
    GetDefaultOptInfo(&rHtmlOpt, &rPlainOpt, &fHTML, FMT_MAIL);

    // Store the options on the messaage
    CHECKHR(hr = HrSetMailOptionsOnMessage(pMsgOut, &rHtmlOpt, &rPlainOpt, NULL, fHTML));

    // Raid-63259: MIMEOLE - Creating message ID causes autodialer to fire
    // Raid-50793: Athena: Should be setting message-ID's in email
#if 0
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pMsgOut->SetOption(OID_GENERATE_MESSAGE_ID, &rOption);
#endif

    // Should we send it immediately?
    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    // Send the message
    CHECKHR(hr = HrSendMailToOutBox(hwndUI, pMsgOut, fSendImmediate, TRUE));

exit:
    // Cleanup
    SafeRelease(pTable);
    SafeMemFree(pszCurSubj);
    SafeMemFree(pszNewSubj);
    SafeRelease(pMsgOut);
    SafeRelease(pAccount);
    g_pMoleAlloc->FreeAddressProps(&rSender);

    // Done
    return hr;
}

HRESULT _HrRecurseSetFilter(FOLDERINFO * pfldinfo, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie)
{
    RULEID              ridRule = RULEID_INVALID;
    IMessageFolder *    pFolder = NULL;
    FOLDERUSERDATA      UserData = {0};

    ridRule = (RULEID) dwCookie;

    if (RULEID_INVALID == ridRule)
    {
        goto exit;
    }

    // If not hidden
    if ((0 != (pfldinfo->dwFlags & FOLDER_HIDDEN)) || (FOLDERID_ROOT == pfldinfo->idFolder))
    {
        goto exit;
    }

    // Not Subscribed
    if (0 == (pfldinfo->dwFlags & FOLDER_SUBSCRIBED))
    {
        goto exit;
    }

    // Server node
    if (0 != (pfldinfo->dwFlags & FOLDER_SERVER))
    {
        goto exit;
    }

    if (FAILED(g_pStore->OpenFolder(pfldinfo->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
    {
        goto exit;
    }

    if ((FOLDER_LOCAL == pfldinfo->tyFolder) && (RULEID_VIEW_DOWNLOADED == ridRule))
    {
        ridRule = RULEID_VIEW_ALL;
    }
    
    // Create the struct to insert
    if (FAILED(pFolder->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
    {
        goto exit;
    }

    UserData.ridFilter = ridRule;
    UserData.dwFilterVersion = 0xFFFFFFFF;
    
    if (FAILED(pFolder->SetUserData(&UserData, sizeof(FOLDERUSERDATA))))
    {
        goto exit;
    }

exit:
    SafeRelease(pFolder);
    return S_OK;
}

HRESULT RuleUtil_HrApplyRulesToFolder(DWORD dwFlags, DWORD dwDeleteFlags,
            IOEExecRules * pIExecRules, IMessageFolder * pFolder, HWND hwndUI, CProgress * pProgress)
{
    HRESULT             hr = S_OK;
    HCURSOR             hcursor = NULL;
    FOLDERID            idFolder = FOLDERID_ROOT;
    HLOCK               hLockNotify = NULL;
    HROWSET             hRowset = NULL;
    MESSAGEINFO         Message = {0};
    IMimeMessage *      pIMMsg = NULL;
    IMimePropertySet *  pIMPropSet = NULL;
    ACT_ITEM *          pActions = NULL;
    ULONG               cActions = 0;
    DWORD               dwExecFlags = 0;
    
    // Wait Cursor
    if (NULL == pProgress)
    {
        hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the Folder Id
    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // We handle partial messages for News
    if (FOLDER_NEWS != GetFolderType(idFolder))
    {
        dwExecFlags |= ERF_SKIPPARTIALS;
    }
    
    // This forces all notifications to be queued (this is good since you do segmented deletes)
    pFolder->LockNotify(0, &hLockNotify);

    // Create a Rowset
    hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Loop
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Do we need to only handle partial messages?
        if ((0 == (dwFlags & RULE_APPLY_PARTIALS)) || (MESSAGE_COMBINED == Message.dwPartial))
        {
            // Open the message object if it's available
            if (Message.faStream)
            {
                if (SUCCEEDED(pFolder->OpenMessage(Message.idMessage, 0, &pIMMsg, NOSTORECALLBACK)))
                {
                    pIMMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pIMPropSet);
                }
            }

            // Get the Actions for this rule
            hr = pIExecRules->ExecuteRules(dwExecFlags, Message.pszAcctId, &Message, pFolder, pIMPropSet,
                                    pIMMsg, Message.cbMessage, &pActions, &cActions);

            // Free up the stuff we're not using anymore
            SafeRelease(pIMPropSet);

            // Did we find anything?
            if (S_OK == hr)
            {
                // Apply this action
                SideAssert(SUCCEEDED(RuleUtil_HrApplyActions(hwndUI, pIExecRules, &Message, 
                                    pFolder, pIMMsg, dwDeleteFlags, pActions, cActions, NULL, NULL)));

                // Free up the actions
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);
            }
            
            SafeRelease(pIMMsg);
        }
        
        pFolder->FreeRecord(&Message);
        
        // Update progress
        if (NULL != pProgress)
        {
            if (S_OK != pProgress->HrUpdate(1))
            {
                hr = S_FALSE;
                goto exit;
            }
        }        
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    SafeRelease(pIMPropSet);
    SafeRelease(pIMMsg);
    pFolder->FreeRecord(&Message);
    pFolder->CloseRowset(&hRowset);
    if (NULL != hLockNotify)
    {
        pFolder->UnlockNotify(&hLockNotify);
    }
    if (NULL == pProgress)
    {
        SetCursor(hcursor);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrImportRules
//
//  This imports the rules from a file
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrImportRules(HWND hwnd)
{
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn;
    CHAR                szFilename[MAX_PATH] = _T("");
    CHAR                szFilter[MAX_PATH] = _T("");
    CHAR                szDefExt[20] = _T("");
    IStream *           pIStm = NULL;
    CLSID               clsid = {0};
    ULONG               cbRead = 0;
    ULONG               cRules = 0;
    RULEINFO *          pinfoRule = NULL;
    CProgress *         pProgress = NULL;
    ULONG               ulIndex = 0;
    IOERule *           pIRule = NULL;
    IPersistStream *    pIPStm = NULL;
    DWORD               dwData = 0;
    RULE_TYPE           type;
    
    // Load Res Strings
    LoadStringReplaceSpecial(idsRulesFilter, szFilter, sizeof(szFilter));
    AthLoadString(idsDefRulesExt, szDefExt, sizeof(szDefExt));
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
    
    hr = HrAthGetFileName(&ofn, TRUE);
    if (S_OK != hr)
    {
        goto exit;
    }
    
    hr = CreateStreamOnHFile(szFilename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pIStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // MAke sure we have a file using our Rules Manager
    hr = pIStm->Read(&clsid, sizeof(clsid), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(clsid));
    
    if (clsid != CLSID_OERulesManager)
    {
        Assert("Ahhhhh This is a bogus file!!!!!");
        hr = E_FAIL;
        goto exit;
    }

    // Read in the version of the rules file format
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(dwData));

    // Check the file format version
    if (dwData != RULE_FILE_VERSION)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesErrBadFileFormat), NULL, MB_ICONINFORMATION | MB_OK);
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the count of rules in the file
    hr = pIStm->Read(&cRules, sizeof(cRules), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(cRules));

    // Allocate space to hold all of the rules
    hr = HrAlloc((void **) &pinfoRule, cRules * sizeof(*pinfoRule));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pinfoRule, cRules * sizeof(*pinfoRule));
    
    // Get the type of rules in the file
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(dwData));

    type = (RULE_TYPE) dwData;
    
    // Set up the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cRules, 0, TRUE, FALSE);

    // Show progress in 2 second
    pProgress->Show(0);
        
    for (ulIndex = 0; ulIndex < cRules; ulIndex++)
    {
        SafeRelease(pIRule);
        
        // Create a new rule
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        SafeRelease(pIPStm);

        // Get the persistance interface from the rule
        hr = pIRule->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
        if (FAILED(hr))
        {
            continue;
        }

        // Load in the rule from the file
        hr = pIPStm->Load(pIStm);
        if (FAILED(hr))
        {
            continue;
        }
        
        // Add the rule to the list
        pinfoRule[ulIndex].ridRule = RULEID_INVALID;
        pinfoRule[ulIndex].pIRule = pIRule;
        pIRule = NULL;
        
        // Bump up the progress dialog
        hr = pProgress->HrUpdate(1);
        if (S_OK != hr)
        {
            break;
        }        
    }

    // Add the rules to the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->SetRules(SETF_APPEND, type, pinfoRule, cRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    SafeRelease(pIPStm);
    if (NULL != pinfoRule)
    {
        for (ulIndex = 0; ulIndex < cRules; ulIndex++)
        {
            SafeRelease(pinfoRule[ulIndex].pIRule);
        }
        MemFree(pinfoRule);
    }
    SafeRelease(pIStm);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrExportRules
//
//  This exports the rules into a file
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrExportRules(HWND hwnd)
{
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn;
    CHAR                szFilename[MAX_PATH] = _T("");
    CHAR                szFilter[MAX_PATH] = _T("");
    CHAR                szDefExt[20] = _T("");
    IStream *           pIStm = NULL;
    ULONG               cbWritten = 0;
    IOEEnumRules *      pIEnumRules = NULL;
    ULONG               cpIRule = 0;
    IPersistStream *    pIPStm = NULL;
    CProgress *         pProgress = NULL;
    ULONG               ulIndex = 0;
    IOERule *           pIRule = NULL;
    LARGE_INTEGER       liSeek = {0};
    DWORD               dwData = 0;
    
    // Load Res Strings
    LoadStringReplaceSpecial(idsRulesFilter, szFilter, sizeof(szFilter));
    AthLoadString(idsDefRulesExt, szDefExt, sizeof(szDefExt));
    AthLoadString(idsRulesDefFile, szFilename, sizeof(szFilename));
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    
    hr = HrAthGetFileName(&ofn, FALSE);
    if (S_OK != hr)
    {
        goto exit;
    }
    
    hr = CreateStreamOnHFile(szFilename, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &pIStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write out the class id for the Rules Manager
    hr = pIStm->Write(&CLSID_OERulesManager, sizeof(CLSID_OERulesManager), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(CLSID_OERulesManager));

    // Write out the version of the rules format
    dwData = RULE_FILE_VERSION;
    hr = pIStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Get the list of rules
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->EnumRules(ENUMF_EDIT, RULE_TYPE_MAIL, &pIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the total number of rules
    cpIRule = 0;
    while (S_OK == pIEnumRules->Next(1, &pIRule, NULL))
    {
        cpIRule++;
        SafeRelease(pIRule);
    }

    hr = pIEnumRules->Reset();
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the number of rules going to be exported
    hr = pIStm->Write(&cpIRule, sizeof(cpIRule), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(cpIRule));
    
    // Write out the type of rules going to be exported
    dwData = RULE_TYPE_MAIL;
    hr = pIStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Set up the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cpIRule, 0, TRUE, FALSE);

    // Show progress in 2 seconds
    pProgress->Show(0);
        
    for (ulIndex = 0; ulIndex < cpIRule; ulIndex++)
    {
        // Get the next rule
        SafeRelease(pIRule);
        hr = pIEnumRules->Next(1, &pIRule, NULL);
        if (FAILED(hr))
        {
            continue;
        }
        Assert(S_OK == hr);
        
        SafeRelease(pIPStm);
        if (FAILED(pIRule->QueryInterface(IID_IPersistStream, (void **) &pIPStm)))
        {
            continue;
        }

        if (FAILED(pIPStm->Save(pIStm, FALSE)))
        {
            continue;
        }
        
        // Update progress
        if (S_OK != pProgress->HrUpdate(1))
        {
            // Change the rule count to the proper total
            liSeek.QuadPart = sizeof(CLSID_OERulesManager);
            if (SUCCEEDED(pIStm->Seek(liSeek, STREAM_SEEK_SET, NULL)))
            {
                ulIndex++;
                SideAssert(SUCCEEDED(pIStm->Write(&ulIndex, sizeof(ulIndex), &cbWritten)));
                Assert(cbWritten == sizeof(ulIndex));
            }
            break;
        }        
    }

    hr = S_OK;
    
exit:
    SafeRelease(pIPStm);
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    SafeRelease(pIEnumRules);
    SafeRelease(pIStm);
    return hr;
}

typedef struct _tagFOLDERIDMAP
{
    FOLDERID   dwFldIdOld;
    FOLDERID   dwFldIdNew;
} FOLDERIDMAP, * PFOLDERIDMAP;

HRESULT RuleUtil_HrMapFldId(DWORD dwFlags, BYTE * pbFldIdMap, FOLDERID fldidOld, FOLDERID * pfldidNew)
{
    HRESULT         hr = S_OK;
    ULONG           cmpfldid = 0;
    FOLDERIDMAP *   pmpfldid;
    ULONG           ulIndex = 0;

    // Verify incoming params
    if ((NULL == pbFldIdMap) || (FOLDERID_INVALID == fldidOld) || (NULL == pfldidNew))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the outgoing param
    *pfldidNew = FOLDERID_INVALID;

    cmpfldid = *((DWORD *) pbFldIdMap);

    if (0 == cmpfldid)
    {
        goto exit;
    }

    pmpfldid = (FOLDERIDMAP *) (pbFldIdMap + sizeof(cmpfldid));

    for (ulIndex = 0; ulIndex < cmpfldid; ulIndex++)
    {
        if (fldidOld == pmpfldid[ulIndex].dwFldIdOld)
        {
            *pfldidNew = pmpfldid[ulIndex].dwFldIdNew;
            break;
        }
    }
    
    // Set the return value
    hr = (FOLDERID_INVALID != *pfldidNew) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrGetUserData(DWORD dwFlags, LPSTR * ppszFirstName, LPSTR * ppszLastName, LPSTR * ppszCompanyName)
{
    HRESULT         hr = S_OK;
    LPWAB           pWab = NULL;
    LPWABOBJECT     pWabObj = NULL;
    SBinary         sbEID = {0};
    IAddrBook *     pIAddrBook = NULL;
    ULONG           ulObjType = 0;
    IMailUser *     pIMailUser = NULL;
    SizedSPropTagArray(3, ptaDefMailUser) = {3, {PR_GIVEN_NAME_A, PR_SURNAME_A, PR_COMPANY_NAME_A}};
    ULONG           cProps = 0;
    LPSPropValue    pProps = NULL;
    LPSPropValue    pPropsWalk = NULL;
    
    if ((NULL == ppszFirstName) || (NULL == ppszLastName) || (NULL == ppszCompanyName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppszFirstName = NULL;
    *ppszLastName = NULL;
    *ppszCompanyName = NULL;

    // Get Wab object
    hr = HrCreateWabObject(&pWab);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWab->HrGetWabObject(&pWabObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWab->HrGetAdrBook(&pIAddrBook);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we already have a concept of me?
    hr = pWabObj->GetMe(pIAddrBook, AB_NO_DIALOG | WABOBJECT_ME_NOCREATE, NULL, &sbEID, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Open the entry
    hr = pIAddrBook->OpenEntry(sbEID.cb, (ENTRYID *)(sbEID.lpb), NULL, 0, &ulObjType, (IUnknown **) &pIMailUser);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the relevant info
    hr = pIMailUser->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &cProps, &pProps);
    if (FAILED(hr))
    {
        goto exit;
    }

    pPropsWalk = pProps;
    
    // Grab the first name if it exists
    if ((PR_GIVEN_NAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszFirstName = PszDupA(pPropsWalk->Value.lpszA);
    }

    pPropsWalk++;
    
    // Grab the last name if it exists
    if ((PR_SURNAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszLastName = PszDupA(pPropsWalk->Value.lpszA);
    }

    pPropsWalk++;
    
    // Grab the company name if it exists
    if ((PR_COMPANY_NAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszCompanyName = PszDupA(pPropsWalk->Value.lpszA);
    }

    hr = S_OK;
    
exit:
    SafeRelease(pIMailUser);
    if (NULL != pWabObj)
    {
        if (NULL != pProps)
        {
            pWabObj->FreeBuffer(pProps);
        }
        
        if (NULL != sbEID.lpb)
        {
            pWabObj->FreeBuffer(sbEID.lpb);
        }
    }
    SafeRelease(pWab);
    return hr;
}

HRESULT _HrMarkThreadAsWatched(MESSAGEID idMessage, IMessageFolder * pFolder, ADJUSTFLAGS * pflgWatch)
{
    HRESULT             hr = S_OK;
    MESSAGEINFO         infoMessage = {0};

    // Check incoming param
    if ((MESSAGEID_INVALID == idMessage) || (NULL == pFolder) || (NULL == pflgWatch))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the message info
    hr = GetMessageInfo(pFolder, idMessage, &infoMessage);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Add Flags
    FLAGSET(infoMessage.dwFlags, pflgWatch->dwAdd);

    // ClearFlags
    FLAGCLEAR(infoMessage.dwFlags, pflgWatch->dwRemove);

    // Update the Message
    IF_FAILEXIT(hr = pFolder->UpdateRecord(&infoMessage));

    // Set the return value
    hr = S_OK;
    
exit:
    pFolder->FreeRecord(&infoMessage);
    return hr;
}

HRESULT RuleUtil_HrApplyActions(HWND hwndUI, IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                                IMessageFolder * pFolder, IMimeMessage * pIMMsg, DWORD dwDeleteFlags,
                                ACT_ITEM * pActions, ULONG cActions, ULONG * pcInfiniteLoops, BOOL *pfDeleteOffServer)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    FOLDERID            idFolder = 0;
    ACT_ITEM *          pActionsList = NULL;
    IMessageFolder *    pFolderNew = NULL;
    MESSAGEIDLIST       List = {0};
    ADJUSTFLAGS         Flags = {0};
    DWORD               dwType = RFT_HTML;
    IStream *           pIStm = NULL;
    LPSTR               pszExt = NULL;
    BOOL                fLoop = FALSE;
    DWORD               dwFlag = 0;
    FOLDERID            idFolderJunkMail = FOLDERID_INVALID;
    RULEFOLDERDATA *    prfdData = NULL;
    BOOL                fSetFlags = FALSE;
    DWORD               dwFlagRemove = 0;
    BOOL                fDoWatch = FALSE;
    ADJUSTFLAGS         WatchFlags = {0};
    
    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pMsgInfo) || (NULL == pActions) || (NULL == pFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Init
    if (pfDeleteOffServer)
        *pfDeleteOffServer = FALSE;
    
    // Initialize the list
    List.cMsgs = 1;
    List.prgidMsg = &(pMsgInfo->idMessage);
    
    // Get the folder id of the message
    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Do all modification operations first
    for (pActionsList = pActions, ulIndex = 0; ulIndex < cActions; ulIndex++, pActionsList++)
    {
        switch(pActionsList->type)
        {
        case ACT_TYPE_HIGHLIGHT:
            Assert(pActionsList->propvar.vt == VT_UI4);
            // Is there something to do?
            if (pMsgInfo->wHighlight != (WORD) (pActionsList->propvar.ulVal))
            {
                pMsgInfo->wHighlight = (WORD) (pActionsList->propvar.ulVal);
                pFolder->UpdateRecord(pMsgInfo);
            }
            break;
            
        case ACT_TYPE_WATCH:
            Assert(pActionsList->propvar.vt == VT_UI4);
            // Is there something to do?
            if (ACT_DATA_WATCHTHREAD == pActions[ulIndex].propvar.ulVal)
            {
                dwFlag = ARF_WATCH;
                dwFlagRemove = ARF_IGNORE;
            }
            else
            {
                Assert(ACT_DATA_IGNORETHREAD == pActions[ulIndex].propvar.ulVal);
                dwFlag = ARF_IGNORE;
                dwFlagRemove = ARF_WATCH;
            }
            
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & dwFlag))
            {
                // Init flags
                WatchFlags.dwAdd |= dwFlag;
                WatchFlags.dwRemove |= dwFlagRemove;
                
                // Mark as watched/ignored
                fDoWatch = TRUE;
            }
            break;
            
        case ACT_TYPE_FLAG:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_FLAGGED))
            {
                // Init flags
                Flags.dwAdd |= ARF_FLAGGED;
                
                // Flag the message
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_READ:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_READ))
            {
                // Init flags
                Flags.dwAdd |= ARF_READ;
                Flags.dwRemove = 0;
                
                // Mark as read
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_MARKDOWNLOAD:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_DOWNLOAD))
            {
                // Init flags
                Flags.dwAdd |= ARF_DOWNLOAD;
                Flags.dwRemove = 0;
                
                // Mark as downloaded
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_FWD:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            SafeRelease(pIStm);
            // Check message secure or not
            if(NULL != pIMMsg)
            {
                pIMMsg->GetFlags(&dwFlag);
                
                // Get the message source
                if (!(IMF_SECURE & dwFlag) &&
                    (SUCCEEDED(pIMMsg->GetMessageSource(&pIStm, 0))))
                {
                    // Auto Forward
                    fLoop = FALSE;
                    if ((FAILED(_HrAutoForwardMessage(hwndUI, pActionsList->propvar.pszVal,
                        pMsgInfo->pszAcctId, pIStm, &fLoop))) && (FALSE != fLoop))
                    {
                        if (NULL != pcInfiniteLoops)
                        {
                            (*pcInfiniteLoops)++;
                        }
                    }
                    else
                    {
                        // Is there something to do?
                        if (0 == (pMsgInfo->dwFlags & ARF_FORWARDED))
                        {
                            // Init flags
                            Flags.dwAdd |= ARF_FORWARDED;
                            Flags.dwRemove = 0;
                            
                            // Mark as forwarded
                            fSetFlags = TRUE;
                        }
                    }
                }
            }
            break;
            
        case ACT_TYPE_REPLY:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            // Auto Reply
            fLoop = FALSE;
            SafeRelease(pIStm);
            if (SUCCEEDED(pIExecRules->GetRuleFile(pActionsList->propvar.pszVal, &pIStm, &dwType)))
            {
                if ((FAILED(_HrAutoReplyMessage(hwndUI, dwType, pActionsList->propvar.pszVal, pIStm,
                    pMsgInfo->pszAcctId, pIMMsg, &fLoop))) && (FALSE != fLoop))
                {
                    if (NULL != pcInfiniteLoops)
                    {
                        (*pcInfiniteLoops)++;
                    }
                }
                else
                {
                    // Is there something to do?
                    if (0 == (pMsgInfo->dwFlags & ARF_REPLIED))
                    {
                        // Init flags
                        Flags.dwAdd |= ARF_REPLIED;
                        Flags.dwRemove = 0;
                        
                        // Mark as replied
                        fSetFlags = TRUE;
                    }
                }
            }
            break;
        }
    }
    
    // Should we set the flags?
    if (FALSE != fSetFlags)
    {
        SetMessageFlagsProgress(hwndUI, pFolder, &Flags, &List);
    }
    
    // Should we watch the message?
    if (FALSE != fDoWatch)
    {
        _HrMarkThreadAsWatched(pMsgInfo->idMessage, pFolder, &WatchFlags);
    }
    
    // Do all non-modification operations next
    for (pActionsList = pActions, ulIndex = 0; ulIndex < cActions; ulIndex++, pActionsList++)
    {
        switch(pActionsList->type)
        {
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            Assert(VT_BLOB == pActionsList->propvar.vt);
            
            if (0 == pActionsList->propvar.blob.cbSize)
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pActionsList->propvar.blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Is there something to do?
            if (idFolder != prfdData->idFolder)
            {
                hr = pIExecRules->GetRuleFolder(prfdData->idFolder, (DWORD_PTR *) (&pFolderNew));
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Move/copy the messages
                CopyMessagesProgress(hwndUI, pFolder, pFolderNew,
                    (pActionsList->type != ACT_TYPE_COPY) ? COPY_MESSAGE_MOVE : NOFLAGS,
                    &List, NULL);
            }
            break;
            
        case ACT_TYPE_NOTIFYMSG:
            // Nothing to do for now
            break;
            
        case ACT_TYPE_NOTIFYSND:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            hr = pIExecRules->AddSoundFile(ASF_PLAYIFNEW, pActionsList->propvar.pszVal);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case ACT_TYPE_DELETE:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            DeleteMessagesProgress(hwndUI, pFolder, dwDeleteFlags | DELETE_MESSAGE_NOPROMPT, &List);
            break;
            
        case ACT_TYPE_JUNKMAIL:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            
            // Get the Junk Mail folder id, if we don't already have it
            if (FOLDERID_INVALID == idFolderJunkMail)
            {
                FOLDERINFO Folder;
                
                hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_JUNK, &Folder);
                if (FAILED(hr))
                {
                    goto exit;;
                }
                
                idFolderJunkMail = Folder.idFolder;
                
                g_pStore->FreeRecord(&Folder);
            }
            
            hr = pIExecRules->GetRuleFolder(idFolderJunkMail, (DWORD_PTR *) (&pFolderNew));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Move the messages
            CopyMessagesProgress(hwndUI, pFolder, pFolderNew, COPY_MESSAGE_MOVE, &List, NULL);
            break;
            
        case ACT_TYPE_DELETESERVER:
            if (pfDeleteOffServer)
                *pfDeleteOffServer = TRUE;
            break;
            
        case ACT_TYPE_DONTDOWNLOAD:
            // Nothing to do for now
            break;
            
        case ACT_TYPE_STOP:
            // Nothing to do for now
            break;
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIStm);
    return hr;
}

HRESULT RuleUtil_HrCreateSendersRule(DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    PROPVARIANT propvar = {0};
    TCHAR       szRes[CCHMAX_STRINGRES];
    ACT_ITEM    aitem;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the list
    *ppIRule = NULL;

    // Create the new rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the name
    if (0 != LoadString(g_hLocRes, idsBlockSender, szRes, ARRAYSIZE(szRes)))
    {
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szRes;
        
        // Set the name
        hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
        ZeroMemory(&propvar, sizeof(propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the normal action
    ZeroMemory(&aitem, sizeof(aitem));
    aitem.type = ACT_TYPE_DELETE;
    aitem.dwFlags = ACT_FLAG_DEFAULT;
    
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) &aitem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppIRule  = pIRule;
    pIRule = NULL;

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrLoadSender
//
//  This creates the sender rule
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrLoadSender(LPCSTR pszRegPath, DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    LONG        lErr = ERROR_SUCCESS;
    DWORD       dwData = 0;
    ULONG       cbData = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    IOERule *   pIRule = NULL;

    Assert(NULL != pszRegPath);
    Assert(NULL != ppIRule);
    
    // Let's get access to the sender root key
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    // If we don't have it saved, then we're done
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Make sure we have a name
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRuleName, 0, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Do we have to set the name?
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        // Get the name
        if (0 == LoadString(g_hLocRes, idsBlockSender, szRes, ARRAYSIZE(szRes)))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Set the name
        lErr = RegSetValueEx(hkeyRoot, c_szRuleName, 0, REG_SZ, (BYTE *) szRes, lstrlen(szRes) + 1);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // Create the rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load in the rule
    hr = pIRule->LoadReg(pszRegPath);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppIRule = pIRule;
    pIRule = NULL;
    
    // Set the return value
    hr = S_OK;
    
exit:    
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_FMatchSender
//
//  This match the sender to the message
//
//
//  Returns:    S_OK, if it was in the sender of the message
//              S_FALSE, if it was not the sender of the message
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrMatchSender(LPCSTR pszSender, MESSAGEINFO * pMsgInfo,
                        IMimeMessage * pIMMsg, IMimePropertySet * pIMPropSet)
{
    HRESULT             hr = S_OK;
    LPSTR               pszAddr = NULL;
    ADDRESSPROPS        rSender = {0};
    IMimeAddressTable * pIAddrTable = NULL;
    BOOL                fMatch = FALSE;
    ULONG               cchVal = 0;
    ULONG               cchEmail = 0;
    CHAR                chTest = 0;

    // Do we have good values
    if ((NULL == pszSender) || ((NULL == pMsgInfo) && (NULL == pIMMsg) && (NULL == pIMPropSet)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Check to make sure that there's something to match
    if ('\0' == pszSender[0])
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the address
    if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszEmailFrom))
    {
        pszAddr = pMsgInfo->pszEmailFrom;
    }
    else if (NULL != pIMMsg)
    {
        rSender.dwProps = IAP_EMAIL;
        if (SUCCEEDED(pIMMsg->GetSender(&rSender)))
        {
            pszAddr = rSender.pszEmail;
        }
    }
    else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pIAddrTable))))
    {
        rSender.dwProps = IAP_EMAIL;
        if (SUCCEEDED(pIAddrTable->GetSender(&rSender)))
        {
            pszAddr = rSender.pszEmail;
        }

        pIAddrTable->Release();
    }

    // Did we find anything?
    if (NULL == pszAddr)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Check to see if it is an address
    if (NULL != StrStrI(pszSender, "@"))
    {
        fMatch = (0 == lstrcmpi(pszSender, pszAddr));
    }
    else
    {
        cchVal = lstrlen(pszSender);
        cchEmail = lstrlen(pszAddr);
        if (cchVal <= cchEmail)
        {
            fMatch = (0 == lstrcmpi(pszSender, pszAddr + (cchEmail - cchVal)));
            if ((FALSE != fMatch) && (cchVal != cchEmail))
            {
                chTest = *(pszAddr + (cchEmail - cchVal - 1));
                if (('@' != chTest) && ('.' != chTest))
                {
                    fMatch = FALSE;
                }
            }
        }
    }

    // Set the proper return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    g_pMoleAlloc->FreeAddressProps(&rSender);
    return hr;
}

HRESULT RuleUtil_HrValidateRuleFolderData(RULEFOLDERDATA * prfdData)
{
    HRESULT         hr = S_OK;
    STOREUSERDATA   UserData = {0};

    // Check incoming params
    if (NULL == prfdData)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Get the timestamp for the store
    hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
    if (FAILED(hr))
    {
        goto exit;
    }
        
    // Is the stamp correct
    if ((UserData.ftCreated.dwLowDateTime != prfdData->ftStamp.dwLowDateTime) ||
            (UserData.ftCreated.dwHighDateTime != prfdData->ftStamp.dwHighDateTime))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;

exit:
    return hr;
}       

///////////////////////////////////////////////////////////////////////////////
//
//  _HrSetDefaultCriteria
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrSetDefaultCriteria(IOERule * pIRule, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    CRIT_ITEM   rgCritItem[CDEF_CRIT_ITEM_MAX];
    ULONG       cCritItem = 0;
    
    Assert(NULL != pIRule);
    Assert(NULL != pdefRule);

    // Initialize the criteria
    ZeroMemory(rgCritItem, sizeof(*rgCritItem) * CDEF_CRIT_ITEM_MAX);
    
    // Set the criteria
    switch (pdefRule->critType)
    {
        case DEF_CRIT_ALLMSGS:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_ALL;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;

        case DEF_CRIT_READ:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_READ;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;
            
        case DEF_CRIT_DWNLDMSGS:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_DOWNLOADED;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;
    
        case DEF_CRIT_IGNTHDS:
            cCritItem = 2;
            rgCritItem[0].type = CRIT_TYPE_THREADSTATE;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_UI4;
            rgCritItem[0].propvar.ulVal = CRIT_DATA_IGNORETHREAD;
            rgCritItem[0].logic = CRIT_LOGIC_OR;
            rgCritItem[1].type = CRIT_TYPE_READ;
            rgCritItem[1].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[1].propvar.vt = VT_EMPTY;
            rgCritItem[1].logic = CRIT_LOGIC_NULL;
            break;
    
        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Set the rule criteria
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) rgCritItem;
    
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrSetDefaultActions
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrSetDefaultActions(IOERule * pIRule, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    ACT_ITEM    rgActItem[CDEF_ACT_ITEM_MAX];
    ULONG       cActItem = 0;
    
    Assert(NULL != pIRule);
    Assert(NULL != pdefRule);

    // Initialize the actions
    ZeroMemory(rgActItem, sizeof(*rgActItem) * CDEF_ACT_ITEM_MAX);
    
    // Set the actions
    switch (pdefRule->actType)
    {
        case DEF_ACT_SHOWMSGS:
            cActItem = 1;
            rgActItem[0].type = ACT_TYPE_SHOW;
            rgActItem[0].dwFlags = ACT_FLAG_DEFAULT;
            rgActItem[0].propvar.vt = VT_UI4;
            rgActItem[0].propvar.ulVal = ACT_DATA_SHOW;
            break;

        case DEF_ACT_HIDEMSGS:
            cActItem = 1;
            rgActItem[0].type = ACT_TYPE_SHOW;
            rgActItem[0].dwFlags = ACT_FLAG_DEFAULT;
            rgActItem[0].propvar.vt = VT_UI4;
            rgActItem[0].propvar.ulVal = ACT_DATA_HIDE;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Set the rule actions
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) rgActItem;
    
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrUpdateDefaultRule
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrUpdateDefaultRule(LPCSTR pszRegPath, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    TCHAR       szFullPath[CCHMAX_STRINGRES];
    TCHAR       szName[CCHMAX_STRINGRES];
    PROPVARIANT propvar = {0};
    
    Assert(NULL != pszRegPath);
    Assert(NULL != pdefRule);

    // Whip up a rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the rule path
    if(lstrlen(pszRegPath) >= sizeof(szFullPath) / sizeof(szFullPath[0]))
    {
        hr = E_FAIL;
        goto exit;
    }

    StrCpyN(szFullPath, pszRegPath, ARRAYSIZE(szFullPath));
    StrCatBuff(szFullPath, g_szBackSlash, ARRAYSIZE(szFullPath));
    wnsprintf(szFullPath + lstrlen(szFullPath), (ARRAYSIZE(szFullPath) - lstrlen(szFullPath)), "%03X", pdefRule->ridRule);
    
    // Do we need to do anything?
    hr = pIRule->LoadReg(szFullPath);
    if (SUCCEEDED(hr))
    {
        // Get the version from the rule
        hr = pIRule->GetProp(RULE_PROP_VERSION, 0, &propvar);
        if (SUCCEEDED(hr))
        {
            Assert(VT_UI4 == propvar.vt);
            // Is the rule too old?
            if (pdefRule->dwVersion <= propvar.ulVal)
            {
                //Bug# 67782
                //We reload the name of the string every time in case, a localized version of OE is installed.
                if (SUCCEEDED(hr = RuleUtil_SetName(pIRule, pdefRule->idName)))
                {
                    if (SUCCEEDED(pIRule->SaveReg(szFullPath, TRUE)))
                        hr = S_FALSE;
                }
                goto exit;
            }
        }
    }

    //Bug# 67782
    //We reload the name of the string every time in case, a localized version of OE is installed.
    hr = RuleUtil_SetName(pIRule, pdefRule->idName);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule version
    propvar.vt = VT_UI4;
    propvar.ulVal = pdefRule->dwVersion - 1;
    
    hr = pIRule->SetProp(RULE_PROP_VERSION, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule criteria
    hr = _HrSetDefaultCriteria(pIRule, pdefRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule actions
    hr = _HrSetDefaultActions(pIRule, pdefRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the rule
    hr = pIRule->SaveReg(szFullPath, TRUE);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    return hr;
}

HRESULT RuleUtil_SetName(IOERule    *pIRule, int idRes)
{
    HRESULT     hr = S_OK;
    TCHAR       szName[CCHMAX_STRINGRES];
    PROPVARIANT propvar = {0};

    if (0 == AthLoadString(idRes, szName, ARRAYSIZE(szName)))
    {
        hr = E_FAIL;
        goto exit;
    }
        
    // Set the rule name
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;
    
    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

exit:
    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrUpdateDefaultRules
//
//  This updates the default rules for the specified rule type
//  when the version in the registry is older than the current
//  version
//
//  Returns:    S_OK, if it was rules were successfully updated
//              S_FALSE, if the rules were already at the correct version
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrUpdateDefaultRules(RULE_TYPE typeRule)
{
    HRESULT                 hr = S_OK;
    LPCSTR                  pszSubKey = NULL;
    LONG                    lErr = ERROR_SUCCESS;
    HKEY                    hkeyRoot = NULL;
    DWORD                   dwData = 0;
    ULONG                   cbData = 0;
    const DEFAULT_RULE *    pdefrule = NULL;
    ULONG                   cpdefrule = 0;
    LPCSTR                  pszOrderDef = NULL;
    ULONG                   ulIndex = 0;
    
    // If we're already loaded then
    // there's nothing to do
    switch(typeRule)
    {
        case RULE_TYPE_FILTER:
            pszSubKey = c_szRulesFilter;
            pdefrule = g_defruleFilters;
            cpdefrule = ARRAYSIZE(g_defruleFilters);
            pszOrderDef = g_szOrderFilterDef;
            break;
            
        default:
            // Nothing to do..
            hr = S_FALSE;
            goto exit;
    }
    
    // Check to see if the Rule node already exists
    lErr = AthUserOpenKey(pszSubKey, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the current version
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, NULL, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    Assert(RULESMGR_VERSION == dwData);

    // Update out the default rules
    for (ulIndex = 0; ulIndex < cpdefrule; ulIndex++, pdefrule++)
    {
        hr = _HrUpdateDefaultRule(pszSubKey, pdefrule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Write out the default order
    if (NULL != pszOrderDef)
    {
        // If the order already exists, then leave it alone
        lErr = RegQueryValueEx(hkeyRoot, c_szRulesOrder, NULL, NULL, NULL, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            lErr = RegSetValueEx(hkeyRoot, c_szRulesOrder, 0,
                                REG_SZ, (CONST BYTE *) pszOrderDef, lstrlen(pszOrderDef) + 1);
            if (ERROR_SUCCESS != lErr)
            {
                hr = HRESULT_FROM_WIN32(lErr);
                goto exit;
            }
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

//--------------------------------------------------------------------------
// RuleUtil_HrGetFilterVersion
//--------------------------------------------------------------------------
HRESULT RuleUtil_HrGetFilterVersion(RULEID ridFilter, DWORD * pdwVersion)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    PROPVARIANT propvar = {0};
    
    TraceCall("_GetFilterVersion");

    Assert(NULL != pdwVersion);

    // Is there something to do
    if (RULEID_INVALID == ridFilter)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the outgoing param
    *pdwVersion = 0;

    // Get the rule from the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the version from the rule
    hr = pIRule->GetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing param
    Assert(VT_UI4 == propvar.vt);
    *pdwVersion = propvar.ulVal;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIRule);
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteClause
//--------------------------------------------------------------------------
HRESULT _HrWriteClause(IStream * pStm, ULONG cClauses, BOOL fAnd, LPCSTR pszClause)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszLogic = NULL;

    // Do we have something to write
    if (NULL != pszClause)
    {
        // Add the proper logical operation
        if (cClauses > 0)
        {
            if (FALSE != fAnd)
            {
                pszLogic = c_szLogicalAnd;
            }
            else
            {
                pszLogic = c_szLogicalOr;
            }
            
            // Write Logical And
            IF_FAILEXIT(hr = pStm->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Write out the clause
        IF_FAILEXIT(hr = pStm->Write(pszClause, lstrlen(pszClause), NULL));

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteFromClause
//--------------------------------------------------------------------------
HRESULT _HrWriteFromClause(IStream * pStream, ULONG cClauses, BOOL fAnd, DWORD dwFlags, LPCSTR pszText, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    ULONG       cClausesOld = 0;
    LPCSTR      pszLogic = NULL;
    LPCTSTR     pszContains = NULL;

    Assert(pStream && pszText && pcClausesNew);
    
    // Add the proper logical operation
    if (cClauses > 0)
    {
        if (FALSE != fAnd)
        {
            pszLogic = c_szLogicalAnd;
        }
        else
        {
            pszLogic = c_szLogicalOr;
        }
        
        // Write Logical And
        IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
    }

    // Figure out the logical operation
    if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        pszLogic = c_szLogicalAnd;
    }
    else
    {
        pszLogic = c_szLogicalOr;
    }
    
    // Write the proper comparison op
    if (0 == (dwFlags & CRIT_FLAG_INVERT))
    {
        pszContains = c_szFilterShow;
    }
    else
    {
        pszContains = c_szFilterHide;
    }
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Write Logical And
    IF_FAILEXIT(hr = pStream->Write(pszContains, lstrlen(pszContains), NULL));
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Add each of the addresses to the stream
    cClausesOld = cClauses;
    for (; '\0' != pszText[0]; pszText += lstrlen(pszText) + 1)
    {
        if ((cClauses - cClausesOld) > 0)
        {
            // Write Logical And
            IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Open the criteria
        IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));
        
        // Write (MSGCOL_EMAILFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(c_szEmailFromAddrPrefix, lstrlen(c_szEmailFromAddrPrefix), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Close the MSGCOL_EMAILFROM
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
        
        // Write Logical Or
        IF_FAILEXIT(hr = pStream->Write(c_szLogicalOr, lstrlen(c_szLogicalOr), NULL));
        
        // Write (MSGCOL_DISPLAYFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(c_szEmailFromPrefix, lstrlen(c_szEmailFromPrefix), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Close the MSGCOL_DISPLAYFROM
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
        
        // Close the criteria
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));

        cClauses++;
    }

    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Set the outgoing param
    *pcClausesNew = cClauses - cClausesOld;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteTextClause
//--------------------------------------------------------------------------
HRESULT _HrWriteTextClause(IStream * pStream, ULONG cClauses, BOOL fAnd, DWORD dwFlags, LPCSTR pszHeader, LPCSTR pszText, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    ULONG       cClausesOld = 0;
    LPCSTR      pszLogic = NULL;
    LPCTSTR     pszContains = NULL;

    Assert(pStream && pszText && pcClausesNew);

    // Add the proper logical operation
    if (cClauses > 0)
    {
        if (FALSE != fAnd)
        {
            pszLogic = c_szLogicalAnd;
        }
        else
        {
            pszLogic = c_szLogicalOr;
        }
        
        // Write Logical And
        IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
    }

    // Figure out the logical operation
    if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        pszLogic = c_szLogicalAnd;
    }
    else
    {
        pszLogic = c_szLogicalOr;
    }
    
    // Write the proper comparison op
    if (0 == (dwFlags & CRIT_FLAG_INVERT))
    {
        pszContains = c_szFilterShow;
    }
    else
    {
        pszContains = c_szFilterHide;
    }
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Write Logical And
    IF_FAILEXIT(hr = pStream->Write(pszContains, lstrlen(pszContains), NULL));
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Add each of the words to the stream
    cClausesOld = cClauses;
    for (; '\0' != pszText[0]; pszText += lstrlen(pszText) + 1)
    {
        if ((cClauses - cClausesOld) > 0)
        {
            // Write Logical And
            IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Write (MSGCOL_EMAILFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(pszHeader, lstrlen(pszHeader), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write Left Paren
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));

        cClauses++;
    }

    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Set the outgoing param
    *pcClausesNew = cClauses - cClausesOld;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteAccountClause
//--------------------------------------------------------------------------
HRESULT _HrWriteAccountClause(IStream * pStream, ULONG cClauses, BOOL fAnd, LPCSTR pszAcctId, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;

    Assert(pStream && pszAcctId && pcClausesNew);

    // Write the header 
    hr = _HrWriteClause(pStream, cClauses, fAnd, c_szEmailAcctPrefix);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write a Quote
    hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write the account ID
    hr = pStream->Write(pszAcctId, lstrlen(pszAcctId), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write a Quote
    hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Close the criteria query
    hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *pcClausesNew = 1;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteUlongClause
//--------------------------------------------------------------------------
HRESULT _HrWriteUlongClause(IStream * pStream, ULONG cClauses, BOOL fAnd, LPCSTR pszHeader, ULONG ulVal, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    CHAR        rgchBuff[10];

    Assert(pStream && pszHeader && pcClausesNew);

    // Write the header 
    hr = _HrWriteClause(pStream, cClauses, fAnd, pszHeader);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Convert the number to a string
    rgchBuff[0] = '\0';
    wnsprintf(rgchBuff, ARRAYSIZE(rgchBuff), "%d", ulVal);
    
    // Write the account ID
    hr = pStream->Write(rgchBuff, lstrlen(rgchBuff), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Close the criteria query
    hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *pcClausesNew = 1;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteClauseFromCriteria
//--------------------------------------------------------------------------
HRESULT _HrWriteClauseFromCriteria(CRIT_ITEM *pCritItem, ULONG cClauses, BOOL fAnd, BOOL fShow, IStream *pStm, ULONG * pcClausesNew)
{
    // Locals
    HRESULT     hr = S_OK;
    LPCSTR      pszClause = NULL;
    ULONG       cClausesNew = 0;
    
    // Trace
    TraceCall("WriteClauseFromCriteria");

    // Invalid Args
    Assert(pCritItem && pStm && pcClausesNew);

    // Do we have something to do?
    switch(pCritItem->type)
    {            
        case CRIT_TYPE_SUBJECT:      
            Assert(VT_BLOB == pCritItem->propvar.vt);
            hr = _HrWriteTextClause(pStm, cClauses, fAnd, pCritItem->dwFlags,
                            c_szEmailSubjectPrefix, (LPTSTR) (pCritItem->propvar.blob.pBlobData), &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:      
            Assert(VT_LPSTR == pCritItem->propvar.vt);
            hr = _HrWriteAccountClause(pStm, cClauses, fAnd, pCritItem->propvar.pszVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_FROM:      
            Assert(VT_BLOB == pCritItem->propvar.vt);
            hr = _HrWriteFromClause(pStm, cClauses, fAnd, pCritItem->dwFlags,
                            (LPTSTR) (pCritItem->propvar.blob.pBlobData), &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_PRIORITY:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_HIPRI:
                    pszClause = c_szFilterPriorityHi;
                    break;

                case CRIT_DATA_LOPRI:
                    pszClause = c_szFilterPriorityLo;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_ATTACH:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, c_szFilterAttach));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_READ:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotRead;
            }
            else
            {
                pszClause = c_szFilterRead;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_DOWNLOADED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotDownloaded;
            }
            else
            {
                pszClause = c_szFilterDownloaded;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_DELETED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotDeleted;
            }
            else
            {
                pszClause = c_szFilterDeleted;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_FLAGGED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotFlagged;
            }
            else
            {
                pszClause = c_szFilterFlagged;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_THREADSTATE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_IGNORETHREAD:
                    pszClause = c_szFilterIgnored;
                    break;

                case CRIT_DATA_WATCHTHREAD:
                    pszClause = c_szFilterWatched;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_LINES:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            hr = _HrWriteUlongClause(pStm, cClauses, fAnd, c_szEmailLinesPrefix, pCritItem->propvar.ulVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_AGE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            hr = _HrWriteUlongClause(pStm, cClauses, fAnd, c_szEmailAgePrefix, pCritItem->propvar.ulVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SECURE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_ENCRYPTSECURE:
                    pszClause = c_szFilterEncrypt;
                    break;

                case CRIT_DATA_SIGNEDSECURE:
                    pszClause = c_szFilterSigned;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_REPLIES:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotReplyPost;
            }
            else
            {
                pszClause = c_szFilterReplyPost;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_ALL:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (FALSE == fShow)
            {
                IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, c_szFilterShowAll));
                cClausesNew = 1;
            }
            break;
    }
    
    // Set the outgoing param
    *pcClausesNew = cClausesNew;
    
exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// _HrBuildQueryFromFilter
//--------------------------------------------------------------------------
HRESULT _HrBuildQueryFromFilter(CRIT_ITEM * pCritList, ULONG cCritList, BOOL fShow,
            LPSTR * ppszQuery, ULONG * pcchQuery,
            ULONG * pcClauses)
{
    HRESULT         hr = S_OK;
    BOOL            fAnd = FALSE;
    CByteStream     stmQuery;
    DWORD           cClauses = 0;
    ULONG           ulIndex = 0;
    LPSTR           pszQuery = NULL;
    ULONG           cchQuery = 0;
    BOOL            fUnread = FALSE;
    ULONG           cClausesNew = 0;

    Assert((NULL != ppszQuery) && (NULL != pcchQuery) && (NULL != pcClauses));
    
    // Initialize all outgoing params
    *ppszQuery = NULL;
    *pcchQuery = 0;
    *pcClauses = 0;
    
    // Figure out the logic op
    if (1 < cCritList)
    {
        fAnd = (CRIT_LOGIC_AND == pCritList->logic);
    }
    
    // Start the query string
    hr = stmQuery.Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the proper action
    if (FALSE == fShow)
    {
        // End the query string
        IF_FAILEXIT(hr = stmQuery.Write(c_szFilterHide, lstrlen(c_szFilterHide), NULL));
    }
    else
    {
        // End the query string
        IF_FAILEXIT(hr = stmQuery.Write(c_szFilterShow, lstrlen(c_szFilterShow), NULL));
    }
        
    // Start the criteria string
    hr = stmQuery.Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // For each of the criteria
    for (ulIndex = 0; ulIndex < cCritList; ulIndex++)
    {
        // Write out the clause
        hr = _HrWriteClauseFromCriteria(pCritList + ulIndex, cClauses, fAnd, fShow, &stmQuery, &cClausesNew);
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we did something
        if (S_OK == hr)
        {
            cClauses += cClausesNew;
        }
    }
    
    // Clauses
    if (cClauses > 0)
    {
        // End the criteria string
        hr = stmQuery.Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // End the query string
        hr = stmQuery.Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // Return the Query
        IF_FAILEXIT(hr = stmQuery.HrAcquireStringA(&cchQuery, &pszQuery, ACQ_DISPLACE));
    }

    // Set the outgoing param
    *ppszQuery = pszQuery;
    *pcchQuery = cchQuery;
    *pcClauses = cClauses;

    // Set the return value
    hr = S_OK;
    
exit:
    // Cleanup

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// RuleUtil_HrBuildQuerysFromFilter
//--------------------------------------------------------------------------
HRESULT RuleUtil_HrBuildQuerysFromFilter(RULEID ridFilter,
        QUERYINFO * pqinfoFilter)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritList = NULL;
    ULONG           cCritList = 0;
    ACT_ITEM *      pActList = NULL;
    ULONG           cActList = 0;
    DWORD           cClauses = 0;
    LPSTR           pszQuery = NULL;
    ULONG           cchQuery = 0;

    // Initialize
    ZeroMemory(pqinfoFilter, sizeof(pqinfoFilter));

    // Get the rule
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(NULL != pIRule);
    
    // Get criteria from filter
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(VT_BLOB == propvar.vt);

    // Save off the criteria list
    pCritList = (CRIT_ITEM *) propvar.blob.pBlobData;
    cCritList = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    Assert(cCritList * sizeof(CRIT_ITEM) == propvar.blob.cbSize);
    ZeroMemory(&propvar, sizeof(propvar));

    // Get actions from filter
    hr = pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(VT_BLOB == propvar.vt);
    
    // Save off the actions list
    pActList = (ACT_ITEM *) propvar.blob.pBlobData;
    cActList = propvar.blob.cbSize / sizeof(ACT_ITEM);
    Assert(cActList * sizeof(ACT_ITEM) == propvar.blob.cbSize);
    ZeroMemory(&propvar, sizeof(propvar));
    
    // Write out the proper action
    Assert(1 == cActList);
    Assert(ACT_TYPE_SHOW == pActList->type);
    Assert(VT_UI4 == pActList->propvar.vt);

    // Get the query string
    hr = _HrBuildQueryFromFilter(pCritList, cCritList, (ACT_DATA_SHOW == pActList->propvar.ulVal),
            &pszQuery, &cchQuery, &cClauses);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing param
    pqinfoFilter->pszQuery = pszQuery;
    pszQuery = NULL;
    pqinfoFilter->cchQuery = cchQuery;

    // Set the return value
    hr = S_OK;
    
exit:
    // Cleanup
    if (NULL != pActList)
    {
        RuleUtil_HrFreeActionsItem(pActList, cActList);
        MemFree(pActList);
    }
    if (NULL != pCritList)
    {
        RuleUtil_HrFreeCriteriaItem(pCritList, cCritList);
        MemFree(pCritList);
    }
    SafeRelease(pIRule);
    SafeMemFree(pszQuery);
    // Done
    return(hr);
}

typedef struct tagVIEWMENUMAP
{
    RULEID  ridFilter;
    DWORD   dwMenuID;
} VIEWMENUMAP, * PVIEWMENUMAP;

static const VIEWMENUMAP    g_vmmDefault[] =
{
    {RULEID_VIEW_ALL,           ID_VIEW_ALL},
    {RULEID_VIEW_UNREAD,        ID_VIEW_UNREAD},
    {RULEID_VIEW_DOWNLOADED,    ID_VIEW_DOWNLOADED},
    {RULEID_VIEW_IGNORED,       ID_VIEW_IGNORED}
};

static const int g_cvmmDefault = sizeof(g_vmmDefault) / sizeof(g_vmmDefault[0]);
static const int VMM_ALL = 0;
static const int VMM_UNREAD = 1;
static const int VMM_DOWNLOADED = 2;
static const int VMM_IGNORED = 3;

///////////////////////////////////////////////////////////////////////////////
//
//  HrCustomizeCurrentView
//
//  This creates a rules editor of the proper type.
//
//  hwnd        - The owner dialog
//  dwFlags     - What type of editor to bring up
//  ridFilter   - The current filter to customize
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCustomizeCurrentView(HWND hwnd, DWORD dwFlags, RULEID * pridFilter)
{
    HRESULT         hr = S_OK;
    CEditRuleUI *   pEditRuleUI = NULL;
    IOERule *       pIFilter = NULL;
    IOERule *       pIFilterNew = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    LPSTR           pszName = NULL;
    PROPVARIANT     propvar = {0};
    RULEINFO        infoRule = {0};
    DWORD           dwFlagsSet = 0;
    
    // Check incoming params
    if ((NULL == hwnd) || (NULL == pridFilter) || (RULEID_INVALID == *pridFilter))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a rule editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the filter
    hr = g_pRulesMan->GetRule(*pridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clone the rule
    hr = pIFilter->Clone(&pIFilterNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Is this filter a read only filter?
    if (FALSE != FIsFilterReadOnly(*pridFilter))
    {
        // Get the name from the source rule
        hr = pIFilterNew->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the string template to display
        cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            goto exit;
        }

        // Allocate space to hold the final display string
        DWORD cchSize = (cchRes + lstrlen(propvar.pszVal) + 1);
        hr = HrAlloc((void ** ) &pszName, cchSize);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Build up the string and set it
        wnsprintf(pszName, cchSize, szRes, propvar.pszVal);

        PropVariantClear(&propvar);
        propvar.vt = VT_LPSTR;
        propvar.pszVal = pszName;
        pszName = NULL;
        
        // Set the name into the new rule
        Assert(VT_LPSTR == propvar.vt);
        Assert(NULL != propvar.pszVal);
        hr = pIFilterNew->SetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Clear the version of the new rule
        PropVariantClear(&propvar);
        propvar.vt = VT_UI4;
        propvar.ulVal = 0;
        hr = pIFilterNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // Set the rule id to invalid
        *pridFilter = RULEID_INVALID;

        // Note that we want to append the rule
        dwFlagsSet = SETF_APPEND;
    }
    else
    {
        dwFlagsSet = SETF_REPLACE;
    }
    
    // Initialize the rule editor object
    hr = pEditRuleUI->HrInit(hwnd, ERF_CUSTOMIZEVIEW, RULE_TYPE_FILTER, pIFilterNew, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Did anything change
    if (S_OK == hr)
    {
        // Initialize the rule info
        infoRule.pIRule = pIFilterNew;
        infoRule.ridRule = *pridFilter;
        
        // Add the rule to the list of rules
        hr = g_pRulesMan->SetRules(dwFlagsSet, RULE_TYPE_FILTER, &infoRule, 1);
        if(FAILED(hr))
        {
            goto exit;
        }

        *pridFilter = infoRule.ridRule;
    }

exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszName);
    SafeRelease(pIFilterNew);
    SafeRelease(pIFilter);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return hr;
}

CViewMenu::~CViewMenu()
{
    if (NULL != m_pmruList)
    {
        delete m_pmruList;
    }
}

ULONG CViewMenu::AddRef(VOID)
{
    return ++m_cRef;
}

ULONG CViewMenu::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CViewMenu::HrInit(DWORD dwFlags)
{
    HRESULT         hr = S_OK;

    m_dwFlags = dwFlags;

    // Create the MRU list
    m_pmruList = new CMRUList;
    if (NULL == m_pmruList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_pmruList->CreateList(5, 0, c_szRulesFilterMRU);
    
    // Make sure the MRU list is up to date
    SideAssert(FALSE != _FValiadateMRUList());
        
    m_dwState |= STATE_INIT;

    hr = S_OK;

exit:
    return hr;
}

HRESULT CViewMenu::HrReplaceMenu(DWORD dwFlags, HMENU hmenu)
{
    HRESULT         hr = S_OK;
    HMENU           hmenuView = NULL;
    MENUITEMINFO    mii = {0};

    // Load in the real view menu
    hmenuView = LoadPopupMenu(IDR_VIEW_POPUP);
    if (NULL == hmenuView)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Add in the default views
    _AddDefaultViews(hmenuView);
    
    // Set the real view menu in
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    
    mii.hSubMenu = hmenuView;
    SetMenuItemInfo(hmenu, ID_POPUP_FILTER, FALSE, &mii);

    // Mark the menu as dirty
    m_dwState |= STATE_DIRTY;

    hr = S_OK;

exit:
    return hr;
}

HRESULT CViewMenu::UpdateViewMenu(DWORD dwFlags, HMENU hmenuView, IMessageList * pMsgList)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    ULONGLONG           ullFolder = 0;
    FOLDERID            idFolder = FOLDERID_INVALID;
    FOLDERINFO          infoFolder = {0};
    MENUITEMINFO        mii = {0};
    BOOL                fDeletedExists = FALSE;
    BOOL                fDownloadedExists = FALSE;
    BOOL                fRepliesExists = FALSE;
    CHAR                szName[CCHMAX_STRINGRES];

    // Check incoming params
    if (NULL == pMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Have we been initialized yet?
    if (0 == (m_dwState & STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we don't have a menu, we got problems
    if ((NULL == hmenuView) || (FALSE == IsMenu(hmenuView)))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the folder type from the list
    
    // Get the OE message list interface
    if (FAILED(pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList)))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the folder id from the list
    hr = pIMsgList->get_Folder(&ullFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    idFolder = (FOLDERID) ullFolder;

    // Get the folder info from the folder id
    Assert(NULL != g_pStore);
    hr = g_pStore->GetFolderInfo(idFolder, &infoFolder);
    if (FAILED(hr))
    {
        goto exit;
    }        
    
    // Figure out if we're supposed to remove/add IMAP specific menus
    
    // Initialize the menu info for searching
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA;

    // Does the ID_SHOW_DELETED menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_SHOW_DELETED, FALSE, &mii))
    {
        fDeletedExists = TRUE;
    }
    
    // Does the ID_SHOW_REPLIES menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_SHOW_REPLIES, FALSE, &mii))
    {
        fRepliesExists = TRUE;
    }
    
    // Does the ID_VIEW_DOWNLOADED menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_VIEW_DOWNLOADED, FALSE, &mii))
    {
        fDownloadedExists = TRUE;
    }
    
    // If the folder is not a LOCAL folder or it is a find folder and
    // the menu item item does not exist
    if (((FOLDER_LOCAL != infoFolder.tyFolder) || (0 != (m_dwFlags & VMF_FINDER)))&& (FALSE == fDownloadedExists))
    {
        // Insert the downloaded menu after the replies menu
        hr = _HrInsertViewMenu(hmenuView, g_vmmDefault[VMM_DOWNLOADED].ridFilter,
                            g_vmmDefault[VMM_DOWNLOADED].dwMenuID, ID_VIEW_IGNORED);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    // else if the folder is a LOCAL folder and not a find folder and
    // the menu item does exist
    else if ((FOLDER_LOCAL == infoFolder.tyFolder) && (0 == (m_dwFlags & VMF_FINDER)) && (FALSE != fDownloadedExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_VIEW_DOWNLOADED, MF_BYCOMMAND);
    }

    // If the folder is an NNTP folder and
    // the menu item item does not exist
    if ((FOLDER_NEWS == infoFolder.tyFolder) && (FALSE == fRepliesExists))
    {
        // Get the name of the deleted item string
        AthLoadString(idsViewReplies, szName, sizeof(szName));
        
        // Initialize the menu info
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_SHOW_REPLIES;
        mii.dwTypeData = szName;
        mii.cch = lstrlen(szName);

        // Insert the menu item
        if (FALSE == InsertMenuItem(hmenuView, ID_THREAD_MESSAGES, FALSE, &mii))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    // else if the folder is not an NNTP folder and
    // the menu item does exist
    else if ((FOLDER_NEWS != infoFolder.tyFolder) && (FALSE != fRepliesExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_SHOW_REPLIES, MF_BYCOMMAND);
    }

    // If the folder is an IMAP folder or a find folder and
    // the menu item item does not exist
    if (((FOLDER_IMAP == infoFolder.tyFolder) || (0 != (m_dwFlags & VMF_FINDER))) && (FALSE == fDeletedExists))
    {
        // Get the name of the deleted item string
        AthLoadString(idsShowDeleted, szName, sizeof(szName));
        
        // Initialize the menu info
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_SHOW_DELETED;
        mii.dwTypeData = szName;
        mii.cch = lstrlen(szName);

        // Insert the menu item
        if (FALSE == InsertMenuItem(hmenuView, ID_THREAD_MESSAGES, FALSE, &mii))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    // else if the folder is not an IMAP folder and not a Find folder and
    // the menu item does exist
    else if ((FOLDER_IMAP != infoFolder.tyFolder) && (0 == (m_dwFlags & VMF_FINDER)) && (FALSE != fDeletedExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_SHOW_DELETED, MF_BYCOMMAND);
    }

    // if we're dirty
    if (0 != (m_dwState & STATE_DIRTY))
    {
        // Load in the MRU filter list
        hr = _HrReloadMRUViewMenu(hmenuView);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Note that we've reloaded ourselves
        m_dwState &= ~STATE_DIRTY;
    }

    // See if we need to add the extra view menu
    hr = _HrAddExtraViewMenu(hmenuView, pIMsgList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pIMsgList);
    return hr;
}

HRESULT CViewMenu::QueryStatus(IMessageList * pMsgList, OLECMD  * prgCmds)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    BOOL                fThreading = FALSE;
    BOOL                fShowDeleted = FALSE;
    BOOL                fShowReplies = FALSE;
    MENUITEMINFO        mii = {0};
    CHAR                rgchFilterTag[CCH_FILTERTAG_MAX];
    ULONGLONG           ullFilter = 0;
    RULEID              ridFilter = RULEID_INVALID;
    RULEID              ridFilterTag = RULEID_INVALID;
    
    // Check incoming params
    if ((NULL == pMsgList) || (NULL == prgCmds))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the OE message list interface
    if (FAILED(pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList)))
    {
        hr = E_FAIL;
        goto exit;
    }
            
    // Get the current filter on the message list
    pIMsgList->get_FilterMessages(&ullFilter);
    ridFilter = (RULEID) ullFilter;
    
    // Set the flags on the correct menu item
    switch(prgCmds->cmdID)
    {
        case ID_VIEW_ALL:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_ALL].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_UNREAD:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_UNREAD].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_DOWNLOADED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_DOWNLOADED].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_IGNORED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_IGNORED].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_CURRENT:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (m_ridCurrent == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_RECENT_0:
        case ID_VIEW_RECENT_1:
        case ID_VIEW_RECENT_2:
        case ID_VIEW_RECENT_3:
        case ID_VIEW_RECENT_4:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            if (NULL != m_pmruList)
            {
                if (-1 == m_pmruList->EnumList(prgCmds->cmdID - ID_VIEW_RECENT_0, rgchFilterTag, ARRAYSIZE(rgchFilterTag)))
                {
                    break;
                }

                if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterTag))
                {
                    break;
                }
        
                // If this filter is turned on, make sure the item is checked
                if (ridFilterTag == ridFilter)
                {
                    prgCmds->cmdf |= OLECMDF_NINCHED;
                }
            }
            break;
            
        case ID_VIEW_APPLY:
        case ID_VIEW_CUSTOMIZE:
        case ID_VIEW_MANAGER:
            // If we have a Rules Manager, 
            // then we are enabled
            if (NULL != g_pRulesMan)
            {
                prgCmds->cmdf |= OLECMDF_ENABLED;
            }
            break;
            
        case ID_SHOW_REPLIES:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if show replies is turned on
            if (SUCCEEDED(pIMsgList->get_ShowReplies(&fShowReplies)))
            {
                // If replies is turned on, make sure the item is checked
                if (FALSE != fShowReplies)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;

        case ID_SHOW_DELETED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if show deleted is turned on
            if (SUCCEEDED(pIMsgList->get_ShowDeleted(&fShowDeleted)))
            {
                // If threading is turned on, make sure the item is checked
                if (FALSE != fShowDeleted)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;

        case ID_THREAD_MESSAGES:
            // This menu item is always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if threading is turned on
            if (SUCCEEDED(pIMsgList->get_GroupMessages(&fThreading)))
            {
                // If threading is turned on, make sure the item is checked
                if (FALSE != fThreading)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;
    }
    
    // Set the proper return value
    hr = S_OK;

exit:
    SafeRelease(pIMsgList);
    return hr;
}

HRESULT CViewMenu::Exec(HWND hwndUI, DWORD nCmdID, IMessageList * pMsgList, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    BOOL                fThreading = FALSE;
    BOOL                fShowDeleted = FALSE;
    BOOL                fShowReplies = FALSE;
    MENUITEMINFO        mii = {0};
    ULONGLONG           ullFilter = 0;
    RULEID              ridFilter = RULEID_INVALID;
    TCHAR               rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID              ridFilterTag = RULEID_INVALID;
    FOLDERID            idFolder = FOLDERID_INVALID;
    ULONGLONG           ullFolder = 0;
    FOLDERTYPE          typeFolder = FOLDER_INVALID;
    DWORD               dwFlags = 0;
    BOOL                fApplyAll = FALSE;
        
    // Check incoming params
    if (NULL == pMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the OE message list interface
    hr = pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList);
    if (FAILED(hr))
    {
        goto exit;
    }
            
    // Get the current filter on the message list
    hr = pIMsgList->get_FilterMessages(&ullFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    ridFilter = (RULEID) ullFilter;

    // Execute the actions for the correct menu item
    switch(nCmdID)
    {
        case ID_VIEW_ALL:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_ALL].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_ALL].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_UNREAD:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_UNREAD].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_UNREAD].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_DOWNLOADED:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_DOWNLOADED].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_DOWNLOADED].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_IGNORED:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_IGNORED].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_IGNORED].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_CURRENT:
            // Make sure we add the filter to the MRU list
            _AddViewToMRU(m_ridCurrent);
            
            // If this filter is turned on, make sure the item is checked
            if (m_ridCurrent != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) m_ridCurrent);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_RECENT_0:
        case ID_VIEW_RECENT_1:
        case ID_VIEW_RECENT_2:
        case ID_VIEW_RECENT_3:
        case ID_VIEW_RECENT_4:
            if (NULL != m_pmruList)
            {
                if (-1 == m_pmruList->EnumList(nCmdID - ID_VIEW_RECENT_0, rgchFilterTag, ARRAYSIZE(rgchFilterTag)))
                {
                    break;
                }

                if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterTag))
                {
                    break;
                }
        
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilterTag);
                
                // If this filter is turned on, make sure the item is checked
                if (ridFilterTag != ridFilter)
                {
                    // Set the new filter on the item
                    hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilterTag);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Mark the menu as dirty
                    m_dwState |= STATE_DIRTY;                
                }
            }
            break;
            
        case ID_VIEW_APPLY:
            if ((NULL != pvaIn) && (VT_I4 == pvaIn->vt))
            {
                // Make sure we add the filter to the MRU list
                _AddViewToMRU((RULEID) IntToPtr(pvaIn->lVal));
                
                // If threading is turned on, make sure the item is checked
                if (ridFilter != (RULEID) IntToPtr(pvaIn->lVal))
                {                
                    // Set the new filter on the item
                    hr = pIMsgList->put_FilterMessages((long) pvaIn->lVal);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Mark the menu as dirty
                    m_dwState |= STATE_DIRTY;                
                }

            }
            break;
            
        case ID_VIEW_CUSTOMIZE:
            hr = HrCustomizeCurrentView(hwndUI, 0, &ridFilter);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // If the views list changed, then apply the filter to the list
            if (S_OK == hr)
            {
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilter);
                
                // Get the current threading state
                hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;

        case ID_VIEW_MANAGER:
            if (0 == (m_dwFlags & VMF_FINDER))
            {
                // Get the current folder id
                hr = pIMsgList->get_Folder(&ullFolder);
                if (FAILED(hr))
                {
                    goto exit;
                }
                idFolder = (FOLDERID) ullFolder;
                
                // Get the folder info for this folder
                typeFolder = GetFolderType(idFolder);
                if (FOLDER_LOCAL == typeFolder)
                {
                    dwFlags = VRDF_POP3;
                }
                else if (FOLDER_NEWS == typeFolder)
                {
                    dwFlags = VRDF_NNTP;
                }
                else if (FOLDER_IMAP == typeFolder)
                {
                    dwFlags = VRDF_IMAP;
                }
                else if (FOLDER_HTTPMAIL == typeFolder)
                {
                    dwFlags = VRDF_HTTPMAIL;
                }
            }
            
            hr = HrDoViewsManagerDialog(hwndUI, dwFlags, &ridFilter, &fApplyAll);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // If the views list changed, then apply the filter to the list
            if (S_OK == hr)
            {
                // Make sure the MRU list is up to date
                SideAssert(FALSE != _FValiadateMRUList());
                
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilter);
                
                // Get the current threading state
                hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                if (FALSE != fApplyAll)
                {
                    // Set the global view
                    SetDwOption(OPT_VIEW_GLOBAL, PtrToUlong(ridFilter), NULL, 0);

                    // Set the new view on all the subscribed folders
                    hr = RecurseFolderHierarchy(FOLDERID_ROOT, RECURSE_SUBFOLDERS | RECURSE_INCLUDECURRENT,
                                        0, (DWORD_PTR) ridFilter, _HrRecurseSetFilter);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_SHOW_REPLIES:
            // Get the current deleted state
            hr = pIMsgList->get_ShowReplies(&fShowReplies);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fShowReplies = !fShowReplies;

            // Set the current deleted state
            hr = pIMsgList->put_ShowReplies(fShowReplies);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
                        
        case ID_SHOW_DELETED:
            // Get the current deleted state
            hr = pIMsgList->get_ShowDeleted(&fShowDeleted);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fShowDeleted = !fShowDeleted;

            // Set the current deleted state
            hr = pIMsgList->put_ShowDeleted(fShowDeleted);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case ID_THREAD_MESSAGES:
            // Get the current threading state
            hr = pIMsgList->get_GroupMessages(&fThreading);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fThreading = !fThreading;

            // Set the current threading state
            hr = pIMsgList->put_GroupMessages(fThreading);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
    }
    
    // Set the proper return value
    hr = S_OK;

exit:
    SafeRelease(pIMsgList);
    return hr;
}

VOID CViewMenu::_AddDefaultViews(HMENU hmenu)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    PROPVARIANT     propvar = {0};
    IOERule *       pIFilter = NULL;
    MENUITEMINFO    mii = {0};
    ULONG           ulMenu = 0;

    Assert(NULL != hmenu);
    
    // If we don't have a rules manager then fail
    if (NULL == g_pRulesMan)
    {
        goto exit;
    }

    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID | MIIM_DATA | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    
    // Add each one of the default views
    for (ulIndex = 0; ulIndex < g_cvmmDefault; ulIndex++)
    {
        // Get the view from the rules manager
        if (FAILED(g_pRulesMan->GetRule(g_vmmDefault[ulIndex].ridFilter, RULE_TYPE_FILTER, 0, &pIFilter)))
        {
            continue;
        }
        
        // Get the name from the rule
        ZeroMemory(&propvar, sizeof(propvar));
        if ((SUCCEEDED(pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar))) &&
                    (NULL != propvar.pszVal))
        {
            // Add the name to the rule
            Assert(VT_LPSTR == propvar.vt);
            mii.wID = g_vmmDefault[ulIndex].dwMenuID;
            mii.dwItemData = (DWORD_PTR) g_vmmDefault[ulIndex].ridFilter;
            mii.dwTypeData = propvar.pszVal;
            mii.cch = lstrlen(propvar.pszVal);
            if (FALSE != InsertMenuItem(hmenu, ulMenu, TRUE, &mii))
            {
                ulMenu++;
            }
        }

        PropVariantClear(&propvar);
        SafeRelease(pIFilter);
    }

    // Add in the default separator if we added at least one item
    if (0 != ulMenu)
    {
        // Set up the menu items
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_VIEW_DEFAULT_SEPERATOR;
        mii.dwItemData = 0;
        mii.dwTypeData = 0;
        mii.cch = 0;

        // Insert the separator
        InsertMenuItem(hmenu, ulMenu, TRUE, &mii);
    }
    
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return;
}

HRESULT CViewMenu::_HrInsertViewMenu(HMENU hmenuView, RULEID ridFilter, DWORD dwMenuID, DWORD dwMenuIDInsert)
{
    HRESULT         hr = S_OK;
    IOERule *       pIFilter = NULL;
    PROPVARIANT     propvar = {0};
    MENUITEMINFO    mii = {0};
    
    // Get the view from the rules manager
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the name from the view
    hr = pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Nothing to do if we don't have a name
    if (NULL == propvar.pszVal)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID | MIIM_DATA | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    mii.wID = dwMenuID;
    mii.dwItemData = (DWORD_PTR) ridFilter;
    mii.dwTypeData = propvar.pszVal;
    mii.cch = lstrlen(propvar.pszVal);

    // Insert the menu item
    if (FALSE == InsertMenuItem(hmenuView, dwMenuIDInsert, FALSE, &mii))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the return value
    hr = S_OK;

exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return hr;
}

HRESULT CViewMenu::_HrReloadMRUViewMenu(HMENU hmenuView)
{
    HRESULT         hr = S_OK;
    ULONG           ulMenu = 0;
    INT             nItem = 0;
    CHAR            rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID          ridFilter = RULEID_INVALID;
    MENUITEMINFO    mii = {0};

    // Set up the menu items
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID;
    
    // Delete the old items
    for (ulMenu = ID_VIEW_RECENT_0; ulMenu < ID_VIEW_CUSTOMIZE; ulMenu++)
    {
        if (FALSE != GetMenuItemInfo(hmenuView, ulMenu, FALSE, &mii))
        {
            RemoveMenu(hmenuView, ulMenu, MF_BYCOMMAND);
        }
    }
    
    // Add in each of the filters from the mru list
    for (nItem = 0, ulMenu = ID_VIEW_RECENT_0;
                ((-1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag))) &&
                            (ulMenu < ID_VIEW_RECENT_SEPERATOR)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilter))
        {
            continue;
        }
        
        // Insert the menu item
        if (SUCCEEDED(_HrInsertViewMenu(hmenuView, ridFilter, ulMenu, ID_VIEW_CUSTOMIZE)))
        {
            ulMenu++;
        }
    }

    // Add in the MRU separator if we added at least one item
    if (ID_VIEW_RECENT_0 != ulMenu)
    {
        // Set up the menu items
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_VIEW_RECENT_SEPERATOR;
        mii.dwItemData = 0;
        mii.dwTypeData = 0;
        mii.cch = 0;

        // Insert the separator
        InsertMenuItem(hmenuView, ID_VIEW_CUSTOMIZE, FALSE, &mii);
    }
    
    // Set the proper return value
    hr = S_OK;
     
    return hr;
}

HRESULT CViewMenu::_HrAddExtraViewMenu(HMENU hmenuView, IOEMessageList * pIMsgList)
{
    HRESULT         hr = S_OK;
    ULONGLONG       ullFilter = 0;
    RULEID          ridFilter = RULEID_INVALID;
    MENUITEMINFO    mii = {0};
    BOOL            fExtraMenu = FALSE;
    IOERule *       pIFilter = NULL;
    PROPVARIANT     propvar = {0};
    DWORD           dwMenuID = 0;

    Assert(NULL != pIMsgList);

    // Get the current filter on the message list
    hr = pIMsgList->get_FilterMessages(&ullFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    ridFilter = (RULEID) ullFilter;

    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA;

    // Does the ID_VIEW_CURRENT menu item exist?
    fExtraMenu = !!GetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &mii);
    
    // Is the view filter one of the defaults or in the MRU list?
    if ((FALSE != FIsFilterReadOnly(ridFilter)) || (FALSE != _FViewInMRUList(ridFilter, NULL)))
    {
        // Does the ID_VIEW_CURRENT menu item exist?
        if (FALSE != fExtraMenu)
        {
            // Remove the ID_VIEW_CURRENT menu item
            RemoveMenu(hmenuView, ID_VIEW_CURRENT, MF_BYCOMMAND);

            // Remove the ID_VIEW_CURRENT_SEPERATOR menu item separator
            RemoveMenu(hmenuView, ID_VIEW_CURRENT_SEPERATOR, MF_BYCOMMAND);

            // Clear out the saved current id
            m_ridCurrent = RULEID_INVALID;
        }
    }
    else
    {
        // Does the ID_VIEW_CURRENT menu item exist?
        if (FALSE != fExtraMenu)
        {
            // Is it different than the current view filter
            if (ridFilter != (RULEID) mii.dwItemData)
            {
                // Get the view from the rules manager
                hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Get the name from the view
                hr = pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar);
                if (FAILED(hr))
                {
                    goto exit;
                }

                // Nothing to do if we don't have a name
                if (NULL == propvar.pszVal)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                
                // Initialize the menu info
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_DATA | MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwItemData = (DWORD_PTR) ridFilter;
                mii.dwTypeData = propvar.pszVal;
                mii.cch = lstrlen(propvar.pszVal);

                // Reset the menu name and data
                SetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &mii);
            }
        }
        else
        {
            // Initialize the menu item info
            mii.fMask = MIIM_DATA;
            
            // Figure out which menu to add it before
            dwMenuID = (FALSE != GetMenuItemInfo(hmenuView, ID_VIEW_RECENT_0, FALSE, &mii)) ? ID_VIEW_RECENT_0: ID_VIEW_CUSTOMIZE;
            
            // Add the extra menu item
            hr = _HrInsertViewMenu(hmenuView, ridFilter, ID_VIEW_CURRENT, dwMenuID);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Set up the menu item info
            mii.fMask = MIIM_ID | MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            mii.fState = MFS_ENABLED;
            mii.wID = ID_VIEW_CURRENT_SEPERATOR;
            mii.dwItemData = 0;
            mii.dwTypeData = 0;
            mii.cch = 0;
            
            // Add the extra menu item separator
            InsertMenuItem(hmenuView, dwMenuID, FALSE, &mii);
        }

        // Save the current rule id
        m_ridCurrent = ridFilter;
     }

     // Set the proper return value
     hr = S_OK;
     
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return hr;
}

VOID CViewMenu::_AddViewToMRU(RULEID ridFilter)
{
    CHAR    rgchFilterTag[CCH_FILTERTAG_MAX];
    
    // Is there anything to do?
    if (RULEID_INVALID == ridFilter)
    {
        goto exit;
    }

    // If this isn't a default view
    if (FALSE == FIsFilterReadOnly(ridFilter))
    {
        // Format the rule id as a hex string
        wnsprintf(rgchFilterTag, ARRAYSIZE(rgchFilterTag), "0X%08X", PtrToUlong(ridFilter));

        // Add the string into the MRU list
        m_pmruList->AddString(rgchFilterTag);
    }
        
exit:
    return;
}

BOOL CViewMenu::_FViewInMRUList(RULEID ridFilter, DWORD * pdwID)
{
    BOOL    fRet = FALSE;
    INT     nItem = 0;
    CHAR    rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID  ridFilterMRU = RULEID_INVALID;

    // Initialize the return value
    if (NULL != pdwID)
    {
        *pdwID = -1;
    }

    // Add in each of the filters from the mru list
    for (nItem = 0; -1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterMRU))
        {
            continue;
        }

        if (ridFilterMRU == ridFilter)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

BOOL CViewMenu::_FValiadateMRUList(VOID)
{
    BOOL        fRet = FALSE;
    INT         nItem = 0;
    CHAR        rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID      ridFilterMRU = RULEID_INVALID;
    IOERule *   pIFilter = NULL;

    Assert(NULL != m_pmruList);
    Assert(NULL != g_pRulesMan);

    // Add in each of the filters from the mru list
    for (nItem = 0; -1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterMRU))
        {
            continue;
        }

        // Get the view from the rules manager
        if (FAILED(g_pRulesMan->GetRule(ridFilterMRU, RULE_TYPE_FILTER, 0, &pIFilter)))
        {
            if (-1 == m_pmruList->RemoveString(rgchFilterTag))
            {
                fRet = FALSE;
                goto exit;
            }
        }
        SafeRelease(pIFilter);
    }

    // Set the return value
    fRet = TRUE;

exit:
    SafeRelease(pIFilter);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateViewMenu
//
//  This creates a view menu.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateViewMenu(DWORD dwFlags, CViewMenu ** ppViewMenu)
{
    CViewMenu * pViewMenu = NULL;
    HRESULT     hr = S_OK;

    // Check the incoming params
    if (NULL == ppViewMenu)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppViewMenu = NULL;

    // Create the view menu object
    pViewMenu = new CViewMenu;
    if (NULL == pViewMenu)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pViewMenu->HrInit(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppViewMenu = pViewMenu;
    pViewMenu = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pViewMenu)
    {
        delete pViewMenu;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\ruledesc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleDesc.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "ruledesc.h"
#include "editrule.h"
#include "ruleutil.h"
#include <rulesdlg.h>
#include <newfldr.h>
#include <richedit.h>
#include <fontnsc.h>
#include <wabdefs.h>
#include <mimeolep.h>
#include <xpcomm.h>
#include "reutil.h"
#include "shlwapip.h"
#include <demand.h>

typedef struct tagSELECTADDR
{
    LONG            lRecipType;
    UINT            uidsWell;
    LPWSTR          pwszAddr;
} SELECTADDR, * PSELECTADDR;

typedef struct tagSELECTACCT
{
    RULE_TYPE       typeRule;
    LPSTR           pszAcct;
} SELECTACCT, * PSELECTACCT;


class CEditLogicUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    HWND                m_hwndDlg;
    RULE_TYPE           m_typeRule;
    HWND                m_hwndDescript;
    IOERule *           m_pIRule;
    CRuleDescriptUI *   m_pDescriptUI;
    
  public:
    CEditLogicUI();
    ~CEditLogicUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule);
    HRESULT HrShow(void);
            
    // The Rules Manager dialog function
    static INT_PTR CALLBACK FEditLogicDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

    // Message handling functions
    BOOL FOnInitDialog(HWND hwndDlg);
    BOOL FOnOK(void);
    BOOL FOnLogicChange(HWND hwndName);

};

// Constants
static const int c_cCritItemGrow = 16;
static const int c_cActItemGrow = 16;
  
static const int PUI_WORDS  = 0x00000001;
                       
HRESULT _HrCriteriaEditPeople(HWND hwnd, CRIT_ITEM * pCritItem);
HRESULT _HrCriteriaEditWords(HWND hwnd, CRIT_ITEM * pCritItem);

CRuleDescriptUI::CRuleDescriptUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
            m_typeRule(RULE_TYPE_MAIL),
            m_pDescriptListCrit(NULL), m_cDescriptListCrit(0),
            m_pDescriptListAct(NULL), m_cDescriptListAct(0),
            m_hfont(NULL), m_wpcOld(NULL), m_logicCrit(CRIT_LOGIC_AND),
            m_fErrorLogic(FALSE)
{
}

CRuleDescriptUI::~CRuleDescriptUI()
{
    _FreeDescriptionList(m_pDescriptListCrit);
    m_pDescriptListCrit = NULL;
    m_cDescriptListCrit = 0;
    
    _FreeDescriptionList(m_pDescriptListAct);
    m_pDescriptListAct = NULL;
    m_cDescriptListAct = 0;
    
    if ((NULL != m_hwndOwner) && (FALSE != IsWindow(m_hwndOwner)) && (NULL != m_wpcOld))
    {
        SetWindowLongPtr(m_hwndOwner, GWLP_WNDPROC, (LONG_PTR) m_wpcOld);
        m_wpcOld = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Make sure we set the correct font into the control
    m_hfont = HGetSystemFont(FNT_SYS_ICON);
    if (NULL != m_hfont)
    {
        SetFontOnRichEdit(m_hwndOwner, m_hfont);
    }

    // Save off the flags
    m_dwFlags = dwFlags;

    if (0 != (m_dwFlags & RDF_READONLY))
    {
        m_dwState |= STATE_READONLY;
    }
    
    // Subclass the original dialog
    if ((NULL != m_hwndOwner) && (0 == (m_dwFlags & RDF_READONLY)))
    {
        // Save off the object pointer
        SetWindowLongPtr(m_hwndOwner, GWLP_USERDATA, (LONG_PTR) this);
        
        m_wpcOld = (WNDPROC) SetWindowLongPtr(m_hwndOwner, GWLP_WNDPROC, (LONG_PTR) CRuleDescriptUI::_DescriptWndProc);
    }
    
    // We're done
    m_dwState |= STATE_INITIALIZED;

    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrSetRule
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrSetRule(RULE_TYPE typeRule, IOERule * pIRule)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListCrit = NULL;
    ULONG               cDescriptListCrit = 0;
    CRIT_LOGIC          logicCrit = CRIT_LOGIC_AND;
    RULEDESCRIPT_LIST * pDescriptListAct = NULL;
    ULONG               cDescriptListAct = 0;
    BOOL                fDisabled = FALSE;
    PROPVARIANT         propvar = {0};
    
    // Are we in a good state?
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL != pIRule)
    {
        // Create the criteria list
        hr = _HrBuildCriteriaList(pIRule, &pDescriptListCrit, &cDescriptListCrit, &logicCrit);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Create the actions list
        hr = _HrBuildActionList(pIRule, &pDescriptListAct, &cDescriptListAct);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the enabled state
        if (SUCCEEDED(pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            Assert(VT_BOOL == propvar.vt);
            fDisabled = propvar.boolVal;
        }
    }

    m_typeRule = typeRule;
    
    _FreeDescriptionList(m_pDescriptListCrit);
    m_pDescriptListCrit = pDescriptListCrit;
    pDescriptListCrit = NULL;
    m_cDescriptListCrit = cDescriptListCrit;
    
    m_logicCrit = logicCrit;
    m_fErrorLogic = FALSE;
    
    _FreeDescriptionList(m_pDescriptListAct);
    m_pDescriptListAct = pDescriptListAct;
    pDescriptListAct = NULL;
    m_cDescriptListAct = cDescriptListAct;

    // Make sure we verify the rule
    HrVerifyRule();
    
    // Clear the dirty state
    m_dwState &= ~STATE_DIRTY;
    
    // Set the rule state
    if (NULL != pIRule)
    {
        m_dwState |= STATE_HASRULE;
    }
    else
    {
        m_dwState &= ~STATE_HASRULE;
    }
    if (FALSE == fDisabled)
    {
        m_dwState |= STATE_ENABLED;
    }
    else
    {
        m_dwState &= ~STATE_ENABLED;
    }
    
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptListCrit);
    _FreeDescriptionList(pDescriptListAct);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrVerifyRule
//
//  This verifies the rule string
//
//  Returns:    S_OK, if the rule state is valid
//              S_FALSE, if the rule state is invalid
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrVerifyRule(void)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    BOOL                fBad = FALSE;

    // If we have nothing, then the rule is still in error
    if ((NULL == m_pDescriptListCrit) && (NULL == m_pDescriptListAct))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Validate the logic operation
    if (1 < m_cDescriptListCrit)
    {
        m_fErrorLogic = (CRIT_LOGIC_NULL == m_logicCrit);
        if (FALSE != m_fErrorLogic)
        {
            fBad = TRUE;
        }
    }

    // Validate the criteria
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        pDescriptListWalk->fError = !_FVerifyCriteria(pDescriptListWalk);
        if (FALSE != pDescriptListWalk->fError)
        {
            fBad = TRUE;
        }
    }
    
    // Build up the actions
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        pDescriptListWalk->fError = !_FVerifyAction(pDescriptListWalk);
        if (FALSE != pDescriptListWalk->fError)
        {
            fBad = TRUE;
        }
    }

    // Set the correct return value
    hr = (FALSE == fBad) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrEnableCriteria
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrEnableCriteria(CRIT_TYPE type, BOOL fEnable)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;

    // Find the index of the criteria
    for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditCritList); ulIndex++)
    {
        if (type == c_rgEditCritList[ulIndex].typeCrit)
        {
            break;
        }
    }

    // Did we find the criteria item?
    if (ulIndex >= ARRAYSIZE(c_rgEditCritList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Are we trying to remove the item
    if (FALSE == fEnable)
    {

        if (FALSE == _FRemoveDescription(&m_pDescriptListCrit, ulIndex, &pDescriptListAlloc))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Free up the description
        pDescriptListAlloc->pNext = NULL;
        _FreeDescriptionList(pDescriptListAlloc);
        m_cDescriptListCrit--;
    }
    else
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Save of the criteria type info
        pDescriptListAlloc->ulIndex = ulIndex;

        _InsertDescription(&m_pDescriptListCrit, pDescriptListAlloc);
        m_cDescriptListCrit++;
    }
            
    m_dwState |= STATE_DIRTY;
    
    ShowDescriptionString();
    
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrEnableActions
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrEnableActions(ACT_TYPE type, BOOL fEnable)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;

    // Find the index of the actions
    for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditActList); ulIndex++)
    {
        if (type == c_rgEditActList[ulIndex].typeAct)
        {
            break;
        }
    }

    // Did we find the action item?
    if (ulIndex >= ARRAYSIZE(c_rgEditActList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Are we trying to remove the item
    if (FALSE == fEnable)
    {
        if (FALSE == _FRemoveDescription(&m_pDescriptListAct, ulIndex, &pDescriptListAlloc))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Free up the description
        pDescriptListAlloc->pNext = NULL;
        _FreeDescriptionList(pDescriptListAlloc);
        m_cDescriptListAct--;
    }
    else
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Save of the actions type info
        pDescriptListAlloc->ulIndex = ulIndex;

        _InsertDescription(&m_pDescriptListAct, pDescriptListAlloc);
        m_cDescriptListAct++;
    }
            
    m_dwState |= STATE_DIRTY;
    
    ShowDescriptionString();
    
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrGetCriteria
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrGetCriteria(CRIT_ITEM ** ppCritList, ULONG * pcCritList)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               cCritItemAlloc = 0;

    if (NULL == ppCritList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppCritList = NULL;
    if (NULL != pcCritList)
    {
        *pcCritList = 0;
    }

    // If we don't have any criteria then return
    if (NULL == m_pDescriptListCrit)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we need more room?
        if (cCritItem == cCritItemAlloc)
        {
            if (FAILED(HrRealloc((void **) &pCritItem,
                            sizeof(*pCritItem) * (cCritItemAlloc + c_cCritItemGrow))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            ZeroMemory(pCritItem + cCritItemAlloc, sizeof(*pCritItem) * c_cCritItemGrow);
            cCritItemAlloc += c_cCritItemGrow;
        }

        // Set the criteria type
        pCritItem[cCritItem].type = c_rgEditCritList[pDescriptListWalk->ulIndex].typeCrit;
        
        // Set the flags
        pCritItem[cCritItem].dwFlags = pDescriptListWalk->dwFlags;

        if (VT_EMPTY != pDescriptListWalk->propvar.vt)
        {
            if (FAILED(PropVariantCopy(&(pCritItem[cCritItem].propvar), &(pDescriptListWalk->propvar))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }

        // Set the logic operator 
        if (0 != cCritItem)
        {
            pCritItem[cCritItem - 1].logic = m_logicCrit;
        }

        // Move to the next item
        cCritItem++;
    }

    *ppCritList = pCritItem;
    pCritItem = NULL;
    
    if (NULL != pcCritList)
    {
        *pcCritList = cCritItem;
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrGetActions
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrGetActions(ACT_ITEM ** ppActList, ULONG * pcActList)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               cActItemAlloc = 0;

    if (NULL == ppActList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppActList = NULL;
    if (NULL != pcActList)
    {
        *pcActList = 0;
    }

    // If we don't have any criteria then return
    if (NULL == m_pDescriptListAct)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we need more room?
        if (cActItem == cActItemAlloc)
        {
            if (FAILED(HrRealloc((void **) &pActItem,
                            sizeof(*pActItem) * (cActItemAlloc + c_cActItemGrow))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            ZeroMemory(pActItem + cActItemAlloc, sizeof(*pActItem) * c_cActItemGrow);
            cActItemAlloc += c_cActItemGrow;
        }

        // Set the action type
        pActItem[cActItem].type = c_rgEditActList[pDescriptListWalk->ulIndex].typeAct;
        
        // Set the flags
        pActItem[cActItem].dwFlags = pDescriptListWalk->dwFlags;
        
        if (VT_EMPTY != pDescriptListWalk->propvar.vt)
        {
            if (FAILED(PropVariantCopy(&(pActItem[cActItem].propvar), &(pDescriptListWalk->propvar))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        
        // Move to the next item
        cActItem++;
    }

    *ppActList = pActItem;
    pActItem = NULL;
    
    if (NULL != pcActList)
    {
        *pcActList = cActItem;
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ShowDescriptionString
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::ShowDescriptionString(VOID)
{
    WCHAR               wszRes[CCHMAX_STRINGRES + 3];
    ULONG               cchRes = 0;
    BOOL                fError = FALSE;
    CHARFORMAT          chFmt = {0};
    PARAFORMAT          paraFmt = {0};
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    BOOL                fFirst = FALSE;
    UINT                uiText = 0;
    BOOL                fErrorFwdSec = FALSE;
    CHARRANGE           chrg = {0};
    
    Assert(NULL != m_hwndOwner);

    // Let's clear the redraw state to reduce flicker.
    SendMessage(m_hwndOwner, WM_SETREDRAW, 0, 0);
    
    // Clear text
    SetRichEditText(m_hwndOwner, NULL, FALSE, NULL, TRUE);
    
    // Set default CHARFORMAT
    chFmt.cbSize = sizeof(chFmt);
    chFmt.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
    chFmt.dwEffects = CFE_AUTOCOLOR;
    SendMessage(m_hwndOwner, EM_SETCHARFORMAT, (WPARAM)SCF_ALL, (LPARAM)&chFmt);

    paraFmt.cbSize = sizeof(paraFmt);
    paraFmt.dwMask = PFM_ALIGNMENT;
    
    if (0 == (m_dwState & STATE_HASRULE))
    {

        // Set up the empty string paragraph style
        paraFmt.wAlignment = PFA_CENTER;

        uiText = (RULE_TYPE_FILTER != m_typeRule) ? 
                    idsRulesDescriptionEmpty : 
                    idsViewDescriptionEmpty;
    }
    else
    {
        paraFmt.wAlignment = PFA_LEFT;

        // Determine if the rule is in error
        if (m_fErrorLogic)
        {
            fError = TRUE;
        }
        
        if (!fError)
        {
            // Walk the criteria looking for errors
            for (pDescriptListWalk = m_pDescriptListCrit;
                        pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
            {
                if (pDescriptListWalk->fError)
                {
                    fError = TRUE;
                    break;
                }
            }
        }
        
        if (!fError)
        {
            // Walk the actions looking for errors
            for (pDescriptListWalk = m_pDescriptListAct;
                        pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
            {
                if (pDescriptListWalk->fError)
                {
                    // Note that we are in error
                    fError = TRUE;

                    // Is we have a FWD action
                    if (ACT_TYPE_FWD == c_rgEditActList[pDescriptListWalk->ulIndex].typeAct)
                    {
                        // If security is turned then note it
                        if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
                        {
                            fErrorFwdSec = TRUE;
                        }
                        break;
                    }
                }
            }
        }
    
        if (fError)
        {
            uiText = fErrorFwdSec ? idsRulesErrorFwdHeader : idsRulesErrorHeader;
        }
        else if (0 != (m_dwFlags & RDF_APPLYDLG))
        {
            uiText = idsRulesApplyHeader;
        }
        else if (RULE_TYPE_FILTER != m_typeRule)
        {
            uiText = (0 != (m_dwState & STATE_ENABLED)) ? idsRuleHeader : idsRulesOffHeader;
        }
    }
    
    // Set default PARAFORMAT
    SendMessage(m_hwndOwner, EM_SETPARAFORMAT, 0, (LPARAM)&paraFmt);

    // Load help text
    wszRes[0] = L'\0';
    cchRes = LoadStringWrapW(g_hLocRes, uiText, wszRes, ARRAYSIZE(wszRes));

    // If error, make sure help text is bolded
    if (fError)
    {
        chFmt.dwMask = CFM_BOLD;
        chFmt.dwEffects = CFE_BOLD;
    }

    // Set help text into the richedit control
    RuleUtil_AppendRichEditText(m_hwndOwner, 0, wszRes, &chFmt);
    
    // Build up the criteria
    fFirst = TRUE;
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (0 != (pDescriptListWalk->dwFlags & CRIT_FLAG_INVERT))
        {
            uiText = c_rgEditCritList[pDescriptListWalk->ulIndex].uiTextAlt;
        }
        else
        {
            uiText = c_rgEditCritList[pDescriptListWalk->ulIndex].uiText;
        }
        
        _ShowLinkedString(uiText, pDescriptListWalk, fFirst, TRUE);
        fFirst = FALSE;

        // Only need to do this once for the block sender rule
        if (CRIT_TYPE_SENDER == c_rgEditCritList[pDescriptListWalk->ulIndex].typeCrit)
        {
            break;
        }
    }
    
    // Build up the actions
    fFirst = TRUE;
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (0 != (pDescriptListWalk->dwFlags & ACT_FLAG_INVERT))
        {
            uiText = c_rgEditActList[pDescriptListWalk->ulIndex].uiTextAlt;
        }
        else
        {
            uiText = c_rgEditActList[pDescriptListWalk->ulIndex].uiText;
        }
        
        _ShowLinkedString(uiText, pDescriptListWalk, fFirst, FALSE);
        fFirst = FALSE;
    }

    // Restore the selection
    RichEditExSetSel(m_hwndOwner, &chrg);
    
    // Let's set back the redraw state and invalidate the rect to
    // get the string drawn
    SendMessage(m_hwndOwner, WM_SETREDRAW, 1, 0);
    InvalidateRect(m_hwndOwner, NULL, TRUE);
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _ShowLinkedString
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_ShowLinkedString(ULONG ulText, RULEDESCRIPT_LIST * pDescriptListWalk,
            BOOL fFirst, BOOL fCrit)
{
    HRESULT             hr = S_OK;
    WCHAR               wszRes[CCHMAX_STRINGRES + 2];
    ULONG               uiStrId = 0;
    ULONG               cchText = 0;
    CHARFORMAT          chFmt = {0};
    CHARRANGE           chrg = {0};
    LPWSTR              lpwsz = NULL;

    if ((0 == ulText) || (NULL == pDescriptListWalk))
    {
        Assert(FALSE);
        goto exit;
    }

    // Figure out where we're supposed to start
    cchText = GetRichEditTextLen(m_hwndOwner);

    // So richedit 2 and 3 need to have each beginning line
    // have the default charformat reset. It actually only matters
    // if you are showing both criteria and actions. In that case, if
    // this isn't done, then the default charformat might be incorretly
    // set to one of the other charformats that have been used. So, there
    // is obviously something amiss here, but I can't figure
    // it out, this is what we use to do, and this works.
    // See raid 78472 in IE/OE 5.0 database
    chrg.cpMin = cchText;
    chrg.cpMax = cchText;
    RichEditExSetSel(m_hwndOwner, &chrg);

    // Set default CHARFORMAT
    chFmt.cbSize = sizeof(chFmt);
    chFmt.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
    chFmt.dwEffects = CFE_AUTOCOLOR;
    SendMessage(m_hwndOwner, EM_SETCHARFORMAT, (WPARAM)SCF_SELECTION, (LPARAM)&chFmt);

    // Should we use a logical op?
    if (!fFirst)
    {
        // Which string should we load?
        if (fCrit)
        {
            if (CRIT_LOGIC_AND == m_logicCrit)
            {
                uiStrId = idsCriteriaAnd;
            }
            else if (CRIT_LOGIC_OR == m_logicCrit)
            {
                uiStrId =  idsCriteriaOr;
            }
            else
            {
                uiStrId =  idsCriteriaAndOr;
            }
        }
        else
        {
            uiStrId = idsActionsAnd;
        }
        
        wszRes[0] = L'\0';
        if (0 == LoadStringWrapW(g_hLocRes, uiStrId, wszRes, ARRAYSIZE(wszRes)))
        {
            goto exit;
        }

        // Write out the linked logic string
        IF_FAILEXIT(hr = RuleUtil_HrShowLinkedString(m_hwndOwner, m_fErrorLogic,
                    (0 != (m_dwState & STATE_READONLY)), wszRes, NULL, cchText,
                    &(pDescriptListWalk->ulStartLogic), &(pDescriptListWalk->ulEndLogic), &cchText));
    }

    // Get the description string
    wszRes[0] = L'\0';
    if (0 == LoadStringWrapW(g_hLocRes, ulText, wszRes, ARRAYSIZE(wszRes)))
    {
        goto exit;
    }

    // Write out the linked string
    if(pDescriptListWalk->pszText)
        IF_NULLEXIT(lpwsz = PszToUnicode(CP_ACP, pDescriptListWalk->pszText));

    IF_FAILEXIT(hr = RuleUtil_HrShowLinkedString(m_hwndOwner, pDescriptListWalk->fError,
                (0 != (m_dwState & STATE_READONLY)), wszRes, lpwsz,
                cchText, &(pDescriptListWalk->ulStart), &(pDescriptListWalk->ulEnd), &cchText));
    
    // Hack for HyperLinks to work without having to measure text (was broken for BiDi)
    RuleUtil_AppendRichEditText(m_hwndOwner, cchText, g_wszSpace, NULL);
    // Terminate the string
    RuleUtil_AppendRichEditText(m_hwndOwner, cchText + 1, g_wszCRLF, NULL);    
    
exit:
    MemFree(lpwsz);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeLogicValue
//
//  This changes the value of the logic op
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeLogicValue(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL            fRet = FALSE;
    int             iRet = 0;
    CRIT_LOGIC      logicCrit = CRIT_LOGIC_NULL;
    
    // Bring up the choose logic op dialog
    if (NULL != m_logicCrit)
    {
        logicCrit = m_logicCrit;
    }
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaLogic),
                                        m_hwndOwner,  _FSelectLogicDlgProc,
                                        (LPARAM) &logicCrit);

    fRet = (iRet == IDOK);

    // Update the description field if neccessary
    if (FALSE != fRet)
    {            
        m_logicCrit = logicCrit;

        // ZIFF
        // Can we be sure we are really OK??
        m_fErrorLogic = FALSE;
        
        ShowDescriptionString();
    }
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildCriteriaList
//
//  This builds the criteria list
//
//  Returns:    TRUE, if the criteria list was created
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::_HrBuildCriteriaList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList,
            CRIT_LOGIC * plogicCrit)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         propvar = {0};
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    ULONG               ulList = 0;
    ULONG               cDescriptList = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;
    LPSTR               pszText = NULL;
    CRIT_LOGIC          logicCrit = CRIT_LOGIC_NULL;
    
    Assert((NULL != pIRule) && (NULL != ppDescriptList) &&
                    (NULL != pcDescriptList) && (NULL != plogicCrit));

    // Initialize the outgoing param
    *ppDescriptList = NULL;
    *pcDescriptList = 0;
    *plogicCrit = CRIT_LOGIC_AND;
    
    // Get the list of criteria
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Grab the criteria list
    Assert(NULL != propvar.blob.pBlobData);
    cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
    propvar.blob.pBlobData = NULL;
    propvar.blob.cbSize = 0;

    // For each criteria, add it to the description list
    for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Search for the criteria type
        for (ulList = 0; ulList < ARRAYSIZE(c_rgEditCritList); ulList++)
        {
            if (pCritItem[ulIndex].type == c_rgEditCritList[ulList].typeCrit)
            {
                // Save of the criteria type info
                pDescriptListAlloc->ulIndex = ulList;

                // Save off the flags
                pDescriptListAlloc->dwFlags = pCritItem[ulIndex].dwFlags;

                // Do we have any data?
                if (VT_EMPTY != pCritItem[ulIndex].propvar.vt)
                {
                    // Copy the data
                    SideAssert(SUCCEEDED(PropVariantCopy(&propvar, &(pCritItem[ulIndex].propvar))));
                    pDescriptListAlloc->propvar = propvar;
                    ZeroMemory(&propvar, sizeof(propvar));

                    // Build up the description text
                    if (FALSE != _FBuildCriteriaText(pCritItem[ulIndex].type, pDescriptListAlloc->dwFlags,
                                            &(pDescriptListAlloc->propvar), &pszText))
                    {
                        // Save off the string
                        pDescriptListAlloc->pszText = pszText;
                        pszText = NULL;
                    }

                }

                // We're done searching
                break;
            }
        }

        // Did we find anything?
        if (ulList >= ARRAYSIZE(c_rgEditCritList))
        {
            // Free up the description
            _FreeDescriptionList(pDescriptListAlloc);
        }
        else
        {
            // Save the rule description
            _InsertDescription(&pDescriptList, pDescriptListAlloc);
            pDescriptListAlloc = NULL;                           
            cDescriptList++;
        }

        SafeMemFree(pszText);
    }

    // Get the logic op
    logicCrit = (cDescriptList > 1) ? pCritItem->logic : CRIT_LOGIC_AND;

    // Set the outgoing params
    *ppDescriptList = pDescriptList;
    pDescriptList = NULL;
    *pcDescriptList = cDescriptList;
    *plogicCrit = logicCrit;

    // Set the return value
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptList);
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeCriteriaValue
//
//  This changes the value of the criteria value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeCriteriaValue(RULEDESCRIPT_LIST * pCritList)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    int                 iRet = 0;
    LONG                lDiff = 0;
    FOLDERID            idFolder = FOLDERID_ROOT;
    CHARRANGE           chrg;
    LPSTR               pszVal = NULL;
    ULONG               ulVal = 0;
    SELECTACCT          selAcct;
    IImnAccount *       pAccount = NULL;
    CHARFORMAT          chfmtLink;
    CHARFORMAT          chfmtNormal;
    CRIT_ITEM           critItem;
    RULEFOLDERDATA *    prfdData = NULL;

    ZeroMemory(&critItem, sizeof(critItem));
    
    switch(c_rgEditCritList[pCritList->ulIndex].typeCrit)
    {
      case CRIT_TYPE_NEWSGROUP:
        // Bring up the select newsgroup dialog
        if ((0 != pCritList->propvar.blob.cbSize) && (NULL != pCritList->propvar.blob.pBlobData))
        {
            // Validate the rule folder data
            if (S_OK == RuleUtil_HrValidateRuleFolderData((RULEFOLDERDATA *) (pCritList->propvar.blob.pBlobData)))
            {
                idFolder = ((RULEFOLDERDATA *) (pCritList->propvar.blob.pBlobData))->idFolder;
            }
        }
        
        hr = SelectFolderDialog(m_hwndOwner, SFD_SELECTFOLDER, idFolder, 
                                TREEVIEW_NOLOCAL | TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_NONEWFOLDERS | FD_DISABLEROOT | FD_DISABLESERVERS | FD_FORCEINITSELFOLDER,
                                MAKEINTRESOURCE(idsSelectNewsgroup), MAKEINTRESOURCE(idsSelectNewsgroupCaption), &idFolder);

        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {
            STOREUSERDATA   UserData = {0};

            // Create space for the data structure
            hr = HrAlloc((VOID **) &prfdData, sizeof(*prfdData));
            if (FAILED(hr))
            {
                goto exit;
            }

            // Initialize the data struct
            ZeroMemory(prfdData, sizeof(*prfdData));
            
            // Get the timestamp for the store
            hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Set the timestamp
            prfdData->ftStamp = UserData.ftCreated;
            prfdData->idFolder = idFolder;

            // Set the folder id
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_BLOB;
            pCritList->propvar.blob.cbSize = sizeof(*prfdData);
            pCritList->propvar.blob.pBlobData = (BYTE *) prfdData;
            prfdData = NULL;
        }
        break;
        
      case CRIT_TYPE_SUBJECT:
      case CRIT_TYPE_BODY:
        // Duplicate the data
        critItem.type = c_rgEditCritList[pCritList->ulIndex].typeCrit;
        critItem.dwFlags = pCritList->dwFlags;
        critItem.propvar.vt = VT_BLOB;

        // Copy over the blob data if it is there
        if ((0 != pCritList->propvar.blob.cbSize) &&
                (NULL != pCritList->propvar.blob.pBlobData))
        {
            hr = HrAlloc((VOID **) &(critItem.propvar.blob.pBlobData), pCritList->propvar.blob.cbSize);
            if (SUCCEEDED(hr))
            {
                critItem.propvar.blob.cbSize = pCritList->propvar.blob.cbSize;
                CopyMemory(critItem.propvar.blob.pBlobData,
                            pCritList->propvar.blob.pBlobData, critItem.propvar.blob.cbSize);
            }
        }
        
        // Edit the words
        hr = _HrCriteriaEditWords(m_hwndOwner, &critItem);
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }
        
        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {            
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = critItem.dwFlags;
            pCritList->propvar = critItem.propvar;
            critItem.propvar.blob.pBlobData = NULL;
            critItem.propvar.blob.cbSize = 0;
        }
        break;

      case CRIT_TYPE_TO:
      case CRIT_TYPE_CC:
      case CRIT_TYPE_TOORCC:
      case CRIT_TYPE_FROM:
        // Duplicate the data
        critItem.type = c_rgEditCritList[pCritList->ulIndex].typeCrit;
        critItem.dwFlags = pCritList->dwFlags;
        critItem.propvar.vt = VT_BLOB;

        // Copy over the blob data if it is there
        if ((0 != pCritList->propvar.blob.cbSize) &&
                (NULL != pCritList->propvar.blob.pBlobData))
        {
            hr = HrAlloc((VOID **) &(critItem.propvar.blob.pBlobData), pCritList->propvar.blob.cbSize);
            if (SUCCEEDED(hr))
            {
                critItem.propvar.blob.cbSize = pCritList->propvar.blob.cbSize;
                CopyMemory(critItem.propvar.blob.pBlobData,
                            pCritList->propvar.blob.pBlobData, critItem.propvar.blob.cbSize);
            }
        }
        
        // Edit the people
        hr = _HrCriteriaEditPeople(m_hwndOwner, &critItem);
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }
        
        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {            
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = critItem.dwFlags;
            pCritList->propvar = critItem.propvar;
            critItem.propvar.blob.pBlobData = NULL;
            critItem.propvar.blob.cbSize = 0;
        }
        break;

      case CRIT_TYPE_ACCOUNT:
        // Bring up the rename rule dialog
        if (NULL != pCritList->propvar.pszVal)
        {
            pszVal = PszDupA(pCritList->propvar.pszVal);
        }
        
        selAcct.typeRule = m_typeRule;
        selAcct.pszAcct = pszVal;
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaAcct),
                                            m_hwndOwner, _FSelectAcctDlgProc,
                                            (LPARAM) &selAcct);

        pszVal = selAcct.pszAcct;
        
        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            // Figure out account name
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_LPSTR;
            pCritList->propvar.pszVal = pszVal;
            pszVal = NULL;
            
        }
        break;

      case CRIT_TYPE_SIZE:
        // Bring up the rename rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaSize),
                                            m_hwndOwner, _FSelectSizeDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_LINES:
        // Bring up the line rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaLines),
                                            m_hwndOwner, _FSelectLinesDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_AGE:
        // Bring up the age rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaAge),
                                            m_hwndOwner, _FSelectAgeDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_PRIORITY:
        // Bring up the priority rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaPriority),
                                            m_hwndOwner,  _FSelectPriorityDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_SECURE:
        // Bring up the secure rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaSecure),
                                            m_hwndOwner,  _FSelectSecureDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_THREADSTATE:
        // Bring up the thread state rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaThreadState),
                                            m_hwndOwner,  _FSelectThreadStateDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
        
      case CRIT_TYPE_FLAGGED:
        // Bring up the flag dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaFlag),
                                            m_hwndOwner,  _FSelectFlagDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
        
      case CRIT_TYPE_DOWNLOADED:
        // Bring up the deletion dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaDownloaded),
                                            m_hwndOwner,  _FSelectDownloadedDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
                
      case CRIT_TYPE_READ:
        // Bring up the deletion dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaRead),
                                            m_hwndOwner,  _FSelectReadDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
                
      default:
        fRet = FALSE;
        break;
    }

    // Update the description field if neccessary
    if (FALSE != fRet)
    {
        // ZIFF
        // Can we be sure we are really OK??
        pCritList->fError = FALSE;
        
        // If we have something to build up
        if (VT_EMPTY != pCritList->propvar.vt)
        {
            if (FALSE == _FBuildCriteriaText(c_rgEditCritList[pCritList->ulIndex].typeCrit,
                            pCritList->dwFlags, &(pCritList->propvar), &pszText))
            {
                goto exit;
            }
            
            SafeMemFree(pCritList->pszText);
            pCritList->pszText = pszText;
            pszText = NULL;
        }
        
        ShowDescriptionString();
    }
    
exit:
    SafeMemFree(prfdData);
    SafeMemFree(critItem.propvar.blob.pBlobData);
    SafeRelease(pAccount);
    SafeMemFree(pszVal);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildCriteriaText
//
//  This changes the value of the criteria value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FBuildCriteriaText(CRIT_TYPE type, DWORD dwFlags, 
                    PROPVARIANT * ppropvar, LPSTR * ppszText)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    HRESULT             hr = S_OK;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    UINT                uiId = 0;
    TCHAR               rgchFirst[CCHMAX_STRINGRES];
    ULONG               cchFirst = 0;
    TCHAR               rgchSecond[CCHMAX_STRINGRES];
    ULONG               cchSecond = 0;
    LPTSTR              pszString = NULL;
    LPTSTR              pszWalk = NULL;
    UINT                uiID = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    if ((NULL == ppropvar) || (NULL == ppszText))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(type)
    {
        case CRIT_TYPE_NEWSGROUP:
            if ((0 == ppropvar->blob.cbSize) || (NULL == ppropvar->blob.pBlobData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            prfdData = (RULEFOLDERDATA *) (ppropvar->blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Are we subscribed?
            if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszText = PszDupA(Folder.pszName);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SUBJECT:
        case CRIT_TYPE_BODY:
        case CRIT_TYPE_TO:
        case CRIT_TYPE_CC:
        case CRIT_TYPE_TOORCC:
        case CRIT_TYPE_FROM:
            if ((VT_BLOB != ppropvar->vt) ||
                (0 == ppropvar->blob.cbSize) ||
                (NULL == ppropvar->blob.pBlobData) ||
                ('\0' == ppropvar->blob.pBlobData[0]))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszString = (LPTSTR) ppropvar->blob.pBlobData;
            
            // Load up the first template
            if (0 != (dwFlags & CRIT_FLAG_INVERT))
            {
                uiID = idsCriteriaMultFirstNot;
            }
            else
            {
                uiID = idsCriteriaMultFirst;
            }
            
            cchFirst = LoadString(g_hLocRes, uiID, rgchFirst, sizeof(rgchFirst));
            if (0 == cchFirst)
            {
                fRet = FALSE;
                goto exit;
            }
            
            cchText = cchFirst + 1;
            
            // How many strings do we have?
            if ((lstrlen(pszString) + 3) != (int) ppropvar->blob.cbSize)
            {
                if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
                {
                    uiID = idsCriteriaMultAnd;
                }
                else
                {
                    uiID = idsCriteriaMultOr;
                }
                
                // Load up the second template
                cchSecond = LoadString(g_hLocRes, uiID, rgchSecond, sizeof(rgchSecond));
                if (0 == cchSecond)
                {
                    fRet = FALSE;
                    goto exit;
                }
                
                // Add in the second string for each other string
                for (pszWalk = pszString; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
                {
                    cchText += cchSecond;
                }
            }
            else
            {
                rgchSecond[0] = '\0';
            }
            
            // Total up the space
            cchText += ppropvar->blob.cbSize;
            
            // Allocate the space
            if (FAILED(HrAlloc((void **) &pszText, cchText)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Copy in the first string
            wnsprintf(pszText, cchText, rgchFirst, pszString);
            pszString += lstrlen(pszString) + 1;
            
            // For each string
            pszWalk = pszText + lstrlen(pszText);
            cchText -= lstrlen(pszText);
            for (; '\0' != pszString[0]; pszString += lstrlen(pszString) + 1)
            {
                // Build up the string
                wnsprintf(pszWalk, cchText, rgchSecond, pszString);
                cchText -= lstrlen(pszWalk);
                pszWalk += lstrlen(pszWalk);
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:
            Assert(g_pAcctMan);
            if (!g_pAcctMan || FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, ppropvar->pszVal, &pAccount)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_ACCOUNT_NAME)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, pszText, CCHMAX_ACCOUNT_NAME)))
            {
                fRet = FALSE;
                goto exit;
            }        
            break;
            
        case CRIT_TYPE_SIZE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wnsprintf(pszText, CCHMAX_STRINGRES, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsKB, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_LINES:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wnsprintf(pszText, CCHMAX_STRINGRES, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsLines, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_AGE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wnsprintf(pszText, CCHMAX_STRINGRES, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsDays, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_PRIORITY:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (CRIT_DATA_HIPRI == ppropvar->ulVal)
            {
                uiId = idsHighPri;
            }
            else if (CRIT_DATA_LOPRI == ppropvar->ulVal)
            {
                uiId = idsLowPri;
            }
            else
            {
                uiId = idsNormalPri;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        case CRIT_TYPE_SECURE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (0 != (ppropvar->ulVal & CRIT_DATA_ENCRYPTSECURE))
            {
                uiId = idsSecureEncrypt;
            }
            else if (0 != (ppropvar->ulVal & CRIT_DATA_SIGNEDSECURE))
            {
                uiId = idsSecureSigned;
            }
            else
            {
                uiId = idsSecureNone;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        case CRIT_TYPE_THREADSTATE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (0 != (ppropvar->ulVal & CRIT_DATA_WATCHTHREAD))
            {
                uiId = idsThreadWatch;
            }
            else if (0 != (ppropvar->ulVal & CRIT_DATA_IGNORETHREAD))
            {
                uiId = idsThreadIgnore;
            }
            else
            {
                uiId = idsThreadNone;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }

    *ppszText = pszText;
    pszText = NULL;

    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FVerifyCriteria
//
//  This verifies the value of the criteria
//
//  Returns:    TRUE, if the criteria value was valid
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FVerifyCriteria(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    HRESULT             hr = S_OK;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    LPSTR               pszWalk = NULL;
    RULEFOLDERDATA *    prfdData = NULL;

    if (NULL == pDescriptList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(c_rgEditCritList[pDescriptList->ulIndex].typeCrit)
    {
        case CRIT_TYPE_NEWSGROUP:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pDescriptList->propvar.blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Does the folder exist
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                hr = S_FALSE;
                goto exit;
            }        
            
            // Are we subscribed?
            if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
            {
                hr = S_FALSE;
                goto exit;
            }        
            break;
            
        case CRIT_TYPE_ALL:
        case CRIT_TYPE_JUNK:
        case CRIT_TYPE_READ:
        case CRIT_TYPE_REPLIES:
        case CRIT_TYPE_DOWNLOADED:
        case CRIT_TYPE_DELETED:
        case CRIT_TYPE_ATTACH:
        case CRIT_TYPE_FLAGGED:
            if (VT_EMPTY != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SUBJECT:
        case CRIT_TYPE_BODY:
        case CRIT_TYPE_TO:
        case CRIT_TYPE_CC:
        case CRIT_TYPE_TOORCC:
        case CRIT_TYPE_FROM:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize) ||
                (NULL == pDescriptList->propvar.blob.pBlobData) ||
                ('\0' == pDescriptList->propvar.blob.pBlobData[0]))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Spin through each item making sure it is perfect
            cchText = 0;
            for (pszWalk = (LPTSTR) pDescriptList->propvar.blob.pBlobData;
            '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
            {
                cchText += lstrlen(pszWalk) + 1;
            }
            
            // For the terminator
            if ('\0' == pszWalk[0])
            {
                cchText++;
            }
            if ('\0' == pszWalk[1])
            {
                cchText++;
            }
            
            if (cchText != pDescriptList->propvar.blob.cbSize)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SIZE:
        case CRIT_TYPE_THREADSTATE:
        case CRIT_TYPE_LINES:
        case CRIT_TYPE_PRIORITY:
        case CRIT_TYPE_AGE:
        case CRIT_TYPE_SECURE:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                fRet = FALSE;
                goto exit;
            }
            
            Assert(g_pAcctMan);
            if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pDescriptList->propvar.pszVal, &pAccount)))
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SENDER:
        {
            LPWSTR  pwszText = NULL,
                    pwszVal = NULL;

            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                AssertSz(VT_LPWSTR != pDescriptList->propvar.vt, "We are getting UNICODE here.");
                fRet = FALSE;
                goto exit;
            }
            
            // Verify the email string
            pwszVal = PszToUnicode(CP_ACP, pDescriptList->propvar.pszVal);
            if (!pwszVal)
            {
                hr = S_FALSE;
                goto exit;
            }
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszVal);
            MemFree(pwszText);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }    
            break;
        }
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }

    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrBuildActionList
//
//  This builds the actions list
//
//  Returns:    TRUE, if the criteria list was created
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::_HrBuildActionList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         propvar = {0};
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    ULONG               ulList = 0;
    ULONG               cDescriptList = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;
    LPSTR               pszText = NULL;
    
    Assert((NULL != pIRule) &&
                (NULL != ppDescriptList) && (NULL != pcDescriptList));

    // Initialize the outgoing param
    *ppDescriptList = NULL;
    *pcDescriptList = 0;
    
    // Get the list of actions
    hr = pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Grab the actions list
    Assert(NULL != propvar.blob.pBlobData);
    cActItem = propvar.blob.cbSize / sizeof(ACT_ITEM);
    pActItem = (ACT_ITEM *) (propvar.blob.pBlobData);
    propvar.blob.pBlobData = NULL;
    propvar.blob.cbSize = 0;

    // For each action, add it to the description list
    for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Search for the criteria type
        for (ulList = 0; ulList < ARRAYSIZE(c_rgEditActList); ulList++)
        {
            if (pActItem[ulIndex].type == c_rgEditActList[ulList].typeAct)
            {
                // Save of the criteria type info
                pDescriptListAlloc->ulIndex = ulList;

                // Save off the flags
                pDescriptListAlloc->dwFlags = pActItem[ulIndex].dwFlags;

                // Do we have any data?
                if (VT_EMPTY != pActItem[ulIndex].propvar.vt)
                {
                    // Copy the data
                    SideAssert(SUCCEEDED(PropVariantCopy(&propvar, &(pActItem[ulIndex].propvar))));
                    pDescriptListAlloc->propvar = propvar;
                    ZeroMemory(&propvar, sizeof(propvar));

                    // Build up the description text
                    if (FALSE != _FBuildActionText(pActItem[ulIndex].type,
                                            &(pDescriptListAlloc->propvar), &pszText))
                    {
                        pDescriptListAlloc->pszText = pszText;
                        pszText = NULL;
                    }
                }

                // We're done searching
                break;
            }
        }

        // Did we find anything?
        if (ulList >= ARRAYSIZE(c_rgEditActList))
        {
            // Free up the description
            _FreeDescriptionList(pDescriptListAlloc);
        }
        else
        {
            // Save the rule description
            _InsertDescription(&pDescriptList, pDescriptListAlloc);
            pDescriptListAlloc = NULL;                           
            cDescriptList++;
        }
        
        SafeMemFree(pszText);
    }

    // Set the outgoing params
    *ppDescriptList = pDescriptList;
    pDescriptList = NULL;
    *pcDescriptList = cDescriptList;

    // Set the return value
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptList);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeActionValue
//
//  This changes the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeActionValue(RULEDESCRIPT_LIST * pActList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    int                 iRet = 0;
    LONG                lDiff = 0;
    CHARRANGE           chrg;
    FOLDERID            idFolder = FOLDERID_ROOT;
    LPSTR               pszVal = NULL;
    ULONG               ulVal = 0;
    SELECTADDR          selAddr;
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn = {0};
    TCHAR               szFilter[MAX_PATH] = _T("");
    TCHAR               szDefExt[20] = _T("");
    RULEFOLDERDATA *    prfdData = NULL;
    UINT                uiID = 0;

    switch(c_rgEditActList[pActList->ulIndex].typeAct)
    {
        case ACT_TYPE_HIGHLIGHT:
            // Bring up the rename rule dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionColor),
                m_hwndOwner,  _FSelectColorDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        case ACT_TYPE_WATCH:
            // Bring up the watch or ignore dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionWatch),
                m_hwndOwner,  _FSelectWatchDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            // Bring up the change folder dialog
            if ((0 != pActList->propvar.blob.cbSize) && (NULL != pActList->propvar.blob.pBlobData))
            {
                // Validate the rule folder data
                if (S_OK == RuleUtil_HrValidateRuleFolderData((RULEFOLDERDATA *) (pActList->propvar.blob.pBlobData)))
                {
                    idFolder = ((RULEFOLDERDATA *) (pActList->propvar.blob.pBlobData))->idFolder;
                }
            }
        
            hr = SelectFolderDialog(m_hwndOwner, SFD_SELECTFOLDER, idFolder, 
                TREEVIEW_NONEWS | TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_DISABLEROOT | FD_DISABLEOUTBOX | FD_DISABLEINBOX | FD_DISABLESENTITEMS | FD_DISABLESERVERS | FD_FORCEINITSELFOLDER,
                (c_rgEditActList[pActList->ulIndex].typeAct == ACT_TYPE_COPY) ? MAKEINTRESOURCE(idsCopy) : MAKEINTRESOURCE(idsMove),
                (c_rgEditActList[pActList->ulIndex].typeAct == ACT_TYPE_COPY) ? MAKEINTRESOURCE(idsCopyCaption) : MAKEINTRESOURCE(idsMoveCaption),
                &idFolder);
        
            fRet = (S_OK == hr);
            if (FALSE != fRet)
            {
                STOREUSERDATA   UserData = {0};
            
                // Create space for the data structure
                hr = HrAlloc((VOID **) &prfdData, sizeof(*prfdData));
                if (FAILED(hr))
                {
                    goto exit;
                }
            
                // Initialize the data struct
                ZeroMemory(prfdData, sizeof(*prfdData));
            
                // Get the timestamp for the store
                hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
                if (FAILED(hr))
                {
                    goto exit;
                }
            
                // Set the timestamp
                prfdData->ftStamp = UserData.ftCreated;
                prfdData->idFolder = idFolder;
            
                // Set the folder id
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_BLOB;
                pActList->propvar.blob.cbSize = sizeof(*prfdData);
                pActList->propvar.blob.pBlobData = (BYTE *) prfdData;
                prfdData = NULL;
            }
            break;
        
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            // Bring up the select file dialog
            hr = HrAlloc((void **) &pszVal, MAX_PATH * sizeof(*pszVal));
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
        
            pszVal[0] = '\0';
            if (NULL != pActList->propvar.pszVal)
            {
                StrCpyN(pszVal, pActList->propvar.pszVal, MAX_PATH * sizeof(*pszVal));
            }
        
            if (ACT_TYPE_NOTIFYSND == c_rgEditActList[pActList->ulIndex].typeAct)
            {
                uiID = idsRuleNtfySndFilter;
            }
            else
            {
                uiID = idsRuleReplyWithFilter;
            }
        
            // Load Res Strings
            LoadStringReplaceSpecial(uiID, szFilter, sizeof(szFilter));
        
            // Setup Save file struct
            ofn.lStructSize = sizeof (ofn);
            ofn.hwndOwner = m_hwndOwner;
            ofn.lpstrFilter = szFilter;
            ofn.nFilterIndex = 2;
            ofn.lpstrFile = pszVal;
            ofn.nMaxFile = MAX_PATH * sizeof(*pszVal);
            ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
            hr = HrAthGetFileName(&ofn, TRUE);
        
            fRet = (S_OK == hr);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_LPSTR;
                pActList->propvar.pszVal = pszVal;
                pszVal = NULL;
            }
            break;
        
        case ACT_TYPE_FWD:
        {
            LPWSTR pwszVal = NULL;
            if (NULL != pActList->propvar.pszVal)
            {
                pwszVal = PszToUnicode(CP_ACP, pActList->propvar.pszVal);
                if (!pwszVal)
                {
                    fRet = FALSE;
                    break;
                }
            }
            
            // Bring up the address picker
            selAddr.lRecipType = MAPI_TO;
            selAddr.uidsWell = idsRulePickForwardTo;
            selAddr.pwszAddr = pwszVal;
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionFwd),
                m_hwndOwner,  _FSelectAddrDlgProc,
                (LPARAM) &selAddr);
            pwszVal = selAddr.pwszAddr;
            
            fRet = (iRet == IDOK);        
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_LPSTR;
                pActList->propvar.pszVal = PszToANSI(CP_ACP, pwszVal);
                pwszVal = NULL;                
            }
            MemFree(pwszVal);
            break;
        }
        
        case ACT_TYPE_SHOW:
            // Bring up the watch or ignore dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionsShow),
                m_hwndOwner,  _FSelectShowDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    // Update the description field if neccessary
    if (FALSE != fRet)
    {
        // ZIFF
        // Can we be sure we are really OK??
        pActList->fError = FALSE;
        
        // If we have something to build up
        if (VT_EMPTY != pActList->propvar.vt)
        {
            if (FALSE == _FBuildActionText(c_rgEditActList[pActList->ulIndex].typeAct, &(pActList->propvar), &pszText))
            {
                goto exit;
            }
            
            SafeMemFree(pActList->pszText);
            pActList->pszText = pszText;
            pszText = NULL;
        }
        ShowDescriptionString();
    }
    
exit:
    SafeMemFree(prfdData);
    SafeMemFree(pszVal);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildActionText
//
//  This changes the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FBuildActionText(ACT_TYPE type, PROPVARIANT * ppropvar, LPSTR * ppszText)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    TCHAR               szRes[CCHMAX_STRINGRES];
    HRESULT             hr = S_OK;
    FOLDERINFO          Folder={0};
    UINT                uiId = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    if ((NULL == ppropvar) || (NULL == ppszText))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(type)
    {
        case ACT_TYPE_HIGHLIGHT:
            LoadString(g_hLocRes, ppropvar->ulVal + idsAutoColor,
                szRes, sizeof(szRes)/sizeof(TCHAR));
            pszText = PszDupA(szRes);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_WATCH:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // Figure out which string to use
            switch (ppropvar->ulVal)
            {
                case ACT_DATA_WATCHTHREAD:
                    uiId = idsThreadWatch;
                    break;
            
                case ACT_DATA_IGNORETHREAD:
                    uiId = idsThreadIgnore;
                    break;
            
                default:
                    uiId = idsThreadNone;
                    break;
            }
        
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            if ((0 == ppropvar->blob.cbSize) || (NULL == ppropvar->blob.pBlobData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            prfdData = (RULEFOLDERDATA *) (ppropvar->blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszText = PszDupA(Folder.pszName);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            pszText = PszDupA(ppropvar->pszVal);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case ACT_TYPE_FWD:
        {
            LPWSTR  pwszVal = PszToUnicode(CP_ACP, ppropvar->pszVal),
                    pwszText = NULL;

            if (ppropvar->pszVal && !pwszVal)
            {
                fRet = FALSE;
                goto exit;
            }

            // Update the display string
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszVal);

            pszText = PszToANSI(CP_ACP, pwszText);
            if (pwszText && !pszText)
            {
                fRet = FALSE;
                goto exit;
            }

            MemFree(pwszText);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        }
            
        case ACT_TYPE_SHOW:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            switch (ppropvar->ulVal)
            {
                case ACT_DATA_SHOW:
                    uiId = idsShowMessages;
                    break;
                
                case ACT_DATA_HIDE:
                    uiId = idsHideMessages;
                    break;
                
                default:
                    uiId = idsShowHideMessages;
                    break;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }
    
    *ppszText = pszText;
    pszText = NULL;

    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    g_pStore->FreeRecord(&Folder);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FVerifyAction
//
//  This verifies the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FVerifyAction(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    HRESULT             hr = S_OK;
    FOLDERINFO          Folder={0};
    RULEFOLDERDATA *    prfdData = NULL;

    if (NULL == pDescriptList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(c_rgEditActList[pDescriptList->ulIndex].typeAct)
    {
        // These ones are always valid
        case ACT_TYPE_DELETESERVER:
        case ACT_TYPE_DONTDOWNLOAD:
        case ACT_TYPE_FLAG:
        case ACT_TYPE_READ:
        case ACT_TYPE_MARKDOWNLOAD:
        case ACT_TYPE_DELETE:
        case ACT_TYPE_JUNKMAIL:
        case ACT_TYPE_STOP:
            if (VT_EMPTY != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_HIGHLIGHT:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_WATCH:
        case ACT_TYPE_SHOW:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                hr = S_FALSE;
                goto exit;
            }
        
            if (ACT_DATA_NULL == pDescriptList->propvar.ulVal)
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize))
            {
                hr = S_FALSE;
                goto exit;
            }
        
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pDescriptList->propvar.blob.pBlobData);
        
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
        
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                hr = S_FALSE;
                goto exit;
            }        
            else
                g_pStore->FreeRecord(&Folder);
            break;
        
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                fRet = FALSE;
                goto exit;
            }
        
            Assert(lstrlen(pDescriptList->propvar.pszVal) <= MAX_PATH)
                if (0xFFFFFFFF == GetFileAttributes(pDescriptList->propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            
        case ACT_TYPE_FWD:
        {
            LPWSTR  pwszVal = NULL,
                    pwszText = NULL;
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                AssertSz(VT_LPWSTR != pDescriptList->propvar.vt, "We have UNICODE coming in.");
                fRet = FALSE;
                goto exit;
            }
        
            // Update the display string
            pwszVal = PszToUnicode(CP_ACP, pDescriptList->propvar.pszVal);
            if (!pwszVal)
            {
                fRet = FALSE;
                goto exit;
            }
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszText);
            MemFree(pwszVal);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // If either always encrypt or always sign is turned on
            // we can't do anything
            if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        }
        
        default:
            fRet = FALSE;
            goto exit;
            break;
    }
    
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _UpdateRanges
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_UpdateRanges(LONG lDiff, ULONG ulStart)
{
    TCHAR               szRes[CCHMAX_STRINGRES + 3];
    ULONG               cchRes = 0;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;

    if (0 == lDiff)
    {
        goto exit;
    }
    
    // Update the criteria ranges
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulStartLogic > ulStart)
        {
            pDescriptListWalk->ulStartLogic += lDiff;
            pDescriptListWalk->ulEndLogic += lDiff;
            
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
        else if (pDescriptListWalk->ulStart > ulStart)
        {
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
    }

    // Update the action ranges
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulStart > ulStart)
        {
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
    }
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _InsertDescription
//
//  This adds a description node to the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_InsertDescription(RULEDESCRIPT_LIST ** ppDescriptList,
            RULEDESCRIPT_LIST * pDescriptListNew)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    RULEDESCRIPT_LIST * pDescriptListPrev = NULL;
    
    Assert(NULL != ppDescriptList);

    // Search for the proper place to place the new item
    for (pDescriptListWalk = *ppDescriptList;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulIndex > pDescriptListNew->ulIndex)
        {
            break;
        }

        // Save off the old description
        pDescriptListPrev = pDescriptListWalk;
    }

    // If it's supposed to go at the top
    if (NULL == pDescriptListPrev)
    {
        *ppDescriptList = pDescriptListNew;
        pDescriptListNew->pNext = pDescriptListWalk;
    }
    else
    {
        pDescriptListNew->pNext = pDescriptListWalk;
        pDescriptListPrev->pNext = pDescriptListNew;
    }
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FRemoveDescription
//
//  This adds a description node to the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FRemoveDescription(RULEDESCRIPT_LIST ** ppDescriptList, ULONG ulIndex,
            RULEDESCRIPT_LIST ** ppDescriptListRemove)
{
    BOOL                fRet = FALSE;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    RULEDESCRIPT_LIST * pDescriptListPrev = NULL;
    
    Assert((NULL != ppDescriptList) && (NULL != ppDescriptListRemove));

    *ppDescriptListRemove = NULL;
    
    // Find the criteria item in the list
    for (pDescriptListWalk = *ppDescriptList;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (ulIndex == pDescriptListWalk->ulIndex)
        {
            break;
        }

        // Save off the old description
        pDescriptListPrev = pDescriptListWalk;
    }

    // Did we find the criteria item?
    if (NULL == pDescriptListWalk)
    {
        fRet = FALSE;
        goto exit;
    }

    // Remove the criteria item from the list
    if (NULL == pDescriptListPrev)
    {
        *ppDescriptList = pDescriptListWalk->pNext;
    }
    else
    {
        pDescriptListPrev->pNext = pDescriptListWalk->pNext;
    }
    pDescriptListWalk->pNext = NULL;

    // Set the outgoing params
    *ppDescriptListRemove = pDescriptListWalk;
    
    // Set the return value
    fRet = TRUE;
    
exit:        
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FreeDescriptionLists
//
//  This frees the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_FreeDescriptionList(RULEDESCRIPT_LIST * pDescriptList)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    
    while (NULL != pDescriptList)
    {
        pDescriptListWalk = pDescriptList;
        
        SafeMemFree(pDescriptListWalk->pszText);
        PropVariantClear(&(pDescriptListWalk->propvar));

        pDescriptList = pDescriptListWalk->pNext;
        MemFree(pDescriptListWalk);
    }
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnDescriptClick
//
//  This handles clicking on the links in the description field
//
//  uiMsg   - the type of click
//  ulIndex - which criteria/action to change
//  fCrit   - did we click on a criteria?
//  fLogic  - did we click on a logic op?
//
//  Returns:    TRUE, we changed the criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FOnDescriptClick(UINT uiMsg, RULEDESCRIPT_LIST * pDescriptList, BOOL fCrit, BOOL fLogic)
{
    BOOL            fRet = FALSE;
    CHARRANGE       chrg;
    NMHDR           nmhdr;

    if ((WM_LBUTTONUP == uiMsg) || (WM_KEYDOWN == uiMsg))
    {
        // Release the capture if there is one
        if (NULL != GetCapture())
        {
            ReleaseCapture();
        }
        
        // Did we click in the logic op?
        if (fLogic)
        {
            fRet = _FChangeLogicValue(pDescriptList);
        }
        // Did we click in the criteria list?
        else if (fCrit)
        {
            fRet = _FChangeCriteriaValue(pDescriptList);
        }
        else
        {
            fRet = _FChangeActionValue(pDescriptList);
        }

        if (fRet)
        {
            m_dwState |= STATE_DIRTY;

            // Tell the parent dialog something has changed
            nmhdr.hwndFrom = m_hwndOwner;
            nmhdr.idFrom = GetDlgCtrlID(m_hwndOwner);
            nmhdr.code = NM_RULE_CHANGED;
            SendMessage(GetParent(m_hwndOwner), WM_NOTIFY, (WPARAM) (nmhdr.idFrom), (LPARAM) &nmhdr);
        }

        fRet = TRUE;
    }

    if (((WM_LBUTTONDOWN == uiMsg) || (WM_LBUTTONDBLCLK == uiMsg)) &&
                                (0 == (GetAsyncKeyState(VK_CONTROL) & 0x8000)))
    {
        if (fLogic)
        {
            chrg.cpMin = pDescriptList->ulStartLogic;
            chrg.cpMax = pDescriptList->ulEndLogic;
        }
        else
        {
            chrg.cpMin = pDescriptList->ulStart;
            chrg.cpMax = pDescriptList->ulEnd;
        }

        // Need to make sure we show the selection
        SendMessage(m_hwndOwner, EM_HIDESELECTION, (WPARAM) FALSE, (LPARAM) FALSE);
        RichEditExSetSel(m_hwndOwner, &chrg);

        fRet = TRUE;
    }
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInLink
//
//  Given a point in the control, this will tell us whether or not the point
//  is in a link
//
//  ppt         - the point to check
//  pulIndex    - which criteria/action is the point in
//  pfCrit      - is the point over a criteria?
//  pfLogic     - is the point over a logic op?
//
//  Returns:    TRUE, if the point is over a criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FInLink(int chPos, RULEDESCRIPT_LIST ** ppDescriptList,
            BOOL * pfCrit, BOOL * pfLogic)
{
    BOOL    fFound = FALSE;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    POINT   pt;
    ULONG   ulIndex = 0;
    BOOL    fCrit = FALSE;
    BOOL    fLogic = FALSE;
    LONG    idxLine = 0;
    LPSTR   pszBuff = NULL;
    ULONG   cchBuff = 0;
    HDC     hdc = NULL;
    HFONT   hfont = NULL;
    HFONT   hfontOld = NULL;
    SIZE    size;
    LONG    idxPosLine = 0;

    // If we're read only then we can't be in a link
    if ((0 != (m_dwState & STATE_READONLY)) || (0 == chPos))
    {
        fFound = FALSE;
        goto exit;
    }
    
    // Did we click in the criteria list?
    for (pDescriptListWalk = m_pDescriptListCrit;
                NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (((LONG) pDescriptListWalk->ulStart <= chPos) &&
                        ((LONG) pDescriptListWalk->ulEnd >= chPos))
        {
            fCrit = TRUE;
            fFound = TRUE;
            break;
        }

        if (((LONG) pDescriptListWalk->ulStartLogic <= chPos) &&
                        ((LONG) pDescriptListWalk->ulEndLogic >= chPos))
        {
            fLogic = TRUE;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        // Did we click in the actions list
        for (pDescriptListWalk = m_pDescriptListAct;
                    NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
        {
            if (((LONG) pDescriptListWalk->ulStart <= chPos) &&
                            ((LONG) pDescriptListWalk->ulEnd >= chPos))
            {
                fFound = TRUE;
                break;
            }
        }
    }

    if (ppDescriptList)
    {
        *ppDescriptList = pDescriptListWalk;
    }
    
    if (pfCrit)
    {
        *pfCrit = fCrit;
    }
    
    if (pfLogic)
    {
        *pfLogic = fLogic;
    }
    goto exit; 
    
exit:
    if (NULL != hdc)
    {
        ReleaseDC(m_hwndOwner, hdc);
    }
    MemFree(pszBuff);
    return fFound;
}

VOID _SearchForLink(RULEDESCRIPT_LIST * pDescriptList, BOOL fUp, LONG lPos, CHARRANGE * pcrPos)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;

    Assert(NULL != pcrPos);
    
    // Find the closest link...
    for (pDescriptListWalk = pDescriptList;
                NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we have a criteria link?
        if (0 != pDescriptListWalk->ulStart)
        {
            // Are we going down?
            if (FALSE == fUp)
            {
                // Is the link past the current position?
                if ((LONG) pDescriptListWalk->ulEnd > lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStart < pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStart;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEnd;
                    }
                }
            }
            else
            {
                // Is the link before the current position?
                if ((LONG) pDescriptListWalk->ulEnd < lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStart > pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStart;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEnd;
                    }
                }
            }
        }

        // Do we have a logic link?
        if (0 != pDescriptListWalk->ulStartLogic)
        {
            // Are we going down?
            if (FALSE == fUp)
            {
                // Is the link past the current position?
                if ((LONG) pDescriptListWalk->ulEndLogic > lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStartLogic < pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStartLogic;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEndLogic;
                    }
                }
            }
            else
            {
                // Is the link before the current position?
                if ((LONG) pDescriptListWalk->ulEndLogic < lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStartLogic > pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStartLogic;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEndLogic;
                    }
                }
            }
        }
    }

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FMoveToLink
//
//  Given a point in the control, this will tell us whether or not the point
//  is in a link
//
//  ppt         - the point to check
//  pulIndex    - which criteria/action is the point in
//  pfCrit      - is the point over a criteria?
//  pfLogic     - is the point over a logic op?
//
//  Returns:    TRUE, if the point is over a criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FMoveToLink(UINT uiKeyCode)
{
    BOOL                fRet = FALSE;
    BOOL                fUp = FALSE;
    CHARRANGE           crPos = {0};
    CHARRANGE           crLink = {0};

    // Figure out which way we are going
    fUp = ((VK_LEFT == uiKeyCode) || (VK_UP == uiKeyCode));
    
    // Get the current character position
    RichEditExGetSel(m_hwndOwner, &crPos);

    // Find the closest link in the criteria
    _SearchForLink(m_pDescriptListCrit, fUp, crPos.cpMax, &crLink);
    
    // Find the closest link in the actions
    _SearchForLink(m_pDescriptListAct, fUp, crPos.cpMax, &crLink);

    // Do we have anything to do?
    if (0 != crLink.cpMin)
    {
        // Set the new selection
        RichEditExSetSel(m_hwndOwner, &crLink);
        SendMessage(m_hwndOwner, EM_SCROLLCARET, (WPARAM) 0, (LPARAM) 0);

        fRet = TRUE;
    }
    
    return fRet;
}

LRESULT CALLBACK CRuleDescriptUI::_DescriptWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT             lRes = 0;
    POINT               ptCur;
    CRuleDescriptUI *   pDescriptUI = NULL;
    HCURSOR             hcursor = NULL;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    BOOL                fCrit = FALSE;
    BOOL                fLogic = FALSE;
    CHARRANGE           crPos = {0};
    int                 chPos = 0;
    
    pDescriptUI = (CRuleDescriptUI *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_SETCURSOR:
            if((FALSE != IsWindowVisible(hwnd)) && ((HWND) wParam == hwnd))
            {
                lRes = DefWindowProc(hwnd, uiMsg, wParam, lParam);
                if(0 == lRes)
                {
                    GetCursorPos(&ptCur);
                    ScreenToClient(hwnd, &ptCur);
                    chPos = (int) SendMessage(hwnd, EM_CHARFROMPOS, (WPARAM)0, (LPARAM)&ptCur);
                    chPos = RichEditNormalizeCharPos(hwnd, chPos, NULL);
                    if (FALSE != pDescriptUI->_FInLink(chPos, NULL, NULL, NULL))
                    {
                        hcursor = LoadCursor(g_hLocRes, MAKEINTRESOURCE(idcurBrHand));
                        SetCursor(hcursor);
                        lRes = TRUE;
                    }
                }
            }                
            break;
        
        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONUP:
            GetCursorPos(&ptCur);
            ScreenToClient(hwnd, &ptCur);
            chPos = (int) SendMessage(hwnd, EM_CHARFROMPOS, (WPARAM)0, (LPARAM)&ptCur);
            chPos = RichEditNormalizeCharPos(hwnd, chPos, NULL);
            if (FALSE != pDescriptUI->_FInLink(chPos, &pDescriptList, &fCrit, &fLogic))
            {
                // Change the proper value
                lRes = pDescriptUI->_FOnDescriptClick(uiMsg, pDescriptList, fCrit, fLogic);
            }
            break;
        
        case WM_KEYDOWN:
            switch (wParam)
            {
                case VK_RETURN:
                    RichEditExGetSel(hwnd, &crPos);
                    if (FALSE != pDescriptUI->_FInLink(crPos.cpMin, &pDescriptList, &fCrit, &fLogic))
                    {
                        // Change the proper value
                        lRes = pDescriptUI->_FOnDescriptClick(uiMsg, pDescriptList, fCrit, fLogic);
                    }
                    break;
            
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                    lRes = pDescriptUI->_FMoveToLink((UINT) wParam);
                    break;
            }
            break;
    }
    
    if (0 == lRes)
    {
        lRes = CallWindowProc(pDescriptUI->m_wpcOld, hwnd, uiMsg, wParam, lParam);
    }
    
    return lRes;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAddrDlgProc
//
//  This is the main dialog proc for changing addresses
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAddrDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    SELECTADDR *    pseladdr = NULL;
    HWND            hwndAddr = NULL;
    LPWSTR          pwszText = NULL,
                    pwszAddr = NULL;
    ULONG           cchText = 0,
                    cchAddr = 0;
    HRESULT         hr = S_OK;

    pseladdr = (SELECTADDR *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pseladdr = (SELECTADDR *) lParam;
            if (NULL == pseladdr)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pseladdr);

            hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
            
            SetIntlFont(hwndAddr);
            
            // Set the name of the rule into the edit well
            if (NULL == pseladdr->pwszAddr)
            {
                Edit_SetText(hwndAddr, c_szEmpty);
            }
            else
            {
                if (FAILED(RuleUtil_HrParseEmailString(pseladdr->pwszAddr, 0, &pwszText, NULL)))
                {
                    fRet = FALSE;
                    EndDialog(hwndDlg, -1);
                    goto exit;
                }
                SetWindowTextWrapW(hwndAddr, pwszText);
                SafeMemFree(pwszText);
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idedtCriteriaAddr:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndAddr = (HWND) lParam;
                        Assert(NULL != hwndAddr);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndAddr));
                    }
                    break;
                
                case idbCriteriaAddr:
                    hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
                    
                    // Get the name of the rule from the edit well
                    cchText = Edit_GetTextLength(hwndAddr) + 1;
                    if (FAILED(HrAlloc((void **) &pwszText, cchText * sizeof(*pwszText))))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    pwszText[0] = L'\0';
                    cchText = GetWindowTextWrapW(hwndAddr, pwszText, cchText);
                    
                    hr = RuleUtil_HrBuildEmailString(pwszText, cchText, &pwszAddr, &cchAddr);
                    SafeMemFree(pwszText);
                    if (FAILED(hr))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    hr = RuleUtil_HrPickEMailNames(hwndDlg, pseladdr->lRecipType, pseladdr->uidsWell, &pwszAddr);
                    if (S_OK != hr)
                    {
                        fRet = FALSE;
                        SafeMemFree(pwszAddr);
                        goto exit;
                    }
                    
                    if (S_OK != RuleUtil_HrParseEmailString(pwszAddr, 0, &pwszText, NULL))
                    {
                        fRet = FALSE;
                        SafeMemFree(pwszAddr);
                        goto exit;
                    }

                    SetWindowTextWrapW(hwndAddr, pwszText);
                    SafeMemFree(pwszText);
                    SafeMemFree(pwszAddr);
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
                    
                    // Get the name of the rule from the edit well
                    cchText = Edit_GetTextLength(hwndAddr) + 1;
                    if (FAILED(HrAlloc((void **) &pwszText, cchText * sizeof(*pwszText))))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    pwszText[0] = L'\0';
                    cchText = GetWindowTextWrapW(hwndAddr, pwszText, cchText);
                    
                    // Check to see if the rule name is valid
                    if ((FAILED(RuleUtil_HrBuildEmailString(pwszText, cchText, &pwszAddr, &cchAddr))) ||
                                    (0 == cchAddr))
                    {
                        // Put up a message saying something is busted
                        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                        MAKEINTRESOURCEW(idsRulesErrorNoAddr), NULL,
                                        MB_OK | MB_ICONINFORMATION);
                        SafeMemFree(pwszText);
                        SafeMemFree(pwszAddr);
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    SafeMemFree(pseladdr->pwszAddr);
                    pseladdr->pwszAddr = pwszAddr;
                    SafeMemFree(pwszText);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}
///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAcctDlgProc
//
//  This is the main dialog proc for selecting an account dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAcctDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    SELECTACCT *        pselacct = NULL;
    LPSTR               pszAcct = NULL;
    ULONG               cchAcct = 0;
    HWND                hwndAcct = NULL;
    CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
    IImnAccount *       pAccount = NULL;
    IImnEnumAccounts *  pEnumAcct = NULL;
    DWORD               dwSrvTypes = 0;
    ULONG               ulIndex = 0;
    BOOL                fSelected = FALSE;
    
    pselacct = (SELECTACCT *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pselacct = (SELECTACCT *) lParam;
            if (NULL == pselacct)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pselacct);

            hwndAcct = GetDlgItem(hwndDlg, idcCriteriaAcct);
            
            SetIntlFont(hwndAcct);
            
            // Set the name of the rule into the edit well
            Assert(g_pAcctMan);

            switch (pselacct->typeRule)
            {
                case RULE_TYPE_MAIL:
                    dwSrvTypes = SRV_POP3;
                    break;

                case RULE_TYPE_NEWS:
                    dwSrvTypes = SRV_NNTP;
                    break;

                case RULE_TYPE_FILTER:
                    dwSrvTypes = SRV_MAIL | SRV_NNTP;
                    break;
            }
            
            // Grab the enumerator from the account manager
            if (FAILED(g_pAcctMan->Enumerate(dwSrvTypes, &pEnumAcct)))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // Insert each account into the combobox
            while(SUCCEEDED(pEnumAcct->GetNext(&pAccount)))
            {
                // We can get back NULL accounts
                if (NULL == pAccount)
                {
                    break;
                }
                
                // Add the account string to the combobox
                if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, sizeof(szAccount))))
                {
                    SafeRelease(pAccount);
                    continue;
                }

                ulIndex = ComboBox_AddString(hwndAcct, szAccount);
                if (CB_ERR == ulIndex)
                {
                    fRet = FALSE;
                    SafeRelease(pEnumAcct);
                    SafeRelease(pAccount);
                    EndDialog(hwndDlg, -1);
                    goto exit;
                }
                
                if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
                {
                    SafeRelease(pAccount);
                    continue;
                }

                // Set the default selection if we have one
                if ((NULL != pselacct->pszAcct) && (0 == lstrcmp(pselacct->pszAcct, szAccount)))
                {
                    Assert(FALSE == fSelected);
                    ComboBox_SetCurSel(hwndAcct, ulIndex);
                    fSelected = TRUE;
                }

                // Release it
                SafeRelease(pAccount);
            }

            SafeRelease(pEnumAcct);
            
            if (FALSE == fSelected)
            {
                ComboBox_SetCurSel(hwndAcct, 0);
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {            
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndAcct = GetDlgItem(hwndDlg, idcCriteriaAcct);
                    
                    // Get the account name that was selected
                    ulIndex = ComboBox_GetCurSel(hwndAcct);
                    if (CB_ERR == ulIndex)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    cchAcct = ComboBox_GetLBText(hwndAcct, ulIndex, szAccount);
                    if (0 == cchAcct)
                    {
                        fRet = FALSE;
                        goto exit;
                    }

                    Assert(g_pAcctMan);
                    if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
                    {
                        fRet = FALSE;
                        SafeRelease(pAccount);
                        goto exit;
                    }

                    // Release it
                    SafeRelease(pAccount);
                    
                    pszAcct = PszDupA(szAccount);
                    if (NULL == pszAcct)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    SafeMemFree(pselacct->pszAcct);
                    pselacct->pszAcct = pszAcct;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectColorDlgProc
//
//  This is the main dialog proc for selecting a color dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectColorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    ULONG *             pulColor = NULL;
    ULONG               ulColor = NULL;
    HWND                hwndColor = NULL;
    HDC                 hdc = NULL;
    LPMEASUREITEMSTRUCT pmis = NULL;
    LPDRAWITEMSTRUCT    pdis = NULL;
    
    pulColor = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulColor = (ULONG *) lParam;
            if (NULL == pulColor)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulColor);

            hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
            
            SetIntlFont(hwndColor);
            
            // Let's create the color control
            if (FAILED(HrCreateComboColor(hwndColor)))
            {
                fRet = FALSE;
                goto exit;
            }    
            
            if (0 != *pulColor)
            {
                ulColor = *pulColor;
            }
            
            ComboBox_SetCurSel(hwndColor, ulColor);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {            
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
                    
                    // Get the account name that was selected
                    ulColor = ComboBox_GetCurSel(hwndColor);
                    if (CB_ERR == ulColor)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulColor = ulColor;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
        
        case WM_DRAWITEM:
            pdis = (LPDRAWITEMSTRUCT)lParam;
            Assert(pdis);
            Color_WMDrawItem(pdis, iColorCombo);
            fRet = FALSE;
            break;

        case WM_MEASUREITEM:
            pmis = (LPMEASUREITEMSTRUCT)lParam;
            hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
            hdc = GetDC(hwndColor);
            if(hdc)
            {
                Color_WMMeasureItem(hdc, pmis, iColorCombo);
                ReleaseDC(hwndColor, hdc);
            }
            fRet = TRUE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectSizeDlgProc
//
//  This is the main dialog proc for selecting the size dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectSizeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulSize = NULL;
    HWND            hwndSize = NULL;
    HWND            hwndText = NULL;
    ULONG           ulSize = 0;

    pulSize = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulSize = (ULONG *) lParam;
            if (NULL == pulSize)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulSize);

            hwndSize = GetDlgItem(hwndDlg, idspnCriteriaSize);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaSize);
            
            SetIntlFont(hwndText);
            SendMessage(hwndSize, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulSize)
            {
                SendMessage(hwndSize, UDM_SETPOS, 0, MAKELONG( (short) *pulSize, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaSize:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndSize = GetDlgItem(hwndDlg, idspnCriteriaSize);
                    
                    // Get the name of the rule from the edit well
                    ulSize = (INT) SendMessage(hwndSize, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulSize))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulSize = LOWORD(ulSize);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectLinesDlgProc
//
//  This is the main dialog proc for selecting the count of lines dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectLinesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulLines = NULL;
    HWND            hwndLines = NULL;
    HWND            hwndText = NULL;
    ULONG           ulLines = 0;

    pulLines = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulLines = (ULONG *) lParam;
            if (NULL == pulLines)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulLines);

            hwndLines = GetDlgItem(hwndDlg, idspnCriteriaLines);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaLines);
            
            SetIntlFont(hwndText);
            SendMessage(hwndLines, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulLines)
            {
                SendMessage(hwndLines, UDM_SETPOS, 0, MAKELONG( (short) *pulLines, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaLines:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                    
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndLines = GetDlgItem(hwndDlg, idspnCriteriaLines);
                    
                    // Get the name of the rule from the edit well
                    ulLines = (INT) SendMessage(hwndLines, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulLines))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulLines = LOWORD(ulLines);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAgeDlgProc
//
//  This is the main dialog proc for selecting the count of lines dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAgeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulDays = NULL;
    HWND            hwndDays = NULL;
    HWND            hwndText = NULL;
    ULONG           ulDays = 0;

    pulDays = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulDays = (ULONG *) lParam;
            if (NULL == pulDays)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulDays);

            hwndDays = GetDlgItem(hwndDlg, idspnCriteriaAge);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaAge);
            
            SetIntlFont(hwndText);
            SendMessage(hwndDays, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulDays)
            {
                SendMessage(hwndDays, UDM_SETPOS, 0, MAKELONG( (short) *pulDays, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaLines:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndDays = GetDlgItem(hwndDlg, idspnCriteriaAge);
                    
                    // Get the name of the rule from the edit well
                    ulDays = (INT) SendMessage(hwndDays, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulDays))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulDays = LOWORD(ulDays);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectPriorityDlgProc
//
//  This is the main dialog proc for selecting the priority dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectPriorityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulPri = NULL;
    ULONG           ulPri = 0;

    pulPri = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulPri = (ULONG *) lParam;
            if (NULL == pulPri)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulPri);

            // Set the default item
            CheckDlgButton(hwndDlg, (CRIT_DATA_LOPRI == *pulPri) ? idcCriteriaLowPri : idcCriteriaHighPri, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaLowPri))
                    {
                        ulPri = CRIT_DATA_LOPRI;
                    }
                    else
                    {
                        ulPri = CRIT_DATA_HIPRI;
                    }
                    
                    *pulPri = ulPri;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectSecureDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectSecureDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulSec = NULL;
    ULONG           ulSec = 0;
    UINT            uiId = 0;

    pulSec = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulSec = (ULONG *) lParam;
            if (NULL == pulSec)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulSec);

            // Set the default item
            if (0 != ((*pulSec) & CRIT_DATA_ENCRYPTSECURE))
            {
                uiId = idcCriteriaEncrypt;
            }
            else
            {
                uiId = idcCriteriaSigned;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaSigned))
                    {
                        ulSec = CRIT_DATA_SIGNEDSECURE;
                    }
                    else
                    {
                        ulSec = CRIT_DATA_ENCRYPTSECURE;
                    }
                    
                    *pulSec = ulSec;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectThreadStateDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectThreadStateDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulThread = NULL;
    ULONG           ulThread = 0;
    UINT            uiId = 0;

    pulThread = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulThread = (ULONG *) lParam;
            if (NULL == pulThread)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulThread);

            // Set the default item
            if (0 != ((*pulThread) & CRIT_DATA_IGNORETHREAD))
            {
                uiId = idcCriteriaIgnoreThread;
            }
            else
            {
                uiId = idcCriteriaWatchThread;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaWatchThread))
                    {
                        ulThread = CRIT_DATA_WATCHTHREAD;
                    }
                    else
                    {
                        ulThread = CRIT_DATA_IGNORETHREAD;
                    }
                    
                    *pulThread = ulThread;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectShowDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectShowDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (ACT_DATA_HIDE == *pulVal)
            {
                uiId = idcCriteriaHide;
            }
            else
            {
                uiId = idcCriteriaShow;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaHide))
                    {
                        *pulVal = ACT_DATA_HIDE;
                    }
                    else
                    {
                        *pulVal = ACT_DATA_SHOW;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectShowDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectLogicDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CRIT_LOGIC *    plogicCrit = NULL;
    UINT            uiId = 0;

    plogicCrit = (CRIT_LOGIC *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            plogicCrit = (CRIT_LOGIC *) lParam;
            if (NULL == plogicCrit)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) plogicCrit);

            // Set the default item
            if (CRIT_LOGIC_OR == (*plogicCrit))
            {
                uiId = idcCriteriaOr;
            }
            else
            {
                uiId = idcCriteriaAnd;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaAnd))
                    {
                        *plogicCrit = CRIT_LOGIC_AND;
                    }
                    else
                    {
                        *plogicCrit = CRIT_LOGIC_OR;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectFlagDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectFlagDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNoFlag;
            }
            else
            {
                uiId = idcCriteriaFlag;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNoFlag))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectDownloadedDlgProc
//
//  This is the main dialog proc for selecting the downloaded dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectDownloadedDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNotDownloaded;
            }
            else
            {
                uiId = idcCriteriaDownloaded;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNotDownloaded))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectReadDlgProc
//
//  This is the main dialog proc for selecting the read state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectReadDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNotRead;
            }
            else
            {
                uiId = idcCriteriaRead;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNotRead))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectWatchDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectWatchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulThread = NULL;
    ULONG           ulThread = 0;
    UINT            uiId = 0;

    pulThread = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulThread = (ULONG *) lParam;
            if (NULL == pulThread)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulThread);

            // Set the default item
            if (ACT_DATA_IGNORETHREAD == *pulThread)
            {
                uiId = idcActionsIgnoreThread;
            }
            else
            {
                uiId = idcActionsWatchThread;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcActionsWatchThread))
                    {
                        ulThread = ACT_DATA_WATCHTHREAD;
                    }
                    else
                    {
                        ulThread = ACT_DATA_IGNORETHREAD;
                    }
                    
                    *pulThread = ulThread;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

// Class definitions
class CEditPeopleOptionsUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        CRIT_ITEM *         m_pCritItem;
    
    public:
        CEditPeopleOptionsUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                                m_hwndDlg(NULL), m_hwndList(NULL), m_pCritItem(NULL) {}
        ~CEditPeopleOptionsUI();

        // The main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(CRIT_ITEM * pCritItem);
                
        // The Rules Manager dialog function
        static INT_PTR CALLBACK FEditPeopleOptionsDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

        // Message handling functions
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis);
        BOOL FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis);

    private:
        BOOL _FLoadCtrls(VOID);
        BOOL _FOnOK(DWORD * pdwFlags);
        BOOL _AddTagLineToList(VOID);
        BOOL _FAddWordToList(DWORD dwFlags, LPCTSTR pszItem);
};

typedef struct tagPEOPLEEDITTAG
{
    CRIT_TYPE   type;
    UINT        uiNormal;
    UINT        uiInverted;
} PEOPLEEDITTAG, * PPEOPLEEDITTAG;

static const PEOPLEEDITTAG g_rgpetTagLines[] =
{
    {CRIT_TYPE_TO,      idsCriteriaToEdit,      idsCriteriaToNotEdit},
    {CRIT_TYPE_CC,      idsCriteriaCCEdit,      idsCriteriaCCNotEdit},
    {CRIT_TYPE_FROM,     idsCriteriaFromEdit,    idsCriteriaFromNotEdit},
    {CRIT_TYPE_TOORCC,  idsCriteriaToOrCCEdit,  idsCriteriaToOrCCNotEdit},
    {CRIT_TYPE_SUBJECT, idsCriteriaSubjectEdit, idsCriteriaSubjectNotEdit},
    {CRIT_TYPE_BODY,    idsCriteriaBodyEdit,    idsCriteriaBodyNotEdit}
};

static const int g_cpetTagLines = sizeof(g_rgpetTagLines) / sizeof(g_rgpetTagLines[0]);

class CEditPeopleUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndPeople;
        HWND            m_hwndList;
        ULONG           m_cxMaxPixels;
        CRIT_ITEM *     m_pCritItem;

    public:
        CEditPeopleUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndPeople(NULL), m_hwndList(NULL),
                        m_cxMaxPixels(0), m_pCritItem(NULL) {}
        ~CEditPeopleUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(CRIT_ITEM * pCritItem);

        static INT_PTR CALLBACK FEditPeopleDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis);
        BOOL FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis);

    private:
        BOOL _FLoadListCtrl(VOID);
        VOID _AddItemToList(VOID);
        VOID _AddItemsFromWAB(VOID);
        VOID _RemoveItemFromList(VOID);
        VOID _ChangeOptions(VOID);
        BOOL _FOnNameChange(VOID);
        BOOL _FOnOK(CRIT_ITEM * pCritItem);
        VOID _UpdateButtons(VOID);
        BOOL _AddTagLineToList(VOID);
        BOOL _FAddWordToList(DWORD dwFlags, LPCTSTR pszItem);
};

CEditPeopleOptionsUI::~CEditPeopleOptionsUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleOptionsUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      cf;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // We're done
    m_dwState |= STATE_INITIALIZED;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleOptionsUI::HrShow(CRIT_ITEM * pCritItem)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;
    UINT        uiID = 0;

    // Check incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the data
    m_pCritItem = pCritItem;
    
    // Figure out which dialog template to use
    if (0 != (m_dwFlags & PUI_WORDS))
    {
        uiID = iddCriteriaWordsOptions;
    }
    else
    {
        uiID = iddCriteriaPeopleOptions;
    }
    
    // Bring up the editor dialog
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(uiID),
                                        m_hwndOwner,  CEditPeopleOptionsUI::FEditPeopleOptionsDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CEditPeopleOptionsUI::FEditPeopleOptionsDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    CEditPeopleOptionsUI *  pOptionsUI = NULL;

    pOptionsUI = (CEditPeopleOptionsUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pOptionsUI = (CEditPeopleOptionsUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pOptionsUI);

            if (FALSE == pOptionsUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pOptionsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
            
        case WM_MEASUREITEM:
            fRet = pOptionsUI->FOnMeasureItem(hwndDlg, (UINT) wParam, (MEASUREITEMSTRUCT *) lParam);
            break;

        case WM_DRAWITEM:
            fRet = pOptionsUI->FOnDrawItem((UINT) wParam, (DRAWITEMSTRUCT *) lParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit people UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idcCriteriaList);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Load the list view
    fRet = _FLoadCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK(&(m_pCritItem->dwFlags)))
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;

        case idcCriteriaNotCont:
        case idcCriteriaContains:
        case idcCriteriaAnd:
        case idcCriteriaOr:
            if (BN_CLICKED == uiNotify)
            {
                // Make sure the list is redrawn
                InvalidateRect(m_hwndList, NULL, TRUE);
            }
            break;

    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnMeasureItem
//
//  This handles the WM_MEASUREITEM message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis)
{
    BOOL        fRet = FALSE;
    HWND        hwndList = NULL;
    HDC         hdcList = NULL;
    TEXTMETRIC  tm = {0};
    
    // Get the window handle
    hwndList = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the device context
    hdcList = GetDC(hwndList);
    if (NULL == hdcList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the text metrics for the device context
    GetTextMetrics(hdcList, &tm);

    // Set the item height
    pmis->itemHeight = tm.tmHeight;

    fRet = TRUE;

exit:
    if (NULL != hdcList)
    {
        ReleaseDC(hwndList, hdcList);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDrawItem
//
//  This handles the WM_DRAWITEM message for the people editor UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis)
{
    BOOL        fRet = FALSE;
    DWORD       dwFlags = 0;
    INT         cchText = 0;
    LPTSTR      pszText = NULL;
    LPTSTR      pszString = NULL;
    UINT        uiID = 0;
    TCHAR       rgchRes[CCHMAX_STRINGRES];
    COLORREF    crfBack = NULL;
    COLORREF    crfText = NULL;
    ULONG       ulIndex = 0;
    LPTSTR      pszPrint = NULL;

    // Make sure this is the correct control
    if (ODT_LISTBOX != pdis->CtlType)
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the flags from the dialog
    if (FALSE == _FOnOK(&dwFlags))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Nothing else to do if it's the first item
    if (0 == pdis->itemID)
    {
        for (ulIndex = 0; ulIndex < g_cpetTagLines; ulIndex++)
        {
            if (g_rgpetTagLines[ulIndex].type == m_pCritItem->type)
            {
                if (0 != (dwFlags & CRIT_FLAG_INVERT))
                {
                    uiID = g_rgpetTagLines[ulIndex].uiInverted;
                }
                else
                {
                    uiID = g_rgpetTagLines[ulIndex].uiNormal;
                }
                break;
            }
        }
        
        // Did we find anything?
        if (ulIndex >= g_cpetTagLines)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Load the item template
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszPrint = rgchRes;
    }
    else
    {
        // Get the size of the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) (pdis->itemID), (LPARAM) 0);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the the string for the item
        if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * (cchText + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Get the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) (pdis->itemID), (LPARAM) pszText);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Figure out which string template to use
        if (1 == pdis->itemID)
        {
            uiID = idsCriteriaEditFirst;
        }
        else
        {
            if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
            {
                uiID = idsCriteriaEditAnd;
            }
            else
            {
                uiID = idsCriteriaEditOr;
            }
        }
        
        // Load the proper string template for the item
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the final string
        DWORD cchSize = (cchText + CCHMAX_STRINGRES + 1);
        if (FAILED(HrAlloc((VOID **) &pszString, sizeof(*pszString) * cchSize)))
        {
            fRet = FALSE;
            goto exit;
        }

        // Create the final string
        wnsprintf(pszString, cchSize, rgchRes, pszText);

        pszPrint = pszString;
    }
    
    // Determine Colors
    crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));

    // Clear the item
    ExtTextOut(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, ETO_OPAQUE, &(pdis->rcItem), NULL, 0, NULL);

    // Draw the new item
    DrawTextEx(pdis->hDC, pszPrint, lstrlen(pszPrint), &(pdis->rcItem), DT_BOTTOM | DT_NOPREFIX | DT_SINGLELINE, NULL);

    if (pdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(pdis->hDC, &(pdis->rcItem));
    }
    
    // Reset Text Colors
    SetTextColor (pdis->hDC, crfText);
    SetBkColor (pdis->hDC, crfBack);

    // Set return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FLoadCtrls(VOID)
{
    BOOL    fRet = FALSE;
    UINT    uiID = 0;
    LPTSTR  pszWalk = NULL; 
    
    Assert(NULL != m_hwndList);

    // Set the contains option
    if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_INVERT))
    {
        uiID = idcCriteriaNotCont;
    }
    else
    {
        uiID = idcCriteriaContains;
    }

    CheckRadioButton(m_hwndDlg, idcCriteriaContains, idcCriteriaNotCont, uiID);

    // Set the logic option
    if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        uiID = idcCriteriaAnd;
    }
    else
    {
        uiID = idcCriteriaOr;
    }

    CheckRadioButton(m_hwndDlg, idcCriteriaAnd, idcCriteriaOr, uiID);
    
    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add the tag line to the top of the list
    _AddTagLineToList();
    
    // If we have some items, let's add them to the list
    if (0 != m_pCritItem->propvar.blob.cbSize)
    {
        // Add each item into the list
        for (pszWalk = (LPSTR) (m_pCritItem->propvar.blob.pBlobData);
                    '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            if (FALSE == _FAddWordToList(0, pszWalk))
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }

    // If we don't have at least two names in the list
    if (3 > SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        // Disable the And/Or buttons
        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaAnd, FALSE);
        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaOr, FALSE);
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FOnOK(DWORD * pdwFlags)
{
    BOOL    fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    // Get the contains option
    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, idcCriteriaContains))
    {
        *pdwFlags &= ~CRIT_FLAG_INVERT;
    }
    else
    {
        *pdwFlags |= CRIT_FLAG_INVERT;
    }
    
    // Get the logic option
    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, idcCriteriaAnd))
    {
        *pdwFlags |= CRIT_FLAG_MULTIPLEAND;
    }
    else
    {
        *pdwFlags &= ~CRIT_FLAG_MULTIPLEAND;
    }
    
    // Set the return value
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddTagLineToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_AddTagLineToList(VOID)
{
    BOOL            fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    fRet = _FAddWordToList(0, " ");
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddWordToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FAddWordToList(DWORD dwFlags, LPCTSTR pszItem)
{
    BOOL            fRet = FALSE;
    int             cItems = 0;
    INT             iRet = 0;
    
    Assert(NULL != m_hwndList);

    // Is there anything to do?
    if ((NULL == pszItem) || ('\0' == pszItem[0]))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the data into the list 
    iRet = (INT) SendMessage(m_hwndList, LB_ADDSTRING, (WPARAM) cItems, (LPARAM) pszItem);
    if ((LB_ERR == iRet) || (LB_ERRSPACE == iRet))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

CEditPeopleUI::~CEditPeopleUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      cf;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // We're done
    m_dwState |= STATE_INITIALIZED;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleUI::HrShow(CRIT_ITEM * pCritItem)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;
    UINT        uiID = 0;

    // Check incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the data
    m_pCritItem = pCritItem;
    
    // Figure out which dialog template to use
    if (0 != (m_dwFlags & PUI_WORDS))
    {
        uiID = iddCriteriaWords;
    }
    else
    {
        uiID = iddCriteriaPeople;
    }
    
    // Bring up the editor dialog
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(uiID),
                                        m_hwndOwner,  CEditPeopleUI::FEditPeopleDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CEditPeopleUI::FEditPeopleDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    CEditPeopleUI *         pPeopleUI = NULL;

    pPeopleUI = (CEditPeopleUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pPeopleUI = (CEditPeopleUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pPeopleUI);

            if (FALSE == pPeopleUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pPeopleUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_MEASUREITEM:
            fRet = pPeopleUI->FOnMeasureItem(hwndDlg, (UINT) wParam, (MEASUREITEMSTRUCT *) lParam);
            break;

        case WM_DRAWITEM:
            fRet = pPeopleUI->FOnDrawItem((UINT) wParam, (DRAWITEMSTRUCT *) lParam);
            break;            
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit people UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idcCriteriaList);
    m_hwndPeople = GetDlgItem(hwndDlg, idcCriteriaEdit);
    if ((NULL == m_hwndList) || (NULL == m_hwndPeople))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK(m_pCritItem))
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case idcCriteriaEdit:
            if (EN_CHANGE == uiNotify)
            {
                _FOnNameChange();
            }
            fRet = FALSE;
            break;
    
        case idcCriteriaAdd:
            _AddItemToList();
            break;

        case idcCriteriaAddrBook:
            _AddItemsFromWAB();
            break;

        case idcCriteriaRemove:
            _RemoveItemFromList();
            break;
            
        case idcCriteriaOptions:
            _ChangeOptions();
            break;

        case idcCriteriaList:   
            if (LBN_SELCHANGE == uiNotify)
            {
                // Update the buttons
                _UpdateButtons();
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnMeasureItem
//
//  This handles the WM_MEASUREITEM message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis)
{
    BOOL        fRet = FALSE;
    HWND        hwndList = NULL;
    HDC         hdcList = NULL;
    TEXTMETRIC  tm = {0};
    
    // Get the window handle
    hwndList = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the device context
    hdcList = GetDC(hwndList);
    if (NULL == hdcList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the text metrics for the device context
    GetTextMetrics(hdcList, &tm);

    // Set the item height
    pmis->itemHeight = tm.tmHeight;

    fRet = TRUE;

exit:
    if (NULL != hdcList)
    {
        ReleaseDC(hwndList, hdcList);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDrawItem
//
//  This handles the WM_DRAWITEM message for the people editor UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis)
{
    BOOL        fRet = FALSE;
    INT         cchText = 0;
    LPTSTR      pszText = NULL;
    LPTSTR      pszString = NULL;
    UINT        uiID = 0;
    TCHAR       rgchRes[CCHMAX_STRINGRES];
    COLORREF    crfBack = NULL;
    COLORREF    crfText = NULL;
    ULONG       ulIndex = 0;
    LPTSTR      pszPrint = NULL;

    // Make sure this is the correct control
    if (ODT_LISTBOX != pdis->CtlType)
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing else to do if it's the first item
    if (0 == pdis->itemID)
    {
        for (ulIndex = 0; ulIndex < g_cpetTagLines; ulIndex++)
        {
            if (g_rgpetTagLines[ulIndex].type == m_pCritItem->type)
            {
                if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_INVERT))
                {
                    uiID = g_rgpetTagLines[ulIndex].uiInverted;
                }
                else
                {
                    uiID = g_rgpetTagLines[ulIndex].uiNormal;
                }
                break;
            }
        }
        
        // Did we find anything?
        if (ulIndex >= g_cpetTagLines)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Load the item template
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszPrint = rgchRes;
    }
    else
    {
        // Get the size of the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) (pdis->itemID), (LPARAM) 0);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the the string for the item
        if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * (cchText + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Get the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) (pdis->itemID), (LPARAM) pszText);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Figure out which string template to use
        if (1 == pdis->itemID)
        {
            uiID = idsCriteriaEditFirst;
        }
        else
        {
            if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
            {
                uiID = idsCriteriaEditAnd;
            }
            else
            {
                uiID = idsCriteriaEditOr;
            }
        }
        
        // Load the proper string template for the item
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the final string
        DWORD cchSize = (cchText + CCHMAX_STRINGRES + 1);
        if (FAILED(HrAlloc((VOID **) &pszString, sizeof(*pszString) * cchSize)))
        {
            fRet = FALSE;
            goto exit;
        }

        // Create the final string
        wnsprintf(pszString, cchSize, rgchRes, pszText);

        pszPrint = pszString;
    }
    
    // Determine Colors
    if (pdis->itemState & ODS_SELECTED)
    {
        crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
        crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    // Clear the item
    ExtTextOut(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, ETO_OPAQUE, &(pdis->rcItem), NULL, 0, NULL);

    // Draw the new item
    DrawTextEx(pdis->hDC, pszPrint, lstrlen(pszPrint), &(pdis->rcItem), DT_BOTTOM | DT_NOPREFIX | DT_SINGLELINE, NULL);

    if (pdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(pdis->hDC, &(pdis->rcItem));
    }
    
    // Reset Text Colors
    SetTextColor (pdis->hDC, crfText);
    SetBkColor (pdis->hDC, crfBack);

    // Set return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add the tag line to the top of the list
    _AddTagLineToList();
    
    // If we have some items, let's add them to the list
    if (0 != m_pCritItem->propvar.blob.cbSize)
    {
        // Add each item into the list
        for (pszWalk = (LPSTR) (m_pCritItem->propvar.blob.pBlobData);
                    '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            fRet = _FAddWordToList(0, pszWalk);
            if (FALSE == fRet)
                goto exit;
        }
    }
    
    SendMessage(m_hwndDlg, DM_SETDEFID, IDOK, 0);
    
    // Enable the dialog buttons.
    _UpdateButtons();

    fRet = TRUE;

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddItemToList
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_AddItemToList(VOID)
{
    ULONG       cchName = 0;
    LPTSTR      pszItem = NULL;
    
    // Get the item from the edit well
    cchName = Edit_GetTextLength(m_hwndPeople) + 1;
    if (FAILED(HrAlloc((void **) &pszItem, cchName * sizeof(*pszItem))))
    {
        goto exit;
    }
    
    pszItem[0] = '\0';
    cchName = Edit_GetText(m_hwndPeople, pszItem, cchName);
    
    // Check to see if the name is valid
    if (0 == UlStripWhitespace(pszItem, TRUE, TRUE, NULL))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsEditPeopleErrorNoName),
                        NULL, MB_OK | MB_ICONINFORMATION);
        goto exit;
    }

    _FAddWordToList(0, pszItem);

    // Clear out the edit well
    Edit_SetText(m_hwndPeople, "");
    
    _UpdateButtons();
    
exit:
    SafeMemFree(pszItem);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddItemsFromWAB
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_AddItemsFromWAB(VOID)
{
    ULONG       cchName = 0;
    LPWSTR      pwszAddrs = NULL;
    LPWSTR      pwszWalk = NULL;
    LONG        lRecipType = 0;
    UINT        uidsWell = 0;
    
    // Set the proper tags
    switch(m_pCritItem->type)
    {
      case CRIT_TYPE_TO:
        lRecipType = MAPI_TO;
        uidsWell = idsRulePickTo;
        break;
        
      case CRIT_TYPE_CC:
        lRecipType = MAPI_CC;
        uidsWell = idsRulePickCC;
        break;
        
      case CRIT_TYPE_FROM:
        lRecipType = MAPI_ORIG;
        uidsWell = idsRulePickFrom;
        break;

      case CRIT_TYPE_TOORCC:
        lRecipType = MAPI_TO;
        uidsWell = idsRulePickToOrCC;
        break;

      default:
        goto exit;
        break;
    }
    
    if (FAILED(RuleUtil_HrGetAddressesFromWAB(m_hwndDlg, lRecipType, uidsWell, &pwszAddrs)))
    {
        goto exit;
    }

    // Loop through each of the addresses
    for (pwszWalk = pwszAddrs; '\0' != pwszWalk[0]; pwszWalk += lstrlenW(pwszWalk) + 1)
    {
        LPSTR pszWalk = NULL;
        // Addresses only have to be US ASCII so won't loose anything in this conversion.
        pszWalk = PszToANSI(CP_ACP, pwszWalk);
        if (!pszWalk)
        {
            TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        _FAddWordToList(0, pszWalk);
        MemFree(pszWalk);
    }

    _UpdateButtons();
    
exit:
    MemFree(pwszAddrs);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveItemFromList
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_RemoveItemFromList(VOID)
{
    INT         iSelected = 0;
    INT         cItems = 0;
    
    Assert(NULL != m_hwndList);

    // Figure out which item is selected in the list
    iSelected = (INT) SendMessage(m_hwndList, LB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == iSelected)
    {
        goto exit;
    }

    // If it's the tag line, then fail
    if (0 == iSelected)
    {
        goto exit;
    }

    // Get the current number of items
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        goto exit;
    }

    // Remove the item
    if (LB_ERR == (INT) SendMessage(m_hwndList, LB_DELETESTRING, (WPARAM) iSelected, (LPARAM) 0))
    {
        goto exit;
    }
    
    // If we deleted the last item, select the new last item
    if (iSelected == (cItems - 1))
    {
        iSelected--;
    }

    // Set the new selection
    if (0 != iSelected)
    {
        SideAssert(LB_ERR != (INT) SendMessage(m_hwndList, LB_SETCURSEL, (WPARAM) iSelected, (LPARAM) 0));
    }

    _UpdateButtons();
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _ChangeOptions
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_ChangeOptions(VOID)
{
    HRESULT                 hr = S_OK;
    CEditPeopleOptionsUI *  pOptionUI = NULL;
    CRIT_ITEM               critItem;
    
    Assert(NULL != m_pCritItem);

    // Initialize local variables
    ZeroMemory(&critItem, sizeof(critItem));
    
    // Create the options UI object
    pOptionUI = new CEditPeopleOptionsUI;
    if (NULL == pOptionUI)
    {
        goto exit;
    }
    
    // Initialize the options UI object
    hr = pOptionUI->HrInit(m_hwndDlg, m_dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the parameters to pass to the options dialog
    critItem.type = m_pCritItem->type;
    critItem.dwFlags = m_pCritItem->dwFlags;
    critItem.propvar.vt = VT_BLOB;

    // Get the parameter from the dialog
    if (FALSE == _FOnOK(&critItem))
    {
        goto exit;
    }
    
    // Show the options UI
    hr = pOptionUI->HrShow(&critItem);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // If anything changed
    if (S_OK == hr)
    {
        // Set the new value
        m_pCritItem->dwFlags = critItem.dwFlags;
        
        // Make sure the list is redrawn
        InvalidateRect(m_hwndList, NULL, TRUE);
        
        // Mark us as dirty
        m_dwState |= STATE_DIRTY;
    }
    
exit:
    PropVariantClear(&(critItem.propvar));
    if (NULL != pOptionUI)
    {
        delete pOptionUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnNameChange
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FOnNameChange(VOID)
{
    BOOL    fRet = FALSE;
    BOOL    fIsText = FALSE;

    Assert(NULL != m_hwndPeople);

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
    fIsText = (0 != Edit_GetTextLength(m_hwndPeople));

    // Disable the Add button if the name is empty
    fRet = RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaAdd, fIsText);

    SendMessage(m_hwndDlg, DM_SETDEFID, (FALSE != fIsText) ? idcCriteriaAdd : IDOK, 0);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FOnOK(CRIT_ITEM * pCritItem)
{
    BOOL    fRet = FALSE;
    INT     cItems = 0;
    INT     iIndex = 0;
    INT     iRet = 0;
    ULONG   cchText = 0;
    LPTSTR  pszText = NULL;
    LPTSTR  pszWalk = NULL;
    
    Assert(NULL != m_hwndList);

    // Get the total number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if ((LB_ERR == cItems) || (2 > cItems))
    {
        fRet = FALSE;
        goto exit;
    }

    // Loop through each item, calculating the space each would take
    for (iIndex = 1; iIndex < cItems; iIndex++)
    {
        // Get the space for the item
        iRet = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) iIndex, (LPARAM) 0);
        if ((LB_ERR == iRet) || (0 == iRet))
        {
            continue;
        }

        // Count the space needed
        cchText += iRet + 1;
    }

    // Add in space for the terminator
    cchText += 2;

    // Allocate space to hold the item
    if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * cchText)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Loop through each item, calculating the space each would take
    pszWalk = pszText;
    for (iIndex = 1; iIndex < cItems; iIndex++)
    {
        // Get the space for the item
        iRet = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) iIndex, (LPARAM) pszWalk);
        if ((LB_ERR == iRet) || (0 == iRet))
        {
            continue;
        }

        // Count the space needed
        pszWalk += iRet + 1;
    }

    // Add in space for the terminator
    pszWalk[0] = '\0';
    pszWalk[1] = '\0';

    // Set the new string in the blob
    SafeMemFree(pCritItem->propvar.blob.pBlobData);
    pCritItem->propvar.blob.pBlobData = (BYTE *) pszText;
    pszText = NULL;
    pCritItem->propvar.blob.cbSize = sizeof(*pszText) * cchText;
    
    // Set the return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _UpdateButtons
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CEditPeopleUI::_UpdateButtons(VOID)
{
    INT         iSelected = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEditable = FALSE;
    INT         cItems = 0;

    Assert(NULL != m_hwndList);

    // Get the currently selected item
    iSelected = (INT) SendMessage(m_hwndList, LB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == iSelected)
    {
        iSelected = -1;
    }
    
    fSelected = (-1 != iSelected);
    fEditable = ((FALSE != fSelected) && (0 != iSelected));
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaRemove, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaOptions, cItems > 1);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, cItems > 1);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddTagLineToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_AddTagLineToList(VOID)
{
    BOOL            fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    fRet = _FAddWordToList(0, " ");
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddWordToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FAddWordToList(DWORD dwFlags, LPCTSTR pszItem)
{
    BOOL            fRet = FALSE;
    int             cItems = 0;
    INT             iRet = 0;
    
    Assert(NULL != m_hwndList);

    // Is there anything to do?
    if ((NULL == pszItem) || (L'\0' == pszItem[0]))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the data into the list 
    iRet = (INT) SendMessage(m_hwndList, LB_ADDSTRING, (WPARAM) cItems, (LPARAM) pszItem);
    if ((LB_ERR == iRet) || (LB_ERRSPACE == iRet))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrCriteriaEditPeople
//
//  This creates a people editor.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrCriteriaEditPeople(HWND hwnd, CRIT_ITEM * pCritItem)
{
    HRESULT         hr = S_OK;
    CEditPeopleUI * pPeopleUI = NULL;

    // Check the incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the view menu object
    pPeopleUI = new CEditPeopleUI;
    if (NULL == pPeopleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pPeopleUI->HrInit(hwnd, 0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show the UI
    hr = pPeopleUI->HrShow(pCritItem);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (NULL != pPeopleUI)
    {
        delete pPeopleUI;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrCriteriaEditWords
//
//  This creates a words editor.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrCriteriaEditWords(HWND hwnd, CRIT_ITEM * pCritItem)
{
    HRESULT         hr = S_OK;
    CEditPeopleUI * pPeopleUI = NULL;

    // Check the incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the view menu object
    pPeopleUI = new CEditPeopleUI;
    if (NULL == pPeopleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pPeopleUI->HrInit(hwnd, PUI_WORDS);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show the UI
    hr = pPeopleUI->HrShow(pCritItem);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (NULL != pPeopleUI)
    {
        delete pPeopleUI;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\rulesui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rulesui.h"
#include "aplyrule.h"
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "spamui.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <newfldr.h>
#include <instance.h>
#include "shlwapip.h" 
#include <demand.h>

// Constants
class COEMailRulesPageUI : public COERulesPageUI
{
    private:
        enum MOVE_DIR {MOVE_RULE_UP = 0, MOVE_RULE_DOWN = 1};

    private:
        HWND                m_hwndOwner;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        HWND                m_hwndDescript;
        RULE_TYPE           m_typeRule;
        CRuleDescriptUI *   m_pDescriptUI;

    public:
        COEMailRulesPageUI();

        enum INIT_TYPE
        {
            INIT_MAIL   = 0x00000000,
            INIT_NEWS   = 0x00000001
        };
        
        COEMailRulesPageUI(DWORD dwFlagsInit) :
                            COERulesPageUI(iddRulesMail,
                                           (0 != (dwFlagsInit & INIT_NEWS)) ? idsRulesNews : idsRulesMail, 0, 0), 
                            m_hwndOwner(NULL), m_hwndDlg(NULL), m_hwndList(NULL),
                            m_hwndDescript(NULL),
                            m_typeRule((0 != (dwFlagsInit & INIT_NEWS)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL),
                            m_pDescriptUI(NULL) {}
        virtual ~COEMailRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FMailRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FMailRulesPageDlgProc;}

        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);

    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddRuleToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule);
        VOID _EnableButtons(INT iSelected);
        VOID _EnableRule(INT iSelected);

        // For dealing with the description field
        VOID _LoadRule(INT iSelected);
        BOOL _FSaveRule(INT iSelected);

        // Functions to deal with the basic actions
        VOID _NewRule(VOID);
        VOID _EditRule(INT iSelected);
        VOID _MoveRule(INT iSelected, MOVE_DIR dir);
        VOID _RemoveRule(INT iSelected);
        VOID _CopyRule(INT iSelected);
        VOID _OnApplyTo(INT iSelected);

        BOOL _FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi);
        BOOL _FOnRuleDescValid(VOID);
};

// Global data
const static HELPMAP g_rgCtxMapRulesMgr[] = {
                       {0, 0}};
                       
const static HELPMAP g_rgCtxMapMailRules[] = {
                        {idbNewRule,            idhNewRule},
                        {idbModifyRule,         idhModifyRule},
                        {idbCopyRule,           idhCopyRule},
                        {idbDeleteRule,         idhRemoveRule},
                        {idbRulesApplyTo,       idhRuleApply},
                        {idbMoveUpRule,         idhRuleUp},
                        {idbMoveDownRule,       idhRuleDown},
                        {idredtRuleDescription, idhRuleDescription},
                        {0, 0}};
                       
COERulesMgrUI::COERulesMgrUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(0), m_hwndDlg(NULL), m_hwndTab(NULL)
{
    ZeroMemory(m_rgRuleTab, sizeof(m_rgRuleTab));
}

COERulesMgrUI::~COERulesMgrUI()
{
    ULONG    ulIndex = 0;
    
    for (ulIndex = 0; ulIndex < RULE_PAGE_MAX; ulIndex++)
    {
        if (NULL != m_rgRuleTab[ulIndex])
        {
            delete m_rgRuleTab[ulIndex];
        }
    }
}

HRESULT COERulesMgrUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Create each of the rule pages

    if (!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        // Create the mail page
        m_rgRuleTab[RULE_PAGE_MAIL] = new COEMailRulesPageUI(COEMailRulesPageUI::INIT_MAIL);
        if (NULL == m_rgRuleTab[RULE_PAGE_MAIL])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    // Create the news page
    m_rgRuleTab[RULE_PAGE_NEWS] = new COEMailRulesPageUI(COEMailRulesPageUI::INIT_NEWS);
    if (NULL == m_rgRuleTab[RULE_PAGE_NEWS])
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create the junk page
    if ((0 == (g_dwAthenaMode & MODE_NEWSONLY)) && (0 != (g_dwAthenaMode & MODE_JUNKMAIL)))
    {
        m_rgRuleTab[RULE_PAGE_JUNK] = new COEJunkRulesPageUI();
        if (NULL == m_rgRuleTab[RULE_PAGE_JUNK])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    // Create the senders page
    m_rgRuleTab[RULE_PAGE_SENDERS] = new COESendersRulesPageUI();
    if (NULL == m_rgRuleTab[RULE_PAGE_SENDERS])
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COERulesMgrUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRulesManager),
                                        m_hwndOwner, COERulesMgrUI::FOERuleMgrDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COERulesMgrUI::FOERuleMgrDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COERulesMgrUI *         pRulesUI = NULL;

    pRulesUI = (COERulesMgrUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pRulesUI = (COERulesMgrUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pRulesUI);

            if (FALSE == pRulesUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pRulesUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pRulesUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pRulesUI->FOnDestroy();
            break;
            
        case WM_OE_GET_RULES:
            fRet = pRulesUI->FOnGetRules((RULE_TYPE) wParam, (RULENODE **) lParam);
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapRulesMgr);
            break;
    }
    
    exit:
        return fRet;
}

BOOL COERulesMgrUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndTab = GetDlgItem(hwndDlg, idtbRulesTab);
    if (NULL == m_hwndTab)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize tab control
    fRet = _FInitTabCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSel = 0;
    TCITEM  tcitem = {0};

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;

        default:
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            fRet = !!SendMessage((HWND) (tcitem.lParam), WM_COMMAND, MAKEWPARAM(iCtl, uiNotify), (LPARAM) hwndCtl);
            break;
    }

exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL    fRet = FALSE;
    INT     iSel = 0;
    TCITEM  tcitem = {0};
    HWND    hwndDlg = NULL;
    HWND    hwndFocus = NULL;

    switch (pnmhdr->code)
    {
        case TCN_SELCHANGING:
            // Get the window handle for the currently
            // selected tab
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;            
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            hwndDlg = (HWND) tcitem.lParam;
            Assert(NULL != hwndDlg);
            
            // Hide and disable the current dialog
            ShowWindow(hwndDlg, SW_HIDE);
            EnableWindow(hwndDlg, FALSE);

            SetDlgMsgResult(hwndDlg, WM_NOTIFY, FALSE);
            
            fRet = TRUE;
            break;

        case TCN_SELCHANGE:
            // Get the window handle for the currently
            // selected tab
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;            
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            hwndDlg = (HWND) tcitem.lParam;
            Assert(NULL != hwndDlg);
            
            // Hide and disable the current dialog
            ShowWindow(hwndDlg, SW_SHOW);
            EnableWindow(hwndDlg, TRUE);

            // Set the focus to the first control
            // if the focus isn't in the tab
            hwndFocus = GetFocus();
            if (hwndFocus != m_hwndTab)
            {
                SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM) GetNextDlgTabItem(hwndDlg, NULL, FALSE), (LPARAM) TRUE);
            }
            
            fRet = TRUE;
            break;            
    }

exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnDestroy(VOID)
{
    BOOL    fRet = FALSE;
    UINT    cTabs = 0;
    UINT    uiIndex = 0;
    TC_ITEM tcitem;
    
    // Get the number of tabs
    cTabs = TabCtrl_GetItemCount(m_hwndTab);

    // Initialize the Tab control structure...
    ZeroMemory(&tcitem, sizeof(tcitem));
    tcitem.mask = TCIF_PARAM;

    // Destroy the dialogs from each page
    for (uiIndex = 0; uiIndex < cTabs; uiIndex++)
    {
        // Get the window handle for the dialog
        if (FALSE != TabCtrl_GetItem(m_hwndTab, uiIndex, &tcitem))
        {
            // Destroy the dialog
            DestroyWindow((HWND) tcitem.lParam);
        }
    }

    fRet = TRUE;
    
    return fRet;
}

BOOL COERulesMgrUI::FOnGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL        fRet = FALSE;
    RULENODE *  prnodeList = NULL;
    RULENODE *  prnodeSender = NULL;
    RULENODE *  prnodeJunk = NULL;
    RULENODE *  prnodeWalk = NULL;
    
    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Forward the message to the correct dialog
    switch(typeRule)
    {
        case RULE_TYPE_MAIL:
            // Get the rules from the senders page
            if (NULL != m_rgRuleTab[RULE_PAGE_SENDERS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_SENDERS]->FGetRules(RULE_TYPE_MAIL, &prnodeSender);
            }
            
            // Get the rules from the mail rules page
            if (NULL != m_rgRuleTab[RULE_PAGE_MAIL])
            {
                fRet = m_rgRuleTab[RULE_PAGE_MAIL]->FGetRules(RULE_TYPE_MAIL, &prnodeList);
            }
            
            // Get the rules from the junk mail page
            if (NULL != m_rgRuleTab[RULE_PAGE_JUNK])
            {
                fRet = m_rgRuleTab[RULE_PAGE_JUNK]->FGetRules(RULE_TYPE_MAIL, &prnodeJunk);
            }

            break;
            
        case RULE_TYPE_NEWS:
            // Get the rules from the senders page
            if (NULL != m_rgRuleTab[RULE_PAGE_SENDERS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_SENDERS]->FGetRules(RULE_TYPE_NEWS, &prnodeSender);
            }

            // Get the rules from the news rules page
            if (NULL != m_rgRuleTab[RULE_PAGE_NEWS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_NEWS]->FGetRules(RULE_TYPE_NEWS, &prnodeList);
            }
            break;

        default:
            Assert(FALSE);
            fRet = FALSE;
            goto exit;
            break;
    }

    // Set up the list
    if (NULL != prnodeJunk)
    {
        Assert(NULL == prnodeJunk->pNext);

        if (NULL == prnodeList)
        {
            prnodeList = prnodeJunk;
        }
        else
        {
            prnodeWalk = prnodeList;
            while (NULL != prnodeWalk->pNext)
            {
                prnodeWalk = prnodeWalk->pNext;
            }

            prnodeWalk->pNext = prnodeJunk;
        }
        prnodeJunk = NULL;
    }
    
    if (NULL != prnodeSender)
    {
        Assert(NULL == prnodeSender->pNext);

        prnodeSender->pNext = prnodeList;
        prnodeList = prnodeSender;
        prnodeSender = NULL;
    }
    
    // Set the outgoing param
    *pprnode = prnodeList;
    prnodeList = NULL;
    
    // Tell the dialog it's aok to proceed
    SetDlgMsgResult(m_hwndDlg, WM_OE_GET_RULES, TRUE);

    fRet = TRUE;

exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; //MemFree(prnodeWalk);
    }
    if (NULL != prnodeJunk)
    {
        if (NULL != prnodeJunk->pIRule)
        {
            prnodeJunk->pIRule->Release();
        }
        delete prnodeJunk; // MemFree(prnodeJunk);
    }
    if (NULL != prnodeSender)
    {
        if (NULL != prnodeSender->pIRule)
        {
            prnodeSender->pIRule->Release();
        }
        delete prnodeSender; //MemFree(prnodeSender);
    }
    return fRet;
}

BOOL COERulesMgrUI::_FOnOK(VOID)
{
    BOOL    fRet = FALSE;
    UINT    uiRuleTab = 0;
    HRESULT hr = S_OK;

    // Add the tabs to the tab control
    for (uiRuleTab = 0; uiRuleTab < RULE_PAGE_MAX; uiRuleTab++)
    {
        if (NULL == m_rgRuleTab[uiRuleTab])
        {
            continue;
        }
        
        hr = m_rgRuleTab[uiRuleTab]->HrCommitChanges(0, TRUE);
        if ((FAILED(hr)) && (E_UNEXPECTED != hr))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL COERulesMgrUI::_FOnCancel(VOID)
{
    return TRUE;
}

BOOL COERulesMgrUI::_FInitTabCtrl(VOID)
{
    BOOL    fRet = FALSE;
    TCITEM  tcitem;
    TCHAR   szRes[CCHMAX_STRINGRES];
    UINT    uiRuleTab = 0;
    HWND    hwndDlg = NULL;
    UINT    cRuleTab = 0;
    UINT    uiDefaultTab = 0;
    NMHDR   nmhdr;

    // Make sure we have a resource dll
    Assert(g_hLocRes);
    
    // Initialize the Tab control structure...
    ZeroMemory(&tcitem, sizeof(tcitem));
    tcitem.mask = TCIF_PARAM | TCIF_TEXT;
    tcitem.pszText = szRes;
    tcitem.iImage = -1;
        

    // Add the tabs to the tab control
    for (uiRuleTab = 0; uiRuleTab < RULE_PAGE_MAX; uiRuleTab++)
    {
        // Initialize each of the pages
        if ((NULL == m_rgRuleTab[uiRuleTab]) || (FAILED(m_rgRuleTab[uiRuleTab]->HrInit(m_hwndDlg, m_dwFlags))))
        {
            continue;
        }
        
        // Create the child dialog for the tab
        hwndDlg = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(m_rgRuleTab[uiRuleTab]->UiGetDlgRscId()),
                                        m_hwndDlg, m_rgRuleTab[uiRuleTab]->DlgProcGetPageDlgProc(),
                                        (LPARAM) (m_rgRuleTab[uiRuleTab]));
        if (NULL == hwndDlg)
        {
            continue;
        }
        tcitem.lParam = (LPARAM) hwndDlg;
        
        // Load in the display string for the tab
        LoadString(g_hLocRes, m_rgRuleTab[uiRuleTab]->UiGetTabLabelId(), szRes, ARRAYSIZE(szRes));
        
        // Insert the tab
        TabCtrl_InsertItem(m_hwndTab, cRuleTab, &tcitem);

        // Save off the default tab
        if (uiRuleTab == (m_dwFlags & RULE_PAGE_MASK))
        {
            uiDefaultTab = cRuleTab;
        }
        
        cRuleTab++;
    }    

    if (0 == cRuleTab)
    {
        fRet = FALSE;
        goto exit;
    }

    // Select the proper tab
    if (-1 != TabCtrl_SetCurSel(m_hwndTab, uiDefaultTab))
    {
        nmhdr.hwndFrom = m_hwndTab;
        nmhdr.idFrom = idtbRulesTab;
        nmhdr.code = TCN_SELCHANGE;
        SideAssert(FALSE != FOnNotify(idtbRulesTab, &nmhdr));
    }

    // Need to set the tab control to the bottom of the Z-order
    // to prevent overlapping redraws
    SetWindowPos(m_hwndTab, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    // We worked
    fRet = TRUE;

exit:
    return fRet;
}

// Default destructor for the Mail Rules UI
COEMailRulesPageUI::~COEMailRulesPageUI()
{
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the mail rules UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEMailRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEMailRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        cRules = 0;
    INT         iSelected = 0;
    RULEINFO *  pinfoRule = NULL;
    ULONG       cpinfoRule = 0;
    LVITEM      lvitem = {0};

    Assert(NULL != m_hwndList);
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_OK != m_pDescriptUI->HrIsDirty()))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the number of rules in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    if (0 != cRules)
    {
        // Let's make sure the selected rule is saved...
        iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
        if (-1 != iSelected)
        {
            _FSaveRule(iSelected);
        }

        // Allocate space to hold the rules        
        hr = HrAlloc( (void **) &pinfoRule, cRules * sizeof(*pinfoRule));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(pinfoRule, cRules * sizeof(*pinfoRule));

        lvitem.mask = LVIF_PARAM;
        
        cpinfoRule = 0;
        for (lvitem.iItem = 0; lvitem.iItem < cRules; lvitem.iItem++)
        {
            // Grab the rule from the list view
            if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
            {
                if (NULL == lvitem.lParam)
                {
                    continue;
                }
                
                pinfoRule[cpinfoRule] = *((RULEINFO *) (lvitem.lParam));
                cpinfoRule++;
            }   
        }
    }
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_CLEAR, m_typeRule, pinfoRule, cpinfoRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    SafeMemFree(pinfoRule);
    return hr;
}

INT_PTR CALLBACK COEMailRulesPageUI::FMailRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEMailRulesPageUI *    pMailUI = NULL;
    HWND                    hwndRE = 0;

    pMailUI = (COEMailRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pMailUI = (COEMailRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pMailUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtRuleDescription);

            if (!hwndRE || (FALSE == pMailUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pMailUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pMailUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pMailUI->FOnDestroy();
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapMailRules);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    INT             iSelected = 0;
    INT             cRules = 0;
    LVITEM          lvitem;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    RULENODE *      prnodeList = NULL;
    RULENODE *      prnodeWalk = NULL;
    HRESULT         hr = S_OK;
    RULEINFO *      pinfoRule = NULL;

    Assert(NULL != m_hwndList);

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if ((0 == (m_dwState & STATE_INITIALIZED)) || (NULL == m_hwndList))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Get the selected item
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

    // Make sure we don't loose any changes
    _FSaveRule(iSelected);
    
    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);
    if (0 == cRules)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Initialize the list view item
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Create the list of rules
    for (lvitem.iItem = 0; lvitem.iItem < cRules; lvitem.iItem++)
    {
        // Grab the rule from the listview
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            fRet = FALSE;
            goto exit;
        }
        pinfoRule = (RULEINFO *) (lvitem.lParam);

        if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
        {
            continue;
        }

        
        // Skip over invalid rules
        hr = pinfoRule->pIRule->Validate(0);
        if (FAILED(hr) || (S_FALSE == hr))
        {
            continue;
        }

        // Create a new rule node
        prnodeNew = new RULENODE;
        if (NULL == prnodeNew)
        {
            fRet = FALSE;
            goto exit;
        }

        prnodeNew->pNext = NULL;
        prnodeNew->pIRule = pinfoRule->pIRule;
        prnodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == prnodeWalk)
        {
            prnodeList = prnodeNew;
        }
        else
        {
            prnodeWalk->pNext = prnodeNew;
        }
        prnodeWalk = prnodeNew;
        prnodeNew = NULL;        
    }

    // Set the outgoing param
    *pprnode = prnodeList;
    prnodeList = NULL;
    
    fRet = TRUE;
    
exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; //MemFree(prnodeWalk);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the mail rules UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    TCHAR           szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvRulesList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtRuleDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }

    // We need to change the title if we are a news page
    if (RULE_TYPE_NEWS == m_typeRule)
    {
        if (0 == LoadString(g_hLocRes, idsRuleTitleNews, szRes, ARRAYSIZE(szRes)))
        {
            goto exit;
        }

        SetDlgItemText(m_hwndDlg, idcRuleTitle, szRes);
    }
    else
    {
        if (FALSE != FIsIMAPOrHTTPAvailable())
        {
            AthLoadString(idsRulesNoIMAP, szRes, sizeof(szRes));

            SetDlgItemText(m_hwndDlg, idcRuleTitle, szRes);
        }
    }
    
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Check to see if the list is empty
    if (0 == ListView_GetItemCount(m_hwndList))
    {
        if (((m_typeRule == RULE_TYPE_MAIL) && (RMF_MAIL == m_dwFlags)) ||
                    ((m_typeRule == RULE_TYPE_NEWS) && (RMF_NEWS == m_dwFlags)))
        {
            PostMessage(m_hwndDlg, WM_COMMAND, MAKEWPARAM(idbNewRule, 0), (LPARAM) (GetDlgItem(m_hwndDlg, idbNewRule)));
        }
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idbNewRule:
            _NewRule();
            fRet = TRUE;
            break;

        case idbModifyRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditRule(iSelected);
                fRet = TRUE;
            }
            break;

        case idbMoveUpRule:
        case idbMoveDownRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Move the rule in the desired direction
                _MoveRule(iSelected, (idbMoveUpRule == iCtl) ? MOVE_RULE_UP : MOVE_RULE_DOWN);
                fRet = TRUE;
            }
            break;

        case idbDeleteRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveRule(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbCopyRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Copy the rule from the list
                _CopyRule(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbRulesApplyTo:
            // Apply the rule from the list
            _OnApplyTo(ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED));
            fRet = TRUE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    // or the desscription field
    if ((idlvRulesList != pnmhdr->idFrom) && (idredtRuleDescription != pnmhdr->idFrom))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMSTATEICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state                        
                        _EnableRule(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list

                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditRule(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list
                
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGING:
            // If an item's state changed to unselected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 != (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 == (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Save off the rule changes
                _FSaveRule(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The space key changes the enable state of a rule
            if (VK_SPACE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Change the enable state of the rule
                    _EnableRule(iSelected);
                }
            }
            // The delete key removes the rule from the list view
            else if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveRule(iSelected);
                }
            }
            break;
            
        case LVN_BEGINLABELEDIT:
        case LVN_ENDLABELEDIT:
            fRet = _FOnLabelEdit((LVN_BEGINLABELEDIT == pnmlv->hdr.code), (NMLVDISPINFO *) pnmhdr);
            break;

        case NM_RULE_CHANGED:
            fRet = _FOnRuleDescValid();
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnDestroy(VOID)
{
    BOOL        fRet = FALSE;
    UINT        cRules = 0;
    UINT        uiIndex = 0;
    LVITEM      lvitem = {0};
    UNALIGNED   RULEINFO *  pIRuleInfo = NULL;

    Assert(m_hwndList);
    
    // Get the number of rules in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    // Initialize to get the rule interface from the list view
    lvitem.mask = LVIF_PARAM;

    // Release each of the rules from the list view
    for (uiIndex = 0; uiIndex < cRules; uiIndex++)
    {
        lvitem.iItem = uiIndex;
        
        // Get the rule interface
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRuleInfo = (UNALIGNED RULEINFO *) (lvitem.lParam);

            if (NULL != pIRuleInfo)
            {
                // Release the rule
                if (NULL != pIRuleInfo->pIRule)
                {
                    pIRuleInfo->pIRule->Release();
                }
                delete pIRuleInfo; // MemFree(pIRuleInfo);
            }
        }
    }

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the mail rules dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc;
    RECT        rc;
    HIMAGELIST  himl = NULL;

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULEINFO *      pinfoRules = NULL;
    ULONG           cpinfoRules = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Get the Rules enumerator
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRules(GETF_EDIT, m_typeRule, &pinfoRules, &cpinfoRules);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Add each filter to the list
    dwListIndex = 0;

    for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
    {
        // Make a copy of the rule
        hr = pinfoRules[ulIndex].pIRule->Clone(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }
        
        // Add filter to the list
        if (FALSE != _FAddRuleToList(dwListIndex, pinfoRules[ulIndex].ridRule, pIRule))
        {
            dwListIndex++;
        }

        SafeRelease(pIRule);
    }

    // Select the first item in the list
    if (0 != dwListIndex)
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != dwListIndex) ? 0 : -1);

    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    if (NULL != pinfoRules)
    {
        for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
        {
            pinfoRules[ulIndex].pIRule->Release();
        }
        MemFree(pinfoRules);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  rhdlTag - the rule handle for the new rule
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FAddRuleToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    LVITEM      lvitem = {0};
    BOOL        fNotValid = FALSE;
    BOOL        fDisabled = FALSE;
    RULEINFO *  pinfoRule = NULL;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Is it disabled?    
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    fDisabled = !!propvar.boolVal;
    
    // Need to check if the rule is valid
    hr = pIRule->Validate(0);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    fNotValid = (hr == S_FALSE);

    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate space for the rule
    pinfoRule = new RULEINFO;
    if (NULL == pinfoRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set up the value
    pinfoRule->ridRule = ridRule;
    pinfoRule->pIRule = pIRule;
    pinfoRule->pIRule->AddRef();
    
    // Add in the image and rule interface
    lvitem.mask = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
    lvitem.iItem = dwIndex;
    // Need to change the state to mark the rule as invalid
    if (FALSE != fNotValid)
    {
        lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1);
    }
    else
    {
        lvitem.state = fDisabled ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                                INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
    }
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.pszText = propvar.pszVal;
    lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
    lvitem.lParam = (LPARAM) pinfoRule;

    if (-1 == ListView_InsertItem(m_hwndList, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }

    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Mail rules UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEnDisUp = FALSE;
    BOOL        fEnDisDown = FALSE;
    LVITEM      lvitem = {0};
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Load the description field
    _LoadRule(iSelected);
    
    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    fSelected = (-1 != iSelected);
    
    // If we have rules and the top rule isn't selected
    fEnDisUp = ((1 < cRules) &&  (0 != iSelected) && (FALSE != fSelected));

    // If we have rules and the bottom rule ins't selected
    fEnDisDown = ((1 < cRules) &&  ((cRules - 1) != iSelected) && (FALSE != fSelected));

    // Enable the up/down buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbMoveDownRule, fEnDisDown);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbMoveUpRule, fEnDisUp);

    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDeleteRule, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbCopyRule, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifyRule, fSelected);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableRule
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_EnableRule(int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;
    BOOL        fEnabled = FALSE;
    PROPVARIANT propvar;

    // Grab the list view item
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Let's make sure we can enable this rule
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRulesErrorEnable), NULL,
                        MB_OK | MB_ICONINFORMATION);
        goto exit;
    }

    // Get the new enabled value
    fEnabled = (lvi.state != INDEXTOSTATEIMAGEMASK(iiconStateChecked+1));

    // Set the UI to the opposite enabled state
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE;
    lvi.iItem = iSelected;
    lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateChecked+1) :
                            INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    ListView_SetItem(m_hwndList, &lvi);
    
    // Set the enabled property
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_BOOL;
    propvar.boolVal = !fEnabled;
    hr = pIRule->SetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Tell the description field about it
    m_pDescriptUI->HrSetEnabled(fEnabled);
    
    // Redraw the string the new rule
    m_pDescriptUI->ShowDescriptionString();
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadRule
//
//  This loads the selected rule into the description field.
//  If there isn't a selected rule, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_LoadRule(INT iSelected)
{
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(m_typeRule, pIRule);

    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveRule
//
//  This checks to see if the rule has been changed in the description
//  area and if it has, then it warns the user and changes the text
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    TRUE, if the rule either didn't change or did change without problems
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FSaveRule(int iSelected)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    LVITEM          lvi = {0};
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;

    // If the rule didn't change, then we're done
    hr = m_pDescriptUI->HrIsDirty();
    if (S_OK != hr)
    {
        fRet = (S_FALSE == hr);
        goto exit;
    }
    
    // Grab the list view item
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Get the criteria from the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the criteria from the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions for the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewRule
//
//  This brings up a fresh rules editor
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_NewRule(VOID)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    LVFINDINFO      lvfinfo = {0};
    PROPVARIANT     propvar = {0};
    CEditRuleUI *   pEditRuleUI = NULL;
    LONG            cRules = 0;
    UINT            uiStrId = 0;
       
    // Create a new rule object
    if (FAILED(HrCreateRule(&pIRule)))
    {
        goto exit;
    }

    // Figure out the string Id
    if (RULE_TYPE_NEWS == m_typeRule)
    {
        uiStrId = idsRuleNewsDefaultName;
    }
    else
    {
        uiStrId = idsRuleMailDefaultName;
    }
    
    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, uiStrId, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    ulIndex = 1;
    wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);

    lvfinfo.flags = LVFI_STRING;
    lvfinfo.psz = szName;
    while (-1 != ListView_FindItem(m_hwndList, -1, &lvfinfo))
    {
        ulIndex++;
        wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);
    }

    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, ERF_NEWRULE, m_typeRule, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        // Add the rule to the manager UI
        cRules = ListView_GetItemCount(m_hwndList);
        
        _FAddRuleToList(cRules, RULEID_INVALID, pIRule);

        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, cRules, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Make sure the new item is visible
        ListView_EnsureVisible(m_hwndList, cRules, FALSE);
    }
    
exit:
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditRule
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_EditRule(int iSelected)
{
    HRESULT         hr = S_OK;
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    CEditRuleUI *   pEditRuleUI = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            fNotValid = FALSE;
    BOOL            fDisabled = FALSE;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveRule(iSelected);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }   

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create the rules editor
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, 0, m_typeRule, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the rule changed, make sure we reload the description field
    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;

        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.mask = LVIF_STATE;
        lvitem.stateMask = LVIS_STATEIMAGEMASK;
        lvitem.iItem = iSelected;
        
        // Is it disabled?    
        hr = pIRule->GetProp(RULE_PROP_DISABLED , 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        fDisabled = !!propvar.boolVal;
        
        // Need to check if the rule is valid
        hr = pIRule->Validate(0);
        if (FAILED(hr))
        {
            goto exit;
        }

        fNotValid = (hr == S_FALSE);

        // Grab the rule name
        PropVariantClear(&propvar);
        hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        if ((VT_LPSTR == propvar.vt) && (NULL != propvar.pszVal) && ('\0' != propvar.pszVal[0]))
        {
            lvitem.mask |= LVIF_TEXT;
            lvitem.pszText = propvar.pszVal;
            lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
        }

        // Grab the rule state
        
        // Need to change the state to mark the rule as invalid
        if (FALSE != fNotValid)
        {
            lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1);
        }
        else
        {
            lvitem.state = fDisabled ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                                    INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
        }
        
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }
        
        _EnableButtons(iSelected);
    }
    
exit:
    PropVariantClear(&propvar);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _MoveRule
//
//  This moves the selected rule in the desired direction
//
//  iSelected   - index of the item in the listview to work on
//  dir         - the direction to move the item
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_MoveRule(INT iSelected, MOVE_DIR dir)
{
    LVITEM      lvitem = {0};
    TCHAR       szName[CCHMAX_STRINGRES];
    IOERule *   pIRule = NULL;
    int         nIndexNew = 0;
    
    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    szName[0] = '\0';
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_STATE | LVIF_PARAM | LVIF_TEXT;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED | LVIS_STATEIMAGEMASK;
    lvitem.pszText = szName;
    lvitem.cchTextMax = ARRAYSIZE(szName);
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    
    // Update the item in the list view

    // Get the info for the new index
    nIndexNew = iSelected;
    nIndexNew += (MOVE_RULE_UP == dir) ? -1 : 2;

    // Insert the new index
    lvitem.iItem = nIndexNew;
    if (-1 == ListView_InsertItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    // Ensure the new item is visible
    ListView_EnsureVisible(m_hwndList, nIndexNew, FALSE);
    ListView_RedrawItems(m_hwndList, nIndexNew, nIndexNew);

    // If we moved up, then the old item is now one lower than before
    if (MOVE_RULE_UP == dir)
    {
        iSelected++;
    }

    // Remove the old item
    if (FALSE == ListView_DeleteItem(m_hwndList, iSelected))
    {
        goto exit;
    }

    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveRule
//
//  This removes the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_RemoveRule(int iSelected)
{
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    PROPVARIANT propvar = {0};
    int         cRules = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    UINT        cchRes = 0;
    LPTSTR      pszMessage = NULL;

    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pinfoRule = (RULEINFO *) (lvitem.lParam);
    if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
    {
        goto exit;
    }
    
    // Warn the user to make sure they know we are going to remove the rule
    if (FAILED(pinfoRule->pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(propvar.pszVal) + 1);
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchSize)))
    {
        goto exit;
    }

    // Build up the string and display it
    wnsprintf(pszMessage, cchSize, szRes, propvar.pszVal);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cRules = ListView_GetItemCount(m_hwndList);
    if (cRules > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cRules)
        {
            // Move the selection to the new last item in the list
            iSelected = cRules - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }

    // Release the rule
    SafeRelease(pinfoRule->pIRule);

    // Free up the memory
    delete pinfoRule; // SafeMemFree(pinfoRule);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  CopyRule
//
//  This copies the selected rule from the rules manager
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_CopyRule(INT iSelected)
{
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    HRESULT         hr = S_OK;
    IOERule *       pIRuleNew = NULL;
    PROPVARIANT     propvar = {0};
    UINT            cRules = 0;
    TCHAR           szRes[CCHMAX_STRINGRES];
    UINT            cchRes = 0;
    LPTSTR          pszName = NULL;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveRule(iSelected);
    
    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create a new rule object
    hr = pIRule->Clone(&pIRuleNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Let's set the name

    // Get the name from the source rule
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(propvar.pszVal) + 1);
    if (FAILED(HrAlloc((void ** ) &pszName, cchSize)))
    {
        goto exit;
    }

    // Build up the string and set it
    wnsprintf(pszName, cchSize, szRes, propvar.pszVal);

    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    pszName = NULL;
    
    // Set the name into the new rule
    Assert(VT_LPSTR == propvar.vt);
    Assert(NULL != propvar.pszVal);
    hr = pIRuleNew->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clear the version of the new rule
    PropVariantClear(&propvar);
    propvar.vt = VT_UI4;
    propvar.ulVal = 0;
    hr = pIRuleNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Add the rule to the rules list right below
    // the original rule
    iSelected++;
    _FAddRuleToList(iSelected, RULEID_INVALID, pIRuleNew);

    // Make sure the new item is selected
    ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    // Make sure the new item is visible
    ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszName);
    SafeRelease(pIRuleNew);
    PropVariantClear(&propvar);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnApplyTo
//
//  This applies the rules into a folder
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_OnApplyTo(INT iSelected)
{
    COEApplyRulesUI *   pApplyRulesUI = NULL;
    RULENODE *          prnodeList = NULL;
    RULENODE *          prnodeWalk = NULL;
    LVITEM              lvitem = {0};
    IOERule *           pIRule = NULL;
    HRESULT             hr = S_OK;

    // Create the rules UI object
    pApplyRulesUI = new COEApplyRulesUI;
    if (NULL == pApplyRulesUI)
    {
        goto exit;
    }

    // Get the rules from the page
    if (FALSE == SendMessage(m_hwndOwner, WM_OE_GET_RULES, (WPARAM) m_typeRule, (LPARAM) &prnodeList))
    {
        goto exit;
    }

    if (NULL == prnodeList)
    {
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_NEWS == m_typeRule) ? MAKEINTRESOURCEW(idsErrorApplyRulesNews) : MAKEINTRESOURCEW(idsErrorApplyRulesMail),
                        NULL, MB_OK | MB_ICONERROR);
        goto exit;
    }
    
    // Get the rule associated with the item
    if (-1 != iSelected)
    {
        lvitem.iItem = iSelected;
        lvitem.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL != pIRule)
            {
                // Verify that it is valid
                hr = pIRule->Validate(0);
                if ((FAILED(hr)) || (S_FALSE == hr))
                {
                    pIRule = NULL;
                }
            }
        }
    }
    
    if (FAILED(pApplyRulesUI->HrInit(m_hwndDlg, 0, m_typeRule, prnodeList, pIRule)))
    {
        goto exit;
    }
    prnodeList = NULL;
  
    if (FAILED(pApplyRulesUI->HrShow()))
    {
        goto exit;
    }
    
exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        MemFree(prnodeWalk);
    }
    if (NULL != pApplyRulesUI)
    {
        delete pApplyRulesUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnLabelEdit
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi)
{
    BOOL            fRet = FALSE;
    HWND            hwndEdit;
    ULONG           cchName = 0;
    IOERule *       pIRule = NULL;
    LVITEM          lvitem;
    PROPVARIANT     propvar;

    Assert(NULL != m_hwndList);

    if (NULL == pdi)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(m_hwndList == pdi->hdr.hwndFrom);
    
    if (FALSE != fBegin)
    {
        // Get the edit control
        hwndEdit = ListView_GetEditControl(m_hwndList);

        if (NULL == hwndEdit)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Limit the amount of text for the name
        SendMessage(hwndEdit, EM_LIMITTEXT, c_cchNameMax - 1, 0);

        // Tell the dialog it's aok to proceed
        SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
    }
    else
    {            
        // Did something change?
        if ((-1 != pdi->item.iItem) && (NULL != pdi->item.pszText))
        {
            cchName = lstrlen(pdi->item.pszText);
            
            // Check to see if the rule name is valid
            if ((0 == cchName) || (0 == UlStripWhitespace(pdi->item.pszText, TRUE, TRUE, &cchName)))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsRulesErrorNoName), NULL,
                                MB_OK | MB_ICONINFORMATION);
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Get the rule for the item
            ZeroMemory(&lvitem, sizeof(lvitem));
            lvitem.iItem = pdi->item.iItem;
            lvitem.mask = LVIF_PARAM;
            if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }

            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL == pIRule)
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Set the new name into the rule
            
            ZeroMemory(&propvar, sizeof(propvar));
            propvar.vt = VT_LPSTR;
            propvar.pszVal = pdi->item.pszText;
            
            SideAssert(S_OK == pIRule->SetProp(RULE_PROP_NAME, 0, &propvar));

            // Mark the rule list as dirty
            m_dwState |= STATE_DIRTY;
        
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnRuleDescValid
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FOnRuleDescValid(VOID)
{
    BOOL        fRet = FALSE;
    INT         iSelected = 0;
    LVITEM      lvitem;
    IOERule *   pIRule = NULL;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar;

    Assert(NULL != m_hwndList);
    
    // Get the selected item
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
    if (-1 == iSelected)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the current state of the rule
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    
    // If the rule already valid, then bail
    if (lvitem.state != INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // If we are still, invalid then bail
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the new enabled value
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the UI to the proper enabled state
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_STATE;
    lvitem.iItem = iSelected;
    lvitem.state = (!!propvar.boolVal) ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                            INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    
    ListView_SetItem(m_hwndList, &lvitem);

    fRet = TRUE;
    
exit:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\viewsui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  ViewsUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "ruledesc.h"

// Views Manager UI Class
class COEViewsMgrUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };
        
    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        HWND                m_hwndDescript;
        CRuleDescriptUI *   m_pDescriptUI;
        RULEID *            m_pridRule;
        IOERule *           m_pIRuleDownloaded;
        BOOL                m_fApplyAll;
        
    public:
        // Constructor/destructor
        COEViewsMgrUI();
        ~COEViewsMgrUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULEID * pridRule);
        HRESULT HrShow(BOOL * pfApplyAll);
        
        // Dialog methods
        static INT_PTR CALLBACK FOEViewMgrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);
        
    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddViewToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule, BOOL fSelect);
        VOID _EnableButtons(INT iSelected);
        VOID _EnableView(INT iSelected);

        // For dealing with the description field
        VOID _LoadView(INT iSelected);
        BOOL _FSaveView(INT iSelected);

        // Functions to deal with the basic actions
        VOID _NewView(VOID);
        VOID _EditView(INT iSelected);
        VOID _RemoveView(INT iSelected);
        VOID _CopyView(INT iSelected);
        VOID _DefaultView(INT iSelected);
        BOOL _FOnOK(VOID);
        BOOL _FOnCancel(VOID);
        BOOL _FGetDefaultItem(IOERule ** ppIRuleDefault, RULEID * pridDefault);
        BOOL _FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi);
};

BOOL FIsFilterReadOnly(RULEID ridFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\spamui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  SpamUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "rulesui.h"
#include "addrrule.h"

enum SENDER_FLAGS
{
    SNDF_NONE   = 0x00000000,
    SNDF_MAIL   = 0x00000001,
    SNDF_NEWS   = 0x00000002
};

enum EXCPTLIST_FLAGS
{
    ELF_NONE    = 0x00000000,
    ELF_WAB     = 0x00000001
};

// Type definitions
typedef struct tagCOLUMNITEM
{
    UINT            uidsName;
    UINT            uiWidth;
} COLUMNITEM, * PCLOUMNITEM;

typedef struct tagEDIT_SENDER
{
    DWORD       dwFlags;
    LONG        lSelected;
    LPSTR       pszSender;
} EDIT_SENDER, * PEDIT_SENDER;

// Class definitions
class CEditSenderUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndSender;

        EDIT_SENDER *   m_pEditSender;

    public:
        CEditSenderUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndSender(NULL), m_pEditSender(NULL) {}
        ~CEditSenderUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_SENDER * pEditSender);
        HRESULT HrShow(VOID);

        static INT_PTR CALLBACK FEditSendersDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
};

class CExceptionsListUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndList;
        ULONG           m_cchLabelMax;
        IOERule *       m_pIRule;

    public:
        CExceptionsListUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndList(NULL), m_hwndDlg(NULL), m_cchLabelMax(0), 
                        m_pIRule(NULL) {}
        ~CExceptionsListUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(IOERule * pIRule);

        static INT_PTR CALLBACK FExceptionsListDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);

    private:
        // Functions to deal with the basic actions
        VOID _NewException(VOID);
        VOID _EditException(INT iSelected);
        VOID _RemoveException(INT iSelected);
        BOOL _FOnOK(VOID);

        // Utility functions
        BOOL _FInitCtrls(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FSaveListCtrl(VOID);
        BOOL _FAddExceptionToList(LPSTR pszExcpt, ULONG * pulIndex);
        void _EnableButtons(INT iSelected);        
};

class COEJunkRulesPageUI : public COERulesPageUI
{
    private:
        enum
        {
            STATE_CTRL_INIT     = 0x00000010
        };
    
        enum {
            ID_JUNK_SCALE = 0,
            ID_JUNK_DELETE,
            ID_MAX
        };
        
    private:
        HWND                m_hwndOwner;
        HWND                m_hwndDlg;
        HIMAGELIST          m_himl;
        CExceptionsListUI * m_pExceptionsUI;
        IOERule *           m_pIRuleJunk;
        
    public:
        COEJunkRulesPageUI() : COERulesPageUI(iddRulesJunk, idsRulesJunk, 0, 0), m_hwndOwner(NULL),
                    m_hwndDlg(NULL), m_himl(NULL), m_pExceptionsUI(NULL), m_pIRuleJunk(NULL) {}
        virtual ~COEJunkRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FJunkRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FJunkRulesPageDlgProc;}
        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnHScroll(INT iScrollCode, short int iPos, HWND hwndCtl);
        BOOL FOnDestroy(VOID) {return FALSE;}

    private:
        BOOL _FInitCtrls(VOID);
        BOOL _FLoadJunkSettings();
        BOOL _FSaveJunkSettings();
        VOID _EnableButtons(VOID);
};

class COESendersRulesPageUI : public COERulesPageUI
{
    private:
        enum BLOCK_TYPE
        {
            BLOCK_NONE  = 0x00000000,
            BLOCK_MAIL  = 0x00000001,
            BLOCK_NEWS  = 0x00000002
        };
        
    private:
        HWND                    m_hwndOwner;
        HWND                    m_hwndDlg;
        HWND                    m_hwndList;
        IOERule *               m_pIRuleMail;
        IOERule *               m_pIRuleNews;
        ULONG                   m_cchLabelMax;

        static const COLUMNITEM m_rgcitem[];
        static const UINT       m_crgcitem;
        
    public:
        COESendersRulesPageUI() : COERulesPageUI(iddRulesSenders, idsRulesSenders, 0, 0),
                                    m_hwndOwner(NULL), m_hwndDlg(NULL), m_hwndList(NULL),
                                    m_pIRuleMail(NULL), m_pIRuleNews(NULL), m_cchLabelMax(0) {};
        virtual ~COESendersRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FSendersRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FSendersRulesPageDlgProc;}
        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID) {return FALSE;}
        BOOL FFindItem(LPCSTR pszFind, LONG lSkip);

    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);

        BOOL _FAddSenderToList(RULE_TYPE type, LPSTR pszSender);
        void _EnableButtons(INT iSelected);
        void _EnableSender(RULE_TYPE type, INT iSelected);
        BOOL _FLoadSenders(RULE_TYPE type, IOERule * pIRule);
        BOOL _FSaveSenders(RULE_TYPE type);
        BOOL _FFindSender(LPCSTR pszSender, LONG lSkip, LONG * plSender);
        
        // Functions to deal with the basic actions
        VOID _NewSender(VOID);
        VOID _EditSender(INT iSelected);
        VOID _RemoveSender(INT iSelected);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\spamui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  SpamUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "oerules.h"
#include "spamui.h"
#include "junkrule.h"
#include "rule.h"
#include "ruleutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <msoejunk.h>
#include "shlwapip.h" 
#include <ipab.h>
#include <demand.h>

// Type definitions
typedef struct tagEDIT_EXCPT
{
    DWORD       dwFlags;
    LPSTR       pszExcpt;
} EDIT_EXCPT, * PEDIT_EXCPT;

// Class definitions
class CEditExceptionUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndExcpt;

        EDIT_EXCPT *    m_pEditExcpt;

    public:
        CEditExceptionUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndExcpt(NULL), m_pEditExcpt(NULL) {}
        ~CEditExceptionUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_EXCPT * pEditExcpt);
        HRESULT HrShow(VOID);

        static INT_PTR CALLBACK FEditExcptDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
};

// global data
const static HELPMAP g_rgCtxMapJunkRules[] = {
                        {idcJunkMail,       idhJunkMail},
                        {idbExceptions,     idhExceptions},
                        {idcJunkSlider,     idhJunkSlider},
                        {idcJunkDelete,     idhJunkDelete},
                        {0, 0}};
                       
const static HELPMAP g_rgCtxMapSenderRules[] = {
                        {idbAddSender,      idhAddSender},
                        {idbModifySender,   idhModifySender},
                        {idbRemoveSender,   idhRemoveSender},
                        {0, 0}};
                       
CEditSenderUI::~CEditSenderUI()
{
    if ((NULL != m_pEditSender) && (NULL != m_pEditSender->pszSender))
    {
        MemFree(m_pEditSender->pszSender);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the edit sender UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//  pEditSender - the edit sender parameters
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditSenderUI::HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_SENDER * pEditSender)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if ((NULL == hwndOwner) || (NULL == pEditSender))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pEditSender = pEditSender;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the edit sender UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditSenderUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddEditSender),
                                        m_hwndOwner, CEditSenderUI::FEditSendersDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditSendersDlgProc
//
//  This is the main dialog proc for entering a sender
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditSenderUI::FEditSendersDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CEditSenderUI * pEditSenderUI = NULL;

    pEditSenderUI = (CEditSenderUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            pEditSenderUI = (CEditSenderUI *) lParam;
            if (NULL == pEditSenderUI)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pEditSenderUI);

            if (FALSE == pEditSenderUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pEditSenderUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit senders dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditSenderUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL    fRet = FALSE;
    UINT    uiCtrl = 0;
    HWND    hwndCtrl = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    UINT    uiTitle = 0;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndSender = GetDlgItem(hwndDlg, idedtSender);
    if (NULL == m_hwndSender)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we have a sender, then set it into the list
    if (NULL != m_pEditSender->pszSender)
    {
        // Misformatted sender?
        if (SNDF_NONE == m_pEditSender->dwFlags)
        {
            fRet = FALSE;
            goto exit;
        }

        // Set the sender into the dialog
        Edit_SetText(m_hwndSender, m_pEditSender->pszSender);

        // Set the proper 
        if ((SNDF_MAIL | SNDF_NEWS) == m_pEditSender->dwFlags)
        {
            uiCtrl = idcBlockBoth;
        }
        else if (SNDF_NEWS == m_pEditSender->dwFlags)
        {
            uiCtrl = idcBlockNews;
        }
        else
        {
            uiCtrl = idcBlockMail;
        }

        uiTitle = idsEditBlockSender;
    }
    else
    {
        Edit_SetText(m_hwndSender, c_szEmpty);

        uiCtrl = idcBlockMail;

        uiTitle = idsAddBlockSender;
    }

    // Get the window title
    AthLoadString(uiTitle, szRes, sizeof(szRes));
    
    // Set the window title
    SetWindowText(m_hwndDlg, szRes);
    
    hwndCtrl = GetDlgItem(m_hwndDlg, uiCtrl);
    if (NULL == hwndCtrl)
    {
        fRet = FALSE;
        goto exit;
    }

    SendMessage(hwndCtrl, BM_SETCHECK, (WPARAM) BST_CHECKED, (LPARAM) 0);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditSenderUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    ULONG   cchSender = 0;
    LPSTR   pszSender = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    LPSTR   pszText = NULL;

    // Deal with the edit control notifications
    if ((EN_CHANGE == uiNotify) && (idedtSender == iCtl))
    {
        Assert(NULL != m_hwndSender);
        Assert((HWND) hwndCtl == m_hwndSender);

        RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndSender));
        goto exit;
    }
    
    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case IDOK:
            // Get the sender from the edit well
            cchSender = Edit_GetTextLength(m_hwndSender) + 1;
            if (FAILED(HrAlloc((void **) &pszSender, cchSender * sizeof(*pszSender))))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszSender[0] = '\0';
            cchSender = Edit_GetText(m_hwndSender, pszSender, cchSender);
            
            // Check to see if the sender is valid
            if (0 == UlStripWhitespace(pszSender, TRUE, TRUE, NULL))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsSenderBlank), NULL,
                                MB_OK | MB_ICONINFORMATION);
                fRet = FALSE;
                goto exit;
            }

            if (FALSE != SendMessage(m_hwndOwner, WM_OE_FIND_DUP, (WPARAM) (m_pEditSender->lSelected), (LPARAM) pszSender))
            {
                AthLoadString(idsSenderDupWarn, szRes, sizeof(szRes));
                
                DWORD cchSize = (lstrlen(pszSender) * 2 + lstrlen(szRes) + 1);
                if (FAILED(HrAlloc((VOID **) &pszText, cchSize * sizeof(*pszText))))
                {
                    fRet = FALSE;
                    goto exit;
                }

                wnsprintf(pszText, cchSize, szRes, pszSender, pszSender);
                
                // Put up a message saying something is busted
                if (IDYES != AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail),
                                pszText, NULL, MB_YESNO | MB_ICONINFORMATION))
                {
                    fRet = FALSE;
                    goto exit;
                }
            }
            
            // Save off the sender
            SafeMemFree(m_pEditSender->pszSender);
            m_pEditSender->pszSender = pszSender;
            pszSender = NULL;

            if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockMail),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_MAIL;
            }
            else if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockNews),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_NEWS;
            }
            else if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockBoth),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_MAIL | SNDF_NEWS;
            }
            
            EndDialog(m_hwndDlg, IDOK);
            fRet = TRUE;
            break;
    }
    
exit:
    SafeMemFree(pszText);
    SafeMemFree(pszSender);
    return fRet;
}

// This is for editing the exceptions from the exceptions list UI

///////////////////////////////////////////////////////////////////////////////
//
//  ~CEditExceptionUI
//
//  This is the default destructor for the Exception editor
//
//  Returns:    None
//
///////////////////////////////////////////////////////////////////////////////
CEditExceptionUI::~CEditExceptionUI()
{
    if ((NULL != m_pEditExcpt) && (NULL != m_pEditExcpt->pszExcpt))
    {
        MemFree(m_pEditExcpt->pszExcpt);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the edit exception UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//  pEditExcpt - the edit exception parameters
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditExceptionUI::HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_EXCPT * pEditExcpt)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if ((NULL == hwndOwner) || (NULL == pEditExcpt))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pEditExcpt = pEditExcpt;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the edit exception UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditExceptionUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddEditException),
                                        m_hwndOwner, CEditExceptionUI::FEditExcptDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditExcptDlgProc
//
//  This is the main dialog proc for entering an exception
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditExceptionUI::FEditExcptDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    CEditExceptionUI *  pEditExcptUI = NULL;

    pEditExcptUI = (CEditExceptionUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            pEditExcptUI = (CEditExceptionUI *) lParam;
            if (NULL == pEditExcptUI)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pEditExcptUI);

            if (FALSE == pEditExcptUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pEditExcptUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit exception dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditExceptionUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL    fRet = FALSE;
    UINT    uiCtrl = 0;
    HWND    hwndCtrl = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    UINT    uiTitle = 0;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndExcpt = GetDlgItem(hwndDlg, idedtException);
    if (NULL == m_hwndExcpt)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we have a sender, then set it into the list
    if (NULL != m_pEditExcpt->pszExcpt)
    {
        // Set the sender into the dialog
        Edit_SetText(m_hwndExcpt, m_pEditExcpt->pszExcpt);

        uiTitle = idsEditException;
    }
    else
    {
        Edit_SetText(m_hwndExcpt, c_szEmpty);
        
        uiTitle = idsAddException;
    }
    
    // Get the window title
    AthLoadString(uiTitle, szRes, sizeof(szRes));
    
    // Set the window title
    SetWindowText(m_hwndDlg, szRes);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the exception UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditExceptionUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    ULONG   cchExcpt = 0;
    LPSTR   pszExcpt = NULL;

    // Deal with the edit control notifications
    if ((EN_CHANGE == uiNotify) && (idedtException == iCtl))
    {
        Assert(NULL != m_hwndExcpt);
        Assert((HWND) hwndCtl == m_hwndExcpt);

        RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndExcpt));
        goto exit;
    }
    
    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case IDOK:
            // Get the sender from the edit well
            cchExcpt = Edit_GetTextLength(m_hwndExcpt) + 1;
            if (FAILED(HrAlloc((void **) &pszExcpt, cchExcpt * sizeof(*pszExcpt))))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszExcpt[0] = '\0';
            cchExcpt = Edit_GetText(m_hwndExcpt, pszExcpt, cchExcpt);
            
            // Check to see if the sender is valid
            if (0 == UlStripWhitespace(pszExcpt, TRUE, TRUE, NULL))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsExceptionBlank), NULL,
                                MB_OK | MB_ICONINFORMATION);
                MemFree(pszExcpt);
                fRet = FALSE;
                goto exit;
            }

            // Save off the sender
            SafeMemFree(m_pEditExcpt->pszExcpt);
            m_pEditExcpt->pszExcpt = pszExcpt;

            EndDialog(m_hwndDlg, IDOK);
            fRet = TRUE;
            break;
    }
    
exit:
    return fRet;
}

// Default destructor for the Junk Rules UI
COEJunkRulesPageUI::~COEJunkRulesPageUI()
{
    if (NULL != m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    
    if (NULL != m_pExceptionsUI)
    {
        delete m_pExceptionsUI;
        m_pExceptionsUI = NULL;
    }
    SafeRelease(m_pIRuleJunk);
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the junk UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Let's create the Exception List UI
    m_pExceptionsUI = new CExceptionsListUI;
    if (NULL == m_pExceptionsUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    BOOL        fJunkEnable = FALSE;
    DWORD       dwVal = 0;
    RULEINFO    infoRule = {0};
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if (0 == (m_dwState & STATE_DIRTY))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Save the junk mail rule settings
    if (FALSE == _FSaveJunkSettings())
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_JUNK;
    infoRule.pIRule = m_pIRuleJunk;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_JUNK, RULE_TYPE_MAIL, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we delete items from the Junk folder
    dwVal = (BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete))) ? 1 : 0;
    
    SetDwOption(OPT_DELETEJUNK, dwVal, NULL, 0);

    // How many days should we wait?
    dwVal = (DWORD) SendMessage(GetDlgItem(m_hwndDlg, idcJunkDeleteSpin), UDM_GETPOS, (WPARAM) 0, (LPARAM) 0);

    if (0 == HIWORD(dwVal))
    {
        SetDwOption(OPT_DELETEJUNKDAYS, dwVal, NULL, 0);
    }

    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEJunkRulesPageUI::FJunkRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEJunkRulesPageUI *    pJunkUI = NULL;

    pJunkUI = (COEJunkRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pJunkUI = (COEJunkRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pJunkUI);

            if (FALSE == pJunkUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            }
            break;

        case WM_NOTIFY:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            }
            break;

        case WM_HSCROLL:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnHScroll((INT) LOWORD(wParam), (short int) HIWORD(wParam), (HWND) lParam);
            }
            break;

        case WM_DESTROY:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnDestroy();
            }
            break;  
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet =  OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapJunkRules);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    HRESULT         hr = S_OK;
    PROPVARIANT     propvar = {0};

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Make sure we don't lose any changes

    // Get the correct rule
    if (RULE_TYPE_MAIL == typeRule)
    {
        if (FALSE != _FSaveJunkSettings())
        {
            pIRule = m_pIRuleJunk;
        }
    }
    else
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        fRet = TRUE;
        goto exit;
    }

    // Skip over invalid rules
    hr = pIRule->Validate(0);
    if (FAILED(hr) || (S_FALSE == hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Skip over the junk rule if it is disabled
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if ((FAILED(hr)) || (FALSE != propvar.boolVal))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Create a new rule node
    prnodeNew = new RULENODE;
    if (NULL == prnodeNew)
    {
        fRet = FALSE;
        goto exit;
    }

    prnodeNew->pNext = NULL;
    prnodeNew->pIRule = pIRule;
    prnodeNew->pIRule->AddRef();
    
    // Set the outgoing param
    *pprnode = prnodeNew;
    prnodeNew = NULL;
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; // MemFree(prnodeNew);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the junk UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    CHAR            szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Initialize the controls
    fRet = _FInitCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Initialize the Exceptions List
    if (FAILED(m_pExceptionsUI->HrInit(m_hwndDlg, m_dwFlags)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FALSE != FIsIMAPOrHTTPAvailable())
    {
        AthLoadString(idsJunkMailNoIMAP, szRes, sizeof(szRes));

        SetDlgItemText(m_hwndDlg, idcJunkTitle, szRes);
    }
    
    // Update the buttons
    _EnableButtons();
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    
    switch (iCtl)
    {
        case idcJunkMail:
            if (BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)))
            {
                if (NULL == m_pIRuleJunk)
                {
                    hr = HrCreateJunkRule(&m_pIRuleJunk);
                    if (FAILED(hr))
                    {
                        fRet = FALSE;
                        SafeRelease(m_pIRuleJunk);
                        goto exit;
                    }
                }
            }
            // Fall through
            
        case idcJunkDelete:
            // Update the buttons
            _EnableButtons();
            
            // Note that the state has changed
            m_dwState |= STATE_DIRTY;
            fRet = FALSE;
            break;
            
        case idedtJunkDelete:
            if ((0 != (m_dwState & STATE_CTRL_INIT)) && (EN_CHANGE == uiNotify))
            {
                // Note that the state has changed
                m_dwState |= STATE_DIRTY;
                fRet = FALSE;
            }
            break;

        case idbExceptions:
            if (S_OK == m_pExceptionsUI->HrShow(m_pIRuleJunk))
            {
                // Note that the state has changed
                m_dwState |= STATE_DIRTY;
                fRet = FALSE;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    if (idcJunkDeleteSpin != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case UDN_DELTAPOS:
            // Note that the state has changed
            m_dwState |= STATE_DIRTY;
            fRet = FALSE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnHScroll
//
//  This handles the WM_NOTIFY message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnHScroll(INT iScrollCode, short int iPos, HWND hwndCtl)
{
    BOOL            fRet = FALSE;

    // We only handle messags for the slider control
    if (GetDlgItem(m_hwndDlg, idcJunkSlider) != hwndCtl)
    {
        fRet = FALSE;
        goto exit;
    }

    // Note that the state has changed
    m_dwState |= STATE_DIRTY;
    fRet = FALSE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitCtrls
//
//  This initializes the controls in the junk UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FInitCtrls(VOID)
{
    BOOL        fRet = FALSE;
    DWORD       dwJunkPct = 0;
    BOOL        fEnableDelete = FALSE;
    HICON       hIcon = NULL;
    IOERule *   pIRuleOrig = NULL;
    IOERule *   pIRule = NULL;
    HRESULT     hr = S_OK;
    
    // Get the icons
    m_himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbRules), 32, 0,
                                    RGB(255, 0, 255));
    if (NULL == m_himl)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the icons into the dialog
    hIcon = ImageList_GetIcon(m_himl, ID_JUNK_SCALE, ILD_TRANSPARENT);
    SendDlgItemMessage(m_hwndDlg, idcJunkSliderIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(m_himl, ID_JUNK_DELETE, ILD_TRANSPARENT);
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    // Set the range of the slider
    SendDlgItemMessage(m_hwndDlg, idcJunkSlider, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG(0, 4));
    
    // Get the junk mail rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_JUNK, RULE_TYPE_MAIL, 0, &pIRuleOrig);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Save off the junk mail rule
    Assert (NULL == m_pIRuleJunk);
    hr = pIRuleOrig->Clone(&pIRule);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    m_pIRuleJunk = pIRule;
    pIRule = NULL;

    // Get the setings from the junk rule
    _FLoadJunkSettings();
    
    // Do we want to delete the junk mail
    fEnableDelete = !!DwGetOption(OPT_DELETEJUNK);
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete), fEnableDelete ? BST_CHECKED : BST_UNCHECKED);

    // Set the range of the spinner
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteSpin, UDM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELONG(999, 1));
    
    // How many days should we wait?
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteSpin, UDM_SETPOS, (WPARAM) 0,
                (LPARAM) MAKELONG(DwGetOption(OPT_DELETEJUNKDAYS), 0));
    if (FALSE == fEnableDelete)
    {
        EnableWindow(GetDlgItem(m_hwndDlg, idcJunkDeleteSpin), FALSE);
        EnableWindow(GetDlgItem(m_hwndDlg, idedtJunkDelete), FALSE);
    }
    
    m_dwState |= STATE_CTRL_INIT;
    
    // We worked
    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadJunkSettings
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FLoadJunkSettings()
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    int         iEnabled = 0;
    DWORD       dwJunkPct = 0;
    
    Assert(NULL != m_pIRuleJunk);
    
    // Get the Junk detection enabled state
    iEnabled = BST_UNCHECKED;
    if ((SUCCEEDED(m_pIRuleJunk->GetProp(RULE_PROP_DISABLED, 0, &propvar))))
    {
        Assert(VT_BOOL == propvar.vt);
        iEnabled = (FALSE == propvar.boolVal) ? BST_CHECKED : BST_UNCHECKED;
    }

    // Set the junk mail flag
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcJunkMail), iEnabled);
    
    // Get the Junk percent
    dwJunkPct = 2;
    if (SUCCEEDED(m_pIRuleJunk->GetProp(RULE_PROP_JUNKPCT, 0, &propvar)))
    {
        Assert(VT_UI4 == propvar.vt);
        dwJunkPct = propvar.ulVal;
    }

    // Set the Junk percent
    SendDlgItemMessage(m_hwndDlg, idcJunkSlider, TBM_SETPOS, (WPARAM) TRUE, (LPARAM) dwJunkPct);
    
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveJunkSettings
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FSaveJunkSettings()
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    BOOL        fDisabled = 0;
    DWORD       dwJunkPct = 0;
    HRESULT     hr = S_OK;

    Assert(NULL != m_pIRuleJunk);
    
    // Get the Junk detection enabled state
    fDisabled = !!(BST_UNCHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)));

    // Set the disabled state
    propvar.vt = VT_BOOL;
    propvar.boolVal = (VARIANT_BOOL) !!fDisabled;
    if (FAILED(m_pIRuleJunk->SetProp(RULE_PROP_DISABLED, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the Junk percent
    dwJunkPct = (DWORD) SendMessage(GetDlgItem(m_hwndDlg, idcJunkSlider), TBM_GETPOS, (WPARAM) 0, (LPARAM) 0);

    // Set the Junk percent
    propvar.vt = VT_UI4;
    propvar.ulVal = dwJunkPct;
    if (FAILED(m_pIRuleJunk->SetProp(RULE_PROP_JUNKPCT, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the junk UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEJunkRulesPageUI::_EnableButtons(VOID)
{
    int         cRules = 0;
    BOOL        fEnableJunk = FALSE;
    BOOL        fEnableDelete = FALSE;
    
    // Get the enabled state of Junk
    fEnableJunk = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)));

    // Get the enabled state of Delete
    fEnableDelete = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete)));

    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDays, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDeleteSpin, (fEnableDelete && fEnableJunk));
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idedtJunkDelete, (fEnableDelete && fEnableJunk));
        
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDelete, fEnableJunk);

    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSliderMore, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSlider, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSliderLess, fEnableJunk);
    
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbExceptions, fEnableJunk);

    return;
}

const COLUMNITEM COESendersRulesPageUI::m_rgcitem[] =
{
    {idsCaptionMail, 50},
    {idsCaptionNews, 50},
    {idsSenderDesc, 105}
};

const UINT COESendersRulesPageUI::m_crgcitem = ARRAYSIZE(COESendersRulesPageUI::m_rgcitem);

// Default destructor for the Mail Rules UI
COESendersRulesPageUI::~COESendersRulesPageUI()
{
    SafeRelease(m_pIRuleMail);
    SafeRelease(m_pIRuleNews);
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the senders UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COESendersRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COESendersRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    RULEINFO    infoRule = {0};

    Assert(NULL != m_hwndList);
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if (0 == (m_dwState & STATE_DIRTY))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Save the mail senders
    if (FALSE == _FSaveSenders(RULE_TYPE_MAIL))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = m_pIRuleMail;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, RULE_TYPE_MAIL, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Save the news senders
    if (FALSE == _FSaveSenders(RULE_TYPE_NEWS))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = m_pIRuleNews;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, RULE_TYPE_NEWS, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    return hr;
}

INT_PTR CALLBACK COESendersRulesPageUI::FSendersRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COESendersRulesPageUI * pSendersUI = NULL;

    pSendersUI = (COESendersRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pSendersUI = (COESendersRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pSendersUI);

            if (FALSE == pSendersUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pSendersUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pSendersUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pSendersUI->FOnDestroy();
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapSenderRules);
            break;

        case WM_OE_FIND_DUP:
            fRet = pSendersUI->FFindItem((LPCSTR) lParam, (LONG) wParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    HRESULT         hr = S_OK;

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if ((0 == (m_dwState & STATE_INITIALIZED)) || (NULL == m_hwndList))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Make sure we don't loose any changes
    _FSaveSenders(typeRule);
    
    if (RULE_TYPE_MAIL == typeRule)
    {
        pIRule = m_pIRuleMail;
    }
    else if (RULE_TYPE_NEWS == typeRule)
    {
        pIRule = m_pIRuleNews;
    }
    else
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        fRet = TRUE;
        goto exit;
    }

    // Skip over invalid rules
    hr = pIRule->Validate(0);
    if (FAILED(hr) || (S_FALSE == hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Create a new rule node
    prnodeNew = new RULENODE;
    if (NULL == prnodeNew)
    {
        fRet = FALSE;
        goto exit;
    }

    prnodeNew->pNext = NULL;
    prnodeNew->pIRule = pIRule;
    prnodeNew->pIRule->AddRef();

    // Set the outgoing param
    *pprnode = prnodeNew;
    prnodeNew = NULL;
    
    fRet = TRUE;
    
exit:
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; // MemFree(prnodeNew);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the senders UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    CHAR            szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvSenderList);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    if (FALSE != FIsIMAPOrHTTPAvailable())
    {
        AthLoadString(idsBlockSenderNoIMAP, szRes, sizeof(szRes));

        SetDlgItemText(m_hwndDlg, idcSenderTitle, szRes);
    }
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idbAddSender:
            _NewSender();
            fRet = TRUE;
            break;

        case idbModifySender:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditSender(iSelected);
                fRet = TRUE;
            }
            break;

        case idbRemoveSender:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveSender(iSelected);
                fRet = TRUE;
            }
            break;            
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    if (idlvSenderList != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_SubItemHitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state
                        if (2 != lvh.iSubItem)
                        {
                            _EnableSender((0 != lvh.iSubItem) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, iSelected);
                        }
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_SubItemHitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (((0 == (lvh.flags & LVHT_ONITEMICON)) &&
                            (0 != (lvh.flags & LVHT_ONITEMLABEL))) || (2 == lvh.iSubItem))
                    {
                        // Edit the rule
                        _EditSender(iSelected);
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The delete key removes the rule from the list view
            if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveSender(iSelected);
                }
            }
            break;
    }

    
exit:
    return fRet;
}
///////////////////////////////////////////////////////////////////////////////
//
//  FFindItem
//
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FFindItem(LPCSTR pszFind, LONG lSkip)
{
    BOOL    fRet = FALSE;

    fRet = _FFindSender(pszFind, lSkip, NULL);

    // Tell the dialog it's aok to proceed
    SetDlgMsgResult(m_hwndDlg, WM_OE_FIND_DUP, fRet);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the senders dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc;
    TCHAR       szRes[CCHMAX_STRINGRES];
    RECT        rc;
    UINT        ulIndex = 0;
    HIMAGELIST  himl = NULL;

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = szRes;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Add the columns to the list view
    for (ulIndex = 0; ulIndex < m_crgcitem; ulIndex++)
    {
        Assert(g_hLocRes);
        LoadString(g_hLocRes, m_rgcitem[ulIndex].uidsName, szRes, ARRAYSIZE(szRes));
        lvc.cchTextMax = lstrlen(szRes);

        if (ulIndex != (m_crgcitem - 1))
        {
            lvc.cx = m_rgcitem[ulIndex].uiWidth;
            rc.right -= lvc.cx;
        }
        else
        {
            lvc.cx = rc.right;
        }
        
        ListView_InsertColumn(m_hwndList, ulIndex, &lvc);
    }

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_SMALL);
    }

    // Full row selection  and subitem images on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current senders
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    IOERule *       pIRuleOrig = NULL;
    IOERule *       pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Get the mail sender rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_MAIL, 0, &pIRuleOrig);
    if (SUCCEEDED(hr))
    {
        // If the block sender rule exist
        if (FALSE != _FLoadSenders(RULE_TYPE_MAIL, pIRuleOrig))
        {
            Assert (NULL == m_pIRuleMail);
            hr = pIRuleOrig->Clone(&pIRule);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }

            m_pIRuleMail = pIRule;
            pIRule = NULL;
        }        
    }

    SafeRelease(pIRuleOrig);
    
    // Get the news sender rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_NEWS, 0, &pIRuleOrig);
    if (SUCCEEDED(hr))
    {
        // If the block sender rule exist
        if (FALSE != _FLoadSenders(RULE_TYPE_NEWS, pIRuleOrig))
        {
            Assert (NULL == m_pIRuleNews);
            hr = pIRuleOrig->Clone(&pIRule);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }

            m_pIRuleNews = pIRule;
            pIRule = NULL;
        }        
    }

    SafeRelease(pIRuleOrig);
    
    // Select the first item in the list
    if ((NULL != m_pIRuleMail) || (NULL != m_pIRuleNews))
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons(((NULL != m_pIRuleMail) || (NULL != m_pIRuleNews)) ? 0 : -1);

    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FAddSenderToList(RULE_TYPE type, LPSTR pszSender)
{
    BOOL        fRet = FALSE;
    LONG        lIndex = 0;
    LVITEM      lvitem = {0};
    ULONG       cchSender = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pszSender)
    {
        fRet = FALSE;
        goto exit;
    }
    
    lvitem.mask = LVIF_IMAGE;
    
    // Insert it if we didn't find it
    if (FALSE == _FFindSender(pszSender, -1, &lIndex))
    {
        lvitem.iItem = ListView_GetItemCount(m_hwndList);
        lvitem.iImage = iiconStateUnchecked;

        lIndex = ListView_InsertItem(m_hwndList, &lvitem);
        if (-1 == lIndex)
        {
            fRet = FALSE;
            goto exit;
        }

        lvitem.iItem = lIndex;
        lvitem.iSubItem = 1;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            fRet = FALSE;
            goto exit;
        }

        ListView_SetItemText(m_hwndList, lIndex, 2, pszSender);
        cchSender = lstrlen(pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }

    // Enable the proper type
    lvitem.iItem = lIndex;
    lvitem.iImage = iiconStateChecked;
    lvitem.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
    ListView_SetItem(m_hwndList, &lvitem);
    
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the senders UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COESendersRulesPageUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;

    Assert(NULL != m_hwndList);

    fSelected = (-1 != iSelected);
    
    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbRemoveSender, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifySender, fSelected);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableRule
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_EnableSender(RULE_TYPE type, int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi;
    IOERule *   pIRule = NULL;
    BOOL        fBlockNews = FALSE;
    BOOL        fBlockMail = FALSE;
    PROPVARIANT propvar;

    Assert(NULL != m_hwndList);
    
    // Are we blocking mail?
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_IMAGE;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    fBlockMail = (iiconStateUnchecked != lvi.iImage);
    
    // Are we blocking news?
    lvi.iSubItem = 1;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    fBlockNews = (iiconStateUnchecked != lvi.iImage);
    
    // Disallow disabling both mail and news
    if (((RULE_TYPE_MAIL == type) && (FALSE != fBlockMail) && (FALSE == fBlockNews)) ||
            ((RULE_TYPE_NEWS == type) && (FALSE != fBlockNews) && (FALSE == fBlockMail)))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRuleSenderErrorNone), NULL,
                        MB_OK | MB_ICONERROR);
        goto exit;
    }

    // Set the UI to the opposite enabled state
    lvi.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
    lvi.iImage = (RULE_TYPE_MAIL != type) ?
                    ((FALSE != fBlockNews) ? iiconStateUnchecked : iiconStateChecked) :
                        ((FALSE != fBlockMail) ? iiconStateUnchecked : iiconStateChecked);
    ListView_SetItem(m_hwndList, &lvi);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadSenders
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  type    - the type of senders these are
//  pIRule  - the rule to get the senders from
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FLoadSenders(RULE_TYPE type, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar;
    CRIT_ITEM * pCritItem = NULL;
    ULONG       cCritItem = 0;
    ULONG       ulIndex = 0;
    
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of senders from the rule
    if (FAILED(pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    if (0 != propvar.blob.cbSize)
    {
        Assert(VT_BLOB == propvar.vt);
        Assert(NULL != propvar.blob.pBlobData);
        cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
        pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
        propvar.blob.pBlobData = NULL;
        propvar.blob.cbSize = 0;

        // Add each sender to the list
        for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
        {
            if ((CRIT_TYPE_SENDER == pCritItem[ulIndex].type) &&
                    (VT_LPSTR == pCritItem[ulIndex].propvar.vt) &&
                    (NULL != pCritItem[ulIndex].propvar.pszVal))
            {
                _FAddSenderToList(type, pCritItem[ulIndex].propvar.pszVal);
            }
            
        }
    }
    
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveSenders
//
//  This save the senders from the list into the rule.
//
//  type    - the type of senders to save
//
//  Returns:    TRUE, if it was successfully saved
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FSaveSenders(RULE_TYPE type)
{
    BOOL            fRet = FALSE;
    ULONG           cSender = 0;
    LPSTR           pszSender = NULL;
    CRIT_ITEM *     pcitemList = NULL;
    ULONG           ccitemList = 0;
    LVITEM          lvitem;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    ACT_ITEM        aitem;
    PROPVARIANT     propvar;
    TCHAR           szRes[CCHMAX_STRINGRES];
    HRESULT         hr = S_OK;

    Assert(NULL != m_hwndList);

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Figure out how many senders we have
    cSender = ListView_GetItemCount(m_hwndList);

    if (0 != cSender)
    {
        // Allocate space to hold the sender
        if (FAILED(HrAlloc((void **) &pszSender, m_cchLabelMax)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszSender[0] = '\0';

        // Allocate space to hold the criteria
        if (FAILED(HrAlloc((void **) &pcitemList, cSender * sizeof(*pcitemList))))
        {
            fRet = FALSE;
            goto exit;
        }

        ZeroMemory(pcitemList, cSender * sizeof(*pcitemList));
    }
    
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_IMAGE;
    
    ccitemList = 0;
    for (ulIndex = 0; ulIndex < cSender; ulIndex++)
    {
        lvitem.iItem = ulIndex;
        lvitem.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            continue;
        }
        
        if (FALSE != (iiconStateUnchecked != lvitem.iImage))
        {
            // Grab the sender from the list
            pszSender[0] ='\0';
            ListView_GetItemText(m_hwndList, ulIndex, 2, pszSender, m_cchLabelMax);
            if ('\0' != pszSender[0])
            {
                // Grab a copy of the sender
                pcitemList[ccitemList].propvar.pszVal = PszDupA(pszSender);
                if (NULL == pcitemList[ccitemList].propvar.pszVal)
                {
                    fRet = FALSE;
                    goto exit;
                }
                
                // Set the criteria specifics
                pcitemList[ccitemList].type = CRIT_TYPE_SENDER;
                pcitemList[ccitemList].logic = CRIT_LOGIC_OR;
                pcitemList[ccitemList].dwFlags = CRIT_FLAG_DEFAULT;
                pcitemList[ccitemList].propvar.vt = VT_LPSTR;

                ccitemList++;
            }   
        }
    }

    if (0 != ccitemList)
    {
        // Which rule are we looking at
        pIRule = (RULE_TYPE_MAIL != type) ? m_pIRuleNews : m_pIRuleMail;
    
        // Check the state
        if (NULL == pIRule)
        {
            // Create the new rule
            if (FAILED(RuleUtil_HrCreateSendersRule(0, &pIRule)))
            {
                fRet = FALSE;
                goto exit;
            }            
        }
        else
        {
            pIRule->AddRef();
        }

        // Set the new criteria in the rule
        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(CRIT_ITEM) * ccitemList;
        propvar.blob.pBlobData = (BYTE *) pcitemList;
        
        // Grab the list of criteria from the rule
        if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    if (RULE_TYPE_MAIL != type)
    {
        SafeRelease(m_pIRuleNews);
        m_pIRuleNews = pIRule;
    }
    else
    {
        SafeRelease(m_pIRuleMail);
        m_pIRuleMail = pIRule;
    }
    pIRule = NULL;
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pcitemList, ccitemList);
    SafeMemFree(pcitemList);
    SafeMemFree(pszSender);
    SafeRelease(pIRule);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FFindSender
//
//  This brings up the edit UI to create a new sender for the senders list
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FFindSender(LPCSTR pszSender, LONG iSkip, LONG * plSender)
{
    BOOL    fRet = FALSE;
    LONG    cSenders = 0;
    LPSTR   pszLabel = NULL;
    LVITEM  lvitem = {0};
    LONG    lIndex = 0;
    
    // Check incoming params
    if (NULL == pszSender)
    {
        goto exit;
    }

    // Initialize the outgoing param
    if (NULL != plSender)
    {
        *plSender = -1;
    }
    
    // Get the number of senders
    cSenders = ListView_GetItemCount(m_hwndList);
    if (0 == cSenders)
    {
        goto exit;
    }
    
    if (FAILED(HrAlloc((void **) &pszLabel, m_cchLabelMax * sizeof(*pszLabel))))
    {
        goto exit;
    }
        
    // Set up the 
    lvitem.iSubItem = 2;
    lvitem.pszText = pszLabel;
    lvitem.cchTextMax = m_cchLabelMax;

    for (lIndex = 0; lIndex < cSenders; lIndex++)
    {
        // We need to skip over the selected item
        if (lIndex == iSkip)
        {
            continue;
        }
        
        if (0 != SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) lIndex, (LPARAM) &lvitem))
        {
            if (0 == lstrcmpi(pszLabel, pszSender))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    if (NULL != plSender)
    {
        if (lIndex < cSenders)
        {
            *plSender = lIndex;
        }
    }
    
exit:
    SafeMemFree(pszLabel);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewSender
//
//  This brings up the edit UI to create a new sender for the senders list
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_NewSender(VOID)
{
    HRESULT         hr = S_OK;
    EDIT_SENDER     editsndr = {0};
    CEditSenderUI * pEditSenderUI = NULL;
    LVITEM          lvitem = {0};
    LONG            iIndex = 0;
    ULONG           cchSender = 0;

    Assert(NULL != m_hwndList);

    editsndr.lSelected = -1;
    
    // Create the sender editor
    pEditSenderUI = new CEditSenderUI;
    if (NULL == pEditSenderUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditSenderUI->HrInit(m_hwndDlg, 0, &editsndr)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditSenderUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the sender changed, make sure we change the label
    if (S_OK == hr)
    {
        lvitem.mask = LVIF_IMAGE;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_MAIL)) ?
                                    iiconStateChecked : iiconStateUnchecked;

        // Are we inserting or replacing?
        if (FALSE == _FFindSender(editsndr.pszSender, -1, &iIndex))
        {
            lvitem.iItem = ListView_GetItemCount(m_hwndList);
            iIndex = ListView_InsertItem(m_hwndList, &lvitem);
            if (-1 == iIndex)
            {
                goto exit;
            }
        }
        else
        {
            lvitem.iItem = iIndex;
            if (-1 == ListView_SetItem(m_hwndList, &lvitem))
            {
                goto exit;
            }
        }
        
        lvitem.iItem = iIndex;
        lvitem.iSubItem = 1;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_NEWS)) ?
                                    iiconStateChecked : iiconStateUnchecked;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        ListView_SetItemText(m_hwndList, iIndex, 2, editsndr.pszSender);
        
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, iIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        
        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iIndex, FALSE);
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        cchSender = lstrlen(editsndr.pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }
    
exit:
    SafeMemFree(editsndr.pszSender);
    if (NULL != pEditSenderUI)
    {
        delete pEditSenderUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditSender
//
//  This brings up the edit UI for the selected sender from the senders list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_EditSender(int iSelected)
{
    HRESULT         hr = S_OK;
    EDIT_SENDER     editsndr = {0};
    LVITEM          lvitem = {0};
    CEditSenderUI * pEditSenderUI = NULL;
    ULONG           cchSender = 0;
    LONG            lItemDelete = 0;

    Assert(NULL != m_hwndList);
    
    editsndr.lSelected = iSelected;
    
    // Allocate space to hold the sender
    hr = HrAlloc((void **) &(editsndr.pszSender), m_cchLabelMax);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Grab the sender from the list
    lvitem.iSubItem = 2;
    lvitem.pszText = editsndr.pszSender;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Are we blocking mail?
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_IMAGE;
    lvitem.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }
    
    if (FALSE != (iiconStateUnchecked != lvitem.iImage))
    {
        editsndr.dwFlags |= SNDF_MAIL;
    }
    
    // Are we blocking news?
    lvitem.iSubItem = 1;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }
    
    if (FALSE != (iiconStateUnchecked != lvitem.iImage))
    {
        editsndr.dwFlags |= SNDF_NEWS;
    }

    // Create the rules editor
    pEditSenderUI = new CEditSenderUI;
    if (NULL == pEditSenderUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditSenderUI->HrInit(m_hwndDlg, 0, &editsndr)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditSenderUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the sender changed, make sure we change the label
    if (S_OK == hr)
    {
        // Do we want to remove a copy of the item
        (VOID) _FFindSender(editsndr.pszSender, iSelected, &lItemDelete);
        
        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.iItem = iSelected;
        lvitem.mask = LVIF_IMAGE;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_MAIL)) ?
                                    iiconStateChecked : iiconStateUnchecked;

        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        lvitem.iSubItem = 1;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_NEWS)) ?
                                    iiconStateChecked : iiconStateUnchecked;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        ListView_SetItemText(m_hwndList, iSelected, 2, editsndr.pszSender);

        // Make sure we remove the dup item
        if (-1 != lItemDelete)
        {
            // Remove the item from the list
            ListView_DeleteItem(m_hwndList, lItemDelete);
        }
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        cchSender = lstrlen(editsndr.pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }
    
exit:
    SafeMemFree(editsndr.pszSender);
    if (NULL != pEditSenderUI)
    {
        delete pEditSenderUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveSender
//
//  This removes the selected sender from the senders list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_RemoveSender(int iSelected)
{
    TCHAR       szRes[CCHMAX_STRINGRES];
    ULONG       cchRes = 0;
    LPSTR       pszSender = NULL;
    LVITEM      lvitem;
    LPSTR       pszMessage = NULL;
    int         cSenders = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRuleSenderWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the sender
    if (FAILED(HrAlloc((void **) &pszSender, m_cchLabelMax)))
    {
        goto exit;
    }
    
    // Grab the sender from the list
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.iSubItem = 2;
    lvitem.pszText = pszSender;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(pszSender) + 1);
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchSize)))
    {
        goto exit;
    }

    // Build up the string and display it
    wnsprintf(pszMessage, cchSize, szRes, pszSender);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cSenders = ListView_GetItemCount(m_hwndList);
    if (cSenders > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cSenders)
        {
            // Move the selection to the new last item in the list
            iSelected = cSenders - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszSender);
    SafeMemFree(pszMessage);
    return;
}

// Default destructor for the Exceptions List UI
CExceptionsListUI::~CExceptionsListUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the Exceptions List UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CExceptionsListUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the Exceptions List UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CExceptionsListUI::HrShow(IOERule * pIRule)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    // Check incoming params
    if (NULL == pIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the item
    m_pIRule = pIRule;
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddExceptionsList),
                                        m_hwndOwner, CExceptionsListUI::FExceptionsListDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CExceptionsListUI::FExceptionsListDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    CExceptionsListUI * pExceptionsUI = NULL;

    pExceptionsUI = (CExceptionsListUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pExceptionsUI = (CExceptionsListUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pExceptionsUI);

            if (FALSE == pExceptionsUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pExceptionsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pExceptionsUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the Exceptions List UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvExceptions);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the list view
    fRet = _FInitCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Set the focus into the list
    SetFocus(m_hwndList);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the Exceptions List UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idcAddException:
            _NewException();
            fRet = TRUE;
            break;

        case idcModifyException:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditException(iSelected);
                fRet = TRUE;
            }
            break;

        case idcRemoveException:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveException(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idcExceptionsWAB:
            // Mark the dialog as dirty
            m_dwState |= STATE_DIRTY;
            break;
            
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the Exceptions List UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh = {0};

    // We only handle notifications for the list control
    if (idlvExceptions != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 == pnmlv->iItem)
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the exception name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditException(iSelected);
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The delete key removes the rule from the list view
            if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveException(iSelected);
                }
            }
            break;
    }

    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewException
//
//  This brings up the edit UI to create a new exception for the Exception List
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_NewException(VOID)
{
    HRESULT             hr = S_OK;
    CEditExceptionUI *  pEditExcptUI = NULL;
    EDIT_EXCPT          editexcpt = {0};
    ULONG               ulIndex = 0;

    Assert(NULL != m_hwndList);
    
    // Create the sender editor
    pEditExcptUI = new CEditExceptionUI;
    if (NULL == pEditExcptUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditExcptUI->HrInit(m_hwndDlg, 0, &editexcpt)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditExcptUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the exception changed, make sure we change the label
    if (S_OK == hr)
    {
        if (FALSE == _FAddExceptionToList(editexcpt.pszExcpt, &ulIndex))
        {
            goto exit;
        }
        
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, ulIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        
        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, ulIndex, FALSE);
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;        
    }
    
exit:
    SafeMemFree(editexcpt.pszExcpt);
    if (NULL != pEditExcptUI)
    {
        delete pEditExcptUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditException
//
//  This brings up the edit UI for the selected exception from the Execption List
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_EditException(int iSelected)
{
    HRESULT             hr = S_OK;
    EDIT_EXCPT          editexcpt = {0};
    LVITEM              lvitem = {0};
    CEditExceptionUI *  pEditExcptUI = NULL;
    ULONG               cchExcpt = 0;
    LONG                lIndex = 0;
    LVFINDINFO          lvfi = {0};

    Assert(NULL != m_hwndList);
    
    // Allocate space to hold the exception
    hr = HrAlloc((void **) &(editexcpt.pszExcpt), m_cchLabelMax);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Grab the exception from the list
    lvitem.pszText = editexcpt.pszExcpt;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Create the exception editor
    pEditExcptUI = new CEditExceptionUI;
    if (NULL == pEditExcptUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditExcptUI->HrInit(m_hwndDlg, 0, &editexcpt)))
    {
        goto exit;
    }

    // Bring up the exception editor UI
    hr = pEditExcptUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the exception changed, make sure we change the label
    if (S_OK == hr)
    {
        lvfi.flags = LVFI_STRING;
        lvfi.psz = editexcpt.pszExcpt;
        
        // Check to see if the item already exists
        lIndex = ListView_FindItem(m_hwndList, -1, &lvfi);
        
        // If the item already exists 
        if ((-1 != lIndex) && (iSelected != lIndex))
        {
            // Make sure the duplicate item is selected
            ListView_SetItemState(m_hwndList, lIndex,
                    LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

            // Let's make sure we can see this new item
            ListView_EnsureVisible(m_hwndList, lIndex, FALSE);
            
            // Remove the item from the list
            ListView_DeleteItem(m_hwndList, iSelected);
        }
        else
        {
            ListView_SetItemText(m_hwndList, iSelected, 0, editexcpt.pszExcpt);
            
            cchExcpt = lstrlen(editexcpt.pszExcpt) + 1;
            if (cchExcpt > m_cchLabelMax)
            {
                m_cchLabelMax = cchExcpt;
            }
        }
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
    }
    
exit:
    SafeMemFree(editexcpt.pszExcpt);
    if (NULL != pEditExcptUI)
    {
        delete pEditExcptUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveException
//
//  This removes the selected exception from the Exception List
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_RemoveException(int iSelected)
{
    TCHAR       szRes[CCHMAX_STRINGRES];
    ULONG       cchRes = 0;
    LPSTR       pszExcpt = NULL;
    LVITEM      lvitem = {0};
    LPSTR       pszMessage = NULL;
    int         cExcpts = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRuleExcptWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the execptions
    if (FAILED(HrAlloc((void **) &pszExcpt, m_cchLabelMax)))
    {
        goto exit;
    }
    
    // Grab the exception from the list
    lvitem.pszText = pszExcpt;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(pszExcpt) + 1);
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchSize)))
    {
        goto exit;
    }

    // Build up the string and display it
    wnsprintf(pszMessage, cchSize, szRes, pszExcpt);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cExcpts = ListView_GetItemCount(m_hwndList);
    if (cExcpts > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cExcpts)
        {
            // Move the selection to the new last item in the list
            iSelected = cExcpts - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszExcpt);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This initializes the controls in the Exceptions List UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FOnOK(VOID)
{
    BOOL        fRet = FALSE;
    BOOL        fWABEnable = FALSE;
    PROPVARIANT propvar = {0};

    // Save of the list of addresses
    if (FALSE == _FSaveListCtrl())
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Are we supposed to check the WAB?
    fWABEnable = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcExceptionsWAB)));

    // Save of the state of the Check WAB button
    propvar.vt = VT_BOOL;
    propvar.boolVal = (VARIANT_BOOL) !!fWABEnable;
    if (FAILED(m_pIRule->SetProp(RULE_PROP_EXCPT_WAB, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Everything's fine
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitCtrls
//
//  This initializes the controls in the Exceptions List UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FInitCtrls(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc = {0};
    RECT        rc = {0};
    PROPVARIANT propvar = {0};
    
    Assert(NULL != m_hwndList);
    
    if (FAILED(m_pIRule->GetProp(RULE_PROP_EXCPT_WAB, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the Check WAB button
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcExceptionsWAB),
                (FALSE != propvar.boolVal) ? BST_CHECKED : BST_UNCHECKED);
                
    // Initialize the list view structure
    lvc.mask = LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Add the column to the list view
    ListView_InsertColumn(m_hwndList, 0, &lvc);

    // Full row selection  and subitem images on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current exceptions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FLoadListCtrl(VOID)
{
    BOOL                fRet = FALSE;
    ULONG               ulIndex = 0;
    IOERuleAddrList *   pIAddrList = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               cralList = 0;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Get the exceptions list from the rule
    if (FAILED(m_pIRule->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of exceptions from the address list
    if (FAILED(pIAddrList->GetList(0, &pralList, &cralList)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Add each item into the list
    for (ulIndex = 0; ulIndex < cralList; ulIndex++)
    {
        // Verify the item
        if (RALF_MAIL != pralList[ulIndex].dwFlags)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Add the item
        if (FALSE == _FAddExceptionToList(pralList[ulIndex].pszAddr, NULL))
        {
            fRet = FALSE;
            goto exit;
        }
    }
    
    // Select the first item in the list
    if (0 != cralList)
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != cralList) ? 0 : -1);

    fRet = TRUE;
    
exit:
    FreeRuleAddrList(pralList, cralList);
    SafeMemFree(pralList);
    SafeRelease(pIAddrList);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveListCtrl
//
//  This save the exceptions from the list view
//
//  Returns:    TRUE, if it was successfully saved
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FSaveListCtrl(VOID)
{
    BOOL                fRet = FALSE;
    ULONG               cExcpts = 0;
    LPSTR               pszAddr = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               ulIndex = 0;
    IOERuleAddrList *   pIAddrList = NULL;

    Assert(NULL != m_hwndList);

    // Figure out how many exceptions are in the list
    cExcpts = ListView_GetItemCount(m_hwndList);

    // If there are exceptions
    if (0 != cExcpts)
    {
        // Allocate space to hold the exceptions
        if (FAILED(HrAlloc((VOID **) &pszAddr, (m_cchLabelMax + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Initialize the exception buffer
        pszAddr[0] = '\0';
        
        // Allocate space to hold the exception list
        if (FAILED(HrAlloc((VOID **) &pralList, cExcpts * sizeof(*pralList))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Initialize the list of exceptions
        ZeroMemory(pralList, cExcpts * sizeof(*pralList));
        
        // Save each exception from the list
        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            // Get the item from the list
            pszAddr[0] = '\0';
            ListView_GetItemText(m_hwndList, ulIndex, 0, pszAddr, m_cchLabelMax + 1);
            
            // Verify it isn't empty
            if ('\0' == pszAddr[0])
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Set the flags
            pralList[ulIndex].dwFlags = RALF_MAIL;

            // Save the item
            pralList[ulIndex].pszAddr = PszDupA(pszAddr);
            if (NULL == pralList[ulIndex].pszAddr)
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }
    
    // Get the exceptions list from the rule
    if (FAILED(m_pIRule->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of exceptions from the address list
    if (FAILED(pIAddrList->SetList(0, pralList, cExcpts)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Set the proper return value
    fRet = TRUE;
    
exit:
    SafeRelease(pIAddrList);
    FreeRuleAddrList(pralList, cExcpts);
    SafeMemFree(pralList);
    SafeMemFree(pszAddr);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddExceptionToList
//
//  This adds the exception passed in to the list view
//
//  pszExcpt    - the actual exception
//  pulIndex    - the index where the item was added
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FAddExceptionToList(LPSTR pszExcpt, ULONG * pulIndex)
{
    BOOL        fRet = FALSE;
    ULONG       cExcpts = 0;
    LPSTR       pszLabel = NULL;
    ULONG       ulIndex = 0;
    LVITEM      lvitem = {0};
    ULONG       cchExcpt = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pszExcpt)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    if (NULL != pulIndex)
    {
        *pulIndex = 0;
    }
    
    cExcpts = ListView_GetItemCount(m_hwndList);

    // Figure out the maximum size of the buffer needed get the string
    if (0 != cExcpts)
    {
        if (FAILED(HrAlloc((void **) &pszLabel, m_cchLabelMax * sizeof(*pszLabel))))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // See if the exception is already in the list
        lvitem.pszText = pszLabel;
        lvitem.cchTextMax = m_cchLabelMax;

        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            if (0 != SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) ulIndex, (LPARAM) &lvitem))
            {
                if (0 == lstrcmpi(pszLabel, pszExcpt))
                {
                    break;
                }
            }
        }
    }
    
    // Insert it if we didn't find it
    if (ulIndex == cExcpts)
    {
        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.mask = LVIF_TEXT;
        lvitem.iItem = ulIndex;
        lvitem.pszText = pszExcpt;
        
        ulIndex = ListView_InsertItem(m_hwndList, &lvitem);
        if (-1 == ulIndex)
        {
            fRet = FALSE;
            goto exit;
        }

        // Figure out the new maximum
        cchExcpt = lstrlen(pszExcpt) + 1;
        if (cchExcpt > m_cchLabelMax)
        {
            m_cchLabelMax = cchExcpt;
        }
    }

    // Set the outgoing param
    if (NULL != pulIndex)
    {
        *pulIndex = ulIndex;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszLabel);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Exceptions List UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CExceptionsListUI::_EnableButtons(INT iSelected)
{
    int         cExcpts = 0;
    BOOL        fSelected = FALSE;

    Assert(NULL != m_hwndList);

    fSelected = (-1 != iSelected);
    
    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRemoveException, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcModifyException, fSelected);
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\ruleutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

// Forward definitions
interface IOEMessageList;
interface IMessageList;
class CProgress;
class CMRUList;

const DWORD RULE_DEFAULT_MAIL   = 0x00000000;
const DWORD RULE_DEFAULT_NEWS   = 0x00000001;

const DWORD CCH_INDEX_MAX   = 4;
const DWORD DWORD_INDEX_MIN = 0;
const DWORD DWORD_INDEX_MAX = 0x1000;

const DWORD MRDF_MAIL       = 0x00000000;
const DWORD MRDF_NEWS       = 0x00000001;
const DWORD MRDF_JUNK       = 0x00000002;
const DWORD MRDF_SENDERS    = 0x00000003;

void DoMessageRulesDialog(HWND hwnd, DWORD dwFlags);

// For creating a rule from a message
const DWORD CRFMF_MAIL = 0x00000000;
const DWORD CRFMF_NEWS = 0x00000001;

HRESULT HrCreateRuleFromMessage(HWND hwnd, DWORD dwFlags, MESSAGEINFO * pmsginfo, IMimeMessage * pMessage);

// Utility functions for the Block Sender object
const DWORD ABSF_MAIL = 0x00000001;
const DWORD ABSF_NEWS = 0x00000002;

HRESULT HrBlockSendersFromFolder(HWND hwnd, DWORD dwFlags, FOLDERID idFolder, LPSTR * ppszSender, ULONG cpszSender);

const DWORD VRDF_POP3       = 0x00000001;
const DWORD VRDF_NNTP       = 0x00000002;
const DWORD VRDF_IMAP       = 0x00000004;
const DWORD VRDF_HTTPMAIL   = 0x00000008;

HRESULT HrDoViewsManagerDialog(HWND hwnd, DWORD dwFlags, RULEID * pridRule, BOOL * pfApplyAll);

HRESULT HrCreateRulesManager(IUnknown * pIUnkOuter, IUnknown ** ppIUnknown);

// Functions to deal with the address criteria/actions
HRESULT RuleUtil_HrBuildEmailString(LPWSTR pwszText, ULONG cchText, LPWSTR * ppwszEmail, ULONG * pcchEmail);
HRESULT RuleUtil_HrParseEmailString(LPWSTR pwszEmail, ULONG cchEmail, LPWSTR * ppwszOut, ULONG * pcchOut);

// Functions to deal with the text criteria/actions
HRESULT RuleUtil_HrBuildTextString(LPTSTR pszIn, ULONG cchIn, LPTSTR * ppszText, ULONG * pcchText);
HRESULT RuleUtil_HrParseTextString(LPTSTR pszText, ULONG cchText, LPTSTR * ppszOut, ULONG * pcchOut);

// Utility functions to get values with allocations
HRESULT RuleUtil_HrGetDlgString(HWND hwndDlg, UINT uiCtlId, LPTSTR *ppszText, ULONG * pcchText);
HRESULT RuleUtil_HrGetRegValue(HKEY hkey, LPCSTR pszValueName, DWORD * pdwType, BYTE ** ppbData, ULONG * pcbData);

HRESULT RuleUtil_HrPickEMailNames(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs);
HRESULT RuleUtil_HrGetAddressesFromWAB(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs);

BOOL RuleUtil_FEnDisDialogItem(HWND hwndDlg, UINT idcItem, BOOL fEnable);
HRESULT RuleUtil_AppendRichEditText(HWND hwndRedit, ULONG ulStart, LPCWSTR pszText, CHARFORMAT *pchfmt);
HRESULT RuleUtil_HrShowLinkedString(HWND hwndEdit, BOOL fError, BOOL fReadOnly, 
                                    LPWSTR pszFmt, LPCWSTR pszData, ULONG ulStart, 
                                    ULONG * pulStartLink, ULONG * pulEndLink, ULONG * pulEnd);

// Utility functions for the COECriteria object
HRESULT RuleUtil_HrDupCriteriaItem(CRIT_ITEM * pItemIn, ULONG cItemIn, CRIT_ITEM ** ppItemOut);
HRESULT RuleUtil_HrFreeCriteriaItem(CRIT_ITEM * pItem, ULONG cItem);

// Utility functions for the COEActions object
HRESULT RuleUtil_HrDupActionsItem(ACT_ITEM * pItemIn, ULONG cItemIn, ACT_ITEM ** ppItemOut);
HRESULT RuleUtil_HrFreeActionsItem(ACT_ITEM * pItem, ULONG cItem);

HRESULT RuleUtil_HrAddBlockSender(RULE_TYPE type, LPCSTR pszAddr);
HRESULT RuleUtil_SetName(IOERule    *pIRule, int idRes);

// Utility functions for merge between old and new rules design

// Migration IBA_MOVE=1000 to ACT_MOVE
#define ACT_MOVETO              FLAG01
#define ACT_COPYTO              FLAG02
#define ACT_FORWARDTO           FLAG03
#define ACT_REPLYWITH           FLAG04
#define ACT_DONTDOWNLOAD        FLAG05
#define ACT_DELETEOFFSERVER     FLAG06
#define ACT_ACCOUNT             FLAG07
#define ACT_HIGHLIGHT           FLAG08
#define ACT_FLAG                FLAG09
#define ACT_READ                FLAG10
#define ACT_MARKDOWNLOAD        FLAG11
#define ACT_WATCH               FLAG12
#define ACT_IGNORE              FLAG13

HRESULT RuleUtil_HrMergeActions(ACT_ITEM * pActionsOrig, ULONG cActionsOrig,
                                ACT_ITEM * pActionsNew, ULONG cActionsNew,
                                ACT_ITEM ** ppActionsDest, ULONG * pcActionsDest);
                                
HRESULT RuleUtil_HrGetOldFormatString(HKEY hkeyRoot, LPCSTR pszValue, LPCSTR pszSep, LPSTR * ppszString, ULONG * pcchString);

// Functions to import/export messages
HRESULT RuleUtil_HrImportRules(HWND hwnd);
HRESULT RuleUtil_HrExportRules(HWND hwnd);

const int RULE_APPLY_PARTIALS = 0x00000001;
const int RULE_APPLY_SHOWUI   = 0x00000002;

HRESULT RuleUtil_HrApplyRulesToFolder(DWORD dwFlags, DWORD dwDeleteFlags,
                IOEExecRules * pExecRules, IMessageFolder * pFolder, HWND hwndUI, CProgress * pProgress);

HRESULT RuleUtil_HrFindAction(ACT_ITEM * pActions, ULONG cActions, ACT_TYPE typeAct, ACT_ITEM ** ppActFound);

HRESULT RuleUtil_HrMapFldId(DWORD dwFlags, BYTE * pbFldIdMap, FOLDERID fldidOld, FOLDERID * pfldidNew);

HRESULT RuleUtil_HrGetUserData(DWORD dwFlags, LPSTR * ppszFirstName, LPSTR * ppszLastName, LPSTR * ppszCompanyName);
HRESULT RuleUtil_HrApplyActions(HWND hwndUI, IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                                IMessageFolder * pFolder, IMimeMessage * pIMMsg, DWORD dwDeleteFlags,
                                ACT_ITEM * pActions, ULONG cActions, ULONG * pcInfiniteLoops, BOOL *pfDeleteOffServer);

HRESULT RuleUtil_HrCreateSendersRule(DWORD dwFlags, IOERule ** ppIRule);
HRESULT RuleUtil_HrLoadSender(LPCSTR pszRegPath, DWORD dwFlags, IOERule ** ppIRule);
HRESULT RuleUtil_HrMatchSender(LPCSTR pszSender, MESSAGEINFO * pMsgInfo,
                        IMimeMessage * pIMMsg, IMimePropertySet * pIMPropSet);
HRESULT RuleUtil_HrUpdateDefaultRules(RULE_TYPE typeRule);

HRESULT RuleUtil_HrGetFilterVersion(RULEID ridFilter, DWORD * pdwVersion);
HRESULT RuleUtil_HrValidateRuleFolderData(RULEFOLDERDATA * prfdData);

typedef struct tagQUERYINFO
{
    BOOL    fThreaded;
    LPSTR   pszQuery;
    ULONG   cchQuery;
} QUERYINFO, * PQUERYINFO;

HRESULT RuleUtil_HrBuildQuerysFromFilter(RULEID ridFilter, QUERYINFO * pqinfoFilter);

const int VMF_FINDER    = 0x00000001;

class CViewMenu
{
    private:
        struct VIEW_ITEM
        {
            RULEID              ridRule;
            struct VIEW_ITEM *  pNext;
        };
        
        enum
        {
            STATE_UNINIT   = 0x00000000,
            STATE_INIT     = 0x00000001,
            STATE_LOADED   = 0x00000002,
            STATE_DIRTY    = 0x00000004,
        };

        enum
        {
            CCH_FILTERTAG_MAX   = 11
        };
        
    private:
        ULONG       m_cRef;
        DWORD       m_dwFlags;
        DWORD       m_dwState;
        RULEID      m_ridCurrent;
        CMRUList *  m_pmruList;
        
    public:
        CViewMenu() : m_cRef(1), m_dwFlags(0), m_dwState(STATE_UNINIT),
                    m_ridCurrent(RULEID_INVALID), m_pmruList(NULL) {}
        ~CViewMenu();

        ULONG AddRef(VOID);
        ULONG Release(VOID);
        
        HRESULT HrInit(DWORD dwFlags);
        HRESULT HrReplaceMenu(DWORD dwFlags, HMENU hmenuView);
        HRESULT UpdateViewMenu(DWORD dwFlags, HMENU hmenuView, IMessageList * pMsgList);

        HRESULT QueryStatus(IMessageList * pMsgList, OLECMD * prgCmds);
        HRESULT Exec(HWND hwndUI, DWORD nCmdID, IMessageList * pMsgList, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
        HRESULT HrAddView(DWORD dwFlags, RULEID ridRule) {return E_NOTIMPL; }

    private:
        VOID _AddDefaultViews(HMENU hmenuView);
        HRESULT _HrInsertViewMenu(HMENU hmenuView, RULEID ridFilter, DWORD dwMenuID, DWORD dwMenuIDInsert);
        HRESULT _HrReloadMRUViewMenu(HMENU hmenuView);
        HRESULT _HrAddExtraViewMenu(HMENU hmenuView, IOEMessageList * pIMsgList);
        VOID _AddViewToMRU(RULEID ridFilter);
        BOOL _FViewInMRUList(RULEID ridFilter, DWORD * pdwID);
        BOOL _FValiadateMRUList(VOID);
};

HRESULT HrCreateViewMenu(DWORD dwFlags, CViewMenu ** ppViewMenu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\acctview.h ===
#ifndef _INC_ACCTVIEW_H
#define _INC_ACCTVIEW_H

#include "browser.h"
#include <columns.h>

class CEmptyList;
class CFolderUpdateCB;
class CGetNewGroups;

typedef struct tagFLDRNODE
{
    FOLDERID id;
    DWORD indent;
    DWORD dwDownload;
} FLDRNODE;

class CAccountView : 
        public IViewWindow,
        public IOleCommandTarget,
        public IDatabaseNotify
    {
    public:
        CAccountView();
        ~CAccountView();

        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IOleWindow
        HRESULT STDMETHODCALLTYPE GetWindow(HWND * lphwnd);                         
        HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
        // IAthenaView
        HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
        HRESULT STDMETHODCALLTYPE UIActivate(UINT uState);
        HRESULT STDMETHODCALLTYPE CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb, 
                                                   RECT *prcView, HWND *phWnd);
        HRESULT STDMETHODCALLTYPE DestroyViewWindow();
        HRESULT STDMETHODCALLTYPE SaveViewState();
        HRESULT STDMETHODCALLTYPE OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID);

        // IOleCommandTarget
        HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

        // IDatabaseNotify
        STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

        HRESULT HrInit(FOLDERID idFolder);

        static LRESULT CALLBACK AcctViewWndProc(HWND, UINT, WPARAM, LPARAM);

    private:
        /////////////////////////////////////////////////////////////////////////
        //
        // Message Handling
        //
        LRESULT _WndProc(HWND, UINT, WPARAM, LPARAM);
        BOOL    _OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
        void    _OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
        LRESULT _OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
        void    _OnSetFocus(HWND hwnd, HWND hwndOldFocus);
        void    _PostCreate(void);
        HRESULT _InsertChildren(FOLDERID idFolder, DWORD indent, DWORD *piNode);
        HRESULT _InsertChildrenSpecial(FOLDERID idFolder, DWORD indent, DWORD *piNode);
        BOOL    _OnWinIniChange(HWND hwnd);
        void    _OnContextMenu(HWND hwnd, HWND hwndFrom, int x, int y);
        HRESULT _MarkForDownload(DWORD nCmdID);
        HRESULT _ToggleDownload(int iItem);
        HRESULT _GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id);
        HRESULT _InsertFolder(LPFOLDERINFO pFolder);
        HRESULT _InsertFolderNews(LPFOLDERINFO pFolder);
        HRESULT _UpdateFolder(LPFOLDERINFO pFolder1, LPFOLDERINFO pFolder2);
        HRESULT _DeleteFolder(LPFOLDERINFO pFolder);
        HRESULT _Subscribe(BOOL fSubscribe);
        HRESULT _MarkAllRead(void);
        BOOL    _IsSelectedFolder(FLDRFLAGS dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial = FALSE);
        DWORD   _GetDownloadCmdStatus(int iSel, FLDRFLAGS dwFlags);
        LRESULT _OnPaint(HWND hwnd, HDC hdc);
        void    _HandleItemStateChange(void);
        void    _HandleSettingsButton(HWND hwnd);
        void    _OnCommand(WPARAM wParam, LPARAM lParam);
        HRESULT _HandleAccountRename(LPFOLDERINFO pFolder);
        void    _HandleDelete(BOOL fNoTrash);

        /////////////////////////////////////////////////////////////////////////
        //
        // Shell Interface Handling
        //
        BOOL    _OnActivate(UINT uActivation);
        BOOL    _OnDeactivate();

        int     _GetFolderIndex(FOLDERID id);
        int     _GetSubFolderCount(int index);

        inline FOLDERID _IdFromIndex(int index)     { IxpAssert((DWORD)index < m_cnode); return((index >= 0 && (DWORD)index < m_cnode) ? m_rgnode[index].id : FOLDERID_INVALID); }
        inline FLDRNODE *_NodeFromIndex(int index)  { IxpAssert((DWORD)index < m_cnode); return((index >= 0 && (DWORD)index < m_cnode) ? &m_rgnode[index] : NULL); }

    private:
        UINT                m_cRef;
        FOLDERID            m_idFolder;
        FOLDERTYPE          m_ftType;
        DWORD               m_dwDownloadDef;
        IAthenaBrowser     *m_pShellBrowser;
        BOOL                m_fFirstActive;
        CColumns           *m_pColumns;
        UINT                m_uActivation;
        HWND                m_hwndOwner;                  // Owner window
        HWND                m_hwnd;                       // Our window
        BOOL                m_fRegistered;

        HWND                m_hwndList;
        HWND                m_hwndHeader;
        HWND                m_rgBtns[3];
        int                 m_cBtns;
        RECT                m_rcHeader;
        RECT                m_rcMajor;
        LPSTR               m_pszMajor;
        RECT                m_rcMinor;
        LPSTR               m_pszMinor;
        RECT                m_rcButtons;

        DWORD               m_cnode;
        DWORD               m_cnodeBuf;
        FLDRNODE           *m_rgnode;

        HIMAGELIST          m_himlFolders;
        CEmptyList         *m_pEmptyList;

        CGetNewGroups      *m_pGroups;
        DWORD               m_clrWatched;
    };

#endif // _INC_ACCTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\rules\viewsui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  ViewsUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "viewsui.h"
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "reutil.h"
#include "shlwapip.h" 
#include <rulesdlg.h>
#include <imagelst.h>
#include <demand.h>

INT_PTR CALLBACK FSelectApplyViewDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Global data
const static HELPMAP g_rgCtxMapViewsMgr[] = {
                        {idbNewView,            idhNewView},
                        {idbModifyView,         idhModifyView},
                        {idbCopyView,           idhCopyView},
                        {idbDeleteView,         idhRemoveView},
                        {idbDefaultView,        idhApplyView},
                        {idredtViewDescription, idhViewDescription},
                        {0, 0}};
                       
COEViewsMgrUI::COEViewsMgrUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                                m_hwndDlg(NULL), m_hwndList(NULL), m_hwndDescript(NULL),
                                m_pDescriptUI(NULL), m_pridRule(NULL), m_pIRuleDownloaded(NULL),
                                m_fApplyAll(FALSE)
{
}

COEViewsMgrUI::~COEViewsMgrUI()
{
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
    SafeRelease(m_pIRuleDownloaded);
}

HRESULT COEViewsMgrUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULEID * pridRule)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pridRule = pridRule;
    
    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEViewsMgrUI::HrShow(BOOL * pfApplyAll)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (NULL == pfApplyAll)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    *pfApplyAll = FALSE;
    
    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddViewsManager),
                                        m_hwndOwner, COEViewsMgrUI::FOEViewMgrDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    *pfApplyAll = m_fApplyAll;
    
    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEViewsMgrUI::FOEViewMgrDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEViewsMgrUI *         pViewsUI = NULL;
    HWND                    hwndRE = 0;

    pViewsUI = (COEViewsMgrUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pViewsUI = (COEViewsMgrUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pViewsUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtViewDescription);

            if (!hwndRE || (FALSE == pViewsUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pViewsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pViewsUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pViewsUI->FOnDestroy();
            break;   
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapViewsMgr);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the view manager UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvViewsList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtViewDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case idbNewView:
            _NewView();
            fRet = TRUE;
            break;

        case idbModifyView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the view editor for that item
                _EditView(iSelected);
                fRet = TRUE;
            }
            break;

        case idbDeleteView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveView(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbDefaultView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _DefaultView(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbCopyView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _CopyView(iSelected);
                fRet = TRUE;
            }
            break;

        case idbRenameView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Set the focus in the list view
                SetFocus(m_hwndList);
                
                // Edit the view label in the list
                fRet = (NULL != ListView_EditLabel(m_hwndList, iSelected));
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh = {0};

    // We only handle notifications for the list control
    // or the desscription field
    if ((idlvViewsList != pnmhdr->idFrom) && (idredtViewDescription != pnmhdr->idFrom))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 == pnmlv->iItem)
            {
                // We clicked outside the list

                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            else
            {
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMSTATEICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state                        
                        _EnableView(iSelected);
                    }
                }
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditView(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list
                
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGING:
            // If an item's state changed to unselected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 != (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 == (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Save off the rule changes
                _FSaveView(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The space key changes the enable state of a rule
            if (VK_SPACE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Change the enable state of the rule
                    _EnableView(iSelected);
                }
            }
            // The delete key removes the rule from the list view
            else if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveView(iSelected);
                }
            }
            break;
            
        case LVN_BEGINLABELEDIT:
        case LVN_ENDLABELEDIT:
            fRet = _FOnLabelEdit((LVN_BEGINLABELEDIT == pnmlv->hdr.code), (NMLVDISPINFO *) pnmhdr);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnDestroy(VOID)
{
    BOOL        fRet = FALSE;
    UINT        cRules = 0;
    UINT        uiIndex = 0;
    LVITEM      lvitem = {0};
    RULEINFO *  pIRuleInfo = NULL;

    Assert(m_hwndList);
    
    // Get the number of views in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    // Initialize to get the rule interface from the list view
    lvitem.mask = LVIF_PARAM;

    // Release each of the views from the list view
    for (uiIndex = 0; uiIndex < cRules; uiIndex++)
    {
        lvitem.iItem = uiIndex;
        
        // Get the rule interface
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRuleInfo = (RULEINFO *) (lvitem.lParam);

            if (NULL != pIRuleInfo)
            {
                // Release the view
                if (NULL != pIRuleInfo->pIRule)
                {
                    pIRuleInfo->pIRule->Release();
                }
                delete pIRuleInfo; // MemFree(pIRuleInfo);
            }
        }
    }

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FOnOK(VOID)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    LONG        cViews = 0;
    INT         iSelected = 0;
    RULEINFO *  pinfoRule = NULL;
    ULONG       cpinfoRule = 0;
    LVITEM      lvitem = {0};
    IOERule *   pIRuleDefault = NULL;
    ULONG       ulIndex = 0;
    ULONG       cViewsTotal = 0;

    Assert(NULL != m_hwndList);
    
    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_OK != m_pDescriptUI->HrIsDirty()))
    {
        fRet = TRUE;
        goto exit;
    }

    // Let's make sure the selected rule is saved...
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
    if (-1 != iSelected)
    {
        _FSaveView(iSelected);
    }

    // Get the number of rules in the list view
    cViews = ListView_GetItemCount(m_hwndList);

    cViewsTotal = cViews;

    if (NULL != m_pIRuleDownloaded)
    {
        cViewsTotal++;
    }

    if (0 != cViewsTotal)
    {
        // Allocate space to hold the rules        
        hr = HrAlloc( (void **) &pinfoRule, cViewsTotal * sizeof(*pinfoRule));
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }

        ZeroMemory(pinfoRule, cViewsTotal * sizeof(*pinfoRule));

        if (0 != cViews)
        {
            lvitem.mask = LVIF_PARAM;
            
            cpinfoRule = 0;
            for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
            {
                // Grab the rule from the list view
                if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
                {
                    pinfoRule[cpinfoRule] = *((RULEINFO *) (lvitem.lParam));
                    cpinfoRule++;
                }   
            }
        }

        if (NULL != m_pIRuleDownloaded)
        {
            pinfoRule[cpinfoRule].ridRule = RULEID_VIEW_DOWNLOADED;
            pinfoRule[cpinfoRule].pIRule = m_pIRuleDownloaded;
            cpinfoRule++;
        }
    }
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_CLEAR, RULE_TYPE_FILTER, pinfoRule, cpinfoRule);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the default item
    if (0 != cViews)
    {
        // Get the current default item
        if (FALSE != _FGetDefaultItem(&pIRuleDefault, NULL))
        {
            // Search for it in the list of rules
            for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
            {
                if (pIRuleDefault == pinfoRule[ulIndex].pIRule)
                {
                    *m_pridRule = pinfoRule[ulIndex].ridRule;
                    break;
                }
            }
        }
    }
    
    // Clear the dirty state
    m_dwState &= ~STATE_DIRTY;
    
    fRet = TRUE;
    
exit:
    delete pinfoRule; //SafeMemFree(pinfoRule);
    return fRet;
}

BOOL COEViewsMgrUI::_FOnCancel(VOID)
{
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the view manager UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc = {0};
    RECT        rc = {0};
    HIMAGELIST  himl = NULL;
    TCHAR       szRes[CCHMAX_STRINGRES + 5];

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    lvc.mask = LVCF_WIDTH | LVCF_TEXT;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Load the string for the column
    lvc.pszText = szRes;
    lvc.cchTextMax = ARRAYSIZE(szRes);
    if (0  == LoadString(g_hLocRes, idsNameCol, szRes, ARRAYSIZE(szRes)))
    {
        szRes[0] = '\0';
    }
    
    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current views
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULEINFO *      pinfoRules = NULL;
    ULONG           cpinfoRules = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    BOOL            fSelect = FALSE;
    BOOL            fFoundDefault = FALSE;

    Assert(NULL != m_hwndList);

    // Get the Rules enumerator
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRules(GETF_EDIT, RULE_TYPE_FILTER, &pinfoRules, &cpinfoRules);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Add each filter to the list
    dwListIndex = 0;

    for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
    {
        // Make a copy of the view
        hr = pinfoRules[ulIndex].pIRule->Clone(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Check to see if this is a default view we aren't supposed to show
        if ((0 != (m_dwFlags & VRDF_POP3)) && (RULEID_VIEW_DOWNLOADED == pinfoRules[ulIndex].ridRule))
        {
            m_pIRuleDownloaded = pIRule;
            pIRule = NULL;
        }
        else
        {
            // Is this the default view?
            if ((NULL != m_pridRule) && (*m_pridRule == pinfoRules[ulIndex].ridRule))
            {
                fSelect = TRUE;
                fFoundDefault = TRUE;
            }
            else
            {
                fSelect = FALSE;
            }
            
            // Add view to the list
            if (FALSE != _FAddViewToList(dwListIndex, pinfoRules[ulIndex].ridRule, pIRule, fSelect))
            {
                dwListIndex++;
            }

            SafeRelease(pIRule);
        }
    }
    
    // Select the first item in the list
    if (0 != dwListIndex)
    {
        if (FALSE == fFoundDefault)
        {
            ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }
    }
    else
    {
        // Enable the dialog buttons.
        _EnableButtons(-1);
    }
    
    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    if (NULL != pinfoRules)
    {
        for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
        {
            pinfoRules[ulIndex].pIRule->Release();
        }
        SafeMemFree(pinfoRules); //delete pinfoRules; 
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the view passed in to the list view
//
//  dwIndex - the index on where to add the view to into the list
//  pIRule  - the actual view
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FAddViewToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule, BOOL fSelect)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    INT         iItem = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Allocate space for the rule
    pinfoRule = new RULEINFO;
    if (NULL == pinfoRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set up the value
    pinfoRule->ridRule = ridRule;
    pinfoRule->pIRule = pIRule;
    pinfoRule->pIRule->AddRef();
    
    // Add in the image and rule interface
    lvitem.mask = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.iItem = dwIndex;
    if ((NULL != m_pridRule) && (*m_pridRule == pinfoRule->ridRule))
    {
        lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1);
    }
    lvitem.pszText = propvar.pszVal;
    lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
    lvitem.lParam = (LONG_PTR) pinfoRule;

    iItem = ListView_InsertItem(m_hwndList, &lvitem);
    if (-1 == iItem)
    {
        fRet = FALSE;
        goto exit;
    }

    if (FALSE != fSelect)
    {
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Make sure the new item is visible
        ListView_EnsureVisible(m_hwndList, iItem, FALSE);
    }
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the view manager UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEditable = FALSE;
    LVITEM      lvi = {0};
    RULEID      ridFilter = RULEID_INVALID;

    Assert(NULL != m_hwndList);

    // Load the description field
    _LoadView(iSelected);
    
    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            ridFilter = ((RULEINFO *) (lvi.lParam))->ridRule;
        }        
    }

    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    fSelected = (-1 != iSelected);
    fEditable = !FIsFilterReadOnly(ridFilter);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDefaultView, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDeleteView, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbCopyView, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbRenameView, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifyView, fSelected && fEditable);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableView
//
//  This switches the current default state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_EnableView(int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvitem = {0};
    int         iRet = 0;
    INT         cViews = 0;
    
    Assert(-1 != iSelected);
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddApplyView),
            m_hwndDlg, FSelectApplyViewDlgProc, (LPARAM) &m_fApplyAll);

    if (IDOK != iRet)
    {
        goto exit;
    }

    // Get the current count of item
    cViews = ListView_GetItemCount(m_hwndList);

    // Set up the list view item
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Walk each item in the list
    for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
    {
        ListView_GetItem(m_hwndList, &lvitem);
        
        // Set the selected item to the default
        if (iSelected == lvitem.iItem)
        {
            if (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) != lvitem.state)
            {
                // Save off the default item
                if (NULL != m_pridRule)
                {
                    *m_pridRule = ((RULEINFO *) (lvitem.lParam))->ridRule;
                }

                // Set the state
                ListView_SetItemState(m_hwndList, lvitem.iItem,
                                    INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1),
                                    LVIS_STATEIMAGEMASK);
            }
        }
        else
        {
            if (0 != lvitem.state)
            {
                // Clear out the state
                ListView_SetItemState(m_hwndList, lvitem.iItem, 0, LVIS_STATEIMAGEMASK);

                // Need to update the item
                ListView_Update(m_hwndList, lvitem.iItem);
            }
        }
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;

exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadView
//
//  This loads the selected view into the description field.
//  If there isn't a selected view, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_LoadView(INT iSelected)
{
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;
    RULEID      ridFilter = RULEID_INVALID;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;
            ridFilter = ((RULEINFO *) (lvi.lParam))->ridRule;
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(RULE_TYPE_FILTER, pIRule);

    // Set the proper read only state of the description field
    m_pDescriptUI->HrSetReadOnly(FIsFilterReadOnly(ridFilter));
    
    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveView
//
//  This checks to see if the view has been changed in the description
//  area and if it has, then it warns the user and changes the text
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    TRUE, if the rule either didn't change or did change without problems
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FSaveView(int iSelected)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    LVITEM          lvi = {0};
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;

    // If the rule didn't change, then we're done
    hr = m_pDescriptUI->HrIsDirty();
    if (S_OK != hr)
    {
        fRet = (S_FALSE == hr);
        goto exit;
    }
    
    // Grab the list view item
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Get the criteria from the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the criteria from the rule
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions for the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewView
//
//  This brings up a fresh rules editor
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_NewView(VOID)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    LVFINDINFO      lvfinfo = {0};
    PROPVARIANT     propvar = {0};
    ACT_ITEM        aitem;
    CEditRuleUI *   pEditRuleUI = NULL;
    LONG            cRules = 0;
       
    // Create a new rule object
    if (FAILED(HrCreateRule(&pIRule)))
    {
        goto exit;
    }

    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, idsViewDefaultName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    ulIndex = 1;
    wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);

    lvfinfo.flags = LVFI_STRING;
    lvfinfo.psz = szName;
    while (-1 != ListView_FindItem(m_hwndList, -1, &lvfinfo))
    {
        ulIndex++;
        wnsprintf(szName, ARRAYSIZE(szName), szRes, ulIndex);
    }

    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

#ifdef NEVER
    // Set the default action
    // Set the normal action
    ZeroMemory(&aitem, sizeof(aitem));
    aitem.type = ACT_TYPE_SHOW;
    aitem.dwFlags = ACT_FLAG_DEFAULT;
    aitem.propvar.vt = VT_UI4;
    aitem.propvar.ulVal = ACT_DATA_NULL;
    
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) &aitem;

    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
#endif  // NEVER

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, ERF_NEWRULE | ERF_ADDDEFAULTACTION, RULE_TYPE_FILTER, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        // Add the rule to the manager UI
        cRules = ListView_GetItemCount(m_hwndList);
        
        _FAddViewToList(cRules, RULEID_INVALID, pIRule, TRUE);
    }
    
exit:
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditView
//
//  This brings up the edit UI for the selected view from the view list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_EditView(int iSelected)
{
    HRESULT         hr = S_OK;
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    CEditRuleUI *   pEditRuleUI = NULL;
    PROPVARIANT     propvar = {0};

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveView(iSelected);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }   

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // If the rule is read-only then we're done
    if (FALSE != FIsFilterReadOnly(((RULEINFO *) (lvitem.lParam))->ridRule))
    {
        goto exit;
    }
    
    // Create the rules editor
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, 0, RULE_TYPE_FILTER, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the rule changed, make sure we reload the description field
    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;

        // Grab the rule name
        PropVariantClear(&propvar);
        hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        if ((VT_LPSTR == propvar.vt) && (NULL != propvar.pszVal) && ('\0' != propvar.pszVal[0]))
        {
            ZeroMemory(&lvitem, sizeof(lvitem));
            lvitem.iItem = iSelected;
            lvitem.mask = LVIF_TEXT;
            lvitem.pszText = propvar.pszVal;
            lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
            
            if (-1 == ListView_SetItem(m_hwndList, &lvitem))
            {
                goto exit;
            }
        }

        _EnableButtons(iSelected);
    }
    
exit:
    PropVariantClear(&propvar);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveView
//
//  This removes the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_RemoveView(int iSelected)
{
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    BOOL        fDefault = FALSE;
    PROPVARIANT propvar = {0};
    int         cViews = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    UINT        cchRes = 0;
    LPTSTR      pszMessage = NULL;

    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pinfoRule = (RULEINFO *) (lvitem.lParam);
    fDefault = (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) == lvitem.state);
    if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
    {
        goto exit;
    }
    
    // If the rule is read-only then we're done
    if (FALSE != FIsFilterReadOnly(pinfoRule->ridRule))
    {
        goto exit;
    }
    
    // Warn the user to make sure they know we are going to remove the rule
    if (FAILED(pinfoRule->pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(propvar.pszVal) + 1);
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchSize)))
    {
        goto exit;
    }

    // Build up the string and display it
    wnsprintf(pszMessage, cchSize, szRes, propvar.pszVal);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cViews = ListView_GetItemCount(m_hwndList);
    if (cViews > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cViews)
        {
            // Move the selection to the new last item in the list
            iSelected = cViews - 1;
        }

        // Do we need to reset the default
        if (FALSE != fDefault)
        {
            // Set the state
            ListView_SetItemState(m_hwndList, iSelected, INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1),
                                LVIS_STATEIMAGEMASK);
        }
        
        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }

    // Release the rule
    SafeRelease(pinfoRule->pIRule);

    // Free up the memory
    delete pinfoRule; //SafeMemFree(pinfoRule);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _CopyView
//
//  This copies the selected view from the view manager UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_CopyView(INT iSelected)
{
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    HRESULT         hr = S_OK;
    IOERule *       pIRuleNew = NULL;
    PROPVARIANT     propvar = {0};
    UINT            cRules = 0;
    TCHAR           szRes[CCHMAX_STRINGRES];
    UINT            cchRes = 0;
    LPTSTR          pszName = NULL;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveView(iSelected);
    
    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create a new rule object
    hr = pIRule->Clone(&pIRuleNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Let's set the name

    // Get the name from the source rule
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    DWORD cchSize = (cchRes + lstrlen(propvar.pszVal) + 1);
    if (FAILED(HrAlloc((void ** ) &pszName, cchSize)))
    {
        goto exit;
    }

    // Build up the string and set it
    wnsprintf(pszName, cchSize, szRes, propvar.pszVal);

    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    pszName = NULL;
    
    // Set the name into the new rule
    Assert(VT_LPSTR == propvar.vt);
    Assert(NULL != propvar.pszVal);
    hr = pIRuleNew->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clear the version of the new rule
    PropVariantClear(&propvar);
    propvar.vt = VT_UI4;
    propvar.ulVal = 0;
    hr = pIRuleNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Add the rule to the rules list right below
    // the original rule
    iSelected++;
    _FAddViewToList(iSelected, RULEID_INVALID, pIRuleNew, TRUE);

    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszName);
    SafeRelease(pIRuleNew);
    PropVariantClear(&propvar);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _DefaultView
//
//  This sets the selected view as the default view
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_DefaultView(int iSelected)
{
    Assert(NULL != m_hwndList);

    _EnableView(iSelected);
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _DefaultView
//
//  This sets the selected view as the default view
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FGetDefaultItem(IOERule ** ppIRuleDefault, RULEID * pridDefault)
{
    BOOL        fRet = FALSE;
    LVITEM      lvitem = {0};
    INT         cViews = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the current count of item
    cViews = ListView_GetItemCount(m_hwndList);

    // Set up the list view item
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Walk each item in the list
    for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
    {
        ListView_GetItem(m_hwndList, &lvitem);
        
        // Set the selected item to the default
        if (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) == lvitem.state)
        {
            // We found it
            fRet = TRUE;
            
            // Save off the default item
            if (NULL != pridDefault)
            {
                *pridDefault = ((RULEINFO *) (lvitem.lParam))->ridRule;
            }
            if (NULL != ppIRuleDefault)
            {
                *ppIRuleDefault = ((RULEINFO *) (lvitem.lParam))->pIRule;
            }
            break;
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnLabelEdit
//
//  This brings up the edit UI for the selected view from the view list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi)
{
    BOOL            fRet = FALSE;
    HWND            hwndEdit = NULL;
    ULONG           cchName = 0;
    IOERule *       pIRule = NULL;
    LVITEM          lvitem = {0};
    PROPVARIANT     propvar = {0};

    Assert(NULL != m_hwndList);

    if (NULL == pdi)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(m_hwndList == pdi->hdr.hwndFrom);
    
    if (FALSE != fBegin)
    {
        // Get the rule for the item
        lvitem.iItem = pdi->item.iItem;
        lvitem.mask = LVIF_PARAM;
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
            fRet = TRUE;
            goto exit;
        }

        // Should we allow the use to end the item?
        if (FALSE != FIsFilterReadOnly(((RULEINFO *) (lvitem.lParam))->ridRule))
        {
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
            fRet = TRUE;
            goto exit;
        }
            
        // Get the edit control
        hwndEdit = ListView_GetEditControl(m_hwndList);

        if (NULL == hwndEdit)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Limit the amount of text for the name
        SendMessage(hwndEdit, EM_LIMITTEXT, c_cchNameMax - 1, 0);

        // Tell the dialog it's aok to proceed
        SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
    }
    else
    {            
        // Did something change?
        if ((-1 != pdi->item.iItem) && (NULL != pdi->item.pszText))
        {
            cchName = lstrlen(pdi->item.pszText);
            
            // Check to see if the rule name is valid
            if ((0 == cchName) || (0 == UlStripWhitespace(pdi->item.pszText, TRUE, TRUE, &cchName)))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsRulesErrorNoName), NULL,
                                MB_OK | MB_ICONINFORMATION);
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Get the rule for the item
            lvitem.iItem = pdi->item.iItem;
            lvitem.mask = LVIF_PARAM;
            if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }

            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL == pIRule)
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Set the new name into the rule
            
            propvar.vt = VT_LPSTR;
            propvar.pszVal = pdi->item.pszText;
            
            SideAssert(S_OK == pIRule->SetProp(RULE_PROP_NAME, 0, &propvar));

            // Mark the rule list as dirty
            m_dwState |= STATE_DIRTY;
        
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL FIsFilterReadOnly(RULEID ridFilter)
{
    BOOL fRet = FALSE;

    // Check the incoming params
    if (RULEID_INVALID == ridFilter)
    {
        goto exit;
    }

    if ((RULEID_VIEW_ALL == ridFilter) ||
            (RULEID_VIEW_UNREAD == ridFilter) ||
            (RULEID_VIEW_DOWNLOADED == ridFilter) ||
            (RULEID_VIEW_IGNORED == ridFilter))
    {
        fRet = TRUE;
    }            
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FSelectApplyViewDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FSelectApplyViewDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    BOOL *          pfApplyAll = NULL;
    UINT            uiId = 0;

    pfApplyAll = (BOOL *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pfApplyAll = (BOOL *) lParam;
            if (NULL == pfApplyAll)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pfApplyAll);

            // Set the default item
            if (FALSE != *pfApplyAll)
            {
                uiId = idcViewAll;
            }
            else
            {
                uiId = idcViewCurrent;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    *pfApplyAll = (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcViewAll));
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\acctview.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <store.h>
#include <storecb.h>
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include <inetcfg.h>
#include <fonts.h>
#include <columns.h>
#include <imagelst.h>
#include <instance.h>
#include <spoolui.h>
#include <options.h>
#include <acctutil.h>
#include "shlwapip.h"
#include <menuutil.h>
#include "storutil.h"
#include <outbar.h>
#include <subscr.h>
#include "newsutil.h"
#include "acctview.h"
#include <newfldr.h>
#include <mailutil.h>
#include "menures.h"
#include "demand.h"

ASSERTDATA

#define SUBSCRIBE_BORDER    7
#define CALLOCIDBUF         256
#define IDC_SUBSCRIBE_LIST  (ID_FIRST - 4)
#define FOLDER_SYNCMASK     (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)

static const char c_szAcctViewWndClass[] = "Outlook Express AcctView";

int __cdecl GroupCompare(const void *lParam1, const void *lParam2) ;
void DrawSettingsButton(HWND hwnd, LPDRAWITEMSTRUCT pdi);
#define C_RGBCOLORS 16
extern const DWORD rgrgbColors16[C_RGBCOLORS];

typedef struct tagACCTVIEWBTN
{
    int idsText;
    int cmd;
} ACCTVIEWBTN;

static const ACCTVIEWBTN c_rgMailBtns[] =
{
    { idsDeliverMailTT, ID_SEND_RECEIVE }
};

static const ACCTVIEWBTN c_rgImapBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsIMAPFoldersBtn, ID_IMAP_FOLDERS },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

static const ACCTVIEWBTN c_rgNewsBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsNewsgroupsBtn, ID_NEWSGROUPS },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

static const ACCTVIEWBTN c_rgHttpBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

CAccountView::CAccountView()
{
    m_cRef = 1;
    // m_ftType
    m_pShellBrowser = NULL;
    m_fFirstActive = FALSE;
    m_pColumns = NULL;
    m_uActivation = SVUIA_DEACTIVATE;
    m_hwndOwner = NULL;
    m_hwnd = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_fRegistered = FALSE;

    m_hwndList = NULL;
    m_pszMajor = NULL;
    m_pszMinor = NULL;
    m_cBtns = 0;

    m_cnode = 0;
    m_cnodeBuf = 0;
    m_rgnode = NULL;

    m_himlFolders = NULL;
    m_pEmptyList = NULL;

    m_pGroups = NULL;
    m_clrWatched = 0;
}

CAccountView::~CAccountView()
{
    if (m_pGroups != NULL)
    {
        m_pGroups->Close();
        m_pGroups->Release();
    }

    if (m_rgnode != NULL)
        MemFree(m_rgnode);

    SafeRelease(m_pShellBrowser);
    SafeRelease(m_pColumns);

    if (m_pEmptyList != NULL)
        delete m_pEmptyList;

    if (m_himlFolders != NULL)
        ImageList_Destroy(m_himlFolders);

    if (m_pszMajor != NULL)
        MemFree(m_pszMajor);
    if (m_pszMinor != NULL)
        MemFree(m_pszMinor);
}

HRESULT CAccountView::HrInit(FOLDERID idFolder)
{
    WNDCLASS wc;

    if (!GetClassInfo(g_hInst, c_szAcctViewWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CAccountView::AcctViewWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szAcctViewWndClass;
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_idFolder = idFolder;
    m_ftType = GetFolderType(idFolder);

    m_dwDownloadDef = (m_ftType == FOLDER_NEWS) ? FOLDER_DOWNLOADNEW : FOLDER_DOWNLOADALL;

    // Set the image lists for the listview
    Assert(m_himlFolders == NULL);
    m_himlFolders = InitImageList(16, 16, MAKEINTRESOURCE(idbFolders), cFolderIcon, RGB(255, 0, 255));
    Assert(m_himlFolders);

    m_pEmptyList = new CEmptyList;
    if (m_pEmptyList == NULL)
        return(E_OUTOFMEMORY);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IViewWindow *)this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (void*) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CAccountView::AddRef()
{
    DOUT(TEXT("CAccountView::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CAccountView::Release()
{
    DOUT(TEXT("CAccountView::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::GetWindow(HWND * lphwnd)
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CAccountView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaView
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::TranslateAccelerator(LPMSG lpmsg)
{
    return(S_FALSE);
}

HRESULT STDMETHODCALLTYPE CAccountView::UIActivate(UINT uActivation)
{
    if (uActivation != SVUIA_DEACTIVATE)
        _OnActivate(uActivation);
    else
        _OnDeactivate();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccountView::CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb,
                                                           RECT *prcView, HWND *phWnd)
{
    FOLDERINFO info;

    m_pShellBrowser = psb;
    Assert(m_pShellBrowser);
    m_pShellBrowser->AddRef();

    m_pShellBrowser->GetWindow(&m_hwndOwner);
    Assert(IsWindow(m_hwndOwner));

    m_pColumns = new CColumns;
    if (m_pColumns == NULL)
        return(E_OUTOFMEMORY);

    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT|WS_EX_CLIENTEDGE,
        c_szAcctViewWndClass,
        NULL,
        WS_VISIBLE|WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
        prcView->left,
        prcView->top,
        prcView->right - prcView->left,
        prcView->bottom - prcView->top,
        m_hwndOwner,
        NULL,
        g_hInst,
        (LPVOID)this);

    if (!m_hwnd)
        return E_FAIL;

    *phWnd = m_hwnd;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CAccountView::DestroyViewWindow()
{
    HRESULT hr;
    HWND hwndDest;

    if (m_fRegistered)
        g_pStore->UnregisterNotify((IDatabaseNotify *)this);

    if (m_hwnd)
    {
        hwndDest = m_hwnd;
        m_hwnd = NULL;

        DestroyWindow(hwndDest);
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccountView::SaveViewState()
{
    Assert(m_pColumns != NULL);
    m_pColumns->Save(NULL, NULL);

    OptionUnadvise(m_hwnd);
    return S_OK;
}

//
//  FUNCTION:   CAccountView::OnInitMenuPopup
//
//  PURPOSE:    Called when the user is about to display a menu.  We use this
//              to update the enabled or disabled status of many of the
//              commands on each menu.
//
//  PARAMETERS:
//      hmenu       - Handle of the main menu.
//      hmenuPopup  - Handle of the popup menu being displayed.
//      uID         - Specifies the id of the menu item that
//                    invoked the popup.
//
//  RETURN VALUE:
//      Returns S_OK if we process the message.
//
//
HRESULT CAccountView::OnPopupMenu(HMENU hmenu, HMENU hmenuPopup, UINT uID)
{
    return(S_OK);
}

DWORD CAccountView::_GetDownloadCmdStatus(int iSel, FLDRFLAGS dwFlags)
{
    DWORD cmdf;

    cmdf = OLECMDF_SUPPORTED;
    if (m_ftType != FOLDER_LOCAL)
    {
        if (iSel != -1)
        {
            if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
            {
                cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                if (_IsSelectedFolder(dwFlags, TRUE, TRUE))
                    cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
            }
        }
    }

    return(cmdf);
}

HRESULT CAccountView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG i;
    BOOL fTree, fSpecial;
    FOLDERID idFolder;
    FOLDERINFO info;
    HRESULT hr;
    int iSel, cSel, cItems, iSelT;
    OLECMD *pcmd;

    Assert(prgCmds != NULL);

    cSel = ListView_GetSelectedCount(m_hwndList);
    cItems = ListView_GetItemCount(m_hwndList);
    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
    if (iSel != -1 && (DWORD)iSel >= m_cnode)
        iSel = -1;
    fTree = !(S_OK == m_pShellBrowser->HasFocus(ITB_OEVIEW));

    for (i = 0, pcmd = prgCmds; i < cCmds; i++, pcmd++)
    {
        if (pcmd->cmdf == 0)
        {
            switch (pcmd->cmdID)
            {
                case ID_POPUP_SYNCHRONIZE:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_ftType != FOLDER_LOCAL && iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADHEADERS);
                    break;

                case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADNEW);
                    break;

                case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADALL);
                    break;

                case ID_UNMARK_RETRIEVE_FLD:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
                        {
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                            if (_IsSelectedFolder(FOLDER_SYNCMASK, FALSE, TRUE))
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        }
                    }
                    break;

                case ID_SUBSCRIBE:
                case ID_UNSUBSCRIBE:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if ((m_ftType == FOLDER_IMAP || m_ftType == FOLDER_NEWS) && iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, pcmd->cmdID == ID_UNSUBSCRIBE, FALSE, TRUE))
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_SELECT_ALL:
                case ID_COLUMNS:
                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_CATCH_UP:
                    if (m_ftType == FOLDER_NEWS && iSel != -1)
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_OPEN_FOLDER:
                case ID_OPEN:
                case ID_GO_SELECTED:
                case ID_COMPACT:
                case ID_MARK_ALL_READ:
                    if (iSel == -1)
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                // TODO: support ID_PURGE_DELETED???

                // commands below are handled by the treeview if it has the focus
                // otherwise we'll handle them based on what is selected in us

                case ID_PROPERTIES:
                case ID_ADD_SHORTCUT:
                    if (!fTree)
                    {
                        if (iSel != -1)
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            pcmd->cmdf = OLECMDF_SUPPORTED;
                    }
                    break;

                case ID_NEW_FOLDER:
                case ID_NEW_FOLDER2:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (m_ftType != FOLDER_NEWS && iSel != -1)
                        {
                            hr = g_pStore->GetFolderInfo(_IdFromIndex(iSel), &info);
                            if (SUCCEEDED(hr))
                            {
                                if (info.tySpecial != FOLDER_DELETED)
                                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                g_pStore->FreeRecord(&info);
                            }
                        }
                    }
                    break;

                case ID_DELETE:
                case ID_DELETE_FOLDER:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (iSel != -1 && m_ftType != FOLDER_NEWS)
                        {
                            iSelT = iSel;
                            while (iSelT != -1)
                            {
                                hr = g_pStore->GetFolderInfo(_IdFromIndex(iSelT), &info);
                                if (SUCCEEDED(hr))
                                {
                                    fSpecial = (info.tySpecial != FOLDER_NOTSPECIAL);

                                    g_pStore->FreeRecord(&info);

                                    if (!fSpecial)
                                    {
                                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                        break;
                                    }
                                }

                                iSelT = ListView_GetNextItem(m_hwndList, iSelT, LVNI_SELECTED);
                            }
                        }
                    }
                    break;

                case ID_MOVE:
                case ID_RENAME:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (m_ftType != FOLDER_NEWS && iSel != -1)
                        {
                            hr = g_pStore->GetFolderInfo(_IdFromIndex(iSel), &info);
                            if (SUCCEEDED(hr))
                            {
                                if (info.tySpecial == FOLDER_NOTSPECIAL)
                                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                g_pStore->FreeRecord(&info);
                            }
                        }
                    }
                    break;
            }
        }
    }

    return(S_OK);
}

HRESULT CAccountView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int iSel;
    BOOL fTree;
    HRESULT hr;
    FOLDERID id;

    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
    if (iSel != -1)
    {
        if (MenuUtil_HandleNewMessageIDs(nCmdID, m_hwndOwner, _IdFromIndex((DWORD)iSel), m_ftType != FOLDER_NEWS, FALSE, NULL))
            return(S_OK);
    }

    fTree = !(S_OK == m_pShellBrowser->HasFocus(ITB_OEVIEW));

    hr = OLECMDERR_E_NOTSUPPORTED;

    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
        case ID_UNMARK_RETRIEVE_FLD:
            _MarkForDownload(nCmdID);
            hr = S_OK;
            break;

        case ID_COLUMNS:
            m_pColumns->ColumnsDialog(m_hwndOwner);
            hr = S_OK;
            break;

        case ID_SUBSCRIBE:
        case ID_UNSUBSCRIBE:
            _Subscribe(nCmdID == ID_SUBSCRIBE);
            hr = S_OK;
            break;

        case ID_COMPACT:
            if (iSel != -1)
                CompactFolders(m_hwndOwner, RECURSE_INCLUDECURRENT, _IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_CATCH_UP:
            iSel = -1;
            while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
                MenuUtil_OnCatchUp(_IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_GO_SELECTED:
        case ID_OPEN:
        case ID_OPEN_FOLDER:
            if (iSel != -1)
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, _IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_SELECT_ALL:
            ListView_SelectAll(m_hwndList);
            if (m_hwndList != GetFocus())
                SetFocus(m_hwndList);
            hr = S_OK;
            break;

        case ID_MARK_ALL_READ:
            _MarkAllRead();
            hr = S_OK;
            break;

        // commands below are handled by the treeview if it has the focus
        // otherwise we'll handle them based on what is selected in us

        case ID_ADD_SHORTCUT:
            if (!fTree)
            {
                if (iSel != -1)
                    OutlookBar_AddShortcut(_IdFromIndex((DWORD)iSel));
                hr = S_OK;
            }
            break;

        case ID_PROPERTIES:
            if (!fTree)
            {
                if (iSel != -1)
                    MenuUtil_OnProperties(m_hwndOwner, _IdFromIndex(iSel));
                hr = S_OK;
            }
            break;

        case ID_NEW_FOLDER:
        case ID_NEW_FOLDER2:
            if (!fTree)
            {
                if (iSel != -1)
                    SelectFolderDialog(m_hwndOwner, SFD_NEWFOLDER, _IdFromIndex((DWORD)iSel), TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT | FD_FORCEINITSELFOLDER,
                        NULL, NULL, NULL);
                hr = S_OK;
            }
            break;

        case ID_MOVE:
            if (!fTree)
            {
                if (iSel != -1)
                {
                    // TODO: move all selected folders, not just the one with focus
                    SelectFolderDialog(m_hwndOwner, SFD_MOVEFOLDER, _IdFromIndex((DWORD)iSel), TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT,
                        MAKEINTRESOURCE(idsMove), MAKEINTRESOURCE(idsMoveCaption), NULL);
                }
                hr = S_OK;
            }
            break;

        case ID_RENAME:
            if (!fTree)
            {
                if (iSel != -1)
                    RenameFolderDlg(m_hwndOwner, _IdFromIndex((DWORD)iSel));
                hr = S_OK;
            }
            break;

        case ID_DELETE:
        case ID_DELETE_NO_TRASH:
        case ID_DELETE_FOLDER:
            if (!fTree)
            {
                if (iSel != -1)
                    _HandleDelete(nCmdID == ID_DELETE_NO_TRASH);

                hr = S_OK;
            }
            break;
    }

    return(hr);
}

void CAccountView::_HandleSettingsButton(HWND hwndBtn)
{
    HRESULT hr;
    HMENU hMenu;
    HWND hwndBrowser;
    RECT rc;
    DWORD state;

    hMenu = LoadPopupMenu(IDR_SYNCHRONIZE_POPUP);
    if (hMenu != NULL)
    {
        // Enable / disable
        MenuUtil_EnablePopupMenu(hMenu, (IOleCommandTarget *)this);

        GetWindowRect(hwndBtn, &rc);
        m_pShellBrowser->GetWindow(&hwndBrowser);

        TrackPopupMenu(hMenu, TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN,
            rc.left, rc.bottom, 0, hwndBrowser, NULL);

        DestroyMenu(hMenu);
    }
}

void CAccountView::_HandleDelete(BOOL fNoTrash)
{
    FOLDERID *pid;
    int iSel, cSel, cid;

    cSel = ListView_GetSelectedCount(m_hwndList);
    if (cSel > 0)
    {
        if (MemAlloc((void **)&pid, cSel * sizeof(FOLDERID)))
        {
            cid = cSel;
            iSel = -1;
            while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
            {
                cid--;
                Assert(cid >= 0);
                pid[cid] = _IdFromIndex(iSel);
            }

            Assert(cid == 0);

            if (m_ftType == FOLDER_NEWS)
            {
                MenuUtil_OnSubscribeGroups(m_hwndOwner, pid, cSel, FALSE);
            }
            else
            {
                MenuUtil_DeleteFolders(m_hwndOwner, pid, cSel, fNoTrash);
            }

            MemFree(pid);
        }
    }
}

BOOL CAccountView::_IsSelectedFolder(FLDRFLAGS dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial)
{
    BOOL fSpecial;
    HRESULT hr;
    FLDRFLAGS dw;
    FOLDERINFO info;
    DWORD iItem = -1;
	BOOL fHTTPFolder = FALSE;

    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        hr = g_pStore->GetFolderInfo(_IdFromIndex(iItem), &info);
        if (SUCCEEDED(hr))
        {
            dw = info.dwFlags;
			fHTTPFolder = (BOOL) (info.tyFolder & FOLDER_HTTPMAIL);

            fSpecial = fIgnoreSpecial && (info.tySpecial != FOLDER_NOTSPECIAL);

            g_pStore->FreeRecord(&info);

            if (fSpecial)
                continue;

            if (fAll)
            {
                // If all must match and this one doesn't, then we can quit now.
                if (!(fCondition == !!(dw & dwFlags)))
                    return (FALSE);
            }
            else
            {
                // If only one needs to match and this one does, then we can
                // quit now.
                if (fCondition == !!(dw & dwFlags))
				{
					if(fHTTPFolder)
					{
						FOLDERINFO		SvrFolderInfo = {0};
						IImnAccount 	*pAccount = NULL;
						CHAR			szAccountId[CCHMAX_ACCOUNT_NAME];
						HRESULT 		hr = S_OK;
						DWORD			dwShow = 0;
						
						// Get the server for this folder
						IF_FAILEXIT(hr = GetFolderServer(_IdFromIndex(iItem), &SvrFolderInfo));
						
						// Get the account ID for the server
						*szAccountId = 0;
						IF_FAILEXIT(hr = GetFolderAccountId(&SvrFolderInfo, szAccountId, ARRAYSIZE(szAccountId)));
						
						// Get the account interface
						IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));
						
						IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwShow));
						if(dwShow)
						{
							if(HideHotmail())
								return (FALSE);
						}
					}
exit:					
                    return (TRUE);
				}
            }
        }
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}

LRESULT CALLBACK CAccountView::AcctViewWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRet;
    CAccountView     *pThis;

    if (msg == WM_NCCREATE)
    {
        pThis = (CAccountView *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
    }
    else
        pThis = (CAccountView *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    Assert(pThis);

    return pThis->_WndProc(hwnd, msg, wParam, lParam);
}

LRESULT CAccountView::_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndFocus, hwndBrowser;
    BOOL fTip;
    RECT rc;

    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         _OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           _OnSize);
        HANDLE_MSG(hwnd, WM_NOTIFY,         _OnNotify);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       _OnSetFocus);

        case WM_MENUSELECT:
            CStatusBar *pStatusBar;
            m_pShellBrowser->GetStatusBar(&pStatusBar);
            HandleMenuSelect(pStatusBar, wParam, lParam);
            pStatusBar->Release();
            return 0;

        case WM_COMMAND:
            _OnCommand(wParam, lParam);
            break;

        case WM_PAINT:
            return(_OnPaint(hwnd, (HDC)wParam));

        case WM_DRAWITEM:
            if (wParam == ID_POPUP_SYNCHRONIZE)
            {
                DrawSettingsButton(hwnd, (LPDRAWITEMSTRUCT)lParam);
                return(TRUE);
            }
            break;

        case WM_CONTEXTMENU:
            _OnContextMenu(hwnd, (HWND)wParam, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            return(0);

        case NVM_INITHEADERS:
            _PostCreate();
            return 0;

        case WM_ACTIVATE:
            _HandleItemStateChange();

            if (LOWORD(wParam) != WA_INACTIVE)
            {
                // DefWindowProc will set the focus to our view window, which
                // is not what we want.  Instead, we will let the explorer set
                // the focus to our view window if we should get it, at which
                // point we will set it to the proper control.
                return 0;
            }
            break;

        case WM_SYSCOLORCHANGE:
            SendMessage(m_hwndList, msg, wParam, lParam);
            break;

        case WM_WININICHANGE:
            SendMessage(m_hwndList, msg, wParam, lParam);

            // reposition and resize things with the new font
            _OnWinIniChange(hwnd);
            break;

        case NVM_GETNEWGROUPS:
            if (m_pGroups != NULL)
            {
                m_pGroups->HandleGetNewGroups();
                m_pGroups->Release();
                m_pGroups = NULL;
            }
            return(0);

        case CM_OPTIONADVISE:
            m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
            return (0);

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
            {
                hwndFocus = GetFocus();
                if (IsChild(hwnd, hwndFocus))
                    return SendMessage(hwndFocus, msg, wParam, lParam);
            }
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void CAccountView::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    HWND hwndBrowser;
    HRESULT hr;

    if (HIWORD(wParam) == BN_CLICKED)
    {
        switch (LOWORD(wParam))
        {
            case ID_SEND_RECEIVE:
            case ID_SYNC_THIS_NOW:
            case ID_IMAP_FOLDERS:
            case ID_NEWSGROUPS:
                m_pShellBrowser->GetWindow(&hwndBrowser);
                SendMessage(hwndBrowser, WM_COMMAND, wParam, lParam);
                break;

            case ID_POPUP_SYNCHRONIZE:
                _HandleSettingsButton((HWND)lParam);
                break;

            default:
                Assert(FALSE);
                break;
        }
    }
}

//
//  FUNCTION:   CAccountView::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CAccountView::_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    HRESULT hr;
    DWORD style;
    FOLDERINFO info;
    COLUMN_SET_TYPE set;
    const ACCTVIEWBTN *pBtn;
    int i, cBtn, idsMajor, idsMinor;
    char sz[CCHMAX_STRINGRES];

    switch (m_ftType)
    {
        case FOLDER_LOCAL:
            set = COLUMN_SET_LOCAL_STORE;
            pBtn = c_rgMailBtns;
            cBtn = ARRAYSIZE(c_rgMailBtns);
            idsMajor = 0;
            idsMinor = idsLocalFoldersMinor;
            break;
        case FOLDER_IMAP:
            set = COLUMN_SET_IMAP_ACCOUNT;
            pBtn = c_rgImapBtns;
            cBtn = ARRAYSIZE(c_rgImapBtns);
            idsMajor = idsSyncManager;
            idsMinor = idsSetSyncSettings;
            break;
        case FOLDER_HTTPMAIL:
            set = COLUMN_SET_HTTPMAIL_ACCOUNT;
            pBtn = c_rgHttpBtns;
            cBtn = ARRAYSIZE(c_rgHttpBtns);
            idsMajor = idsSyncManager;
            idsMinor = idsSetSyncSettings;
            break;
        case FOLDER_NEWS:
            set = COLUMN_SET_NEWS_ACCOUNT;
            pBtn = c_rgNewsBtns;
            cBtn = ARRAYSIZE(c_rgNewsBtns);
            idsMajor = idsSyncManagerNews;
            idsMinor = idsSetNewsSyncSettings;
            break;
        default:
            Assert(FALSE);
            break;
    }

    for (i = 0; i < cBtn; i++, pBtn++)
    {
        if (pBtn->cmd == ID_POPUP_SYNCHRONIZE)
            style = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_NOTIFY | BS_OWNERDRAW | WS_DISABLED;
        else
            style = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_NOTIFY;
        AthLoadString(pBtn->idsText, sz, ARRAYSIZE(sz));
        m_rgBtns[m_cBtns] = CreateWindow("button", sz, style,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                hwnd, (HMENU)LongToHandle(pBtn->cmd), g_hInst, 0);
        if (m_rgBtns[m_cBtns] != NULL)
            m_cBtns++;
    }

    m_hwndList = CreateWindowEx(0, WC_LISTVIEW, c_szEmpty,
        WS_VISIBLE | WS_TABSTOP | WS_CHILD | LVS_REPORT | LVS_NOSORTHEADER |
        LVS_OWNERDATA | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        hwnd, (HMENU)IDC_SUBSCRIBE_LIST, g_hInst, 0);
    Assert(m_hwndList != NULL);

    hr = m_pColumns->Initialize(m_hwndList, set);
    Assert(SUCCEEDED(hr));

    hr = m_pColumns->ApplyColumns(COLUMN_LOAD_REGISTRY, 0, 0);
    Assert(SUCCEEDED(hr));

    m_hwndHeader = ListView_GetHeader(m_hwndList);
    Assert(m_hwndHeader != NULL);

    // Initialize the extended styles so we get full row select.  Just because
    // it looks better.
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);

    Assert(m_himlFolders != NULL);
    ListView_SetImageList(m_hwndList, m_himlFolders, LVSIL_SMALL);

    SetIntlFont(m_hwndList);

    hr = g_pStore->GetFolderInfo(m_idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (MemAlloc((void **)&m_pszMajor, CCHMAX_STRINGRES))
        {
            if (idsMajor != 0)
            {
                AthLoadString(idsMajor, sz, ARRAYSIZE(sz));
                wnsprintf(m_pszMajor, CCHMAX_STRINGRES, sz, info.pszName);
            }
            else
            {
                StrCpyN(m_pszMajor, info.pszName, CCHMAX_STRINGRES);
            }
        }

        if (idsMinor != 0)
            m_pszMinor = AthLoadString(idsMinor, NULL, 0);

        g_pStore->FreeRecord(&info);
    }

    m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
    OptionAdvise(hwnd);
    _OnWinIniChange(hwnd);

    return TRUE;
}

BOOL CAccountView::_OnWinIniChange(HWND hwnd)
    {
    char sz[CCHMAX_STRINGRES];
    TEXTMETRIC tm;
    HDC hdc;
    int i, cch, cxMax;
    SIZE size;
    HFONT hfont, hfontBold, hfontOld;
    RECT rc, rcBtn;

    GetClientRect(hwnd, &rc);

    hfont = HGetCharSetFont(FNT_SYS_ICON, NULL);
    hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);

    hdc = GetDC(hwnd);

    hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

    Assert(m_pszMajor != NULL);
    GetTextExtentPoint32(hdc, m_pszMajor, lstrlen(m_pszMajor), &size);
    m_rcMajor.left = SUBSCRIBE_BORDER;
    m_rcMajor.top = SUBSCRIBE_BORDER;
    m_rcMajor.right = m_rcMajor.left + size.cx;
    m_rcMajor.bottom = m_rcMajor.top + size.cy;

    m_rcMinor.left = m_rcMajor.left;
    m_rcMinor.top = m_rcMajor.bottom + 1;
    if (m_pszMinor != NULL)
    {
        SelectObject(hdc, (HGDIOBJ)hfont);
        GetTextExtentPoint32(hdc, m_pszMinor, lstrlen(m_pszMinor), &size);
    }
    m_rcMinor.right = m_rcMinor.left + size.cx;
    m_rcMinor.bottom = m_rcMinor.top + size.cy;

    m_rcHeader.left = 0;
    m_rcHeader.top = 0;
    m_rcHeader.right = rc.right;
    m_rcHeader.bottom = m_rcMinor.bottom + SUBSCRIBE_BORDER;

    m_rcButtons.left = m_rcHeader.left;
    m_rcButtons.top = m_rcHeader.bottom + 1;
    m_rcButtons.right = m_rcHeader.right;
    m_rcButtons.bottom = m_rcButtons.top + m_rcHeader.bottom;

    SelectObject(hdc, hfont);

    cxMax = 0;
    for (i = 0; i < m_cBtns; i++)
    {
        cch = GetWindowText(m_rgBtns[i], sz, ARRAYSIZE(sz));
        GetTextExtentPoint32(hdc, sz, cch, &size);
        if (size.cx > cxMax)
            cxMax = size.cx;
    }

    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    rcBtn.top = m_rcButtons.top + SUBSCRIBE_BORDER;
    rcBtn.bottom = rcBtn.top + (m_rcMinor.bottom - m_rcMajor.top);
    rcBtn.left = m_rcMajor.left;
    rcBtn.right = cxMax + 2 * GetSystemMetrics(SM_CXEDGE) + 6 + (rcBtn.bottom - rcBtn.top);

    cxMax = SUBSCRIBE_BORDER + (rcBtn.right - rcBtn.left);

    for (i = 0; i < m_cBtns; i++)
    {
        SendMessage(m_rgBtns[i], WM_SETFONT, (WPARAM)hfont, 0);

        SetWindowPos(m_rgBtns[i], NULL, rcBtn.left, rcBtn.top,
            rcBtn.right - rcBtn.left, rcBtn.bottom - rcBtn.top,
            SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

        rcBtn.left += cxMax;
        rcBtn.right += cxMax;
    }

    rc.top = m_rcButtons.bottom + 1;
    SendMessage(m_hwndList, WM_SETFONT, (WPARAM)hfont, 0);
    SetWindowPos(m_hwndList, NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

    return(TRUE);
}

//
//  FUNCTION:   CAccountView::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area.
//      cyClient - New height of the client area.
//
void CAccountView::_OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    int cy;
    BOOL fUpdate;

    fUpdate = (cxClient > m_rcHeader.right);

    m_rcHeader.right = cxClient;
    m_rcMajor.right = m_rcHeader.right - SUBSCRIBE_BORDER;
    m_rcMinor.right = m_rcMajor.right;
    m_rcButtons.right = m_rcHeader.right;

    if ((m_rcButtons.bottom + 1) < cyClient)
        cy = cyClient - (m_rcButtons.bottom + 1);
    else
        cy = 1;

    SetWindowPos(m_hwndList, NULL, 0, 0, cxClient, cy,
        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOMOVE);

    if (fUpdate)
    {
        InvalidateRect(hwnd, NULL, FALSE);
        UpdateWindow(hwnd);
    }
}

LRESULT CAccountView::_OnPaint(HWND hwnd, HDC hdc)
{
    HFONT hfont, hfontBold, hfontOld;
    RECT rc, rcT;
    PAINTSTRUCT ps;
    COLORREF crText, crBackground;
    HBRUSH hBrush, hBrushOld;

    if (0 != GetUpdateRect(hwnd, &rc, FALSE))
    {
        hdc = BeginPaint(hwnd, &ps);

        if (IntersectRect(&rcT, &rc, &m_rcHeader))
        {
            crText = GetSysColor(COLOR_WINDOW);
            crBackground = GetSysColor(COLOR_3DSHADOW);

            hBrush = CreateSolidBrush(crBackground);
            hBrushOld = SelectBrush(hdc, hBrush);
            PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, rcT.bottom - rcT.top, PATCOPY);
            SelectBrush(hdc, hBrushOld);
            DeleteBrush(hBrush);

            SetBkColor(hdc, crBackground);
            SetTextColor(hdc, crText);

            if (m_pszMajor != NULL &&
                IntersectRect(&rcT, &rc, &m_rcMajor))
            {
                hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);
                hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

                DrawText(hdc, m_pszMajor, lstrlen(m_pszMajor), &m_rcMajor, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);

                SelectObject(hdc, (HGDIOBJ)hfontOld);
            }

            if (m_pszMinor != NULL &&
                IntersectRect(&rcT, &rc, &m_rcMinor))
            {
                hfontBold = HGetCharSetFont(FNT_SYS_ICON, NULL);
                hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

                DrawText(hdc, m_pszMinor, lstrlen(m_pszMinor), &m_rcMinor, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);

                SelectObject(hdc, (HGDIOBJ)hfontOld);
            }
        }

        rc.bottom = m_rcButtons.bottom;
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_BOTTOM);

        EndPaint(hwnd, &ps);
    }

    return(0);
}

BOOL DrawArrow(HDC hdc, LPARAM x, WPARAM y, int dx, int dy)
{
    int i, iCount;

    iCount = (dx + 1) / 2;

    // draw arrow head
    for (i = 0; i < iCount; i++, dx -= 2, x += 1)
        PatBlt(hdc, (int) x, (int) y++, dx, 1, PATCOPY);

    return(TRUE);
}

#define CXARROW     9
#define CYARROW     5

void DrawSettingsButton(HWND hwnd, LPDRAWITEMSTRUCT pdi)
{
    BOOL fPushed, fDisabled;
    TCHAR sz[CCHMAX_STRINGRES];
    RECT rcFocus;
    int d, cch, x, y, xArrow, yArrow;
    SIZE size;
    UINT dsFlags;
    HGDIOBJ hbrOld;

    Assert(pdi->CtlType == ODT_BUTTON);
    Assert(pdi->CtlID == ID_POPUP_SYNCHRONIZE);

    if (!!(pdi->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
    {
        fPushed = !!(pdi->itemState & ODS_SELECTED);
        fDisabled = !!(pdi->itemState & ODS_DISABLED);

        if (fPushed)
            dsFlags = DFCS_BUTTONPUSH | DFCS_PUSHED;
        else
            dsFlags = DFCS_BUTTONPUSH;

        DrawFrameControl(pdi->hDC, &pdi->rcItem, DFC_BUTTON, dsFlags);

        cch = GetWindowText(pdi->hwndItem, sz, ARRAYSIZE(sz));
        GetTextExtentPoint32(pdi->hDC, sz, cch, &size);

        size.cy++;
        x = (pdi->rcItem.left + pdi->rcItem.right - size.cx) / 2;
        y = (pdi->rcItem.top + pdi->rcItem.bottom - size.cy) / 2;
        if (fPushed)
        {
            x++;
            y++;
        }

        xArrow = x + size.cx + 7;
        yArrow = (pdi->rcItem.top + pdi->rcItem.bottom - CYARROW) / 2;
        yArrow++;
        if (fPushed)
            yArrow++;

        if (fDisabled)
        {
            DrawState(pdi->hDC, NULL, DrawArrow, 0, 0,
                xArrow, yArrow, CXARROW, CYARROW, DST_COMPLEX | DSS_DISABLED);
        }
        else
        {
            hbrOld = SelectObject(pdi->hDC, GetSysColorBrush(COLOR_BTNTEXT));
            DrawArrow(pdi->hDC, xArrow, yArrow, CXARROW, CYARROW);
            SelectObject(pdi->hDC, hbrOld);
        }


        if (fDisabled)
            dsFlags = DST_TEXT | DSS_DISABLED;
        else
            dsFlags = DST_TEXT | DSS_NORMAL;

        DrawState(pdi->hDC, NULL, NULL, (LPARAM)sz, (WPARAM)cch,
            x, y, size.cx, size.cy, dsFlags);
    }

    if (!!(pdi->itemAction & ODA_FOCUS) || !!(pdi->itemState & ODS_FOCUS))
    {
        rcFocus = pdi->rcItem;

        d = GetSystemMetrics(SM_CXEDGE) + 1;
        rcFocus.left += d;
        rcFocus.right -= d;

        d = GetSystemMetrics(SM_CYEDGE) + 1;
        rcFocus.top += d;
        rcFocus.bottom -= d;

        DrawFocusRect(pdi->hDC, &rcFocus);
    }
}

//
//  FUNCTION:   CAccountView::OnSetFocus
//
//  PURPOSE:    If the focus ever is set to the view window, we want to
//              make sure it goes to one of our child windows.  Preferably
//              the focus will go to the last child to have the focus.
//
//  PARAMETERS:
//      hwnd         - Handle of the view window.
//      hwndOldFocus - Handle of the window losing focus.
//
void CAccountView::_OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    SetFocus(m_hwndList);
}

//
//  FUNCTION:   CAccountView::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CAccountView::_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    LRESULT lRes=0;
    HD_NOTIFY *phdn;
    int iSel;
    DWORD dwPos;
    UINT uChanged;
    FOLDERINFO info;
    LV_HITTESTINFO lvhti;
    NM_LISTVIEW *pnmlv;
    LV_DISPINFO *pDispInfo;
    DWORD cColumns;
    NMCUSTOMDRAW *pnmcd;
    COLUMN_ID id;
    FOLDERID idFolder;
    COLUMN_SET *rgColumns;
    HRESULT hr;
    FNTSYSTYPE fntType;

    if (pnmhdr->hwndFrom != m_hwndList &&
        pnmhdr->hwndFrom != m_hwndHeader)
        return(0);

    switch (pnmhdr->code)
    {
        case NM_SETFOCUS:
            m_pShellBrowser->OnViewWindowActive(this);
            _HandleItemStateChange();
            break;

        case LVN_ITEMACTIVATE:
            // Tell our host to open the selected items
            iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
            if (iSel >= 0)
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, _IdFromIndex(iSel));
            break;

        case LVN_GETDISPINFO:
            pDispInfo = (LV_DISPINFO *)pnmhdr;
            id = m_pColumns->GetId(pDispInfo->item.iSubItem);

            if ((DWORD)pDispInfo->item.iItem < m_cnode)
                _GetDisplayInfo(pDispInfo, id);
            break;

        case NM_CLICK:
            dwPos = GetMessagePos();
            lvhti.pt.x = (int)(short)LOWORD(dwPos);
            lvhti.pt.y = (int)(short)HIWORD(dwPos);
            ScreenToClient(m_hwndList, &(lvhti.pt));

            // Ask the ListView where this is
            if (-1 == ListView_SubItemHitTest(m_hwndList, &lvhti))
                break;

            id = m_pColumns->GetId(lvhti.iSubItem);
            if (lvhti.flags == LVHT_ONITEMICON)
            {
                if (id == COLUMN_DOWNLOAD)
                {
                    _ToggleDownload(lvhti.iItem);
                }
            }
            break;

        case NM_CUSTOMDRAW:
            pnmcd = (NMCUSTOMDRAW *)pnmhdr;

            // If this is a prepaint notification, we tell the control we're interested
            // in further notfications.
            if (pnmcd->dwDrawStage == CDDS_PREPAINT)
            {
                lRes = CDRF_NOTIFYITEMDRAW;
                break;
            }

            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            // $REVIEW - Why?
            if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
            {
                fntType = FNT_SYS_ICON;

                if (pnmcd->dwItemSpec >= m_cnode)
                {
                    lRes = CDRF_DODEFAULT;
                    break;
                }

                if (SUCCEEDED(g_pStore->GetFolderInfo(_IdFromIndex((DWORD)(pnmcd->dwItemSpec)), &info)))
                {
                    if (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM))
                    {
                        if ((info.cWatchedUnread) && (m_clrWatched > 0 && m_clrWatched < 16))
                        {
                            LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[m_clrWatched - 1];
                        }
                        else
                        {
                            id = m_pColumns->GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem);
                            if (id == COLUMN_DOWNLOAD && 0 == (info.dwFlags & FOLDER_SYNCMASK))
                            {
                                LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                            }
                        }
                    }

                    if (info.cUnread > 0 ||
                        (info.tyFolder == FOLDER_NEWS && info.dwNotDownloaded > 0))
                        fntType = FNT_SYS_ICON_BOLD;

                    g_pStore->FreeRecord(&info);
                }

                SelectObject(pnmcd->hdc, HGetCharSetFont(fntType, GetListViewCharset()));
                lRes = CDRF_NEWFONT | CDRF_NOTIFYSUBITEMDRAW;
                break;
            }

            lRes = CDRF_DODEFAULT;
            break;

        case LVN_ITEMCHANGED:
            pnmlv = (NM_LISTVIEW *)pnmhdr;
            if (!!(pnmlv->uChanged & LVIF_STATE) &&
                !!((LVIS_SELECTED | LVIS_FOCUSED) & (pnmlv->uOldState ^ pnmlv->uNewState)))
            {
                _HandleItemStateChange();
            }
            break;

        case HDN_ENDTRACK:
            phdn = (HD_NOTIFY *)pnmhdr;
            m_pColumns->SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;

        case HDN_DIVIDERDBLCLICK:
            phdn = (HD_NOTIFY *)pnmhdr;
            // When the user double clicks on a header divider, we're supposed to
            // autosize that column.
            m_pColumns->SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_hwndList, phdn->iItem));
            break;

        default:
            lRes = 0;
            break;
    }

    return(lRes);
}

void CAccountView::_HandleItemStateChange()
{
    OLECMD rgCmds[3];
    HRESULT hr;
    IOleCommandTarget *pTarget;
    int i;

    hr = m_pShellBrowser->QueryInterface(IID_IOleCommandTarget, (void **)&pTarget);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < m_cBtns; i++)
        {
            rgCmds[i].cmdID = GetWindowLong(m_rgBtns[i], GWL_ID);
            rgCmds[i].cmdf = 0;
        }

        hr = pTarget->QueryStatus(NULL, m_cBtns, rgCmds, NULL);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < m_cBtns; i++)
            {
                EnableWindow(m_rgBtns[i], !!(rgCmds[i].cmdf & OLECMDF_ENABLED));

                Assert(0 == (rgCmds[i].cmdf & OLECMDF_LATCHED));
                Assert(0 == (rgCmds[i].cmdf & OLECMDF_NINCHED));
            }
        }

        pTarget->Release();
    }

    m_pShellBrowser->UpdateToolbar();
}

HRESULT CAccountView::_GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id)
{
    DWORD dwFlags;
    int count;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *pNode;

    pNode = _NodeFromIndex((DWORD)pDispInfo->item.iItem);
    if (pNode == NULL)
        return(S_OK);

    hr = g_pStore->GetFolderInfo(pNode->id, &info);
    if (FAILED(hr))
        return(hr);

    if (!!(pDispInfo->item.mask & LVIF_TEXT))
    {
        if (id == COLUMN_NEWSGROUP || id == COLUMN_FOLDER)
        {
            StrCpyN(pDispInfo->item.pszText, info.pszName, pDispInfo->item.cchTextMax);
        }
        else if (id == COLUMN_DOWNLOAD)
        {
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                if (0 == (info.dwFlags & FOLDER_SYNCMASK))
                    dwFlags = pNode->dwDownload;
                else
                    dwFlags = info.dwFlags;

                Assert(!!(dwFlags & FOLDER_SYNCMASK));

                if (!!(dwFlags & FOLDER_DOWNLOADALL))
                    AthLoadString(idsAllMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(dwFlags & FOLDER_DOWNLOADNEW))
                    AthLoadString(idsNewMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(dwFlags & FOLDER_DOWNLOADHEADERS))
                    AthLoadString(idsNewHeaders, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
            }
        }
        else if (id == COLUMN_TOTAL || id == COLUMN_UNREAD)
        {
            if (id == COLUMN_UNREAD)
                count = info.cUnread;
            else
                count = info.cMessages;

            if (FOLDER_NEWS == info.tyFolder)
                count += info.dwNotDownloaded;

            if (count < 0)
                count = 0;
            wnsprintf(pDispInfo->item.pszText, pDispInfo->item.cchTextMax, "%d", count);
        }
    }

    if (!!(pDispInfo->item.mask & LVIF_IMAGE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                pDispInfo->item.iImage = iNewsGroup;
                if (!!(info.dwFlags & FOLDER_SYNCMASK))
                    pDispInfo->item.iImage = iNewsGroupSync;
            }
        }
        else if (COLUMN_FOLDER == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                if (info.tySpecial == FOLDER_NOTSPECIAL)
                    pDispInfo->item.iImage = iFolderClosed;
                else
                    pDispInfo->item.iImage = (iInbox + (((info.tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : info.tySpecial) - 1));
            }
        }
        else if (COLUMN_DOWNLOAD == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
                {
                if (!!(info.dwFlags & FOLDER_SYNCMASK))
                    pDispInfo->item.iImage = iChecked;
                else
                    pDispInfo->item.iImage = iUnchecked;
            }
        }
    }

    if (!!(pDispInfo->item.mask & LVIF_INDENT))
    {
        if (COLUMN_FOLDER == id)
            pDispInfo->item.iIndent = pNode->indent;
    }

    g_pStore->FreeRecord(&info);
    return(S_OK);
}

BOOL CAccountView::_OnActivate(UINT uActivation)
{
    // if focus stays within the frame, but goes outside our view.
    // ie.. TreeView gets focus then we get an activate nofocus. Be sure
    // to UIDeactivate the docobj in this case
    if (uActivation == SVUIA_ACTIVATE_NOFOCUS)
    {

    }

    if (m_uActivation != uActivation)
    {
        _OnDeactivate();
        m_uActivation = uActivation;

        if (!m_fFirstActive)
        {
            PostMessage(m_hwnd, NVM_INITHEADERS, 0, 0L);
            m_fFirstActive = TRUE;
        }
    }
    return TRUE;
}

BOOL CAccountView::_OnDeactivate()
{
    return TRUE;
}

HRESULT CAccountView::_InsertChildren(FOLDERID idFolder, DWORD indent, DWORD *piNode)
{
    DWORD cnode;
    ULONG cFolders;
    IEnumerateFolders *pEnum;
    FOLDERINFO info;
    HRESULT hr;

    Assert(piNode != NULL);
    Assert(*piNode <= m_cnode);

    hr = g_pStore->EnumChildren(idFolder, TRUE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            while (S_OK == pEnum->Next(1, &info, NULL))
            {
                Assert(m_cnode <= m_cnodeBuf);

                // Skip folders which are hidden
                if (ISFLAGSET(info.dwFlags, FOLDER_HIDDEN))
                    continue;

                if (m_cnode == m_cnodeBuf)
                {
                    cnode = m_cnode + cFolders + CALLOCIDBUF;
                    if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
                    {
                        pEnum->Release();
                        return(E_OUTOFMEMORY);
                    }

                    m_cnodeBuf = cnode;
                }

                if (*piNode < m_cnode)
                    MoveMemory(&m_rgnode[*piNode + 1], &m_rgnode[*piNode], (m_cnode - *piNode) * sizeof(FLDRNODE));

                m_rgnode[*piNode].id = info.idFolder;
                m_rgnode[*piNode].indent = indent;
                m_rgnode[*piNode].dwDownload = m_dwDownloadDef;
                (*piNode)++;
                m_cnode++;

                if (!!(info.dwFlags & FOLDER_HASCHILDREN))
                    hr = _InsertChildren(info.idFolder, indent + 1, piNode);

                g_pStore->FreeRecord(&info);

                if (FAILED(hr))
                    break;
            }
        }

        pEnum->Release();
    }

    return(hr);
}

HRESULT CAccountView::_InsertChildrenSpecial(FOLDERID idFolder, DWORD indent, DWORD *piNode)
{
    DWORD cnode;
    ULONG iFolder, cFolders;
    IEnumerateFolders *pEnum;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *rgNode, *pNode;

    Assert(piNode != NULL);
    Assert(*piNode <= m_cnode);
    Assert(indent == 0);

    rgNode = NULL;

    hr = g_pStore->EnumChildren(idFolder, TRUE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            if (!MemAlloc((void **)&rgNode, cFolders * sizeof(FLDRNODE)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pNode = rgNode;
                cFolders = 0;
                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    if ((!(g_dwAthenaMode & MODE_NEWSONLY) || (info.tySpecial != FOLDER_INBOX)) &&
                        ISFLAGCLEAR(info.dwFlags, FOLDER_HIDDEN))
                    {
                        pNode->id = info.idFolder;
                        pNode->indent = !!(info.dwFlags & FOLDER_HASCHILDREN) ? 1 : 0;
                        pNode->dwDownload = m_dwDownloadDef;

                        pNode++;
                        cFolders++;
                    }
                    g_pStore->FreeRecord(&info);
                }

                qsort(rgNode, cFolders, sizeof(FLDRNODE), GroupCompare);
            }
        }

        pEnum->Release();
    }

    if (rgNode != NULL)
    {
        Assert(SUCCEEDED(hr));
        Assert(cFolders > 0);
        Assert(m_cnode == 0);
        Assert(m_cnodeBuf == 0);

        for (iFolder = 0, pNode = rgNode; iFolder < cFolders; iFolder++, pNode++)
        {
            if (m_cnode == m_cnodeBuf)
            {
                cnode = m_cnode + cFolders + CALLOCIDBUF;
                if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                m_cnodeBuf = cnode;
            }

            m_rgnode[*piNode].id = pNode->id;
            m_rgnode[*piNode].indent = indent;
            m_rgnode[*piNode].dwDownload = m_dwDownloadDef;
            (*piNode)++;
            m_cnode++;

            if (pNode->indent == 1)
            {
                hr = _InsertChildren(pNode->id, indent + 1, piNode);

                if (FAILED(hr))
                    break;
            }
        }

        MemFree(rgNode);
    }

    return(hr);
}

void CAccountView::_PostCreate()
{
    HRESULT hr;
    DWORD iNode;
    BOOL fNews, fSub;

    Assert(m_cnode == 0);

    ProcessICW(m_hwndOwner, m_ftType);

    fNews = m_ftType == FOLDER_NEWS;

    iNode = 0;
    if (fNews)
        hr = _InsertChildren(m_idFolder, 0, &iNode);
    else
        hr = _InsertChildrenSpecial(m_idFolder, 0, &iNode);
    if (FAILED(hr))
    {
        if (m_rgnode != NULL)
        {
            MemFree(m_rgnode);
            m_rgnode = NULL;
        }
        m_cnode = 0;
        m_cnodeBuf = 0;
    }
    else
    {
        Assert(iNode == m_cnode);
    }

    ListView_SetItemCount(m_hwndList, m_cnode);
    if (m_cnode > 0)
    {
        ListView_SetItemState(m_hwndList, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if (m_cnode == 0)
        m_pEmptyList->Show(m_hwndList, m_ftType == FOLDER_NEWS ? (LPSTR)idsEmptyNewsAcct : (LPSTR)idsEmptyMailAcct);

    UpdateWindow(m_hwndList);

    g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this);
    m_fRegistered = TRUE;

    fSub = FALSE;

    if (m_cnode == 0 && (fNews || m_ftType == FOLDER_IMAP || m_ftType == FOLDER_HTTPMAIL))
    {
        if (IDYES == AthMessageBoxW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena),
                        fNews ? MAKEINTRESOURCEW(idsErrNoSubscribedGroups) : MAKEINTRESOURCEW(idsErrNoSubscribedFolders),
                        0, MB_YESNO))
        {
            if (m_ftType == FOLDER_HTTPMAIL)
                DownloadNewsgroupList(m_hwndOwner, m_idFolder);
            else
                DoSubscriptionDialog(m_hwndOwner, fNews, m_idFolder);
            fSub = TRUE;
        }
    }
    else if (m_ftType == FOLDER_IMAP && NULL != g_pStore)
    {
        FOLDERINFO  fiServer;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fiServer)))
        {
            CheckIMAPDirty(fiServer.pszAccountId, m_hwnd, fiServer.idFolder, NOFLAGS);
            g_pStore->FreeRecord(&fiServer);
        }
    }

    if (!fSub && fNews)
        hr = NewsUtil_CheckForNewGroups(m_hwnd, m_idFolder, &m_pGroups);
}

void CAccountView::_OnContextMenu(HWND hwnd, HWND hwndFrom, int x, int y)
{
    HRESULT hr;
    int iSel, i, id;
    HMENU hmenu;
    FOLDERID idFolder;
    LV_HITTESTINFO lvhti;
    POINT pt = {x, y};

    // We only have context menus for the ListView
    if (hwndFrom != m_hwndList)
        return;

    if (MAKELPARAM(x, y) == -1) // invoked from keyboard: figure out pos.
    {
        Assert(hwndFrom == m_hwndList);
        i = ListView_GetFirstSel(m_hwndList);
        if (i == -1)
            return;

        ListView_GetItemPosition(m_hwndList, i, &pt);
        ClientToScreen(m_hwndList, &pt);
        x = pt.x;
        y = pt.y;
    }

    id = 0;

    if (WindowFromPoint(pt) == m_hwndHeader)
    {
        // Pop up the context menu.
        hmenu = LoadPopupMenu(IDR_COLUMNS_POPUP);
        if (hmenu != NULL)
        {
            // Disable sort options because we don't support sorting
            EnableMenuItem(hmenu, ID_SORT_ASCENDING, MF_GRAYED|MF_DISABLED);
            EnableMenuItem(hmenu, ID_SORT_ASCENDING, MF_GRAYED|MF_DISABLED);

            id = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                             x, y, m_hwnd, NULL);

            DestroyMenu(hmenu);
        }
    }
    else
    {
        // Find out where the click happened
        lvhti.pt.x = x;
        lvhti.pt.y = y;
        ScreenToClient(m_hwndList, &lvhti.pt);

        // Have the ListView tell us what element this was on
        iSel = ListView_HitTest(m_hwndList, &lvhti);
        if (iSel >= 0)
        {
            idFolder = _IdFromIndex((DWORD)iSel);

            hr = MenuUtil_GetContextMenu(idFolder, (IOleCommandTarget *)this, &hmenu);
            if (SUCCEEDED(hr))
            {
                id = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                                 x, y, m_hwnd, NULL);
                DestroyMenu(hmenu);
            }
        }
    }

    if (id != 0)
        Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
}

int __cdecl GroupCompare(const void *lParam1, const void *lParam2)
    {
    int cmp;
    HRESULT hr;
    FOLDERINFO info1, info2;

    IxpAssert(lParam1 != NULL);
    IxpAssert(lParam2 != NULL);

    if (FAILED(g_pStore->GetFolderInfo(((FLDRNODE *)lParam1)->id, &info1)))
        return -1;
    if (FAILED(g_pStore->GetFolderInfo(((FLDRNODE *)lParam2)->id, &info2)))
    {
        g_pStore->FreeRecord(&info1);
        return 1;
    }

    IxpAssert(0 == (info1.dwFlags & FOLDER_SERVER));
    IxpAssert(0 == (info2.dwFlags & FOLDER_SERVER));
    IxpAssert(info1.idParent == info2.idParent);

    if (info1.tySpecial != FOLDER_NOTSPECIAL)
    {
        if (info2.tySpecial != FOLDER_NOTSPECIAL)
            cmp = info1.tySpecial - info2.tySpecial;
        else
            cmp = -1;
    }
    else
    {
        if (info2.tySpecial != FOLDER_NOTSPECIAL)
            cmp = 1;
        else
            cmp = lstrcmpi(info1.pszName, info2.pszName);
    }

    g_pStore->FreeRecord(&info1);
    g_pStore->FreeRecord(&info2);

    return(cmp);
    }

HRESULT CAccountView::_InsertFolder(LPFOLDERINFO pFolder)
{
    BOOL fHide;
    DWORD cnode, cSibs, indent, index, iFirstSib, iSib, iEnd;
    HRESULT hr;
    LV_ITEM lvi;
    FLDRNODE *rgNodeSib, *pNode;

    Assert(!!(pFolder->dwFlags & FOLDER_SUBSCRIBED));

    // Check if folder is hidden
    if (pFolder->dwFlags & FOLDER_HIDDEN)
        return S_OK; // Do not display to user

    if (pFolder->tyFolder == FOLDER_NEWS)
        return(_InsertFolderNews(pFolder));

    fHide = (m_cnode == 0);

    index = _GetFolderIndex(pFolder->idFolder);
    if (index != -1)
    {
        // TODO: are we safe to assume that this one doesn't have subscribed
        // children that we aren't aware of????
        return(S_OK);
    }

    // figure out which folder the new folder is being inserted under
    if (pFolder->idParent == m_idFolder)
    {
        iFirstSib = 0;
        indent = 0;
    }
    else
    {
        index = _GetFolderIndex(pFolder->idParent);
        if (index == -1)
            return(S_OK);
        indent = m_rgnode[index].indent + 1;
        iFirstSib = index + 1;
    }

    // get all of the siblings of the new folder
    if (!MemAlloc((void **)&rgNodeSib, (m_cnode - iFirstSib + 1) * sizeof(FLDRNODE)))
        return(E_OUTOFMEMORY);

    cSibs = 0;
    for (iSib = iFirstSib, pNode = &m_rgnode[iSib]; iSib < m_cnode; iSib++, pNode++)
    {
        if (pNode->indent < indent)
        {
            break;
        }
        else if (pNode->indent == indent)
        {
            rgNodeSib[cSibs].id = pNode->id;
            cSibs++;
        }
    }
    iEnd = iSib;

    // sort the new folder and its siblings, so we know where the new one needs
    // to be inserted
    rgNodeSib[cSibs].id = pFolder->idFolder;
    cSibs++;
    qsort(rgNodeSib, cSibs, sizeof(FLDRNODE), GroupCompare);

    // find out where we're sticking the new folder
    for (iSib = 0, pNode = rgNodeSib; iSib < cSibs; iSib++, pNode++)
    {
        if (pNode->id == pFolder->idFolder)
            break;
    }
    Assert(iSib < cSibs);

    if (iSib + 1 < cSibs)
        index = _GetFolderIndex(rgNodeSib[iSib + 1].id);
    else
        index = iEnd;

    MemFree(rgNodeSib);

    if (m_cnode == m_cnodeBuf)
    {
        cnode = m_cnodeBuf + CALLOCIDBUF;
        if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
            return(E_OUTOFMEMORY);

        m_cnodeBuf = cnode;
    }

    SetWindowRedraw(m_hwndList, FALSE);

    if (index < m_cnode)
        MoveMemory(&m_rgnode[index + 1], &m_rgnode[index], (m_cnode - index) * sizeof(FLDRNODE));

    m_rgnode[index].id = pFolder->idFolder;
    m_rgnode[index].indent = indent;
    m_rgnode[index].dwDownload = m_dwDownloadDef;
    m_cnode++;

    iEnd = index + 1;
    if (!!(pFolder->dwFlags & FOLDER_HASCHILDREN))
    {
        hr = _InsertChildren(pFolder->idFolder, indent + 1, &iEnd);
        // TODO: error handling
        Assert(SUCCEEDED(hr));
    }

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    while (index < iEnd)
    {
        lvi.iItem = index++;
        ListView_InsertItem(m_hwndList, &lvi);
    }

    if (fHide)
        m_pEmptyList->Hide();

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    return(S_OK);
}

HRESULT CAccountView::_InsertFolderNews(LPFOLDERINFO pFolder)
{
    DWORD cnode;
    HRESULT hr;
    LV_ITEM lvi;

    if (m_cnode == m_cnodeBuf)
    {
        cnode = m_cnodeBuf + CALLOCIDBUF;
        if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
            return(E_OUTOFMEMORY);

        m_cnodeBuf = cnode;
    }

    m_rgnode[m_cnode].id = pFolder->idFolder;
    m_rgnode[m_cnode].indent = 0;
    m_rgnode[m_cnode].dwDownload = m_dwDownloadDef;
    m_cnode++;

    qsort(m_rgnode, m_cnode, sizeof(FLDRNODE), GroupCompare);

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.iItem = _GetFolderIndex(pFolder->idFolder);
    Assert(lvi.iItem != -1);
    ListView_InsertItem(m_hwndList, &lvi);

    if (m_cnode == 1)
        m_pEmptyList->Hide();

    return(S_OK);
}

int CAccountView::_GetFolderIndex(FOLDERID id)
{
    int i;
    FLDRNODE *pnode;

    for (i = 0, pnode = m_rgnode; (DWORD)i < m_cnode; i++, pnode++)
    {
        if (id == pnode->id)
            break;
    }

    if ((DWORD)i == m_cnode)
        i = -1;

    return(i);
}

HRESULT CAccountView::_UpdateFolder(LPFOLDERINFO pFolder1, LPFOLDERINFO pFolder2)
{
    HRESULT hr;
    int iItem;

    // Visibility change (FOLDER_SUBSCRIBED or FOLDER_HIDDEN)
    if (ISFLAGSET(pFolder1->dwFlags, FOLDER_SUBSCRIBED) != ISFLAGSET(pFolder2->dwFlags, FOLDER_SUBSCRIBED) ||
        ISFLAGSET(pFolder1->dwFlags, FOLDER_HIDDEN) != ISFLAGSET(pFolder2->dwFlags, FOLDER_HIDDEN))
    {
        if (ISFLAGSET(pFolder2->dwFlags, FOLDER_SUBSCRIBED) && ISFLAGCLEAR(pFolder2->dwFlags, FOLDER_HIDDEN))
        {
            hr = _InsertFolder(pFolder2);
        }
        else
        {
            hr = _DeleteFolder(pFolder2);
        }

        return(hr);
    }

    // Moved or renamed
    if (pFolder1->idParent != pFolder2->idParent ||
        0 != lstrcmpi(pFolder1->pszName, pFolder2->pszName))
    {
        Assert(m_ftType != FOLDER_NEWS);

        hr = _DeleteFolder(pFolder1);

        hr = _InsertFolder(pFolder2);

        return(hr);
    }

    // State change
    if (pFolder1->cUnread != pFolder2->cUnread ||
        pFolder1->cMessages != pFolder2->cMessages ||
        (pFolder1->dwFlags & FOLDER_SYNCMASK) != (pFolder2->dwFlags & FOLDER_SYNCMASK) ||
        0 != lstrcmp(pFolder1->pszName, pFolder2->pszName) ||

        // news only
        (pFolder1->tyFolder == FOLDER_NEWS &&
        (pFolder1->dwServerCount != pFolder2->dwServerCount ||
        pFolder1->dwServerHigh != pFolder2->dwServerHigh ||
        pFolder1->dwServerLow != pFolder2->dwServerLow)))
    {
        iItem = _GetFolderIndex(pFolder1->idFolder);
        if (iItem != -1)
            ListView_RedrawItems(m_hwndList, iItem, iItem);
    }

    return(S_OK);
}

int CAccountView::_GetSubFolderCount(int index)
{
    DWORD indent;
    int indexT;

    Assert((DWORD)index < m_cnode);

    indent = m_rgnode[index].indent;

    index++;
    indexT = index;
    while ((DWORD)index < m_cnode)
    {
        if (m_rgnode[index].indent <= indent)
            break;
        index++;
    }

    return(index - indexT);
}

HRESULT CAccountView::_DeleteFolder(LPFOLDERINFO pFolder)
{
    HRESULT hr;
    int iItem, cSub;

    iItem = _GetFolderIndex(pFolder->idFolder);
    if (iItem == -1)
        return(S_OK);

    SetWindowRedraw(m_hwndList, FALSE);

    cSub = _GetSubFolderCount(iItem);

    if ((DWORD)(iItem + cSub) < (m_cnode - 1))
        MoveMemory(&m_rgnode[iItem], &m_rgnode[iItem + cSub + 1], (m_cnode - (iItem + cSub + 1)) * sizeof(FLDRNODE));
    m_cnode -= cSub + 1;

    while (cSub >= 0)
    {
        ListView_DeleteItem(m_hwndList, iItem + cSub);
        cSub--;
    }

    if (m_cnode == 0)
        m_pEmptyList->Show(m_hwndList, m_ftType == FOLDER_NEWS ? (LPSTR)idsEmptyNewsAcct : (LPSTR)idsEmptyMailAcct);

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    return(S_OK);
}

HRESULT CAccountView::_HandleAccountRename(LPFOLDERINFO pFolder)
{
    char sz[CCHMAX_STRINGRES];
    HDC hdc;
    SIZE size;
    HFONT hfontBold, hfontOld;

    Assert(m_pszMajor != NULL);
    Assert(pFolder != NULL);

    AthLoadString(idsSyncManager, sz, ARRAYSIZE(sz));
    wnsprintf(m_pszMajor, CCHMAX_STRINGRES, sz, pFolder->pszName);

    hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);

    hdc = GetDC(m_hwnd);

    hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

    GetTextExtentPoint32(hdc, m_pszMajor, lstrlen(m_pszMajor), &size);
    m_rcMajor.left = SUBSCRIBE_BORDER;
    m_rcMajor.top = SUBSCRIBE_BORDER;
    m_rcMajor.right = m_rcMajor.left + size.cx;
    m_rcMajor.bottom = m_rcMajor.top + size.cy;

    SelectObject(hdc, hfontOld);
    ReleaseDC(m_hwnd, hdc);

    InvalidateRect(m_hwnd, NULL, FALSE);
    UpdateWindow(m_hwnd);

    return(S_OK);
}

STDMETHODIMP CAccountView::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB)
{
    BOOL                fMatch;
    DWORD               i;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    FOLDERINFO          Server;
    ORDINALLIST         Ordinals;
    TRANSACTIONTYPE     tyTransaction;
    INDEXORDINAL        iIndex;
    HRESULT             hr;

    while (hTransaction)
    {
        hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals);
        if (FAILED(hr))
            break;

        if (Folder1.idFolder == m_idFolder)
        {
            if (TRANSACTION_UPDATE == tyTransaction &&
                0 != lstrcmp(Folder1.pszName, Folder2.pszName))
            {
                hr = _HandleAccountRename(&Folder2);
            }
        }
        else if (Folder1.tyFolder == m_ftType && 0 == (Folder1.dwFlags & FOLDER_SERVER))
        {
            fMatch = FALSE;

            if (m_ftType == FOLDER_LOCAL)
            {
                if (Folder1.tyFolder == FOLDER_LOCAL)
                    fMatch = TRUE;
            }
            else
            {
                hr = GetFolderServer(Folder1.idParent, &Server);
                if (SUCCEEDED(hr))
                {
                    fMatch = (Server.idFolder == m_idFolder);
                    g_pStore->FreeRecord(&Server);
                }
            }

            if (fMatch)
            {
                // Insert (new Folder notification)
                if (TRANSACTION_INSERT == tyTransaction)
                {
                    hr = _InsertFolder(&Folder1);
                }
                // Update
                else if (TRANSACTION_UPDATE == tyTransaction)
                {
                    hr = _UpdateFolder(&Folder1, &Folder2);
                }

                // Delete
                else if (TRANSACTION_DELETE == tyTransaction)
                {
                    hr = _DeleteFolder(&Folder1);
                }
            }
        }
    }

    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);

    return(S_OK);
}

HRESULT CAccountView::_ToggleDownload(int iItem)
{
    FLDRNODE *pnode;
    FOLDERINFO info;
    HRESULT hr;

    pnode = _NodeFromIndex(iItem);
    Assert(pnode != NULL);

    hr = g_pStore->GetFolderInfo(pnode->id, &info);
    if (SUCCEEDED(hr))
    {
        if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
        {
            if (!!(info.dwFlags & FOLDER_SYNCMASK))
            {
                pnode->dwDownload = (info.dwFlags & FOLDER_SYNCMASK);
                info.dwFlags &= ~FOLDER_SYNCMASK;
            }
            else
            {
                Assert(0 == (pnode->dwDownload & ~FOLDER_SYNCMASK));
                info.dwFlags |= pnode->dwDownload;
            }

            hr = g_pStore->UpdateRecord(&info);
        }

        g_pStore->FreeRecord(&info);
    }

    return(S_OK);
}

HRESULT CAccountView::_MarkForDownload(DWORD nCmdID)
{
    int iSel;
    FLDRFLAGS flag;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *pnode;

    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
            flag = FOLDER_DOWNLOADHEADERS;
            break;

        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
            flag = FOLDER_DOWNLOADNEW;
            break;

        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
            flag = FOLDER_DOWNLOADALL;
            break;

        case ID_UNMARK_RETRIEVE_FLD:
            flag = 0;
            break;

        default:
            Assert(FALSE);
            break;
    }

    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pnode = _NodeFromIndex(iSel);

        hr = g_pStore->GetFolderInfo(pnode->id, &info);
        if (SUCCEEDED(hr))
        {
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED) &&
                (info.dwFlags & FOLDER_SYNCMASK) != flag)
            {
                if (flag == 0)
                    pnode->dwDownload = (info.dwFlags & FOLDER_SYNCMASK);
                info.dwFlags &= ~FOLDER_SYNCMASK;
                if (flag != 0)
                    info.dwFlags |= flag;

                hr = g_pStore->UpdateRecord(&info);
            }

            g_pStore->FreeRecord(&info);
        }
    }

    return(S_OK);
}

HRESULT CAccountView::_Subscribe(BOOL fSubscribe)
{
    FOLDERID *pid;
    int iSel, cSel, cid;

    cSel = ListView_GetSelectedCount(m_hwndList);
    if (cSel > 0)
    {
        if (!MemAlloc((void **)&pid, cSel * sizeof(FOLDERID)))
            return(E_OUTOFMEMORY);

        cid = 0;
        iSel = -1;
        while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
        {
            Assert(cid < cSel);
            pid[cid] = _IdFromIndex(iSel);
            cid++;
        }

        MenuUtil_OnSubscribeGroups(m_hwndOwner, pid, cid, fSubscribe);

        MemFree(pid);
    }

    return(S_OK);
}

HRESULT CAccountView::_MarkAllRead()
{
    int iSel;
    IMessageFolder *pFolder;
    ADJUSTFLAGS flags;
    FOLDERID idFolder;
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(m_hwndOwner, MAKEINTRESOURCE(idsSettingMessageFlags), FALSE);
    if (SUCCEEDED(hr))
    {
        flags.dwAdd = ARF_READ;
        flags.dwRemove = 0;

        iSel = -1;
        while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
        {
            idFolder = _IdFromIndex(iSel);

            if (SUCCEEDED(g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder)))
            {
                hr = pFolder->SetMessageFlags(NULL, &flags, NULL, (IStoreCallback *)pCB);
                if (hr == E_PENDING)
                {
                    hr = pCB->Block();

                    pCB->Reset();
                }

                pFolder->Release();
            }

            if (FAILED(hr))
                break;
        }

        pCB->Close();
    }

    pCB->Release();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\bmapi.cpp ===
#include <pch.hxx>
#include "demand.h" 
#include <bmapi.h>




#define FBadCh(c)		((c) - ' ' > 64)
#define DEC(c)			((BYTE) (((c) - ' ') & 0x3f))

/* uuencode/decode a binary string */
#define ENC(c)			((BYTE) ((c) ? ((c) & 0x3f) + ' ': '`'))

int rgLeft[3] = { 0, 2, 3 };




typedef USHORT		CCH;




STDAPI_(BOOL) FDecodeID(LPTSTR sz, LPBYTE pb, ULONG *pcb);
STDAPI_(int) CchEncodedLine(int cb);
STDAPI_(ULONG) CbOfEncoded(LPTSTR sz);
ERR ErrSzToBinaryEID( LPSTR lpstrEID, ULONG * lpcbEID, LPVOID * lppvEID );
LPSTR FAR PASCAL LpstrFromBstrA( BSTR bstrSrc, LPSTR lpstrDest );
LPSTR FAR PASCAL LpstrFromBstr( BSTR bstrSrc, LPSTR lpstrDest );
int FAR PASCAL FBMAPIFreeStruct (LPVOID lpMapiIn, ULONG uCount, USHORT usFlag);
ULONG PASCAL VB2Mapi( LPVOID lpVBIn, LPVOID lpMapiIn, ULONG uCount, USHORT usFlag );
LPMAPI_MESSAGE FAR PASCAL vbmsg2mapimsg( LPVB_MESSAGE lpVBMessage, LPSAFEARRAY lpsaVBRecips, LPSAFEARRAY lpsaVBFiles, ULONG * pulErr );
ERR FAR PASCAL ErrLpstrToBstrA( LPSTR cstr, BSTR * lpBstr );
ERR FAR PASCAL ErrLpstrToBstr( LPSTR cstr, BSTR * lpBstr );
STDAPI_(void) EncodeID(LPBYTE pb, ULONG cb, LPTSTR sz);
STDAPI_(ULONG) CchOfEncoding(ULONG cbBinary);
ERR ErrBinaryToSzEID( LPVOID lpvEID, ULONG cbEID, LPSTR * lppstrEID );
ULONG PASCAL Mapi2VB (LPVOID lpMapiIn, LPVOID lpVBIn, ULONG uCount, USHORT usFlag);















/*---------------------------------------------------------------------
 *
 *                 Copyright Microsoft Corporation, 1992
 *    _______________________________________________________________
 *
 *    PROGRAM: BMAPI.CPP
 *
 *    PURPOSE: Contains library routines VB MAPI wrappers
 *
 *    FUNCTIONS:
 *                BMAPISendMail
 *                BMAPIFindNext
 *                BMAPIReadMail
 *                BMAPIGetReadMail
 *                BMAPISaveMail
 *                BMAPIAddress
 *                BMAPIGetAddress
 *                BMAPIResolveName
 *                BMAPIDetails
 *
 *    MISCELLANEOUS:
 *
 *    -  All BMAPI procedures basically follow the same structure as
 *       follows;
 *
 *              BMAPI_ENTRY BMAPIRoutine (...)
 *              {
 *                  Allocate C Structures
 *                  Translate VB structures to C structures
 *                  Call MAPI Procedure
 *                  Translate C structures to VB Structures
 *                  DeAllocate C Structures
 *                  Return
 *              }
 *
 *
 *    REVISION HISTORY:
 *     
 *    - Last modified by v-snatar
 *
 *
 *      _____________________________________________________________
 *
 *                 Copyright Microsoft Corporation, 1992-1997
 *
 *----------------------------------------------------------------------*/

//---------------------------------------------------------------------------
// Name:		BMAPISendMail()
//
// Description:
//				32 bit support for VB MAPISendMail().
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPISendMail (LHANDLE 			hSession,
                           ULONG_PTR		ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY * 	lppsaRecips,
                           LPSAFEARRAY * 	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved)
{
    ULONG                   ulRet = SUCCESS_SUCCESS;
    LPMAPI_MESSAGE          lpMail = NULL;


    //  Translate VB data into C data.

    if ((lpMail = vbmsg2mapimsg( lpM, *lppsaRecips, *lppsaFiles, &ulRet )) == NULL)
        return ulRet;
    

    // Call MAPI Procedure

    ulRet = MAPISendMail( hSession,      // session
                         ulUIParam,     // UIParam
                         lpMail,        // Mail
                         flFlags,       // Flags
                         ulReserved );  // Reserved

    // Free up data allocated by call to vbmsg2mapimsg

    FBMAPIFreeStruct(lpMail, 1, MESSAGE);
    return ulRet;
   }

//---------------------------------------------------------------------------
// Name:		BMAPIFindNext()
//
// Description:
//				Implements FindNext MAPI API.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIFindNext( LHANDLE 		hSession,    	// Session
                           ULONG_PTR	ulUIParam,     	// UIParam
                           BSTR *		lpbstrType,     // MessageType
                           BSTR *		lpbstrSeed,     // Seed message Id
                           ULONG 		flFlags,       	// Flags
                           ULONG 		ulReserved,    	// Reserved
                           BSTR * 		lpbstrId)       // Message Id (in/out)
{
    ULONG           ulRet;
    LPSTR           lpID = NULL;
    LPSTR           lpSeed;
    LPSTR           lpTypeArg;


    // Translate VB strings into C strings.  We'll deallocate
    // the strings before we return.

	// Always allocate the MessageID string.  This way we can redimension
	// it to fit the returned size.  We'll never use the caller's buffer.
	// It turns out the VBSetHlstr call (from ErrLpstrToHlstr) will reassign
	// the string for us.

    if (!MemAlloc((LPVOID*)&lpID, 513))
        return MAPI_E_INSUFFICIENT_MEMORY;


    lpSeed = LpstrFromBstrA( *lpbstrSeed, NULL);
    lpTypeArg = LpstrFromBstrA( *lpbstrType, NULL);

    // Call MAPI Procedure

	ulRet = MAPIFindNext( hSession,      // Session
                         ulUIParam,     // UIParam
                         lpTypeArg,     // Message Type
                         lpSeed,        // Seed Message Id
                         flFlags,       // Flags,
                         ulReserved,    // Reserved
                         lpID );        // Message ID

    // Translate Message ID into VB string

    if ( ulRet == SUCCESS_SUCCESS )
        ErrLpstrToBstrA( lpID, lpbstrId);


    // Free up C strings allocated by call to LpstrFromHlstr

    SafeMemFree( lpID );
    SafeMemFree( lpSeed );
    SafeMemFree( lpTypeArg );

    return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIReadMail()
//
// Description:
//
// 				Implements MAPIReadMail VB API.  The memory allocated by
// 				MAPIReadMail is NOT deallocated (with MAPIFreeBuffer) until
//				the	caller calls BMAPIGetReadMail.  The recipient and file
//				count is returned so that the caller can Re-dimension buffers
//				before calling BMAPI GetReadMail.  A long pointer to the
//				ReadMail data is also returned since it is required in the
//				BAMPIGetReadMail call.

// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIReadMail( PULONG_PTR	lpulMessage, 	// pointer to output data (out)
                           LPULONG 		nRecips,     	// number of recipients (out)
                           LPULONG 		nFiles,      	// number of file attachments (out)
                           LHANDLE 		hSession,    	// Session
                           ULONG_PTR	ulUIParam,     	// UIParam
                           BSTR *		lpbstrID,       // Message Id
                           ULONG 		flFlags,       	// Flags
                           ULONG 		ulReserved )    // Reserved
{
    LPSTR               lpID;
    ULONG               ulRet;
    LPMAPI_MESSAGE      lpMail = NULL;


    // Translate VB String to C String

    lpID = LpstrFromBstrA( *lpbstrID, NULL );

    // Read the message, lpMail is set by MAPI to point
    // to the memory allocated by MAPI.

    ulRet = MAPIReadMail( hSession,          	// Session
                         ulUIParam,         	// UIParam
                         lpID,              	// Message Id
                         flFlags,           	// Flags
                         ulReserved,        	// Reserved
                         &lpMail ); 	// Pointer to MAPI Data (returned)

    // Check for read error return code

    if ( ulRet != SUCCESS_SUCCESS )
    {
          // Clean up.  Set return message to zero

          *lpulMessage = 0L;
          SafeMemFree( lpID );
          return ulRet;
    }

    // Pull out the recipient and file array re-dim info

    *nFiles = lpMail->nFileCount;
    *nRecips = lpMail->nRecipCount;
    *lpulMessage = (ULONG_PTR) (LPVOID) lpMail;

    SafeMemFree( lpID );
	return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIGetReadMail()
//
// Description:
//
// 				Copies data stored by MAPI ReadMail (see BMAPIReadMail)
// 				into a VB Buffer passed by the caller.  It is up to the
//				caller to make sure the buffer passed is large enough to
//				accomodate the data.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIGetReadMail( ULONG 		lpMessage,	 // Pointer to MAPI Mail
                              LPVB_MESSAGE	lpvbMessage, // Pointer to VB Message Buffer (out)
                              LPSAFEARRAY * lppsaRecips, // Pointer to VB Recipient Buffer (out)
                              LPSAFEARRAY * lppsaFiles,  // Pointer to VB File attachment Buffer (out)
                              LPVB_RECIPIENT lpvbOrig)   // Pointer to VB Originator Buffer (out)
{
    ULONG 			ulRet = SUCCESS_SUCCESS;
    ERR 			errVBrc;
    LPMAPI_MESSAGE 	lpMail;

    lpMail = (LPMAPI_MESSAGE)((ULONG_PTR)lpMessage);
	if ( !lpMail )
		return MAPI_E_INSUFFICIENT_MEMORY;

    // copy Attachment info to callers VB Buffer

    if (ulRet = Mapi2VB( lpMail->lpFiles, *lppsaFiles, lpMail->nFileCount, FILE ))
    {
		MAPIFreeBuffer(lpMail);
        return ulRet;
    }

    // copy Recipient info to callers VB Buffer

    if ( ulRet = Mapi2VB( lpMail->lpRecips, *lppsaRecips, lpMail->nRecipCount, RECIPIENT | USESAFEARRAY ) )
    {
		MAPIFreeBuffer( lpMail );
        return ulRet;
    }

    // Copy MAPI Message to callers VB Buffer

    errVBrc = 0;

	if ( lpMail->lpOriginator )
	{
	    lpvbOrig->ulReserved    = lpMail->lpOriginator->ulReserved;
	    lpvbOrig->ulRecipClass  = MAPI_ORIG;

	    if ( lpMail->lpOriginator->lpszName )
	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpOriginator->lpszName, &lpvbOrig->bstrName ));

	    if ( lpMail->lpOriginator->lpszAddress )
	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpOriginator->lpszAddress, &lpvbOrig->bstrAddress ));

	    if (lpMail->lpOriginator->ulEIDSize)
	    {
			LPSTR	lpStrEID;

			// Hexize recipient EID and convert to OLE BSTR

			if ( ErrBinaryToSzEID( lpMail->lpOriginator->lpEntryID,
					lpMail->lpOriginator->ulEIDSize,  &lpStrEID ) )
			{
				errVBrc = TRUE;
				goto exit;
			}

			// To figure out size first convert to UNICODE

			errVBrc = ErrLpstrToBstr( lpStrEID, &lpvbOrig->bstrEID );
			if ( errVBrc )
			{
				goto exit_orig;
			}

        	lpvbOrig->ulEIDSize = SysStringByteLen( lpvbOrig->bstrEID )
        			+ sizeof(OLECHAR);

			SysFreeString( lpvbOrig->bstrEID );

	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpStrEID, &lpvbOrig->bstrEID ));

exit_orig:

			SafeMemFree( lpStrEID );
	    }
	}

    lpvbMessage->flFlags    = lpMail->flFlags;
    lpvbMessage->ulReserved = lpMail->ulReserved;
    lpvbMessage->nRecipCount = lpMail->nRecipCount;
    lpvbMessage->nFileCount = lpMail->nFileCount;

    if (lpMail->lpszSubject)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszSubject, &lpvbMessage->bstrSubject));

    if (lpMail->lpszNoteText)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszNoteText, &lpvbMessage->bstrNoteText));

    if (lpMail->lpszMessageType)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszMessageType, &lpvbMessage->bstrMessageType));

    if (lpMail->lpszDateReceived)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszDateReceived, &lpvbMessage->bstrDate));

exit:

	MAPIFreeBuffer( lpMail );

	if ( errVBrc )
		ulRet = MAPI_E_FAILURE;

    return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPISaveMail()
//
// Description:
//				Implements MAPISaveMail API.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPISaveMail( LHANDLE 			hSession,   	// Session
                           ULONG_PTR		ulUIParam,  	// UIParam
                           LPVB_MESSAGE 	lpM,        	// Pointer to VB Message Buffer
                           LPSAFEARRAY *	lppsaRecips,   	// Pointer to VB Recipient Buffer
                           LPSAFEARRAY *	lppsaFiles,    	// Pointer to VB File Attacment Buffer
                           ULONG 			flFlags,    	// Flags
                           ULONG 			ulReserved, 	// Reserved
                           BSTR * 			lpbstrID)   	// Message ID
{
    LPSTR 			lpID;
    ULONG 			ulRet= SUCCESS_SUCCESS;
    LPMAPI_MESSAGE 	lpMail;


    // Translate VB data to MAPI data

    lpID = LpstrFromBstrA( *lpbstrID, NULL );

	// If we allocate Message ID then we can set the flag.
	// otherwise for backward compatability assume the callers buffer size.

	if ( lpID == NULL )
	{
	    if (!MemAlloc((LPVOID*)&lpID,  513))
            return MAPI_E_INSUFFICIENT_MEMORY;
	}

    if ( (lpMail = vbmsg2mapimsg( lpM, *lppsaRecips, *lppsaFiles, &ulRet )) == NULL )
	{
        SafeMemFree( lpID );
        return ulRet;
    }

    ulRet = MAPISaveMail( hSession,
                         ulUIParam,
                         lpMail,
						 flFlags,
                         ulReserved,
                         lpID );

	if ( ulRet )
		goto exit;

    if ( ErrLpstrToBstrA( lpID, lpbstrID ) )
		ulRet = MAPI_E_INSUFFICIENT_MEMORY;

exit:
    SafeMemFree( lpID );
    FBMAPIFreeStruct( lpMail, 1, MESSAGE );


	return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIAddress()
//
// Description:
//
// 				Purpose: Allows Visual Basic to call MAPIAddress.  The
//				Recipient data is stored in a global memory block.  To
//				retrieve the data the caller must call BMAPIGetAddress.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIAddress( PULONG_PTR		lpulRecip,       // Pointer to New Recipient Buffer (out)
                          LHANDLE 			hSession,        // Session
                          ULONG_PTR			ulUIParam,       // UIParam
                          BSTR *			lpbstrCaption,   // Caption string
                          ULONG 			ulEditFields,    // Number of Edit Controls
                          BSTR * 			lpbstrLabel,     // Label string
                          LPULONG 			lpulRecipients,  // Pointer to number of Recipients (in/out)
                          LPSAFEARRAY *		lppsaRecip, 	 // Pointer to Initial Recipients VB_RECIPIENT
                          ULONG 			ulFlags,         // Flags
                          ULONG 			ulReserved )     // Reserve
{
    LPSTR 				lpLabel = NULL;
    LPSTR 				lpCaption = NULL;
    ULONG 				ulRet;
    ULONG 				nRecipients = 0;
    LPMAPI_RECIPIENT 	lpMapi = NULL;
    LPMAPI_RECIPIENT 	lpNewRecipients	= NULL;

    // Convert VB Strings to C strings

    lpLabel   = LpstrFromBstrA( *lpbstrLabel, NULL );
    lpCaption = LpstrFromBstrA( *lpbstrCaption, NULL );

    // Allocate memory and translate VB_RECIPIENTS to MAPI_RECIPIENTS.

	if ( *lpulRecipients )
	{
	    if (!MemAlloc((LPVOID*)&lpMapi, (*lpulRecipients	* sizeof (MAPI_RECIPIENT))))
            return MAPI_E_INSUFFICIENT_MEMORY;
	}

    if ( ulRet = VB2Mapi( (LPVOID)*lppsaRecip, (LPVOID)lpMapi, *lpulRecipients, RECIPIENT | USESAFEARRAY ) )
    {
        SafeMemFree( lpLabel );
        SafeMemFree( lpCaption );
        FBMAPIFreeStruct( lpMapi, *lpulRecipients, RECIPIENT );
        return ulRet;
    }

    // Call the MAPIAddress function

    ulRet = MAPIAddress(	hSession,           	// Session
                        ulUIParam,          	// UIParam
                        lpCaption,          	// Caption
                        ulEditFields,       	// Number of edit fields
                        lpLabel,            	// Label
                        *lpulRecipients,    	// Number of Recipients
                        lpMapi,             	// Pointer to recipients
                        ulFlags,            	// Flags
                        ulReserved,         	// Reserved
                        (LPULONG) &nRecipients, // Address for new recipient count
                        (lpMapiRecipDesc far *)&lpNewRecipients);  // Address of new recipient data

    // Free up MAPI structures created in this procedure

    SafeMemFree( lpLabel );
    SafeMemFree( lpCaption );
    FBMAPIFreeStruct( lpMapi, *lpulRecipients, RECIPIENT );

    // Set the returned parameters and return

    if ( ulRet == SUCCESS_SUCCESS )
    {
        *lpulRecipients = nRecipients;
        *lpulRecip = (ULONG_PTR) (LPVOID) lpNewRecipients;
    }

	return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIGetAddress()
//
// Description:
//				Converts a MapiRecipDesc array into an OLE 2.0 SAFEARRAY.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIGetAddress (ULONG 			ulRecipientData, // Pointer to recipient data
                             ULONG 			cRecipients,     // Number of recipients
							 LPSAFEARRAY *	lppsaRecips )	 // VB recipient array
{
    ULONG				ulRet = SUCCESS_SUCCESS;
    LPMAPI_RECIPIENT 	lpData = NULL;

    if (cRecipients == 0)
	{
		MAPIFreeBuffer( (LPVOID)((ULONG_PTR)ulRecipientData) );
        return SUCCESS_SUCCESS;
	}

    lpData = (LPMAPI_RECIPIENT)((ULONG_PTR)ulRecipientData);

    // Translate MAPI Address data to VB buffer

	ulRet = Mapi2VB( lpData, *lppsaRecips, cRecipients, RECIPIENT | USESAFEARRAY );

	// Free up MAPI recipient data since it got copied over.

	MAPIFreeBuffer( lpData );
	return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIDetails()
//
// Description:
//				Allows VB to call MAPIDetails procedure.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIDetails (LHANDLE 			hSession,   // Session
                          ULONG_PTR			ulUIParam, 	// UIParam
                          LPVB_RECIPIENT	lpVB,  		// Pointer to VB recipient stucture
                          ULONG 			ulFlags,    // Flags
                          ULONG 			ulReserved) // Reserved

{
    ULONG            ulRet;
    LPMAPI_RECIPIENT lpMapi	= NULL;


    // Translate VB_RECIPIENTS to MAPI_RECIPIENTS.

    if (!MemAlloc((LPVOID*)&lpMapi,sizeof (MAPI_RECIPIENT)))
        return MAPI_E_INSUFFICIENT_MEMORY;

    if ( ulRet = VB2Mapi( lpVB, lpMapi, 1, RECIPIENT ) )
    {
        FBMAPIFreeStruct( lpMapi, 1, RECIPIENT );
        return ulRet;
    }

    // Call the Simple MAPI function

    ulRet = MAPIDetails( hSession,     // Session
                        ulUIParam,    // UIParam
                        lpMapi,       // Pointer to MAPI Recipient structure
                        ulFlags,      // Flags
                        ulReserved ); // Reserved

    FBMAPIFreeStruct( lpMapi, 1L, RECIPIENT );
    return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIResolveName
//
// Description:
//				Implements VB MAPIResolveName
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIResolveName (LHANDLE 			hSession,     // Session
                              ULONG_PTR			ulUIParam,    // UIParam
                              BSTR 				bstrMapiName, // Name to be resolved
                              ULONG 			ulFlags,      // Flags
                              ULONG 			ulReserved,   // Reserved
                              LPVB_RECIPIENT	lpVB)  		  // Pointer to VB recipient structure (out)

{
    LPMAPI_RECIPIENT	lpMapi = NULL;
    ULONG 				ulRet;
	LPSTR				lpszMapiName;


    lpszMapiName = LpstrFromBstrA( bstrMapiName, NULL );

    // Call the MAPIResolveName function

    ulRet = MAPIResolveName( hSession,   					// Session
                            ulUIParam,  					// UIParam
                            lpszMapiName, 					// Pointer to resolve name
                            ulFlags,    					// Flags
                            ulReserved, 					// Reserved
                           (LPPMAPI_RECIPIENT) &lpMapi ); 	// Pointer to Recipient (returned)

    if (ulRet != SUCCESS_SUCCESS)
        return ulRet;


	// Translate MAPI data to VB data

	ulRet = Mapi2VB( lpMapi, lpVB, 1, RECIPIENT );

	MAPIFreeBuffer( lpMapi );
	return ulRet;
}




// Helper Functions

//---------------------------------------------------------------------------
// Name:		vbmsg2mapimsg()
//
// Description:
// 				Translates VB Message structure to MAPI Message structure
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
LPMAPI_MESSAGE FAR PASCAL vbmsg2mapimsg( LPVB_MESSAGE lpVBMessage, LPSAFEARRAY lpsaVBRecips,
		LPSAFEARRAY lpsaVBFiles, ULONG * pulErr )

{
    LPMAPI_FILE lpMapiFile=NULL;
    LPMAPI_MESSAGE lpMapiMessage=NULL;
    LPMAPI_RECIPIENT lpMapiRecipient=NULL;

    if (lpVBMessage == (LPVB_MESSAGE) NULL)
    {
    	*pulErr = MAPI_E_FAILURE;
        return NULL;
    }

    // Allocate MAPI Message, Recipient and File structures
    // NOTE: Don't move the following lines of code without
    // making sure you de-allocate memory properly if the
    // calls fail.

	if (!MemAlloc((LPVOID*)&lpMapiMessage,sizeof(MapiMessage)))
	{
		*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
        return NULL;
	}

    if (lpVBMessage->nFileCount > 0)
    {
        if (!MemAlloc((LPVOID*)&lpMapiFile, sizeof(MAPI_FILE)*lpVBMessage->nFileCount))
        {
            FBMAPIFreeStruct( (LPVOID*)&lpMapiMessage, 1, MESSAGE );
			*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
            return NULL;
        }
    }

    if (lpVBMessage->nRecipCount > 0)
    {
        if (!MemAlloc((LPVOID*)&lpMapiRecipient, sizeof(MAPI_RECIPIENT)*lpVBMessage->nRecipCount))
        {
            FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
            FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
			*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
            return NULL;
        }
    }

    // Translate structures from VB to MAPI

    if ( *pulErr = VB2Mapi( lpsaVBFiles, lpMapiFile, lpVBMessage->nFileCount, FILE | USESAFEARRAY ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    if ( *pulErr = VB2Mapi( lpsaVBRecips, lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT | USESAFEARRAY ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    if ( *pulErr = VB2Mapi( lpVBMessage, lpMapiMessage, 1, MESSAGE ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    // Chain File and Recipient structures to Message structure

    lpMapiMessage->lpFiles = lpMapiFile;
    lpMapiMessage->lpRecips = lpMapiRecipient;

    return lpMapiMessage;
}


//---------------------------------------------------------------------------
// Name:		VB2Mapi()
//
// Description:
//				Converts VB structures to MAPI structures.  Arrays from
//				VB 4.0 arrive as OLE SAFEARRAYs.
//
// Parameters:
// Returns:
//				Simple MAPI error code
//
// Effects:
// Notes:
//				originally FALSE for failure, TRUE for success.
// Revision:
//---------------------------------------------------------------------------
ULONG PASCAL VB2Mapi( LPVOID lpVBIn, LPVOID lpMapiIn, ULONG uCount, USHORT usFlag )
{
    ULONG 				u;
	HRESULT				hr			= 0;
	ULONG				ulErr		= SUCCESS_SUCCESS;
	ERR					Err			= FALSE;
    LPVB_RECIPIENT 		lpVBR;
    LPMAPI_RECIPIENT 	lpMapiR;
    LPVB_MESSAGE 		lpVBM;
    LPMAPI_MESSAGE 		lpMapiM;
    LPVB_FILE 			lpVBF;
    LPMAPI_FILE 		lpMapiF;
	LPSAFEARRAY			lpsa		= NULL;

    if (lpVBIn == (LPVOID)NULL)
    {
        lpMapiIn = NULL;
        return SUCCESS_SUCCESS;
    }

    if (uCount <= 0)
    {
        lpMapiIn = NULL;
        return SUCCESS_SUCCESS;
    }

    if ( lpMapiIn == (LPVOID)NULL )
        return MAPI_E_FAILURE;

    switch ( usFlag & ~(USESAFEARRAY) )
    {
        case RECIPIENT:
			if ( usFlag & USESAFEARRAY )
			{
				lpsa = (LPSAFEARRAY)lpVBIn;
				hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBR );
				if (hr)
				{
					ulErr = MAPI_E_FAILURE;
					goto exit;
				}

				if (!lpVBR || lpsa->rgsabound[0].cElements < uCount)
				{
					(void)SafeArrayUnaccessData( lpsa );
					ulErr = MAPI_E_INVALID_RECIPS;
					goto exit;
				}
			}
			else
			{
				lpVBR = (LPVB_RECIPIENT)lpVBIn;
			}

            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiR++, lpVBR++ )
            {
                lpMapiR->ulReserved   = lpVBR->ulReserved;
                lpMapiR->ulRecipClass = lpVBR->ulRecipClass;

				if ( usFlag & USESAFEARRAY )
				{
	                lpMapiR->lpszName     = LpstrFromBstr( lpVBR->bstrName, NULL );
	                lpMapiR->lpszAddress  = LpstrFromBstr( lpVBR->bstrAddress, NULL );
				}
				else
				{
	                lpMapiR->lpszName     = LpstrFromBstrA( lpVBR->bstrName, NULL );
	                lpMapiR->lpszAddress  = LpstrFromBstrA( lpVBR->bstrAddress, NULL );
				}

                if (lpVBR->ulEIDSize > 0L)
                {
					LPSTR	lpStrT;

					// Convert EID string from OLE Bstr...

                    if ( usFlag & USESAFEARRAY )
                    {
						if ( IsBadReadPtr( lpVBR->bstrEID, lpVBR->ulEIDSize ) )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

                    	lpStrT = LpstrFromBstr( lpVBR->bstrEID, NULL );
                    }
					else
					{
						// VB 4.0 took care of translating Wide Char to Multibyte.

						// ulEIDSize is still based on UNICODE byte size.  Take
						// smallest approximation.

						if ( IsBadReadPtr( lpVBR->bstrEID, lpVBR->ulEIDSize / 2 ) )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

                    	lpStrT = LpstrFromBstrA( lpVBR->bstrEID, NULL );
					}

					// and UnHexize.

					if ( lpStrT )
					{
						Err = ErrSzToBinaryEID( lpStrT, &lpMapiR->ulEIDSize,
								&lpMapiR->lpEntryID );

						SafeMemFree(lpStrT );

						if ( Err )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

					}
                }
                else
                    lpMapiR->lpEntryID = (LPVOID) NULL;
            }

			if ( usFlag & USESAFEARRAY )
				(void)SafeArrayUnaccessData( lpsa );

            break;

        case FILE:
			lpsa = (LPSAFEARRAY)lpVBIn;
			hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBF );
			if ( hr )
			{
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

			if ( !lpVBF || lpsa->rgsabound[0].cElements < uCount )
			{
				(void)SafeArrayUnaccessData( lpsa );
                ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
				goto exit;
			}

            lpMapiF = (LPMAPI_FILE)lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiF++, lpVBF++)
            {
                lpMapiF->ulReserved 	= lpVBF->ulReserved;
                lpMapiF->flFlags 		= lpVBF->flFlags;
                lpMapiF->nPosition 		= lpVBF->nPosition;
                lpMapiF->lpszPathName	= LpstrFromBstr( lpVBF->bstrPathName, NULL );
                lpMapiF->lpszFileName 	= LpstrFromBstr( lpVBF->bstrFileName, NULL );
                lpMapiF->lpFileType 	= LpstrFromBstr( lpVBF->bstrFileType, NULL);
            }

			(void)SafeArrayUnaccessData( lpsa );

            break;

        case MESSAGE:
            lpVBM = (LPVB_MESSAGE) lpVBIn;
            lpMapiM = (LPMAPI_MESSAGE) lpMapiIn;

            lpMapiM->ulReserved         = lpVBM->ulReserved;
            lpMapiM->flFlags            = lpVBM->flFlags;
            lpMapiM->nRecipCount        = lpVBM->nRecipCount;
            lpMapiM->lpOriginator       = NULL;
            lpMapiM->nFileCount         = lpVBM->nFileCount;
            lpMapiM->lpRecips           = NULL;
            lpMapiM->lpFiles            = NULL;

			// errors are ignored

            lpMapiM->lpszSubject        = LpstrFromBstrA( lpVBM->bstrSubject, NULL );
            lpMapiM->lpszNoteText       = LpstrFromBstrA( lpVBM->bstrNoteText, NULL );
            lpMapiM->lpszConversationID = LpstrFromBstrA( lpVBM->bstrConversationID, NULL );
            lpMapiM->lpszDateReceived   = LpstrFromBstrA( lpVBM->bstrDate, NULL );
            lpMapiM->lpszMessageType    = LpstrFromBstrA( lpVBM->bstrMessageType, NULL );

            break;

        default:
            ulErr = MAPI_E_FAILURE;
			goto exit;
    }

exit:

	return ulErr;
}

//---------------------------------------------------------------------------
// Name:		Mapi2VB
//
// Description:
//				Converts MAPI RECIPIENT, FILE, or MESSAGE structures to VB
//				Recipients and Files are handled as OLE SAFEARRAYs.
//
// Parameters:
// Returns:
//				Simple Mapi error code
//
// Effects:
// Notes:
//				originally FALSE for failure, TRUE for success.
// Revision:
//---------------------------------------------------------------------------
ULONG PASCAL Mapi2VB (LPVOID lpMapiIn, LPVOID lpVBIn, ULONG uCount, USHORT usFlag)
{
	HRESULT				hr = 0;
	ERR					Err	= FALSE;
	ULONG				ulErr = SUCCESS_SUCCESS;
    ULONG 				u;
    LPVB_MESSAGE 		lpVBM;
    LPMAPI_MESSAGE 		lpMapiM;
    LPVB_RECIPIENT 		lpVBR;
    LPMAPI_RECIPIENT 	lpMapiR;
    LPVB_FILE 			lpVBF;
    LPMAPI_FILE 		lpMapiF;
	LPSAFEARRAY			lpsa		= NULL;

    // If lpVBIn is NULL, this is a bad thing

    if (lpVBIn == (LPVOID) NULL)
        return MAPI_E_FAILURE;

    // if lpMapiIn is NULL then set
    // lpVBIn to NULL and return success

    if (lpMapiIn == NULL)
    {
        lpVBIn = NULL;
        return SUCCESS_SUCCESS;
    }

    switch ( usFlag & ~(USESAFEARRAY) )
    {
        case RECIPIENT:
			if ( usFlag & USESAFEARRAY )
			{
				lpsa = (LPSAFEARRAY)lpVBIn;
				hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBR );
				if (hr)
				{
					ulErr = MAPI_E_FAILURE;
					goto exit;
				}

				if ( !lpVBR || lpsa->rgsabound[0].cElements < uCount )
				{
					(void)SafeArrayUnaccessData(lpsa);
					ulErr = MAPI_E_INVALID_RECIPS;
					goto exit;
				}

			}
			else
			{
				lpVBR = (LPVB_RECIPIENT)lpVBIn;
			}

            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiR++, lpVBR++)
            {
                lpVBR->ulReserved    = lpMapiR->ulReserved;
                lpVBR->ulRecipClass  = lpMapiR->ulRecipClass;

				if (usFlag & USESAFEARRAY)
				{
	                if ( ErrLpstrToBstr( lpMapiR->lpszName, &lpVBR->bstrName ) )
					{
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
					}

	                if (Err = ErrLpstrToBstr( lpMapiR->lpszAddress, &lpVBR->bstrAddress ) )
					{
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
					}
				}
				else
				{
	                if ( ErrLpstrToBstrA( lpMapiR->lpszName, &lpVBR->bstrName ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }


	                if ( ErrLpstrToBstrA( lpMapiR->lpszAddress, &lpVBR->bstrAddress ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }
				}

                if ( lpMapiR->ulEIDSize > 0L)
                {
					LPSTR	lpStrEID;

					// Convert Recip EID to a hexized string

					if ( ErrBinaryToSzEID( lpMapiR->lpEntryID, lpMapiR->ulEIDSize, &lpStrEID ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }

					// Convert to a BSTR
					// and figure out the size

                    if ( usFlag & USESAFEARRAY )
                    {
                    	Err = ErrLpstrToBstr( lpStrEID, &lpVBR->bstrEID );
						SafeMemFree( lpStrEID );

						if (Err)
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}


	                	lpVBR->ulEIDSize = SysStringByteLen( lpVBR->bstrEID )
	                			+ sizeof(OLECHAR);
                    }
					else
					{
						// To figure out size first convert to UNICODE

						if ( ErrLpstrToBstr( lpStrEID, &lpVBR->bstrEID ) )
						{
							SafeMemFree( lpStrEID );
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

	                	lpVBR->ulEIDSize = SysStringByteLen( lpVBR->bstrEID )
	                			+ sizeof(OLECHAR);

						SysFreeString( lpVBR->bstrEID );

                    	Err = ErrLpstrToBstrA( lpStrEID, &lpVBR->bstrEID );
						SafeMemFree( lpStrEID );
						if ( Err )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}
					}
                }
            }

			if ( usFlag & USESAFEARRAY )
				(void)SafeArrayUnaccessData( lpsa );

            break;

        case FILE:
			lpsa = (LPSAFEARRAY)lpVBIn;
			hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBF );
			if ( hr )
			{
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

			if ( !lpVBF || lpsa->rgsabound[0].cElements < uCount )
			{
				(void)SafeArrayUnaccessData( lpsa );
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

            lpMapiF = (LPMAPI_FILE) lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiF++, lpVBF++)
            {
                lpVBF->ulReserved = lpMapiF->ulReserved;
				lpVBF->flFlags    = lpMapiF->flFlags;
                lpVBF->nPosition  = lpMapiF->nPosition;

                if ( ErrLpstrToBstr( lpMapiF->lpszPathName, &lpVBF->bstrPathName ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }

                if ( ErrLpstrToBstr( lpMapiF->lpszFileName, &lpVBF->bstrFileName ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }

                // this is something to keep VBAPI from faulting

                if ( ErrLpstrToBstr( (LPSTR) "", &lpVBF->bstrFileType ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }
            }

			(void)SafeArrayUnaccessData( lpsa );

            break;

        case MESSAGE:
            lpVBM = (LPVB_MESSAGE)lpVBIn;
            lpMapiM = (LPMAPI_MESSAGE)lpMapiIn;

            lpVBM->ulReserved   = lpMapiM->ulReserved;
            lpVBM->flFlags      = lpMapiM->flFlags;
            lpVBM->nRecipCount  = lpMapiM->nRecipCount;
            lpVBM->nFileCount   = lpMapiM->nFileCount;

            if ( ErrLpstrToBstr( lpMapiM->lpszSubject, &lpVBM->bstrSubject ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszNoteText, &lpVBM->bstrNoteText ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszConversationID, &lpVBM->bstrConversationID ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszDateReceived, &lpVBM->bstrDate ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszMessageType, &lpVBM->bstrMessageType ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            break;

        default:
            ulErr = MAPI_E_FAILURE;
			goto exit;
    }

exit:
	return ulErr;
}

//---------------------------------------------------------------------------
// Name:			FBMAPIFreeStruct()
//
// Description:
// 					DeAllocates MAPI structure created in VB2MAPI
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
int FAR PASCAL FBMAPIFreeStruct (LPVOID lpMapiIn, ULONG uCount, USHORT usFlag)
{
    ULONG u;
    LPMAPI_RECIPIENT	lpMapiR;
    LPMAPI_FILE 		lpMapiF;
    LPMAPI_MESSAGE 		lpMapiM;

    if (lpMapiIn == (LPVOID) NULL)
        return TRUE;

    switch ( usFlag )
    {
        case RECIPIENT:
            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiR++ )
            {
                SafeMemFree(lpMapiR->lpszName);
                SafeMemFree(lpMapiR->lpszAddress);
                SafeMemFree(lpMapiR->lpEntryID);
            }

            SafeMemFree(lpMapiIn);
            break;

        case FILE:
            lpMapiF = (LPMAPI_FILE) lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiF++ )
            {
                SafeMemFree(lpMapiF->lpszPathName);
                SafeMemFree(lpMapiF->lpszFileName);
                SafeMemFree(lpMapiF->lpFileType);
            }

            SafeMemFree(lpMapiIn);
            break;

        case MESSAGE:
            lpMapiM = ( LPMAPI_MESSAGE ) lpMapiIn;

            if (lpMapiM->lpRecips)
                FBMAPIFreeStruct((LPVOID)lpMapiM->lpRecips, lpMapiM->nRecipCount, RECIPIENT);

            if (lpMapiM->lpFiles)
                FBMAPIFreeStruct((LPVOID) lpMapiM->lpFiles, lpMapiM->nFileCount, FILE);

            SafeMemFree( lpMapiM->lpszSubject );
            SafeMemFree( lpMapiM->lpszNoteText );
            SafeMemFree( lpMapiM->lpszMessageType );
            SafeMemFree( lpMapiM->lpszDateReceived );
            SafeMemFree( lpMapiM->lpszConversationID );
            SafeMemFree( lpMapiM );
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// Name:		LpstrFromBstr()
//
// Description:
//				Copies and converts OLE Bstr from UNICODE to an ANSI
//				C string.
//
// Parameters:
// Returns:
//				String if successful
//				NULL if failure
// Effects:
// Notes:
//				Note that this function returns NULL for failure as well as
//				a NULL bstr.  This was how the original VB 3.0 implementation
//				worked.
//
// Revision:
//---------------------------------------------------------------------------
LPSTR FAR PASCAL LpstrFromBstr( BSTR bstrSrc, LPSTR lpstrDest )
{
    USHORT cbSrc;

	if ( !bstrSrc )
		return NULL;

    // Copy over the bstr string to a 'C' string

    cbSrc = (USHORT)SysStringLen((OLECHAR *)bstrSrc);

    if (cbSrc == 0)
        return NULL;

	// make sure we handle truly multi byte character sets when
	// we convert from UNICODE to MultiByte.

	cbSrc = (USHORT)((cbSrc + 1) * sizeof(OLECHAR));

    // If Destination is NULL then we'll allocate
    // memory to hold the string.  The caller must
    // deallocate this at some time.

    if ( lpstrDest == NULL )
    {
        if(!MemAlloc((LPVOID*)&lpstrDest, cbSrc))
            return NULL;
    }

	if (!WideCharToMultiByte(CP_ACP, 0, bstrSrc, -1, lpstrDest, cbSrc, NULL, NULL))
	{
		SafeMemFree(lpstrDest);
		lpstrDest = NULL;
	}

    return lpstrDest;
}

//---------------------------------------------------------------------------
// Name:		LpstrFromBstrA
//
// Description:
// 				Copies OLE Bstre ANSI string to C string. Allocates string space
//          	from the global heap and returns a long
//          	pointer to memory. The memory must be freed by the caller
//          	with a call to BMAPIFree.
//
// Parameters:
// Returns:
//				String if successful
//				NULL if failure
//
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------

LPSTR FAR PASCAL LpstrFromBstrA( BSTR bstrSrc, LPSTR lpstrDest )
{
    USHORT cbSrc;

    // If Destination is NULL then we'll allocate memory to hold the
    // string.  The caller must deallocate this at some time.

    cbSrc = (USHORT)SysStringByteLen((OLECHAR *)bstrSrc);

    // Copy over the hlstr string to a 'C' string

    if ( cbSrc == 0 )
        return NULL;

    if ( lpstrDest == NULL )
    {
        if (!MemAlloc((LPVOID*)&lpstrDest, cbSrc + 1))
            return NULL;
    }

    memcpy( lpstrDest, bstrSrc, cbSrc );
    lpstrDest[cbSrc] = '\0';

    return lpstrDest;
}


//---------------------------------------------------------------------------
// Name:		ErrSzToBinaryEID()
//
// Description:
//				Converts a hexized binary string to binary returning
//				the binary data and the size of the data.
//
// Parameters:
// Returns:
//				FALSE	if success.
//				TRUE	if failure.
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR ErrSzToBinaryEID( LPSTR lpstrEID, ULONG * lpcbEID, LPVOID * lppvEID )
{
	ERR		Err		= FALSE;
	ULONG 	cbEID;

	cbEID = CbOfEncoded( lpstrEID );
	if (!MemAlloc(lppvEID, cbEID))
    {
        Err = TRUE;
		goto exit;
	}

	if (!FDecodeID( lpstrEID, (LPBYTE)*lppvEID, lpcbEID ) )
	{
		Err = TRUE;
		SafeMemFree( *lppvEID );
		*lppvEID = NULL;
		goto exit;
	}

exit:

	return Err;
}

/*
 *	Given an string that encodes some binary data, returns the
 *	maximal size of the binary data.
 */
STDAPI_(ULONG) CbOfEncoded(LPTSTR sz)
{
	return (lstrlen(sz) / 4 + 1) * 3;	//	slightly fat
}


/*
 *	Given a byte count, returns the number of characters necessary
 *	to encode that many bytes.
 */
STDAPI_(int) CchEncodedLine(int cb)
{
	Assert(cb <= 45);
	return (cb / 3) * 4 + rgLeft[cb % 3];
}

/*
 -	FDecodeID
 -
 *	Purpose:
 *		Turns a character string produced by EncodeID back to a
 *		byte string. Some validation of the input string is done.
 *
 *	Arguments:
 *		sz				in		The input character string.
 *		pb				out		The decoded byte string. The output
 *								string is not length-checked.
 *		pcb				out		The size of the byte string
 *
 *	Returns:
 *		FALSE => the encoded string was garbled in some way
 *		TRUE  => all OK
 */
STDAPI_(BOOL) FDecodeID(LPTSTR sz, LPBYTE pb, ULONG *pcb)
{
	int		cchLine;
	int		ich;
	CCH		cch = (CCH)lstrlen(sz);
	LPTSTR	szT = sz;

	AssertSz(!IsBadStringPtr(sz, INFINITE), "FDecodeID: sz fails address check");
	AssertSz(!IsBadWritePtr(pb, 1), "FDecodeID: pb fails address check");
	AssertSz(!IsBadWritePtr(pcb, sizeof(ULONG)), "FDecodeID: pcb fails address check");

	*pcb = 0;

	while (*szT)
	{
		//	Process line header
		if (FBadCh(*szT))
			return FALSE;
		ich = DEC(*szT);				//	Byte count for "line"
		*pcb += ich;					//	running total of decoded info
		cchLine = CchEncodedLine(ich);	//	Length-check this "line"
		if (szT + cchLine + 1 > sz + cch)
			return FALSE;
		++szT;

		//	Process line contents
		for (ich = 0; ich < cchLine; ++ich)
		{
			if (FBadCh(*szT))
				return FALSE;
			switch (ich % 4)
			{
			case 0:
				*pb = (BYTE) (DEC(*szT) << 2);
				break;
			case 1:
				*pb |= (DEC(*szT) >> 4) & 0x03;
				++pb;
				*pb = (BYTE) (DEC(*szT) << 4);
				break;
			case 2:
				*pb |= (DEC(*szT) >> 2) & 0x0f;
				++pb;
				*pb = (BYTE) (DEC(*szT) << 6);
				break;
			case 3:
				*pb |= DEC(*szT);
				++pb;
				break;
			}
			++szT;
		}
	}

	return TRUE;
}

//---------------------------------------------------------------------------
// Name:		ErrLpstrToBstrA()
//
// Description:
//				Copies C string to OLE BSTR.  Note that the bstr
//				contains an ANSI string.  VB 4.0 will automatically
//				convert this ANSI string to unicode when the string if
//				this string is a member of a UDT and declared as a UDT.
//				Arrays of UDTs are handled as SAFEARRAYS.
//
//
// Parameters:
// Returns:
//				FALSE if successful
//				TRUE if failure
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR FAR PASCAL ErrLpstrToBstrA( LPSTR cstr, BSTR * lpBstr )
{
	UINT	uiLen;

	if ( *lpBstr )
		SysFreeString( *lpBstr );

	uiLen = lstrlen( cstr );

	*lpBstr = SysAllocStringByteLen( cstr, (uiLen) ? uiLen : 0 );

	return (ERR)((*lpBstr) ? FALSE : TRUE);
}


//---------------------------------------------------------------------------
// Name:		ErrBinaryToSzEID()
//
// Description:
//				Converts binary data to a hexized string.
//
// Parameters:
// Returns:
//				FALSE	if success.
//				TRUE	if failure.
//
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR ErrBinaryToSzEID( LPVOID lpvEID, ULONG cbEID, LPSTR * lppstrEID )
{
	ERR		Err	= FALSE;
	ULONG	cbStr;

	cbStr = CchOfEncoding( cbEID );

    if (!MemAlloc((LPVOID*)lppstrEID, cbStr))
    {
        Err = TRUE;
		goto exit;
	}

	EncodeID( (LPBYTE)lpvEID, cbEID, *lppstrEID );

exit:

	return Err;
}

/*
 *	Given the size of a binary string, returns the size of its
 *	ASCII encoding.
 */
STDAPI_(ULONG) CchOfEncoding(ULONG cbBinary)
{
	return
		(cbBinary / 3) * 4				//	3 bytes -> 4 characters
	+	rgLeft[cbBinary % 3]			//	Leftover bytes -> N characters
	+	((cbBinary / 45) + 1)			//	overhead: 1 byte per line
	+	1;								//	null
}

/*
 -	EncodeID
 -
 *	Purpose:
 *		Turns a byte string into a character string, using the
 *		uuencode algorithm.
 *
 *		Three bytes are mapped into 6 bits each of 4 characters, in
 *		the range 0x21 - 0x60. The encoding is broken up into lines
 *		of 60 characters or less. Each line begins with a count
 *		byte (which specifies the number of bytes encoded, not
 *		characters) and ends with a CRLF pair.
 *
 *		Note that this encoding is sub-optimal for UNICODE: the
 *		characters used still fall into the 7-bit ASCII range.
 *
 *	Arguments:
 *		pb				in		the byte string to encode
 *		cb				in		length of the input string
 *		sz				out		the encoded character string. No
 *								length checking is performed on the
 *								output.
 *
 */
STDAPI_(void) EncodeID(LPBYTE pb, ULONG cb, LPTSTR sz)
{
	int		cbLine;
	int		ib;
	BYTE	b;
#ifdef	DEBUG
	LPTSTR	szBase = sz;
	ULONG	cchTot = CchOfEncoding(cb);
#endif

	AssertSz(!IsBadReadPtr(pb, (UINT) cb), "EncodeID: pb fails address check");
	AssertSz(!IsBadWritePtr(sz, (UINT) cchTot), "EncodeID: sz fails address check");

	while (cb)
	{
		cbLine = min(45, (int)cb);

		Assert(sz < szBase + cchTot);
		*sz++ = ENC(cbLine);

		for (ib = 0; ib < cbLine; ++ib)
		{
			Assert(sz < szBase + cchTot);
			b = 0;
			switch (ib % 3)
			{
			case 0:
				*sz++ = ENC(*pb >> 2);
				if (ib+1 < cbLine)
					b = (BYTE) ((pb[1] >> 4) & 0x0f);
				*sz++ = ENC((*pb << 4) & 0x30 | b);
				break;
			case 1:
				if (ib+1 < cbLine)
					b = (BYTE) ((pb[1] >> 6) & 0x03);
				*sz++ = ENC((*pb << 2) & 0x3c | b);
				break;
			case 2:
				*sz++ = ENC(*pb & 0x3f);
				break;
			}
			pb++;
		}

		cb -= cbLine;
		Assert(cb == 0 || sz + 1 < szBase + cchTot);
	}

	Assert(sz + 1 == szBase + cchTot);
	*sz = 0;
}

//---------------------------------------------------------------------------
// Name:		ErrLpstrToBstr()
//
// Description:
//				Copies and converts a C string to an OLE BSTR.  This
//				routine will convert MultiByte to WideChar.
// Parameters:
// Returns:
//				FALSE if successful
//				TRUE if failure
//
// Effects:
// Notes:
//				SysReallocString returns FALSE if memory failure.
// Revision:
//---------------------------------------------------------------------------
ERR FAR PASCAL ErrLpstrToBstr( LPSTR cstr, BSTR * lpBstr )
{
	OLECHAR *	lpszWC 	= NULL;
	INT			cch		= 0;
	ERR			Err		= FALSE;

	if ( !cstr )
	{
		*lpBstr = NULL;
		return FALSE;
	}

	cch = lstrlen( cstr );
    if (!MemAlloc((LPVOID*)&lpszWC, (cch + 1) * sizeof(OLECHAR)))
        return TRUE ;


	// convert ANSI to WideChar

	if ( !MultiByteToWideChar( GetACP(), 0, cstr, -1, lpszWC, cch + 1 ) )
	{
		Err = TRUE;
		goto exit;

	}

	if ( *lpBstr )
	{
		Err = (ERR)!SysReAllocString( lpBstr, lpszWC );
		if ( Err )
			goto exit;
	}
	else
	{
		*lpBstr = SysAllocString( lpszWC );
		if ( !*lpBstr )
		{
			Err = TRUE;
			goto exit;
		}
	}

exit:

	SafeMemFree(lpszWC);

return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\cdrptrgt.h ===
////////////////////////////////////////////////////////////////////////
//
//  CDropTarget
//
//  IDropTarget implementation
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_CDRPTRGT_H
#define _INC_CDRPTRGT_H


class CDropTarget : public IDropTarget
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IDropTarget methods ***
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CDropTarget(HWND hwndOwner, int iFolderType, LPCITEMIDLIST pidl);
    ~CDropTarget();

private:
    UINT            m_cRef;
    HWND            m_hwndOwner;
    int             m_iFolderType;
    LPFOLDERIDLIST  m_pidl;
    DWORD           m_dwEffect;
};

#endif // _INC_CDRPTRGT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\browser.h ===
/* *
   * Browser implementation
   * 
   * Jan 97: erican
   */

#pragma once

// for ITreeViewNotify
#include "treeview.h"

// for IConnectionNotify
#include "conman.h"
#include "tbbands.h"

// for IIdentityChangeNotify
#include "msident.h"

// for IMessageList
#include "msoeobj.h"

typedef enum tagLAYOUTPOS
{
    LAYOUT_POS_NA = -1,
    LAYOUT_POS_TOP = 0,
    LAYOUT_POS_LEFT,
    LAYOUT_POS_BOTTOM,
    LAYOUT_POS_RIGHT
} LAYOUTPOS;


typedef struct tagLAYOUT
{
    DWORD cbSize;

    // Things that can be turned on or off
    unsigned fToolbar : 1;
    unsigned fStatusBar : 1;
    unsigned fFolderBar : 1;
    unsigned fFolderList : 1;
    unsigned fTipOfTheDay : 1;
    unsigned fInfoPaneEnabled : 1;
    unsigned fInfoPane : 1;
    unsigned fOutlookBar : 1;
    unsigned fContacts : 1;
    unsigned fMailPreviewPane : 1;
    unsigned fMailPreviewPaneHeader : 1;
    unsigned fMailSplitVertically : 1;
    unsigned fNewsPreviewPane : 1;
    unsigned fNewsPreviewPaneHeader : 1;
    unsigned fNewsSplitVertically : 1;
    unsigned fFilterBar           : 1;

    // Which side is the toolbar docked to
    //COOLBAR_SIDE csToolbarSide;

    // Preview Pane settings
    BYTE bMailSplitHorzPct;         // Percent of the view that the preview pane occupies in mail / imap
    BYTE bMailSplitVertPct;
    BYTE bNewsSplitHorzPct;         // Percent of the view that the preview pane occupies in news
    BYTE bNewsSplitVertPct;
} LAYOUT, *PLAYOUT;

// forward defines
class CStatusBar;
class CBodyBar;
class CFolderBar;
class COutBar;
typedef struct tagACCTMENU *LPACCTMENU;
class CNavPane;
class CAdBar;

class IBrowserDoc
{
public:
    virtual void ResetMenus(HMENU) = 0;
    virtual void BrowserExiting(void) = 0;
};

interface IAthenaBrowser;

/////////////////////////////////////////////////////////////////////////////
//
// IViewWindow
//
// Description:  
//      IViewWindow is implemented by all views that are hosted within the 
//      Outlook Express shell.  The methods in this interface are used to manage
//      UI related things such as creation and destruction, keyboard input, and
//      menu enabling etc.
// 
interface IViewWindow : public IOleWindow
{
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(UIActivate)(THIS_ UINT uState) PURE;
    STDMETHOD(CreateViewWindow)(THIS_ IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                RECT *prcView, HWND *pHwnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(OnPopupMenu)(THIS_ HMENU hMenu, HMENU hMenuPopup, UINT uID) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// 
// IMessageWindow
//
// IMessageWindow is an interface implemented specifically by views in 
// Outlook Express that contain the Message List object and Preview Pane   
// object.  Methods are used to control the behavior of those controls.
//
interface IMessageWindow : public IUnknown
{
    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate) PURE;
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp) PURE;
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload) PURE;
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//
// IServerInfo
//
// IServerInfo is used so a newly created view can query the previous view
// to see if the current connection to the server can be reused for this new
// folder.
//
interface IServerInfo : public IUnknown
{
    STDMETHOD(GetFolderId)(THIS_ FOLDERID *pID) PURE;
    STDMETHOD(GetMessageFolder)(THIS_ IMessageServer **ppServer) PURE;
};



DECLARE_INTERFACE_(IAthenaBrowser, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IAthenaBrowser methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, DWORD dwIndex, BOOL fShow, BOOL fActivate) PURE;
    STDMETHOD(ShowToolbar) (THIS_ IUnknown* punkSrc, BOOL fShow) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc) PURE;
    STDMETHOD(HasFocus) (THIS_ UINT itb) PURE;
    STDMETHOD(OnViewWindowActive) (THIS_ struct IViewWindow *pAV) PURE;
    STDMETHOD(BrowseObject) (THIS_ FOLDERID idFolder, DWORD dwFlags) PURE;
    STDMETHOD(GetStatusBar) (THIS_ CStatusBar * * ppStatusBar) PURE;
    STDMETHOD(GetCoolbar) (THIS_ CBands * * ppCoolbar) PURE;
    STDMETHOD(GetLanguageMenu) (THIS_ HMENU *phMenu, UINT cp) PURE;
    STDMETHOD(InitPopupMenu) (THIS_ HMENU hMenu) PURE;
    STDMETHOD(UpdateToolbar) (THIS) PURE;
    STDMETHOD(GetFolderType) (THIS_ FOLDERTYPE *pftType) PURE;
    STDMETHOD(GetCurrentFolder) (THIS_ FOLDERID *pidFolder) PURE;
    STDMETHOD(GetCurrentView) (THIS_ IViewWindow **ppView) PURE;
    STDMETHOD(GetTreeView) (THIS_ CTreeView **ppTree) PURE;
    STDMETHOD(GetViewRect) (THIS_ LPRECT prc) PURE;
    STDMETHOD(GetFolderBar) (THIS_ CFolderBar **ppFolderBar) PURE;
    STDMETHOD(SetViewLayout)(THIS_ DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize) PURE;
    STDMETHOD(GetViewLayout)(THIS_ DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize) PURE;
    STDMETHOD(GetLayout) (THIS_ PLAYOUT playout) PURE;
    STDMETHOD(AccountsChanged) (THIS) PURE;
    STDMETHOD(CycleFocus)(THIS_ BOOL fReverse) PURE;
    STDMETHOD(ShowAdBar)(THIS_ BSTR bstr) PURE;
};


#define ITB_NONE        ((UINT)-1)
#define ITB_COOLBAR     0
#define ITB_ADBAR       1
#define ITB_BODYBAR     2
#define ITB_OUTBAR      3
#define ITB_FOLDERBAR   4
#define ITB_NAVPANE     5
#define ITB_TREE        6
#define ITB_MAX         7
//changing the name from ITB_VIEW to ITB_OEVIEW to fix the build break caused due to a redef in iedev
#define ITB_OEVIEW        (ITB_MAX + 1)

/////////////////////////////////////////////////////////////////////////////
//
// CBrowser
//

class CBrowser :
    public IAthenaBrowser,
    public IOleCommandTarget,
    public IDockingWindowSite,
    public IInputObjectSite,
    public ITreeViewNotify,
    public IConnectionNotify,
    public IIdentityChangeNotify,
    public IStoreCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    //
    // OLE Interfaces
    //
    
    // IUnknown 
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);                         
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
    // IAthenaBrowser (also IOleWindow)
    virtual STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, DWORD dwIndex, BOOL fShow, BOOL fActivate);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc);
    virtual STDMETHODIMP HasFocus(UINT itb);
    virtual STDMETHODIMP OnViewWindowActive(IViewWindow *pAV);
    virtual STDMETHODIMP BrowseObject(FOLDERID idFolder, DWORD dwFlags);
    virtual STDMETHODIMP GetStatusBar(CStatusBar * * ppStatusBar);
    virtual STDMETHODIMP GetCoolbar(CBands * * ppCoolbar);
    virtual STDMETHODIMP GetLanguageMenu(HMENU *phMenu, UINT cp);
    virtual STDMETHODIMP InitPopupMenu(HMENU hMenu);
    virtual STDMETHODIMP UpdateToolbar();
    virtual STDMETHODIMP GetFolderType(FOLDERTYPE *pftType);
    virtual STDMETHODIMP GetCurrentFolder(FOLDERID *pidFolder);
    virtual STDMETHODIMP GetCurrentView(IViewWindow **ppView);
    virtual STDMETHODIMP GetTreeView(CTreeView * * ppTree);
    virtual STDMETHODIMP GetViewRect(LPRECT prc);
    virtual STDMETHODIMP GetFolderBar(CFolderBar **ppFolderBar);
    virtual STDMETHODIMP SetViewLayout(DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize);
    virtual STDMETHODIMP GetViewLayout(DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize);
    virtual STDMETHODIMP GetLayout(PLAYOUT playout);
    virtual STDMETHODIMP AccountsChanged(void) { m_fRebuildAccountMenu = TRUE; return (S_OK); }
    virtual STDMETHODIMP CycleFocus(BOOL fReverse);
    virtual STDMETHODIMP ShowAdBar(BSTR     bstr);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                     OLECMDTEXT *pCmdText); 
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    // IDockingWindowSite (also IOleWindow)
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // ITreeViewNotify
    void OnSelChange(FOLDERID idFolder);
    void OnRename(FOLDERID idFolder);
    void OnDoubleClick(FOLDERID idFolder);

    // IStoreCallback Members
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    // IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);
    
    // IIdentityChangeNotify
    virtual STDMETHODIMP QuerySwitchIdentities();
    virtual STDMETHODIMP SwitchIdentities();
    virtual STDMETHODIMP IdentityInformationChanged(DWORD dwType);

    void SetDocObjPointer(IBrowserDoc* pDocObj)
    {
        m_pDocObj = pDocObj;
    }

    /////////////////////////////////////////////////////////////////////////
    //
    // Constructors, Destructors, and Initialization
    //
    CBrowser();
    virtual ~CBrowser();
    HRESULT HrInit(UINT nCmdShow, FOLDERID idFolder, HWND hWndParent = NULL);
    HRESULT IsMenuMessage(MSG *lpmsg);
    HRESULT TranslateMenuMessage(MSG *lpmsg, LRESULT *lres);
    void    WriteUnreadCount(void);

private:
    // IAthenaToolbarFrame support functions
    void    _OnFocusChange(UINT itb);
    UINT    FindTBar(IUnknown* punkSrc);
    void    ReleaseToolbarItem(int itb, BOOL fClose);
    void    ResizeNextBorder(UINT itb);
    void    GetClientArea(LPRECT prc);

    void    SetFolderType(FOLDERID idFolder);
    void    DeferedLanguageMenu();

    HRESULT LoadLayoutSettings(void);
    HRESULT SaveLayoutSettings(void);

    /////////////////////////////////////////////////////////////////////////
    //
    // Callback Functions
    //
    // Note: All callbacks must be made static members to avoid having the 
    //       implicit "this" pointer passed as the first parameter.
    //
    static LRESULT CALLBACK EXPORT_16 BrowserWndProc(HWND, UINT, WPARAM, LPARAM);
                                          
    /////////////////////////////////////////////////////////////////////////
    //
    // Message Handling
    //
    LRESULT WndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);
    HRESULT OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    SpoolerDeliver(WPARAM wParam, LPARAM lParam);
    void    EnableMenuCallback(HMENU hMenu, UINT wID);
    void    FrameActivatePopups(BOOL fActive);
    void    UpdateStatusBar(void);

    HRESULT CmdSendReceieveAccount(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdDeleteAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    BOOL    _InitToolbars();
    void    _ResetMenu(FOLDERTYPE ftNew, BOOL fHideHotMail);
    HRESULT _CheckAndWriteUnreadNumber(DWORD dwSrvTypes);
    DWORD   _GetNumberOfUnreadMsg(IMessageFolder *pFolder);
    inline  void    _AppendIdentityName(LPCTSTR pszIdentityName, LPSTR pszName, DWORD cchName);

private:
    /////////////////////////////////////////////////////////////////////////
    // 
    // Private Data
    //

    /////////////////////////////////////////////////////////////////////////
    // Shell Stuff
    UINT                m_cRef;
    HWND                m_hwnd;                       // Our window
    IViewWindow        *m_pView;
    IOleCommandTarget  *m_pViewCT;
    HWND                m_hwndInner;
    FOLDERTYPE          m_ftSel;
    FOLDERID            m_idSelected;
    BOOL                m_fPainted;
    HICON               m_hIconPhone,
                        m_hIconError,
                        m_hIconAthena,
                        m_hIconOffline,
                        m_hIcon,
                        m_hIconSm;
    BOOL                m_fRebuildAccountMenu,
                        m_fInitNewAcctMenu,
                        m_fInternal;
    HMENU               m_hMenu;
    HWNDLIST            m_hlDisabled;
    BOOL                m_fNoModifyAccts;

    /////////////////////////////////////////////////////////////////////////
    // Child support
    CTreeView          *m_pTreeView;
    CStatusBar         *m_pStatus;
    CBands              *m_pCoolbar;
    CBodyBar           *m_pBodyBar;
    CFolderBar         *m_pFolderBar;
    HWND                m_hwndLastFocus;
    CNavPane           *m_pNavPane;

    TCHAR               m_szName[CCHMAX_STRINGRES];

    /////////////////////////////////////////////////////////////////////////
    // Layout members
    struct SToolbarItem {
        IDockingWindow      *ptbar;
        IOleCommandTarget   *pOleCmdTarget;
        BORDERWIDTHS        rcBorderTool;
        DWORD               fShow;
    };
    SToolbarItem        m_rgTBar[ITB_MAX];

    UINT                m_itbLastFocus;   // last one called OnFocusChange (can be ITB_NONE)

    LAYOUT              m_rLayout;

    /////////////////////////////////////////////////////////////////////////
    // Mail stuff
    ULONG               m_cAcctMenu;
    LPACCTMENU          m_pAcctMenu;
    BOOL                m_fAnimate;
    UINT_PTR            m_idClearStatusTimer;

    /////////////////////////////////////////////////////////////////////////
    // View Language Menu
    HMENU               m_hMenuLanguage;
    BOOL                m_fEnvMenuInited;
    /////////////////////////////////////////////////////////////////////////

    IBrowserDoc         *m_pDocObj;
    COutBar             *m_pOutBar;

    DWORD               m_dwIdentCookie;
    BOOL                m_fSwitchIsLogout;

    CAdBar              *m_pAdBar;
};

#define DISPID_MSGVIEW_BASE                 1000

#define DISPID_MSGVIEW_TOOLBAR              (DISPID_MSGVIEW_BASE + 1)
#define DISPID_MSGVIEW_STATUSBAR            (DISPID_MSGVIEW_BASE + 2)
#define DISPID_MSGVIEW_FOLDERBAR            (DISPID_MSGVIEW_BASE + 4)
#define DISPID_MSGVIEW_FOLDERLIST           (DISPID_MSGVIEW_BASE + 5)
#define DISPID_MSGVIEW_TIPOFTHEDAY          (DISPID_MSGVIEW_BASE + 6)
#define DISPID_MSGVIEW_INFOPANE             (DISPID_MSGVIEW_BASE + 7)
#define DISPID_MSGVIEW_PREVIEWPANE_MAIL     (DISPID_MSGVIEW_BASE + 8)
#define DISPID_MSGVIEW_PREVIEWPANE_NEWS     (DISPID_MSGVIEW_BASE + 9)
#define DISPID_MSGVIEW_FOLDER               (DISPID_MSGVIEW_BASE + 10)
#define DISPID_MSGVIEW_OUTLOOK_BAR          (DISPID_MSGVIEW_BASE + 11)
#define DISPID_MSGVIEW_CONTACTS             (DISPID_MSGVIEW_BASE + 12)
#define DISPID_MSGVIEW_FILTERBAR            (DISPID_MSGVIEW_BASE + 13)

/////////////////////////////////////////////////////////////////////////////
// Drop Down treeview support
void RegisterGlobalDropDown(HWND hwndCtrl);
void UnregisterGlobalDropDown(HWND hwndCtrl);
void CancelGlobalDropDown();
HWND HwndGlobalDropDown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\browser.cpp ===
/*
 *    browser.cpp                                                  
 *    
 *    Purpose:                     
 *        Implements a browser object
 *    
 *    Owner:
 *        EricAn
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */
#include "pch.hxx"
#include "bodybar.h"
#include "browser.h"
#include <shellapi.h>
#include "resource.h"
#include "options.h"
#include "ipab.h"
#include "inetcfg.h"
#include "acctutil.h"
#include "mailutil.h"
#include "impapi.h"
#include "menuutil.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "error.h"
#include "fonts.h"
#include "treeview.h"
#include "goptions.h"
#include "strconst.h"
#include "note.h"
#include "tbbands.h"
#include "statbar.h"
#include "newfldr.h"
#include "conman.h"
#include "acctutil.h"
#include "spoolapi.h"
#include "statnery.h"
#include "inpobj.h"
#include "fldbar.h"
#include "layout.h"
#include "htmlhelp.h"
#include "shared.h"
#include "mailutil.h"
#include <shlwapi.h>
#include "shlwapip.h" 
#include "instance.h"
#include "ruleutil.h"
#include "envfact.h"
#include "storutil.h"
#include "finder.h"
#include "demand.h"
#include "multiusr.h"
#include "menures.h"
#include "store.h"
#include "subscr.h"
#include "outbar.h"
#include "navpane.h"
#include "msostd.h"
#include "inetreg.h"
#include "mapiutil.h"
#include "adbar.h"
#include <mirror.h>

#define MAX_SIZE_EXT_STR    128

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// 
// Defines
//

#define CBM_POSTCREATE  (WM_USER + 4000)
#define TIME_TO_CLEAR_NEWMSGSTATUS      (20*1000)    // 20 seconds
#define TIMER_CLEAR_STATUS              1003

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define CBDOUT(x) DOUTL(DOUT_LEVEL4, x)

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static const TCHAR s_szCallClient[] = TEXT("Internet Call");
static const TCHAR s_szMailClient[] = TEXT("Mail");
static const TCHAR s_szNewsClient[] = TEXT("News");

static HACCEL s_hAccelBrowser = NULL;
static s_fQuickShutdown = FALSE;

enum {
    IMAGE_STATBAR_BLANK,
    IMAGE_STATBAR_WARNING,
    IMAGE_STATBAR_SPOOLER
};

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

//
//  FUNCTION:   ShellUtil_IsRegisteredClient()
//
//  PURPOSE:    Returns whether the specified client type is handled.
//
BOOL ShellUtil_IsRegisteredClient(LPCTSTR pszClient)
{
    LONG cbSize = 0;
    TCHAR szKey[MAX_PATH];
    
    wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szRegPathClients, pszClient);
    return (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, NULL, &cbSize) == ERROR_SUCCESS) && 
           (cbSize > 1);
}

//
//  FUNCTION:   ShellUtil_RunIndirectRegCommand()
//
//  PURPOSE:    find the default value under HKLM\Software\Clients\pszClient
//              tack on shell\open\command
//              then runreg that
//
void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient)
{
    TCHAR szDefApp[MAX_PATH], szExpanded[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    DWORD cbSize = sizeof(szDefApp);
    DWORD dwType;
    
    wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szRegPathClients, pszClient);
    if (RegQueryValueEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, (LPBYTE)szDefApp, &cbSize) == ERROR_SUCCESS) 
    {        
        TCHAR szFullKey[MAX_PATH];
        
        // tack on shell\open\command
        wnsprintf(szFullKey, ARRAYSIZE(szFullKey), TEXT("%s\\%s\\shell\\open\\command"), szKey, szDefApp);
        cbSize = sizeof(szDefApp);
        if (RegQueryValueEx(HKEY_LOCAL_MACHINE, szFullKey, 0, &dwType, (LPBYTE)szDefApp, &cbSize) == ERROR_SUCCESS)
        {
            LPSTR pszArgs;
            SHELLEXECUTEINFO ExecInfo;
            
            pszArgs = PathGetArgs(szDefApp);
            PathRemoveArgs(szDefApp);
            PathUnquoteSpaces(szDefApp);
            
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDefApp, szExpanded, ARRAYSIZE(szExpanded));
                ExecInfo.lpFile = szExpanded;
            }
            else
                ExecInfo.lpFile = szDefApp;
            
            ExecInfo.hwnd = hwnd;
            ExecInfo.lpVerb = NULL;
            ExecInfo.lpParameters = pszArgs;
            ExecInfo.lpDirectory = NULL;
            ExecInfo.nShow = SW_SHOWNORMAL;
            ExecInfo.fMask = 0;
            ExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
            
            ShellExecuteEx(&ExecInfo);
        }
    }
}

/////////////////////////////////////////////////////////////////////////
//
// Constructors, Destructors, and Initialization
//

CBrowser::CBrowser()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_pView = NULL;
    m_pViewCT = NULL;
    m_hwndInner = NULL;
    m_ftSel = FOLDER_TYPESMAX;
    m_idSelected = FOLDERID_INVALID;
    m_fPainted = FALSE;
    m_hIconPhone = 0;
    m_hIconError = 0;
    m_hIconAthena = 0;
    m_hIconOffline = 0;
    m_hIcon = 0;
    m_hIconSm = 0;
    m_pTreeView = NULL;
    m_pStatus = NULL;
    m_pCoolbar = NULL;
    m_pBodyBar = NULL;
    m_pFolderBar = NULL;
    m_hwndLastFocus = NULL;
    m_fInternal = 0;
    *m_szName = 0;
    ZeroMemory(m_rgTBar, sizeof(m_rgTBar));
    m_itbLastFocus = ITB_NONE;
    m_cAcctMenu = 0;
    m_pAcctMenu = NULL;
    m_fAnimate = FALSE;
    m_hMenuLanguage = NULL;
    m_pDocObj = NULL;
    CoIncrementInit("CBrowser::CBrowser", MSOEAPI_START_SHOWERRORS, NULL, NULL);
    m_fEnvMenuInited = FALSE;
    m_fRebuildAccountMenu = TRUE;
    m_fInitNewAcctMenu = FALSE;
    m_hMenu = NULL;
    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));
    m_dwIdentCookie = 0;
    m_fSwitchIsLogout = FALSE;
    m_fNoModifyAccts = FALSE;
    m_pAdBar    = NULL;
}

CBrowser::~CBrowser()
{
    Assert(NULL == m_pView);
    Assert(NULL == m_pViewCT);
    SafeRelease(m_pTreeView);
    SafeRelease(m_pCoolbar);
    SafeRelease(m_pBodyBar);
    SafeRelease(m_pFolderBar);
    SafeRelease(m_pStatus);
    SafeRelease(m_pOutBar);
    SafeRelease(m_pNavPane);
    SafeRelease(m_pAdBar);

    SafeMemFree(m_pAcctMenu);
    g_pBrowser = NULL;
           
    if (m_hIconPhone)
        SideAssert(DestroyIcon(m_hIconPhone));

    if (m_hIconError)
        SideAssert(DestroyIcon(m_hIconError));

    if (m_hIconAthena)
        SideAssert(DestroyIcon(m_hIconAthena));

    if (m_hIconOffline)
        SideAssert(DestroyIcon(m_hIconOffline));
    
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));

    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    if (m_hMenuLanguage)
    {
        DeinitMultiLanguage();
        if(IsMenu(m_hMenuLanguage))
            DestroyMenu(m_hMenuLanguage);
    }

    DOUT("CBrowser calling CoDecrementInit()");
    CoDecrementInit("CBrowser::CBrowser", NULL);

    if (m_hMenu && IsMenu(m_hMenu))
        DestroyMenu(m_hMenu);
}

HRESULT CBrowser::HrInit(UINT nCmdShow, FOLDERID idFolder, HWND hWndParent)
{
    DWORD cb, type, dw;
    WNDCLASSEX      wc;
    WINDOWPLACEMENT wp;
    DWORD dwExStyle = 0;
    // Only load the layout from the registry only if we're standalone
    LoadLayoutSettings();

    m_idSelected = idFolder;

    if (!s_hAccelBrowser)
        s_hAccelBrowser = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_BROWSER_ACCEL));

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szBrowserWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CBrowser::BrowserWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;         // Handled in WM_CREATE
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;         // Handled in WM_CREATE
        wc.lpszClassName    = c_szBrowserWndClass;
        wc.hIconSm          = NULL;         // Handled in WM_CREATE
        if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }
    if(IS_BIDI_LOCALIZED_SYSTEM())
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    m_hwnd = CreateWindowEx(dwExStyle, c_szBrowserWndClass, NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            hWndParent, NULL, g_hInst, (LPVOID) this);

    if (GetOption(OPT_BROWSERPOS, (LPVOID)&wp, sizeof(wp)))
    {
        // If the user has SHOWNORMAL as the default setting in the shortcut, then
        // we'll respect the setting that we saved earlier.  Otherwise, we have to
        // go with what's in the shortcut.
        if (nCmdShow != SW_SHOWNORMAL)
            wp.showCmd = nCmdShow;

        // Also, don't allow the user to come up minimized.  That's kinda wierd.
        else if (wp.showCmd == SW_SHOWMINIMIZED)
            wp.showCmd = SW_SHOWNORMAL;

        SetWindowPlacement(m_hwnd, &wp);
    }
    else
    {
        CenterDialog(m_hwnd);
        ShowWindow(m_hwnd, nCmdShow);
    }

    // Register with identity manager
    SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(IAthenaBrowser *)this, &m_dwIdentCookie)));

    SetForegroundWindow(m_hwnd);

    if (!m_hwnd)
        return E_FAIL;    
    
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
        dw != 0)
        m_fNoModifyAccts = TRUE;

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//
    
////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IAthenaBrowser *) this;
    else if (IsEqualIID(riid, IID_IAthenaBrowser))
        *ppvObj = (void*) (IAthenaBrowser *) this;
    else if (IsEqualIID(riid, IID_IDockingWindowSite))
        *ppvObj = (void*) (IDockingWindowSite *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (void*) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (void*) (IIdentityChangeNotify *) this;
    else        
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CBrowser::AddRef()
{
    DOUT(TEXT("CBrowser::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CBrowser::Release()
{
    DOUT(TEXT("CBrowser::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IStoreCallback
//
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBrowser::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    *phwndParent = GetLastActivePopup(m_hwnd);
    return(S_OK);
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CBrowser::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CBrowser::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaBrowser
//
////////////////////////////////////////////////////////////////////////

BOOL IsOwner(HWND hwndOwner, HWND hwnd)
{
    // Loop through until we find the topmost window
    HWND hwndTemp = hwnd;
    if (GetParent(hwndTemp))
    {
        while (GetParent(hwndTemp))
            hwndTemp = GetParent(hwndTemp);

        if (hwndOwner == hwndTemp)
            return (TRUE);
    }

    return (FALSE);
}

HRESULT CBrowser::TranslateAccelerator(LPMSG lpmsg)
{
    HWND hwndFocus;
    BOOL fInnerValid, fViewFocus;
    int  i;

    if (!(m_hwnd && IsWindow(m_hwnd)))
        return S_FALSE;

    if (FWABTranslateAccelerator(lpmsg))
        return S_TRUE;

    hwndFocus = GetFocus();

    //check if it is a menu message
    if (!GetTlsGlobalActiveNote())
    {
        if (m_pCoolbar->IsMenuMessage(lpmsg) == S_OK)
            return S_OK;
    }

    // handle the mousewheel messages for this thread
    if ((g_msgMSWheel && (lpmsg->message == g_msgMSWheel)) || (lpmsg->message == WM_MOUSEWHEEL))
        {
        POINT pt;
        HWND  hwndT;

        pt.x = GET_X_LPARAM(lpmsg->lParam);
        pt.y = GET_Y_LPARAM(lpmsg->lParam);

        hwndT = WindowFromPoint(pt);
        if (hwndT != m_hwnd && IsChild(m_hwnd, hwndT))
            SendMessage(hwndT, lpmsg->message, lpmsg->wParam, lpmsg->lParam);
        else if (hwndFocus != m_hwnd && IsChild(m_hwnd, hwndFocus))
            SendMessage(hwndFocus, lpmsg->message, lpmsg->wParam, lpmsg->wParam);
        else
            return S_FALSE;
        return S_OK;
        }

    HWND hwndDropDown = HwndGlobalDropDown();
    BOOL fRetCode;

    if (hwndDropDown)
        {
        if (lpmsg->message == WM_LBUTTONDOWN ||
            lpmsg->message == WM_NCLBUTTONDOWN ||
            lpmsg->message == WM_RBUTTONDOWN ||
            lpmsg->message == WM_NCRBUTTONDOWN)
            {
            fRetCode = (BOOL)::SendMessage(hwndDropDown, WMR_CLICKOUTSIDE,
                                           CLK_OUT_MOUSE, (LPARAM)lpmsg->hwnd);
            if (fRetCode)
                return (S_OK);
            }

        if (lpmsg->message == WM_KEYDOWN &&
            // One of the possible hot keys
            (lpmsg->wParam==VK_ESCAPE || lpmsg->wParam==VK_TAB))
            {
            fRetCode = (BOOL)::SendMessage(hwndDropDown, WMR_CLICKOUTSIDE,
                                           CLK_OUT_KEYBD, (LPARAM)lpmsg->wParam);
            if (fRetCode)
                return S_OK;
            }
        }

    if (!(hwndFocus && (IsChild(m_hwnd, hwndFocus) || m_hwnd == hwndFocus || IsOwner(m_hwnd, hwndFocus))))
        return S_FALSE;

    fInnerValid = m_pView && m_hwndInner && IsWindow(m_hwndInner);
    fViewFocus = fInnerValid && hwndFocus && (IsChild(m_hwndInner, hwndFocus) || m_hwndInner == hwndFocus);

    if (fViewFocus)
    {
        if (m_pView->TranslateAccelerator(lpmsg) == S_OK)
            return S_OK;
    }

    for (i=0; i<ITB_MAX; i++)
        {
        if (m_rgTBar[i].ptbar && UnkHasFocusIO(m_rgTBar[i].ptbar) == S_OK)
            {
            if (UnkTranslateAcceleratorIO(m_rgTBar[i].ptbar, lpmsg) == S_OK)
                return S_OK;
            break;
            }
        }

    // Handle tabbing between windows
    if (lpmsg->hwnd &&
        IsChild(m_hwnd, lpmsg->hwnd))
    {
        if (lpmsg->message == WM_KEYDOWN)
        {
            if (lpmsg->wParam == VK_TAB && (FALSE == !!(0x8000 & GetKeyState(VK_CONTROL))))
            {
                SHORT state = GetKeyState(VK_SHIFT);
                HWND hwndNext = GetNextDlgTabItem(m_hwnd, GetFocus(), !!(state & 0x8000));
                SetFocus(hwndNext);
                return (S_OK);
            }
        }
    }

    if (lpmsg->hwnd &&
        IsChild(m_hwnd, lpmsg->hwnd) && s_hAccelBrowser && ::TranslateAccelerator(m_hwnd, s_hAccelBrowser, lpmsg))
        return S_OK;

    // if the view doesn't have focus, it still gets a chance at the accelerator, after the browser
    if (fInnerValid && !fViewFocus)
        if (m_pView->TranslateAccelerator(lpmsg) == S_OK)
            return S_OK;

    return S_FALSE;
}

//
//  Add the specified toolbar (as punkSrc) to this toolbar site
//
// Returns: S_OK, if successfully done.
//          E_FAIL, if failed (exceeded maximum).
//          E_NOINTERFACE, the toolbar does not support an approriate interface.
//
HRESULT CBrowser::AddToolbar(IUnknown* punk, DWORD dwIndex, BOOL fShow, BOOL fActivate)
{
    HRESULT hres = E_FAIL;

    Assert(ITB_NONE == FindTBar(punk));
    Assert(dwIndex < ITB_MAX);
    Assert(m_rgTBar[dwIndex].ptbar == NULL);

    if (punk->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_rgTBar[dwIndex].pOleCmdTarget) != S_OK)
    {
        m_rgTBar[dwIndex].pOleCmdTarget = NULL;
    }

    hres = punk->QueryInterface(IID_IDockingWindow, (LPVOID*)&m_rgTBar[dwIndex].ptbar);
    if (SUCCEEDED(hres)) 
    {
        m_rgTBar[dwIndex].fShow = fShow;
        UnkSetSite(m_rgTBar[dwIndex].ptbar, (IAthenaBrowser *)this);

        if (fActivate)
            m_rgTBar[dwIndex].ptbar->ShowDW(fShow);
    }

    return hres;
}

HRESULT CBrowser::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
        {
        Assert(0);
        return E_INVALIDARG;
        }

    if (m_rgTBar[itb].ptbar)
        {
        m_rgTBar[itb].fShow = fShow;
        m_rgTBar[itb].ptbar->ShowDW(fShow);
        }

    return S_OK;
}

HRESULT CBrowser::RemoveToolbar(IUnknown* punkSrc)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    ReleaseToolbarItem(itb, TRUE);
    
    // Clear the rect and resize the inner ones (including the view).
    SetRect(&m_rgTBar[itb].rcBorderTool, 0, 0, 0, 0);
    ResizeNextBorder(itb+1);
    
    return S_OK;
}

HRESULT CBrowser::HasFocus(UINT itb)
{
    HRESULT     hres = S_FALSE;
    
    if (ITB_OEVIEW == itb)
        hres = (ITB_OEVIEW == m_itbLastFocus) ? S_OK : S_FALSE;
    else if (m_rgTBar[itb].fShow && m_rgTBar[itb].ptbar)
        hres =  UnkHasFocusIO(m_rgTBar[itb].ptbar);
    
    return hres;
}

HRESULT CBrowser::OnViewWindowActive(IViewWindow *pAV)
{
    _OnFocusChange(ITB_OEVIEW);
    return NOERROR;
}

HRESULT CBrowser::BrowseObject(FOLDERID idFolder, DWORD dwFlags)
{
    if (!m_pTreeView)
        return E_FAIL;
    return m_pTreeView->SetSelection(idFolder, TVSS_INSERTIFNOTFOUND);
}

HRESULT CBrowser::GetStatusBar(CStatusBar * * ppStatusBar)
{
    if (m_pStatus)
    {
        *ppStatusBar = m_pStatus;
        m_pStatus->AddRef();
        return S_OK;
    }
    *ppStatusBar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetCoolbar(CBands * * ppCoolbar)
{
    if (m_pCoolbar)
    {
        *ppCoolbar = m_pCoolbar;
        m_pCoolbar->AddRef();
        return S_OK;
    }
    *ppCoolbar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetTreeView(CTreeView * * ppTreeView)
{
    if (m_pTreeView)
    {
        *ppTreeView = m_pTreeView;
        m_pTreeView->AddRef();
        return S_OK;
    }
    *ppTreeView = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetFolderBar(CFolderBar * * ppFolderBar)
{
    if (m_pFolderBar)
    {
        *ppFolderBar = m_pFolderBar;
        m_pFolderBar->AddRef();
        return S_OK;
    }
    *ppFolderBar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetLanguageMenu(HMENU *phMenu, UINT uiCodepage)
{
    if(!m_hMenuLanguage)
        InitMultiLanguage();
    else if (IsMenu(m_hMenuLanguage))
        DestroyMenu(m_hMenuLanguage);
    
    UINT cp;

    if(uiCodepage)
        cp = uiCodepage;
    else if(m_pView)
    {
        IMessageWindow *pWindow;

        if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
        {
            pWindow->GetCurCharSet(&cp);
            pWindow->Release();
        }
        else
            cp = GetACP();
    }
    else
        cp = GetACP();

    m_hMenuLanguage = CreateMimeLanguageMenu(TRUE,TRUE, cp);
    
    if (!m_hMenuLanguage)
        return E_FAIL;
    
    *phMenu = m_hMenuLanguage;
    return S_OK;
}

HRESULT CBrowser::InitPopupMenu(HMENU hMenu)
{
    if (!hMenu)
        return E_INVALIDARG;
    MenuUtil_EnablePopupMenu(hMenu, this);
    
    return S_OK;
}

HRESULT CBrowser::UpdateToolbar()
{
    if (m_pCoolbar)
        return (m_pCoolbar->Update());
    
    return (E_FAIL);
}


HRESULT CBrowser::GetFolderType(FOLDERTYPE *pftType)
{
    if (pftType)
    {
        *pftType = m_ftSel;
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}

HRESULT CBrowser::GetCurrentFolder(FOLDERID *pidFolder)
{
    if (pidFolder)
    {
        *pidFolder = m_idSelected;
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}

HRESULT CBrowser::GetCurrentView(IViewWindow **ppView)
{
    if (ppView)
    {
        *ppView = m_pView;
        (*ppView)->AddRef();
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}
    
////////////////////////////////////////////////////////////////////////
//
//  IDockingWindowSite
//
////////////////////////////////////////////////////////////////////////

//
// This is an implementation of IDockingWindowSite::GetBorderDW.
//
//  This function returns a bounding rectangle for the specified toolbar
//  (by punkSrc). It gets the effective client area, then subtract border
//  area taken by "outer" toolbars. 
// 
HRESULT CBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    GetClientArea(lprectBorder);
    
    //
    // Subtract border area taken by "outer toolbars"
    //
    for (UINT i=0; i<itb; i++) 
    {
        lprectBorder->left += m_rgTBar[i].rcBorderTool.left;
        lprectBorder->top += m_rgTBar[i].rcBorderTool.top;
        lprectBorder->right -= m_rgTBar[i].rcBorderTool.right;
        lprectBorder->bottom -= m_rgTBar[i].rcBorderTool.bottom;
    }
    
    DOUTL(4, "CBrowser::GetBorderDW called returning=%x,%x,%x,%x",
        lprectBorder->left, lprectBorder->top, lprectBorder->right, lprectBorder->bottom);
    return S_OK;
}

HRESULT CBrowser::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    DOUTL(4, "CBrowser::ReqestBorderSpaceST pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

HRESULT CBrowser::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    DOUTL(4, "CBrowser::SetBorderSpaceDW pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    
    m_rgTBar[itb].rcBorderTool = *pborderwidths;
    ResizeNextBorder(itb+1);
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObjectSite
//
////////////////////////////////////////////////////////////////////////

HRESULT CBrowser::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        //Assert(0);
        return E_INVALIDARG;
    }
    
    //
    //  Note that we keep track of which toolbar got the focus last.
    // We can't reliably monitor the kill focus event because OLE's
    // window procedure hook (for merged menu dispatching code) changes
    // focus around. 
    //
    if (fSetFocus) 
    {
        _OnFocusChange(itb);
    }
    
    UpdateToolbar();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  Support functions for IAthenaBrowser and IDockingWindowSite
//
////////////////////////////////////////////////////////////////////////

//
//  This function is called, when either tree control or the drives
// get the focus.
//
void CBrowser::_OnFocusChange(UINT itb)
{
    //
    //  If the view is loosing the focus (within the explorer),
    // we should let it know. We should update _itbLastFocus before
    // calling UIActivate, because it will call our InsertMenu back.
    //
    if (m_itbLastFocus == itb)
        return;

    UINT itbPrevFocus = m_itbLastFocus;
    m_itbLastFocus = itb;

    if (itbPrevFocus == ITB_OEVIEW)
    {
        if (m_pView)
            m_pView->UIActivate(SVUIA_ACTIVATE_NOFOCUS);
    }
    else if (itbPrevFocus != ITB_NONE)
    {
        UnkUIActivateIO(m_rgTBar[itbPrevFocus].ptbar, FALSE, NULL);
    }

    UpdateToolbar();
}


UINT CBrowser::FindTBar(IUnknown* punkSrc)
{
    int i;    
    
    Assert(punkSrc);

    // Quick check without QI
    for (i=0; i<ITB_MAX ;i++ ) 
        {
        if (punkSrc == m_rgTBar[i].ptbar)
            return i;
        }

    // If failed, do the real COM object identity check. 
    for (i=0; i<ITB_MAX ;i++ ) 
        {
        if (m_rgTBar[i].ptbar) 
            {
            if (_IsSameObject(m_rgTBar[i].ptbar, punkSrc)==S_OK) 
                {
                return i;
                }
            }
        }

    return ITB_NONE;
}

void CBrowser::ReleaseToolbarItem(int itb, BOOL fClose)
{
    IDockingWindow *ptbTmp;

    // grab it and NULL it out to eliminate race condition.
    // (actually, there's still a v. small window btwn the 2 statements).
    //
    // e.g. if you close a WebBar and then quickly shutdown windows,
    // the close destroys the window etc. but then the shutdown code
    // does _SaveToolbars which tries to do ->Save on that destroyed guy.
    ptbTmp = m_rgTBar[itb].ptbar;
    m_rgTBar[itb].ptbar = NULL;

    if (fClose)
        ptbTmp->CloseDW(0);
    UnkSetSite(ptbTmp, NULL);
    ptbTmp->Release();

    SafeRelease(m_rgTBar[itb].pOleCmdTarget);
    m_rgTBar[itb].pOleCmdTarget = NULL;
}

void CBrowser::ResizeNextBorder(UINT itb)
{
    // Find the next toolbar (even non-visible one)
    RECT rc;
    IDockingWindow* ptbarNext = NULL;

    for (int i=itb; i<ITB_MAX; i++) 
        {
        if (m_rgTBar[i].ptbar) 
            {
            ptbarNext = m_rgTBar[i].ptbar;
            break;
            }
        }

    if (ptbarNext) 
        {
        GetBorderDW(ptbarNext, &rc);
        ptbarNext->ResizeBorderDW(&rc, (IUnknown*)(IAthenaBrowser*)this, TRUE);
        } 
    else 
        {
        // resize the inner shell view
        GetViewRect(&rc);
        if (m_hwndInner)
            {
            SetWindowPos(m_hwndInner, 
                         NULL,
                         rc.left, 
                         rc.top, 
                         rc.right - rc.left, 
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_NOACTIVATE);            
            }
        else
            {
            InvalidateRect(m_hwnd, &rc, FALSE);
            }
        }
}

void CBrowser::GetClientArea(LPRECT prc)
{
    static const int s_rgCtlIds[] = { 1, 0, 1, IDC_STATUS_BAR, 0, 0};
    Assert(m_hwnd);
    GetEffectiveClientRect(m_hwnd, prc, (LPINT)s_rgCtlIds);
}

HRESULT CBrowser::GetViewRect(LPRECT prc)
{
    Assert(m_hwnd);
    GetClientArea(prc);

    //
    // Extract the border taken by all "frame" toolbars
    //
    for (int i=0; i<ITB_MAX; i++) 
        {
        prc->left += m_rgTBar[i].rcBorderTool.left;
        prc->top += m_rgTBar[i].rcBorderTool.top;
        prc->right -= m_rgTBar[i].rcBorderTool.right;
        prc->bottom -= m_rgTBar[i].rcBorderTool.bottom;
        }

    return (S_OK);
}

HRESULT CBrowser::GetLayout(PLAYOUT playout)
{
    Assert(playout);
    if (playout->cbSize != sizeof(LAYOUT))
        return(E_FAIL);

    Assert(m_rLayout.cbSize == sizeof(LAYOUT));
    CopyMemory(playout, &m_rLayout, sizeof(LAYOUT));

    return (S_OK);
}

HRESULT CBrowser::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText)
{
    ULONG               cServer;
    HRESULT             hr = S_OK;

    // ATTENZIONE!
    // the view gets it first because it might want to handle a command that the treeview normally
    // handles. this is really only necessary for acct views where folders are displayed in the right
    // pane, and folder-related commands should work on the selected folder and not the current 
    // treeview selection

    // View always get's it
    if (m_pViewCT)
    {
        m_pViewCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // TreeView always get's it
    if (m_pTreeView)
    {
        m_pTreeView->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // Contact's get's it
    if (m_pNavPane)
    {
        m_pNavPane->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText, (m_ftSel != FOLDER_NEWS));

    // Loop through the list looking for commands the view didn't handle
    for (ULONG i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // Handle the Send and Receive popup menu
            if (prgCmds[i].cmdID >= ID_ACCOUNT_FIRST && prgCmds[i].cmdID<= ID_ACCOUNT_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            // Envelope stuff
            if (prgCmds[i].cmdID >= ID_ENVELOPE_HOST_FIRST && prgCmds[i].cmdID <= ID_ENVELOPE_HOST_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            if (prgCmds[i].cmdID >= ID_NEW_ACCT_FIRST && prgCmds[i].cmdID <= ID_NEW_ACCT_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            // Regular commands
            switch (prgCmds[i].cmdID)
            {
                case ID_WORK_OFFLINE:
                {
                    // Always enabled and supported
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    if (g_pConMan->IsGlobalOffline())
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;
                    break;
                }
                        
                case ID_SEND_RECEIVE:
                    if (g_dwAthenaMode & MODE_NEWSONLY)
                    {
                        //We want to leave it enabled;
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        break;
                    }
                    //Fall through. In News Only mode we want to do Send All even for Send & Receive All
                case ID_POPUP_ENVELOPE_HOST:
                case ID_RECEIVE_ALL:
                {
                    // At least one SMTP server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cServer)))
                    {
                        if (cServer)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_SEND_ALL:                
                {
                    DWORD cMail = 0, cNews = 0;

                    // At least one SMTP server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cMail)) && 
                        SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_NEWS, &cNews)))
                    {
                        if (cMail || cNews)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_IMAP_FOLDERS:
                {
                    // At least one news server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cServer)))
                    {
                        if (cServer)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_FOLDER_LIST:
                {
                    // Always enabled
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    // Is it checked?
                    if (m_rLayout.fFolderList)
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;

                    break;
                }

                case ID_CONTACTS_LIST:
                {
                    // enabled only when not in outnews mode
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    
                    if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    }

                    // Is it checked?
                    if (m_rLayout.fContacts)
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;

                    break;
                }

                case ID_EXIT_LOGOFF:
                case ID_LOGOFF_IDENTITY:
                {
                    if (MU_CountUsers() > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_DELETE_ACCEL:
                case ID_DELETE_NO_TRASH_ACCEL:
                {
                    IOleCommandTarget *pTarget = NULL;    
                    OLECMD cmd = { 0 };

                    // Check to see if it's the treeview
                    if (S_OK == m_pTreeView->HasFocusIO())
                    {
                        pTarget = m_pTreeView;
                    }

                    // Check to see if it's anything else on the Info Column
                    else if (m_pNavPane->IsContactsFocus())
                    {
                        pTarget = m_pNavPane;
                        cmd.cmdID = ID_DELETE_CONTACT;
                    }

                    // Otherwise, it must be the view
                    else
                    {
                        pTarget = m_pViewCT;
                        if (prgCmds[i].cmdID == ID_DELETE_NO_TRASH_ACCEL)
                            cmd.cmdID = ID_DELETE_NO_TRASH;
                        else
                            cmd.cmdID = ID_DELETE;
                    }

                    // Hit the target with the right command
                    if (pTarget)
                    {
                        pTarget->QueryStatus(NULL, 1, &cmd, NULL);
                        prgCmds[i].cmdf = cmd.cmdf;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_UP_ONE_LEVEL:
                    if (m_idSelected != FOLDERID_ROOT)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SHOW_TOOLBAR:
                case ID_SHOW_FILTERBAR:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            
                case ID_SWITCH_IDENTITY:
                case ID_IDENTITIES:
                case ID_MANAGE_IDENTITIES:
                case ID_NEW_IDENTITY:
                    if (((g_dwAthenaMode & MODE_OUTLOOKNEWS) == MODE_OUTLOOKNEWS) && (MU_CountUsers() <= 1))
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MESSAGE_RULES_MAIL:
                case ID_POPUP_NEW_ACCT:
                    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MESSAGE_RULES_JUNK:
                    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else if (g_dwAthenaMode & MODE_JUNKMAIL)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                // always enabled

                // File Menu
                case ID_POPUP_NEW:
                case ID_POPUP_FOLDER:
                case ID_POPUP_IMPORT:
                case ID_POPUP_EXPORT:
                case ID_POPUP_USERS:
                case ID_IMPORT_ADDRESS_BOOK:
                case ID_IMPORT_WAB:
                case ID_IMPORT_MESSAGES:
                case ID_IMPORT_MAIL_ACCOUNTS:
                case ID_IMPORT_NEWS_ACCOUNTS:
                case ID_IMPORT_RULES:
                case ID_EXPORT_ADDRESS_BOOK:
                case ID_EXPORT_MESSAGES:
                case ID_EXPORT_RULES:
                case ID_EXIT:

                // Edit Menu
                case ID_POPUP_FIND:
                case ID_FIND_MESSAGE:
                case ID_FIND_PEOPLE:

                // View Menu
                case ID_POPUP_TOOLBAR:
                case ID_POPUP_NEXT:
                case ID_LAYOUT:
                case ID_CUSTOMIZE:

                // Go Menu
                case ID_GO_INBOX:
                case ID_GO_NEWS:
                case ID_GO_FOLDER:
                case ID_GO_NETMEETING:
                case ID_GO_OUTBOX:
                case ID_GO_SENT_ITEMS:
                case ID_GO_DRAFTS:

                // Message Menu

                // Tools
                case ID_POPUP_SEND_AND_RECEIVE:
                case ID_SYNCHRONIZE:
                case ID_ADDRESS_BOOK:
                case ID_POPUP_RULES:
                //case ID_MESSAGE_RULES_MAIL:
                case ID_MESSAGE_RULES_NEWS:
                //case ID_MESSAGE_RULES_JUNK:
                case ID_MESSAGE_RULES_SENDERS:
                case ID_OPTIONS:
                case ID_ACCOUNTS:

                // Help
                case ID_HELP_CONTENTS:
                case ID_README:
                case ID_POPUP_MSWEB:
                case ID_MSWEB_FREE_STUFF:
                case ID_MSWEB_PRODUCT_NEWS:
                case ID_MSWEB_FAQ:
                case ID_MSWEB_SUPPORT:
                case ID_MSWEB_FEEDBACK:
                case ID_MSWEB_BEST:
                case ID_MSWEB_SEARCH:
                case ID_MSWEB_HOME:
                case ID_MSWEB_HOTMAIL:
                case ID_ABOUT:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            }
        }
    }

    return S_OK;
}


HRESULT CBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    AssertSz(FALSE, "NYI");
    return (E_NOTIMPL);
}

////////////////////////////////////////////////////////////////////////
//
//  ITreeViewNotify
//
////////////////////////////////////////////////////////////////////////

void CBrowser::OnSelChange(FOLDERID idFolder)
{
    HRESULT        hr = S_OK;
    IViewWindow   *pNewView = NULL;
    BOOL           fViewFocus = FALSE;

    // don't refresh if the pidls match
    if (m_pView)
        {
        if (idFolder == m_idSelected)
            return;
        }

    // Get Focus
    HWND hwndFocus = GetFocus();
    fViewFocus = (IsWindow(m_hwndInner) && IsChild(m_hwndInner, hwndFocus));

    // hold on to the current pidl
    m_idSelected = idFolder;

    SetFolderType(idFolder);

    hr = CreateFolderViewObject(m_idSelected, m_hwnd, IID_IViewWindow, (LPVOID *)&pNewView);
    if (SUCCEEDED(hr))
    {
        IViewWindow *pOldView;

        if (m_pView)
            hr = m_pView->SaveViewState();

        if (SUCCEEDED(hr))
        {
            RECT rc;
            HWND hwnd;

            // Release the old command target
            if (m_pViewCT)
            {
                m_pViewCT->Release();
                m_pViewCT = NULL;
            }

            pOldView = m_pView;
            m_pView = pNewView;

            GetViewRect(&rc);
            hr = pNewView->CreateViewWindow(pOldView, (IAthenaBrowser*)this, &rc, &hwnd);
            if (SUCCEEDED(hr))
            {
                if (pOldView)
                    {
                    pOldView->UIActivate(SVUIA_DEACTIVATE);
                    pOldView->DestroyViewWindow();
                    pOldView->Release();                        
                    }

                m_pView->AddRef();

                // Get the command target interface for the new view.  If it fails, 
                // we can proceed, we just can't send commands.
                if (FAILED(m_pView->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pViewCT)))
                {
                    // Make sure that m_pViewCT is NULL
                    m_pViewCT = NULL;
                }

                m_hwndInner = hwnd;
                m_pView->UIActivate(SVUIA_ACTIVATE_FOCUS);
                if (m_itbLastFocus == ITB_NONE || m_itbLastFocus == ITB_OEVIEW || fViewFocus)
                    {
                    SetFocus(m_hwndInner);
                    m_itbLastFocus = ITB_OEVIEW;
                    }
                UpdateToolbar();
                
                if (m_pCoolbar)
                    m_pCoolbar->UpdateViewState();
            }
            else
            {
                // Bug #20855 - If we failed to browse, try to navigate to the root
                //              instead.  If we failed to browse to the root, then 
                //              we should just leave the view empty.
                m_pView = pOldView;
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFailedNavigate),
                              0, MB_OK | MB_ICONSTOP);
                BrowseObject(FOLDERID_ROOT, NULL);
            }

/*
            if (m_ftSel != FOLDER_HTTPMAIL)
            {
                if (m_pAdBar)
                    ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);

                if (m_pBodyBar)
                    ShowToolbar((IUnknown *) (IDockingWindow *) m_pBodyBar, m_rLayout.fInfoPane);
            }
            else
            {
                if (m_pBodyBar && m_rLayout.fInfoPane)
                    ShowToolbar((IUnknown *) (IDockingWindow *)m_pBodyBar, FALSE);

                if (m_pAdBar && m_pAdBar->fValidUrl())
                {
                    ShowToolbar((IDockingWindow*)m_pAdBar, TRUE);
                }
            }
*/
        }
        SafeRelease(pNewView);
    }

}

void CBrowser::OnRename(FOLDERID idFolder)
    {
    m_idSelected = idFolder;
    SetFolderType(idFolder);
    }

void CBrowser::OnDoubleClick(FOLDERID idFolder)
    {
    return;
    }

HRESULT CBrowser::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                     CConnectionManager *pConMan)
{
    PostMessage(m_hwnd, CM_UPDATETOOLBAR, 0, 0L);
    
    if (CONNNOTIFY_WORKOFFLINE == nCode)
    {
        if (NULL != pvData)
        {
            if (m_pStatus)
                m_pStatus->SetConnectedStatus(CONN_STATUS_WORKOFFLINE);
        }
        else 
        {
            if (m_pStatus)
                m_pStatus->SetConnectedStatus(CONN_STATUS_CONNECTED);
        }
    }
    else 
    if ((CONNNOTIFY_USER_CANCELLED == nCode) || (CONNNOTIFY_CONNECTED == nCode))
    {
        PostMessage(m_hwnd, WM_COMMAND, MAKEWPARAM(ID_RESYNCHRONIZE, 0), 0);
    }
    
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////
//
//  Message Handling
//
////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CBrowser::BrowserWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT      lRet;
    CBrowser    *pThis;
    LRESULT     lres;
    MSG         Menumsg;

    if (msg == WM_NCCREATE)
        {
        pThis = (CBrowser*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
        }
    else
        {
        pThis = (CBrowser*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (msg == WM_NCDESTROY)
            {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)0);
            pThis->Release();
            
            // If this shutdown is due to an identity switch...
            if (s_fQuickShutdown)
            {
                if (NULL != g_pInstance)
                {
                    // ... break out of the message loop in COutlookExpress::Start
                    g_pInstance->SetSwitchingUsers(TRUE);
                }
                
                s_fQuickShutdown = FALSE;
            }

            return 0;
            }
        }

    Menumsg.hwnd    = hwnd;
    Menumsg.message = msg;
    Menumsg.wParam  = wParam;
    Menumsg.lParam  = lParam;

    if (pThis && (pThis->TranslateMenuMessage(&Menumsg, &lres) == S_OK))
        return lres;
    
    wParam = Menumsg.wParam;
    lParam = Menumsg.lParam;

    if (pThis)
        return pThis->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

LRESULT CBrowser::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int         i;
    HWND        hwndActive;

    switch (msg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_INITMENUPOPUP,  OnInitMenuPopup);
        HANDLE_MSG(hwnd, WM_COMMAND,        OnCommand);

        
        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, (NULL != wParam), ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case WM_OESETFOCUS:
            if (IsWindow((HWND) wParam) && IsWindowVisible((HWND) wParam))
                SetFocus((HWND) wParam);
            break;

        case CBM_POSTCREATE:
            DOUTL(2, "CBM_POSTCREATE: GetTickCount() = %ld", GetTickCount());

            UpdateWindow(m_hwnd);
            UpdateStatusBar();
            m_fPainted = TRUE;

            if (m_pTreeView)
            {
                m_pTreeView->Refresh();

                if (!g_pConMan->IsGlobalOffline())
                    g_pConMan->DoOfflineTransactions();

                // Set the focus to the view
                m_itbLastFocus = ITB_OEVIEW;

                m_pTreeView->SetSelection(m_idSelected, TVSS_INSERTIFNOTFOUND);
            }

            if (g_pConMan)
                g_pConMan->OnActivate(TRUE);

            ProcessIncompleteAccts(m_hwnd);

            Assert(g_pSpooler);

            if (g_pSpooler)
                g_pSpooler->Advise(m_hwnd, TRUE);


            // Tell the spooler we're done init'ing
            if (g_pSpooler)
            {
                //safe fix for Bug#8149
                g_pSpooler->OnStartupFinished();
            }

            if (g_pSpooler)
            {
                if (!!DwGetOption(OPT_POLLFORMSGS_ATSTARTUP))
                {
                    DWORD   dwFlags;

                    dwFlags = (!(g_dwAthenaMode & MODE_NEWSONLY)) ? DELIVER_NO_NEWSPOLL : 0;

                    g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                        
                        dwFlags | DELIVER_SEND | DELIVER_MAIL_RECV | DELIVER_POLL | 
                        DELIVER_DIAL_ALWAYS | DELIVER_BACKGROUND | 
                        DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL);
                }
            }

            return 0;

        case CM_UPDATETOOLBAR:
            UpdateToolbar();
            return 0;

        case WM_UPDATELAYOUT:
            {
            if (m_itbLastFocus == ITB_TREE)
                CycleFocus(FALSE);

            // Update our view to reflect these new options
            if (m_pFolderBar)
                m_pFolderBar->Update(FALSE, TRUE);

            if (m_rgTBar[ITB_FOLDERBAR].fShow != m_rLayout.fFolderBar)
                {
                m_rgTBar[ITB_FOLDERBAR].fShow = !m_rgTBar[ITB_FOLDERBAR].fShow;
                m_rgTBar[ITB_FOLDERBAR].ptbar->ShowDW(m_rgTBar[ITB_FOLDERBAR].fShow);
                }

            }
            return 0;

        case WM_PAINT:
            DOUTL(2, "WM_PAINT: GetTickCount() = %ld", GetTickCount());
            // if we don't have a shell view, paint a "clientedge window" instead
            if (!m_pView)
                {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;
                HBRUSH      hBrush;

                GetViewRect(&rc);
                hdc = BeginPaint(hwnd, &ps);
                DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT|BF_ADJUST);
                hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
                SelectBrush(hdc, hBrush);
                EndPaint(hwnd, &ps);
                return 0;
                }
            break;

        case WM_DISPLAYCHANGE:
            {
            WINDOWPLACEMENT wp;
            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetWindowPlacement(hwnd, &wp);
            }
            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_FONTCHANGE:
            DeinitMultiLanguage();
        // fail thru
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            // tell the toolbars Minus one coz we inform the InfoColumn seperately
            for (i=0; i<ITB_MAX - 1; i++) 
                {
                HWND hwndToolbar;
                if (m_rgTBar[i].ptbar && SUCCEEDED(m_rgTBar[i].ptbar->GetWindow(&hwndToolbar)))
                    SendMessage(hwndToolbar, msg, wParam, lParam);
                }            

            // Someone changed the default mail client.
#if 0
            // The mapistub gets quite upset if you unload it while it has an active mapi
            // call running
            if (g_hlibMAPI && lParam && !lstrcmpi((LPSTR) lParam, "Software\\Clients\\Mail"))
            {
                FreeLibrary(g_hlibMAPI);
                g_hlibMAPI = 0;
            }
#endif

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_MENUSELECT:
            if (LOWORD(wParam) >= ID_STATIONERY_RECENT_0 && LOWORD(wParam) <= ID_STATIONERY_RECENT_9)
                {
                m_pStatus->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
                return 0;
                }

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_NOTIFY:
            if (IDC_STATUS_BAR == wParam && lParam)
                {
                m_pStatus->OnNotify((NMHDR *) lParam);
                }

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_EXITMENULOOP:
        case WM_ENTERMENULOOP:
        case WM_ENTERSIZEMOVE:
        case WM_EXITSIZEMOVE:
        case WM_TIMECHANGE:
            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_SETFOCUS:
            break;

        case WM_INITMENU:
            CancelGlobalDropDown();
            break;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }

            FrameActivatePopups(NULL != wParam);
            break;

        case WM_SYSCOMMAND:
            // if we're minimizing, get the control with focus, as when we get the 
            // next WM_ACTIVATE we will already be minimized
            if (wParam == SC_MINIMIZE)
                m_hwndLastFocus = GetFocus();
            break;

        case WM_ACTIVATE:
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                if (!HIWORD(wParam))
                {
                    // save the control with the focus don't do this is we're
                    // minimized, otherwise GetFocus()==m_hwnd
                    m_hwndLastFocus = GetFocus();
                }
                if (g_pConMan)
                    g_pConMan->OnActivate(FALSE);
                FrameActivatePopups(FALSE);
            }
            else
            {
                HWND hwndFocus;
                if (m_hwndLastFocus && IsWindow(m_hwndLastFocus) && IsChild(hwnd, m_hwndLastFocus))
                    SetFocus(m_hwndLastFocus);
                else if (m_rgTBar[ITB_TREE].fShow && SUCCEEDED(m_rgTBar[ITB_TREE].ptbar->GetWindow(&hwndFocus)))
                    SetFocus(hwndFocus);
                else if (m_hwndInner)
                    SetFocus(m_hwndInner);
                
                if (g_pConMan && m_fPainted)
                    g_pConMan->OnActivate(TRUE);
                
                FrameActivatePopups(FALSE);
            }
            
            if (m_pView)
            {
                // If the inner window is a message view, we need to hit it with
                // a OnFrameWindowAcivate() so the preview pane get's updated 
                // correctly.
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->OnFrameWindowActivate(LOWORD(wParam) != WA_INACTIVE);
                    pWindow->Release();
                }
            }

            return 0;
        
        case WM_ENDSESSION:
            if (wParam)
                {
                DOUTL(2, "CBrowser::WM_ENDSESSION");
                // g_fCheckOutboxOnShutdown = FALSE;
                SendMessage(hwnd, WM_CLOSE, 0, 0L);
                }
            return 0;

        case PUI_OFFICE_COMMAND:
            if(wParam == PLUGUI_CMD_QUERY)
            {
                PLUGUI_QUERY pq;

                pq.uQueryVal = 0; // initialize
                pq.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9; // Value filled in by Apps
                pq.PlugUIInfo.uOleServer = FALSE;              // Value filled in by Apps

                return (pq.uQueryVal); // The state of the App
            }
            if(wParam != PLUGUI_CMD_SHUTDOWN)
                return(0);

            // for PLUGUI_CMD_SHUTDOWN fall to close application
            CloseFinderTreads();
            CloseThreadWindows(hwnd, GetCurrentThreadId());

        case WM_CLOSE:
            {
            WINDOWPLACEMENT wp;

            // WriteUnreadCount();
            AcctUtil_FreeSendReceieveMenu(m_hMenu, m_cAcctMenu);
            FreeNewAcctMenu(m_hMenu);

            // Close any active RAS connections we brought up
            if (g_pConMan)
                {
                // Release our notification for connection changes
                g_pConMan->Unadvise(this);
                }

            if (g_pSpooler)
                g_pSpooler->Advise(m_hwnd, FALSE);

            if (m_pView)
                {
                FOLDERSETTINGS fs;
                if (m_pViewCT)
                {
                    m_pViewCT->Release();
                    m_pViewCT = NULL;
                }
                m_pView->SaveViewState();
                m_pView->UIActivate(SVUIA_DEACTIVATE);
                m_hwndInner = NULL;
                m_pView->DestroyViewWindow();
                m_pView->Release();
                m_pView = NULL;
                }

           if (DwGetOption(OPT_PURGEWASTE))
               EmptySpecialFolder(hwnd, FOLDER_DELETED);

            // clean up the toolbars
            for (i=0; i<ITB_MAX; i++) 
                {
                if (m_rgTBar[i].ptbar)
                    ReleaseToolbarItem(i, TRUE);
                }

            // save browser settings
            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetOption(OPT_BROWSERPOS, (LPVOID)&wp, sizeof(wp), NULL, 0);

            if (m_idClearStatusTimer)
                KillTimer(m_hwnd, m_idClearStatusTimer);
            
            SaveLayoutSettings();

            //Let the DocObj know that the browser is dying
            if (m_pDocObj)
            {
                m_pDocObj->BrowserExiting();
            }

            // Unregister with Identity manager
            if (m_dwIdentCookie != 0)
            {
                MU_UnregisterIdentityNotifier(m_dwIdentCookie);
                m_dwIdentCookie = 0;
            }

            DestroyWindow(hwnd);
            }
            return 0;

        case WM_NEW_MAIL:
            Assert(0 == wParam);
            Assert(0 == lParam);

            // Add the tray icon
            if (g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_ADD);

            // Play a sound
            if (DwGetOption(OPT_NEWMAILSOUND) != 0)
            {
                if (!sndPlaySound((LPTSTR) s_szMailSndKey, SND_ASYNC | SND_NODEFAULT))
                    MessageBeep(MB_OK);
            }
            return 0;

        case MVM_NOTIFYICONEVENT:
            if (lParam == WM_LBUTTONDBLCLK)
                {
                if (IsIconic(m_hwnd))
                    ShowWindow(m_hwnd, SW_RESTORE);
                SetForegroundWindow(m_hwnd);
                }
            return 0;

        case MVM_SPOOLERDELIVERY:
            SpoolerDeliver(wParam, lParam);
            return 0;

        case WM_TIMER:
            if (wParam == TIMER_CLEAR_STATUS)
            {
                KillTimer(m_hwnd, m_idClearStatusTimer);
                m_idClearStatusTimer = 0;
                if (m_pStatus)
                    m_pStatus->SetSpoolerStatus(DELIVERY_NOTIFY_COMPLETE, 0);                    
            }
            return 0;

        case WM_DESTROY:
            {
#if 0
            // We need to free our menu resource
            HMENU hMenu = GetMenu(m_hwnd);
            //SetMenu(m_hwnd, NULL);
            DestroyMenu(hMenu);
#endif
            RemoveProp(hwnd, c_szOETopLevel);
            break;
            }

        }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//
//  FUNCTION:   CBrowser::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to 
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CBrowser::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    // Spooler comes first
    g_fCheckOutboxOnShutdown = TRUE;

    m_hwnd = hwnd;

    // Set the title bar icon to the mailnews icon
    UINT idRes = (g_dwAthenaMode & MODE_NEWSONLY) ? idiNewsGroup : idiMailNews;

    m_hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idRes), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idRes), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    m_pStatus = new CStatusBar();
    if (!m_pStatus)
        goto error;

    m_pStatus->Initialize(m_hwnd, 0);
    m_pStatus->ShowStatus(m_rLayout.fStatusBar);

    // Init the menu bar
    m_hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_BROWSER_MENU));

    MenuUtil_ReplaceHelpMenu(m_hMenu);
    MenuUtil_ReplaceNewMsgMenus(m_hMenu);
    MenuUtil_ReplaceMessengerMenus(m_hMenu);

    // Register for connection changes
    if (g_pConMan)
        g_pConMan->Advise((IConnectionNotify *) this);

    // Create all our toolbar windows
    if (!_InitToolbars())
        goto error;
    
    // Initialize the folder bar
    SetFolderType(NULL);
    m_pFolderBar->Update(FALSE, TRUE);

    // Post this so we can do post creation init
    PostMessage(m_hwnd, CBM_POSTCREATE, 0, 0L);
    return TRUE;

error:
    return FALSE;
}


//
//  FUNCTION:   CBrowser::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area. 
//      cyClient - New height of the client area.
//
void CBrowser::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    if (state != SIZE_MINIMIZED)
        {
        if (m_pStatus)
            m_pStatus->OnSize(cxClient, cyClient);    
        ResizeNextBorder(0);
        }
}

HRESULT CBrowser::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    ACCTTYPE    type;
    RULEID      ridTag;

    Assert(m_pTreeView != NULL);
    if (S_OK == m_pTreeView->ForceSelectionChange())
    {
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(id, codeNotify), (LPARAM)hwndCtl);
        return(S_OK);
    }

    // Check to see if the command is even enabled
    OLECMD cmd;
    cmd.cmdID = id;
    cmd.cmdf = 0;

    HRESULT hr = QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL);
    if (FAILED(hr) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (OLECMDERR_E_DISABLED);

    // Give the view first chance at any command so that it can override 
    // browser behavior.
    VARIANTARG va;

    va.vt = VT_I8;
    va.ullVal = (ULONGLONG)hwndCtl;

    // ATTENZIONE!
    // the view gets it first because it might want to handle a command that the treeview normally
    // handles. this is really only necessary for acct views where folders are displayed in the right
    // pane, and folder-related commands should work on the selected folder and not the current 
    // treeview selection

    // We should always allow the views to see the command list.
    if (m_pViewCT && SUCCEEDED(hr = m_pViewCT->Exec(&CMDSETID_OutlookExpress, id, OLECMDEXECOPT_DODEFAULT, &va, NULL)))
        return (S_OK);

    // Infocolumn always get's a chance
    if (m_pTreeView && SUCCEEDED(hr = m_pTreeView->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
        return (S_OK);

    // Infocolumn always get's a chance
    if (m_pNavPane && SUCCEEDED(hr = m_pNavPane->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
        return (S_OK);

    // $REVIEW - Why should we route commands to a toolbar?
    if (m_pCoolbar && (m_pCoolbar->OnCommand(hwnd, id, hwndCtl, codeNotify) == S_OK))
        return S_OK;    

    if (Envelope_WMCommand(hwnd, id, (WORD) codeNotify)== S_OK)
        return S_OK;

    // Handle the extra help menu commands
    if (id > ID_MSWEB_BASE && id < ID_MSWEB_LAST)
    {
        OnHelpGoto(m_hwnd, id);
        return S_OK;
    }

    // Handle the Receive From... popup menu
    if (id >= ID_ACCOUNT_FIRST && id <= ID_ACCOUNT_LAST)
    {
        Assert(g_pSpooler);
        CmdSendReceieveAccount(id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        return (S_OK);
    }

    if (id >= ID_NEW_ACCT_FIRST && id <= ID_NEW_ACCT_LAST)
    {
        HandleNewAcctMenu(m_hwnd, m_hMenu, id);
        return(S_OK);
    }

    // Handle all "create new note" IDs
    if (MenuUtil_HandleNewMessageIDs(id, m_hwnd, m_idSelected, m_ftSel != FOLDER_NEWS, FALSE, NULL))
        return S_OK;

    switch (id)
    {
        // File Menu
        case ID_EXPORT_ADDRESS_BOOK:
        case ID_IMPORT_ADDRESS_BOOK:
            MailUtil_OnImportExportAddressBook(m_hwnd, id == ID_IMPORT_ADDRESS_BOOK);
            break;

        case ID_IMPORT_WAB:
            ImportWAB(m_hwnd);
            break;

        case ID_IMPORT_MESSAGES:
            DoImport(m_hwnd);
            break;

        case ID_IMPORT_MAIL_ACCOUNTS:
        case ID_IMPORT_NEWS_ACCOUNTS:
            DoAcctImport(m_hwnd, id == ID_IMPORT_MAIL_ACCOUNTS);
            break;

        case ID_EXPORT_MESSAGES:
            DoExport(m_hwnd);
            break;

        case ID_IMPORT_RULES:
            RuleUtil_HrImportRules(m_hwnd);
            break;

        case ID_EXPORT_RULES:
            RuleUtil_HrExportRules(m_hwnd);
            break;

        case ID_NEW_IDENTITY:
            MU_NewIdentity(m_hwnd);
            break;

        case ID_SWITCH_IDENTITY:
            MU_Login(m_hwnd, TRUE, NULL);
            break;
        
        case ID_EXIT_LOGOFF:
        case ID_LOGOFF_IDENTITY:
            MU_Logoff(m_hwnd);
            break;

        case ID_MANAGE_IDENTITIES:
            MU_ManageIdentities(m_hwnd);
            break;

        case ID_EXIT:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0L);
            break;

        case ID_WORK_OFFLINE:
            if (g_pConMan)
            {
                g_pConMan->SetGlobalOffline(!g_pConMan->IsGlobalOffline(), hwnd);
                UpdateToolbar();
            }
            break;


        // Edit Menu
        case ID_FIND_MESSAGE:
            DoFindMsg(m_idSelected, FOLDER_LOCAL);
            break;

        case ID_FIND_PEOPLE:
        {
            TCHAR szWABExePath[MAX_PATH];
            if(S_OK == HrLoadPathWABEXE(szWABExePath, sizeof(szWABExePath)))
                ShellExecute(NULL, "open", szWABExePath, "/find", "", SW_SHOWNORMAL);
            break;
        }

        // View Menu
        case ID_LAYOUT:
        {
            LayoutProp_Create(m_hwnd, this, &m_rLayout);
            break;
        }

        case ID_SHOW_TOOLBAR:
        {
            SetViewLayout(DISPID_MSGVIEW_TOOLBAR, LAYOUT_POS_NA, !m_rLayout.fToolbar, 0, 0);
            break;
        }

        case ID_SHOW_FILTERBAR:
        {
            SetViewLayout(DISPID_MSGVIEW_FILTERBAR, LAYOUT_POS_NA, !m_rLayout.fFilterBar, 0, 0);
            break;
        }

        // Go Menu
        case ID_UP_ONE_LEVEL:
            Assert(m_ftSel != FOLDER_ROOTNODE);
            m_pTreeView->SelectParent();
            break;

        case ID_GO_FOLDER:
        {
            FOLDERID idFolder;
            if (SUCCEEDED(SelectFolderDialog(m_hwnd, SFD_SELECTFOLDER, FOLDERID_ROOT, NOFLAGS, MAKEINTRESOURCE(idsGoToFolderTitle), MAKEINTRESOURCE(idsGoToFolderText), &idFolder)))
                BrowseObject(idFolder, 0);
            break;
        }

        case ID_GO_INBOX:
            // special case this for newsonly mode
            if (g_dwAthenaMode & MODE_NEWSONLY)
            {
                ShellUtil_RunClientRegCommand(m_hwnd, s_szMailClient);
            }
            else
                // fall through

        case ID_GO_OUTBOX:
        case ID_GO_SENT_ITEMS:
        case ID_GO_DRAFTS:
        {
            FOLDERID        idStore;
            FOLDERINFO      Folder;
            SPECIALFOLDER   sf;
    
            if (id == ID_GO_OUTBOX)
                sf = FOLDER_OUTBOX;
            else if (id == ID_GO_INBOX)
                sf = FOLDER_INBOX;
            else if (id == ID_GO_SENT_ITEMS)
                sf = FOLDER_SENT;
            else
                sf = FOLDER_DRAFT;

            if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                idStore = FOLDERID_LOCAL_STORE;

            if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, sf, &Folder)))
            {
                BrowseObject(Folder.idFolder, SBSP_DEFBROWSER | SBSP_DEFMODE | SBSP_ABSOLUTE);
                g_pStore->FreeRecord(&Folder);
            } 
            else
            {
                // We might not have this special folder for this account.  Try local.
                if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, sf, &Folder)))
                {
                    BrowseObject(Folder.idFolder, SBSP_DEFBROWSER | SBSP_DEFMODE | SBSP_ABSOLUTE);
                    g_pStore->FreeRecord(&Folder);
                }
            }

            break;
        }

        case ID_GO_NEWS:
        {
            if (g_dwAthenaMode & MODE_MAILONLY)
            {
                ShellUtil_RunClientRegCommand(m_hwnd, s_szNewsClient);
            }
            else
            {
                FOLDERID idServer;

                ProcessICW(m_hwnd, FOLDER_NEWS, TRUE);

                if (SUCCEEDED(GetDefaultServerId(ACCT_NEWS, &idServer)))
                {
                    BrowseObject(idServer, 0);
                }
            }

            break;
        }

        case ID_GO_NETMEETING:
            ShellUtil_RunClientRegCommand(m_hwnd, s_szCallClient);
            break;

        // Tools Menu
        case ID_SEND_RECEIVE:
            Assert(g_pSpooler);

            if (!(g_dwAthenaMode & MODE_NEWSONLY))
            {
                if (g_pSpooler)
                {
                    DWORD   dwFlags = 0;

                    dwFlags = (!(g_dwAthenaMode & MODE_NEWSONLY)) ? DELIVER_NO_NEWSPOLL : 0;

                    g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                        dwFlags | DELIVER_SEND | DELIVER_MAIL_RECV | 
                        DELIVER_POLL | DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL);
                }
                // $REVIEW -  Can someone explain why it's here??? - steveser
                // Tell currently selected folder to refresh itself
                // if (NULL != m_pViewCT)
                //     m_pViewCT->Exec(NULL, ID_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                break;
            }
            //Fall through. In News only mode we want to do Send All even for Send & Receive All
        case ID_SEND_ALL:
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                    DELIVER_SEND | DELIVER_NOSKIP | DELIVER_NEWS_TYPE | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE);
            break;

        case ID_RECEIVE_ALL:
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                    DELIVER_MAIL_RECV | DELIVER_POLL | DELIVER_OFFLINE_FLAGS | DELIVER_IMAP_TYPE | 
                    DELIVER_HTTP_TYPE);
            break;

        case ID_SYNCHRONIZE:
        {
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID, DELIVER_OFFLINE_SYNC | DELIVER_UPDATE_ALL);
            
            /*
            Bug# 60668
            // Tell currently selected folder to refresh itself
            if (NULL != m_pViewCT)
                m_pViewCT->Exec(NULL, ID_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
            */
            break;
        }

        case ID_ADDRESS_BOOK:
        {
            CWab *pWab = NULL;
            if (SUCCEEDED(HrCreateWabObject(&pWab)))
            {
                pWab->HrBrowse(m_hwnd);
                pWab->Release();
            }
            else
            {
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                              NULL, MB_OK | MB_ICONEXCLAMATION);
            }
            break;
        }

        case ID_MESSAGE_RULES_MAIL:
        case ID_MESSAGE_RULES_NEWS:
        case ID_MESSAGE_RULES_JUNK:
        case ID_MESSAGE_RULES_SENDERS:
        {
            DWORD   dwFlags = 0;
            switch (id)
            {
                case ID_MESSAGE_RULES_MAIL:
                    dwFlags = MRDF_MAIL;
                    break;

                case ID_MESSAGE_RULES_NEWS:
                    dwFlags = MRDF_NEWS;
                    break;

                case ID_MESSAGE_RULES_JUNK:
                    dwFlags = MRDF_JUNK;
                    break;

                case ID_MESSAGE_RULES_SENDERS:
                    dwFlags = MRDF_SENDERS;
                    break;

                default:
                    Assert(FALSE);
                    dwFlags = MRDF_MAIL;
                    break;
            }
            DoMessageRulesDialog(m_hwnd, dwFlags);
            break;
        }
        
        case ID_OPTIONS:
            ShowOptions(hwnd, ATHENA_OPTIONS, 0, this);
            break;

        case ID_ACCOUNTS:
        {
            if (m_ftSel == FOLDER_NEWS)
                type = ACCT_NEWS;
            else if (m_ftSel == FOLDER_IMAP || m_ftSel == FOLDER_LOCAL)
                type = ACCT_MAIL;
            else
                type = ACCT_LAST;

            DoAccountListDialog(m_hwnd, type);
            break;
        }

        // HELP MENU COMMANDS
        case ID_HELP_CONTENTS:
            OEHtmlHelp(m_hwnd, c_szMailHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) c_szCtxHelpDefault);
            break;
            
        case ID_README:
            DoReadme(m_hwnd);
            break;
        
        case ID_ABOUT:
            DoAboutAthena(m_hwnd, m_ftSel == FOLDER_NEWS ? idiNews : idiMail);
            break;

        // Toolbar Buttons & Accelerators
        case ID_FOLDER_LIST:
            if (m_itbLastFocus == ITB_NAVPANE)
                CycleFocus(FALSE);

            SetViewLayout(DISPID_MSGVIEW_FOLDERLIST, LAYOUT_POS_NA, !m_rLayout.fFolderList, 0, 0);

            if (m_pFolderBar)
                m_pFolderBar->Update(FALSE, TRUE);
            break;

        case ID_CONTACTS_LIST:
            if (m_itbLastFocus == ITB_NAVPANE)
                CycleFocus(FALSE);

            SetViewLayout(DISPID_MSGVIEW_CONTACTS, LAYOUT_POS_NA, !m_rLayout.fContacts, 0, 0);
            break;

        // $REVIEW - Do we still need this?
        /*
        case idmAccelNextCtl:
        case idmAccelPrevCtl:
            CycleFocus(id == idmAccelPrevCtl);
            break;
        */

        case ID_DELETE_ACCEL:
        case ID_DELETE_NO_TRASH_ACCEL:
            return (CmdDeleteAccel(id, OLECMDEXECOPT_DODEFAULT, NULL, NULL));

        //Msglist handles this command. But if our view is frontpage or account view, this is not handled by them.
        //So we break here so we don't show NYI.
        case ID_RESYNCHRONIZE:
          break;

        default:
#ifdef DEBUG
            if (!hwndCtl || codeNotify == BN_CLICKED)
                nyi(MAKEINTRESOURCE(idsNYIGeneral));
#endif
            return E_NOTIMPL;
        }
    return S_OK;
}


#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b ? MF_CHECKED : MF_UNCHECKED))

void CBrowser::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    char            sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    MENUITEMINFO    mii;
    UINT            uIDPopup;
    HMENU           hMenuLang;
    FOLDERINFO      info;
    HRESULT         hr;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    // make sure we recognize the popup as one of ours
    if (m_hMenu == NULL || !GetMenuItemInfo(m_hMenu, uPos, TRUE, &mii) || mii.hSubMenu != hmenuPopup)
    {
        HMENU   hMenuDrop = NULL;
        int     cItems = 0;
        
        if (GetMenuItemInfo(m_hMenu, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            // MessageView will take care of creating language menu
            // let's just fix menu ID
            mii.fMask = MIIM_ID;
            mii.wID = ID_POPUP_LANGUAGE;
            SetMenuItemInfo(m_hMenu, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii); 
        }

        // Get the drop down menu
        hMenuDrop = GetSubMenu(m_hMenu, uPos);
        if (NULL == hMenuDrop)
        {
            goto exit;
        }
        
        // Get the number of items in the drop down menu
        cItems = GetMenuItemCount(hMenuDrop);
        if (-1 == cItems)
        {
            goto exit;
        }

        // Initialize the menu info
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        // Spin throught the submenus finding the correct menu id
        for (cItems--; cItems >= 0; cItems--)
        {
            if (FALSE == GetMenuItemInfo(hMenuDrop, cItems, TRUE, &mii))
            {
                continue;
            }

            if (hmenuPopup == mii.hSubMenu)
            {
                break;
            }
        }

        // Did we find anything?
        if (cItems < 0)
        {
            goto exit;
        }
    }

    uIDPopup = mii.wID;

    switch (uIDPopup)
    {
        case ID_POPUP_FILE:
            hr = g_pStore->GetFolderInfo(m_idSelected, &info);
            if (SUCCEEDED(hr))
            {
                if (info.tyFolder == FOLDER_IMAP)
                {
                    AthLoadString(idsShowFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_SUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_SUBSCRIBE, sz);
                    AthLoadString(idsHideFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_UNSUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_UNSUBSCRIBE, sz);
                }
                else
                {
                    AthLoadString(idsSubscribeFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_SUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_SUBSCRIBE, sz);
                    AthLoadString(idsUnsubscribeFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_UNSUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_UNSUBSCRIBE, sz);
                }

                g_pStore->FreeRecord(&info);
            }
            MU_UpdateIdentityMenus(hmenuPopup);

            if (m_fNoModifyAccts)
            {
                DeleteMenu(hmenuPopup, ID_IMPORT_MAIL_ACCOUNTS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_IMPORT_NEWS_ACCOUNTS, MF_BYCOMMAND);
            }
            break;

        case ID_POPUP_TOOLS:
        {
            DWORD dwHeaders;

            // See if things were changed
            if (m_fRebuildAccountMenu)
            {
                AcctUtil_FreeSendReceieveMenu(hmenuPopup, m_cAcctMenu);
            }

            // Get the submenu for Send & Receieve
            if (m_fRebuildAccountMenu && GetMenuItemInfo(m_hMenu, ID_POPUP_SEND_AND_RECEIVE, FALSE, &mii))
            {             
                AcctUtil_CreateSendReceieveMenu(mii.hSubMenu, &m_cAcctMenu);
                m_fRebuildAccountMenu = FALSE;
            }

            if (!m_fInitNewAcctMenu)
            {
                InitNewAcctMenu(hmenuPopup);
                m_fInitNewAcctMenu = TRUE;
            }

            // Figure out if the user has the "Download 300 headers" turned on
            dwHeaders = DwGetOption(OPT_DOWNLOADCHUNKS);
            if (OPTION_OFF != dwHeaders)
            {
                // Load a new menu string from the resources
                AthLoadString(idsGetHeaderFmt, sz, ARRAYSIZE(sz));

                // Format it
                wnsprintf(szT, ARRAYSIZE(szT), sz, dwHeaders);

                // Splat it on the menu
                ModifyMenu(hmenuPopup, ID_GET_HEADERS, MF_BYCOMMAND | MF_STRING, ID_GET_HEADERS, szT);
            }
            else
            {
                // Load a new menu string from the resources
                AthLoadString(idsGetNewHeaders, sz, ARRAYSIZE(sz));

                // Splat it on the menu
                ModifyMenu(hmenuPopup, ID_GET_HEADERS, MF_BYCOMMAND | MF_STRING, ID_GET_HEADERS, sz);
            }

            if (m_fNoModifyAccts)
            {
                DeleteMenu(hmenuPopup, ID_ACCOUNTS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_POPUP_NEW_ACCT, MF_BYCOMMAND);
            }

            //Change Sync Folder to Sync Account or Sync NewsGroup depending on the folder selected
            MENUITEMINFO    mii = {0};
            FOLDERINFO      FolderInfo = {0};
            int             id;
            TCHAR           szMenuName[CCHMAX_STRINGRES] = {0};

            if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idSelected, &FolderInfo)))
            {
                if (ISFLAGSET(FolderInfo.dwFlags, FOLDER_SERVER))
                {
                    id  = idsSynchronizeNowBtnTT;
                }
                else if(FolderInfo.tyFolder == FOLDER_NEWS)
                {
                    id = idsDownloadNewsgroupTT;
                }
                else
                    id = idsSyncFolder;

                LoadString(g_hLocRes, id, szMenuName, ARRAYSIZE(szMenuName));

                mii.cbSize      = sizeof(MENUITEMINFO);
                mii.fMask       = MIIM_TYPE;
                mii.fType       = MFT_STRING;
                mii.dwTypeData  = szMenuName;

                SetMenuItemInfo(hmenuPopup, ID_SYNC_THIS_NOW, FALSE, &mii);

                g_pStore->FreeRecord(&FolderInfo);
            }
            
            if (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
                DeleteMenu(hmenuPopup, ID_MESSAGE_RULES_JUNK, MF_BYCOMMAND);
            break;
        }

        case ID_POPUP_MESSAGE:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);

            if (!m_fEnvMenuInited && DwGetOption(OPT_SHOW_ENVELOPES))
            {
                Envelope_AddHostMenu(hmenuPopup, 2);
                m_fEnvMenuInited=TRUE;
            }
            break;
        }
    }

    // let the view handle it last so that it can override any browser init if necessary
    if (m_pView)
    {
        m_pView->OnPopupMenu(m_hMenu, hmenuPopup, uIDPopup);
        if(uIDPopup == ID_POPUP_LANGUAGE)           // It was destroyed
            hmenuPopup = m_hMenuLanguage;
    }

    // now enable/disable the items
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    
exit:
    return;
}

inline void CBrowser::_AppendIdentityName(LPCTSTR pszIdentityName, LPSTR pszName, DWORD cchName)
{
    /*
    if (((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS) && pszIdentityName && *pszIdentityName)
    {
    */
    if (pszIdentityName && *pszIdentityName)
    {
        StrCatBuff(pszName, c_szSpaceDashSpace, cchName);
        StrCatBuff(pszName, pszIdentityName, cchName);
    }
    /*
    }
    */
}

void CBrowser::SetFolderType(FOLDERID idFolder)
{
    int             iIcon;
    LPSTR           pszName=NULL;
    LPCSTR          pszIdentityName=NULL;
    HICON           hIconOld, hIcon;
    FOLDERTYPE      ftNew;
    int             cch;
    DWORD           type, cb, dwLen;
    FOLDERINFO      Folder;
    FOLDERINFO      SvrFolderInfo = {0};
    IImnAccount     *pAccount = NULL;
    DWORD           dwShow = 0;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    HRESULT         hr = S_OK;
	BOOL			fHideHotMail = FALSE;

    if (*m_szName == 0)
    {
        // TODO: it seems like the window title should a global setting not per user
        cb = sizeof(m_szName);
        if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szWindowTitle, &type, (LPBYTE)m_szName, &cb) ||
            FIsEmpty(m_szName))
        {
            if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) == MODE_OUTLOOKNEWS)
            {
                LoadString(g_hLocRes, idsMSOutlookNewsReader, m_szName, ARRAYSIZE(m_szName));
            }
            else
            {
                LoadString(g_hLocRes, idsAthena, m_szName, ARRAYSIZE(m_szName));
            }
        }

        Assert(*m_szName != 0);
    }
    
    pszIdentityName = MU_GetCurrentIdentityName();

    if (FOLDERID_ROOT != idFolder && SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        iIcon = GetFolderIcon(&Folder);
        ftNew = Folder.tyFolder;
    
        dwLen = lstrlen(Folder.pszName) + lstrlen(m_szName) + lstrlen(c_szSpaceDashSpace) + 1;

        if (*pszIdentityName)
            dwLen += (lstrlen(pszIdentityName) + lstrlen(c_szSpaceDashSpace));

        //Its better to allocate a few extra bytes now than having to reallocate later depending on the outnews switch.
        //This memory gets freed before exiting the function
        if (MemAlloc((LPVOID *)&pszName, dwLen))
        {
            StrCpyN(pszName, Folder.pszName, dwLen);
            StrCatBuff(pszName, c_szSpaceDashSpace, dwLen);
            StrCatBuff(pszName, m_szName, dwLen);
            
            _AppendIdentityName(pszIdentityName, pszName, dwLen);

        }
        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        iIcon = iMailNews;
        ftNew = FOLDER_ROOTNODE;
        if (*pszIdentityName)
        {
            dwLen = lstrlen(m_szName) + 1;
            
            if (*pszIdentityName)
                dwLen += lstrlen(pszIdentityName) + lstrlen(c_szSpaceDashSpace);

            if (MemAlloc((LPVOID *)&pszName, dwLen))
            {
                StrCpyN(pszName, m_szName, dwLen);
                
                _AppendIdentityName(pszIdentityName, pszName, dwLen);
            }
        }
        else
            pszName = PszDupA(m_szName);
    }

    SetWindowText(m_hwnd, pszName?pszName:m_szName);

    // Update the folder bar
    if (m_pFolderBar)
        m_pFolderBar->SetCurrentFolder(idFolder);
    
	// Update of Adv Bar
    if (m_pAdBar)  // Say that for Hotmail we have Ad bar always 
    {
        if (FOLDER_HTTPMAIL == ftNew)
        {
            //At startup too if the cached state is to show the URL, then just show the toolbar with whatever it is loaded with
            // Get the server for this folder
            IF_FAILEXIT(hr = GetFolderServer(idFolder, &SvrFolderInfo));

            // Get the account ID for the server
            *szAccountId = 0;
            IF_FAILEXIT(hr = GetFolderAccountId(&SvrFolderInfo, szAccountId, ARRAYSIZE(szAccountId)));

            // Get the account interface
            IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

			IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwShow));
			if(dwShow)
			{
				if(!HideHotmail())
				{
			
					IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_SHOW_ADBAR, &dwShow));
					ShowToolbar((IDockingWindow*)m_pAdBar, !!dwShow);
				}
				else
					fHideHotMail = TRUE;
			}
        }
        else
            ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);
    }

    // update the coolbar and menus if we're changing folder type
    if (m_ftSel != ftNew)
    {
        m_ftSel = ftNew;
        _ResetMenu(ftNew, fHideHotMail);
        m_pCoolbar->SetFolderType(ftNew);
    }

    if (m_pBodyBar)
        ShowToolbar((IDockingWindow*)m_pBodyBar, 
        m_rLayout.fInfoPaneEnabled && m_rLayout.fInfoPane && (m_ftSel != FOLDER_HTTPMAIL));

exit:
    SafeMemFree(pszName);
    g_pStore->FreeRecord(&SvrFolderInfo);
    ReleaseObj(pAccount);
    
}

void CBrowser::_ResetMenu(FOLDERTYPE ftNew, BOOL fHideHotMail)
{
    HMENU           hMenu, hMenuT;
    MENUITEMINFO    mii;
    BOOL            fNews;
    DWORD           cServers;
    IImnEnumAccounts *pEnum;
    
    if (m_hMenuLanguage)
    {
        DeinitMultiLanguage();
        if (IsMenu(m_hMenuLanguage))
            DestroyMenu(m_hMenuLanguage);
        m_hMenuLanguage = NULL;
    }
    
    // load the new menu for the view
    SideAssert(hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_BROWSER_MENU)));

    MenuUtil_ReplaceNewMsgMenus(hMenu);
    MenuUtil_ReplaceHelpMenu(hMenu);
    MenuUtil_ReplaceMessengerMenus(hMenu);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        // get the file popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_FILE, FALSE, &mii));

        DeleteMenu(mii.hSubMenu, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
    }

    if ((ftNew != FOLDER_NEWS) && (ftNew != FOLDER_IMAP))
    {
        // get the edit popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_EDIT, FALSE, &mii));

        if (ftNew != FOLDER_NEWS)
            DeleteMenu(mii.hSubMenu, ID_CATCH_UP, MF_BYCOMMAND);

        if (ftNew != FOLDER_IMAP)
        {
            DeleteMenu(mii.hSubMenu, ID_UNDELETE, MF_BYCOMMAND);
            DeleteMenu(mii.hSubMenu, ID_PURGE_DELETED, MF_BYCOMMAND);
        }
    }

    if (ftNew != FOLDER_NEWS)
    {
        g_pAcctMan->GetAccountCount(ACCT_NEWS, &cServers);
        fNews = (cServers > 0);

        // get the message popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_MESSAGE, FALSE, &mii));

        DeleteMenu(mii.hSubMenu, ID_UNSCRAMBLE, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_CANCEL_MESSAGE, MF_BYCOMMAND);
        if (!fNews)
            DeleteMenu(mii.hSubMenu, ID_REPLY_GROUP, MF_BYCOMMAND);
    }
    else
    {
        fNews = TRUE;
    }

    // get the tools popup
    SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_TOOLS, FALSE, &mii));

    if (ftNew != FOLDER_NEWS)
    {
        DeleteMenu(mii.hSubMenu, ID_GET_HEADERS, MF_BYCOMMAND);
        if (!fNews)
            DeleteMenu(mii.hSubMenu, ID_NEWSGROUPS, MF_BYCOMMAND);
    }

    if ((ftNew == FOLDER_LOCAL) || fHideHotMail)
    {
        DeleteMenu(mii.hSubMenu, ID_POPUP_RETRIEVE, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_SYNC_THIS_NOW, MF_BYCOMMAND);
    }

    if (ftNew != FOLDER_IMAP)
    {
        cServers = 0;
        if (S_OK == g_pAcctMan->Enumerate(SRV_IMAP, &pEnum))
        {
            pEnum->GetCount(&cServers);
            pEnum->Release();
        }

        if (cServers == 0)
        {
            DeleteMenu(mii.hSubMenu, ID_IMAP_FOLDERS, MF_BYCOMMAND);
            if (!fNews)
                DeleteMenu(mii.hSubMenu, SEP_SUBSCRIBE, MF_BYCOMMAND);
        }
    }

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        DeleteMenu(mii.hSubMenu, SEP_MESSENGER, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_POPUP_MESSENGER, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_POPUP_MESSENGER_STATUS, MF_BYCOMMAND);
    }

    m_pCoolbar->ResetMenu(hMenu);
    if (m_hMenu != NULL)
    {
        if (IsMenu(m_hMenu))
        {
            AcctUtil_FreeSendReceieveMenu(m_hMenu, m_cAcctMenu);
            m_cAcctMenu = 0;
            m_fRebuildAccountMenu = TRUE;

            FreeNewAcctMenu(m_hMenu);
            m_fInitNewAcctMenu = FALSE;

            DestroyMenu(m_hMenu);
        }
    }

    m_hMenu = hMenu;
}

void CBrowser::SpoolerDeliver(WPARAM wParam, LPARAM lParam)
{
    HWND    hwndCoolbar = 0;
    char    szRes[256], sz[256];
    LPSTR   pszRes = 0;
    static BOOL s_fWarnings=FALSE;
    static ULONG s_cMsgs=0;
    
    if (wParam != DELIVERY_NOTIFY_ALLDONE)
        m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, 0);
    
    switch (wParam)
    {
        case DELIVERY_NOTIFY_STARTING:
            s_cMsgs = 0;
            s_fWarnings = FALSE;
            break;
        
        case DELIVERY_NOTIFY_CONNECTING:
            if (m_pCoolbar)
                m_pCoolbar->Invoke(idDownloadBegin, 0);

            if (m_idClearStatusTimer)
            {
                KillTimer(m_hwnd, m_idClearStatusTimer);
                m_idClearStatusTimer = 0;
            }

            if (m_pCoolbar)
                m_pCoolbar->GetWindow(&hwndCoolbar);
            break;
        
        case DELIVERY_NOTIFY_RESULT:
            if (EVENT_FAILED == lParam || EVENT_WARNINGS == lParam)
                s_fWarnings = TRUE;
            break;
        
        case DELIVERY_NOTIFY_COMPLETE:
            s_cMsgs += (ULONG) lParam;
            break;
        
        case DELIVERY_NOTIFY_ALLDONE:
            // Stop coolbar animation
            if (m_pCoolbar)
                m_pCoolbar->Invoke(idDownloadEnd, 0);                        
        
            if (s_cMsgs && IsWindow(m_hwnd))
            {
                PostMessage(m_hwnd, WM_NEW_MAIL, 0, 0);
            }

            // Show the Warnings Icon
            if (s_fWarnings)
            {
                m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, -1);
            }
            else
            {
                m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, s_cMsgs);

                // Clear the Timer
                m_idClearStatusTimer = SetTimer(m_hwnd, TIMER_CLEAR_STATUS, TIME_TO_CLEAR_NEWMSGSTATUS, NULL);
            }


            break;
    }
}

HRESULT CBrowser::CycleFocus(BOOL fReverse)
{
    DWORD   dwFlags;
    BOOL    bLast;

    HWND hwndFocus = GetFocus();
    HWND hwndNext;

	if (IsWindowVisible(hwndFocus))
	{
		hwndNext = GetNextDlgTabItem(m_hwnd, hwndFocus, fReverse);
	}
	else
	{
		hwndNext = GetNextDlgTabItem(m_hwnd, NULL, fReverse);
	}

    SetFocus(hwndNext);

    if (hwndNext == m_hwndInner || IsChild(m_hwndInner, hwndNext))
        m_itbLastFocus = ITB_OEVIEW;
    else 
        m_itbLastFocus = ITB_NAVPANE;

    return (S_OK);
}


void CBrowser::FrameActivatePopups(BOOL fActivate)
{
    HWND hwndDropDown = HwndGlobalDropDown();
    
    if (!fActivate && hwndDropDown)
        SendMessage(hwndDropDown, WMR_CLICKOUTSIDE, CLK_OUT_DEACTIVATE, 0);
}


void CBrowser::UpdateStatusBar(void)
{
    if (g_pConMan && m_pStatus)
    {
        if (g_pConMan->IsGlobalOffline())
        {
            m_pStatus->SetConnectedStatus(CONN_STATUS_WORKOFFLINE);
        }
        else
        {
            m_pStatus->SetConnectedStatus(CONN_STATUS_CONNECTED);
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// Support for drop-down treeview.  Trust me, this is necessary no matter
// how gross it is.

// currently active global drop down (if any)
static HWND s_hwndDropDown = NULL;

void RegisterGlobalDropDown(HWND hwndCtrl)
{
    Assert(s_hwndDropDown == 0);
    s_hwndDropDown = hwndCtrl;
}

void UnregisterGlobalDropDown(HWND hwndCtrl)
{
    if (s_hwndDropDown == hwndCtrl)
        s_hwndDropDown = 0;
}

void CancelGlobalDropDown()
{
    if (s_hwndDropDown)
        SendMessage(s_hwndDropDown, WMR_CLICKOUTSIDE, 0, 0);
}

HWND HwndGlobalDropDown()
{
    return s_hwndDropDown;
}

BOOL ModifyLocalFolderMenu(HMENU hMenu)
    {
    MENUITEMINFO mii;
    TCHAR        szRes[CCHMAX_STRINGRES];

    if (g_dwAthenaMode & MODE_NEWSONLY)
        {
        // File menu
        DeleteMenu(hMenu, ID_IMPORT_MESSAGES,       MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_IMPORT_MAIL_ACCOUNTS,  MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXPORT_MESSAGES,       MF_BYCOMMAND);
        
        // Tools
        ZeroMemory(&mii, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;

        if (GetMenuItemInfo(hMenu, ID_POPUP_TOOLS, FALSE, &mii))
            {
            // Remove Send & Receive and Message Rules
            DeleteMenu(mii.hSubMenu, ID_SEND_RECEIVE, MF_BYCOMMAND);
            }
        }

    return (TRUE);
    }

BOOL ModifyRootFolderMenu(HMENU hMenu)
    {        
    if (g_dwAthenaMode & MODE_NEWSONLY)
        {
        // File menu
        DeleteMenu(hMenu, ID_IMPORT_MESSAGES, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_IMPORT_MAIL_ACCOUNTS, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXPORT_MESSAGES, MF_BYCOMMAND);

        // Tools
        DeleteMenu(hMenu, ID_SEND_RECEIVE, MF_BYCOMMAND);
        }

    return (TRUE);
    }

HRESULT CBrowser::GetViewLayout(DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize)
{
    HRESULT hr = E_FAIL;

    switch (opt)
    {
        case DISPID_MSGVIEW_TOOLBAR:
        {
            if (pfVisible)
                *pfVisible = m_rgTBar[ITB_COOLBAR].fShow;

            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_STATUSBAR:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fStatusBar;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERBAR:
        {
            if (pfVisible)
                *pfVisible = m_rgTBar[ITB_COOLBAR].fShow;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERLIST:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fFolderList;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_TIPOFTHEDAY:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fTipOfTheDay;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_INFOPANE:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fInfoPane;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_OUTLOOK_BAR:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fOutlookBar;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_CONTACTS:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fContacts;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_NEWS:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fNewsPreviewPane;
            if (pPos)
                *pPos = m_rLayout.fNewsSplitVertically ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM ;
            if (pdwFlags)
                *pdwFlags = m_rLayout.fNewsPreviewPaneHeader;
            if (pdwSize)
            {
                if (0 == m_rLayout.bNewsSplitHorzPct)
                    m_rLayout.bNewsSplitHorzPct = 50;
                if (0 == m_rLayout.bNewsSplitVertPct)
                    m_rLayout.bNewsSplitVertPct = 50;
                *pdwSize = MAKELONG((WORD) m_rLayout.bNewsSplitHorzPct, (WORD) m_rLayout.bNewsSplitVertPct);
            }

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_MAIL:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fMailPreviewPane;
            if (pPos)
                *pPos = m_rLayout.fMailSplitVertically ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM ;
            if (pdwFlags)
                *pdwFlags = m_rLayout.fMailPreviewPaneHeader;
            if (pdwSize)
            {
                if (0 == m_rLayout.bMailSplitHorzPct)
                    m_rLayout.bMailSplitHorzPct = 50;
                if (0 == m_rLayout.bMailSplitVertPct)
                    m_rLayout.bMailSplitVertPct = 50;
                *pdwSize = MAKELONG((WORD) m_rLayout.bMailSplitHorzPct, (WORD) m_rLayout.bMailSplitVertPct);
            }

            hr = S_OK;
            break;
        }

        default:
            AssertSz(0, "CBrowser::GetViewLayout() - Called with an unrecognized layout option.");
    }

    return (hr);
}


HRESULT CBrowser::SetViewLayout(DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize)
{
    HRESULT hr = E_FAIL;

    switch (opt)
    {
        case DISPID_MSGVIEW_TOOLBAR:
        {
            m_rLayout.fToolbar = !!fVisible;

            // This can be called before the windows are created.  If so, we 
            // store the setting and will use it later.
            if (m_pCoolbar)
            {            
                m_pCoolbar->HideToolbar(!m_rLayout.fToolbar);
            }
            
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FILTERBAR:
        {
            m_rLayout.fFilterBar = !!fVisible;

            if (m_pCoolbar)
                m_pCoolbar->HideToolbar(!m_rLayout.fFilterBar, CBTYPE_RULESTOOLBAR);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_STATUSBAR:
        {
            m_rLayout.fStatusBar = !!fVisible;

            if (m_pStatus)
            {   
                m_pStatus->ShowStatus(m_rLayout.fStatusBar);
                ResizeNextBorder(0);
            }

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERBAR:
        {
            m_rLayout.fFolderBar = fVisible;

            if (m_pFolderBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pFolderBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERLIST:
        {
            m_rLayout.fFolderList = fVisible;

            if (m_pNavPane)
            {
                m_pNavPane->ShowFolderList(fVisible);
                m_pFolderBar->Update(FALSE, TRUE);
            }
            UpdateToolbar();
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_TIPOFTHEDAY:
        {
            m_rLayout.fTipOfTheDay = fVisible;

            if (m_hwndInner)
                SendMessage(m_hwndInner, WM_UPDATELAYOUT, 0, 0);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_INFOPANE:
        {
            m_rLayout.fInfoPane = fVisible;

            if (m_pBodyBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pBodyBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_OUTLOOK_BAR:
        {
            m_rLayout.fOutlookBar = fVisible;

            if (m_pOutBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pOutBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_CONTACTS:
        {
            m_rLayout.fContacts = fVisible;

            if (m_pNavPane)
            {
                m_pNavPane->ShowContacts(fVisible);
            }
            UpdateToolbar();
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_NEWS:
        {
            BOOL fForceUpdate = (m_rLayout.fMailPreviewPane != (unsigned) !!fVisible);

            m_rLayout.fNewsPreviewPane = !!fVisible;
            m_rLayout.fNewsPreviewPaneHeader = !!dwFlags;            
            if (pos != LAYOUT_POS_NA)
                m_rLayout.fNewsSplitVertically = (LAYOUT_POS_LEFT == pos);

            if (LOWORD(dwSize))
            {
                m_rLayout.bNewsSplitHorzPct = (BYTE) LOWORD(dwSize);
            }

            if (HIWORD(dwSize))
            {
                m_rLayout.bNewsSplitVertPct = (BYTE) HIWORD(dwSize);
            }

            if (m_pView)
            {
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->UpdateLayout(fVisible, (BOOL) dwFlags, m_rLayout.fNewsSplitVertically, fForceUpdate);
                    pWindow->Release();
                }
            }
    
            UpdateToolbar();

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_MAIL:
        {
            BOOL fForceUpdate = (m_rLayout.fMailPreviewPane != (unsigned) !!fVisible);

            m_rLayout.fMailPreviewPane = !!fVisible; 
            m_rLayout.fMailPreviewPaneHeader = !!dwFlags;            
            if (pos != LAYOUT_POS_NA)
                m_rLayout.fMailSplitVertically = (LAYOUT_POS_LEFT == pos);

            if (LOWORD(dwSize))
            {
                m_rLayout.bMailSplitHorzPct = (BYTE) LOWORD(dwSize);
            }

            if (HIWORD(dwSize))
            {
                m_rLayout.bMailSplitVertPct = (BYTE) HIWORD(dwSize);
            }

            if (m_pView)
            {
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->UpdateLayout(fVisible, (BOOL) dwFlags, m_rLayout.fMailSplitVertically, fForceUpdate);
                    pWindow->Release();
                }
            }

            UpdateToolbar();

            hr = S_OK;
            break;
        }

        default:
            AssertSz(0, "CBrowser::SetViewLayout() - Called with an unrecognized layout option.");
    }

    return (hr);
}


//
//  FUNCTION:   CBrowser::LoadLayoutSettings()
//
//  PURPOSE:    Loads all of the layout settings from the registry and 
//              caches them in the rLayout member.
//
//  RETURN VALUE:
//      Returns S_OK all the time 
//
HRESULT CBrowser::LoadLayoutSettings(void)
{
    TraceCall("CBrowser::LoadLayoutSettings");

    m_rLayout.cbSize = sizeof(LAYOUT);

    // Things that can be turned on or off
    m_rLayout.fStatusBar              = DwGetOption(OPT_SHOWSTATUSBAR); 
    m_rLayout.fFolderBar              = !DwGetOption(OPT_HIDEFOLDERBAR);
    m_rLayout.fFolderList             = DwGetOption(OPT_SHOWTREE);
    m_rLayout.fTipOfTheDay            = DwGetOption(OPT_TIPOFTHEDAY);
    m_rLayout.fInfoPaneEnabled        = FALSE;
    m_rLayout.fInfoPane               = DwGetOption(OPT_SHOWBODYBAR);
    m_rLayout.fOutlookBar             = DwGetOption(OPT_SHOWOUTLOOKBAR);
    m_rLayout.fContacts               = DwGetOption(OPT_SHOWCONTACTS);
    m_rLayout.fMailPreviewPane        = DwGetOption(OPT_MAILHYBRIDVIEW);
    m_rLayout.fMailPreviewPaneHeader  = DwGetOption(OPT_MAILSHOWHEADERINFO);
    m_rLayout.fMailSplitVertically    = DwGetOption(OPT_MAILSPLITDIR);
    m_rLayout.fNewsPreviewPane        = DwGetOption(OPT_NEWSHYBRIDVIEW);
    m_rLayout.fNewsPreviewPaneHeader  = DwGetOption(OPT_NEWSSHOWHEADERINFO);
    m_rLayout.fNewsSplitVertically    = DwGetOption(OPT_NEWSSPLITDIR);
    
    // Coolbar Side
    //m_rLayout.csToolbarSide = COOLBAR_TOP;

    // Preview Pane widths
    m_rLayout.bMailSplitHorzPct = (BYTE) DwGetOption(OPT_MAILCYSPLIT);
    m_rLayout.bMailSplitVertPct = (BYTE) DwGetOption(OPT_MAILCXSPLIT);
    m_rLayout.bNewsSplitHorzPct = (BYTE) DwGetOption(OPT_NEWSCYSPLIT);
    m_rLayout.bNewsSplitVertPct = (BYTE) DwGetOption(OPT_NEWSCXSPLIT);

    return (S_OK);
}



//
//  FUNCTION:   CBrowser::SaveLayoutSettings()
//
//  PURPOSE:    Saves all of the layout configuration back to the registry.
//
//  RETURN VALUE:
//      Returns S_OK all the time
//
HRESULT CBrowser::SaveLayoutSettings(void)
{
    TraceCall("CBrowser::SaveLayoutSettings");

    // Things that can be turned on or off
    SetDwOption(OPT_SHOWSTATUSBAR, m_rLayout.fStatusBar, 0, 0); 
    SetDwOption(OPT_HIDEFOLDERBAR, !m_rLayout.fFolderBar, 0, 0);
    SetDwOption(OPT_SHOWTREE, m_rLayout.fFolderList, 0, 0);
    SetDwOption(OPT_TIPOFTHEDAY, m_rLayout.fTipOfTheDay, 0, 0);
    SetDwOption(OPT_SHOWBODYBAR, m_rLayout.fInfoPane, 0, 0);
    SetDwOption(OPT_SHOWOUTLOOKBAR, m_rLayout.fOutlookBar, 0, 0);
    SetDwOption(OPT_SHOWCONTACTS, m_rLayout.fContacts, 0, 0);
    SetDwOption(OPT_MAILHYBRIDVIEW, m_rLayout.fMailPreviewPane, 0, 0);
    SetDwOption(OPT_MAILSHOWHEADERINFO, m_rLayout.fMailPreviewPaneHeader, 0, 0);
    SetDwOption(OPT_MAILSPLITDIR, m_rLayout.fMailSplitVertically, 0, 0);
    SetDwOption(OPT_NEWSHYBRIDVIEW, m_rLayout.fNewsPreviewPane, 0, 0);
    SetDwOption(OPT_NEWSSHOWHEADERINFO, m_rLayout.fNewsPreviewPaneHeader, 0, 0);
    SetDwOption(OPT_NEWSSPLITDIR, m_rLayout.fNewsSplitVertically, 0, 0);

    // Preview Pane widths
    SetDwOption(OPT_MAILCYSPLIT, (DWORD) m_rLayout.bMailSplitHorzPct, 0, 0);
    SetDwOption(OPT_MAILCXSPLIT, (DWORD) m_rLayout.bMailSplitVertPct, 0, 0);
    SetDwOption(OPT_NEWSCYSPLIT, (DWORD) m_rLayout.bNewsSplitHorzPct, 0, 0);
    SetDwOption(OPT_NEWSCXSPLIT, (DWORD) m_rLayout.bNewsSplitVertPct, 0, 0);

    return (S_OK);
}


HRESULT CBrowser::CmdSendReceieveAccount(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    MENUITEMINFO mii;

    mii.cbSize     = sizeof(MENUITEMINFO);
    mii.fMask      = MIIM_DATA;
    mii.dwItemData = 0;

    if (GetMenuItemInfo(m_hMenu, nCmdID, FALSE, &mii))
    {
        if (mii.dwItemData)
        {
            g_pSpooler->StartDelivery(m_hwnd, (LPTSTR) mii.dwItemData, FOLDERID_INVALID,
                DELIVER_MAIL_SEND | DELIVER_MAIL_RECV | DELIVER_NOSKIP | 
                DELIVER_POLL | DELIVER_OFFLINE_FLAGS);
        }
        else
        {
            g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                DELIVER_MAIL_SEND | DELIVER_MAIL_RECV | DELIVER_POLL | 
                DELIVER_OFFLINE_FLAGS);
        }
    }

    return (S_OK);
}


HRESULT CBrowser::CmdDeleteAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    BOOL fNoTrash;
    IOleCommandTarget *pTarget = NULL;
    

    // Figure out where the focus is
    HWND hwndFocus = GetFocus();

    Assert(nCmdID == ID_DELETE_ACCEL || nCmdID == ID_DELETE_NO_TRASH_ACCEL);

    fNoTrash = (nCmdID == ID_DELETE_NO_TRASH_ACCEL);

    // Check to see if it's the treeview
    if (S_OK == m_pTreeView->HasFocusIO())
    {
        pTarget = m_pTreeView;
        nCmdID = fNoTrash ? ID_DELETE_NO_TRASH : ID_DELETE_FOLDER;
    }

    // Check to see if it's anything else on the Info Column
    else if (m_pNavPane->IsContactsFocus())
    {
        pTarget = m_pNavPane;
        nCmdID = ID_DELETE_CONTACT;
    }

    // Otherwise, it must be the view
    else
    {
        pTarget = m_pViewCT;
        nCmdID = fNoTrash ? ID_DELETE_NO_TRASH : ID_DELETE;
    }

    // Hit the target with the right command
    if (pTarget)
        return (pTarget->Exec(NULL, nCmdID, nCmdExecOpt, pvaIn, pvaOut));
    else
        return (OLECMDERR_E_NOTSUPPORTED);
}

HRESULT CBrowser::TranslateMenuMessage(MSG *lpmsg, LRESULT *lres)
{
    if (m_pCoolbar)
        return m_pCoolbar->TranslateMenuMessage(lpmsg, lres);
    else
        return S_FALSE;
}

BOOL CBrowser::_InitToolbars(void)
{
    DWORD   dwTreeFlags = 0;

    if (!(m_pTreeView = new CTreeView(this)))
        goto error;

    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
        dwTreeFlags |= TREEVIEW_NOIMAP | TREEVIEW_NOHTTP;

    if (FAILED(m_pTreeView->HrInit(dwTreeFlags, this)))
        goto error;


    if (!(m_pCoolbar = new CBands()))
        goto error;

    if (FAILED(m_pCoolbar->HrInit(NULL, m_hMenu, PARENT_TYPE_BROWSER)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pCoolbar, ITB_COOLBAR, TRUE, TRUE)))
        goto error;

    //m_pCoolbar->HideToolbar(!m_rLayout.fToolbar);
    m_rLayout.fToolbar      = m_pCoolbar->IsBandVisible(CBTYPE_TOOLS);
    m_rLayout.fFilterBar    = m_pCoolbar->IsBandVisible(CBTYPE_RULESTOOLBAR);

    if (FAILED(m_pCoolbar->SetFolderType(m_ftSel)))
        goto error;

    if (!(m_pOutBar = new COutBar()))
        goto error;

    if (FAILED(m_pOutBar->HrInit(NULL, this)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow *) m_pOutBar, ITB_OUTBAR, m_rLayout.fOutlookBar, TRUE)))
        goto error;

#ifdef HOTMAILADV
    if (!(m_pAdBar = new CAdBar()))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pAdBar, ITB_ADBAR, TRUE, FALSE)))
        goto error;
#endif // HOTMAILADV

    if (!(m_pBodyBar = new CBodyBar()))
        goto error;

    BOOL fBodyBarEnabled;
    if (FAILED(m_pBodyBar->HrInit(&fBodyBarEnabled)))
        goto error;
    m_rLayout.fInfoPaneEnabled = !!fBodyBarEnabled;

    if (FAILED(AddToolbar((IDockingWindow*)m_pBodyBar, ITB_BODYBAR, 
                          m_rLayout.fInfoPaneEnabled && m_rLayout.fInfoPane, FALSE)))
        goto error;

    if (!(m_pFolderBar = new CFolderBar()))
        goto error;

    if (FAILED(m_pFolderBar->HrInit(this)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pFolderBar, ITB_FOLDERBAR, m_rLayout.fFolderBar, TRUE)))
        goto error;

    if (!(m_pNavPane = new CNavPane()))
        goto error;

    if (FAILED(m_pNavPane->Initialize(m_pTreeView)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*) m_pNavPane, ITB_NAVPANE, m_rLayout.fFolderList || m_rLayout.fContacts, TRUE)))
        goto error;

    return (TRUE);

error:
    SafeRelease(m_pStatus);
    SafeRelease(m_pTreeView);
    SafeRelease(m_pCoolbar);
    SafeRelease(m_pFolderBar);

    return (FALSE);
}


HRESULT CBrowser::QuerySwitchIdentities()
{
    TraceCall("CBrowser::QuerySwitchIdentities");

    if (!IsWindowEnabled(m_hwnd))
    {
        Assert(IsWindowVisible(m_hwnd));
        return E_PROCESS_CANCELLED_SWITCH;
    }

    if (g_pConMan->IsConnected())
    {
        SetForegroundWindow(m_hwnd);

        if (IDNO == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSwitchUser),MAKEINTRESOURCEW(idsMaintainConnection),  
                              NULL, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON1 | MB_SYSTEMMODAL))
            g_pConMan->Disconnect(m_hwnd, TRUE, FALSE, FALSE );
    }

    m_fSwitchIsLogout = MU_CheckForIdentityLogout();

    return S_OK;
}

HRESULT CBrowser::SwitchIdentities()
{
    TraceCall("CBrowser::SwitchIdentities");

    if (!m_fSwitchIsLogout)
    {
        // Let ::BrowserWndProc know that this close is due to an id switch
        s_fQuickShutdown = TRUE;
    }
    else
    {
        s_fQuickShutdown = FALSE;
        g_pInstance->SetSwitchingUsers(FALSE);
    }

    // We can't SendMessage here as we'd cause ole to throw RPC_E_CANTCALLOUT_ININPUTSYNCCALL 
    PostMessage(m_hwnd, WM_CLOSE, 0, 0);
    
    return S_OK;
}

HRESULT CBrowser::IdentityInformationChanged(DWORD dwType)
{
    TraceCall("CBrowser::IdentityInformationChanged");

    // Refresh for adds, delete, or current identity changed
    // since adding could require that the name show up,
    // deleteing could require that it go away and changed 
    // should be reflected immediately.
    if (dwType != IIC_IDENTITY_CHANGED)
    {
        MU_IdentityChanged();
        OnRename(m_idSelected);
    }
    return S_OK;
}

HRESULT CBrowser::ShowAdBar(BSTR    bstr)
{
    HRESULT     hr              = S_OK;
#ifdef HOTMAILADV
    LPSTR       pszAdInfo       = NULL;
    BOOL        fShowAdPane     = FALSE;
    LPSTR       pszActualUrl    = NULL;
    DWORD       ActualCount     = 0;
    CHAR        szAdPaneValue[MAX_PATH];
    DWORD       cchRetCount     = 0;
    CHAR        szAdOther[MAX_PATH];
    CHAR        szEncodedString[MAX_PATH];
    CHAR        szAdSvr[MAX_PATH];
    FOLDERINFO  FolderInfo = {0};
    CHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount = NULL;
    CHAR        szCachedAdUrl[INTERNET_MAX_URL_LENGTH];

    IF_FAILEXIT(hr = HrBSTRToLPSZ(CP_ACP, bstr, &pszAdInfo));

    //Search for AdPane token
    IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdPane, szAdPaneValue, ARRAYSIZE(szAdPaneValue), &cchRetCount));
    
    fShowAdPane = (lstrcmp(szAdPaneValue, c_szAdPaneOn) == 0);

    // Get the server for this folder
    IF_FAILEXIT(hr = GetFolderServer(m_idSelected, &FolderInfo));

    // Get the account ID for the server
    IF_FAILEXIT(hr = GetFolderAccountId(&FolderInfo, szAccountId));

    // Get the account interface
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

    IF_FAILEXIT(hr = pAccount->SetPropDw(AP_HTTPMAIL_SHOW_ADBAR, fShowAdPane));

    if (fShowAdPane)
    {
        //Plus one for null in version string
        ActualCount += CCH_REDIRECT_ADURL + strlen(c_szUrlSubPVER) + 1; 

        //Search for AdSvr token
        IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdSvr, szAdSvr, ARRAYSIZE(szAdSvr), &cchRetCount));

        ActualCount += cchRetCount;

        ActualCount += CCH_ADSVR_TOKEN_FORMAT;

        //Search for the token other
        IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdOther, szAdOther, ARRAYSIZE(szAdOther), &cchRetCount));

        //Encode the other string
        IF_FAILEXIT(hr = HrEscapeOtherAdToken(szAdOther, szEncodedString, ARRAYSIZE(szEncodedString), &cchRetCount));

        ActualCount += cchRetCount;

        //one for null
        ActualCount += CCH_OTHER_FORMAT + 1;

        IF_FAILEXIT(hr = HrAlloc((LPVOID*)&pszActualUrl, ActualCount));

        *pszActualUrl = 0;

        wnsprintf(pszActualUrl, ActualCount, c_szAdRedirectFormat, c_szRedirectAdUrl, c_szUrlSubPVER,
                               c_szAdSvrFormat, szAdSvr, c_szAdOtherFormat, szEncodedString);

        
        IF_FAILEXIT(hr = m_pAdBar->SetUrl(pszActualUrl));

        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_HTTPMAIL_ADURL, pszActualUrl));
    }

    ShowToolbar((IDockingWindow*)m_pAdBar, fShowAdPane);

    //We need to do this to persist the property into registry.
    IF_FAILEXIT(hr = pAccount->WriteChanges());

exit:

    if (FAILED(hr) && fShowAdPane)
    {
        BOOL    fSucceeded = FALSE;

        //We are supposed to show adpane, but something went wrong in the info we got. 
        //We just display the cached URL.
        *szCachedAdUrl = 0;

        if (pAccount)
        {
            if (SUCCEEDED(pAccount->GetPropSz(AP_HTTPMAIL_ADURL, szCachedAdUrl, ARRAYSIZE(szCachedAdUrl))))
            {
                fSucceeded = SUCCEEDED(m_pAdBar->SetUrl(szCachedAdUrl));
            }
        }

        if (!fSucceeded)
        {
            //If we can't get the cached ad or if the cached is empty, we turn off the adpane
            ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);
        }

    }

    g_pStore->FreeRecord(&FolderInfo);
    ReleaseObj(pAccount);
    MemFree(pszActualUrl);
    MemFree(pszAdInfo);
#endif // HOTMAILADV

    return hr;
}

void CBrowser::WriteUnreadCount(void)
{
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD               cServers = 0;
    IMessageFolder      *pFolder = NULL;
    DWORD               nCount = 0 ;
    FOLDERID            idServer;
    TCHAR               szUserEmail[CCHMAX_EMAIL_ADDRESS];
    WCHAR               wsz[CCHMAX_EMAIL_ADDRESS];
    HRESULT             hr = S_OK;

    // can't proceed if there's no accnt manager
    if (g_pAcctMan == NULL)
        return;

    // 1. Enumerate POP3 accounts:
    if (S_OK == g_pAcctMan->Enumerate(SRV_POP3, &pEnum))
    {
        // Get count of servers
        pEnum->GetCount(&cServers);

        if(cServers == 1)
        {
            // a). All POP3 account in local store
            if(SUCCEEDED(pEnum->GetNext(&pAcct)) && g_pStore)
            {
                IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pFolder));

                nCount = _GetNumberOfUnreadMsg(pFolder);
                IF_FAILEXIT(hr = pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szUserEmail, ARRAYSIZE(szUserEmail)));
                if(MultiByteToWideChar(CP_ACP, 0, szUserEmail, -1, wsz, ARRAYSIZE(wsz)) != 0)
                    // write # unread messages to registry
                    hr = SHSetUnreadMailCountW(wsz, nCount, L"msimn");
                SafeRelease(pFolder);
            }

        }
    }

    // 1. Enumerate IMAP accounts:
    IF_FAILEXIT(hr = _CheckAndWriteUnreadNumber(SRV_IMAP));
    IF_FAILEXIT(hr = _CheckAndWriteUnreadNumber(SRV_HTTPMAIL));

exit:
    SafeRelease(pAcct);
    SafeRelease(pEnum);
    return;
}

DWORD CBrowser::_GetNumberOfUnreadMsg(IMessageFolder *pFolder)
{
    DWORD           nCount = 0;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    HRESULT             hr = S_OK;
    // Create Rowset
    IF_FAILEXIT(hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Iterate throug the messages
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Not Read
        if (FALSE == ISFLAGSET(Message.dwFlags, ARF_READ))
            nCount++;

        // Free
        pFolder->FreeRecord(&Message);
    }

exit:
    // Clenaup
    pFolder->CloseRowset(&hRowset);

    return(nCount);
}

HRESULT CBrowser::_CheckAndWriteUnreadNumber(DWORD dwSrvTypes)
{
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD               cServers = 0;
    IMessageFolder      *pFolder = NULL;
    DWORD               nCount = 0 ;
    FOLDERID            idServer;
    TCHAR               szAccountId[CCHMAX_ACCOUNT_NAME];
    TCHAR               szUserEmail[CCHMAX_EMAIL_ADDRESS];
    WCHAR               wsz[CCHMAX_EMAIL_ADDRESS];
    HRESULT             hr = S_OK;

    if(g_pStore == NULL)
        return(hr);

    if (S_OK == g_pAcctMan->Enumerate(dwSrvTypes, &pEnum))
    {
        while(SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            // Get the Account ID for pAccount
            IF_FAILEXIT(hr = pAcct->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
            
            // Find the Server Id
            IF_FAILEXIT(hr = g_pStore->FindServerId(szAccountId, &idServer));
            
            // Open Store
            IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_INBOX, &pFolder));
            
            nCount = _GetNumberOfUnreadMsg(pFolder);

            // write # unread messages to registry
            IF_FAILEXIT(hr = pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szUserEmail, ARRAYSIZE(szUserEmail)));
            
            if(MultiByteToWideChar(CP_ACP, 0, szUserEmail, -1, wsz, ARRAYSIZE(wsz)) != 0)
                hr = SHSetUnreadMailCountW(wsz, nCount, L"msimn");
            SafeRelease(pFolder);
            SafeRelease(pAcct);      
        }
    }
exit:
    SafeRelease(pFolder);
    SafeRelease(pAcct);
    SafeRelease(pEnum);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\cexticon.h ===
////////////////////////////////////////////////////////////////////////
//
//  CExtractIcon
//
//  IExtractIcon implementation
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_CEXTICON_H
#define _INC_CEXTICON_H

class CExtractIcon : public IExtractIconA, public IExtractIconW
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IExtractIconA methods ***
    HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags,LPSTR szIconFile,UINT cchMax,int FAR *piIndex,UINT FAR *pwFlags);
    HRESULT STDMETHODCALLTYPE Extract(LPCSTR pszFile,UINT nIconIndex,HICON FAR *phiconLarge,HICON FAR *phiconSmall,UINT nIcons);

#ifndef WIN16  // WIN16FF
    // *** IExtractIconW methods ***
    HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags,LPWSTR szIconFile,UINT cchMax,int FAR *piIndex,UINT FAR *pwFlags);
    HRESULT STDMETHODCALLTYPE Extract(LPCWSTR pszFile,UINT nIconIndex,HICON FAR *phiconLarge,HICON FAR *phiconSmall,UINT nIcons);
#endif // !WIN16

    CExtractIcon(int iIcon, int iIconOpen, UINT uFlags, LPSTR szModule);
    ~CExtractIcon();

private:
    UINT        m_cRef;
    int         m_iIcon;
    int         m_iIconOpen;
    UINT        m_uFlags;
    char        m_szModule[MAX_PATH];    
};

#endif // _INC_CEXTICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\cexticon.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  CExtractIcon
//
//  IExtractIcon implementation
//
////////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "cexticon.h"

CExtractIcon::CExtractIcon(int iIcon, int iIconOpen, UINT uFlags, LPSTR szModule)
{
    DOUT("CExtractIcon::CExtractIcon");

    m_cRef = 1;
    m_iIcon = iIcon;
    m_iIconOpen = iIconOpen;
    m_uFlags = uFlags;
    if (szModule)
        StrCpyN(m_szModule, szModule,  ARRAYSIZE(m_szModule));
    else
        GetModuleFileName(g_hInst, m_szModule, sizeof(m_szModule)/sizeof(char));
}

CExtractIcon::~CExtractIcon()
{
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::QueryInterface(REFIID riid, void **ppvObject)
{
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppvObject = (void *)this;
        }
    else if (IsEqualIID(riid, IID_IExtractIconA))
        {
        *ppvObject = (IExtractIconA *)this;
        }
    else if (IsEqualIID(riid, IID_IExtractIconW))
        {
        *ppvObject = (IExtractIconW *)this;
        }
    else
        {
        *ppvObject = NULL;
        return E_NOINTERFACE;
        }

    m_cRef++;
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CExtractIcon::AddRef(void)
{
    DOUT("CExtractIcon::AddRef() ==> %d", m_cRef+1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CExtractIcon::Release(void)
{
    DOUT("CExtractIcon::Release() ==> %d", m_cRef-1);

    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    else
        return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IExtractIconA
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, 
                                                        int *piIndex, UINT *pwFlags)
{
    StrCpyN(szIconFile, m_szModule, cchMax);
    *piIndex = (uFlags & GIL_OPENICON) ? m_iIconOpen : m_iIcon;
    *pwFlags = m_uFlags;
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CExtractIcon::Extract(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
                                                HICON *phiconSmall, UINT nIcons)
{
    // let the explorer extract the icon
    return S_FALSE;
}

#ifndef WIN16  // WIN16FF
////////////////////////////////////////////////////////////////////////
//
//  IExtractIconW
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::GetIconLocation(UINT uFlags, LPWSTR szIconFile, UINT cchMax, 
                                                        int *piIndex, UINT *pwFlags)
{
    MultiByteToWideChar(CP_ACP, 0, m_szModule, -1, szIconFile, cchMax);
    *piIndex = (uFlags & GIL_OPENICON) ? m_iIconOpen : m_iIcon;
    *pwFlags = m_uFlags;
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CExtractIcon::Extract(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
                                                HICON *phiconSmall, UINT nIcons)
{
    // let the explorer extract the icon
    return S_FALSE;
}
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\dllmain.cpp ===
// --------------------------------------------------------------------------
// DLLMAIN.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#include "pch.hxx"
#include "htmlstr.h"
#include "instance.h"
#include "conman.h"
#include "spengine.h"
#include "msglist.h"
#include "baui.h"
#include "wabapi.h"
#include "shared.h"
#include "rulesmgr.h"
#ifndef WIN16  //RUN16_MSLU
#include <msluapi.h>
#include <msluguid.h>
#endif //!WIN16
#include "demand.h"
#include "note.h"
#include "mirror.h"
// #ifdef _ATL_STATIC_REGISTRY
// #include <statreg.h>
// #include <statreg.cpp>
// #endif
#undef SubclassWindow
#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwinx.cpp>

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
HINSTANCE                       g_hLocRes = NULL;
HINSTANCE                       g_hInst=NULL;
LPMALLOC                        g_pMalloc=NULL;         // From memutil.h
CRITICAL_SECTION                g_csDBListen={0};
CRITICAL_SECTION                g_csgoCommon={0};
CRITICAL_SECTION                g_csgoMail={0};
CRITICAL_SECTION                g_csgoNews={0};
CRITICAL_SECTION                g_csFolderDlg={0};
CRITICAL_SECTION                g_csFmsg={0};
CRITICAL_SECTION                s_csPasswordList={0};
CRITICAL_SECTION                g_csAccountPropCache={0};
CRITICAL_SECTION                g_csMsgrList={0};
CRITICAL_SECTION                g_csThreadList={0};
COutlookExpress                *g_pInstance=NULL;
HWND                            g_hwndInit=NULL,
                                g_hwndActiveModal=NULL;
UINT                            g_msgMSWheel=0;
HACCEL                          g_haccelNewsView=0;
DWORD                           g_dwAthenaMode=0;
IImnAccountManager2            *g_pAcctMan=NULL;
HMODULE                         g_hlibMAPI=NULL;
CBrowser                       *g_pBrowser=NULL;
IMimeAllocator                 *g_pMoleAlloc=NULL;
CConnectionManager             *g_pConMan=NULL;
DWORD                           g_dwSecurityCheckedSchemaProp=0;
IFontCache                     *g_lpIFontCache=NULL;
ISpoolerEngine                 *g_pSpooler=NULL;
// bobn: brianv says we have to take this out...
//DWORD                           g_dwBrowserFlags=0;
UINT	                        CF_FILEDESCRIPTORA=0;
UINT	                        CF_FILEDESCRIPTORW=0;
UINT                            CF_FILECONTENTS=0;
UINT                            CF_HTML=0;
UINT                            CF_INETMSG=0;
UINT                            CF_OEFOLDER=0;
UINT                            CF_SHELLURL=0;
UINT                            CF_OEMESSAGES=0;
UINT                            CF_OESHORTCUT=0;
CStationery                    *g_pStationery=NULL;
ROAMSTATE                       g_rsRoamState=RS_NO_ROAMING;
IOERulesManager                *g_pRulesMan = NULL;
IMessageStore                  *g_pStore=NULL;
CRITICAL_SECTION                g_csFindFolder={0};
LPACTIVEFINDFOLDER              g_pHeadFindFolder=NULL;
DWORD                           g_dwTlsTimeout=0xFFFFFFFF;
BOOL                            g_fPluralIDs=0;
UINT                            g_uiCodePage=0;
IDatabaseSession               *g_pDBSession=NULL;
BOOL                            g_bMirroredOS=FALSE;
SYSTEM_INFO                     g_SystemInfo={0};
OSVERSIONINFO					g_OSInfo={0};

// --------------------------------------------------------------------------------
// Debug Trace Tags
// --------------------------------------------------------------------------------
IF_DEBUG(DWORD                  TAG_OBJECTDB=0;)
IF_DEBUG(DWORD                  TAG_INITTRACE=0;)
IF_DEBUG(DWORD                  TAG_SERVERQ=0;)
IF_DEBUG(DWORD                  TAG_IMAPSYNC=0;)

// --------------------------------------------------------------------------------
// global OE type-lib. Defer-created in BaseDisp.Cpp
// freed on process detach, protected with CS
// --------------------------------------------------------------------------------
ITypeLib                        *g_pOETypeLib=NULL;
CRITICAL_SECTION                g_csOETypeLib={0};


// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD                           dwDOUTLevel=0;          // From msoert.h
DWORD                           dwDOUTLMod=0;           // From msoert.h
DWORD                           dwDOUTLModLevel=0;      // From msoert.h
DWORD                           dwATLTraceLevel=0;      // From msoert.h
#endif

// Language DLL
// __declspec( dllimport )  HINSTANCE hLangDll;

// ATL Module Define
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MessageList, CMessageList)
    OBJECT_ENTRY(CLSID_MsgrAb, CMsgrAb)
END_OBJECT_MAP()


// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
//extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved);
{
    // Process Attach
    if (DLL_PROCESS_ATTACH == dwReason)
    {
         SHFusionInitialize(NULL);
        // Save hInstance
        g_hInst = (HINSTANCE)hInst;
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        // We now want thread calls.
        // We don't care about thread attachs
        // SideAssert(DisableThreadLibraryCalls((HINSTANCE)hInst));

        // Get the OLE Task Memory Allocator
        CoGetMalloc(1, &g_pMalloc);
        AssertSz(g_pMalloc, "We are in trouble now.");        

        // Initialize Demand Loader
        InitDemandLoadedLibs();

        // Get System & OS Info
        GetPCAndOSTypes(&g_SystemInfo, &g_OSInfo);

        // Get Resources from Lang DLL
        g_hLocRes = LoadLangDll(g_hInst, c_szOEResDll, fIsNT5());
        if(g_hLocRes == NULL)
        {
            Assert(FALSE);
            return FALSE;
        }

        // Initialize TLS Globals
        InitTlsActiveNote();
        g_dwTlsTimeout = TlsAlloc();
        Assert(0xFFFFFFFF != g_dwTlsTimeout);
        TlsSetValue(g_dwTlsTimeout, NULL);

        // Initialize all global critical sections
        InitializeCriticalSection(&g_csFindFolder);
        InitializeCriticalSection(&g_csDBListen);
        InitializeCriticalSection(&g_csgoCommon);
        InitializeCriticalSection(&g_csgoMail);
        InitializeCriticalSection(&g_csgoNews);
        InitializeCriticalSection(&g_csFolderDlg);
        InitializeCriticalSection(&g_csFmsg);
        InitializeCriticalSection(&g_csOETypeLib);
        InitializeCriticalSection(&s_csPasswordList);
        InitializeCriticalSection(&g_csAccountPropCache);
        InitializeCriticalSection(&g_csMsgrList);
        InitializeCriticalSection(&g_csThreadList);
        // Initialize DOUTs
#ifdef DEBUG
        dwDOUTLevel = GetPrivateProfileInt("Debug", "Level", 0, "athena.ini");
        dwDOUTLMod = GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel = GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
        dwATLTraceLevel = GetPrivateProfileInt("ATL", "TraceLevel", 0, "athena.ini");
        TAG_OBJECTDB = GetDebugTraceTagMask("Database", TAG_OBJECTDB);
        TAG_INITTRACE = GetDebugTraceTagMask("CoIncrementTracing", TAG_INITTRACE);
        TAG_SERVERQ = GetDebugTraceTagMask("ServerQ", TAG_SERVERQ);
        TAG_IMAPSYNC = GetDebugTraceTagMask("IMAPSync", TAG_IMAPSYNC);
#endif
        // Initialize ATL module
        _Module.Init(ObjectMap, g_hInst);
        _Module.m_hInstResource = g_hLocRes;

        // Create Application Object (Don't initialize yet)
        g_pInstance = new COutlookExpress;
        AssertSz(g_pInstance, "We are in trouble now.");
    }

    // Thread Attach
    else if (DLL_THREAD_ATTACH == dwReason)
    {
        SetTlsGlobalActiveNote(NULL);
        TlsSetValue(g_dwTlsTimeout, NULL);
    }

    // Thread Attach
    else if (DLL_THREAD_DETACH == dwReason)
    {
        HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
        if (hwndTimeout && IsWindow(hwndTimeout))
            DestroyWindow(hwndTimeout);
        TlsSetValue(g_dwTlsTimeout, NULL);
    }

    // Process Detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Free Type Lib
        SafeRelease(g_pOETypeLib);

        // Release Application
        SafeRelease(g_pInstance);

        // Free the ATL module
        _Module.Term();

        // Delete all global critical sections
        DeleteCriticalSection(&g_csgoCommon);
        DeleteCriticalSection(&g_csgoMail);
        DeleteCriticalSection(&g_csgoNews);
        DeleteCriticalSection(&g_csFolderDlg);
        DeleteCriticalSection(&g_csFmsg);
        DeleteCriticalSection(&g_csOETypeLib);
        DeleteCriticalSection(&s_csPasswordList);
        DeleteCriticalSection(&g_csAccountPropCache);
        DeleteCriticalSection(&g_csDBListen);
        DeleteCriticalSection(&g_csMsgrList);
        AssertSz(NULL == g_pHeadFindFolder, "Process is terminating with active finders running.");
        DeleteCriticalSection(&g_csFindFolder);
        DeleteCriticalSection(&g_csThreadList);

        // Free demand loaded libs
        FreeDemandLoadedLibs();

        // Free Timeout
        HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
        if (hwndTimeout && IsWindow(hwndTimeout))
            DestroyWindow(hwndTimeout);

        // Free TLS
        DeInitTlsActiveNote();
        if (0xFFFFFFFF != g_dwTlsTimeout)
            TlsFree(g_dwTlsTimeout);

        // Release the task allocator
        SafeRelease(g_pMalloc);

        // Free Resource Lib
        if (NULL != g_hLocRes)
            FreeLibrary(g_hLocRes);

        SHFusionUninitialize();

    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // If no instance, we can definately unload
    if (NULL == g_pInstance)
        return S_OK;

    // Otherwise, check with the instance object
    return g_pInstance->DllCanUnloadNow();
}

// --------------------------------------------------------------------------------
// RegTypeLib
// --------------------------------------------------------------------------------
__inline HRESULT RegTypeLib(HINSTANCE hInstRes)
{
    AssertSz(hInstRes,    "[ARGS] RegTypeLib: NULL hInstRes");
    
    HRESULT     hr = E_FAIL;
    CHAR        szDll[MAX_PATH];
    WCHAR       wszDll[MAX_PATH];

    GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));

    // Convert the module path to Wide-String
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDll, -1, wszDll, ARRAYSIZE(wszDll)))
    {
        ITypeLib   *pTypeLib;

        hr = LoadTypeLib(wszDll, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            // Register the typelib
            hr = RegisterTypeLib(pTypeLib, wszDll, NULL);
            pTypeLib->Release();
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // CallRegInstall and RegTypeLib are in staticRT/shared.cpp
    return(CallRegInstall(g_hInst, g_hInst, c_szReg, NULL));
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

class CClassFactory; // Forward

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\fidcpriv.h ===
////////////////////////////////////////////////////////////////////////
//
//  fidcpriv.h - private to implementation of FolderID Cache
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_FIDCPRIV_H
#define _INC_FIDCPRIV_H

class CEnumFidl : public IEnumIDList
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IEnumIDList methods ***
    HRESULT STDMETHODCALLTYPE Next(ULONG celt,LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone(IEnumIDList **ppenum);

//
// constructor/destructor
//
    CEnumFidl();
    ~CEnumFidl();
    HRESULT HrInit(int iFolderType, LPCFOLDERIDLIST pidl);

private:
    UINT            m_cRef;
    ULONG           m_cElt;
    LPFOLDERIDLIST *m_rgpidl;
    ULONG           m_ulEnumOffset;
};

#endif //_INC_FIDCPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\init.h ===
/*
 *	i n i t . h
 *	
 *	Purpose:
 *		global init code for Athena
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */

#ifndef INIT_H
#define INIT_H

BOOL FCommonViewInit();
HRESULT HrMailInit(HWND hwnd);
BOOL Initialize_RunDLL(BOOL fMail);
void Uninitialize_RunDLL();
void DllDeInit();

#endif  //INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\frntpage.cpp ===
/*
 *    frntpage.cpp                                                  
 *    
 *    Purpose:                     
 *        Implements the Front Page IAthenaView object
 *    
 *    Owner:
 *        EricAn
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */
#include "pch.hxx"
#include "frntpage.h"
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include "frntbody.h"
#include "acctutil.h"
#include "newfldr.h"
#include <wininet.h>
#include <options.h>
#include <layout.h>
#include "finder.h"
#include <inetcfg.h>
#include "instance.h"
#include "storutil.h"
#include "menuutil.h"
#include "menures.h"
#include "statbar.h"

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define FPDOUT(x) DOUTL(DOUT_LEVEL4, x)

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static const TCHAR s_szFrontPageWndClass[] = TEXT("ThorFrontPageWndClass");

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

/////////////////////////////////////////////////////////////////////////
//
// Constructors, Destructors, and Initialization
//

CFrontPage::CFrontPage()
{
    m_cRef = 1;
    m_idFolder = FOLDERID_INVALID;
    m_pShellBrowser = NULL;
    m_fFirstActive = FALSE;
    m_uActivation = SVUIA_DEACTIVATE;
    m_hwndOwner = NULL;
    m_hwnd = NULL;
    m_hwndCtlFocus = NULL;
    m_pBodyObj = NULL;
    m_pBodyObjCT = NULL;
#ifndef WIN16  // No RAS support in Win16
    m_hMenuConnect = 0;
#endif
    m_pStatusBar = NULL;
}

CFrontPage::~CFrontPage()
{
    SafeRelease(m_pShellBrowser);
    SafeRelease(m_pBodyObj);
    SafeRelease(m_pBodyObjCT);
    SafeRelease(m_pStatusBar);
#ifndef WIN16  // No RAS support in Win16
    if (m_hMenuConnect)
        g_pConMan->FreeConnectMenu(m_hMenuConnect);
#endif
}

HRESULT CFrontPage::HrInit(FOLDERID idFolder)
{
    WNDCLASS wc;

    if (!GetClassInfo(g_hInst, s_szFrontPageWndClass, &wc))
        {
        wc.style            = 0;
        wc.lpfnWndProc      = CFrontPage::FrontPageWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szFrontPageWndClass;
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
        }

    // Make copies of our pidls
    m_idFolder = idFolder;
    m_ftType = GetFolderType(m_idFolder);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//
    
////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (void*) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CFrontPage::AddRef()
{
    DOUT(TEXT("CFrontPage::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CFrontPage::Release()
{
    DOUT(TEXT("CFrontPage::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CFrontPage::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaView
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::TranslateAccelerator(LPMSG lpmsg)                
{
    // see if the body obj wants to snag it.
    if (m_pBodyObj && m_pBodyObj->HrTranslateAccelerator(lpmsg) == S_OK)
        return S_OK;

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CFrontPage::UIActivate(UINT uActivation)
{
    if (uActivation != SVUIA_DEACTIVATE)
        OnActivate(uActivation);
    else
        OnDeactivate();
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb, 
                                                       RECT *prcView, HWND *phWnd)
{
    m_pShellBrowser = psb;
    Assert(m_pShellBrowser);
    m_pShellBrowser->AddRef();

    m_pShellBrowser->GetWindow(&m_hwndOwner);
    Assert(IsWindow(m_hwndOwner));

    // Load our registry settings
    LoadBaseSettings();
    
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT|WS_EX_CLIENTEDGE,
                            s_szFrontPageWndClass,
                            NULL,
                            WS_VISIBLE|WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
                            prcView->left,
                            prcView->top,
                            prcView->right - prcView->left,
                            prcView->bottom - prcView->top,
                            m_hwndOwner,
                            NULL,
                            g_hInst,
                            (LPVOID)this);

    if (!m_hwnd)
        return E_FAIL;

    *phWnd = m_hwnd;

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::DestroyViewWindow()                
{
    if (m_hwnd)
        {
        HWND hwndDest = m_hwnd;
        m_hwnd = NULL;
        DestroyWindow(hwndDest);
        }
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::SaveViewState()               
{
    // Save our registry settings
    SaveBaseSettings();
    return NOERROR;
}

//
//  FUNCTION:   CFrontPage::OnInitMenuPopup
//
//  PURPOSE:    Called when the user is about to display a menu.  We use this
//              to update the enabled or disabled status of many of the 
//              commands on each menu.
//
//  PARAMETERS:
//      hmenu       - Handle of the main menu.
//      hmenuPopup  - Handle of the popup menu being displayed.
//      uID         - Specifies the id of the menu item that 
//                    invoked the popup.
//
//  RETURN VALUE:
//      Returns S_OK if we process the message.
//
//
#define MF_ENABLEFLAGS(b)   (MF_BYCOMMAND|(b ? MF_ENABLED : MF_GRAYED|MF_DISABLED))
#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b ? MF_CHECKED : MF_UNCHECKED))

HRESULT CFrontPage::OnPopupMenu(HMENU hmenu, HMENU hmenuPopup, UINT uID)
{
    MENUITEMINFO mii;

    // give the docobj a chance to update its menu
    if (m_pBodyObj)
        m_pBodyObj->HrOnInitMenuPopup(hmenuPopup, uID);

    return S_OK;
}

HRESULT CFrontPage::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                OLECMDTEXT *pCmdText)
{
    // Let MimeEdit have a crack at them
    if (m_pBodyObjCT)
    {
        m_pBodyObjCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // handled
    return S_OK;
}


HRESULT CFrontPage::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
                         VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // make sure that the 'go to inbox' check is consistent with what is in the options dlg
    // but we'll still let the browser actually handle the command
/*
    if (nCmdID == ID_OPTIONS)
    {
        if (m_ftType == FOLDER_ROOTNODE)
        {
            VARIANT_BOOL b;
            if (SUCCEEDED(m_pBodyObj->GetSetCheck(FALSE, &b)))
                SetDwOption(OPT_LAUNCH_INBOX, b ? TRUE : FALSE, m_hwnd, 0);
        }
    }
*/
    // check if the body wants to handle it
    if (m_pBodyObjCT && m_pBodyObjCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) == NOERROR)
        return S_OK;

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CFrontPage::OnFrameWindowActivate(BOOL fActivate)
{
    return m_pBodyObj ? m_pBodyObj->HrFrameActivate(fActivate) : S_OK;
}

HRESULT STDMETHODCALLTYPE CFrontPage::GetCurCharSet(UINT *cp)
{
    *cp = GetACP();
    return (E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CFrontPage::UpdateLayout(THIS_ BOOL fPreviewVisible, 
                                                   BOOL fPreviewHeader, 
                                                   BOOL fPreviewVert, BOOL fReload)
{
    return (E_NOTIMPL);
}



////////////////////////////////////////////////////////////////////////
//
//  Message Handling
//
////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CFrontPage::FrontPageWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRet;
    CFrontPage     *pThis;

    if (msg == WM_NCCREATE)
        {
        pThis = (CFrontPage*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
        }
    else
        pThis = (CFrontPage*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    Assert(pThis);

    return pThis->WndProc(hwnd, msg, wParam, lParam);
}

LRESULT CFrontPage::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fTip;

    switch (msg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_NOTIFY,         OnNotify);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       OnSetFocus);


        case WM_COMMAND:
            return SendMessage(m_hwndOwner, msg, wParam, lParam);
    
        case WM_MENUSELECT:
            HandleMenuSelect(m_pStatusBar, wParam, lParam);
            return 0;

        case NVM_INITHEADERS:
            PostCreate();
            return 0;
/*
        case CM_OPTIONADVISE:
            if ((wParam == OPT_LAUNCH_INBOX || wParam == 0xffffffff) && m_ftType == FOLDER_ROOTNODE)
                {
                VARIANT_BOOL b = DwGetOption(OPT_LAUNCH_INBOX) ? VARIANT_TRUE : VARIANT_FALSE;
                m_pBodyObj->GetSetCheck(TRUE, &b);
                }

        case WM_UPDATELAYOUT:
            m_pShellBrowser->GetViewLayout(DISPID_MSGVIEW_TIPOFTHEDAY, 0, &fTip, 0, 0);
            m_pBodyObj->ShowTip(fTip);
            return 0;
*/
        case WM_ACTIVATE:
            {
            HWND hwndFocus;
            DOUT("CFrontPage - WM_ACTIVATE(%#x)", LOWORD(wParam));
            m_pShellBrowser->UpdateToolbar();
            
            if (LOWORD(wParam) != WA_INACTIVE)
                {
                // DefWindowProc will set the focus to our view window, which
                // is not what we want.  Instead, we will let the explorer set
                // the focus to our view window if we should get it, at which
                // point we will set it to the proper control.
                return 0;
                }

            hwndFocus = GetFocus();
            if (IsChild(hwnd, hwndFocus))
                m_hwndCtlFocus = hwndFocus;
            else
                m_pBodyObj->HrGetWindow(&m_hwndCtlFocus);
            }
            break;
        
        case WM_CLOSE:
            // ignore CTRL-F4's
            return 0;        

        case WM_DESTROY:
            OptionUnadvise(hwnd);
            SafeRelease(m_pStatusBar);
            if (m_pBodyObj)
                {
                m_pBodyObj->HrUnloadAll(NULL, 0);
                m_pBodyObj->HrClose();
                }
            return 0;

#ifndef WIN16
        case WM_DISPLAYCHANGE:
#endif
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_pBodyObj)
                {
                HWND hwndBody;
                m_pBodyObj->HrGetWindow(&hwndBody);
                SendMessage(hwndBody, msg, wParam, lParam);
                }
            /* * * FALL THROUGH * * */

        case FTN_PRECHANGE:
        case FTN_POSTCHANGE:
            break;    

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
                {
                HWND hwndFocus = GetFocus();
                if (IsChild(hwnd, hwndFocus))
                    return SendMessage(hwndFocus, msg, wParam, lParam);
                }
            break;
        }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//
//  FUNCTION:   CFrontPage::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to 
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CFrontPage::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    // register for option update notification
    SideAssert(SUCCEEDED(OptionAdvise(hwnd)));

    m_pBodyObj = new CFrontBody(m_ftType, m_pShellBrowser);
    if (!m_pBodyObj)
        goto error;

    if (FAILED(m_pBodyObj->HrInit(hwnd)))
        goto error;

    if (FAILED(m_pBodyObj->HrShow(FALSE)))
        goto error;

    return TRUE;

error:
    return FALSE;
}


//
//  FUNCTION:   CFrontPage::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area. 
//      cyClient - New height of the client area.
//
void CFrontPage::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rcBody, rcFldr;

    GetClientRect(hwnd, &rcBody);
    m_pBodyObj->HrSetSize(&rcBody);
}

//
//  FUNCTION:   CFrontPage::OnSetFocus
//
//  PURPOSE:    If the focus ever is set to the view window, we want to
//              make sure it goes to one of our child windows.  Preferably
//              the focus will go to the last child to have the focus.
//
//  PARAMETERS:
//      hwnd         - Handle of the view window.
//      hwndOldFocus - Handle of the window losing focus.
//
void CFrontPage::OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    FPDOUT("CFrontPage - WM_SETFOCUS");

    // Check to see that we have a window stored to have focus.  If not
    // default to the message list.
    if (!m_hwndCtlFocus || !IsWindow(m_hwndCtlFocus) || m_hwndCtlFocus == m_hwndOwner)
        {
        m_pBodyObj->HrGetWindow(&m_hwndCtlFocus);
        }

    if (m_hwndCtlFocus && IsWindow(m_hwndCtlFocus))
        SetFocus(m_hwndCtlFocus);
}  

//
//  FUNCTION:   CFrontPage::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CFrontPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (pnmhdr->code == NM_SETFOCUS)
        {
        // if we get a setfocus from a kid, and it's not the
        // body, be sure to UIDeactivate the body
        HWND    hwndBody = 0;

        m_pBodyObj->HrGetWindow(&hwndBody);
        if (pnmhdr->hwndFrom != hwndBody)
            m_pBodyObj->HrUIActivate(FALSE);
        m_pShellBrowser->OnViewWindowActive(this);
        }
    return 0;
}
    
BOOL CFrontPage::OnActivate(UINT uActivation)
{
    // if focus stays within the frame, but goes outside our view.
    // ie.. TreeView gets focus then we get an activate nofocus. Be sure
    // to UIDeactivate the docobj in this case
    if (uActivation == SVUIA_ACTIVATE_NOFOCUS)
        m_pBodyObj->HrUIActivate(FALSE);

    if (m_uActivation != uActivation)
        {
        OnDeactivate();
        m_uActivation = uActivation;
        
        SafeRelease(m_pStatusBar);
        m_pShellBrowser->GetStatusBar(&m_pStatusBar);
        if (m_pBodyObj)
            m_pBodyObj->HrSetStatusBar(m_pStatusBar);
        
        if (!m_fFirstActive)
            {
            PostMessage(m_hwnd, NVM_INITHEADERS, 0, 0L);
            m_fFirstActive = TRUE;
            }
        }
    return TRUE;
}

BOOL CFrontPage::OnDeactivate()
{    
    if (m_uActivation != SVUIA_DEACTIVATE)
        {
        m_uActivation = SVUIA_DEACTIVATE;
        if (m_pBodyObj)
            m_pBodyObj->HrSetStatusBar(NULL);
        }
    return TRUE;
}

BOOL CFrontPage::LoadBaseSettings()
{
    return TRUE;
}

BOOL CFrontPage::SaveBaseSettings()
{
    return TRUE;
}

void CFrontPage::PostCreate()
{
    Assert(m_pShellBrowser);

    m_pBodyObj->HrLoadPage();

    ProcessICW(m_hwndOwner, m_ftType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\dllmain.h ===
// --------------------------------------------------------------------------
// DLLMAIN.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class COutlookExpress;
class CNote;
class CBrowser;
class CConnectionManager;
class CSubManager;
class CFontCache;
class CStationery;
class CNote;
interface IMimeAllocator;
interface IImnAccountManager;
interface ISpoolerEngine;
interface IFontCache;
interface IOERulesManager;
typedef struct tagACTIVEFINDFOLDER *LPACTIVEFINDFOLDER;

// --------------------------------------------------------------------------------
// HINITREF - Used internally by msoe.dll
// --------------------------------------------------------------------------------
DECLARE_HANDLE(HINITREF);
typedef HINITREF *LPHINITREF;


// --------------------------------------------------------------------------------
// Enumerations
// --------------------------------------------------------------------------------
typedef enum tagROAMSTATE {
    RS_NO_ROAMING,           // OE not currently roaming any settings
    RS_SETTINGS_DOWNLOADED   // OE has successfully DL'ed settings from cfg svr
} ROAMSTATE;


// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern HINSTANCE                       g_hInst;
extern HINSTANCE                       g_hLocRes;
extern CRITICAL_SECTION                g_csDBListen;
extern CRITICAL_SECTION                g_csgoCommon;
extern CRITICAL_SECTION                g_csgoMail;
extern CRITICAL_SECTION                g_csgoNews;
extern CRITICAL_SECTION                g_csFolderDlg;
extern CRITICAL_SECTION                g_csFmsg;
extern CRITICAL_SECTION                s_csPasswordList;
extern CRITICAL_SECTION                g_csAccountPropCache;
extern CRITICAL_SECTION                g_csMsgrList;
extern CRITICAL_SECTION                g_csThreadList;
extern COutlookExpress                *g_pInstance;
extern HWND                            g_hwndInit,
                                       g_hwndActiveModal;
extern UINT                            g_msgMSWheel;
extern HACCEL                          g_haccelNewsView;
extern DWORD                           g_dwAthenaMode; 
extern IImnAccountManager2            *g_pAcctMan;
extern HMODULE                         g_hlibMAPI;
extern CBrowser                       *g_pBrowser;
extern DWORD                           g_dwSecurityCheckedSchemaProp;
extern CSubManager                    *g_pSubMgr;
extern IMimeAllocator                 *g_pMoleAlloc;
extern CConnectionManager             *g_pConMan;
extern ISpoolerEngine                 *g_pSpooler;
extern IFontCache                     *g_lpIFontCache;
// bobn: brianv says we have to take this out...
//extern DWORD                           g_dwBrowserFlags;
extern UINT                            CF_FILEDESCRIPTORA; 
extern UINT                            CF_FILEDESCRIPTORW; 
extern UINT                            CF_FILECONTENTS;
extern UINT                            CF_HTML;
extern UINT                            CF_INETMSG;
extern UINT                            CF_OEFOLDER;
extern UINT                            CF_SHELLURL;
extern UINT                            CF_OEMESSAGES;
extern UINT                            CF_OESHORTCUT;
extern CStationery                    *g_pStationery;
extern ROAMSTATE                       g_rsRoamState;
extern IOERulesManager                *g_pRulesMan;
extern IMessageStore                  *g_pStore;
extern DWORD                           g_dwTlsTimeout;
extern CRITICAL_SECTION                g_csFindFolder;
extern LPACTIVEFINDFOLDER              g_pHeadFindFolder;
extern SYSTEM_INFO                     g_SystemInfo;
extern OSVERSIONINFO				   g_OSInfo;

extern BOOL                            g_fPluralIDs;
extern UINT                            g_uiCodePage;
extern IDatabaseSession               *g_pDBSession;
extern BOOL                            g_bMirroredOS;

IF_DEBUG(extern DWORD                  TAG_OBJECTDB;)
IF_DEBUG(extern DWORD                  TAG_INITTRACE;)
IF_DEBUG(extern DWORD                  TAG_SERVERQ;)
IF_DEBUG(extern DWORD                  TAG_IMAPSYNC;)


// global OE type-lib. Defer-created in BaseDisp.Cpp
// freed on process detach, protected with CS
extern ITypeLib                        *g_pOETypeLib;
extern CRITICAL_SECTION                g_csOETypeLib;

inline BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }
inline BOOL fIsWhistler()   { return((fIsNT5() && g_OSInfo.dwMinorVersion >=1) || 
            ((g_OSInfo.dwMajorVersion > 5) &&  (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))); }


#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\factory.cpp ===
// --------------------------------------------------------------------------------
// FACTORY.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "factory.h"
#include "instance.h"
#include "header.h"
#include "ourguid.h"
#include "msgtable.h"
#include "envguid.h"
#include "istore.h"
#include "store.h"
#include "note.h"
#include "msoeobj.h"
#include "..\imap\imapsync.h"
#include "newsstor.h"
#include "msgfldr.h"
#include "store.h"
#include "..\http\httpserv.h"
#include <storsync.h>
#include <ruleutil.h>
#ifdef OE_MOM
#include "..\om\session.h"
#include "..\om\table.h"
#endif

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

//HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
#define PFCI(_pfn) ((PFCREATEINSTANCE)_pfn)
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_MessageStore,      OBJTYPE0, PFCI(CreateMessageStore)),
    CClassFactory(&CLSID_MigrateMessageStore, OBJTYPE0, PFCI(CreateMigrateMessageStore)),
    CClassFactory(&CLSID_StoreNamespace,    OBJTYPE0, PFCI(CreateInstance_StoreNamespace)),
    CClassFactory(&CLSID_OEEnvelope,        OBJTYPE0, PFCI(CreateInstance_Envelope)),
    CClassFactory(&CLSID_OENote,            OBJTYPE0, PFCI(CreateOENote)),
    CClassFactory(&CLSID_MessageDatabase,   OBJTYPE0, PFCI(CreateMsgDbExtension)),    
    CClassFactory(&CLSID_FolderDatabase,    OBJTYPE0, PFCI(CreateFolderDatabaseExt)),    
#ifdef OE_MOM
    CClassFactory(&CLSID_OESession,         OBJTYPE1, PFCI(CreateInstance_OESession)),
    CClassFactory(&CLSID_OEMsgTable,        OBJTYPE1, PFCI(CreateInstance_OEMsgTable)),
#endif
    CClassFactory(&CLSID_OERulesManager,    OBJTYPE0, PFCI(HrCreateRulesManager)),
};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Trace
    TraceCall("DllGetClassObject");

    // Bad param
    if (ppv == NULL)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            IF_FAILEXIT(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, let the ATL creator have a shot
    if (SUCCEEDED(hr = _Module.GetClassObject(rclsid, riid, ppv)))
        goto exit;

    // Otherwise, no class
    hr = TraceResult(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // TraceCall
    TraceCall("CClassFactory::QueryInterface");

    // Invalid Arg
    if (NULL == ppvObj)
        return TraceResult(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TraceResult(E_INVALIDARG);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    g_pInstance->DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    g_pInstance->DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    g_pInstance->DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Trace
    TraceCall("CClassFactory::CreateInstance");

    // Bad param
    if (ppvObj == NULL)
        return TraceResult(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TraceResult(CLASS_E_NOAGGREGATION);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TraceResult(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = (*m_pfCreateInstance)(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        IF_FAILEXIT(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    return g_pInstance->LockServer(fLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\frntpage.h ===
/* *
   * Front Page IAthenaView implementation
   * 
   * Apr 97: EricAn
   */

#ifndef _FRNTPAGE_H
#define _FRNTPAGE_H

// for IAthenaView
#include "browser.h"

class CFrontBody;

/////////////////////////////////////////////////////////////////////////////
//
// Types 
//

/////////////////////////////////////////////////////////////////////////////
// 
// Exported functions
//

/////////////////////////////////////////////////////////////////////////////
//
// Global Exported Data
//

/////////////////////////////////////////////////////////////////////////////
//
// CCommonView
//

class CFrontPage :
    public IViewWindow,
    public IOleCommandTarget,
    public IMessageWindow
{
public:
    /////////////////////////////////////////////////////////////////////////
    //
    // OLE Interfaces
    //
    
    // IUnknown 
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG   STDMETHODCALLTYPE AddRef(void);
    virtual ULONG   STDMETHODCALLTYPE Release(void);

    // IOleWindow
    HRESULT STDMETHODCALLTYPE GetWindow(HWND * lphwnd);                         
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
    // IViewWindow
    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
    HRESULT STDMETHODCALLTYPE UIActivate(UINT uState);
    HRESULT STDMETHODCALLTYPE CreateViewWindow(IViewWindow  *lpPrevView, IAthenaBrowser * psb, 
                                               RECT * prcView, HWND * phWnd);
    HRESULT STDMETHODCALLTYPE DestroyViewWindow();
    HRESULT STDMETHODCALLTYPE SaveViewState();
    HRESULT STDMETHODCALLTYPE OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID);
    
    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                     OLECMDTEXT *pCmdText); 
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // IMessageWindow
    //

    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate);
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp);
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload);
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList) {return E_NOTIMPL;}
    
    //
    // Constructors, Destructors, and Initialization
    //
    CFrontPage();
    virtual ~CFrontPage();
    HRESULT HrInit(FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    //
    // virtuals
    //
    
    /////////////////////////////////////////////////////////////////////////
    //
    // accessors
    //
//    LPITEMIDLIST   PidlRoot()   { return m_pidlRoot; }
//    LPFOLDERIDLIST Fidl()       { return m_fidl; }
    HWND           HwndOwner()  { return m_hwndOwner; }
    
private:
    BOOL    LoadBaseSettings();
    BOOL    SaveBaseSettings();

    /////////////////////////////////////////////////////////////////////////
    //
    // Callback Functions
    //
    // Note: All callbacks must be made static members to avoid having the 
    //       implicit "this" pointer passed as the first parameter.
    //
    static LRESULT CALLBACK FrontPageWndProc(HWND, UINT, WPARAM, LPARAM);
                                          
    /////////////////////////////////////////////////////////////////////////
    //
    // Message Handling
    //
    LRESULT WndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void    OnSetFocus(HWND hwnd, HWND hwndOldFocus);
    void    PostCreate();

    /////////////////////////////////////////////////////////////////////////
    //
    // Shell Interface Handling
    //
    BOOL    OnActivate(UINT uActivation);
    BOOL    OnDeactivate();

private:
    /////////////////////////////////////////////////////////////////////////
    // 
    // Private Data
    //

    /////////////////////////////////////////////////////////////////////////
    // Shell Stuff
    UINT                m_cRef;
    FOLDERID            m_idFolder;
    FOLDERTYPE          m_ftType;
    IAthenaBrowser     *m_pShellBrowser;
    BOOL                m_fFirstActive;
    UINT                m_uActivation;
    HWND                m_hwndOwner;                  // Owner window
    HWND                m_hwnd;                       // Our window
    HWND                m_hwndCtlFocus;               // Child control to set focus to
#ifndef WIN16  // No RAS support in Win16
    HMENU               m_hMenuConnect;
#endif
    
    /////////////////////////////////////////////////////////////////////////
    // Child support
    CFrontBody         *m_pBodyObj;
    IOleCommandTarget  *m_pBodyObjCT;
    CStatusBar         *m_pStatusBar;

    /////////////////////////////////////////////////////////////////////////
    // Language support
        
    /////////////////////////////////////////////////////////////////////////
    // Layout members
};

#endif // _FRNTPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\instance.h ===
// --------------------------------------------------------------------------------
// INSTANCE.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __INSTANCE_H
#define __INSTANCE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include <msoeapi.h>

// --------------------------------------------------------------------------------
// Macros
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define CoIncrementInit(_pszSource, _dwFlags, _pszCmdLine, _phInitRef) \
    g_pInstance->CoIncrementInitDebug(_pszSource, _dwFlags, _pszCmdLine, _phInitRef)
#define CoDecrementInit(_pszSource, _phInitRef) \
    g_pInstance->CoDecrementInitDebug(_pszSource, _phInitRef)
#else
#define CoIncrementInit(_pszSource, _dwFlags, _pszCmdLine, _phInitRef) \
    g_pInstance->CoIncrementInitImpl(_dwFlags, _pszCmdLine, _phInitRef)
#define CoDecrementInit(_pszSource, _phInitRef) \
    g_pInstance->CoDecrementInitImpl(_phInitRef)
#endif // DEBUG

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
extern DWORD g_dwHideMessenger;

#define BL_DISP         0
#define BL_CHECK        1
#define BL_HIDE         2
#define BL_NOTINST      10
#define BL_DISABLE      (BL_CHECK | BL_NOTINST)
#define BL_DEFAULT      BL_CHECK

// --------------------------------------------------------------------------------
// User Window Messages
// --------------------------------------------------------------------------------
#define ITM_SHUTDOWNTHREAD          (WM_USER)
#define ITM_CREATENOTEWINDOW        (WM_USER+1)
#define ITM_CREATEWMSUINOTE         (WM_USER+2)
#define ITM_CALLGENERICVOIDFN       (WM_USER+3)
#define ITM_CALLFINDWINDOW          (WM_USER+4)  // wparam == OFTYPE - see enumeration above.
#define ITM_CREATEREMINDWINDOW      (WM_USER+5)
#define ITM_MAPILOGON               (WM_USER+6)
#define ITM_OPENSTORE               (WM_USER+7)
#define ITM_OPENAB                  (WM_USER+8)
#define ITM_REDOCOLUMNS             (WM_USER+9)
#define ITM_OPENNEWSSTORE           (WM_USER+10)
#define ITM_CLOSENOTES              (WM_USER+11) // this note is passed when we need to close a note.
#define ITM_CHECKCONFIG             (WM_USER+12)
#define ITM_CREATENEWSNOTEWINDOW    (WM_USER+13)
#define ITM_OPTIONADVISE            (WM_USER+14) // wparam = PFNOPTNOTIFY, lparam = LPARAM
#define ITM_OPTIONUNADVISE          (WM_USER+15) // wparam = PFNOPTNOTIFY
#define ITM_GOPTIONSCHANGED         (WM_USER+16)
#define ITM_BROWSETOOBJECT          (WM_USER+17)
#define ITM_IDENTITYMSG             (WM_USER+18)
#define ITM_POSTCOPYDATA            (WM_USER+19)
#define ITM_WAB_CO_DECREMENT        (WM_USER+20)

// --------------------------------------------------------------------------------
// Startup Modes
// --------------------------------------------------------------------------------
#define MODE_NEWSONLY       0x00000001
#define MODE_OUTLOOKNEWS   (0x00000002 | MODE_NEWSONLY | MODE_NOIDENTITIES)
#define MODE_MAILONLY       0x00000004
#define MODE_NOIDENTITIES   0x00000008
#define MODE_EXAM           0x00000010
#define MODE_PLE            0x00000020
#define MODE_JUNKMAIL       0x00000040

// --------------------------------------------------------------------------------
// TRAYICONACTION
// --------------------------------------------------------------------------------
typedef enum tagTRAYICONACTION {
    TRAYICONACTION_ADD,
    TRAYICONACTION_REMOVE
} TRAYICONACTION;

// --------------------------------------------------------------------------------
// REPORTERRORINFO
// --------------------------------------------------------------------------------
typedef struct tagREPORTERRORINFO {
    UINT                nTitleIds;          // Title of the messagebox
    UINT                nPrefixIds;         // Prefix string resource id
    UINT                nErrorIds;          // Error string resource id
    UINT                nReasonIds;         // Reason string resource id
    BOOL                nHelpIds;           // Help String Resource Id
    LPCSTR              pszExtra1;          // Extra parameter 1
    ULONG               ulLastError;        // GetLastError() Value
} REPORTERRORINFO, *LPREPORTERRORINFO;

// --------------------------------------------------------------------------------
// COutlookExpress
// --------------------------------------------------------------------------------
class COutlookExpress : public IOutlookExpress
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    COutlookExpress(void);
    ~COutlookExpress(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IOutlookExpress Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Start(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow);

    // ----------------------------------------------------------------------------
    // Initialize / Uninitialize
    // ----------------------------------------------------------------------------
#ifdef DEBUG
    HRESULT CoIncrementInitDebug(LPCSTR pwszSource, DWORD dwFlags, LPCWSTR pszCmdLine, LPHINITREF phInitRef);
    HRESULT CoDecrementInitDebug(LPCSTR pwszSource, LPHINITREF phInitRef);
#endif // DEBUG

    HRESULT CoIncrementInitImpl(DWORD dwFlags, LPCWSTR pwszCmdLine, LPHINITREF phInitRef);
    HRESULT CoDecrementInitImpl(LPHINITREF phInitRef);

    // ----------------------------------------------------------------------------
    // DllAddRef / DllRelease
    // ----------------------------------------------------------------------------
    HRESULT DllAddRef(void);
    HRESULT DllRelease(void);

    // ----------------------------------------------------------------------------
    // LockServer - Called from CClassFactory Implementation
    // ----------------------------------------------------------------------------
    HRESULT LockServer(BOOL fLock);

    // ----------------------------------------------------------------------------
    // DllCanUnloadNow
    // ----------------------------------------------------------------------------
    HRESULT DllCanUnloadNow(void) {
        HRESULT hr;

        if ((m_cDllInit <= 0) && 
            (m_cDllRef  <= 0) && 
            (m_cDllLock <= 0))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
        return hr;
    }

    // ----------------------------------------------------------------------------
    // Defered Init/Deinit Methods
    // ----------------------------------------------------------------------------
    HRESULT ProcessCommandLine(INT nCmdShow, LPWSTR pwszCmdLineIn, BOOL *pfErrorDisplayed);
    HRESULT BrowseToObject(UINT nCmdShow, FOLDERID idFolder);
    HRESULT ActivateWindow(HWND hwnd);

    // ----------------------------------------------------------------------------
    // Multi-user startup/shutdown
    // ----------------------------------------------------------------------------
    HRESULT SetSwitchingUsers(BOOL bSwitching);
    BOOL    SwitchingUsers(void)                    {return m_fSwitchingUsers;}
    void    SetSwitchToUser(TCHAR *lpszUserName);
    // ----------------------------------------------------------------------------
    // InitWndProc
    // ----------------------------------------------------------------------------
    static LRESULT EXPORT_16 CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    // ----------------------------------------------------------------------------
    // Tray Notification Icon Stuff
    // ----------------------------------------------------------------------------
    HRESULT UpdateTrayIcon(TRAYICONACTION type);
    void CloseSplashScreen(void);

private:
    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    HRESULT _HandleMailURL(LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed);
    HRESULT _HandleNewsURL(INT nCmdShow, LPWSTR pwszCmd, BOOL *pfErrorDisplayed);
    HRESULT _HandleFile(LPWSTR pwszCmd, BOOL *pfErrorDisplayed, BOOL fNews);
    HRESULT _HandleNewsArticleURL(LPSTR pszServerIn, LPSTR pszArticle, UINT uPort, BOOL fSecure, BOOL *pfErrorDisplayed);
    void    _HandleTrayIconEvent(WPARAM wParam, LPARAM lParam);
    HRESULT _ValidateDll(LPCSTR pszDll, BOOL fDemandResult, HMODULE hModule, HRESULT hrLoadError, HRESULT hrVersionError, LPREPORTERRORINFO pError);
    BOOL    _ReportError(HINSTANCE hInstance, HRESULT hrResult, LONG lResult, LPREPORTERRORINFO pInfo);
    HRESULT _CoDecrementInitMain(LPHINITREF phInitRef=NULL);
    void    _ProcessCommandLineFlags(LPWSTR *ppwszCmdLine, DWORD dwFlags);

private:
    // ----------------------------------------------------------------------------
    // PrivateData
    // ----------------------------------------------------------------------------
    LONG                m_cRef;                 // Reference Count
    HANDLE              m_hInstMutex;           // Startup/Shutdown mutex
    BOOL                m_fPumpingMsgs;         // Do we have a message pump running ?
    LONG                m_cDllRef;              // Dll Reference Count
    LONG                m_cDllLock;             // Dll Reference Count
    LONG                m_cDllInit;             // Number of inits
    DWORD               m_dwThreadId;           // Thread that I was created on
    CRITICAL_SECTION    m_cs;                   // Thread Safety
    BOOL                m_fSwitchingUsers;      // Multiple user switch is happening
    TCHAR *             m_szSwitchToUsername;   // Switching to a specific user
    HWND                m_hwndSplash;
    ISplashScreen      *m_pSplash;
    BOOL                m_fIncremented;
    HICON               m_hTrayIcon;
};

#endif // __INSTANCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\instance.cpp ===
// --------------------------------------------------------------------------------
// INSTANCE.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "acctutil.h"
#include "inetcfg.h"
#include <storfldr.h>
#include "zmouse.h"
#include "migrate.h"
#include <notify.h>
#include "conman.h"
#include "browser.h"
#include "note.h"
#include "reutil.h"
#include "spengine.h"
#include "addrobj.h"
#include "statnery.h"
#include "thumb.h"
#include "imagelst.h"
#include "url.h"
#include "secutil.h"
#include "shlwapip.h"
#include "ruleutil.h"
#include "newfldr.h"
#include "envfact.h"
#include "storutil.h"
#include "multiusr.h"
#include "newsstor.h"
#include "storutil.h"
#include <storsync.h>
#include "cleanup.h"
#include <grplist2.h>
#include <newsutil.h>
#include <sync.h>
#include "menures.h"
#include "shared.h"
#include "acctcach.h"
#include <inetreg.h>
#include <mapiutil.h>
#include "useragnt.h"
#include "demand.h"
#include <ieguidp.h>

static DWORD g_dwAcctAdvise = 0xffffffff;
DWORD g_dwHideMessenger = BL_DEFAULT;
extern BOOL g_fMigrationDone;
extern UINT GetCurColorRes(void);

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
void SimpleMAPICleanup(void); // smapi.cpp
BOOL DemandLoadMSOEACCT(void);
BOOL DemandLoadMSOERT2(void);
BOOL DemandLoadINETCOMM(void);

// --------------------------------------------------------------------------------
// Init Common Control Flags
// --------------------------------------------------------------------------------
#define ICC_FLAGS (ICC_WIN95_CLASSES|ICC_DATE_CLASSES|ICC_PAGESCROLLER_CLASS|ICC_USEREX_CLASSES|ICC_COOL_CLASSES|ICC_NATIVEFNTCTL_CLASS)

#ifdef DEBUG
// --------------------------------------------------------------------------------
// INITSOURCEINFO
// --------------------------------------------------------------------------------
typedef struct tagINITSOURCEINFO *LPINITSOURCEINFO;
typedef struct tagINITSOURCEINFO {
    LPSTR               pszSource;
    DWORD               cRefs;
    LPINITSOURCEINFO    pNext;
} INITSOURCEINFO;

static LPINITSOURCEINFO g_InitSourceHead=NULL;

#endif // DEBUG

// --------------------------------------------------------------------------------
// MAKEERROR
// --------------------------------------------------------------------------------
#define MAKEERROR(_pInfo, _nPrefixIds, _nErrorIds, _nReasonIds, _pszExtra1) \
    { \
        (_pInfo)->nTitleIds = idsAthena; \
        (_pInfo)->nPrefixIds = _nPrefixIds; \
        (_pInfo)->nErrorIds = _nErrorIds; \
        (_pInfo)->nReasonIds = _nReasonIds; \
        (_pInfo)->nHelpIds = IDS_ERROR_START_HELP; \
        (_pInfo)->pszExtra1 = _pszExtra1; \
        (_pInfo)->ulLastError = GetLastError(); \
    }

// --------------------------------------------------------------------------------
// CoStartOutlookExpress
// --------------------------------------------------------------------------------
MSOEAPI CoStartOutlookExpress(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow)
{
    // Tracing
    TraceCall("CoStartOutlookExpress");

    // Verify that we have an outlook express object
    Assert(g_pInstance);

    // E_OUTOFMEMORY
    if (NULL == g_pInstance)
    {
        // We should show an error, but the liklyhood of this happening is almost zero
        return TraceResult(E_OUTOFMEMORY);
    }

    // Run...
    return g_pInstance->Start(dwFlags, pwszCmdLine, nCmdShow);
}

// --------------------------------------------------------------------------------
// CoCreateOutlookExpress
// --------------------------------------------------------------------------------
MSOEAPI CoCreateOutlookExpress(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CoCreateOutlookExpress");

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // No global object yet ?
    AssertSz(g_pInstance, "This gets created in dllmain.cpp DllProcessAttach.");

    // Lets not crash
    if (NULL == g_pInstance)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // AddRef that badboy
    g_pInstance->AddRef();

    // Return the Innter
    *ppUnknown = SAFECAST(g_pInstance, IOutlookExpress *);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::COutlookExpress
// --------------------------------------------------------------------------------
COutlookExpress::COutlookExpress(void)
{
    // Trace
    TraceCall("COutlookExpress::COutlookExpress");

    // Init Members
    m_cRef = 1;
    m_hInstMutex = NULL;
    m_fPumpingMsgs = FALSE;
    m_cDllRef = 0;
    m_cDllLock = 0;
    m_cDllInit = 0;
    m_dwThreadId = GetCurrentThreadId();
    m_fSwitchingUsers = FALSE;
    m_szSwitchToUsername = NULL;
    m_hwndSplash        = NULL;
    m_pSplash           = NULL;
    m_fIncremented      = FALSE;
    m_hTrayIcon = 0;

    // Init Thread Safety
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// COutlookExpress::~COutlookExpress
// --------------------------------------------------------------------------------
COutlookExpress::~COutlookExpress(void)
{
    // Trace
    TraceCall("COutlookExpress::~COutlookExpress");

    // We should have been un-inited
    Assert(0 == m_cDllInit && 0 == m_cDllRef && 0 == m_cDllLock);

    // Free the mutex
    SafeCloseHandle(m_hInstMutex);

    // Kill CritSect
    DeleteCriticalSection(&m_cs);

    if(m_hTrayIcon)
    {
        DestroyIcon(m_hTrayIcon);
    }

    // Free the switch to if necessary
    if (m_szSwitchToUsername)
        MemFree(m_szSwitchToUsername);
}

// --------------------------------------------------------------------------------
// COutlookExpress::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP COutlookExpress::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::QueryInterface");

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IOutlookExpress == riid)
        *ppv = (IOutlookExpress *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COutlookExpress::AddRef(void)
{
    TraceCall("COutlookExpress::AddRef");
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// COutlookExpress::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COutlookExpress::Release(void)
{
    TraceCall("COutlookExpress::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// COutlookExpress::LockServer
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::LockServer(BOOL fLock)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::LockServer");

    if (TRUE == fLock)
    {
        InterlockedIncrement(&m_cDllLock);
    }
    else
    {
        InterlockedDecrement(&m_cDllLock);
    }
    
    // Trace
    //TraceInfo(_MSG("Lock: %d, CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", fLock, m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::DllAddRef
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::DllAddRef(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::DllAddRef");

    // Thread Safety
    if (InterlockedIncrement(&m_cDllRef) <= 0)
    {
        // refcount already below zero
        hr = S_FALSE;
    }

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::DllRelease
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::DllRelease(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::DllRelease");

    // Thread Safety
    if (InterlockedDecrement(&m_cDllRef) < 0)
    {
        // refcount already below zero
        hr = S_FALSE;
    }

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// _CheckForJunkMail
// --------------------------------------------------------------------------------
void _CheckForJunkMail()
{
    HKEY hkey;
    DWORD dw=0, cb;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegRoot, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(dw);
        RegQueryValueEx(hkey, c_szRegJunkMailOn, 0, NULL, (LPBYTE)&dw, &cb);

        if (dw)
            g_dwAthenaMode |= MODE_JUNKMAIL;

        RegCloseKey(hkey);
    }

}


// --------------------------------------------------------------------------------
// COutlookExpress::Start
// --------------------------------------------------------------------------------
STDMETHODIMP COutlookExpress::Start(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow)
{
    // Locals
    HRESULT     hr=S_OK;
    MSG         msg;
    HWND        hwndTimeout;
    HINITREF    hInitRef=NULL;
    BOOL        fErrorDisplayed=FALSE;
    LPWSTR      pwszFree=NULL;
    LPWSTR      pwszCmdLineDup = NULL;

    // Stack
    TraceCall("COutlookExpress::Start");

    // Make sure OLE is initialized on the thread
    OleInitialize(NULL);

    // Duplicate It
    IF_NULLEXIT(pwszCmdLineDup = PszDupW(pwszCmdLine));

    // pwszCmdLineDup will change, remember the allocated block
    pwszFree = pwszCmdLineDup;

    //We want to process the switches set the mode flags before we call CoIncrementInit
    _ProcessCommandLineFlags(&pwszCmdLineDup, dwFlags);

    // AddRef the Dll..
    hr = CoIncrementInit("COutlookExpress", dwFlags, pwszCmdLine, &hInitRef);
    if (FAILED(hr))
    {
        fErrorDisplayed = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Process the Command Line..
    IF_FAILEXIT(hr = ProcessCommandLine(nCmdShow, pwszCmdLineDup, &fErrorDisplayed));

    // No splash screen
    CloseSplashScreen();

    // Do a CoDecrementInit
    IF_FAILEXIT(hr = CoDecrementInit("COutlookExpress", &hInitRef));

    // No need for a Message Pump ?
    if (S_OK == DllCanUnloadNow() || FALSE == ISFLAGSET(dwFlags, MSOEAPI_START_MESSAGEPUMP))
        goto exit;

    // Start the message Pump
    EnterCriticalSection(&m_cs);

    // Do we already have a pump running ?
    if (TRUE == m_fPumpingMsgs)
    {
        LeaveCriticalSection(&m_cs);
        goto exit;
    }

    // We are going to pump
    m_fPumpingMsgs = TRUE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);
    SetSwitchingUsers(FALSE);

    // Message Loop
    while (GetMessageWrapW(&msg, NULL, 0, 0) && ((m_cDllInit > 0) || !SwitchingUsers()))
    {
        CNote *pNote = GetTlsGlobalActiveNote();

        // Ask it to translate an accelerator
        if (g_pBrowser && g_pBrowser->TranslateAccelerator(&msg) == S_OK)
            continue;

        // Hand message off to the active note, but ignore init window msgs and ignore per-task msgs where hwnd=0
        if (msg.hwnd != g_hwndInit && IsWindow(msg.hwnd))
        {
            pNote = GetTlsGlobalActiveNote();
            // Give it to the active note if a note has focus, call it's XLateAccelerator...
            if (pNote && pNote->TranslateAccelerator(&msg) == S_OK)
                continue;
        }

        // Get Timeout Window for this thread
        hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

        // Check for Is modeless timeout dialog window message
        if (hwndTimeout && TRUE == IsDialogMessageWrapW(hwndTimeout, &msg))
            continue;

        // If Still not processed
        TranslateMessage(&msg);
        DispatchMessageWrapW(&msg);
    }

    // We are no longer pumping messages
    EnterCriticalSection(&m_cs);
    m_fPumpingMsgs = FALSE;
    LeaveCriticalSection(&m_cs);

    if(SwitchingUsers())
    {
        HrCloseWabWindow();
        while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessageWrapW(&msg);
        }
        MU_ResetRegRoot();
    }
exit:

    // Free command line copy
    SafeMemFree(pwszFree);

    // Do a CoDecrementInit
    CoDecrementInit("COutlookExpress", &hInitRef);

    // No splash screen
    CloseSplashScreen();
    
    // Is there an error ?
    if (FALSE == fErrorDisplayed && FAILED(hr) && 
        hrUserCancel != hr &&
        MAPI_E_USER_CANCEL != hr)
    {
        REPORTERRORINFO rError={0};
        
        MAKEERROR(&rError, 0, IDS_ERROR_UNKNOWN, 0, NULL);
        _ReportError(g_hLocRes, hr, 0, &rError);
    }

    //Bug #101360 - (erici) OleInitialize created a window, this destroys it.
    OleUninitialize();

    // Done
    return (SwitchingUsers() ? S_RESTART_OE : hr);
}

// --------------------------------------------------------------------------------
// COutlookExpress::_ReportError
// --------------------------------------------------------------------------------
BOOL COutlookExpress::_ReportError(
    HINSTANCE           hInstance,          // Dll Instance
    HRESULT             hrResult,           // HRESULT of the error
    LONG                lResult,            // LRESULT from like a registry function
    LPREPORTERRORINFO   pInfo)              // Report Error Information
{
    // Locals
    TCHAR       szRes[255],
                szMessage[1024],
                szTitle[128];

    // INit
    *szMessage = '\0';

    // Is there a prefix
    if (pInfo->nPrefixIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nPrefixIds, szMessage, ARRAYSIZE(szMessage));
    }

    // Error ?
    if (pInfo->nErrorIds)
    {
        // Are there extras in this error string
        if (NULL != pInfo->pszExtra1)
        {
            // Locals
            TCHAR szTemp[255];

            // Load and format
            LoadString(hInstance, pInfo->nErrorIds, szTemp, ARRAYSIZE(szTemp));

            // Format the string
            wnsprintf(szRes, ARRAYSIZE(szRes), szTemp, pInfo->pszExtra1);
        }

        // Load the string
        else
        {
            // Load the error string
            LoadString(hInstance, pInfo->nErrorIds, szRes, ARRAYSIZE(szRes));
        }

        // Add to szMessage
        StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
        StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));
    }

    // Reason ?
    if (pInfo->nReasonIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nReasonIds, szRes, ARRAYSIZE(szRes));

        // Add to szMessage
        StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
        StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));
    }

    // Load the string
    LoadString(hInstance, pInfo->nHelpIds, szRes, ARRAYSIZE(szRes));

    // Add to szMessage
    StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
    StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));

    // Append Error Results
    if (lResult != 0 && E_FAIL == hrResult && pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(%d, %d)", lResult, pInfo->ulLastError);
    else if (lResult != 0 && E_FAIL == hrResult && 0 == pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(%d)", lResult);
    else if (pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(0x%08X, %d)", hrResult, pInfo->ulLastError);
    else
        wnsprintf(szRes, ARRAYSIZE(szRes), "(0x%08X)", hrResult);

    // Add to szMessage
    StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
    StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));

    // Get the title
    LoadString(hInstance, pInfo->nTitleIds, szTitle, ARRAYSIZE(szTitle));

    // Show the error message
    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);

    // Done
    return TRUE;
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// COutlookExpress::_ValidateDll
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_ValidateDll(LPCSTR pszDll, BOOL fDemandResult, HMODULE hModule,
    HRESULT hrLoadError, HRESULT hrVersionError, LPREPORTERRORINFO pError)
{
    // Locals
    HRESULT                 hr=S_OK;
    PFNGETDLLMAJORVERSION   pfnGetVersion;

    // Tracing
    TraceCall("COutlookExpress::_ValidateDll");

    // We must load these here in order to show errors and not crash - Load MSOERT2.DLL
    if (FALSE == fDemandResult)
    {
        MAKEERROR(pError, IDS_ERROR_PREFIX1, IDS_ERROR_MISSING_DLL, IDS_ERROR_REASON2, pszDll);
        hr = TraceResult(hrLoadError);
        goto exit;
    }

    // Try to get the current verion
    else
    {
        // Get Version Proc Address
        pfnGetVersion = (PFNGETDLLMAJORVERSION)GetProcAddress(hModule, STR_GETDLLMAJORVERSION);

        // Not the Correct Version
        if (NULL == pfnGetVersion || OEDLL_VERSION_CURRENT != (*pfnGetVersion)())
        {
            MAKEERROR(pError, IDS_ERROR_PREFIX1, IDS_ERROR_BADVER_DLL, IDS_ERROR_REASON2, pszDll);
            hr = TraceResult(hrVersionError);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}
#endif // DEAD

// --------------------------------------------------------------------------------
// COutlookExpress::CoIncrementInitDebug
// --------------------------------------------------------------------------------
#ifdef DEBUG
HRESULT COutlookExpress::CoIncrementInitDebug(LPCSTR pszSource, DWORD dwFlags, 
    LPCWSTR pwszCmdLine, LPHINITREF phInitRef)
{
    // Locals
    BOOL                fFound=FALSE;
    LPINITSOURCEINFO    pCurrent;

    // Trace
    TraceCall("COutlookExpress::CoIncrementInitDebug");

    // Invalid Args
    Assert(pszSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find Source
    for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
    {
        // Is this It ?
        if (lstrcmpi(pszSource, pCurrent->pszSource) == 0)
        {
            // Increment Reference Count
            pCurrent->cRefs++;

            // Found
            fFound = TRUE;

            // Done
            break;
        }
    }

    // Not Found, lets add one
    if (FALSE == fFound)
    {
        // Set pCurrent
        pCurrent = (LPINITSOURCEINFO)ZeroAllocate(sizeof(INITSOURCEINFO));
        Assert(pCurrent);

        // Set pszSource
        pCurrent->pszSource = PszDupA(pszSource);
        Assert(pCurrent->pszSource);

        // Set cRefs
        pCurrent->cRefs = 1;

        // Set Next
        pCurrent->pNext = g_InitSourceHead;
        
        // Set Head
        g_InitSourceHead = pCurrent;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Call the Actual CoIncrementInit
    return(CoIncrementInitImpl(dwFlags, pwszCmdLine, phInitRef));
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// COutlookExpress::CoIncrementInitImpl
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::CoIncrementInitImpl(DWORD dwFlags, LPCWSTR pwszCmdLine, LPHINITREF phInitRef)
{
    // Locals
    HRESULT                 hr=S_OK;
    DWORD                   dw;
    RECT                    rc={0};
    HWND                    hwndDesk;
    DWORD                   dwSize;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };
    CImnAdviseAccount      *pImnAdviseAccount=NULL;
    WNDCLASSW               wcW;
    WNDCLASS                wc;
    DWORD                   dwType, dwVal, cb;
    REPORTERRORINFO         rError={0};
    LONG                    lResult=0;
    LPCWSTR                 pwszInitWndClass;
	BOOL					fReleaseMutex=FALSE;
    BOOL                    fResult;
    CHAR                    szFolder[MAX_PATH];
    IF_DEBUG(DWORD          dwTickStart=GetTickCount());

    // Tracing
    TraceCall("COutlookExpress::CoIncrementInitImpl");

    // Make sure OLE is initialized on the thread
    OleInitialize(NULL);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

	if (!SwitchingUsers() && !m_fIncremented)
    {
        SetQueryNetSessionCount(SESSION_INCREMENT_NODEFAULTBROWSERCHECK);
        m_fIncremented = TRUE;
    }

    // Increment Reference Count
    m_cDllInit++;

    // Set phInitRef
    if (phInitRef)
        *phInitRef = (HINITREF)((ULONG_PTR)m_cDllInit);

    // First-Time Reference
    if (m_cDllInit > 1)
    {
        LeaveCriticalSection(&m_cs);
        return S_OK;
    }

    // Leave CS (This code always runs on the same primary thread
    LeaveCriticalSection(&m_cs);

    if (FAILED(hr = MU_Init(ISFLAGSET(dwFlags, MSOEAPI_START_DEFAULTIDENTITY))))
        goto exit;

    // Is there more than one identity?
    g_fPluralIDs = 1 < MU_CountUsers();

    if (!MU_Login(GetDesktopWindow(), FALSE, NULL))
    {
        hr = hrUserCancel;
        goto exit;
    }

    // Create the instance mutex
    if (NULL == m_hInstMutex)
    {
        m_hInstMutex = CreateMutex(NULL, FALSE, STR_MSOEAPI_INSTANCEMUTEX);
        if (NULL == m_hInstMutex)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_INSTMUTEX, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Release m_hInstMutex if it is currently owned by this thread, allow new instances to start.
    if (FALSE == ISFLAGSET(dwFlags, MSOEAPI_START_INSTANCEMUTEX))
    {
        // Lets grab the mutex ourselves
        WaitForSingleObject(m_hInstMutex, INFINITE);
    }

    // Release the mutex
    fReleaseMutex = TRUE;

    // Must init thread on primary instnance thread

    // If the thread id is zero, then we have uninitialized everything.
    // Which means we need to re-initialize everything
    if (0 == m_dwThreadId)
    {
        m_dwThreadId = GetCurrentThreadId();
    }
    
    AssertSz(m_dwThreadId == GetCurrentThreadId(), "We are not doing first CoIncrementInit on the thread in which g_pInstance was created on.");

    // Set g_dwAthenaMode
    _CheckForJunkMail();

    // Get MimeOle IMalloc Interface
    if (NULL == g_pMoleAlloc)
    {
        hr = MimeOleGetAllocator(&g_pMoleAlloc);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_MIMEOLE_ALLOCATOR, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Set OE5 mode for INetcomm.
    MimeOleSetCompatMode(MIMEOLE_COMPAT_MLANG2);

    // Create the Database Session Object
    if (NULL == g_pDBSession)
    {
        hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&g_pDBSession); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_OPEN_STORE, IDS_ERROR_REASON1, NULL);
            goto exit;
        }
    }

    // all migration and upgrade happens in here now.
    hr = MigrateAndUpgrade();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Only if there is a command line...
    if (pwszCmdLine)
    {
        LPSTR pszCmdLine = NULL;
        // If this returns S_OK, we have launched the first-run ICW exe and we need to go away. 
        // this is consistent with IE and forces the user to deal with the ICW before partying with us.
        IF_NULLEXIT(pszCmdLine = PszToANSI(CP_ACP, pwszCmdLine));

        hr = NeedToRunICW(pszCmdLine);
        
        MemFree(pszCmdLine);

        if (hr == S_OK)
        {
            hr = hrUserCancel;
            goto exit;
        }

        // If that failed, time to show an error message
        else if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_FIRST_TIME_ICW, IDS_ERROR_REASON2, NULL);
            hr = TraceResult(hr);
            goto exit;
        }
    }

    // Create WNDCLASS for Primary Outlook Express hidden window
    if (ISFLAGSET(dwFlags, MSOEAPI_START_APPWINDOW))
        pwszInitWndClass = STRW_MSOEAPI_INSTANCECLASS;
    else
        pwszInitWndClass = STRW_MSOEAPI_IPSERVERCLASS;

    // Register the init window
    if (FALSE == GetClassInfoWrapW(g_hInst, pwszInitWndClass, &wcW))
    {
        ZeroMemory(&wcW, sizeof(wcW));
        wcW.lpfnWndProc = COutlookExpress::InitWndProc;
        wcW.hInstance = g_hInst;
        wcW.lpszClassName = pwszInitWndClass;
        if (FALSE == RegisterClassWrapW(&wcW))
        {
            // In this case, we are in an error condition so don't care if PszToANSI fails.
            LPSTR pszInitWndClass = PszToANSI(CP_ACP, pwszInitWndClass);
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, pszInitWndClass);
            MemFree(pszInitWndClass);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // Create the OutlookExpressHiddenWindow
    if (NULL == g_hwndInit)
    {
        g_hwndInit = CreateWindowExWrapW(WS_EX_TOPMOST, pwszInitWndClass, pwszInitWndClass,
                                    WS_POPUP, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                                    NULL, NULL, g_hInst, NULL);
        if (NULL == g_hwndInit)
        {
            // In this case, we are in an error condition so don't care if PszToANSI fails.
            LPSTR pszInitWndClass = PszToANSI(CP_ACP, pwszInitWndClass);
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, pszInitWndClass);
            MemFree(pszInitWndClass);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_GOPTIONS, IDS_ERROR_REASON1, NULL);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Prompt the user for a store location, if we don't have one already
    hr = InitializeLocalStoreDirectory(NULL, FALSE);
    if (hrUserCancel == hr || FAILED(hr))
    {   
        // If not user cancel, then must be another error
        if (hrUserCancel != hr)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INITSTORE_DIRECTORY, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
        }

        // Done
        goto exit;
    }

    // This needs to stay in since the Intl guys want a way to work around people who aren't going to upgrade to the latest ATOK11.
    if (ISFLAGSET(dwFlags, MSOEAPI_START_SHOWSPLASH) && 0 == DwGetOption(OPT_NO_SPLASH)
        && ((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS))
    {
        // Create me a splash screen
        hr = CoCreateInstance(CLSID_IESplashScreen, NULL, CLSCTX_INPROC_SERVER, IID_ISplashScreen, (LPVOID *)&m_pSplash);

        // If that worked, heck, lets show it
        if (SUCCEEDED(hr))
        {
            HDC hdc = GetDC(NULL);
            m_pSplash->Show(g_hLocRes, ((GetDeviceCaps(hdc, BITSPIXEL) > 8) ? idbSplashHiRes : idbSplash256), idbSplashLoRes, &m_hwndSplash);
            ReleaseDC(NULL, hdc);
        }

        // Trace
        else
            TraceResultSz(hr, "CoCreateInstance(CLSID_IESplashScreen, ...) failed, but who cares.");

        // Everything is good
        hr = S_OK;
    }

    cb = sizeof(dw);
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szHideMessenger, &dwType, (LPBYTE)&dw, &cb))
        dw = 0xffffffff;
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, c_szRegFlat, c_szHideMessenger, &dwType, (LPBYTE)&dwVal, &cb))
        dwVal = 0xffffffff;
    if (dw != 0xffffffff && dwVal != 0xffffffff)
        g_dwHideMessenger = max(dw, dwVal);
    else if (dw != 0xffffffff)
        g_dwHideMessenger = dw;
    else if (dwVal != 0xffffffff)
        g_dwHideMessenger = dwVal;
    else
        g_dwHideMessenger = BL_DEFAULT;

    // IntelliMouse support
    g_msgMSWheel = RegisterWindowMessage(TEXT(MSH_MOUSEWHEEL));
    AssertSz(g_msgMSWheel, "RegisterWindowMessage for the IntelliMouse failed, we can still continue.");
            
    // Create WNDCLASS for ThumbNail
    if (FALSE == GetClassInfo(g_hLocRes, WC_THUMBNAIL, &wc))
    {
        ZeroMemory(&wc, sizeof(wc));
        wc.lpfnWndProc = ThumbNailWndProc;
        wc.hInstance = g_hLocRes;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = WC_THUMBNAIL;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        if (FALSE == RegisterClass(&wc))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, WC_THUMBNAIL);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // Get the desktop Window
    hwndDesk = GetDesktopWindow();
    AssertSz(hwndDesk, "GetDesktopWindow returned NULL. We should be ok, I hope.");
    if (hwndDesk)
    {
        // Get the size of the desktop window
        GetWindowRect(hwndDesk, &rc);

        // sungr: following is a hack to avoid the fullscreen app detection hack that user does to modify the top-most state of the tray.
        rc.left += 20;
        rc.top  += 20;
        rc.bottom -= 20;
        rc.right  -= 20;
    }

    // Test to see if we should move the store 
    cb = ARRAYSIZE(szFolder);
    if (ERROR_SUCCESS == AthUserGetValue(NULL, c_szNewStoreDir, &dwType, (LPBYTE)szFolder, &cb))
    {
        DWORD dwMoveStore = 0;
        DWORD cb = sizeof(dwMoveStore);

        AthUserGetValue(NULL, c_szMoveStore, NULL, (LPBYTE)&dwMoveStore, &cb);
        
        if (SUCCEEDED(RelocateStoreDirectory(g_hwndInit, szFolder, (dwMoveStore != 0))))
        {
            AthUserDeleteValue(NULL, c_szNewStoreDir);
            AthUserDeleteValue(NULL, c_szMoveStore);
        }
    }

    // CoIncrementInit Common Controls Library
    InitCommonControlsEx(&icex);

    // Create account manger
    if (NULL == g_pAcctMan)
    {
        hr = AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &g_pAcctMan);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_ACCTMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        pImnAdviseAccount = new CImnAdviseAccount();
        if (NULL == pImnAdviseAccount)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ALLOC_ACCTADVISE, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
        
        hr = pImnAdviseAccount->Initialize();
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_ACCTADVISE, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        // Register Advise sink
        Assert(g_dwAcctAdvise == 0xffffffff);
        hr = g_pAcctMan->Advise(pImnAdviseAccount, &g_dwAcctAdvise);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ADVISE_ACCTMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the rules manager
    if (NULL == g_pRulesMan)
    {
        hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, idsErrorCreateRulesMan, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        // CoIncrementInit the account manager
        hr = g_pRulesMan->Initialize(0);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, idsErrorInitRulesMan, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the global connection manager
    if (NULL == g_pConMan)
    {
        g_pConMan = new CConnectionManager();
        if (NULL == g_pConMan)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ALLOC_CONMAN, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // CoIncrementInit the Connection Manager
        hr = g_pConMan->HrInit(g_pAcctMan);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_CONMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Initialize the HTTP user agent
    InitOEUserAgent(TRUE);

    // Create the Spooler Object
    if (NULL == g_pSpooler)
    {
        hr = CreateThreadedSpooler(NULL, &g_pSpooler, TRUE);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_SPOOLER, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(hr);
            goto exit;
        }
    }

    // Create the Font Cache Object
    if (NULL == g_lpIFontCache)
    {
        hr = CoCreateInstance(CLSID_IFontCache, NULL, CLSCTX_INPROC_SERVER, IID_IFontCache, (LPVOID *)&g_lpIFontCache); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_FONTCACHE, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
        hr = g_lpIFontCache->Init(MU_GetCurrentUserHKey(), c_szRegInternational, 0);
        Assert(SUCCEEDED(hr));
    }

    // Create the Global Store Object
    hr = InitializeStore(dwFlags);
    if (FAILED(hr))
    {
        MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_OPEN_STORE, IDS_ERROR_REASON1, NULL);
        goto exit;
    }

    DoNewsgroupSubscribe();

    if (NULL == g_pSync)
    {
        g_pSync = new COfflineSync;
        if (NULL == g_pSync)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        hr = g_pSync->Initialize();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Start Background Compaction in XX Seconds
    if (DwGetOption(OPT_BACKGROUNDCOMPACT))
        SideAssert(SUCCEEDED(StartBackgroundStoreCleanup(30)));

    // CoIncrementInit Drag Drop Information
    if (0 == CF_FILEDESCRIPTORA)
    {
        CF_FILEDESCRIPTORA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        CF_FILEDESCRIPTORW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        CF_FILECONTENTS = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        CF_HTML = RegisterClipboardFormat(CFSTR_HTML);
        CF_INETMSG = RegisterClipboardFormat(CFSTR_INETMSG);
        CF_OEFOLDER = RegisterClipboardFormat(CFSTR_OEFOLDER);
        CF_SHELLURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        CF_OEMESSAGES = RegisterClipboardFormat(CFSTR_OEMESSAGES);
        CF_OESHORTCUT = RegisterClipboardFormat(CFSTR_OESHORTCUT);
    }

    // Get the current default codepage
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
        g_uiCodePage = (UINT)dwVal;

    // CoIncrementInit the Wab on first run
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, c_szNewWABKey, c_szFirstRunValue, &dwType, &dwVal, &cb))
        HrInitWab(TRUE);

    //This call could fail if the registry gets trashed, but do we want an error box?
    //According to takos, no...we do not.
    HGetDefaultCharset(NULL);
   
exit:
    // Is there an error ?
    if (hrUserCancel != hr && ISFLAGSET(dwFlags, MSOEAPI_START_SHOWERRORS) && (FAILED(hr) || ERROR_SUCCESS != lResult))
    {
        // If ulError is zero, lets set it to a default
        if (0 == rError.nErrorIds)
            MAKEERROR(&rError, 0, IDS_ERROR_UNKNOWN, 0, NULL);

        // Report the Error
        _ReportError(g_hLocRes, hr, lResult, &rError);
    }

    // Release the mutex and signal the caller initialization is done
    if (fReleaseMutex)
        SideAssert(FALSE != ReleaseMutex(m_hInstMutex));

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Cleanup
    SafeRelease(pImnAdviseAccount);

    // If we failed, decrement the reference count
    if (FAILED(hr))
    {
        CloseSplashScreen();
        CoDecrementInit("COutlookExpress", phInitRef);
    }
    else
        Assert(g_pAcctMan);

    // Time To Crank
    TraceInfo(_MSG("Startup Time: %d", GetTickCount() - dwTickStart));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::CloseSplashScreen
// --------------------------------------------------------------------------------
void COutlookExpress::CloseSplashScreen(void)
{
    // Kill the splash screen
    if (m_pSplash)
    {
        m_pSplash->Dismiss();
        m_pSplash->Release();
        m_pSplash = NULL;

        // HACKHACKHACK
        // This is needed because the splash screen might still be around after we
        // free up OLE.
        if (FALSE != IsWindow(m_hwndSplash))
        {
            SendMessage(m_hwndSplash, WM_CLOSE, 0, 0);
        }
    }
}

// --------------------------------------------------------------------------------
// COutlookExpress::CoDecrementInitDebug
// --------------------------------------------------------------------------------
#ifdef DEBUG
HRESULT COutlookExpress::CoDecrementInitDebug(LPCSTR pszSource, LPHINITREF phInitRef)
{
    // Locals
    BOOL                fFound=FALSE;
    LPINITSOURCEINFO    pCurrent;
    LPINITSOURCEINFO    pPrevious=NULL;

    // Trace
    TraceCall("COutlookExpress::CoDecrementInitDebug");

    // Invalid Args
    Assert(pszSource);

    // Do I need to do this
    if (NULL == phInitRef || NULL != *phInitRef)
    {
        // Thread Safety
        EnterCriticalSection(&m_cs);

        // Find Source
        for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
        {
            // Is this It ?
            if (lstrcmpi(pszSource, pCurrent->pszSource) == 0)
            {
                // Increment Reference Count
                pCurrent->cRefs--;

                // Found
                fFound = TRUE;

                // No More Reference Counts ?
                if (0 == pCurrent->cRefs)
                {
                    // Previous ?
                    if (pPrevious)
                        pPrevious->pNext = pCurrent->pNext;
                    else
                        g_InitSourceHead = pCurrent->pNext;

                    // Free pszSource
                    g_pMalloc->Free(pCurrent->pszSource);

                    // Free pCurrent
                    g_pMalloc->Free(pCurrent);
                }

                // Done
                break;
            }

            // Set Previous
            pPrevious = pCurrent;
        }

        // Not Found, lets add one
        Assert(fFound);

        // TraceInfoTag
        TraceInfoTag(TAG_INITTRACE, "********** CoDecrementInit **********");

        // Find Source
        for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
        {
            // TraceInfoTag
            TraceInfoTag(TAG_INITTRACE, _MSG("Source: %s, Refs: %d", pCurrent->pszSource, pCurrent->cRefs));
        }

        // Thread Safety
        LeaveCriticalSection(&m_cs);
    }

    // Call Actual
    return(CoDecrementInitImpl(phInitRef));
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// COutlookExpress::CoDecrementInitImpl
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::CoDecrementInitImpl(LPHINITREF phInitRef)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::CoDecrementInitImpl");

    // If *phInitRef = NULL, then we should no do the CoDecrementInit
    if (phInitRef && NULL == *phInitRef)
    {
        hr = S_OK;
        goto exit;
    }


    // We must de-init on the same thread that we were created on...
    if (m_dwThreadId != GetCurrentThreadId() && g_hwndInit && IsWindow(g_hwndInit))
    {
        // Thunk the shutdown to the correct thread
        hr = (HRESULT) SendMessage(g_hwndInit, ITM_SHUTDOWNTHREAD, 0, (LPARAM)phInitRef);        
    }
    else
    {
        // Forward everything off to the main function
        hr = _CoDecrementInitMain(phInitRef);        
    }

    if (!SwitchingUsers() && m_fIncremented && (m_cDllInit == 0))
    {
		SetQueryNetSessionCount(SESSION_DECREMENT);
        m_fIncremented = FALSE;
    }

    // Uninitialize Ole
    OleUninitialize();
        
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_CoDecrementInitMain
//
// NOTE:  We assume that we already have the critical section before this call
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_CoDecrementInitMain(LPHINITREF phInitRef)
{
    // Stack
    TraceCall("COutlookExpress::_CoDecrementInitMain");

    // If *phInitRef = NULL, then we should no do the CoDecrementInit
    if (phInitRef && NULL == *phInitRef)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This should never happen. It could only happen if g_hwndInit was NULL.
    AssertSz(m_dwThreadId == GetCurrentThreadId(), "We are not doing the last CoDecrementInit on the thread in which g_pInstance was created on.");

    // Release
    Assert(m_cDllInit);
    m_cDllInit--;

    // Not hit zero yet ?
    if (m_cDllInit > 0)
    {
        LeaveCriticalSection(&m_cs);
        goto exit;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);

    // Validate
    Assert(NULL == g_InitSourceHead);

    // Take ownership of the mutex to block people from creating new insts while shutting down
    WaitForSingleObject(m_hInstMutex, INFINITE);

    // Cleanup the Trident data for this thread

    //g_hLibMAPI
    if (g_hlibMAPI)
    {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = 0;
    }

    // Make sure we remove our new mail notification from the tray
    UpdateTrayIcon(TRAYICONACTION_REMOVE);

    // Close Background Compaction
    SideAssert(SUCCEEDED(CloseBackgroundStoreCleanup()));

    // Kill the Spooler
    if (g_pSpooler)
    {
        CloseThreadedSpooler(g_pSpooler);
        g_pSpooler = NULL;
    }

    // de-init the http user agent
    InitOEUserAgent(FALSE);

    // A bunch of de-init things
    FInitRichEdit(FALSE);
    Note_Init(FALSE);
    Envelope_FreeGlobals();

    // Make sure next identity can migrate
    g_fMigrationDone = FALSE;

    // De-initialize Multilanguage menu
    DeinitMultiLanguage();

    // Deinit Stationery
    if (g_pStationery)
    {
        // Save the current list
        g_pStationery->SaveStationeryList();

        // Release the object
        SideAssert(0 == g_pStationery->Release());

        // Lets not free it again
        g_pStationery = NULL;
    }

    // Release the font cache
    SafeRelease(g_lpIFontCache);

    // Simple MAPI Cleanup
#ifndef WIN16
    SimpleMAPICleanup();
#endif

    // Kill the Wab
    HrInitWab(FALSE);

/*
We shouldn't have to do this anymore. This should be handled by IE when we decrement the session count
#ifndef WIN16   // No RAS support in Win16
    if (g_pConMan && g_pConMan->IsRasLoaded() && g_pConMan->IsConnected())
        g_pConMan->Disconnect(g_hwndInit, TRUE, FALSE, TRUE);
#endif
*/

    // Image Lists
    FreeImageLists();

    // Kill the account manager
    if (g_pAcctMan)
    {
        CleanupTempNewsAccounts();

        if (g_dwAcctAdvise != 0xffffffff)
            {
            g_pAcctMan->Unadvise(g_dwAcctAdvise);
            g_dwAcctAdvise = 0xffffffff;
            }

        g_pAcctMan->Release();
        g_pAcctMan = NULL;
    }
    Assert(g_dwAcctAdvise == 0xffffffff);

    SafeRelease(g_pSync);

#ifndef WIN16   // No RAS support in Win16
    SafeRelease(g_pConMan);
#endif

    // Kill the rules manager
    SafeRelease(g_pRulesMan);

    // Take down the password cache
    DestroyPasswordList();

    // free the account data cache
    FreeAccountPropCache();

    // MIMEOLE Allocator
    SafeRelease(g_pMoleAlloc);

    // Kill g_hwndInit
    if (g_hwndInit)
    {
        SendMessage(g_hwndInit, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
        g_hwndInit = NULL;
    }

    // Kill the store
    SafeRelease(g_pStore);
    SafeRelease(g_pLocalStore);
    SafeRelease(g_pDBSession);

    // Global options
    DeInitGlobalOptions();

    // Run register window classes
    UnregisterClass(c_szFolderWndClass, g_hInst);
    UnregisterClassWrapW(STRW_MSOEAPI_INSTANCECLASS, g_hInst);
    UnregisterClassWrapW(STRW_MSOEAPI_IPSERVERCLASS, g_hInst);
    UnregisterClass(c_szFolderViewClass, g_hInst);
    UnregisterClass(c_szBlockingPaintsClass, g_hInst);
    UnregisterClass(WC_THUMBNAIL, g_hInst);

    // Break Message Loop in RunShell if we are pumping messages and not switching identities
    if (m_fPumpingMsgs && !m_fSwitchingUsers)
        PostQuitMessage(0);
    else
        PostMessage(NULL, ITM_IDENTITYMSG, 0, 0);

    MU_Shutdown();

    // Relase the startup/shutdown mutex
    ReleaseMutex(m_hInstMutex);

    // Make sure mark this initialization thread as dead
    m_dwThreadId = 0;

exit:
    // We must have decremented succesfully
    if (phInitRef)
        *phInitRef = NULL;

    // Trace
    //TraceInfo(_MSG("_CoDecrementInitMain Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::ActivateWindow
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::ActivateWindow(HWND hwnd)
{
    // If hwnd is minimized, retstore it
    if (IsIconic(hwnd))
        ShowWindow(hwnd, SW_RESTORE);

    // If the window is not enabled, set it to the foreground
    if (IsWindowEnabled(hwnd))
        SetForegroundWindow(hwnd);

    // Otherwise, I have no clue what this does
    else
    {
        SetForegroundWindow(GetLastActivePopup(hwnd));
        MessageBeep(MB_OK);
        return S_FALSE;
    }

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// COutlookExpress::SetSwitchingUsers
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::SetSwitchingUsers(BOOL bSwitching)
{
    // Set the mode to whatever was passed in
    m_fSwitchingUsers = bSwitching;

    // if we are switching, we need to enter the mutex so that 
    // another process won't get started
    if (bSwitching)
        WaitForSingleObject(m_hInstMutex, INFINITE);
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::SetSwitchingUsers
// --------------------------------------------------------------------------------
void COutlookExpress::SetSwitchToUser(TCHAR *lpszUserName)
{
    ULONG cchUserName = 0;

    if (m_szSwitchToUsername)
    {
        MemFree(m_szSwitchToUsername);
        m_szSwitchToUsername = NULL;
    }

    cchUserName = lstrlen(lpszUserName) + 1;
    MemAlloc((void **)&m_szSwitchToUsername, cchUserName);
    
    if (m_szSwitchToUsername)
    {
        StrCpyN(m_szSwitchToUsername, lpszUserName, cchUserName);
    }
}
// --------------------------------------------------------------------------------
// COutlookExpress::BrowseToObject
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::BrowseToObject(UINT nCmdShow, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Trace
    TraceCall("COutlookExpress::BrowseToObject");

    // Do we already have a global browser object ?
    if (g_pBrowser)
    {
        // Get its Window
        if (SUCCEEDED(g_pBrowser->GetWindow(&hwnd)))
        {
            // Activate that Window
            IF_FAILEXIT(hr = ActivateWindow(hwnd));
        }

        // Tell the browser to browse to this object
        IF_FAILEXIT(hr = g_pBrowser->BrowseObject(idFolder, 0));
    }

    // Otherwise, we need to create a new browser object
    else
    {
        // We should always be on the correct thread here
        if (m_dwThreadId == GetCurrentThreadId())
        {
            // Create a new browser object
            IF_NULLEXIT(g_pBrowser = new CBrowser);

            // CoIncrementInit It
            IF_FAILEXIT(hr = g_pBrowser->HrInit(nCmdShow, idFolder));
        }

        // Otherwise, we need to thunk across to the init thread to make this happen.
        // This can happen when the Finder.cpp does a BrowseToObject to open a messgae's container
        else
        {
            // Thunk with a message
            Assert(g_hwndInit && IsWindow(g_hwndInit));
            IF_FAILEXIT(hr = (HRESULT)SendMessage(g_hwndInit, ITM_BROWSETOOBJECT, (WPARAM)nCmdShow, (LPARAM)idFolder));
        }
    }

exit:
    // Done
    return hr;
}

 
void COutlookExpress::_ProcessCommandLineFlags(LPWSTR *ppwszCmdLine, DWORD  dwFlags)
{
    Assert(ppwszCmdLine != NULL);
    
    DWORD   Mode = 0;

    if (*ppwszCmdLine != NULL)
    {
        // '/mailonly'
        if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchMailOnly, lstrlenW(c_wszSwitchMailOnly)))
        {
            SetStartFolderType(FOLDER_LOCAL);

            Mode |= MODE_MAILONLY;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchMailOnly);
        }

        // '/newsonly'
        else if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchNewsOnly, lstrlenW(c_wszSwitchNewsOnly)))
        {
            SetStartFolderType(FOLDER_NEWS);

            Mode |= MODE_NEWSONLY;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchNewsOnly);
        }
        // '/outnews'
        else if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchOutNews, lstrlenW(c_wszSwitchOutNews)))
        {
            SetStartFolderType(FOLDER_NEWS);

            Mode |= MODE_OUTLOOKNEWS;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchOutNews);
        }
    }

    if (!(dwFlags & MSOEAPI_START_ALREADY_RUNNING))
    {
        g_dwAthenaMode |= Mode;
    }
}

// --------------------------------------------------------------------------------
// COutlookExpress::ProcessCommandLine
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::ProcessCommandLine(INT nCmdShow, LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszArgs;
    FOLDERID        idFolder=FOLDERID_ROOT;
    HWND            hwnd=NULL;
    IF_DEBUG(DWORD  dwTickStart=GetTickCount());

    // Trace
    TraceCall("COutlookExpress::ProcessCommandLine");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // Do we have a command line
    if (NULL == pwszCmdLine)
        return S_OK;

    // Goto Next Switch
    if (*pwszCmdLine == L' ')
        pwszCmdLine++;

    // '/mailurl:'
    if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchMailURL, lstrlenW(c_wszSwitchMailURL)))
    {
        SetStartFolderType(FOLDER_LOCAL);

        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchMailURL);
        IF_FAILEXIT(hr = _HandleMailURL(pwszArgs, pfErrorDisplayed));
    }

    // '/newsurl:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNewsURL, lstrlenW(c_wszSwitchNewsURL)))
    {
        SetStartFolderType(FOLDER_NEWS);

        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchNewsURL);
        IF_FAILEXIT(hr = _HandleNewsURL(nCmdShow, pwszArgs, pfErrorDisplayed));
    }

    // '/eml:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchEml, lstrlenW(c_wszSwitchEml)))
    {
        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchEml);
        IF_FAILEXIT(hr = _HandleFile(pwszArgs, pfErrorDisplayed, FALSE));
    }

    // '/nws:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNws, lstrlenW(c_wszSwitchNws)))
    {
        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchNws);
        IF_FAILEXIT(hr = _HandleFile(pwszArgs, pfErrorDisplayed, TRUE));
    }
    
    // Otherwise, decide where to start a browser at...
    else
    {
        // Handle '/news'
        if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNews, lstrlenW(c_wszSwitchNews)))
        {
            // This sets g_dwIcwFlags
            SetStartFolderType(FOLDER_NEWS);
            
            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);

            hr = ProcessICW(hwnd, FOLDER_NEWS, TRUE);
            if (hr != S_OK)
                goto exit;

            // Get Default News SErver
            GetDefaultServerId(ACCT_NEWS, &idFolder);
        }

        // Handle '/mail /defclient'
        else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchMail, lstrlenW(c_wszSwitchMail)) ||
                 0 == StrCmpNIW(pwszCmdLine, c_wszSwitchDefClient, lstrlenW(c_wszSwitchDefClient)))
        {
            // Locals
            FOLDERINFO  Folder;
            FOLDERID    idStore;
            
            // This sets g_dwIcwFlags
            SetStartFolderType(FOLDER_LOCAL);

            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);

            hr = ProcessICW(hwnd, FOLDER_LOCAL, TRUE);
            if (hr != S_OK)
                goto exit;

            // Get store ID of default account
            if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                idStore = FOLDERID_LOCAL_STORE;

            // Get Inbox Id
            if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, FOLDER_INBOX, &Folder)))
            {
                idFolder = Folder.idFolder;
                g_pStore->FreeRecord(&Folder);
            }

        }

        // No switches
        else
        {
            // default launch 
            //   - if there is already a browser, just activate it
            //   - else if the option is set, select default inbox
            //   - else select the root (pidl = NULL)
            if (g_pBrowser && SUCCEEDED(g_pBrowser->GetWindow(&hwnd)))
            {
                ActivateWindow(hwnd);
                goto exit;
            }
            else if (DwGetOption(OPT_LAUNCH_INBOX) && (FALSE == ISFLAGSET(g_dwAthenaMode, MODE_NEWSONLY)))
            {
                // Locals
                FOLDERINFO  Folder;
                FOLDERID    idStore;

                // This sets g_dwIcwFlags
                SetStartFolderType(FOLDER_LOCAL);

                // Get store ID of default account
                if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                    idStore = FOLDERID_LOCAL_STORE;

                // Get Inbox Id
                if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, FOLDER_INBOX, &Folder)))
                {
                    idFolder = Folder.idFolder;
                    g_pStore->FreeRecord(&Folder);
                }
            }
        }

        // Browe to this new object, I assume if pidl=null, we browse to the root
        IF_FAILEXIT(hr = BrowseToObject(nCmdShow, idFolder));
    }

exit:
    /*
    // Cleanup
    SafeMemFree(pszFree);
    */
    // Trace
    TraceInfo(_MSG("Process Command Line Time: %d milli-seconds", GetTickCount() - dwTickStart));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleFile
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleFile(LPWSTR pwszCmd, BOOL *pfErrorDisplayed, BOOL fNews)
{
    // Locals
    HRESULT             hr=S_OK;
    INIT_MSGSITE_STRUCT initStruct;
    DWORD               dwCreateFlags = OENCF_SENDIMMEDIATE;
    
    if (fNews)
        dwCreateFlags |= OENCF_NEWSFIRST;

    // Stack
    TraceCall("COutlookExpress::_HandleFile");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // Invalid Arg
    if (NULL == pwszCmd || L'\0' == *pwszCmd)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit; 
    }

    // Does the file exist ?
    if (FALSE == PathFileExistsW(pwszCmd))
    {
        // Locals
        REPORTERRORINFO rError={0};

        // Set hr
        hr = TraceResult(MSOEAPI_E_FILE_NOT_FOUND);

        // Duplicate It
        LPSTR pszCmd = PszToANSI(CP_ACP, pwszCmd);
        if (pszCmd)
        {
            // Make the rror
            MAKEERROR(&rError, 0, IDS_ERROR_FILE_NOEXIST, 0, pszCmd);
            rError.nHelpIds = 0;

            // Show an error
            *pfErrorDisplayed = _ReportError(g_hLocRes, hr, 0, &rError);

            // Cleanup
            MemFree(pszCmd);
        }

        // Done
        goto exit;
    }

    initStruct.dwInitType = OEMSIT_FAT;
    initStruct.pwszFile = pwszCmd;

    hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct);

exit:          
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleNewsArticleURL
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleNewsArticleURL(LPSTR pszServerIn, LPSTR pszArticle, UINT uPort, BOOL fSecure, BOOL *pfErrorDisplayed)
{
    HRESULT             hr=S_OK;
    CHAR                szAccountId[CCHMAX_ACCOUNT_NAME];
    LPSTR               psz = NULL, 
                        pszBuf = NULL;
    IImnAccount        *pAccount=NULL;
    INIT_MSGSITE_STRUCT initStruct;
    LPMIMEMESSAGE       pMsg = NULL;

    Assert(pszServerIn);

    // Stack
    TraceCall("COutlookExpress::_HandleNewsArticleURL");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // If a server was specified, then try to create a temp account for it
    if (FALSE == FIsEmptyA(pszServerIn) && SUCCEEDED(CreateTempNewsAccount(pszServerIn, uPort, fSecure, &pAccount)))
    {
        // Get the Account name
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
    }   
    // Otherwise, use the default news server
    else
    {
        // If a server wasn't specified, then use the default account
        IF_FAILEXIT(hr = GetDefaultNewsServer(szAccountId, ARRAYSIZE(szAccountId)));
    }

    // Bug #10555 - The URL shouldn't have <> around the article ID, but some lameoids probably will do it anyway, so deal with it.
    if (FALSE == IsDBCSLeadByte(*pszArticle) && '<' != *pszArticle)
    {
        ULONG cchArticle;

        cchArticle = lstrlen(pszArticle) + 4;
        if (!MemAlloc((void **)&pszBuf, cchArticle))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        wnsprintf(pszBuf, cchArticle, TEXT("<%s>"), pszArticle);
        psz = pszBuf;
    }
    else
    {
        psz = pszArticle;
    }

    
    hr = HrDownloadArticleDialog(szAccountId, psz, &pMsg);
    if (S_OK == (hr))
    {
        Assert(pMsg != NULL);

        initStruct.dwInitType = OEMSIT_MSG;
        initStruct.pMsg = pMsg;
        initStruct.folderID = FOLDERID_INVALID;
    
        hr = CreateAndShowNote(OENA_READ, OENCF_NEWSFIRST, &initStruct);
    }
    else
    {
        // No errors if the user cancel'ed on purpose.
        if (HR_E_USER_CANCEL_CONNECT == hr || HR_E_OFFLINE == hr)
            hr = S_OK;
        else
        {
            AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsNewsTaskArticleError), 0, MB_OK|MB_SETFOREGROUND); 
            hr = S_OK;
        }

    }


exit:
    // Cleanup
    MemFree(pszBuf);
    ReleaseObj(pAccount);
    ReleaseObj(pMsg);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleNewsURL
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleNewsURL(INT nCmdShow, LPWSTR pwszCmd, BOOL *pfErrorDisplayed)
{
    // Locals
    HWND            hwnd;
    HRESULT         hr=S_OK;
    LPSTR           pszCmd=NULL,
                    pszServer=NULL,
                    pszGroup=NULL,
                    pszArticle=NULL;
    UINT            uPort=(UINT)-1;
    BOOL            fSecure;
    FOLDERID        idFolder;
    TCHAR           szRes[CCHMAX_STRINGRES],
                    szError[MAX_PATH + CCHMAX_STRINGRES];

    // Stack
    TraceCall("COutlookExpress::_HandleNewsURL");
    
    // Invalid Arg
    Assert(pfErrorDisplayed);
    Assert(pwszCmd != NULL);
    Assert(*pwszCmd != 0);
    
    // Since this is a URL, then don't need to worry about UNICODE
    IF_NULLEXIT(pszCmd = PszToANSI(CP_ACP, pwszCmd));
    
    // Un-escape the Url
    UrlUnescapeInPlace(pszCmd, 0);
    
    // Figure out if the URL is valid and what type of URL it is.
    hr = URL_ParseNewsUrls(pszCmd, &pszServer, &uPort, &pszGroup, &pszArticle, &fSecure);
    
    if ((hr == INET_E_UNKNOWN_PROTOCOL || hr == INET_E_INVALID_URL) &&
        LoadString(g_hLocRes, idsErrOpenUrlFmt, szRes, ARRAYSIZE(szRes)))
    {
        // if bad url format, warn user and return S_OK as we handled it
        // Outlook Express could not open the URL '%.100s' because it is not a recognized format.
        // we clip the URL to 100 chars, so it easily fits in the MAX_PATH buffer
        wnsprintf(szError, ARRAYSIZE(szError), szRes, pszCmd, lstrlen(pszCmd)>100?g_szEllipsis:c_szEmpty);
        AthMessageBox(g_hwndInit, MAKEINTRESOURCE(idsAthena), szError, 0, MB_OK|MB_SETFOREGROUND); 
        return S_OK;
    }
    IF_FAILEXIT(hr);

        // Compute the correct port number
    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;
    
    // If we have an article, HandleNewsArticleURL
    if (pszArticle)
    {
        // Launch a read note onto the article id
        IF_FAILEXIT(hr = _HandleNewsArticleURL(pszServer, pszArticle, uPort, fSecure, pfErrorDisplayed));
    }

    // Otheriwse, create a PIDL and browse to that pidl (its a newsgroup)
    else
    {
        // Locals
        FOLDERID idFolder;

        if (pszServer == NULL)
        {
            // If we have a browser, the its hwnd so that ICW has a parent
            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);
            else
                hwnd = NULL;

            // Run the ICW if necessary
            hr = ProcessICW(hwnd, FOLDER_NEWS, TRUE);
            if (hr != S_OK)
                goto exit;
        }

        // Create a PIDL for this newsgroup URL
        if (SUCCEEDED(hr = GetFolderIdFromNewsUrl(pszServer, uPort, pszGroup, fSecure, &idFolder)))
        {
            // Browse to that object
            IF_FAILEXIT(hr = BrowseToObject(nCmdShow, idFolder));
        }
    }
    
exit:      
    // Cleanup
    SafeMemFree(pszCmd);
    SafeMemFree(pszServer);
    SafeMemFree(pszGroup);
    SafeMemFree(pszArticle);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleMailURL
//
// PURPOSE:    Provides an entry point into Thor that allows us to be
//             invoked from a URL.  The pszCmdLine paramter must be a
//             valid Mail URL or nothing happens.
//
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleMailURL(LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed)
{
    // Locals
    HRESULT                 hr=S_OK;
    LPMIMEMESSAGE           pMsg=NULL;
    INIT_MSGSITE_STRUCT     initStruct;
    TCHAR                   szRes[CCHMAX_STRINGRES],
                            szError[MAX_PATH + CCHMAX_STRINGRES];
    LPSTR                   pszCmdLine = NULL;

    // Stack
    TraceCall("COutlookExpress::_HandleMailURL");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // No command line
    if (NULL == pwszCmdLine || L'\0' == *pwszCmdLine)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }
   
    // Since this is a URL, then don't need to worry about UNICODE
    IF_NULLEXIT(pszCmdLine = PszToANSI(CP_ACP, pwszCmdLine));

    // Create a Message Object
    IF_FAILEXIT(hr = HrCreateMessage(&pMsg));

    // NOTE: no URLUnescape in this function - it must be done in URL_ParseMailTo to handle
    // URLs of the format:
    //
    //      mailto:foo@bar.com?subject=AT%26T%3dBell&cc=me@too.com
    //
    // so that the "AT%26T" is Unescaped into "AT&T=Bell" *AFTER* the "subject=AT%26T%3dBell&" blob is parsed.
    hr = URL_ParseMailTo(pszCmdLine, pMsg);

    if ((hr == INET_E_UNKNOWN_PROTOCOL || hr == INET_E_INVALID_URL) &&
        LoadString(g_hLocRes, idsErrOpenUrlFmt, szRes, ARRAYSIZE(szRes)))
    {
        // if bad url format, warn user and return S_OK as we handled it
        // Outlook Express could not open the URL '%.100s' because it is not a recognized format.
        // we clip the URL to 100 chars, so it easily fits in the MAX_PATH buffer
        wnsprintf(szError, ARRAYSIZE(szError), szRes, pszCmdLine, lstrlen(pszCmdLine)>100?g_szEllipsis:c_szEmpty);
        AthMessageBox(g_hwndInit, MAKEINTRESOURCE(idsAthena), szError, 0, MB_OK|MB_SETFOREGROUND); 
        return S_OK;
    }

    IF_FAILEXIT(hr);

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = FOLDERID_INVALID;

    hr = CreateAndShowNote(OENA_COMPOSE, OENCF_SENDIMMEDIATE, &initStruct);

exit:
    // Cleanup
    SafeRelease(pMsg);
    MemFree(pszCmdLine);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::InitWndProc
// --------------------------------------------------------------------------------
LRESULT EXPORT_16 CALLBACK COutlookExpress::InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    // Locals
    BOOL        fRet;
    HRESULT     hr;

    // Delegate to the Account Manager
    if (g_pAcctMan && g_pAcctMan->ProcessNotification(msg, wp, lp) == S_OK)
        return TRUE;

    // Handle the Message
    switch(msg)
    {
        case WM_ENDSESSION:
            // if we get forced down by window, we don't exit clean, so deinit global opt it not called. We obviously don't have a mailbomb so clear the regkey.
            SetDwOption(OPT_ATHENA_RUNNING, FALSE, NULL, 0);
            break;

        case WM_SETTINGCHANGE:
            Assert (g_lpIFontCache);
            if (g_lpIFontCache)
                {
                if (!wp || SPI_SETNONCLIENTMETRICS == wp || SPI_SETICONTITLELOGFONT == wp)
                    g_lpIFontCache->OnOptionChange();
                }
            break;

        case ITM_WAB_CO_DECREMENT:
            Wab_CoDecrement();
            return 0;

        case ITM_BROWSETOOBJECT:
            return (LRESULT)g_pInstance->BrowseToObject((UINT)wp, (FOLDERID)lp);

        case ITM_SHUTDOWNTHREAD:
            return (LRESULT)g_pInstance->_CoDecrementInitMain((LPHINITREF)lp);

        case ITM_POSTCOPYDATA:
            if (lp)
            {
                g_pInstance->Start(MSOEAPI_START_ALREADY_RUNNING, (LPCWSTR)lp, SW_SHOWNORMAL);
                MemFree((LPWSTR)lp);
            }
            break;

        case WM_COPYDATA:
            {
                // Locals
                COPYDATASTRUCT *pCopyData = (COPYDATASTRUCT *)lp;

                // Command-line
                if (pCopyData->dwData == MSOEAPI_ACDM_CMDLINE)
                {
                    // #25238: On Win95, OLE get's pissed if we syncronously do stuff on the 
                    // WM_COPYDATA. On the most part it works, but if we show an error and pump messages
                    // then some messages get run out of sequence and we deadlock between msimn.exe and
                    // iexplore.exe. Now we post to ourselves as we don't care about the HRESULT anyway
                    // we free the duped string on the post
                    PostMessage(hwnd, ITM_POSTCOPYDATA, 0, (LPARAM)PszDupW((LPCWSTR)pCopyData->lpData));
                    return 0;
                }

                // Notification Thunk
                else if (pCopyData->dwData == MSOEAPI_ACDM_NOTIFY)
                {
                    // Locals
                    NOTIFYDATA      rNotify;
                    LRESULT         lResult=0;

                    // Crack the notification
                    if (SUCCEEDED(CrackNotificationPackage(pCopyData, &rNotify)))
                    {
                        // Otherwise, its within this process...
                        if (ISFLAGSET(rNotify.dwFlags, SNF_SENDMSG))
                            lResult = SendMessage(rNotify.hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam);
                        else
                            PostMessage(rNotify.hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam);

                        // Done
                        return lResult;
                    }

                    // Problems
                    else
                        Assert(FALSE);
                }
            }
            break;

        case MVM_NOTIFYICONEVENT:
            g_pInstance->_HandleTrayIconEvent(wp, lp);
            return (0);
    }

    // Delegate to default window procedure
    return DefWindowProc(hwnd, msg, wp, lp);
}


HRESULT COutlookExpress::UpdateTrayIcon(TRAYICONACTION type)
{
    NOTIFYICONDATA nid;
    HWND           hwnd = NULL;
    ULONG          i;

    TraceCall("COutlookExpress::UpdateTrayIcon");

    EnterCriticalSection(&m_cs);

    // Make sure we have the init window around first
    if (!g_hwndInit)
        goto exit;

    // Set up the struct
    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.uID = 0;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = MVM_NOTIFYICONEVENT;
    if(m_hTrayIcon)
    {
        //Bug #86366 - (erici) Fixes leak.  Don't create a new ICON each time COutlookExpress::UpdateTrayIcon is called.
        nid.hIcon = m_hTrayIcon;
    }
    else
    {
        nid.hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiNewMailNotify), IMAGE_ICON, 16, 16, 0);
    }
    nid.hWnd = g_hwndInit;
    LoadString(g_hLocRes, idsNewMailNotify, nid.szTip, sizeof(nid.szTip));

    if (TRAYICONACTION_REMOVE == type)
    {
        Shell_NotifyIcon(NIM_DELETE, &nid);
    }

    // Add
    if (TRAYICONACTION_ADD == type)
    {
        Shell_NotifyIcon(NIM_ADD, &nid);
    }
    g_pBrowser->WriteUnreadCount();

exit:
    LeaveCriticalSection(&m_cs);

    return (S_OK);
}


void COutlookExpress::_HandleTrayIconEvent(WPARAM wParam, LPARAM lParam)
    {
    HWND hwnd;

    if (lParam == WM_LBUTTONDBLCLK)
    {
        if (g_pBrowser)
        {
            g_pBrowser->GetWindow(&hwnd);
            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
            SetForegroundWindow(hwnd);        
            
            PostMessage(hwnd, WM_COMMAND, ID_GO_INBOX, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\migrate.cpp ===
// --------------------------------------------------------------------------------
// MIGRATE.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "strconst.h"
#include "resource.h"
#include "storfldr.h"
#include <imnact.h>
#include <acctutil.h>
#include "shlwapi.h"
#include <mimeole.h>
#include "xpcomm.h"
#include "oerules.h"
#include "goptions.h"
#include "ruleutil.h"
#include "criteria.h"
#include "actions.h"
#include "rule.h"
#include "storutil.h"
#include "shared.h"
#include "multiusr.h"
#include "msident.h"
#include "imapute.h"
#include <store.h>

#include "demand.h"

static const char c_szSettingsUpgraded[] = {"Settings Upgraded"};

BOOL g_fMigrationDone = FALSE;

void MigrateSettings(HKEY hkey);
HRESULT MigrateStoreToV2(HKEY hkeyV2, LPTSTR pszSrc, DWORD cchSrc, LPTSTR pszDest, DWORD cchDest);
HRESULT MigrateAccounts(void);
HRESULT MigrateMailServers(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3, HKEY hkeySmtp);
HRESULT MigrateNewsServers(IImnAccountManager *pAcctMan, HKEY hkeyNews);
HRESULT MigrateBase64EncodedPassword(LPCSTR pszBase64, DWORD cch, DWORD dwPropId, IImnAccount *pAccount);
HRESULT MigrateServerDataFiles(LPSTR pszServer, LPCSTR pszOldDir, LPCSTR pszSubDir);
void MigrateAccessibilityKeys(void);
HRESULT MigrateToPropertyStore(void);
void MigrateMailRulesSettings(void);
void ConvertToDBX(void);
void MigrateAccConnSettings();
void ForwardMigrateConnSettings();
void MigrateBeta2Rules();
void Stage5RulesMigration(VOID);
void Stage6RulesMigration(VOID);
#define VERLEN 20

// Data structures
typedef enum
    {
    VER_NONE = 0,
    VER_1_0,
    VER_1_1,
    VER_4_0,
    VER_5_0_B1,
    VER_5_0,
    VER_MAX,
    } SETUPVER;

/*******************************************************************

    NAME:       ConvertVerToEnum

********************************************************************/
SETUPVER ConvertVerToEnum(WORD *pwVer)
    {
    SETUPVER sv;
    Assert(pwVer);

    switch (pwVer[0])
        {
        case 0:
            sv = VER_NONE;
            break;

        case 1:
            if (0 == pwVer[1])
                sv = VER_1_0;
            else
                sv = VER_1_1;
            break;

        case 4:
            sv = VER_4_0;
            break;

        case 5:
            sv = VER_5_0;
            break;

        default:
            sv = VER_MAX;
        }

    return sv;
    }


/*******************************************************************

    NAME:       ConvertStrToVer

********************************************************************/
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer)
    {
    int i;

    Assert(pszStr);
    Assert(pwVer);

    ZeroMemory(pwVer, 4 * sizeof(WORD));

    for (i=0; i<4; i++)
        {
        while (*pszStr && (*pszStr != ',') && (*pszStr != '.'))
            {
            pwVer[i] *= 10;
            pwVer[i] += *pszStr - '0';
            pszStr++;
            }
        if (*pszStr)
            pszStr++;
        }

    return;
    }


/*******************************************************************

    NAME:       GetVerInfo

********************************************************************/
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev)
    {
    HKEY hkeyT;
    DWORD cb;
    CHAR szVer[VERLEN];
    WORD wVer[4];

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWABVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
        {
        if (psvCurr)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegCurrVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, wVer);
            *psvCurr = ConvertVerToEnum(wVer);
            }

        if (psvPrev)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegPrevVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, wVer);
            *psvPrev = ConvertVerToEnum(wVer);
            }

        RegCloseKey(hkeyT);
        }
    }

// Entry Point
HRESULT MigrateAndUpgrade()
{
    DWORD	dwMigrate, cb, type, fMigratedStore, fMigratedStoreOE5, fConvertedToDBX, dwRegVer=0, dwMasterVer=0;
    BOOL    fNewID=FALSE;
    HKEY	hkey, hkeyForceful;
    TCHAR	szSrc[MAX_PATH], szDest[MAX_PATH];

// Keep this up to date!
#define LAST_MIGVALUE 7

    if (g_fMigrationDone)
        return(S_OK);

    ForwardMigrateConnSettings();

    if (ERROR_SUCCESS == RegCreateKeyEx(MU_GetCurrentUserHKey(), c_szRegRoot, NULL, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &cb))
    {
        // Before anything else, see if this identity has had its registry initialized
        cb = sizeof(dwRegVer);
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szOEVerStamp, 0, &type, (LPBYTE)&dwRegVer, &cb))
        {
            HKEY hkeyDef;

            // No Defaults at all
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegDefaultSettings, 0, KEY_READ, &hkeyDef))
            {
                CopyRegistry(hkeyDef,  hkey);
                RegCloseKey(hkeyDef);
            }

            fNewID = TRUE;
        }
        else if (type != REG_DWORD || cb != sizeof(DWORD))
        {
            dwRegVer = 0;
        }

        // Compare to forceful setting reg value to see if we need those
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegForcefulSettings, 0, KEY_READ, &hkeyForceful))
        {
            cb = sizeof(dwMasterVer);
            RegQueryValueEx(hkeyForceful, c_szOEVerStamp, 0, NULL, (LPBYTE)&dwMasterVer, &cb);

            // Do we need to copy these in?
            if (dwRegVer < dwMasterVer)
            {
                // The act of copying will set c_szOEVerStamp
                CopyRegistry(hkeyForceful, hkey);
            }

            RegCloseKey(hkeyForceful);
        }


        // Start with no paths
        szSrc[0] = szDest[0] = 0;

        // move the store from v1 location to new location.
        // this is done because v1 barfs when trying to look at v2 store.
        // when we uninstall, we try to move the store back to its v1 location
        // and we tweak the versions of the store files so v1 repairs the files
        // and can run without crashing
        // HKCU,"software/microsoft/outlook express/5.0","MSIMN"
        if (fNewID)
        {
            fMigratedStore = TRUE;
            RegSetValueEx(hkey, c_szMSIMN, NULL, REG_DWORD, (LPBYTE)&fMigratedStore, sizeof(fMigratedStore));
        }
        else
        {
            cb = sizeof(fMigratedStore);
            if (RegQueryValueEx(hkey, c_szMSIMN, NULL, NULL, (LPBYTE)&fMigratedStore, &cb) != ERROR_SUCCESS)
                fMigratedStore = FALSE;

            if (!fMigratedStore)
            {
                // See if there is a v1 store, if so, figure out source and dest
                MigrateStoreToV2(hkey, szSrc, ARRAYSIZE(szSrc), szDest, ARRAYSIZE(szDest));
                fMigratedStore = TRUE;
                RegSetValueEx(hkey, c_szMSIMN, NULL, REG_DWORD, (LPBYTE)&fMigratedStore, sizeof(fMigratedStore));
            }
        }

        // we need to do this everytime we startup.
        // thank the trident guys for this lovely perf hit.
        MigrateAccessibilityKeys();

        if (fNewID)
            dwMigrate = LAST_MIGVALUE;
        else
        {
            cb = sizeof(dwMigrate);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSettingsUpgraded, 0, &type, (LPBYTE)&dwMigrate, &cb))
                dwMigrate = 0;
        }

        // ATTENTION! PLEASES READ THE FOLLOWING BEFORE CHANGING THE UPGRADE CODE,
        // SO YOU DON'T MESS ANYTHING UP. (i don't often comment anything so this must
        // be important.)
        //
        // everything in the dwMigrate == 0 case is pre-oe5 and before we had one place to do
        // upgrade and migration of previous oe settings. some of the pre-oe5 migration code used
        // their own reg values to indicate that migration had been performed, so we'll use those
        // in this case.
        // but from now on all migration should use the same reg value (c_szSettingsUpgraded) to
        // track what needs to be upgraded/migrated. as you change something and add migration code
        // bump up the value

        if (dwMigrate == 0)
        {
            SETUPVER svPrev;

            // HKCU,"software/microsoft/outlook express/5.0","Settings Migrated"
            MigrateSettings(hkey);

            GetVerInfo(NULL, &svPrev);
            if (VER_1_0 == svPrev || VER_1_1 == svPrev)
                MigrateAccounts();

            dwMigrate = 1;
        }

        if (dwMigrate == 1)
        {
//         MigrateCharSetMapSettings(); // We don't need to migrate this settings,
                                        // but need to keep dwMigrate for Beta2. (YST)

            dwMigrate = 2;
        }

        if (dwMigrate == 2)
        {
            //Migrate account connection settings
            MigrateAccConnSettings();

            dwMigrate = 3;
        }

        // More settings migratation are done after the store migration

        // For Outlook Express V5, we migrate the OE4 version store to the ObjectDB Store.
        // For V1 Users, the code above will have just executed and now they get to migrate again.
        if (fNewID)
            fMigratedStoreOE5 = TRUE;
        else
        {
            cb = sizeof(fMigratedStoreOE5);
            if (RegQueryValueEx(hkey, c_szStoreMigratedToOE5, NULL, NULL, (LPBYTE)&fMigratedStoreOE5, &cb) != ERROR_SUCCESS)
                fMigratedStoreOE5 = FALSE;
        }

        if (!fMigratedStoreOE5)
        {
            // If we didn't just come from v1, we don't know where we are coming from or going to...
            // Default to Store Root location
            if (!szSrc[0])
            {
                Assert(!szDest[0]);

                cb = sizeof(szSrc);
                RegQueryValueEx(hkey, c_szRegStoreRootDir, 0, &type, (LPBYTE)szSrc, &cb);
                if (REG_EXPAND_SZ == type)
                {
                    ExpandEnvironmentStrings(szSrc, szDest, ARRAYSIZE(szDest));
                    StrCpyN(szSrc, szDest, ARRAYSIZE(szSrc));
                }
                else
                    StrCpyN(szDest, szSrc, ARRAYSIZE(szDest));
            }
            else
                Assert(szDest[0]);

            // Do we have anything to migrate?
            if (szSrc[0] && szDest[0])
            {
                if (SUCCEEDED(MigrateLocalStore(NULL, szSrc, szDest)))
                {
                    // Since the store migration remapped the folder id
                    // we must fix up the folder id in the rules
                    ImapUtil_B2SetDirtyFlag();

                    fMigratedStoreOE5 = TRUE;
                    RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fMigratedStoreOE5, sizeof(fMigratedStoreOE5));
                }
            }
            else
                // Nothing to migrate = success!
                fMigratedStoreOE5 = TRUE;

        }

        // Save state
        RegSetValueEx(hkey, c_szStoreMigratedToOE5, NULL, REG_DWORD, (LPBYTE)&fMigratedStoreOE5, sizeof(fMigratedStoreOE5));

        if (fNewID)
        {
            fConvertedToDBX = TRUE;
            RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fConvertedToDBX, sizeof(fConvertedToDBX));
        }
        else
        {
            cb = sizeof(fConvertedToDBX);
            if (RegQueryValueEx(hkey, c_szConvertedToDBX, NULL, NULL, (LPBYTE)&fConvertedToDBX, &cb) != ERROR_SUCCESS)
                fConvertedToDBX = FALSE;
            if (!fConvertedToDBX)
            {
                fConvertedToDBX = TRUE;
                ConvertToDBX();
                RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fConvertedToDBX, sizeof(fConvertedToDBX));
            }
        }

        if (dwMigrate == 3)
        {
            //Migrate rules settings

            // This must be done after the store has been migrated
            MigrateMailRulesSettings();

            dwMigrate = 4;
        }

        if (dwMigrate == 4)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            MigrateBeta2Rules();

            dwMigrate = 5;
        }

        if (dwMigrate == 5)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            Stage5RulesMigration();

            dwMigrate = 6;
        }

        if (dwMigrate == 6)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            Stage6RulesMigration();

            dwMigrate = LAST_MIGVALUE;
        }

        // Write the present upgraded settings value
        RegSetValueEx(hkey, c_szSettingsUpgraded, 0, REG_DWORD, (LPBYTE)&dwMigrate, sizeof(dwMigrate));

        // Cleanup
        RegCloseKey(hkey);
    }

    g_fMigrationDone = TRUE;

    return(S_OK);
    }


//--------------------------------------------------------------------------
// MigrateAccConnSettings
//
// This migrates the connection settings for each account. This should be called
// for the following upgrade scenarios. 1)Upgrade from pre-OE5 to OE5 Beta2 or more
// 2)Upgrade from OeBeta1 to OE5 Beta2 or more
// If the Connection Setting was previously LAN, we migrate it to use InternetConnection
// (which is any connection available). If the previous setting was RAS, we leave it
// as it is.
//
//--------------------------------------------------------------------------
void MigrateAccConnSettings()
{

	IImnEnumAccounts   *pEnum = NULL;
	IImnAccount		   *pAccount = NULL;
	DWORD				dwConnection;

	Assert(g_pAcctMan == NULL);

	if (FAILED(AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &g_pAcctMan)))
	{
		return;
	}

    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
	{
		while(SUCCEEDED(pEnum->GetNext(&pAccount)))
		{
			// Get Email Address
			if (SUCCEEDED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
			{
				if (dwConnection == CONNECTION_TYPE_LAN)
				{
                    pAccount->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_INETSETTINGS);
                    pAccount->SaveChanges();
				}
			}

			SafeRelease(pAccount);
		}

		SafeRelease(pEnum);
	}

    g_pAcctMan->Release();
    g_pAcctMan = NULL;

}

void ForwardMigrateConnSettings()
{
    /*
    We shouldn't have to do all the stuff we do above in MigrateAccConnSettings.
    We just need to look at the old regsitry settings at
    \\HKCU\Software\Microsoft\Internet Account Manager\Accounts.
    Migrating from OE4 to OE5 just uses the same location if there is only one identity.
    */

    HKEY    hKeyAccounts = NULL;
    DWORD   dwAcctSubKeys = 0;
    LONG    retval;
    DWORD   index = 0;
    LPTSTR  lpszAccountName = NULL;
    HKEY    hKeyAccountName = NULL;
    DWORD   memsize = 0;
    DWORD   dwValue;
    DWORD   cbData = sizeof(DWORD);
    DWORD   cbMaxAcctSubKeyLen;
    DWORD   DataType;
    DWORD   dwConnSettingsMigrated = 1;

    //This setting is in \\HKCU\Software\Microsoft\InternetAccountManager\Accounts

    retval = RegOpenKey(HKEY_CURRENT_USER, c_szIAMAccounts, &hKeyAccounts);
    if (ERROR_SUCCESS != retval)
        goto exit;

    retval = RegQueryValueEx(hKeyAccounts, c_szConnSettingsMigrated, NULL,  &DataType,
                        (LPBYTE)&dwConnSettingsMigrated, &cbData);

    if ((retval != ERROR_FILE_NOT_FOUND) && (retval != ERROR_SUCCESS || dwConnSettingsMigrated == 1))
        goto exit;

    retval = RegQueryInfoKey(hKeyAccounts, NULL, NULL, NULL, &dwAcctSubKeys,
                         &cbMaxAcctSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != retval)
        goto exit;

    memsize = sizeof(TCHAR) * cbMaxAcctSubKeyLen;

    if (!MemAlloc((LPVOID*)&lpszAccountName, memsize))
    {
        lpszAccountName = NULL;
        goto exit;
    }

    ZeroMemory(lpszAccountName, memsize);

    while (index < dwAcctSubKeys)
    {
        retval = RegEnumKey(hKeyAccounts, index, lpszAccountName, memsize);

        index++;

        if (retval == ERROR_SUCCESS)
        {
            retval = RegOpenKey(hKeyAccounts, lpszAccountName, &hKeyAccountName);
            if (retval == ERROR_SUCCESS)
            {
                cbData = sizeof(DWORD);
                retval = RegQueryValueEx(hKeyAccountName, c_szConnectionType, NULL, &DataType, (LPBYTE)&dwValue, &cbData);
                if (retval == ERROR_SUCCESS)
                {
                    if (dwValue == CONNECTION_TYPE_LAN)
                    {
                        dwValue = CONNECTION_TYPE_INETSETTINGS;
                        retval = RegSetValueEx(hKeyAccountName, c_szConnectionType, 0, REG_DWORD, (const BYTE *)&dwValue,
                                               sizeof(DWORD));
                    }
                }

                RegCloseKey(hKeyAccountName);
            }
        }
    }

    //Set this to one so, when we downgrade when we do backward migration based on this key value
    dwConnSettingsMigrated = 1;
    RegSetValueEx(hKeyAccounts, c_szConnSettingsMigrated, 0, REG_DWORD, (const BYTE*)&dwConnSettingsMigrated,
                  sizeof(DWORD));

exit:
    SafeMemFree(lpszAccountName);

    if (hKeyAccounts)
        RegCloseKey(hKeyAccounts);
}


//--------------------------------------------------------------------------
// ConvertToDBX
//--------------------------------------------------------------------------
void ConvertToDBX(void)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRootDir[MAX_PATH + MAX_PATH];
    CHAR            szSrcFile[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("ConvertToDBX");

    // Get Root Directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

    // Folders
    MakeFilePath(szRootDir, "folders.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "folders.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

    // Pop3uidl
    MakeFilePath(szRootDir, "pop3uidl.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "pop3uidl.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

    // Offline
    MakeFilePath(szRootDir, "Offline.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "Offline.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

exit:
    // Done
    return;
}

HRESULT MigrateStoreToV2(HKEY hkeyV2, LPTSTR pszSrc, DWORD cchSrc, LPTSTR pszDest, DWORD cchDest)
{
    HKEY    hkeyV1;
    BOOL    fMoved = FALSE;

    Assert(pszSrc);
    Assert(pszDest);
    Assert(cchSrc > 0);
    Assert(cchDest > 0);

    // Okay, this is the first time.  Let's see if a previous version exists.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      c_szRegRoot_V1,
                                      0,
                                      KEY_READ,
                                      &hkeyV1))
        {
        DWORD   dwType;

        // No need to worry about REG_EXPAND_SZ here as V1 didn't write it
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyV1,
                                             c_szRegStoreRootDir,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)pszSrc,
                                             &cchSrc) && *pszSrc)
            {
            AssertSz(REG_EXPAND_SZ != dwType, "V1's store path is REG_EXPAND_SZ!");

            // Figure out new path
            GetDefaultStoreRoot(NULL, pszDest, cchDest);

            // Remember it
            RegSetValueEx(hkeyV2, c_szRegStoreRootDir,  NULL, REG_SZ, (LPBYTE)pszDest, (lstrlen(pszDest)+1) * sizeof(TCHAR));
            }

        RegCloseKey(hkeyV1);
        }

    return(S_OK);
}

static const LPCTSTR c_rgCommonSettings[] =
    {
    c_szRegAlwaysSuggest,
    c_szRegIgnoreNumbers,
    c_szRegIgnoreUpper,
    c_szRegIgnoreProtect,
    c_szRegCheckOnSend,
    c_szRegIgnoreDBCS,
    c_szRasConnDetails
    };

static const LPCTSTR c_rgMailSettings[] =
    {
    c_szOptNewMailSound,
    c_szPurgeWaste,
    c_szOptnSaveInSentItems,
    c_szRegIncludeMsg,
    c_szRegPollForMail,
    c_szRegSendImmediate,
    c_szRegSigType,
    c_szRegSigText,
    c_szRegSigFile,
    c_szMarkPreviewAsRead,
    c_szRegIndentChar,
    c_szLogSmtp,
    c_szLogPop3,
    c_szSmtpLogFile,
    c_szPop3LogFile
    };

static const LPCTSTR c_rgNewsSettings[] =
    {
    c_szRegDownload,
    c_szRegAutoExpand,
    c_szRegNotifyNewGroups,
    c_szRegMarkAllRead,
    c_szRegSigType,
    c_szRegSigText,
    c_szRegSigFile,
    c_szRegNewsNoteAdvRead,
    c_szRegNewsNoteAdvSend,
    c_szRegNewsFillPreview,
    c_szCacheDelMsgDays,
    c_szCacheRead,
    c_szCacheCompactPer
    };

// Copies values listed in ppszSettings from hkeyOld to hkey
void MigrateNode(HKEY hkey, HKEY hkeyOld, LPCTSTR pszSub, LPCTSTR *ppszSettings, int cSettings)
    {
    int i;
    HKEY hkeyOldT, hkeyT;
    DWORD cValues, cbMax, cb, type;
    BYTE *pb;

    Assert(hkey != NULL);
    Assert(hkeyOld != NULL);
    Assert(ppszSettings != NULL);
    Assert(cSettings > 0);

    if (pszSub != NULL)
        {
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyOld, pszSub, 0, KEY_READ, &hkeyOldT))
            return;
        hkeyOld = hkeyOldT;

        if (ERROR_SUCCESS != RegCreateKeyEx(hkey, pszSub, NULL, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyT, &cb))
            {
            RegCloseKey(hkeyOldT);
            return;
            }
        hkey = hkeyT;
        }

    if (ERROR_SUCCESS == RegQueryInfoKey(hkeyOld, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                            &cValues, &cbMax, NULL, NULL) &&
        cValues > 0 &&
        cbMax > 0 &&
        MemAlloc((void **)&pb, cbMax))
        {
        for (i = 0; i < cSettings; i++)
            {
            cb = cbMax;
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, *ppszSettings, NULL, &type, pb, &cb))
                RegSetValueEx(hkey, *ppszSettings, 0, type, pb, cb);

            ppszSettings++;
            }

        MemFree(pb);
        }

    if (pszSub != NULL)
        {
        RegCloseKey(hkeyT);
        RegCloseKey(hkeyOldT);
        }
    }

BOOL MigrateSignature(HKEY hkey, HKEY hkeyOld, DWORD dwSig, BOOL fMail)
    {
    BOOL fMigrate;
    DWORD dwSigType, dwSigOpt, cb, type;
    HKEY hkeySig;
    char *psz, sz[MAX_PATH];

    fMigrate = FALSE;

    dwSigType = LOWORD(dwSig);
    dwSigOpt = HIWORD(dwSig);

    if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, (dwSigType == 2) ? c_szRegSigFile : c_szRegSigText, NULL, &type, NULL, &cb) &&
        cb > 1 &&
        MemAlloc((void **)&psz, cb))
        {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, (dwSigType == 2) ? c_szRegSigFile : c_szRegSigText, NULL, &type, (LPBYTE)psz, &cb))
            {
            wnsprintf(sz, ARRAYSIZE(sz), c_szPathFileFmt, c_szSigs, fMail ? c_szMail : c_szNews);
            if (ERROR_SUCCESS == RegCreateKeyEx(hkey, sz, NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeySig, &type))
                {
                if (type == REG_CREATED_NEW_KEY)
                    {
                    // name
                    AthLoadString(fMail ? idsMailSig : idsNewsSig, sz, ARRAYSIZE(sz));
                    RegSetValueEx(hkeySig, c_szSigName, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz) + 1);

                    // text/file
                    RegSetValueEx(hkeySig, (dwSigType == 2) ? c_szSigFile : c_szSigText, 0, REG_SZ, (LPBYTE)psz, cb);

                    // type
                    RegSetValueEx(hkeySig, c_szSigType, 0, REG_DWORD, (LPBYTE)&dwSigType, sizeof(dwSigType));

                    fMigrate = TRUE;
                    }

                RegCloseKey(hkeySig);
                }
            }

        MemFree(psz);
        }

    return(fMigrate);
    }

static const TCHAR c_szSettingsMigrated[] = TEXT("Settings Migrated");

void MigrateSettings(HKEY hkey)
    {
    HKEY hkeySrc, hkeyDst, hkeyOld;
    DWORD dw, cb, type, dwMigrate, dwSig, dwFlags;
    TCHAR   szPath[MAX_PATH];

    cb = sizeof(dwMigrate);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSettingsMigrated, NULL, &type, (LPBYTE)&dwMigrate, &cb))
        dwMigrate = 0;

    // v4.0 migration
    if (dwMigrate == 0)
        {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegRoot_V1, 0, KEY_READ, &hkeyOld))
            {
            MigrateNode(hkey, hkeyOld, NULL, (LPCTSTR *)c_rgCommonSettings, ARRAYSIZE(c_rgCommonSettings));
            MigrateNode(hkey, hkeyOld, c_szMail, (LPCTSTR *)c_rgMailSettings, ARRAYSIZE(c_rgMailSettings));
            MigrateNode(hkey, hkeyOld, c_szNews, (LPCTSTR *)c_rgNewsSettings, ARRAYSIZE(c_rgNewsSettings));

            RegCloseKey(hkeyOld);
            }

        // copy the inbox rules
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szInboxRulesPath_V1, 0, KEY_READ, &hkeySrc))
            {
            StrCpyN(szPath, c_szRegRoot, ARRAYSIZE(szPath));
            StrCatBuff(szPath, c_szInboxRulesPath, ARRAYSIZE(szPath));

            if (ERROR_SUCCESS == RegCreateKeyEx(MU_GetCurrentUserHKey(), szPath, 0, NULL,
                                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyDst, &dw))
                {
                if (dw != REG_OPENED_EXISTING_KEY)
                    CopyRegistry(hkeySrc, hkeyDst);
                RegCloseKey(hkeyDst);
                }

            RegCloseKey(hkeySrc);
            }

        dwMigrate = 1;
        }

    // v5.0 migration
    if (dwMigrate == 1)
        {
        dwFlags = 0xffffffff;

        // mail signature
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szMail, 0, KEY_READ, &hkeyOld))
            {
            cb = sizeof(dwSig);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, c_szRegSigType, NULL, &type, (LPBYTE)&dwSig, &cb) &&
                LOWORD(dwSig) != 0)
                {
                if (MigrateSignature(hkey, hkeyOld, dwSig, TRUE))
                    dwFlags = HIWORD(dwSig);
                }

            RegCloseKey(hkeyOld);
            }

        // news signature
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szNews, 0, KEY_READ, &hkeyOld))
            {
            cb = sizeof(dwSig);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, c_szRegSigType, NULL, &type, (LPBYTE)&dwSig, &cb) &&
                LOWORD(dwSig) != 0)
                {
                if (MigrateSignature(hkey, hkeyOld, dwSig, FALSE) &&
                    dwFlags == 0xffffffff)
                    dwFlags = HIWORD(dwSig);
                }

            RegCloseKey(hkeyOld);
            }

        cb = sizeof(dw);
        if (dwFlags != 0xffffffff &&
            ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSigFlags, NULL, &type, (LPBYTE)&dw, &cb))
            {
            RegSetValueEx(hkey, c_szSigFlags, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));
            }
        }
    }

const static char c_szRegImnMail[] = {"Software\\Microsoft\\Internet Mail and News\\Mail"};
const static char c_szMailPOP3Path[] = {"Software\\Microsoft\\Internet Mail and News\\Mail\\POP3"};
const static char c_szMailSMTPPath[] = {"Software\\Microsoft\\Internet Mail and News\\Mail\\SMTP"};
const static char c_szRegImnNews[] = {"Software\\Microsoft\\Internet Mail and News\\News"};

const static char c_szDefaultSmtpServer[] = {"Default SMTP Server"};
const static char c_szDefaultPop3Server[] = {"Default POP3 Server"};
const static char c_szRegConnectType[] = {"Connection Type"};
const static char c_szRegRasPhonebookEntry[] = {"RAS Phonebook Entry"};
const static char c_szRegMailConnectType[] = {"Mail Connection Type"};
const static char c_szSenderOrg[] = {"Sender Organization"};
const static char c_szSenderEMail[] = {"Sender EMail"};
const static char c_szSenderReplyTo[] = {"Reply To"};
const static char c_szSendTimeout[] = {"SendTimeout"};
const static char c_szRecvTimeout[] = {"RecvTimeout"};
const static char c_szPort[] = {"Port"};
const static char c_szRegBreakMessages[] = {"Break Message Size (KB)"};
const static char c_szRegAccountName[] = {"Account Name"};
const static char c_szRegUseSicily[] = {"Use Sicily"};
const static char c_szRegSecureConnect[] = {"Secure Connection"};
const static char c_szRegServerTimeout[] = {"Timeout"};
const static char c_szRegServerPort[] = {"NNTP Port"};
const static char c_szRegUseDesc[] = {"Use Group Descriptions"};
const static char c_szRegNewsConnectFlags[] = {"Connection Flags"};
const static char c_szRegDefServer[] = {"DefaultServer"};
const static char c_szLeaveOnServer[] = {"LeaveMailOnServer"};
const static char c_szRemoveDeleted[] = {"RemoveOnClientDelete"};
const static char c_szRemoveExpired[] = {"RemoveExpire"};
const static char c_szExpireDays[] = {"ExpireDays"};
const static char c_szRegAccount[] = {"Account"};

HRESULT MigrateAccounts()
    {
    HKEY hkeyPop3, hkeySmtp, hkeyMail, hkeyNews;
    HRESULT hr = S_OK;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegImnMail, 0, KEY_ALL_ACCESS, &hkeyMail) != ERROR_SUCCESS)
        hkeyMail = NULL;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegImnNews, 0, KEY_ALL_ACCESS, &hkeyNews) != ERROR_SUCCESS)
        hkeyNews = NULL;

    if (hkeyMail != NULL || hkeyNews != NULL)
    {
        // Create account manger because CSubList depends on g_pAcctMan
        Assert(g_pAcctMan == NULL);
        // Only ever migrate to DEFAULT user!
        hr = AcctUtil_CreateAccountManagerForIdentity((GUID *)&UID_GIBC_DEFAULT_USER, &g_pAcctMan);
        if (SUCCEEDED(hr))
        {
            // Try to open: HKCU\Software\Microsoft\IMN\Mail\POP3
            if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMailPOP3Path, 0, KEY_ALL_ACCESS, &hkeyPop3) == ERROR_SUCCESS)
            {
                // Try to open: HKCU\Software\Microsoft\IMN\Mail\SMTP
                if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMailSMTPPath, 0, KEY_ALL_ACCESS, &hkeySmtp) == ERROR_SUCCESS)
                {
                    hr = MigrateMailServers(g_pAcctMan, hkeyMail, hkeyPop3, hkeySmtp);
                    Assert(SUCCEEDED(hr));

                    RegCloseKey(hkeySmtp);
                }

                RegCloseKey(hkeyPop3);
            }

            if (hkeyNews != NULL)
            {
                hr = MigrateNewsServers(g_pAcctMan, hkeyNews);
                Assert(SUCCEEDED(hr));
            }

            g_pAcctMan->Release();
            g_pAcctMan = NULL;
        }

        if (hkeyMail != NULL)
            RegCloseKey(hkeyMail);
        if (hkeyNews != NULL)
            RegCloseKey(hkeyNews);
    }

    return(hr);
}

typedef struct tagACCTMIGRATEMAP
    {
    LPCSTR szRegValue;
    DWORD dwProp;
    } ACCTMIGRATEMAP;

typedef const ACCTMIGRATEMAP *LPCMIGRATEMAP;

HRESULT MigrateAccountSettings(IImnAccount *pAccount, HKEY hkey, LPCMIGRATEMAP pMap, int cMap)
    {
    HRESULT hr;
    int i;
    LPBYTE pb;
    PROPTYPE ptype;
    DWORD dw, cb, type;
    char sz[512];

    Assert(pAccount != NULL);
    Assert(pMap != NULL);
    Assert(cMap > 0);

    for (i = 0; i < cMap; i++, pMap++)
        {
        ptype = PROPTAG_TYPE(pMap->dwProp);
        Assert(ptype == TYPE_STRING || ptype == TYPE_DWORD || ptype == TYPE_BOOL || ptype == TYPE_PASS);

        if (ptype == TYPE_STRING || ptype == TYPE_PASS)
            {
            cb = sizeof(sz);
            pb = (LPBYTE)sz;
            }
        else
            {
            cb = sizeof(dw);
            pb = (LPBYTE)&dw;
            }

        if (RegQueryValueEx(hkey, pMap->szRegValue, 0, &type, pb, &cb) == ERROR_SUCCESS)
            {
            if (ptype == TYPE_PASS)
            {
                // IMN's Password is stored as ANSI in a REG_BINARY with no NULL terminator
                // Be sure to let MigrateBase64EncodedPassword know how long the password is
                hr = MigrateBase64EncodedPassword(sz, cb, pMap->dwProp, pAccount);
            }
            else
                hr = pAccount->SetProp(pMap->dwProp, pb, cb);
            if (FAILED(hr))
                break;
            }
        }

    return(hr);
    }

static const ACCTMIGRATEMAP c_rgMailMap[] =
    {
    {c_szRegConnectType, AP_RAS_CONNECTION_TYPE},
    {c_szRegRasPhonebookEntry, AP_RAS_CONNECTOID},
    {c_szRegMailConnectType, AP_RAS_CONNECTION_FLAGS},
    {c_szSenderName, AP_SMTP_DISPLAY_NAME},
    {c_szSenderOrg, AP_SMTP_ORG_NAME},
    {c_szSenderEMail, AP_SMTP_EMAIL_ADDRESS},
    {c_szSenderReplyTo, AP_SMTP_REPLY_EMAIL_ADDRESS},
    };

static const ACCTMIGRATEMAP c_rgPop3Map[] =
    {
    {c_szSendTimeout, AP_SMTP_TIMEOUT},
    {c_szRecvTimeout, AP_POP3_TIMEOUT},
    {c_szPort, AP_POP3_PORT},
    {c_szLeaveOnServer, AP_POP3_LEAVE_ON_SERVER},
    {c_szRemoveDeleted, AP_POP3_REMOVE_DELETED},
    {c_szRemoveExpired, AP_POP3_REMOVE_EXPIRED},
    {c_szExpireDays, AP_POP3_EXPIRE_DAYS},
    {c_szRegAccount, AP_POP3_USERNAME},
    {c_szRegUseSicily, AP_POP3_USE_SICILY},
    {c_szPassword, AP_POP3_PASSWORD},
    };

static const ACCTMIGRATEMAP c_rgSmtpMap[] =
    {
    {c_szPort, AP_SMTP_PORT}
    };

HRESULT MigrateMailAccountSettings(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3Server,
                                   HKEY hkeySmtpServer, LPSTR szDefPop3Server, LPSTR szDefSmtpServer)
    {
    DWORD dw, cb;
    HRESULT hr;
    char sz[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount;

    Assert(pAcctMan != NULL);
    Assert(szDefPop3Server != NULL);
    Assert(szDefSmtpServer != NULL);

    hr = pAcctMan->CreateAccountObject(ACCT_MAIL, &pAccount);
    if (FAILED(hr))
        return(hr);

    CHECKHR(hr = pAccount->SetPropSz(AP_SMTP_SERVER, szDefSmtpServer));

    CHECKHR(hr = pAccount->SetPropSz(AP_POP3_SERVER, szDefPop3Server));

    // Set Friendly Name
    StrCpyN(sz, szDefPop3Server, ARRAYSIZE(sz));
    CHECKHR(hr = pAcctMan->GetUniqueAccountName(sz, ARRAYSIZE(sz)));
    CHECKHR(hr = pAccount->SetPropSz(AP_ACCOUNT_NAME, sz));

    cb = sizeof(dw);
    if (RegQueryValueEx(hkeyMail, c_szRegBreakMessages, 0, NULL, (LPBYTE)&dw, &cb) == ERROR_SUCCESS &&
        dw != 0xffffffff)
        {
        // AP_SPLITMSGS
        CHECKHR(hr = pAccount->SetPropDw(AP_SMTP_SPLIT_MESSAGES, TRUE));

        // AP_SPLITSIZE
        CHECKHR(hr = pAccount->SetPropDw(AP_SMTP_SPLIT_SIZE, dw));
        }

    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyMail, c_rgMailMap, ARRAYSIZE(c_rgMailMap)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyPop3Server, c_rgPop3Map, ARRAYSIZE(c_rgPop3Map)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeySmtpServer, c_rgSmtpMap, ARRAYSIZE(c_rgSmtpMap)));

    // Save Account Changes
    hr = pAccount->SaveChanges();

exit:
    pAccount->Release();

    return(hr);
    }

// Note: This migrates only the default server, not un-supported multi servers
HRESULT MigrateMailServers(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3, HKEY hkeySmtp)
    {
    char szDefSmtpServer[CCHMAX_SERVER_NAME],
         szDefPop3Server[CCHMAX_SERVER_NAME];
    ULONG cb;
    DWORD dw;
    HKEY hkeyPop3Server = NULL,
         hkeySmtpServer = NULL;
    BOOL fSmtpMigrated = FALSE,
         fPop3Migrated = FALSE;
    HRESULT hr = S_OK;

    Assert(pAcctMan != NULL);
    Assert(hkeyMail != NULL);
    Assert(hkeyPop3 != NULL);
    Assert(hkeySmtp != NULL);

    // Get Default SMTP Server
    cb = sizeof(szDefSmtpServer);
    if (RegQueryValueEx(hkeyMail, c_szDefaultSmtpServer, 0, NULL, (LPBYTE)szDefSmtpServer, &cb) == ERROR_SUCCESS &&
        !FIsEmpty(szDefSmtpServer))
        {
        // If we have a default smtp sever, lets open the key
        RegOpenKeyEx(hkeySmtp, szDefSmtpServer, 0, KEY_ALL_ACCESS, &hkeySmtpServer);
        }

    // Get Default POP3 Server
    cb = sizeof(szDefPop3Server);
    if (RegQueryValueEx(hkeyMail, c_szDefaultPop3Server, 0, NULL, (LPBYTE)szDefPop3Server, &cb) == ERROR_SUCCESS &&
        !FIsEmpty(szDefPop3Server))
        {
        // If we have a default pop3 sever, lets open the key
        RegOpenKeyEx(hkeyPop3, szDefPop3Server, 0, KEY_ALL_ACCESS, &hkeyPop3Server);
        }

    // If we couldn't open the pop3 server, lets look in the registry and use the first server
    if (hkeyPop3Server == NULL)
        {
        // Enumerate and open the first server in the list
        cb = sizeof(szDefPop3Server);
        if (RegEnumKeyEx(hkeyPop3, 0, szDefPop3Server, &cb, 0, NULL, NULL, NULL) == ERROR_SUCCESS)
            RegOpenKeyEx(hkeyPop3, szDefPop3Server, 0, KEY_ALL_ACCESS, &hkeyPop3Server);
        }

    // If we couldn't open the pop3 server, lets look in the registry and use the first server
    if (hkeySmtpServer == NULL)
        {
        // Enumerate and open the first server in list
        cb = sizeof(szDefSmtpServer);
        if (RegEnumKeyEx(hkeySmtp, 0, szDefSmtpServer, &cb, 0, NULL, NULL, NULL) == ERROR_SUCCESS)
            RegOpenKeyEx(hkeySmtp, szDefSmtpServer, 0, KEY_ALL_ACCESS, &hkeySmtpServer);
        }

    if (hkeySmtpServer != NULL)
        {
        cb = sizeof(fSmtpMigrated);
        RegQueryValueEx(hkeySmtpServer, c_szMigrated, 0, NULL, (LPBYTE)&fSmtpMigrated, &cb);

        if (hkeyPop3Server != NULL)
            {
            cb = sizeof(fPop3Migrated);
            RegQueryValueEx(hkeyPop3Server, c_szMigrated, 0, NULL, (LPBYTE)&fPop3Migrated, &cb);

            if (!fPop3Migrated && !fSmtpMigrated)
                {
                hr = MigrateMailAccountSettings(pAcctMan, hkeyMail, hkeyPop3Server,
                                        hkeySmtpServer, szDefPop3Server, szDefSmtpServer);
                if (SUCCEEDED(hr))
                    {
                    fSmtpMigrated = TRUE;
                    RegSetValueEx(hkeySmtpServer, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fSmtpMigrated, sizeof(fSmtpMigrated));

                    fPop3Migrated = TRUE;
                    RegSetValueEx(hkeyPop3Server, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fPop3Migrated, sizeof(fPop3Migrated));
                    }
                }

            RegCloseKey(hkeyPop3Server);
            }

        RegCloseKey(hkeySmtpServer);
        }

    return(S_OK);
    }

static const ACCTMIGRATEMAP c_rgNewsMap[] =
    {
    {c_szSenderName, AP_NNTP_DISPLAY_NAME},
    {c_szSenderOrg, AP_NNTP_ORG_NAME},
    {c_szSenderEMail, AP_NNTP_EMAIL_ADDRESS},
    {c_szSenderReplyTo, AP_NNTP_REPLY_EMAIL_ADDRESS},
    };

static const ACCTMIGRATEMAP c_rgNewsServerMap[] =
    {
    {c_szRegAccountName, AP_NNTP_USERNAME},
    {c_szRegUseSicily, AP_NNTP_USE_SICILY},
    {c_szRegSecureConnect, AP_NNTP_SSL},
    {c_szRegServerTimeout, AP_NNTP_TIMEOUT},
    {c_szRegServerPort, AP_NNTP_PORT},
    {c_szRegUseDesc, AP_NNTP_USE_DESCRIPTIONS},
    {c_szRegConnectType, AP_RAS_CONNECTION_TYPE},
    {c_szRegRasPhonebookEntry, AP_RAS_CONNECTOID},
    {c_szRegNewsConnectFlags, AP_RAS_CONNECTION_FLAGS},
    {c_szPassword, AP_NNTP_PASSWORD},
    };

HRESULT MigrateNewsAccountSettings(IImnAccountManager *pAcctMan, HKEY hkeyNews, HKEY hkeyServer, LPSTR szServer, BOOL fDefault)
    {
    IImnAccount *pAccount;
    char sz[CCHMAX_ACCOUNT_NAME], szNewsDir[MAX_PATH], szDataDir[MAX_PATH];
    HRESULT hr;
    DWORD cb;

    Assert(pAcctMan != NULL);
    Assert(szServer != NULL);

    hr = pAcctMan->CreateAccountObject(ACCT_NEWS, &pAccount);
    if (FAILED(hr))
        return(hr);

    // AP_NNTP_SERVER
    CHECKHR(hr = pAccount->SetPropSz(AP_NNTP_SERVER, szServer));

    // Set Friendly Name
    StrCpyN(sz, szServer, ARRAYSIZE(sz));
    CHECKHR(hr = pAcctMan->GetUniqueAccountName(sz, ARRAYSIZE(sz)));
    CHECKHR(hr = pAccount->SetPropSz(AP_ACCOUNT_NAME, sz));

    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyNews, c_rgNewsMap, ARRAYSIZE(c_rgNewsMap)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyServer, c_rgNewsServerMap, ARRAYSIZE(c_rgNewsServerMap)));

    CHECKHR(hr = pAccount->SaveChanges());

    if (fDefault)
        pAccount->SetAsDefault();

exit:
    pAccount->Release();

    return(hr);
    }

HRESULT MigrateNewsServers(IImnAccountManager *pAcctMan, HKEY hkeyNews)
    {
    char szDefNntpServer[CCHMAX_SERVER_NAME],
         szServer[CCHMAX_SERVER_NAME];
    HKEY hkeyAthena = NULL, hkeyServer = NULL;
    DWORD cb, dw, i;
    BOOL fMigrated, fSetDefault, fDefault;
    LONG lResult;
    HRESULT hr = S_OK;

    Assert(pAcctMan != NULL);
    Assert(hkeyNews != NULL);

    fSetDefault = FALSE;
    hr = pAcctMan->GetDefaultAccountName(ACCT_NEWS, szServer, ARRAYSIZE(szServer));
    if (FAILED(hr))
        {
        // Query for the default news account
        cb = sizeof(szDefNntpServer);
        if (RegQueryValueEx(hkeyNews, c_szRegDefServer, 0, NULL, (LPBYTE)szDefNntpServer, &cb) == ERROR_SUCCESS &&
            !FIsEmpty(szDefNntpServer))
            fSetDefault = TRUE;
        }

    // Enumerate through the keys
    for (i = 0; ; i++)
        {
        // Enumerate Friendly Names
        cb = sizeof(szServer);
        lResult = RegEnumKeyEx(hkeyNews, i, szServer, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
            continue;

        // Lets open they server key
        if (RegOpenKeyEx(hkeyNews, szServer, 0, KEY_ALL_ACCESS, &hkeyServer) != ERROR_SUCCESS)
            continue;

        // Has this server been migrated yet ?
        cb = sizeof(fMigrated);
        if (RegQueryValueEx(hkeyServer, c_szMigrated, 0, NULL, (LPBYTE)&fMigrated, &cb) != ERROR_SUCCESS)
            fMigrated = FALSE;

        // If not migrated
        if (!fMigrated)
            {
            fDefault = (fSetDefault && (0 == lstrcmpi(szServer, szDefNntpServer)));

            hr = MigrateNewsAccountSettings(pAcctMan, hkeyNews, hkeyServer, szServer, fDefault);
            if (SUCCEEDED(hr))
                {
                fMigrated = TRUE;
                RegSetValueEx(hkeyServer, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fMigrated, sizeof(fMigrated));
                }

            if (fDefault)
                fSetDefault = FALSE;
            }

        RegCloseKey(hkeyServer);
        }

    return(S_OK);
    }

HRESULT MigrateBase64EncodedPassword(LPCSTR pszBase64, DWORD cch, DWORD dwPropId, IImnAccount *pAccount)
    {
    HRESULT          hr=S_OK;
    IStream         *pstmBase64=NULL;
    IStream         *pstmDecoded=NULL;
    IMimeBody       *pBody=NULL;
    LPSTR            pszPassword=NULL;

    // Invalid Arg
    Assert(pszBase64 && pAccount);

    // Create a mime body
    CHECKHR(hr = MimeOleCreateBody(&pBody));

    // InitNew
    CHECKHR(hr = pBody->InitNew());

    // Create a pstmBase64 Stream
    CHECKHR(hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmBase64));

    // Write the pszBase64 into this
    CHECKHR(hr = pstmBase64->Write(pszBase64, cch * sizeof(*pszBase64), NULL));

    // Commit
    CHECKHR(hr = pstmBase64->Commit(STGC_DEFAULT));

    // Rewind it
    CHECKHR(hr = HrRewindStream(pstmBase64));

    // Set it into IMimeBody
    CHECKHR(hr = pBody->SetData(IET_BASE64, NULL, NULL, IID_IStream, (LPVOID)pstmBase64));

    // Get the decoded stream
    CHECKHR(hr = pBody->GetData(IET_DECODED, &pstmDecoded));

    // Convert to string
    CHECKALLOC(pszPassword = PszFromANSIStreamA(pstmDecoded));

    // Store the property
    CHECKHR(hr = pAccount->SetPropSz(dwPropId, pszPassword));

exit:
    // Cleanup
    if (pszPassword)
        ZeroMemory(pszPassword, sizeof(pszPassword[0]) * lstrlenA(pszPassword));  // Done for security.
    SafeRelease(pstmBase64);
    SafeRelease(pstmDecoded);
    SafeRelease(pBody);
    SafeMemFree(pszPassword);

    return(hr);
    }

static const char c_szAccessColors[] = "Always Use My Colors";
static const char c_szAccessFontFace[] = "Always Use My Font Face";
static const char c_szAccessFontSize[] = "Always Use My Font Size";
static const char c_szAccessSysCaret[] = "Move System Caret";

void MigrateAccessibilityKeys()
    {
    HKEY hkeyExplorer, hkeyAthena;
    char szValue[MAX_PATH];
	DWORD cbData, dw;

    // Migrate keys from HKCU\SW\MS\InternetExplorer\Settings
	if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szIESettingsPath, 0, KEY_QUERY_VALUE, &hkeyExplorer) == ERROR_SUCCESS)
        {
        StrCpyN(szValue, c_szRegTriSettings, ARRAYSIZE(szValue));
        if (RegCreateKeyEx(MU_GetCurrentUserHKey(), szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAthena, &dw) == ERROR_SUCCESS)
	        {
			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessColors, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessColors, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessFontFace, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessFontFace, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessFontSize, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessFontSize, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

    		RegCloseKey(hkeyAthena);
			}

		RegCloseKey(hkeyExplorer);
		}

    // Migrate keys from HKCU\SW\MS\InternetExplorer\Main
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyIEMain, 0, KEY_QUERY_VALUE, &hkeyExplorer) == ERROR_SUCCESS)
        {
        StrCpyN(szValue, c_szRegTriMain, ARRAYSIZE(szValue));
        if (RegCreateKeyEx(MU_GetCurrentUserHKey(), szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAthena, &dw) == ERROR_SUCCESS)
			{
			cbData = MAX_PATH;
			if (RegQueryValueEx(hkeyExplorer, c_szAccessSysCaret, NULL, NULL, (LPBYTE)&szValue, &cbData) == ERROR_SUCCESS)
				RegSetValueEx(hkeyAthena, c_szAccessSysCaret, 0, REG_SZ, (LPBYTE)szValue, cbData);

            RegCloseKey(hkeyAthena);
            }

        RegCloseKey(hkeyExplorer);
		}
    }

ULONG UlBuildCritText(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszReg = NULL;
    LPSTR           pszVal = NULL;
    LPSTR           pszTokens = NULL;
    LPSTR           pszWalk = NULL;
    LPSTR           pszString = NULL;
    CRIT_ITEM       critItem;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszReg, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszReg, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszReg))
    {
        ulRet = 0;
        goto exit;
    }

    // The strings are supposed to be in lowercase
    CharLower(pszReg);

    // Break up the strings into each search token
    pszTokens = SzGetSearchTokens(pszReg);
    if (NULL == pszTokens)
    {
        ulRet = 0;
        goto exit;
    }

    // Count the space needed for the final string
    cbData = 0;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            cbData += lstrlen(pszWalk) + 1;
        }
    }

    // Nothing to add
    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    // Add space to hold the string terminator
    cbData += 2;
    DWORD cchSizeString = cbData;

    // Allocate space to hold the final string
    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the string
    pszString = pszVal;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            StrCpyNA(pszString, pszWalk, cchSizeString);
            cchSizeString -= (lstrlen(pszString) + 1);
            pszString += lstrlen(pszString) + 1;
        }
    }

    // Terminate the string
    pszString[0] = '\0';
    pszString[1] = '\0';

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_MULTIPLEAND;
    critItem.propvar.vt = VT_BLOB;
    critItem.propvar.blob.cbSize = cbData;
    critItem.propvar.blob.pBlobData = (BYTE *) pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    SafeMemFree(pszTokens);
    SafeMemFree(pszVal);
    SafeMemFree(pszReg);
    return ulRet;
}

ULONG UlBuildCritAcct(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL;
    CRIT_ITEM       critItem;
    IImnAccount *   pAccount = NULL;
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszVal))
    {
        ulRet = 0;
        goto exit;
    }

    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszVal, &pAccount)))
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
        {
            SafeMemFree(pszVal);
            pszVal = PszDupA(szAccount);
            if (NULL == pszVal)
            {
                ulRet = 0;
                goto exit;
            }
        }
    }

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_DEFAULT;
    critItem.propvar.vt = VT_LPSTR;
    critItem.propvar.pszVal = pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(pszVal);
    SafeRelease(pAccount);
    return ulRet;
}
ULONG UlBuildCritAddr(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    CRIT_ITEM       critItem;
    LPSTR           pszReg = NULL;
    LPSTR           pszVal = NULL;
    LPSTR           pszTokens = NULL;
    LPSTR           pszWalk = NULL;
    LPSTR           pszString = NULL;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &(pszReg), cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszReg, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszReg))
    {
        ulRet = 0;
        goto exit;
    }

    // The strings are supposed to be in lowercase
    CharLower(pszReg);

    // Break up the strings into each search token
    pszTokens = SzGetSearchTokens(pszReg);
    if (NULL == pszTokens)
    {
        ulRet = 0;
        goto exit;
    }

    // Count the space needed for the final string
    cbData = 0;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty addresses
        if (FALSE == FIsEmptyA(pszWalk))
        {
            cbData += lstrlen(pszWalk) + 1;
        }
    }

    // Nothing to add
    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    // Add space to hold the string terminator
    cbData += 2;
    DWORD cchSizeString = cbData;

    // Allocate space to hold the final string
    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the string
    pszString = pszVal;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            StrCpyN(pszString, pszWalk, cchSizeString);
            cchSizeString -= (lstrlen(pszString) + 1);
            pszString += lstrlen(pszString) + 1;
        }
    }

    // Terminate the string
    pszString[0] = '\0';
    pszString[1] = '\0';


    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_MULTIPLEAND;
    critItem.propvar.vt = VT_BLOB;
    critItem.propvar.blob.cbSize = cbData;
    critItem.propvar.blob.pBlobData = (BYTE *) pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(pszVal);
    SafeMemFree(pszTokens);
    SafeMemFree(pszReg);
    return ulRet;
}

ULONG UlBuildCritKB(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    ULONG           ulVal = NULL;
    CRIT_ITEM       critItem;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key long from the registry
    cbData = sizeof(ulVal);
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) &ulVal, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_DEFAULT;
    critItem.propvar.vt = VT_UI4;
    critItem.propvar.ulVal = ulVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    return ulRet;
}

ULONG UlBuildActFolder(HKEY hKeyRoot, IMessageStore * pStore, BYTE * pbFldIdMap, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG               ulRet = 0;
    DWORD               cbData = 0;
    LONG                lErr = ERROR_SUCCESS;
    ULONG               ulVal = NULL;
    ACT_ITEM            actItem;
    FOLDERID            idFolder = FOLDERID_INVALID;
    STOREUSERDATA       UserData = {0};
    RULEFOLDERDATA *    prfdData = NULL;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key long from the registry
    cbData = sizeof(ulVal);
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) &ulVal, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // Convert to V5 folder id
    if ((NULL == pbFldIdMap) || (FAILED(RuleUtil_HrMapFldId(0, pbFldIdMap, (FOLDERID)((ULONG_PTR)ulVal), &idFolder))))
    {
        idFolder = (FOLDERID)((ULONG_PTR)ulVal);
    }

    // Create space for the data structure
    if (FAILED(HrAlloc((VOID **) &prfdData, sizeof(*prfdData))))
    {
        ulRet = 0;
        goto exit;
    }

    // Initialize the data struct
    ZeroMemory(prfdData, sizeof(*prfdData));

    // Get the timestamp for the store
    if (FAILED(pStore->GetUserData(&UserData, sizeof(STOREUSERDATA))))
    {
        ulRet = 0;
        goto exit;
    }

    // Set up the rule folder data
    prfdData->ftStamp = UserData.ftCreated;
    prfdData->idFolder = idFolder;

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_BLOB;
    actItem.propvar.blob.cbSize = sizeof(*prfdData);
    actItem.propvar.blob.pBlobData = (BYTE *) prfdData;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(prfdData);
    return ulRet;
}

ULONG UlBuildActFwd(HKEY hKeyRoot, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0,
                    cchCount = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL,
                    pszTokens = NULL;
    LPWSTR          pwszVal = NULL,
                    pwszTokens = NULL;
    ACT_ITEM        actItem;
    ULONG           ulIndex = 0;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (0 == cbData)
    {
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);
    Assert(*pszVal);

    // Convert the string to our format
    for (ulIndex = 0; ulIndex < cbData; ulIndex++)
    {
        if (',' == pszVal[ulIndex])
        {
            pszVal[ulIndex] = ';';
        }
    }

    pwszVal = PszToUnicode(CP_ACP, pszVal);
    if (!pwszVal)
        goto exit;

    if (FAILED(RuleUtil_HrBuildEmailString(pwszVal, 0, &pwszTokens, &cchCount)))
    {
        goto exit;
    }

    Assert(pwszTokens);
    pszTokens = PszToANSI(CP_ACP, pwszTokens);
    if (!pszTokens)
        goto exit;

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_LPSTR;
    actItem.propvar.pszVal = pszTokens;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    MemFree(pszVal);
    MemFree(pwszVal);
    MemFree(pszTokens);
    MemFree(pwszTokens);
    return ulRet;
}

ULONG UlBuildActFile(HKEY hKeyRoot, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL;
    ACT_ITEM        actItem;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszVal))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_LPSTR;
    actItem.propvar.pszVal = pszVal;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    SafeMemFree(pszVal);
    return ulRet;
}

// The maximum possible size of the Athena V1 actions string
const int CCH_V1_ACTION_MAX = 255;

BOOL FConvertV1ActionsToV4(HKEY hkeyRule, IMessageStore * pStore, IOEActions * pIAct)
{
    BOOL                fRet = FALSE;
    ULONG               cbData = 0;
    LONG                lErr = ERROR_SUCCESS;
    TCHAR               szAction[CCH_V1_ACTION_MAX];
    LPSTR               pszFolderName = NULL;
    FOLDERID            idFolder = FOLDERID_INVALID;
    ACT_ITEM            actItem;
    RULEFOLDERDATA      rfdData = {0};
    STOREUSERDATA       UserData = {0};

    Assert(NULL != hkeyRule);
    Assert(NULL != pStore);
    Assert(NULL != pIAct);

    // Is there anything to do?
    cbData = sizeof(szAction);
    lErr = RegQueryValueEx(hkeyRule, c_szActionV1, NULL, NULL, (BYTE *) szAction, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(0 == lstrcmpi(szAction, (LPTSTR) c_szMoveV1));

    // Convert from old move to a V4 move

    // Get the size of the folder name
    lErr = RegQueryValueEx(hkeyRule, c_szFolderV1, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate space to hold the folder name
    if (FAILED(HrAlloc( (VOID **) &pszFolderName, cbData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the old folder name
    lErr = RegQueryValueEx(hkeyRule, c_szFolderV1, NULL, NULL, (BYTE *) pszFolderName, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Find the folder id from the folder name in the store
    if (FAILED(GetFolderIdFromName(pStore, pszFolderName, FOLDERID_LOCAL_STORE, &idFolder)))
    {
        idFolder = FOLDERID_INVALID;
    }

    // Get the timestamp for the store
    pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));

    // Set the timestamp and folder id
    rfdData.ftStamp = UserData.ftCreated;
    rfdData.idFolder = idFolder;

    // Build up the actions
    ZeroMemory(&actItem, sizeof(actItem));
    actItem.type = ACT_TYPE_MOVE;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_BLOB;
    actItem.propvar.blob.cbSize = sizeof(rfdData);
    actItem.propvar.blob.pBlobData = (BYTE *) &rfdData;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, NULL)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszFolderName);
    return fRet;
}


void MigrateMailRulesSettings(void)
{
    IImnAccountManager *pAcctMan = NULL;
    HKEY            hkeyOldRoot = NULL;
    LONG            lErr = 0;
    ULONG           cSubKeys = 0;
    HKEY            hkeyNewRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           cbData = 0;
    BYTE *          pbFldIdMap = NULL;
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    TCHAR           szNameOld[16];
    HKEY            hKeyOld = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            boolVal = FALSE;
    IOECriteria *   pICrit = NULL;
    CRIT_ITEM       critItem;
    ULONG           ccritItem = 0;
    CRIT_ITEM *     pCrit = NULL;
    ULONG           ccritItemAlloc = 0;
    IOEActions *    pIAct = NULL;
    DWORD           dwActs = 0;
    ACT_ITEM        actItem;
    ULONG           cactItem = 0;
    ACT_ITEM *      pAct = NULL;
    ULONG           cactItemAlloc = 0;
    ULONG           ulName = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    IOERule *       pIRuleFind = NULL;
    RULEINFO        infoRule = {0};
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];
    IMessageStore * pStore = NULL;

    // Initialize the local vars
    ZeroMemory(&critItem, sizeof(critItem));
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the old key
    lErr = AthUserOpenKey(c_szRegPathInboxRules, KEY_READ, &hkeyOldRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Is there anything to do?
    lErr = RegQueryInfoKey(hkeyOldRoot, NULL, NULL, NULL,
                    &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if ((lErr != ERROR_SUCCESS) || (0 == cSubKeys))
    {
        goto exit;
    }

    // To make sure we don't get any sample rule created
    // set up the registry to look like we've already been set-up

    // Get the new rules key
    lErr = AthUserCreateKey(c_szRulesMail, KEY_ALL_ACCESS, &hkeyNewRoot, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Save out the rules version
    cbData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyNewRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &cbData, sizeof(cbData));
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Figure out the size of the folderid map
    lErr = AthUserGetValue(NULL, c_szFolderIdChange, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        goto exit;
    }

    // If the map exists, then grab it
    if (ERROR_SUCCESS == lErr)
    {
        // Allocate the space to hold the folderid map
        if (FAILED(HrAlloc((void **) &pbFldIdMap, cbData)))
        {
            goto exit;
        }

        // Get the folderid map from the registry
        lErr = AthUserGetValue(NULL, c_szFolderIdChange, NULL, pbFldIdMap, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            goto exit;
        }
    }

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create the Rules Manager
    Assert(NULL == g_pRulesMan);
    hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the rules manager
    hr = g_pRulesMan->Initialize(0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the Account Manager
    Assert(g_pAcctMan == NULL);
    hr = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = pAcctMan->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&g_pAcctMan);
    pAcctMan->Release();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    pStore = new CMessageStore(FALSE);
    if (NULL == pStore)
    {
        goto exit;
    }

    // Initialize the store
    hr = pStore->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }

    ulIndex = 0;
    wnsprintf(szNameOld, ARRAYSIZE(szNameOld), "Rule%05d", ulIndex);

    if (0 == LoadString(g_hLocRes, idsRuleDefaultName, szRes, ARRAYSIZE(szRes)))
    {
        goto exit;
    }

    // For each entry in the old rules key
    for (;RegOpenKeyEx(hkeyOldRoot, szNameOld, 0, KEY_READ, &hKeyOld) == ERROR_SUCCESS; RegCloseKey(hKeyOld))
    {
        // Create the new Rule
        SafeRelease(pIRule);
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Set the name on the rule
        ulName = 1;
        wnsprintf(szName, ARRAYSIZE(szName), szRes, ulName);

        Assert(NULL != g_pRulesMan);
        while (S_OK == g_pRulesMan->FindRule(szName, RULE_TYPE_MAIL, &pIRuleFind))
        {
            SafeRelease(pIRuleFind);
            ulName++;
            wnsprintf(szName, ARRAYSIZE(szName), szRes, ulName);
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szName;
        pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

        // Set the enabled state on the rule
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szDisabled, NULL, NULL, (LPVOID) (&boolVal), &cbData);

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BOOL;
        propvar.boolVal = !!boolVal;
        pIRule->SetProp(RULE_PROP_DISABLED, 0, &propvar);

        // Copy over the criteria
        SafeRelease(pICrit);
        hr = HrCreateCriteria(&pICrit);
        if (FAILED(hr))
        {
            continue;
        }

        ccritItem = 0;

        // Check for All Messages
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterAllMessages, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            critItem.type = CRIT_TYPE_ALL;
            critItem.propvar.vt = VT_EMPTY;
            critItem.logic = CRIT_LOGIC_NULL;
            critItem.dwFlags = CRIT_FLAG_DEFAULT;
            if (SUCCEEDED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, NULL)))
            {
                ccritItem++;
            }
        }
        else
        {
            // Check for account
            cbData = sizeof(boolVal);
            SHQueryValueEx(hKeyOld, c_szFilterByAccount, NULL, NULL, (LPVOID) (&boolVal), &cbData);
            if (FALSE != boolVal)
            {
                ccritItem += UlBuildCritAcct(hKeyOld, c_szAccount, CRIT_TYPE_ACCOUNT, pICrit);
            }

            // Check for size
            cbData = sizeof(boolVal);
            SHQueryValueEx(hKeyOld, c_szFilterOnSize, NULL, NULL, (LPVOID) (&boolVal), &cbData);
            if (FALSE != boolVal)
            {
                ccritItem += UlBuildCritKB(hKeyOld, c_szFilterSize, CRIT_TYPE_SIZE, pICrit);
            }

            // Check for subject
            ccritItem += UlBuildCritText(hKeyOld, c_szSubject, CRIT_TYPE_SUBJECT, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szFrom, CRIT_TYPE_FROM, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szTo, CRIT_TYPE_TO, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szCC, CRIT_TYPE_CC, pICrit);
        }

        if (0 != ccritItem)
        {
            // Get the criteria from the criteria object and set it on the rule
            RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
            SafeMemFree(pCrit);
            if (SUCCEEDED(pICrit->GetCriteria(0, &pCrit, &ccritItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = ccritItem * sizeof(CRIT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pCrit;
                if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        // Copy over the actions
        SafeRelease(pIAct);
        hr = HrCreateActions(&pIAct);
        if (FAILED(hr))
        {
            continue;
        }

        cactItem = 0;

        // Convert any old V1 actions to V4
        if (FALSE != FConvertV1ActionsToV4(hKeyOld, pStore, pIAct))
        {
            cactItem = 1;
        }
        else
        {
            // Get list of actions
            cbData = sizeof(dwActs);
            SHQueryValueEx(hKeyOld, c_szActions, NULL, NULL, (LPVOID) (&dwActs), &cbData);

            // Check for don't download
            if (0 != (dwActs & ACT_DONTDOWNLOAD))
            {
                actItem.type = ACT_TYPE_DONTDOWNLOAD;
                actItem.dwFlags = ACT_FLAG_DEFAULT;
                actItem.propvar.vt = VT_EMPTY;
                if (SUCCEEDED(pIAct->AppendActions(0, &actItem, 1, NULL)))
                {
                    cactItem++;
                }
            }
            // Check for delete from server
            else if (0 != (dwActs & ACT_DELETEOFFSERVER))
            {
                actItem.type = ACT_TYPE_DELETESERVER;
                actItem.dwFlags = ACT_FLAG_DEFAULT;
                actItem.propvar.vt = VT_EMPTY;
                if (SUCCEEDED(pIAct->AppendActions(0, &actItem, 1, NULL)))
                {
                    cactItem++;
                }
            }
            else
            {
                // Check for move to
                if (0 != (dwActs & ACT_MOVETO))
                {
                    cactItem += UlBuildActFolder(hKeyOld, pStore, pbFldIdMap, c_szMoveToHfolder, ACT_TYPE_MOVE, pIAct);
                }

                // Check for copy to
                if (0 != (dwActs & ACT_COPYTO))
                {
                    cactItem += UlBuildActFolder(hKeyOld, pStore, pbFldIdMap, c_szCopyToHfolder, ACT_TYPE_COPY, pIAct);
                }

                // Check for forward to
                if (0 != (dwActs & ACT_FORWARDTO))
                {
                    cactItem += UlBuildActFwd(hKeyOld, c_szForwardTo, ACT_TYPE_FWD, pIAct);
                }

                // Check for reply with
                if (0 != (dwActs & ACT_REPLYWITH))
                {
                    cactItem += UlBuildActFile(hKeyOld, c_szReplyWithFile, ACT_TYPE_REPLY, pIAct);
                }
            }
        }

        if (0 != cactItem)
        {
            // Get the actions from the action object and set it on the rule
            RuleUtil_HrFreeActionsItem(pAct, cactItemAlloc);
            SafeMemFree(pAct);
            if (SUCCEEDED(pIAct->GetActions(0, &pAct, &cactItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = cactItem * sizeof(ACT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pAct;
                if (FAILED(pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        // Initialize the rule info
        infoRule.ridRule = RULEID_INVALID;
        infoRule.pIRule = pIRule;

        // Add it to the rules
        g_pRulesMan->SetRules(SETF_APPEND, RULE_TYPE_MAIL, &infoRule, 1);

        ulIndex++;
        wnsprintf(szNameOld, ARRAYSIZE(szNameOld), "Rule%05d", ulIndex);
    }

exit:
    RuleUtil_HrFreeActionsItem(pAct, cactItemAlloc);
    SafeMemFree(pAct);
    RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
    SafeMemFree(pCrit);
    SafeRelease(pIAct);
    SafeRelease(pICrit);
    SafeRelease(pIRule);
    if (NULL != hKeyOld)
    {
        RegCloseKey(hKeyOld);
    }
    SafeRelease(pStore);
    SafeRelease(g_pAcctMan);
    SafeRelease(g_pRulesMan);
    DeInitGlobalOptions();
    SafeMemFree(pbFldIdMap);
    if (NULL != hkeyNewRoot)
    {
        RegCloseKey(hkeyNewRoot);
    }
    if (NULL != hkeyOldRoot)
    {
        RegCloseKey(hkeyOldRoot);
    }
}

void CopyBeta2RulesToRTM(VOID)
{
    LONG    lErr = ERROR_SUCCESS;
    HKEY    hKeyMail = NULL;
    HKEY    hkeyRTM = NULL;
    DWORD   dwDisp = 0;

    // Get the Beta 2 hkey for rules
    lErr = AthUserOpenKey(c_szMail, KEY_READ, &hKeyMail);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Create the RTM hkey for rules
    lErr = AthUserCreateKey(c_szRulesMail, KEY_ALL_ACCESS, &hkeyRTM, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Copy the Beta 2 rules to the new location
    SHCopyKey(hKeyMail, c_szRules, hkeyRTM, NULL);

exit:
    if (NULL != hkeyRTM)
    {
        RegCloseKey(hkeyRTM);
    }
    if (NULL != hKeyMail)
    {
        RegCloseKey(hKeyMail);
    }
    return;
}

void UpdateBeta2String(HKEY hkeyItem, LPCSTR pszSep, DWORD dwItemType)
{
    HRESULT hr = S_OK;
    LPSTR   pszData = NULL;
    ULONG   cbData = 0;
    LONG    lErr = ERROR_SUCCESS;
    DWORD   dwData = 0;

    Assert(NULL != hkeyItem);

    // Get the new data
    hr = RuleUtil_HrGetOldFormatString(hkeyItem, c_szCriteriaValue, g_szComma, &pszData, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write out the new data
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValue, 0, REG_BINARY, (BYTE *) pszData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_BLOB;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper flags
    dwData = CRIT_FLAG_MULTIPLEAND;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write the new type
    cbData = sizeof(dwItemType);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaType, 0, REG_DWORD, (BYTE *) &dwItemType, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    SafeMemFree(pszData);
    return;
}

static IMessageStore * g_pStoreRulesMig = NULL;

VOID WriteOldOrderFormat(HKEY hkeyItem, LPSTR pszOrder)
{
    ULONG   cbData = 0;
    LPSTR   pszWalk = NULL;
    ULONG   cchWalk = 0;

    // Convert the order string back to our old format
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += cchWalk + 1)
    {
        cchWalk = lstrlen(pszWalk);
        *(pszWalk + cchWalk) = ' ';
        cbData += cchWalk + 1;
    }

    // Make sure we terminate the order string
    pszOrder[cbData - 1] = '\0';

    // Save it
    RegSetValueEx(hkeyItem, c_szRulesOrder, 0, REG_SZ, (BYTE *) pszOrder, cbData);

    return;
}

static CRIT_TYPE    g_rgtypeCritMerge[] =
{
    CRIT_TYPE_FROM,
    CRIT_TYPE_TO,
    CRIT_TYPE_CC,
    CRIT_TYPE_TOORCC
};

static const int g_ctypeCritMerge = sizeof(g_rgtypeCritMerge) / sizeof(g_rgtypeCritMerge[0]);

BOOL FMergeRuleData(HKEY hkeyItem, LPSTR pszSubKey, LPSTR * ppszData, ULONG * pcbData)
{
    BOOL    fRet = FALSE;
    LONG    lErr = ERROR_SUCCESS;
    DWORD   dwType = 0;
    ULONG   cbString = 0;
    LPSTR   pszData = NULL;
    ULONG   cbData = 0;

    // Get the size of the original string
    lErr = SHGetValue(hkeyItem, pszSubKey, c_szCriteriaValue, &dwType, NULL, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the space for the final string
    cbData = *pcbData + cbString - 2;
    if (cbData < *pcbData)
    	cbData = *pcbData;

    // Allocate space for the final data
    if (FAILED(HrAlloc((VOID **) &pszData, cbData * sizeof(*pszData))))
    {
        fRet = FALSE;
        goto exit;
    }

    // Copy over the original string
    CopyMemory(pszData, *ppszData, *pcbData * sizeof(*pszData));

    // Copy over the new data
    lErr = SHGetValue(hkeyItem, pszSubKey, c_szCriteriaValue, &dwType, (BYTE *) (pszData + *pcbData - 2), &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Free the old data
    SafeMemFree(*ppszData);

    // Set the return values
    *ppszData = pszData;
    pszData = NULL;
    *pcbData = cbData;

    fRet = TRUE;

exit:
    SafeMemFree(pszData);
    return fRet;
}

void AddStopAction(HKEY hkeyItem, LPSTR * ppszOrder, ULONG * pcchOrder)
{
    ULONG       ulIndex = 0;
    CHAR        rgchTag[CCH_INDEX_MAX];
    LPSTR       pszWalk = NULL;
    HKEY        hkeyAction = NULL;
    DWORD       dwDisp = 0;
    ULONG       cbData = 0;
    LONG        lErr = 0;
    ACT_TYPE    typeAct = ACT_TYPE_NULL;
    DWORD       dwData = 0;
    ULONG       cchOrder = 0;
    LPSTR       pszOrder = NULL;

    // Check to see if we need to add the stop processing action
    if ('\0' == (*ppszOrder + lstrlen(*ppszOrder) + 1)[0])
    {
        // Get the action type
        cbData = sizeof(typeAct);
        lErr = SHGetValue(hkeyItem, *ppszOrder, c_szActionsType, NULL, (BYTE *) &typeAct, &cbData);
        if (ERROR_SUCCESS == lErr)
        {
            if ((ACT_TYPE_DONTDOWNLOAD == typeAct) || (ACT_TYPE_DELETESERVER == typeAct))
            {
                goto exit;
            }
        }
    }

    // Spin through the order item looking for an open entry
    for (ulIndex = 0; ulIndex < DWORD_INDEX_MAX; ulIndex++)
    {
        // Create the tag
        wnsprintf(rgchTag, ARRAYSIZE(rgchTag), "%03X", ulIndex);

        // Search for the tag in the list
        for (pszWalk = *ppszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            if (0 == lstrcmp(pszWalk, rgchTag))
            {
                // Found it
                break;
            }
        }

        // If we didn't find it
        if ('\0' == pszWalk[0])
        {
            // Use this one
            break;
        }
    }

    // Did we find anything?
    if (ulIndex >= DWORD_INDEX_MAX)
    {
        goto exit;
    }

    // Create the new entry
    lErr = RegCreateKeyEx(hkeyItem, rgchTag, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAction, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Set the action type
    cbData = sizeof(typeAct);
    typeAct = ACT_TYPE_STOP;
    lErr = RegSetValueEx(hkeyAction, c_szActionsType, 0, REG_DWORD, (BYTE *) &typeAct, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Set the action flags
    dwData = ACT_FLAG_DEFAULT;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyAction, c_szActionsFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Allocate space to hold the new order string
    cchOrder= *pcchOrder + CCH_INDEX_MAX;
    if (FAILED(HrAlloc((VOID **) &pszOrder, cchOrder * sizeof (*pszOrder))))
    {
        goto exit;
    }

    // Copy over the old values
    CopyMemory(pszOrder, *ppszOrder, (*pcchOrder) * sizeof(*pszOrder));

    // Add it to the new order string
    StrCpyN(pszOrder + *pcchOrder - 2, rgchTag, (cchOrder - *pcchOrder + 2));

    // Terminate the new string
    pszOrder[cchOrder - 2] = '\0';
    pszOrder[cchOrder - 1] = '\0';

    // Release the old string
    SafeMemFree(*ppszOrder);

    // Save the new string
    *ppszOrder = pszOrder;
    pszOrder = NULL;
    *pcchOrder = cchOrder;

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    return;
}

void MergeRTMCriteria(HKEY hkeyItem, CRIT_TYPE typeCrit, LPSTR pszOrder, ULONG cchOrder)
{
    LONG        lErr = ERROR_SUCCESS;
    LPSTR       pszWalk = NULL;
    CRIT_TYPE   typeCritNew = CRIT_TYPE_NULL;
    ULONG       cbData = 0;
    LPSTR       pszFirst = NULL;
    DWORD       dwType = 0;
    ULONG       cbString = 0;
    LPSTR       pszString = NULL;
    LPSTR       pszSrc = NULL;

    // Look through each item
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        cbData = sizeof(typeCritNew);
        lErr = SHGetValue(hkeyItem, pszWalk, c_szCriteriaType, &dwType, (BYTE *) &typeCritNew, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        if (typeCritNew == typeCrit)
        {
            break;
        }
    }

    // If we couldn't find it we're done
    if ('\0' == pszWalk[0])
    {
        goto exit;
    }

    // Get the size of the original string
    pszFirst = pszWalk;
    lErr = SHGetValue(hkeyItem, pszFirst, c_szCriteriaValue, &dwType, NULL, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (FAILED(HrAlloc((VOID **) &pszString, cbString * sizeof(*pszString))))
    {
        goto exit;
    }

    // Get the original string
    lErr = SHGetValue(hkeyItem, pszFirst, c_szCriteriaValue, &dwType, (BYTE *) pszString, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Search for more entries of this type
    for (pszWalk = pszFirst + lstrlen(pszFirst) + 1; '\0' != pszWalk[0]; )
    {
        cbData = sizeof(typeCritNew);
        lErr = SHGetValue(hkeyItem, pszWalk, c_szCriteriaType, &dwType, (BYTE *) &typeCritNew, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        if (typeCritNew == typeCrit)
        {
            if (FALSE == FMergeRuleData(hkeyItem, pszWalk, &pszString, &cbString))
            {
                break;
            }

            // Remove the old key
            SHDeleteKey(hkeyItem, pszWalk);

            // Remove the item from the order string
            pszSrc = pszWalk + lstrlen(pszWalk) + 1;
            MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));
            cchOrder -= (ULONG) (pszSrc - pszWalk);
        }
        else
        {
            pszWalk += lstrlen(pszWalk) + 1;
        }
    }

    // Save out the final string
    lErr = SHSetValue(hkeyItem, pszFirst, c_szCriteriaValue, REG_BINARY, (BYTE *) pszString, cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

exit:
    SafeMemFree(pszString);
    return;
}

void UpdateBeta2Folder(HKEY hkeyItem)
{
    LONG            lErr = ERROR_SUCCESS;
    DWORD           dwType = 0;
    FOLDERID        idFolder = FOLDERID_INVALID;
    ULONG           cbData = 0;
    STOREUSERDATA   UserData = {0};
    RULEFOLDERDATA  rfdData = {0};
    DWORD           dwData = 0;

    Assert(NULL != hkeyItem);

    // Get the old folder id
    cbData = sizeof(idFolder);
    lErr = RegQueryValueEx(hkeyItem, c_szCriteriaValue, 0, &dwType, (BYTE *) &idFolder, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Get the timestamp for the store
    Assert(NULL != g_pStoreRulesMig);
    if (FAILED(g_pStoreRulesMig->GetUserData(&UserData, sizeof(STOREUSERDATA))))
    {
        goto exit;
    }

    // Set up the new data
    rfdData.idFolder = idFolder;
    rfdData.ftStamp = UserData.ftCreated;

    // Write out the new data
    cbData = sizeof(rfdData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValue, 0, REG_BINARY, (BYTE *) &rfdData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_BLOB;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    return;
}

void UpdateBeta2Show(HKEY hkeyItem)
{
    LONG            lErr = ERROR_SUCCESS;
    DWORD           dwType = 0;
    DWORD           dwData = 0;
    ULONG           cbData = 0;

    Assert(NULL != hkeyItem);

    // Get the old flags
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyItem, c_szActionsFlags, 0, &dwType, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (0 != (dwData & ACT_FLAG_INVERT))
    {
        dwData = ACT_DATA_HIDE;
    }
    else
    {
        dwData = ACT_DATA_SHOW;
    }

    // Write out the new data
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsValue, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_UI4;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper flags
    dwData = ACT_FLAG_DEFAULT;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    return;
}

void UpdateBeta2Criteria(HKEY hkeyItem, LPCSTR pszSubKey)
{
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyAtom = NULL;
    CRIT_TYPE   typeCrit = CRIT_TYPE_NULL;
    DWORD       dwType = 0;
    ULONG       cbData = 0;

    lErr = RegOpenKeyEx(hkeyItem, pszSubKey, 0, KEY_ALL_ACCESS, &hkeyAtom);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the type of criteria
    cbData = sizeof(typeCrit);
    lErr = RegQueryValueEx(hkeyAtom, c_szCriteriaType, NULL, &dwType, (BYTE *) &typeCrit, &cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // For each criteria type
    switch (typeCrit)
    {
        case CRIT_TYPE_FROM:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_FROM);
            break;

        case CRIT_TYPE_FROMADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_FROM);
            break;

        case CRIT_TYPE_TO:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_TO);
            break;

        case CRIT_TYPE_TOADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_TO);
            break;

        case CRIT_TYPE_CC:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_CC);
            break;

        case CRIT_TYPE_CCADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_CC);
            break;

        case CRIT_TYPE_TOORCC:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_TOORCC);
            break;

        case CRIT_TYPE_TOORCCADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_TOORCC);
            break;

        case CRIT_TYPE_SUBJECT:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_SUBJECT);
            break;

        case CRIT_TYPE_BODY:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_BODY);
            break;

        case CRIT_TYPE_NEWSGROUP:
            UpdateBeta2Folder(hkeyAtom);
            break;
    }

exit:
    if (NULL != hkeyAtom)
    {
        RegCloseKey(hkeyAtom);
    }
    return;
}

void UpdateBeta2Actions(HKEY hkeyItem, LPCSTR pszSubKey)
{
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyAtom = NULL;
    ACT_TYPE    typeAct = ACT_TYPE_NULL;
    DWORD       dwType = 0;
    ULONG       cbData = 0;

    lErr = RegOpenKeyEx(hkeyItem, pszSubKey, 0, KEY_ALL_ACCESS, &hkeyAtom);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the type of actions
    cbData = sizeof(typeAct);
    lErr = RegQueryValueEx(hkeyAtom, c_szActionsType, NULL, &dwType, (BYTE *) &typeAct, &cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // For each actions type
    switch (typeAct)
    {
        case ACT_TYPE_MOVE:
        case ACT_TYPE_COPY:
            UpdateBeta2Folder(hkeyAtom);
            break;

        case ACT_TYPE_SHOW:
            UpdateBeta2Show(hkeyAtom);
    }

exit:
    if (NULL != hkeyAtom)
    {
        RegCloseKey(hkeyAtom);
    }
    return;
}

void MigrateBeta2RuleItems(HKEY hkeyRule, LPCSTR pszSubkey, BOOL fActions, RULE_TYPE typeRule)
{
    LONG    lErr = ERROR_SUCCESS;
    HKEY    hkeySubkey = NULL;
    HRESULT hr = S_OK;
    LPSTR   pszOrder = NULL;
    LPSTR   pszWalk = NULL;
    ULONG   ulIndex = 0;
    ULONG   cbData = 0;
    ULONG   cchWalk = 0;

    lErr = RegOpenKeyEx(hkeyRule, pszSubkey, 0, KEY_ALL_ACCESS, &hkeySubkey);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeySubkey, c_szRulesOrder, g_szSpace, &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // For each item in the order string
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Update actions
        if (FALSE != fActions)
        {
            UpdateBeta2Actions(hkeySubkey, pszWalk);
        }
        else
        {
            UpdateBeta2Criteria(hkeySubkey, pszWalk);
        }
    }

    if (FALSE == fActions)
    {
        // For each item type
        for (ulIndex = 0; ulIndex < g_ctypeCritMerge; ulIndex++)
        {
            MergeRTMCriteria(hkeySubkey, g_rgtypeCritMerge[ulIndex], pszOrder, cbData);
        }
    }
    else
    {
        if (typeRule != RULE_TYPE_FILTER)
        {
            AddStopAction(hkeySubkey, &pszOrder, &cbData);
        }
    }

    // Write out the order string
    WriteOldOrderFormat(hkeySubkey, pszOrder);

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeySubkey)
    {
        RegCloseKey(hkeySubkey);
    }
    return;
}

void UpdateBeta2Rule(HKEY hkeyRoot, LPCSTR pszRule, RULE_TYPE typeRule)
{
    HKEY    hkeyRule = NULL;
    LONG    lErr = ERROR_SUCCESS;

    // Open up the rule
    lErr = RegOpenKeyEx(hkeyRoot, pszRule, 0, KEY_ALL_ACCESS, &hkeyRule);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Migrate the criteria
    MigrateBeta2RuleItems(hkeyRule, c_szRuleCriteria, FALSE, typeRule);

    // Migrate the actions
    MigrateBeta2RuleItems(hkeyRule, c_szRuleActions, TRUE, typeRule);

exit:
    if (NULL != hkeyRule)
    {
        RegCloseKey(hkeyRule);
    }
    return;
}

typedef struct _RULEREGKEY
{
    LPCSTR      pszRegKey;
    RULE_TYPE   typeRule;
} RULEREGKEY, * PRULEREGKEY;

static RULEREGKEY g_rgpszRuleRegKeys[] =
{
    {c_szRulesMail,     RULE_TYPE_MAIL},
    {c_szRulesNews,     RULE_TYPE_NEWS},
    {c_szRulesFilter,   RULE_TYPE_FILTER}
};

static const int g_cpszRuleRegKeys = sizeof(g_rgpszRuleRegKeys) / sizeof(g_rgpszRuleRegKeys[0]);

void UpdateBeta2RuleFormats(VOID)
{
    ULONG           ulIndex = 0;
    LONG            lErr = ERROR_SUCCESS;
    HKEY            hkeyRoot = NULL;
    HRESULT         hr = S_OK;
    LPSTR           pszOrder = NULL;
    LPSTR           pszWalk = NULL;
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];

    // Set up the global objects

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    g_pStoreRulesMig = new CMessageStore(FALSE);
    if (NULL == g_pStoreRulesMig)
    {
        goto exit;
    }

    // Initialize the store
    hr = g_pStoreRulesMig->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }


    // For each type of rule
    for (ulIndex = 0; ulIndex < g_cpszRuleRegKeys; ulIndex++)
    {
        // Open up the rule type reg key
        if (NULL != hkeyRoot)
        {
            RegCloseKey(hkeyRoot);
        }
        lErr = AthUserOpenKey(g_rgpszRuleRegKeys[ulIndex].pszRegKey, KEY_ALL_ACCESS, &hkeyRoot);
        if (lErr != ERROR_SUCCESS)
        {
            continue;
        }

        // Get the order string
        SafeMemFree(pszOrder);
        hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, NULL);
        if (FAILED(hr))
        {
            continue;
        }

        // For each item in the order string
        for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            // Update rule
            UpdateBeta2Rule(hkeyRoot, pszWalk, g_rgpszRuleRegKeys[ulIndex].typeRule);
        }
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    SafeRelease(g_pStoreRulesMig);
    return;
}

void MigrateBeta2Rules(VOID)
{
    // Copy over all the items from the mail\rules area

    // Get the new rules key
    CopyBeta2RulesToRTM();

    // Go through each rule type updating the formats
    UpdateBeta2RuleFormats();

    // Merge the items if neccessary

    return;
}

void MigrateGroupFilterSettings(void)
{
    IImnAccountManager *pAcctMan = NULL;
    HKEY            hkeyOldRoot = NULL;
    LONG            lErr = 0;
    ULONG           cSubKeys = 0;
    HKEY            hkeyNewRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           cbData = 0;
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    TCHAR           szNameOld[16];
    HKEY            hKeyOld = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            boolVal = FALSE;
    IOECriteria *   pICrit = NULL;
    CRIT_ITEM       critItem;
    ULONG           ccritItem = 0;
    CRIT_ITEM *     pCrit = NULL;
    ULONG           ccritItemAlloc = 0;
    DWORD           dwActs = 0;
    ACT_ITEM        actItem;
    ULONG           cactItemAlloc = 0;
    ULONG           ulName = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    IOERule *       pIRuleFind = NULL;
    RULEINFO        infoRule = {0};
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];
    IMessageStore * pStore = NULL;

    // Initialize the local vars
    ZeroMemory(&critItem, sizeof(critItem));
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the old key
    lErr = AthUserOpenKey(c_szRegPathGroupFilters, KEY_READ, &hkeyOldRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Is there anything to do?
    lErr = RegQueryInfoKey(hkeyOldRoot, NULL, NULL, NULL,
                    &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if ((lErr != ERROR_SUCCESS) || (0 == cSubKeys))
    {
        goto exit;
    }

    // To make sure we don't get any sample rule created
    // set up the registry to look like we've already been set-up

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create the Rules Manager
    Assert(NULL == g_pRulesMan);
    hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the rules manager
    hr = g_pRulesMan->Initialize(0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the Account Manager
    Assert(g_pAcctMan == NULL);
    hr = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = pAcctMan->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&g_pAcctMan);
    pAcctMan->Release();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    pStore = new CMessageStore(FALSE);
    if (NULL == pStore)
    {
        goto exit;
    }

    // Initialize the store
    hr = pStore->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }

    ulIndex = 0;
    wnsprintf(szNameOld, ARRAYSIZE(szNameOld), "Rule%05d", ulIndex);

    // Initialize the action
    actItem.type = ACT_TYPE_SHOW;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_UI4;
    actItem.propvar.ulVal = ACT_DATA_HIDE;

    if (0 == LoadString(g_hLocRes, idsNewsFilterDefaultName, szRes, ARRAYSIZE(szRes)))
    {
        goto exit;
    }

    // For each entry in the old rules key
    for (;RegOpenKeyEx(hkeyOldRoot, szNameOld, 0, KEY_READ, &hKeyOld) == ERROR_SUCCESS; RegCloseKey(hKeyOld))
    {
        // Create the new Rule
        SafeRelease(pIRule);
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Set the name on the rule
        ulName = 1;
        wnsprintf(szName, ARRAYSIZE(szName), szRes, ulName);

        Assert(NULL != g_pRulesMan);
        while (S_OK == g_pRulesMan->FindRule(szName, RULE_TYPE_FILTER, &pIRuleFind))
        {
            SafeRelease(pIRuleFind);
            ulName++;
            wnsprintf(szName, ARRAYSIZE(szName), szRes, ulName);
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szName;
        pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

        // Copy over the criteria
        SafeRelease(pICrit);
        hr = HrCreateCriteria(&pICrit);
        if (FAILED(hr))
        {
            continue;
        }

        ccritItem = 0;

        // Check for age
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterOnDate, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            ccritItem += UlBuildCritKB(hKeyOld, c_szFilterDays, CRIT_TYPE_AGE, pICrit);
        }

        // Check for lines
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterOnSize, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            ccritItem += UlBuildCritKB(hKeyOld, c_szFilterSize, CRIT_TYPE_LINES, pICrit);
        }

        // Check for subject
        ccritItem += UlBuildCritText(hKeyOld, c_szSubject, CRIT_TYPE_SUBJECT, pICrit);

        // Check for From
        ccritItem += UlBuildCritAddr(hKeyOld, c_szFrom, CRIT_TYPE_FROM, pICrit);

        if (0 != ccritItem)
        {
            // Get the criteria from the criteria object and set it on the rule
            RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
            SafeMemFree(pCrit);
            if (SUCCEEDED(pICrit->GetCriteria(0, &pCrit, &ccritItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = ccritItem * sizeof(CRIT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pCrit;
                if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(actItem);
        propvar.blob.pBlobData = (BYTE *) &actItem;
        if (FAILED(pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar)))
        {
            continue;
        }

        // Initialize the rule info
        infoRule.ridRule = RULEID_INVALID;
        infoRule.pIRule = pIRule;

        // Add it to the rules
        g_pRulesMan->SetRules(SETF_APPEND, RULE_TYPE_FILTER, &infoRule, 1);

        ulIndex++;
        wnsprintf(szNameOld, ARRAYSIZE(szNameOld), "Rule%05d", ulIndex);
    }

exit:
    RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
    SafeMemFree(pCrit);
    SafeRelease(pICrit);
    SafeRelease(pIRule);
    if (NULL != hKeyOld)
    {
        RegCloseKey(hKeyOld);
    }
    SafeRelease(pStore);
    SafeRelease(g_pAcctMan);
    SafeRelease(g_pRulesMan);
    DeInitGlobalOptions();
    if (NULL != hkeyNewRoot)
    {
        RegCloseKey(hkeyNewRoot);
    }
    if (NULL != hkeyOldRoot)
    {
        RegCloseKey(hkeyOldRoot);
    }
}

void RemoveDeletedFromFilters(VOID)
{
    CHAR        szDeleted[CCH_INDEX_MAX];
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    HRESULT     hr = S_OK;
    LPSTR       pszOrder = NULL;
    ULONG       cchOrder = 0;
    LPSTR       pszWalk = NULL;
    LPSTR       pszSrc = NULL;

    // Create the DELETED key
    wnsprintf(szDeleted, ARRAYSIZE(szDeleted), "%03X", RULEID_VIEW_DELETED);

    // Open the filter key
    lErr = AthUserOpenKey(c_szRulesFilter, KEY_ALL_ACCESS, &hkeyRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, &cchOrder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search for RULEID_VIEW_DELETED
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        if (0 == lstrcmpi(szDeleted, pszWalk))
        {
            break;
        }
    }

    // If we found it, then remove it
    if ('\0' != pszWalk[0])
    {
        // Delete the view
        SHDeleteKey(hkeyRoot, szDeleted);

        // Remove it from the order string
        pszSrc = pszWalk + lstrlen(pszWalk) + 1;
        MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));

        // Save the order string
        WriteOldOrderFormat(hkeyRoot, pszOrder);
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return;
}

void Stage5RulesMigration(VOID)
{
    // Remove CRIT_TYPE_DELETED from views
    RemoveDeletedFromFilters();

    // Migrate the newsgroup filters
    MigrateGroupFilterSettings();

    return;
}

void RemoveRepliesFromFilters(VOID)
{
    CHAR        szDeleted[CCH_INDEX_MAX];
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    HRESULT     hr = S_OK;
    LPSTR       pszOrder = NULL;
    ULONG       cchOrder = 0;
    LPSTR       pszWalk = NULL;
    LPSTR       pszSrc = NULL;

    // Create the DELETED key
    wnsprintf(szDeleted, ARRAYSIZE(szDeleted), "%03X", RULEID_VIEW_REPLIES);

    // Open the filter key
    lErr = AthUserOpenKey(c_szRulesFilter, KEY_ALL_ACCESS, &hkeyRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, &cchOrder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search for RULEID_VIEW_REPLIES
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        if (0 == lstrcmpi(szDeleted, pszWalk))
        {
            break;
        }
    }

    // If we found it, then remove it
    if ('\0' != pszWalk[0])
    {
        // Delete the view
        SHDeleteKey(hkeyRoot, szDeleted);

        // Remove it from the order string
        pszSrc = pszWalk + lstrlen(pszWalk) + 1;
        MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));

        // Save the order string
        WriteOldOrderFormat(hkeyRoot, pszOrder);
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return;
}

void Stage6RulesMigration(VOID)
{
    // Remove RULEID_VIEW_REPLIES from views
    RemoveRepliesFromFilters();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\migrate.h ===
// --------------------------------------------------------------------------------
// MIGRATE.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIGRATE_H
#define __MIGRATE_H

HRESULT MigrateAndUpgrade(void);
void BuildOldCacheFileName(LPCSTR lpszServer, LPCSTR lpszGroup, LPSTR lpszFile);

#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\navpane.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     navpane.h
//
//  PURPOSE:    Defines CNavPane class
//

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Dec's
//
class CTreeView;
interface IMsgrAb;
interface IAthenaBrowser;
class CPaneFrame;


class CNavPane : public IDockingWindow,
                 public IObjectWithSite,
                 public IOleCommandTarget,
                 public IInputObjectSite,
                 public IInputObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CNavPane();
    ~CNavPane();

    HRESULT Initialize(CTreeView *pTreeView);

    BOOL IsTreeVisible() { return m_fTreeVisible; }
    BOOL ShowFolderList(BOOL fShow);
    BOOL ShowContacts(BOOL fShow);
    BOOL IsContactsFocus();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown 
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IOleWindow
    //
    STDMETHODIMP GetWindow(HWND* lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow 
    //
    STDMETHODIMP ShowDW(BOOL fShow);
    STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown*  punkToolbarSite,
                                BOOL fReserved);
    STDMETHODIMP CloseDW(DWORD dwReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite
    //
    STDMETHODIMP GetSite(REFIID riid, LPVOID *ppvSite);
    STDMETHODIMP SetSite(IUnknown   *pUnkSite);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                             OLECMDTEXT *pCmdText);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                      VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // IInputObjectSite
    //
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    /////////////////////////////////////////////////////////////////////////
    // IInputObject
    //
    STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    STDMETHODIMP HasFocusIO(void);
    STDMETHODIMP TranslateAcceleratorIO(LPMSG pMsg);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window Proc Goo
    //
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _NavWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void _OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
    BOOL _OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
    UINT _OnNCHitTest(HWND hwnd, int x, int y);

    /////////////////////////////////////////////////////////////////////////
    // Utility stuff
    //
    HRESULT _CreateChildWindows(void);
    void _UpdateVisibleState(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //

    // All kinds of state
    ULONG               m_cRef;             // Ref count
    BOOL                m_fShow;            // TRUE if we're visible
    BOOL                m_fTreeVisible;     // TRUE if the treeview is visible
    BOOL                m_fContactsVisible; // TRUE if contacts are visible

    // Groovy window handles
    HWND                m_hwnd;             // Our window handle
    HWND                m_hwndParent;       // Our parent's window handle
    HWND                m_hwndTree;         // The folder list window handle
    HWND                m_hwndContacts;     // The contacts control window

    // Interfaces you only wish you could have
    IDockingWindowSite *m_pSite;            // Our site 
    CTreeView          *m_pTreeView;        // Folder list pointer
    IMsgrAb            *m_pContacts;        // Contacts control
    IOleCommandTarget  *m_pContactsTarget;  // Command target for contacts
    CPaneFrame         *m_pContactsFrame;   // Contacts control frame

    // Sizing information
    int                 m_cxWidth;          // How wide our outer window is
    BOOL                m_fResizing;        // TRUE if we're in the process of resizing
    BOOL                m_fSplitting;       // TRUE if we're splitting
    int                 m_cySplitPct;       // Split percentage between the two panes
    RECT                m_rcSplit;          // Rectangle of the split bar in screen coordinates
    RECT                m_rcSizeBorder;     // Rectangle of the right hand sizing bar
    int                 m_cyTitleBar;       // Height of the pane's title bar
};


class CPaneFrame : IInputObjectSite
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CPaneFrame();
    ~CPaneFrame();

    HWND Initialize(HWND hwndParent, IInputObjectSite *pSite, int idsTitle, int idMenu = 0);
    BOOL SetChild(HWND hwndChild, DWORD dwDispId, IAthenaBrowser *pBrowser, IObjectWithSite *pObject,
                  IOleCommandTarget *pTarget = 0);
    void ShowMenu(void);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown 
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IInputObjectSite
    //
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window Proc Goo
    //
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL _OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void _OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _OnPaint(HWND hwnd);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void _OnToggleClosePin(HWND hwnd, BOOL fPin);
    void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void _OnTimer(HWND hwnd, UINT id);

    void _UpdateDrawingInfo(void);

    void _CreateCloseToolbar();
    void _SizeCloseToolbar();
    void _PositionToolbar(LPPOINT pt);

private:
    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //

    ULONG               m_cRef;

    // Groovy Window Handles
    HWND                m_hwnd;
    HWND                m_hwndChild;
    HWND                m_hwndParent;

    // Child info
    IAthenaBrowser     *m_pBrowser;
    DWORD               m_dwDispId;
    IOleCommandTarget  *m_pTarget;
    int                 m_idMenu;
    IInputObjectSite   *m_pSite;

    // Drawing Info
    TCHAR               m_szTitle[CCHMAX_STRINGRES];
    HFONT               m_hFont;
    HBRUSH              m_hbr3DFace;
    UINT                m_cyTitleBar;
    RECT                m_rcChild;
    RECT                m_rcTitleButton;
    BOOL                m_fHighlightIndicator;
    BOOL                m_fHighlightPressed;

    // Toolbar Info
    HWND                m_hwndClose;
    DWORD               m_cButtons;
    BOOL                m_fPin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\navpane.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     navpane.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include "navpane.h"
#include "treeview.h"
#include "baui.h"
#include "browser.h"
#include "menuutil.h"
#include "inpobj.h"

/////////////////////////////////////////////////////////////////////////////
// Local Stuff
//
const TCHAR c_szNavPaneClass[] = _T("Outlook Express Navigation Pane");
const TCHAR c_szPaneFrameClass[] = _T("Outlook Express Pane Frame");

// Sizing consts
const int c_cxBorder     = 1;
const int c_cyBorder     = 1;
const int c_cxTextBorder = 4;
const int c_cyTextBorder = 2;
const int c_cyClose      = 3;
const int c_cySplit      = 4;
const int c_cxSplit      = 3;

#define ID_PANE_CLOSE   2000
#define ID_PANE_PIN     2001
#define ID_PANE_TITLE   2002

#define IDT_PANETIMER   100
#define	ELAPSE_MOUSEOVERCHECK	250

/////////////////////////////////////////////////////////////////////////////
// CNavPane Implementation
//

CNavPane::CNavPane()
{
    m_cRef = 1;
    m_fShow = FALSE;
    m_fTreeVisible = FALSE;
    m_fContactsVisible = FALSE;

    m_hwnd = 0;
    m_hwndParent = 0;
    m_hwndTree = 0;
    m_hwndContacts = 0;

    m_pSite = NULL;
    m_pTreeView = NULL;
    m_pContacts = NULL;
    m_pContactsFrame = NULL;
    m_pContactsTarget = NULL;

    m_cxWidth = 200;
    m_fResizing = FALSE;
    m_fSplitting = FALSE;
    m_cySplitPct = 50;
    ZeroMemory(&m_rcSplit, sizeof(RECT));
    ZeroMemory(&m_rcSizeBorder, sizeof(RECT));

    m_cyTitleBar = 32;
}

CNavPane::~CNavPane()
{
    SafeRelease(m_pContactsFrame);
}


HRESULT CNavPane::Initialize(CTreeView *pTreeView)
{
    // We've got to have this
    if (!pTreeView)
        return (E_INVALIDARG);

    // Keep it
    m_pTreeView = pTreeView;
    m_pTreeView->AddRef();

    // Load some settings
    m_cxWidth = DwGetOption(OPT_NAVPANEWIDTH);
    if (m_cxWidth < 0)
        m_cxWidth = 200;

    m_cySplitPct = DwGetOption(OPT_NAVPANESPLIT);

    // Do some parameter checking
    if (m_cySplitPct > 100 || m_cySplitPct < 2)
        m_cySplitPct = 66;

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CNavPane::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CNavPane::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IDockingWindow *) this;
    else if (IsEqualIID(riid, IID_IDockingWindow))
        *ppvObj = (LPVOID) (IDockingWindow *) this;
    else if (IsEqualIID(riid, IID_IObjectWithSite))
        *ppvObj = (LPVOID) (IObjectWithSite *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IInputObject))
        *ppvObj = (LPVOID) (IInputObject *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CNavPane::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CNavPane::AddRef(void)
{
    TraceCall("CNavPane::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CNavPane::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CNavPane::Release(void)
{
    TraceCall("CNavPane::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   CNavPane::GetWindow()
//
//  PURPOSE:    Returns the handle of our outer window
//
//  PARAMETERS: 
//      [out] pHwnd - return value
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::GetWindow(HWND *pHwnd)
{
    TraceCall("CNavPane::GetWindow");

    if (!pHwnd)
        return (E_INVALIDARG);

    if (IsWindow(m_hwnd))
    {
        *pHwnd = m_hwnd;
        return (S_OK);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CNavPane::ContextSensitiveHelp()
//
//  PURPOSE:    Does anyone _ever_ implement this?
//
HRESULT CNavPane::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CNavPane::ContextSensitiveHelp");
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNavPane::ShowDW()
//
//  PURPOSE:    Show's or hides the Nav pane.  If the pane has not yet been
//              created it does that too.
//
//  PARAMETERS: 
//      [in] fShow - TRUE to show, FALSE to hide
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::ShowDW(BOOL fShow)
{
    HRESULT     hr;
    WNDCLASSEX  wc;

    TraceCall("CNavPane::ShowDW");

    // Nothing works without a site pointer
    if (!m_pSite)
        return (E_UNEXPECTED);

    // Check to see if we've been created yet
    if (!m_hwnd)
    {
        // Register the window class if necessary
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, c_szNavPaneClass, &wc))
        {
            wc.style            = 0;
            wc.lpfnWndProc      = _WndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            wc.hCursor          = LoadCursor(0, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = c_szNavPaneClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;

            RegisterClassEx(&wc);
        }

        // Get the parent window before we create ours
        if (FAILED(m_pSite->GetWindow(&m_hwndParent)))
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to get a parent window handle.");
        }

        // Create the window
        m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szNavPaneClass, NULL, 
                                WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                0, 0, 10, 10, m_hwndParent, (HMENU) 0, g_hInst, this);
        if (!m_hwnd)
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to create main window.");
            return (E_OUTOFMEMORY);
        }

        // Create any children
        if (FAILED(hr = _CreateChildWindows()))
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to create child windows.");
            DestroyWindow(m_hwnd);
            return (hr);
        }
    }

    // Show or hide the window appropriately
    m_fShow = (fShow && (m_fTreeVisible || m_fContactsVisible));
    ResizeBorderDW(0, 0, FALSE);
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::ResizeBorderDW()
//
//  PURPOSE:    Called when it's time for us to re-request space from our 
//              parent.
//
//  PARAMETERS: 
//      [in] prcBorder - a RECT containing the outer rectangle the object can request space in
//      [in] punkSite  - pointer to the site that changed
//      [in] fReserved - unused.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkSite, BOOL fReserved)
{
    const DWORD c_cxResizeBorder = 3;
    HRESULT     hr = S_OK;
    RECT        rcRequest = { 0 };
    RECT        rcBorder;

    TraceCall("CNavPane::ResizeBorderDW");

    // If we don't have a site pointer, this ain't gonna work
    if (!m_pSite)
        return (E_UNEXPECTED);

    // If we visible, then calculate our border requirements.  If we're not 
    // visible, the our requirements are zero and we can use the default
    // values in rcRequest.
    Assert(IsWindow(m_hwnd));

    // If the caller didn't provide us with a rect, get one ourselves
    if (!prcBorder)
    {
        m_pSite->GetBorderDW((IDockingWindow *) this, &rcBorder);
        prcBorder = &rcBorder;
    }

    // The space we need is the min of either what we want to be or the
    // width of the parent minus some
    if (m_fShow)
    {
        rcRequest.left = min(prcBorder->right - prcBorder->left - 32, m_cxWidth);
    }

    // Ask for the space we need
    if (SUCCEEDED(m_pSite->RequestBorderSpaceDW((IDockingWindow *) this, &rcRequest)))
    {
        // Tell the site how be we're going to be
        if (SUCCEEDED(m_pSite->SetBorderSpaceDW((IDockingWindow *) this, &rcRequest)))
        {
            // Now once that's all done, resize ourselves if we're visible
            if (m_fShow)
            {
                SetWindowPos(m_hwnd, 0, prcBorder->left, prcBorder->top, rcRequest.left,
                             prcBorder->bottom - prcBorder->top, SWP_NOZORDER | SWP_NOACTIVATE);
            }
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::CloseDW()
//
//  PURPOSE:    Called when the parent want's to destroy this window
//
//  PARAMETERS: 
//      [in] dwReserved - unused
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::CloseDW(DWORD dwReserved)
{
    TraceCall("CNavPane::CloseDW");

    // Save our settings
    SetDwOption(OPT_NAVPANEWIDTH, m_cxWidth, NULL, 0);
    SetDwOption(OPT_NAVPANESPLIT, m_cySplitPct, NULL, 0);

    if (m_pTreeView)
        m_pTreeView->DeInit();

    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // Destroy our children here
    SafeRelease(m_pTreeView);
    SafeRelease(m_pContactsTarget);
    SafeRelease(m_pContacts);

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::GetSite()
//
//  PURPOSE:    Called to request an interface to our site
//
//  PARAMETERS: 
//      [in]  riid - Requested interface
//      [out] ppvSite - Returned interface if available
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::GetSite(REFIID riid, LPVOID *ppvSite)
{
    HRESULT hr;

    TraceCall("CNavPane::GetSite");

    if (m_pSite)
    {
        // Ask our site for the requested interface
        hr = m_pSite->QueryInterface(riid, ppvSite);
        return (hr);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CNavPane::SetSite()
//
//  PURPOSE:    Called to tell us who our site will be.
//
//  PARAMETERS: 
//      [in] pUnkSite - Pointer to the new site
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::SetSite(IUnknown *pUnkSite)
{
    HRESULT hr = S_OK;

    TraceCall("CNavPane::SetSite");

    // If we already have a site, release it
    if (m_pSite)
    {
        m_pSite->Release();
        m_pSite = 0;
    }

    // If we were given a new site, keep it
    if (pUnkSite)
    {
        hr = pUnkSite->QueryInterface(IID_IDockingWindowSite, (LPVOID *) &m_pSite);
        return (hr);
    }

    return (hr);
}


//
//  FUNCTION:   CNavPane::_WndProc()
//
//  PURPOSE:    External callback.
//
LRESULT CALLBACK CNavPane::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNavPane *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (CNavPane *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
        pThis = (CNavPane *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (pThis)
        return (pThis->_NavWndProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}


//
//  FUNCTION:   CNavPane::_NavWndProc()
//
//  PURPOSE:    Left as an exercise for the reader
//
LRESULT CALLBACK CNavPane::_NavWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_SETCURSOR,   _OnSetCursor);
        HANDLE_MSG(hwnd, WM_SIZE,        _OnSize);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   _OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, _OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,   _OnLButtonUp);
        
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        {
            // Forward these to all our children
            if (IsWindow(m_hwndTree))
                SendMessage(m_hwndTree, uMsg, wParam, lParam);
            if (IsWindow(m_hwndContacts))
                SendMessage(m_hwndContacts, uMsg, wParam, lParam);

            // Update any of our own sizes
            m_cyTitleBar =(UINT) SendMessage(m_hwndTree, WM_GET_TITLE_BAR_HEIGHT, 0, 0);
            return (0);
        }

    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CNavPane::_OnSize()
//
//  PURPOSE:    When our window get's resized, we need to resize our child 
//              windows too.
//
void CNavPane::_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    RECT rc;
    DWORD cyTree;
    DWORD cySplit = c_cySplit;
    
    TraceCall("CNavPane::_OnSize");

    // If only the tree is visible
    if (m_fTreeVisible && !m_fContactsVisible)
        cyTree = cy;
    else if (m_fTreeVisible && m_fContactsVisible)
        cyTree = (cy * m_cySplitPct) / 100;
    else if (!m_fTreeVisible && m_fContactsVisible)
    {
        cyTree = 0;
        cySplit = 0;
    }

    // Resize the TreeView to fit inside our window
    if (m_hwndTree)
        SetWindowPos(m_hwndTree, 0, 0, 0, cx - c_cxSplit, cyTree, SWP_NOZORDER | SWP_NOACTIVATE);
    if (m_hwndContacts)
    SetWindowPos(m_hwndContacts, 0, 0, cyTree + cySplit, cx - 3, cy - cyTree - cySplit, SWP_NOZORDER | SWP_NOACTIVATE);

    // Figure out where a few things are, starting with the split bar
    SetRect(&rc, c_cxBorder, cyTree, cx - c_cxSplit - c_cxBorder, cyTree + cySplit);
    m_rcSplit = rc;

    // Figure out where the right side is
    SetRect(&rc, cx - c_cxSplit, 0, cx, cy);
    m_rcSizeBorder = rc;
}


//
//  FUNCTION:   CNavPane::_OnLButtonDown()
//
//  PURPOSE:    When the user clicks down and we get this notification, it 
//              must be because they want to resize.
//
void CNavPane::_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    TraceCall("CNavPane::_OnLButtonDown");

    if (!m_fResizing)
    {
        SetCapture(hwnd);
        m_fResizing = TRUE;

        POINT pt = {x, y};
        if (PtInRect(&m_rcSplit, pt))
        {
            m_fSplitting = TRUE;
        }
    }
}


//
//  FUNCTION:   CNavPane::_OnMouseMove()
//
//  PURPOSE:    If we're resizing, update our position etc.
//
void CNavPane::_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    RECT  rcClient;

    TraceCall("CNavPane::_OnMouseMove");

    if (m_fResizing)
    {
        if (m_fSplitting)
        {
            GetClientRect(m_hwnd, &rcClient);
            m_cySplitPct = (int)(((float) pt.y / (float) rcClient.bottom) * 100);

            // Make sure we have the min's and max's right
            int cy = (rcClient.bottom * m_cySplitPct) / 100;
            if (cy < m_cyTitleBar)
            {
                m_cySplitPct = (int)(((float) m_cyTitleBar / (float) rcClient.bottom) * 100);
            }
            else if (rcClient.bottom - cy < m_cyTitleBar)
            {
                m_cySplitPct = (int)(((float) (rcClient.bottom - m_cyTitleBar) / (float) rcClient.bottom) * 100);
            }

            _OnSize(hwnd, 0, rcClient.right, rcClient.bottom);          
        }
        else
        {
            if (pt.x > 32)
            {
                GetClientRect(m_hwndParent, &rcClient);
                m_cxWidth = max(0, min(pt.x, rcClient.right - 32));
                ResizeBorderDW(0, 0, FALSE);
            }
        }
    }
}


//
//  FUNCTION:   CNavPane::_OnLButtonUp()
//
//  PURPOSE:    If the user was resizing, then they're done now and we can
//              clean up.
//
void CNavPane::_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    TraceCall("CNavPane::_OnLButtonUp");

    if (m_fResizing)
    {
        ReleaseCapture();
        m_fResizing = FALSE;
        m_fSplitting = FALSE;
    }
}


//
//  FUNCTION:   CNavPane::_OnSetCursor()
//
//  PURPOSE:    Do some jimmying with the cursor
//
BOOL CNavPane::_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    POINT pt;

    TraceCall("_OnSetCursor");

    // Get the cursor position
    GetCursorPos(&pt);
    ScreenToClient(m_hwnd, &pt);
    
    // If the cursor is within the split bar, update the cursor
    if (PtInRect(&m_rcSplit, pt))
    {
        SetCursor(LoadCursor(NULL, IDC_SIZENS));
        return (TRUE);
    }

    if (PtInRect(&m_rcSizeBorder, pt))
    {
        SetCursor(LoadCursor(NULL, IDC_SIZEWE));
        return (TRUE);
    }

    return (FALSE);
}


//
//  FUNCTION:   CNavPane::_OnNCHitTest()
//
//  PURPOSE:    We monkey around with the non client area to get the correct 
//              cursors
//
//  PARAMETERS: 
//      [in] hwnd - Window handle the mouse is in
//      [in] x, y - Position of the mouse in screen coordinates
//
//  RETURN VALUE:
//      Our personal opinion of where the mouse is.
//
UINT CNavPane::_OnNCHitTest(HWND hwnd, int x, int y)
{
    POINT pt = {x, y};

    // If the cursor is in the split bar
    if (PtInRect(&m_rcSplit, pt))
        return (HTTOP);

    if (PtInRect(&m_rcSizeBorder, pt))
        return (HTRIGHT);

    return (HTCLIENT);
}


//
//  FUNCTION:   CNavPane::_CreateChildWindows()
//
//  PURPOSE:    Creates the child windows that will be displayed.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::_CreateChildWindows(void)
{
    IOleWindow   *pWindow = NULL;
    IInputObject *pInputObj = NULL;
    HRESULT       hr;

    TraceCall("CNavPane::_CreateChildWindows");

    // The treeview is always created by the browser.  All we have to do
    // is tell it to create it's UI.
    m_hwndTree = m_pTreeView->Create(m_hwnd, (IInputObjectSite *) this, TRUE);
    Assert(m_hwndTree);

    // If the tree is supposed to be visible, show it
    if (DwGetOption(OPT_SHOWTREE))
    {
        ShowWindow(m_hwndTree, SW_SHOW);
        m_fTreeVisible = TRUE;
        m_cyTitleBar = (UINT) SendMessage(m_hwndTree, WM_GET_TITLE_BAR_HEIGHT, 0, 0);
    }

    // If we're showing contacts, create it
    if (DwGetOption(OPT_SHOWCONTACTS) && (!(g_dwAthenaMode & MODE_OUTLOOKNEWS)))
    {
        ShowContacts(TRUE);
    }

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::ShowFolderList()
//
//  PURPOSE:    Shows and hides the folder list doodad
//
//  PARAMETERS: 
//      BOOL fShow
//
BOOL CNavPane::ShowFolderList(BOOL fShow)
{
    TraceCall("CNavPane::ShowFolderList");

    // The folder list _always_ exists.  We just toggle the state
    ShowWindow(m_hwndTree, fShow ? SW_SHOW : SW_HIDE);
    m_fTreeVisible = fShow;
    _UpdateVisibleState();

    RECT rc;
    GetClientRect(m_hwnd, &rc);
    _OnSize(m_hwnd, 0, rc.right, rc.bottom);

    return (TRUE);
}


//
//  FUNCTION:   CNavPane::ShowContacts()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      BOOL fShow
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CNavPane::ShowContacts(BOOL fShow)
{
    CMsgrAb        *pMsgrAb;
    HWND            hwnd;
    IAthenaBrowser *pBrowser;
    HRESULT         hr;
    RECT            rc = {0};

    if (!m_pContacts)
    {
        hr = CreateMsgrAbCtrl(&m_pContacts);
        if (SUCCEEDED(hr))
        {
            // Initialize the control
            m_pContactsFrame = new CPaneFrame();
            if (!m_pContactsFrame)
                return (0);
            m_hwndContacts = m_pContactsFrame->Initialize(m_hwnd, this, idsABBandTitle, IDR_BA_TITLE_POPUP);

            pMsgrAb = (CMsgrAb *) m_pContacts;
            hwnd = pMsgrAb->CreateControlWindow(m_hwndContacts, rc);
            if (hwnd)
            {
                if (SUCCEEDED(m_pSite->QueryInterface(IID_IAthenaBrowser, (LPVOID *) &pBrowser)))
                {
                    m_pContactsFrame->SetChild(hwnd, DISPID_MSGVIEW_CONTACTS, pBrowser, pMsgrAb, pMsgrAb);
                    pBrowser->Release();
                }
            }

            // Get the command target
            m_pContacts->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pContactsTarget);
        }
    }

    SetWindowPos(m_hwndContacts, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    ShowWindow(m_hwndContacts, fShow ? SW_SHOW : SW_HIDE);
    m_fContactsVisible = fShow;
    _UpdateVisibleState();

    GetClientRect(m_hwnd, &rc);
    _OnSize(m_hwnd, 0, rc.right, rc.bottom);

    return (TRUE);
}


//
//  FUNCTION:   CNavPane::_UpdateVisibleState()
//
//  PURPOSE:    Checks to see if we need to show our hide ourselves
//
void CNavPane::_UpdateVisibleState(void)
{
    // If this leaves us with nothing visible, then we hide ourselves
    if (!m_fTreeVisible && !m_fContactsVisible)
    {
        ShowWindow(m_hwnd, SW_HIDE);
        m_fShow = FALSE;
        ResizeBorderDW(0, 0, 0);
    }
    else if (m_fShow == FALSE && (m_fTreeVisible || m_fContactsVisible))
    {
        // Show ourselves
        m_fShow = TRUE;
        ShowWindow(m_hwnd, SW_SHOW);
        ResizeBorderDW(0, 0, 0);
    }
}


HRESULT CNavPane::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText) 
{

    if (m_pContactsTarget)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            if (prgCmds[i].cmdf == 0 && prgCmds[i].cmdID == ID_CONTACTS_MNEMONIC)
            {
                prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
            }
        }
    }

    if (m_pContactsTarget)
        return (m_pContactsTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText));

    return (S_OK);
}


HRESULT CNavPane::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    if (m_pContactsTarget && nCmdID == ID_CONTACTS_MNEMONIC)
    {
        m_pContactsFrame->ShowMenu();
        return (S_OK);
    }

    if (m_pContactsTarget)
        return (m_pContactsTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut));

    return (OLECMDERR_E_NOTSUPPORTED);
}

BOOL CNavPane::IsContactsFocus(void)
{
    IInputObject *pInputObject = 0;
    HRESULT       hr = S_FALSE;

    if (m_pContacts)
    {
        if (SUCCEEDED(m_pContacts->QueryInterface(IID_IInputObject, (LPVOID *) &pInputObject)))
        {
            hr = pInputObject->HasFocusIO();
            pInputObject->Release();
            return (S_OK == hr);
        }
    }

    return (S_OK == hr);
}

HRESULT CNavPane::OnFocusChangeIS(IUnknown *punkSrc, BOOL fSetFocus)
{
    // Simply call through to our host
    UnkOnFocusChangeIS(m_pSite, (IInputObject*) this, fSetFocus);
    return (S_OK);
}

HRESULT CNavPane::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (fActivate)
    {
        UnkOnFocusChangeIS(m_pSite, (IInputObject *) this, TRUE);
        SetFocus(m_hwnd);
    }

    return (S_OK);
}

HRESULT CNavPane::HasFocusIO(void)
{
    if (m_hwnd == 0)
       return (S_FALSE);

    HWND hwndFocus = GetFocus();
    return (hwndFocus == m_hwnd || IsChild(m_hwnd, hwndFocus)) ? S_OK : S_FALSE;
}    
    
HRESULT CNavPane::TranslateAcceleratorIO(LPMSG pMsg)
{
    if (m_pTreeView && (m_pTreeView->HasFocusIO() == S_OK))
        return m_pTreeView->TranslateAcceleratorIO(pMsg);

    if (m_pContacts && (UnkHasFocusIO(m_pContacts) == S_OK))
        return UnkTranslateAcceleratorIO(m_pContacts, pMsg);

    return (S_FALSE);
}    

/////////////////////////////////////////////////////////////////////////////
// CPaneFrame
//

CPaneFrame::CPaneFrame()
{
    m_cRef = 1;

    m_hwnd = 0;
    m_hwndChild = 0;
    m_hwndParent = 0;

    m_szTitle[0] = 0;
    m_hFont = 0;
    m_hbr3DFace = 0;
    m_cyTitleBar = 0;
    m_fHighlightIndicator = FALSE;
    m_fHighlightPressed = FALSE;
    ZeroMemory(&m_rcTitleButton, sizeof(RECT));

    m_hwndClose = 0;
    m_cButtons = 1;

    m_pBrowser = NULL;
    m_dwDispId = 0;
    m_pTarget = 0;
    m_idMenu = 0;

    m_fPin = FALSE;
}

CPaneFrame::~CPaneFrame()
{
    if (m_hFont != 0)
        DeleteObject(m_hFont);
    if (m_hbr3DFace != 0)
        DeleteObject(m_hbr3DFace);
}


//
//  FUNCTION:   CPaneFrame::Initialize()
//
//  PURPOSE:    Initializes the frame by telling the pane what it's title 
//              should be.
//
//  PARAMETERS: 
//      [in] hwndParent
//      [in] idsTitle
//
//  RETURN VALUE:
//      HWND 
//
HWND CPaneFrame::Initialize(HWND hwndParent, IInputObjectSite *pSite, int idsTitle, int idMenu)
{
    WNDCLASSEX wc;

    TraceCall("CPaneFrame::Initialize");

    // This should be NULL
    Assert(NULL == m_hwnd);
    
    // Save this for later
    m_hwndParent = hwndParent;
    m_idMenu = idMenu;
    m_pSite = pSite;

    // Load the title
    AthLoadString(idsTitle, m_szTitle, ARRAYSIZE(m_szTitle));

    // Register the window class if necessary
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szPaneFrameClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = _WndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = LoadCursor(0, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szPaneFrameClass;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    // Create the window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szPaneFrameClass, m_szTitle, 
                            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            0, 0, 0, 0, hwndParent, 0, g_hInst, this);
    if (!m_hwnd)
    {
        AssertSz(m_hwnd, "CPaneFrame::Initialize() - Failed to create a frame");
        return (0);
    }

    return (m_hwnd);
}


//
//  FUNCTION:   CPaneFrame::SetChild()
//
//  PURPOSE:    Allows the owner to tell us what the child window handle is.
//
BOOL CPaneFrame::SetChild(HWND hwndChild, DWORD dwDispId, IAthenaBrowser *pBrowser, 
                          IObjectWithSite *pObject, IOleCommandTarget *pTarget)
{
    TraceCall("CPaneFrame::SetChild");

    if (IsWindow(hwndChild))
    {
        m_hwndChild = hwndChild;

        if (pBrowser)
        {
            m_pBrowser = pBrowser;
            m_dwDispId = dwDispId;
        }

        if (pObject)
        {
            pObject->SetSite((IInputObjectSite *) this);
        }

        if (pTarget)
        {
            m_pTarget = pTarget;
        }

        return (TRUE);
    }

    return (FALSE);
}


void CPaneFrame::ShowMenu(void)
{
    if (m_idMenu)
    {
        _OnLButtonDown(m_hwnd, 0, m_rcTitleButton.left, m_rcTitleButton.top, 0);
    }
}

//
//  FUNCTION:   CPaneFrame::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CPaneFrame::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CPaneFrame::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CPaneFrame::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CPaneFrame::AddRef(void)
{
    TraceCall("CPaneFrame::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CPaneFrame::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CPaneFrame::Release(void)
{
    TraceCall("CPaneFrame::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


HRESULT CPaneFrame::OnFocusChangeIS(IUnknown *punkSrc, BOOL fSetFocus)
{
    // Simply call through to our host
    UnkOnFocusChangeIS(m_pSite, (IInputObject*) this, fSetFocus);
    return (S_OK);
}


//
//  FUNCTION:   CPaneFrame::_WndProc()
//
//  PURPOSE:    External callback.
//
LRESULT CALLBACK CPaneFrame::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPaneFrame *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (CPaneFrame *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
        pThis = (CPaneFrame *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (pThis)
        return (pThis->_FrameWndProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}


//
//  FUNCTION:   CPaneFrame::_FrameWndProc()
//
//  PURPOSE:    Left as an exercise for the reader
//
LRESULT CALLBACK CPaneFrame::_FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,      _OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,        _OnSize);
        HANDLE_MSG(hwnd, WM_PAINT,       _OnPaint);
        HANDLE_MSG(hwnd, WM_COMMAND,     _OnCommand);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   _OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, _OnLButtonDown);
        HANDLE_MSG(hwnd, WM_TIMER,       _OnTimer);

        case WM_TOGGLE_CLOSE_PIN:
            _OnToggleClosePin(hwnd, (BOOL) lParam);
            return (0);

        case WM_GET_TITLE_BAR_HEIGHT:
            return (m_cyTitleBar + (c_cyBorder * 2) + 1);

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        {
            // Forward these to all our children
            if (IsWindow(m_hwndChild))
                SendMessage(m_hwndChild, uMsg, wParam, lParam);
            _UpdateDrawingInfo();
            break;
        }

        case WM_SETFOCUS:
        {
            if (m_hwndChild && ((HWND)wParam) != m_hwndChild)
                SetFocus(m_hwndChild);
            break;
        }            
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CPaneFrame::_OnCreate()
//
//  PURPOSE:    Loads some info that will be handy later
//
BOOL CPaneFrame::_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    TraceCall("CPaneFrame::_OnCreate");

    m_hwnd = hwnd;

    _UpdateDrawingInfo();
    _CreateCloseToolbar();

    return (TRUE);
}


//
//  FUNCTION:   CPaneFrame::_OnSize()
//
//  PURPOSE:    Resizes our child to fit in the right place
//
void CPaneFrame::_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    TraceCall("CPaneFrame::_OnSize");

    m_rcChild.left = c_cyBorder;
    m_rcChild.top = m_cyTitleBar;
    m_rcChild.right = cx - (2 * c_cyBorder);
    m_rcChild.bottom = cy - m_cyTitleBar - c_cyBorder;

    if (m_hwndChild)
        SetWindowPos(m_hwndChild, 0, m_rcChild.left, m_rcChild.top, m_rcChild.right, 
                     m_rcChild.bottom, SWP_NOZORDER | SWP_NOACTIVATE);

    POINT pt = {cx, cy};
    _PositionToolbar(&pt);

    // Invalidate the title area
    RECT rc = m_rcChild;
    rc.top = 0;
    rc.bottom = m_rcChild.top;
    InvalidateRect(m_hwnd, &rc, FALSE);

    rc.left = 0;
    rc.right = c_cyBorder;
    rc.bottom = cy;
    InvalidateRect(m_hwnd, &rc, FALSE);

    rc.left = cx - c_cyBorder;
    rc.right = cx;
    InvalidateRect(m_hwnd, &rc, FALSE);
}


//
//  FUNCTION:   CPaneFrame::_OnPaint()
//
//  PURPOSE:    Called when it's time to paint our borders and title area.
//
void CPaneFrame::_OnPaint(HWND hwnd)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    POINT       pt[3];
    HBRUSH      hBrush,
                hBrushOld;
    HPEN        hPen,
                hPenOld;

    // Get our window size
    GetClientRect(m_hwnd, &rcClient);
    rc = rcClient;

    // Start painting
    hdc = BeginPaint(hwnd, &ps);

    // Draw a simple edge around or window
    DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_TOPRIGHT | BF_BOTTOMLEFT);

    // Now draw a raised edge around our title bar area
    InflateRect(&rc, -1, -1);
    rc.bottom = m_cyTitleBar;
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);

    // Paint the background
    InflateRect(&rc, -c_cxBorder, -c_cyBorder);
    FillRect(hdc, &rc, m_hbr3DFace);

    // Now draw some groovy text
    SelectFont(hdc, m_hFont);
    SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

    // Draw the text
    InflateRect(&rc, -c_cxTextBorder, -c_cyTextBorder);

    if (!m_fPin)
    {
        DrawText(hdc, m_szTitle, -1, &rc, DT_CALCRECT | DT_VCENTER | DT_LEFT);
        DrawText(hdc, m_szTitle, -1, &rc, DT_VCENTER | DT_LEFT);
    }
    else
    {
        TCHAR sz[CCHMAX_STRINGRES];
        AthLoadString(idsPushPinInfo, sz, ARRAYSIZE(sz));
        IDrawText(hdc, sz, &rc, DT_VCENTER | DT_END_ELLIPSIS | DT_LEFT, 
                  rc.bottom - rc.top);
        DrawText(hdc, sz, -1, &rc, DT_CALCRECT | DT_VCENTER | DT_END_ELLIPSIS | DT_LEFT);
    }

    // Drop-down indicator
    if (m_idMenu)
    {
        COLORREF    crFG = GetSysColor(COLOR_WINDOWTEXT);

        pt[0].x = rc.right + 6;
        pt[0].y = (m_cyTitleBar - 6) / 2 + 2;
        pt[1].x = pt[0].x + 6;
        pt[1].y = pt[0].y;
        pt[2].x = pt[0].x + 3;
        pt[2].y = pt[0].y + 3;

        hPen = CreatePen(PS_SOLID, 1, crFG);
        hBrush = CreateSolidBrush(crFG);
        hPenOld = SelectPen(hdc, hPen);
        hBrushOld = SelectBrush(hdc, hBrush);
        Polygon(hdc, pt, 3);
        SelectPen(hdc, hPenOld);
        SelectBrush(hdc, hBrushOld);
        DeleteObject(hPen);
        DeleteObject(hBrush);

        if (m_fHighlightIndicator)
        {
            rc = m_rcTitleButton;
            DrawEdge(hdc, &rc, m_fHighlightPressed ? BDR_SUNKENOUTER : BDR_RAISEDINNER, 
                     BF_TOPRIGHT | BF_BOTTOMLEFT);
        }
    }

    EndPaint(hwnd, &ps);    
}


//
//  FUNCTION:   _OnCommand()
//
//  PURPOSE:    We get the occasional command now and again
//
void CPaneFrame::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case ID_PANE_CLOSE:
        {
            if (m_pBrowser)
                m_pBrowser->SetViewLayout(m_dwDispId, LAYOUT_POS_NA, FALSE, 0, 0);
            return;
        }

        case ID_PANE_PIN:
        {
            SendMessage(m_hwndChild, WMR_CLICKOUTSIDE, CLK_OUT_DEACTIVATE, 0);
            if (m_pBrowser)
                m_pBrowser->SetViewLayout(m_dwDispId, LAYOUT_POS_NA, TRUE, 0, 0);
            return;
        }
    }

    return;
}

//
//  FUNCTION:   CPaneFrame::_OnToggleClosePin()
//
//  PURPOSE:    Sent to the frame when we should change the close button
//              to a pin button.
//
//  PARAMETERS: 
//      [in] fPin - TRUE to turn the Pin on, FALSE to turn it off.
//
void CPaneFrame::_OnToggleClosePin(HWND hwnd, BOOL fPin)
{
    TraceCall("CPaneFrame::_OnToggleClosePin");

    if (fPin)
    {
        static const TBBUTTON tb[] = 
        {
            { 2, ID_PANE_PIN, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_DELETEBUTTON, 0, 0);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETHOTITEM, (WPARAM) -1, 0);

        m_fPin = TRUE;
    }
    else
    {
        static const TBBUTTON tb[] = 
        {
            { 1, ID_PANE_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_DELETEBUTTON, 0, 0);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETHOTITEM, (WPARAM) -1, 0);

        m_fPin = FALSE;
    }
}


//
//  FUNCTION:   CPaneFrame::_UpdateDrawingInfo()
//
//  PURPOSE:    When we get created or when the user changes their settings, 
//              we need to reload our fonts, colors, and sizes.
//
void CPaneFrame::_UpdateDrawingInfo(void)
{
    LOGFONT     lf;
    TEXTMETRIC  tm;
    HDC         hdc;

    TraceCall("CPaneFrame::_UpdateDrawingInfo");

    if (m_hFont)
        DeleteObject(m_hFont);

    // Figure out which font to use
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

    // Create the font
    m_hFont = CreateFontIndirect(&lf);

    // Get the metrics of this font
    hdc = GetDC(m_hwnd);
    SelectFont(hdc, m_hFont);
    GetTextMetrics(hdc, &tm);

    // Calculate the height
    m_cyTitleBar = tm.tmHeight + (2 * c_cyBorder) + (2 * c_cyTextBorder);

    RECT rc = {2 * c_cxBorder, 2 * c_cyBorder, 0, m_cyTitleBar - c_cyBorder};
    SIZE s;
    GetTextExtentPoint32(hdc, m_szTitle, lstrlen(m_szTitle), &s);
    m_rcTitleButton = rc;
    m_rcTitleButton.right = 14 + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);

    ReleaseDC(m_hwnd, hdc);

    // Get the brush we need
    if (m_hbr3DFace)
        DeleteObject(m_hbr3DFace);
    m_hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
}


//
//  FUNCTION:   CPaneFrame::_CreateCloseToolbar()
//
//  PURPOSE:    Creates the toolbar that has our close button
//
void CPaneFrame::_CreateCloseToolbar()
{
    CHAR szTitle[255];

    TraceCall("CPaneFrame::_CreateCloseToolbar");

    AthLoadString(idsHideFolders, szTitle, ARRAYSIZE(szTitle));

    m_hwndClose = CreateWindowEx(0, TOOLBARCLASSNAME, szTitle, 
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT | TBSTYLE_CUSTOMERASE |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY |
                                 CCS_NOPARENTALIGN | CCS_NORESIZE,
                                 0, c_cyClose, 30, 15, m_hwnd, 0, g_hInst, NULL);
    if (m_hwndClose)
    {
        static const TBBUTTON tb[] = 
        {
            { 1, ID_PANE_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(m_hwndClose, TB_SETBITMAPSIZE, 0, (LPARAM) MAKELONG(11, 9));
        
        TBADDBITMAP tbab = { g_hLocRes, idbClosePin };
        SendMessage(m_hwndClose, TB_ADDBITMAP, 4, (LPARAM) &tbab);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETINDENT, 0, 0);

        _SizeCloseToolbar();
    }
}


//
//  FUNCTION:   CPaneFrame::_SizeCloseToolbar()
//
//  PURPOSE:    Set's the size of the toolbar appropriately.
//
void CPaneFrame::_SizeCloseToolbar(void)
{
    TraceCall("CPaneFrame::_SizeCloseToolbar");

    RECT rc;
    LONG lButtonSize;

    GetWindowRect(m_hwndClose, &rc);
    lButtonSize = (LONG) SendMessage(m_hwndClose, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(m_hwndClose, NULL, 0, 0, LOWORD(lButtonSize) * m_cButtons,
                 rc.bottom - rc.top, SWP_NOMOVE | SWP_NOACTIVATE);

    _PositionToolbar(NULL);
}



//
//  FUNCTION:   CPaneFrame::_PositionToolbar()
//
//  PURPOSE:    Does the work of correctly positioning the close button
//              toolbar.
//
//  PARAMETERS: 
//      LPPOINT ppt
//
void CPaneFrame::_PositionToolbar(LPPOINT ppt)
{
    TraceCall("CPaneFrame::_PositionToolbar");

    if (m_hwndClose)
    {
        RECT rc;
        GetClientRect(m_hwnd, &rc);

        if (ppt)
        {
            rc.left = 0;
            rc.right = ppt->x;
        }

        RECT rcTB;
        GetWindowRect(m_hwndClose, &rcTB);
        rc.left = rc.right - (rcTB.right - rcTB.left) - 3;

        DWORD top = max((int) ((m_cyTitleBar - (rcTB.bottom - rcTB.top)) / 2) + 1, 0);

        SetWindowPos(m_hwndClose, HWND_TOP, rc.left, top, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }
}

void CPaneFrame::_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    UINT  id;

    if (m_idMenu && PtInRect(&m_rcTitleButton, pt))
    {
        m_fHighlightPressed = TRUE;
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
        UpdateWindow(m_hwnd);

        HMENU hMenu = LoadPopupMenu(m_idMenu);
        MenuUtil_EnablePopupMenu(hMenu, m_pTarget);

        if (m_idMenu == IDR_BA_TITLE_POPUP && ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE)))
        {
            DeleteMenu(hMenu, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
            DeleteMenu(hMenu, SEP_MESSENGER, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SORT_BY_NAME, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SORT_BY_STATUS, MF_BYCOMMAND);
        }

        pt.x = m_rcTitleButton.left;
        pt.y = m_rcTitleButton.bottom;

        ClientToScreen(m_hwnd, &pt);
        id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, m_hwnd, NULL);
        if (id)
        {
            m_pTarget->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        m_fHighlightPressed = m_fHighlightIndicator = FALSE;
        KillTimer(m_hwnd, IDT_PANETIMER);
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
        UpdateWindow(m_hwnd);

        if(hMenu)
        {
            //Bug #101329 - (erici) Destroy leaked MENU.
            BOOL bMenuDestroyed = DestroyMenu(hMenu);
            Assert(bMenuDestroyed);
        }
    }
}


void CPaneFrame::_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};

    if (m_idMenu && (m_fHighlightIndicator != PtInRect(&m_rcTitleButton, pt)))
    {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);

        if (m_fHighlightIndicator)
            SetTimer(m_hwnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hwnd, IDT_PANETIMER);
    }       
}

void CPaneFrame::_OnTimer(HWND hwnd, UINT id)
{
    RECT rcClient;
    POINT pt;
    DWORD dw;

    dw = GetMessagePos();
    pt.x = LOWORD(dw);
    pt.y = HIWORD(dw);
    ScreenToClient(m_hwnd, &pt);

    if (id == IDT_PANETIMER)
    {
        GetClientRect(m_hwnd, &rcClient);

        // No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!PtInRect(&rcClient, pt) && !m_fHighlightPressed)
		{
			KillTimer(m_hwnd, IDT_PANETIMER);
			m_fHighlightIndicator = FALSE;
            InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\multiusr.h ===
/************************************************
    MultiUsr.h

    Header for multiple user functionality
    in Outlook Express.

    Initially by Christopher Evans (cevans) 4/28/98
*************************************************/
#ifndef _MULTIUSR_H
#define _MULTIUSR_H

interface IUserIdentity;

#define USERPASSWORD_MAX_LENGTH         16
#define CCH_USERNAME_MAX_LENGTH         63

HRESULT     MU_RegisterIdentityNotifier(IUnknown *punk, DWORD *pdwCookie);
HRESULT     MU_UnregisterIdentityNotifier(DWORD dwCookie);
BOOL        MU_CheckForIdentityLogout();

HRESULT     MU_GetCurrentUserInfo(LPSTR pszId, UINT cchId, LPSTR pszName, UINT cchName);
HRESULT     MU_GetCurrentUserDirectoryRoot(TCHAR   *lpszUserRoot, int cch);
HRESULT     MU_GetIdentityDirectoryRoot(IUserIdentity *pIdentity, LPSTR lpszUserRoot, int cch);
HKEY        MU_GetCurrentUserHKey();
HRESULT     MU_OpenCurrentUserHkey(HKEY *pHkey);
BOOL        MU_Login(HWND hwnd, BOOL fForceUI, char *lpszUsername);
BOOL        MU_Logoff(HWND hwnd);
DWORD       MU_CountUsers();
LPCTSTR     MU_GetRegRoot();
void        MU_ResetRegRoot();
LPCSTR      MU_GetCurrentIdentityName();
void        MigrateOEMultiUserToIdentities(void);
BOOL        MU_IdentitiesDisabled();
void        MU_UpdateIdentityMenus(HMENU hMenu);
void        MU_IdentityChanged();
HRESULT     MU_Init(BOOL fDefaultId);
void        MU_Shutdown();
void        MU_NewIdentity(HWND hwnd);
void        MU_ManageIdentities(HWND hwnd);
GUID       *PGUIDCurrentOrDefault(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\multiusr.cpp ===
/*******************************************************
    MultiUsr.cpp

    Code for handling multiple user functionality in
    Outlook Express.

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/
#include "pch.hxx"
#include "multiusr.h"
#include "demand.h"
#include "instance.h"
#include "acctutil.h"
#include "options.h"
#include "conman.h"
#include <..\help\mailnews.h>
#include "msident.h"
#include "menures.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifndef THOR_SETUP
#include <shlwapi.h>
#define strstr                  StrStr
#define RegDeleteKeyRecursive   SHDeleteKey
#endif // THOR_SETUP

TCHAR g_szRegRoot[MAX_PATH] = "";
static TCHAR g_szCharsetRegRoot[MAX_PATH] = "";
static TCHAR g_szIdentityName[CCH_USERNAME_MAX_LENGTH+1];
static BOOL g_fUsingDefaultId = FALSE;
static IUserIdentityManager *g_pIdMan = NULL;
static HKEY g_hkeyIdentity = HKEY_CURRENT_USER;
static BOOL g_fIdentitiesDisabled = FALSE;

extern DWORD g_dwIcwFlags;

GUID *PGUIDCurrentOrDefault(void) {
    return (g_fUsingDefaultId ? (GUID *)&UID_GIBC_DEFAULT_USER : (GUID *)&UID_GIBC_CURRENT_USER);
}

static void SafeIdentityRelease()
{
    if (g_pIdMan && 0 == (g_pIdMan)->Release()) 
    {
        g_pIdMan = NULL; 
        RegCloseKey(g_hkeyIdentity); 
        g_hkeyIdentity = HKEY_CURRENT_USER;
    }
}

/*
    MU_RegisterIdentityNotifier

    Handles the dirty work of registering an identity notifier.
    Caller needs to hold on to dwCookie and use it to unadvise.
*/
HRESULT MU_RegisterIdentityNotifier(IUnknown *punk, DWORD *pdwCookie)
{
    IConnectionPoint *pConnectPt = NULL;
    HRESULT hr = S_OK;
    
    Assert(pdwCookie);
    Assert(punk);
    Assert(g_pIdMan);

    if (SUCCEEDED(hr = g_pIdMan->QueryInterface(IID_IConnectionPoint, (void **)&pConnectPt)))
    {
        Assert(pConnectPt);

        SideAssert(SUCCEEDED(hr = pConnectPt->Advise(punk, pdwCookie)));
        
        SafeRelease(pConnectPt);
        g_pIdMan->AddRef();
    }

    return hr;
}


/*
    MU_RegisterIdentityNotifier

    Handles the dirty work of unregistering an identity notifier.
    dwCookie is the cookie returned from MU_RegisterIdentityNotifier.
*/
HRESULT MU_UnregisterIdentityNotifier(DWORD dwCookie)
{
    IConnectionPoint *pConnectPt = NULL;
    HRESULT hr = S_OK;

    Assert(g_pIdMan);

    if (SUCCEEDED(hr = g_pIdMan->QueryInterface(IID_IConnectionPoint, (void **)&pConnectPt)))
    {
        Assert(pConnectPt);

        SideAssert(SUCCEEDED(hr = pConnectPt->Unadvise(dwCookie)));
        
        SafeRelease(pConnectPt);
        SafeIdentityRelease();
    }
    return hr;
}

/*
    MU_CheckForIdentitySwitch

    Check to see if the switch is actually a logout, or just a switch.
    Then tell the COutlookExpress object so that it can restart if
    necessary
*/
BOOL MU_CheckForIdentityLogout()
{
    HRESULT hr;
    IUserIdentity   *pIdentity = NULL;
    BOOL    fIsLogout = TRUE;
    GUID    uidCookie;

    Assert(g_pIdMan);
    
    if (SUCCEEDED(hr = g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_INCOMING_USER, &pIdentity)))
    {
        if (pIdentity)
        {
            pIdentity->GetCookie(&uidCookie);

            fIsLogout = (uidCookie == GUID_NULL);
            pIdentity->Release();
        }
    }

    return fIsLogout;
}


/*
    MU_ShowErrorMessage

    Simple wrapper around resource string table based call to MessageBox
*/
void MU_ShowErrorMessage(HINSTANCE     hInst, 
                        HWND        hwnd, 
                        UINT        iMsgID, 
                        UINT        iTitleID)
{
    char    szMsg[255], szTitle[63];

    LoadString(g_hLocRes, iMsgID, szMsg, sizeof(szMsg));
    LoadString(g_hLocRes, iTitleID, szTitle, sizeof(szTitle));
    MessageBox(hwnd, szMsg, szTitle, MB_OK);
}

// --------------------------------------------------------------------------------
//  Functions to convert GUIDs to ascii strings
// --------------------------------------------------------------------------------

static int AStringFromGUID(GUID *puid,  TCHAR *lpsz, int cch)
{
    WCHAR   wsz[255];
    int     i;

    i = StringFromGUID2(*puid, wsz, 255);

    if (WideCharToMultiByte(CP_ACP, 0, wsz, -1, lpsz, cch, NULL, NULL) == 0)
        return 0;
    
    return (lstrlen(lpsz) + 1);
}


static HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid)
{
    WCHAR   wsz[255];
    HRESULT hr;

    if (MultiByteToWideChar(CP_ACP, 0, lpsz, -1, wsz, 255) == 0)
        return GetLastError();

    hr = CLSIDFromString(wsz, puid);
    
    return hr;
}

/*
    MU_GetCurrentUserInfo

    return the current user's id (guid) and username as strings
*/
HRESULT MU_GetCurrentUserInfo(LPSTR pszId, UINT cchId, LPSTR pszName, UINT cchName)
{
    HRESULT     hr = E_UNEXPECTED;
    IUserIdentity   *pIdentity = NULL;
    GUID        uidUserId;
    WCHAR       szwName[CCH_USERNAME_MAX_LENGTH+1];

    Assert(g_pIdMan);

    // we have to have the IUserIdentityManager
    if (!g_pIdMan)
        goto exit;
    
    // Get the current user
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    
    // if the caller wants the id
    if (pszId)
    {
        // get the cookie (id) as a guid
        if (FAILED(hr = pIdentity->GetCookie(&uidUserId)))
            goto exit;

        // turn it into a string
        if (0 == AStringFromGUID(&uidUserId,  pszId, cchId))
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }

    // if the caller wants the user's name
    if (pszName)
    {
        // get the name as a wide string
        if (FAILED(hr = pIdentity->GetName(szwName, cchName)))
            goto exit;

        // convert it to an ascii string
        if (WideCharToMultiByte(CP_ACP, 0, szwName, -1, pszName, cchName, NULL, NULL) == 0)
            hr = GetLastError();
    }

exit:
    // clean up
    SafeRelease(pIdentity);

    return hr;
}

/*
    MU_GetCurrentUserHKey

    Return the current user's HKEY.

    If no one has logged on yet (this happens when coming in from SMAPI)
    then do the login first.  If the user cancels the login, just return
    the hkey for the default user.

    Caller should not close this key.  It is a common key.  If it is going 
    to be passed out to another library or something, caller should call 
    MU_OpenCurrentUserHkey.
*/
HKEY    MU_GetCurrentUserHKey()
{
    IUserIdentity *pIdentity = NULL;
    HRESULT hr;
    HKEY    hkey;

    // g_hkeyIdentity is initialized to HKEY_CURRENT_USER
    if (g_hkeyIdentity == HKEY_CURRENT_USER)
    {
        // we haven't logged in yet.  Lets try now
        if (!MU_Login(GetDesktopWindow(), FALSE, ""))
        {
            Assert(g_pIdMan);

            if (NULL == g_pIdMan)
                goto exit;

            // if they cancelled or whatever, try to get the
            // default user
            if (FAILED(hr = g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, &pIdentity)))
                goto exit;
        }
        else
        {
            // login succeeded, get the current identity
            Assert(g_pIdMan);

            if (NULL == g_pIdMan)
                goto exit;

            if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
                goto exit;
        }
        
        if (g_hkeyIdentity != HKEY_CURRENT_USER)
            RegCloseKey(g_hkeyIdentity);

        // open a new all access reg key.  Caller must close it
        if (pIdentity && SUCCEEDED(hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey)))
            g_hkeyIdentity = hkey;
        else
            g_hkeyIdentity = HKEY_CURRENT_USER;
    }
exit:
    // Clean up
    SafeRelease(pIdentity);
    return g_hkeyIdentity;
}


/*
    MU_OpenCurrentUserHkey

    Open a new reg key for the current user.  
*/
HRESULT MU_OpenCurrentUserHkey(HKEY *pHkey)
{
    HRESULT     hr = E_UNEXPECTED;
    IUserIdentity   *pIdentity = NULL;
    GUID        uidUserId;

    Assert(g_pIdMan);
    
    // we have to have the IUserIdentityManager
    if (!g_pIdMan)
        goto exit;
    
    // Get the current identity.  If we can't get it, bail.
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    
    // If passed in an hkey pointer, open a new all access key
    if (pHkey)
        hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, pHkey);

exit:
    // Clean up
    SafeRelease(pIdentity);
    return hr;

}


/*
    MU_GetCurrentUserDirectoryRoot

    Return the path to the top of the current user's root directory.
    This is the directory where the mail store should be located.
    It is in a subfolder the App Data folder.

    lpszUserRoot is a pointer to a character buffer that is cch chars
    in size.
*/
HRESULT MU_GetCurrentUserDirectoryRoot(TCHAR   *lpszUserRoot, int cch)
{
    HRESULT hr = E_FAIL;
    IUserIdentity *pIdentity = NULL;

    Assert(g_pIdMan);
    Assert(lpszUserRoot != NULL);
    Assert(cch >= MAX_PATH);

    if (g_pIdMan == NULL)
        goto exit;
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    hr = MU_GetIdentityDirectoryRoot(pIdentity, lpszUserRoot, cch);

exit:
    SafeRelease(pIdentity);

    return hr;
}

HRESULT MU_GetIdentityDirectoryRoot(IUserIdentity *pIdentity, LPSTR lpszUserRoot, int cch)
{
    HRESULT hr;
    TCHAR szSubDir[MAX_PATH], *psz;
    WCHAR szwUserRoot[MAX_PATH];
    int cb;

    Assert(pIdentity);
    Assert(lpszUserRoot != NULL);
    Assert(cch >= MAX_PATH);

    hr = pIdentity->GetIdentityFolder(GIF_NON_ROAMING_FOLDER, szwUserRoot, MAX_PATH);
    if (FAILED(hr))
        return(hr);
    
    if (WideCharToMultiByte(CP_ACP, 0, szwUserRoot, -1, lpszUserRoot, cch, NULL, NULL) == 0)
        return(E_FAIL);

    AthLoadString(idsMicrosoft, szSubDir, ARRAYSIZE(szSubDir));
    psz = PathAddBackslash(szSubDir);
    AthLoadString(idsAthena, psz, ARRAYSIZE(szSubDir)-(DWORD)(psz-szSubDir));

    cb = lstrlen(lpszUserRoot) + lstrlen(szSubDir) + 3;
    if (cb < cch)
    {
        psz = PathAddBackslash(lpszUserRoot);
        if (psz)
        {
            StrCpyN(psz, szSubDir, cch - (DWORD)(psz-lpszUserRoot));
            psz = PathAddBackslash(lpszUserRoot);
        }
        
        hr = S_OK;
    }

    return(hr);
}

DWORD  MU_CountUsers()
{
    IEnumUserIdentity  *pEnum = NULL;
    HRESULT             hr;
    ULONG               cUsers = 0;

    Assert(g_pIdMan);
    
    if (SUCCEEDED(hr = g_pIdMan->EnumIdentities(&pEnum)) && pEnum)
    {
        pEnum->GetCount(&cUsers);
    
        SafeRelease(pEnum);
    }
    return cUsers;

}

/*
    MU_Login

    Wrapper routine for logging in to OE.  Asks the user to choose a username
    and, if necessary, enter the password for that user.  The user can also
    create an account at this point.  

    lpszUsername should contain the name of the person who should be the default
    selection in the list.  If the name is empty ("") then it will look up the
    default from the registry.

    Returns the username that was selected in lpszUsername.  Returns true
    if that username is valid.
*/
BOOL        MU_Login(HWND hwnd, BOOL fForceUI, char *lpszUsername) 
{
    HRESULT hr = S_OK;
    IUserIdentity   *pIdentity = NULL;

    if (g_fUsingDefaultId)
        goto exit;

    if (NULL == g_pIdMan)
    {
        hr = MU_Init(FALSE);
        if (FAILED(hr))
            goto exit;
    }

#pragma prefast(suppress:11, "noise")
    g_pIdMan->AddRef();

#pragma prefast(suppress:11, "noise")
    hr = g_pIdMan->Logon(hwnd, (fForceUI ? UIL_FORCE_UI : 0), &pIdentity);

    if (SUCCEEDED(hr))
    {
        g_fIdentitiesDisabled = (hr == S_IDENTITIES_DISABLED);

        if (!fForceUI)
        {
            if (g_hkeyIdentity != HKEY_CURRENT_USER)
                RegCloseKey(g_hkeyIdentity);

            hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS,&g_hkeyIdentity);
        }

        SafeRelease(pIdentity);
    }
    SafeIdentityRelease();
exit:
    return SUCCEEDED(hr);
}

BOOL        MU_Logoff(HWND hwnd)
{
    HRESULT hr=E_FAIL;

    Assert(g_pIdMan);

    if (g_pIdMan)
        hr = g_pIdMan->Logoff(hwnd);
    return SUCCEEDED(hr);
}

/*
    MU_MigrateFirstUserSettings

    This should only be called once, when there are no users configured yet.
*/
#define MAXDATA_LENGTH      16L*1024L

void        MU_MigrateFirstUserSettings(void)
{
/*    OEUSERINFO  vCurrentUser;
    TCHAR   szLM[255];
    HKEY    hDestinationKey = NULL;
    HKEY    hSourceKey = NULL;
    FILETIME    ftCU = {0,1}, ftLM = {0,0};     //default CU to just later than LM
    DWORD   dwType, dwSize, dwStatus;

    if (MU_GetCurrentUserInfo(&vCurrentUser))
    {
        TCHAR   szRegPath[MAX_PATH], szAcctPath[MAX_PATH];

        Assert(vCurrentUser.idUserID != -1);
        
        MU_GetRegRootForUserID(vCurrentUser.idUserID, szRegPath);
        Assert(*szRegPath);

        MU_GetAccountRegRootForUserID(vCurrentUser.idUserID, szAcctPath);
        Assert(*szAcctPath);

        hDestinationKey = NULL;
            
        if (RegCreateKey(HKEY_CURRENT_USER, szAcctPath, &hDestinationKey) == ERROR_SUCCESS)
        {
          if (RegOpenKey(HKEY_CURRENT_USER, c_szInetAcctMgrRegKey, &hSourceKey) == ERROR_SUCCESS)
          {
              CopyRegistry(hSourceKey, hDestinationKey);
              RegCloseKey(hSourceKey);
          }
          RegCloseKey(hDestinationKey);
        }
            
        if (RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hDestinationKey) == ERROR_SUCCESS)
        {
            if (RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceKey) == ERROR_SUCCESS)
            {
                DWORD EnumIndex;
                DWORD cbValueName;
                DWORD cbValueData;
                DWORD Type;
                CHAR ValueNameBuffer[MAXKEYNAME];
                BYTE ValueDataBuffer[MAXDATA_LENGTH];
                
                //
                //  Copy all of the value names and their data.
                //

                EnumIndex = 0;

                while (TRUE) {

                    cbValueName = sizeof(ValueNameBuffer);
                    cbValueData = MAXDATA_LENGTH;

                    if (RegEnumValue(hSourceKey, EnumIndex++, ValueNameBuffer,
                        &cbValueName, NULL, &Type, ValueDataBuffer, &cbValueData) !=
                        ERROR_SUCCESS)
                        break;

                    RegSetValueEx(hDestinationKey, ValueNameBuffer, 0, Type,
                        ValueDataBuffer, cbValueData);

                }


                RegSetValueEx(hDestinationKey, c_szUserID, 0, REG_DWORD, (BYTE *)&vCurrentUser.idUserID, sizeof(DWORD));

                //
                //  Copy all of the subkeys and recurse into them.
                //

                EnumIndex = 0;

                while (TRUE) 
                {
                    HKEY    hSourceSubKey, hDestinationSubKey;

                    if (RegEnumKey(hSourceKey, EnumIndex++, ValueNameBuffer, MAXKEYNAME) !=
                        ERROR_SUCCESS)
                        break;
                    
                    // don't recursively copy the Profiles key into the profiles key.
                    if (lstrcmpi(ValueNameBuffer, "Profiles") != 0)
                    {
                        if (RegOpenKey(hSourceKey, ValueNameBuffer, &hSourceSubKey) ==
                            ERROR_SUCCESS) 
                        {

                            if (RegCreateKey(hDestinationKey, ValueNameBuffer,
                                &hDestinationSubKey) == ERROR_SUCCESS) 
                            {

                                CopyRegistry(hSourceSubKey, hDestinationSubKey);

                                RegCloseKey(hDestinationSubKey);

                            }

                            RegCloseKey(hSourceSubKey);

                        }
                    }
                }

                RegCloseKey(hSourceKey);
            }
            RegCloseKey(hDestinationKey);
        }
    }
    */
}


/*
    MU_ShutdownCurrentUser

    Do everything necessary to get the app to the point where 
    calling CoDecrementInit will tear everything else down.
*/
BOOL    MU_ShutdownCurrentUser(void)
{
    HWND    hWnd, hNextWnd = NULL;
    BOOL    bResult = true;
    LRESULT lResult;
    DWORD   dwProcessId, dwWndProcessId;
    HINITREF hInitRef;
/*
    g_pInstance->SetSwitchingUsers(true);

    dwProcessId = GetCurrentProcessId();
    
    g_pInstance->CoIncrementInit(0, "", &hInitRef);

    hWnd = GetTopWindow(NULL);

    if (g_pConMan->IsConnected())
    {
         if (IDNO == AthMessageBoxW(hWnd, MAKEINTRESOURCEW(idsSwitchUser),MAKEINTRESOURCEW(idsMaintainConnection),  
                              NULL, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON1 | MB_APPLMODAL))
            g_pConMan->Disconnect(hWnd, TRUE, FALSE, FALSE );
    }

    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        GetWindowThreadProcessId(hWnd,&dwWndProcessId); 
        
        if (dwProcessId == dwWndProcessId && IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName( hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, g_szDBNotifyWndProc) != 0 &&
                lstrcmp(szWndClassName, g_szDBListenWndProc) != 0)
            {

                lResult = SendMessage(hWnd, WM_CLOSE, 0, 0);

                // if the window is still there, something is wrong
                if(lResult != ERROR_SUCCESS || GetTopWindow(NULL) == hWnd)
                {
                    Assert(GetTopWindow(NULL) != hWnd); 
                    return false;
                }
            }
        }

        hWnd = hNextWnd;
    }

    g_pInstance->CoDecrementInit(&hInitRef);
*/
    return bResult;
}



/*
    _GetRegRootForUserID

    HACK ALERT

    The proper way to store registry things with identities is to use the
    HKEY that is returned from IUserIdentity::OpenIdentityRegKey.  This is 
    here only because some old interfaces assume HKEY_CURRENT_USER.   Those
    that do, need to be fixed.  In the meantime, we have this
*/
HRESULT     _GetRegRootForUserID(GUID *puidUserId, LPSTR pszPath, DWORD cch)
{
    HRESULT         hr = S_OK;
    IUserIdentity  *pIdentity = NULL;
    TCHAR           szPath[MAX_PATH];
    HKEY            hkey;
    TCHAR           szUid[255];
    GUID            uidIdentityId;

    Assert(pszPath);
    Assert(g_pIdMan);
    Assert(puidUserId);
    if (g_pIdMan == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(puidUserId, &pIdentity)))
        goto exit;

    if (FAILED(hr = pIdentity->GetCookie(&uidIdentityId)))
        goto exit;

    AStringFromGUID(&uidIdentityId,  szUid, 255);
    wnsprintf(pszPath, cch, "%s\\%s\\%s", "Identities", szUid, c_szRegRoot);

exit:
    SafeRelease(pIdentity);
    return hr;
}



LPCTSTR     MU_GetRegRoot()
{
    if (*g_szRegRoot)
        return g_szRegRoot;

    if (FAILED(_GetRegRootForUserID(PGUIDCurrentOrDefault(), g_szRegRoot, ARRAYSIZE(g_szRegRoot))))
        _GetRegRootForUserID((GUID *)&UID_GIBC_DEFAULT_USER, g_szRegRoot, ARRAYSIZE(g_szRegRoot));

    return g_szRegRoot;
}

LPCSTR MU_GetCurrentIdentityName()
{
    HRESULT hr;
    IUserIdentity *pIdentity = NULL;
    WCHAR   szwName[CCH_USERNAME_MAX_LENGTH+1];

    Assert(g_pIdMan);
    if (g_pIdMan == NULL)
        return NULL;
    
    if (*g_szIdentityName)
        return g_szIdentityName;
    
    if (MU_CountUsers() == 1)
        g_szIdentityName[0] = 0;
    else
    {
        if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
            goto exit;

        if (!pIdentity)
            goto exit;

        if (FAILED(hr = pIdentity->GetName(szwName, CCH_USERNAME_MAX_LENGTH)))
            goto exit;

        if (WideCharToMultiByte(CP_ACP, 0, szwName, -1, g_szIdentityName, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
        {
            g_szIdentityName[0] = 0;
            goto exit;
        }
    }
exit:
    SafeRelease(pIdentity);
    return g_szIdentityName;
}

void  MU_ResetRegRoot()
{
    RegCloseKey(g_hkeyIdentity);
    g_hkeyIdentity = HKEY_CURRENT_USER;
    g_szRegRoot[0] = 0;
    g_szIdentityName[0] = 0;
    g_dwIcwFlags = 0;
}

void MigrateOEMultiUserToIdentities(void)
{
    TCHAR   szProfilesPath[] = "Software\\Microsoft\\Outlook Express\\5.0\\Profiles";
    TCHAR   szCheckKeyPath[] = "Software\\Microsoft\\Outlook Express\\5.0\\Shared Settings\\Setup";
    TCHAR   szPath[MAX_PATH], szProfilePath[MAX_PATH];
    HKEY    hOldKey, hOldSubkey, hNewTopKey, hNewOEKey, hNewIAMKey, hCheckKey = NULL;
    DWORD   EnumIndex;
    DWORD   cbKeyName, cUsers;
    DWORD   dwType, dwValue, dwStatus, dwSize;
    CHAR    KeyNameBuffer[1024];
    IPrivateIdentityManager *pPrivIdMgr;
    HRESULT hr;

    if (NULL == g_pIdMan)
    {
        hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&g_pIdMan);
        
        if (FAILED(hr))
            return;
    }

    Assert(g_pIdMan);

    if (FAILED(g_pIdMan->QueryInterface(IID_IPrivateIdentityManager, (void **)&pPrivIdMgr)))
        return;

    if (RegOpenKey(HKEY_CURRENT_USER, szProfilesPath, &hOldKey) == ERROR_SUCCESS)
    {
        dwStatus = RegCreateKey(HKEY_CURRENT_USER, szCheckKeyPath, &hCheckKey);

        dwSize = sizeof(dwValue);
        if (dwStatus != ERROR_SUCCESS ||
            (dwStatus = RegQueryValueEx(hCheckKey, "MigToLWP", NULL, &dwType, (LPBYTE)&dwValue, &dwSize)) != ERROR_SUCCESS ||
                        (1 != dwValue))
        {
            //
            //  Copy all of the value names and their data.
            //

            dwStatus = RegQueryInfoKey(hOldKey, NULL, NULL, 0, &cUsers, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

            EnumIndex = 0;

            while (TRUE && cUsers > 0) 
            {

                cbKeyName = sizeof(KeyNameBuffer);

                if (RegEnumKey(hOldKey, EnumIndex++, KeyNameBuffer, cbKeyName) !=
                    ERROR_SUCCESS)
                    break;
            
                wnsprintf(szProfilePath, ARRAYSIZE(szProfilePath), "%s\\Application Data", KeyNameBuffer);

                if (ERROR_SUCCESS == RegOpenKey(hOldKey, szProfilePath, &hOldSubkey))
                {
                    TCHAR   szUserName[CCH_USERNAME_MAX_LENGTH+1];
                    WCHAR   szwUserName[CCH_USERNAME_MAX_LENGTH+1];
                    IUserIdentity *pIdentity = NULL;

                    dwSize = sizeof(szUserName);
                    if ((dwStatus = RegQueryValueEx(hOldSubkey, "Current Username", NULL, &dwType, (LPBYTE)szUserName, &dwSize)) == ERROR_SUCCESS &&
                            (0 != *szUserName))
                    {
                        if (MultiByteToWideChar(CP_ACP, 0, szUserName, -1, szwUserName, CCH_USERNAME_MAX_LENGTH) == 0)
                            goto UserFailed;
                        
                        if (cUsers == 1)
                        {
                            if (FAILED(g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, &pIdentity)) || !pIdentity)
                                goto UserFailed;
                        }
                        else
                        {
                            if (FAILED(pPrivIdMgr->CreateIdentity(szwUserName, &pIdentity)) || !pIdentity)
                                goto UserFailed;
                        }
                        if (FAILED(pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hNewTopKey)))
                            goto UserFailed;

                        if (ERROR_SUCCESS == RegCreateKey(hNewTopKey, c_szRegRoot, &hNewOEKey))
                        {
                            CopyRegistry(hOldSubkey, hNewOEKey);
                            RegCloseKey(hNewOEKey);
                        }

                        // now copy the IAM settings
                        wnsprintf(szProfilePath, ARRAYSIZE(szProfilePath), "%s\\Internet Accounts", KeyNameBuffer);
                    
                        RegCloseKey(hOldSubkey);
                        hOldSubkey = NULL;

                        if (ERROR_SUCCESS == RegOpenKey(hOldKey, szProfilePath, &hOldSubkey))
                        {
                            if (ERROR_SUCCESS == RegCreateKey(hNewTopKey, c_szInetAcctMgrRegKey, &hNewIAMKey))
                            {
                                CopyRegistry(hOldSubkey, hNewIAMKey);
                                RegCloseKey(hNewIAMKey);
                            }
                        }
                    

UserFailed:
                        RegCloseKey(hNewTopKey);
                        SafeRelease(pIdentity);
                        if (hOldSubkey)
                        {
                            RegCloseKey(hOldSubkey);
                            hOldSubkey = NULL;
                        }
                    }
                }

            }

            dwValue = 1;
            RegSetValueEx(hCheckKey, "MigToLWP", 0, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
        }
        if (hCheckKey != NULL)
            RegCloseKey(hCheckKey);
        RegCloseKey(hOldKey);

    }
    pPrivIdMgr->Release();
}

BOOL    MU_IdentitiesDisabled()
{
    return g_fIdentitiesDisabled || (g_dwAthenaMode & MODE_NOIDENTITIES && !g_fPluralIDs);
}

void MU_UpdateIdentityMenus(HMENU hMenu)
{
    DWORD   cItems, dwIndex;
    MENUITEMINFO    mii;
    TCHAR   szLogoffString[255];
    TCHAR   szRes[255];

    if (MU_IdentitiesDisabled())
    {
        // Delete the switch identity menu
        DeleteMenu(hMenu, ID_SWITCH_IDENTITY, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXIT_LOGOFF, MF_BYCOMMAND);

        // loop through the other menu items looking for logoff
        cItems = GetMenuItemCount(hMenu);
    
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID;

        for (dwIndex = cItems; dwIndex > 0; --dwIndex)
        {
            GetMenuItemInfo(hMenu, dwIndex, TRUE, &mii);

            // if this is the logoff item, delete it and the separator 
            // line that follows
            if (mii.wID == ID_IDENTITIES)
            {
                DeleteMenu(hMenu, ID_IDENTITIES, MF_BYCOMMAND);
                DeleteMenu(hMenu, dwIndex, MF_BYPOSITION);
                break;
            }
        }
    }
    else
    {
        // Load a new menu string from the resources
        AthLoadString(idsLogoffFormat, szRes, ARRAYSIZE(szRes));

        // Format it
        wnsprintf(szLogoffString, ARRAYSIZE(szLogoffString), szRes, MU_GetCurrentIdentityName());

        // Splat it on the menu
        ModifyMenu(hMenu, ID_LOGOFF_IDENTITY, MF_BYCOMMAND | MF_STRING, ID_LOGOFF_IDENTITY, szLogoffString);
    }
}

void MU_NewIdentity(HWND hwnd)
{
    if (g_pIdMan)
    {
        g_pIdMan->ManageIdentities(hwnd, UIMI_CREATE_NEW_IDENTITY);
    }
}

void MU_ManageIdentities(HWND hwnd)
{
    if (g_pIdMan)
    {
        g_pIdMan->ManageIdentities(hwnd, 0);
    }
}

void MU_IdentityChanged()
{
    // flush the cached name so we reload it
    *g_szIdentityName = 0;
}

HRESULT MU_Init(BOOL fDefaultId)
{
    HRESULT hr = S_OK;

    g_fUsingDefaultId = fDefaultId;

    if (NULL == g_pIdMan)
    {
        hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&g_pIdMan);

        if (FAILED(hr))
            MU_ShowErrorMessage(g_hLocRes, GetDesktopWindow(), idsCantLoadMsident,idsAthenaTitle);
    }
    else
        g_pIdMan->AddRef();
    return hr;
}

void MU_Shutdown()
{
    Assert(g_pIdMan);
    if (g_pIdMan == NULL)
        return;

    SafeIdentityRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\rundll.cpp ===
//
//  DLL.CPP - Dll initialization routines
//

#include "pch.hxx"
#include "strconst.h"
#include <shlguid.h>
#include "ourguid.h"
#include "globals.h"
#include "folder.h"
#include "newsview.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "mailnote.h"
#include "newsnote.h"
#include "resource.h"
#include "init.h"
#include <store.h>
#include "url.h" 
#include "shelutil.h"
#include <goptions.h>
#include "nnserver.h"
#include "storfldr.h"   // IsThisNashville
#include "strconst.h"
#include "grplist.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <secutil.h>
#include <error.h>
#ifndef WIN16  //RUN16_MSLU
#include <msluapi.h>
#include <msluguid.h>
#endif //!WIN16

extern HRESULT BrowseToObject(LPCITEMIDLIST pidl);
HRESULT HrOpenMessage(HFOLDER hfldr, MSGID msgid, LPMIMEMESSAGE *ppMsg);
BOOL ParseFolderMsgId(LPSTR pszCmdLine, HFOLDER *phfldr, MSGID *pmsgid);
HRESULT HrDownloadArticleDialog(CNNTPServer *pNNTPServer, LPTSTR pszArticle, LPMIMEMESSAGE *ppMsg);


///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNWSFile
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNWSFile(LPTSTR pszCmd)
{
#ifndef WIN16  //RUN16_NEWS
    LPMIMEMESSAGE   pMsg;
    int             idsErr = idsNewsRundllFailed;
    NCINFO          nci = { 0 };

    if (!pszCmd|| !*pszCmd)
        goto exit; 
    
    DOUTL(1, TEXT("HandleNWSFile - pszCmd = %s"), pszCmd);

    if ((UINT)GetFileAttributes (pszCmd) == (UINT)-1)    
        {
        idsErr = idsErrNewsCantOpen;
        goto exit;
        }

    // Do the basic DLL initialization first.
    if (!Initialize_RunDLL(FALSE))
        goto exit;
        
    // Create new message
    if (SUCCEEDED(HrCreateMessage(&pMsg)))
        {
        if (SUCCEEDED(HrLoadMsgFromFile(pMsg, pszCmd)))
            {
            LPSTR lpszUnsent;

            nci.ntNote = ntReadNote;
            nci.dwFlags = NCF_NEWS;
            nci.pMsg = pMsg;

            if (MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &lpszUnsent) == S_OK)
                {
                if (*lpszUnsent)
                    nci.ntNote = ntSendNote;
                SafeMimeOleFree(lpszUnsent);
                }

            if (SUCCEEDED(HrCreateNote(&nci)))
                idsErr = 0;
            }
        else
            idsErr = idsErrNewsCantOpen;
        pMsg->Release();
        }

    Uninitialize_RunDLL();

exit:          
    if (idsErr)
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsErr), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
    return (idsErr) ? E_FAIL : S_OK;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNewsArticleURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNewsArticleURL(LPTSTR pszServerIn, LPTSTR pszArticle, UINT uPort, BOOL fSecure)
{
#ifndef WIN16  //RUN16_NEWS
    NCINFO          nci;
    CNNTPServer    *pNNTPServer = NULL;
    HRESULT         hr = E_FAIL;
    TCHAR           szAccount[CCHMAX_ACCOUNT_NAME];
    TCHAR           szArticleId[1024];
    IImnAccount    *pAcct = NULL;
    LPMIMEMESSAGE   pMsg = NULL;

    // The URL specified an article id.  In this case we ONLY want to 
    // display a ReadNote window.  This requires a bit of work.

    // Do the basic DLL initialization first.
    if (!Initialize_RunDLL(FALSE))
        {
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsNewsRundllFailed), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
        return E_FAIL;
        }
        
    // If a server was specified, then try to create a temp account for it
    if (pszServerIn && 
        *pszServerIn && 
        SUCCEEDED(NewsUtil_CreateTempAccount(pszServerIn, uPort, fSecure, &pAcct)))
        {
        pAcct->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount));
        pAcct->Release();
        }        
    else
        {
        // If a server wasn't specified, then use the default account
        if (NewsUtil_GetDefaultServer(szAccount, ARRAYSIZE(szAccount)) != S_OK)
            goto exit;
        }

    // Need to invoke read note.  First create and initialize an server.
    pNNTPServer = new CNNTPServer();
    if (!pNNTPServer)
        goto exit;
    
    if (FAILED(pNNTPServer->HrInit(szAccount)))
        goto exit;

    if (FAILED(pNNTPServer->Connect()))
        goto exit;

    // Bug #10555 - The URL shouldn't have <> around the article ID, but some 
    //              lameoids probably will do it anyway, so deal with it.
    StrCpyN(szArticleId, pszArticle, ARRAYSIZE(szArticleId));
    if (!IsDBCSLeadByte(*pszArticle))
        {
        if (*pszArticle != '<')
            wnsprintf(szArticleId, ARRAYSIZE(szArticleId), TEXT("<%s>"), pszArticle);
        }            

    if (SUCCEEDED(hr = HrDownloadArticleDialog(pNNTPServer, szArticleId, &pMsg)))
        {
        // Initialize the NNCI struct so we can invoke a note window.    
        ZeroMemory(&nci, sizeof(NCINFO));
        nci.ntNote = ntReadNote;
        nci.dwFlags = NCF_NEWS;
        nci.pMsg = pMsg;
        HrSetAccount(pMsg, szAccount);

        // Create the note.
        hr = HrCreateNote(&nci); 
        }

exit:
    SafeRelease(pNNTPServer);
    Uninitialize_RunDLL();

    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsErrNewsCantOpen), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNewsURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNewsURL(LPTSTR pszCmd)
{
#ifndef WIN16  //RUN16_NEWS
    LPTSTR       pszCmdLine = NULL;
    HRESULT      hr = E_FAIL;
    LPTSTR       pszServer = 0, pszGroup = 0, pszArticle = 0;
    UINT         uPort = (UINT) -1;
    BOOL         fSecure;
    ULONG        cchCmdLine;

    cchCmdLine = 2 + lstrlen(pszCmd);
    if (!MemAlloc((LPVOID*) &pszCmdLine, cchCmdLine * sizeof(TCHAR)))
        goto exit;
    
    StrCpyN(pszCmdLine, pszCmd, cchCmdLine);
    UrlUnescapeInPlace(pszCmdLine, 0);

    DOUTL(1, TEXT("HandleNewsURL - pszCmdLine = %s"), pszCmdLine);

    if (!pszCmdLine || !*pszCmdLine)
        goto exit;
    
    // Figure out if the URL is valid and what type of URL it is.
    if (FAILED (URL_ParseNewsUrls(pszCmdLine, &pszServer, &uPort, &pszGroup, &pszArticle, &fSecure)))
        goto exit;

    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;

    if (pszArticle)
        {
        HandleNewsArticleURL(pszServer, pszArticle, uPort, fSecure);
        hr = S_OK;
        }
    else
        {
        LPITEMIDLIST pidl = NULL;
        ShellUtil_PidlFromNewsURL(pszServer, uPort, pszGroup, fSecure, &pidl);
        hr = BrowseToObject(pidl);
        if (pidl)
            PidlFree(pidl);
        }
    
exit:          
    if (pszCmdLine)
        MemFree(pszCmdLine);
    if (pszServer)    
        MemFree(pszServer);
    if (pszGroup)
        MemFree(pszGroup);
    if (pszArticle)
        MemFree(pszArticle);

    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsNewsRundllFailed), 0,
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleEMLFile
//
//  PURPOSE:    Used to open EML files. 
// 
///////////////////////////////////////////////////////////////////////
HRESULT HandleEMLFile(LPTSTR pszCmd)
{
    LPMIMEMESSAGE   pMsg=0;
    NCINFO          nci;
    HRESULT         hr = E_FAIL;
    int             idsErr = idsMailRundllFailed;

    if (!pszCmd || !*pszCmd)
        goto exit;
    
    DOUTL(1, TEXT("HandleEMLFile - pszCmd = %s"), pszCmd);

    // Check to see the file is valid
    if ((UINT)GetFileAttributes (pszCmd) == (UINT)-1)
        {
        idsErr = idsErrNewsCantOpen;
        goto exit;
        }

    if (!Initialize_RunDLL(TRUE))
        goto exit;

    // Create new mail message
    if (SUCCEEDED(hr = HrCreateMessage(&pMsg)))
        {
        // OPIE: correct way load EML file thro' IPF???
        // Ensure that the string is ANSI.    
        if (SUCCEEDED(hr = HrLoadMsgFromFile(pMsg, pszCmd)))
            {
            if (SUCCEEDED(hr = HandleSecurity(GetDesktopWindow(), pMsg)))
                {
                LPSTR lpszUnsent;

                // Show the note
                ZeroMemory(&nci, sizeof(NCINFO));    
                nci.ntNote = ntReadNote;    
                nci.pMsg = pMsg;
                if (MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &lpszUnsent) == S_OK)
                    {
                    if (*lpszUnsent)
                        {
                        nci.ntNote = ntSendNote;
                        nci.dwFlags = NCF_SENDIMMEDIATE;   //always on dllentry points...
                        }
                    SafeMimeOleFree(lpszUnsent);
                    }            

                if (SUCCEEDED(hr = HrCreateNote(&nci)))
                    idsErr = 0;
                }
            }
        else
            idsErr = idsErrNewsCantOpen;
        pMsg->Release();
        }

    // Once the user quits or sends the note, we can quit.
    Uninitialize_RunDLL();

exit:
    if (idsErr && hr != HR_E_ATHSEC_FAILED)
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaMail), 
                      MAKEINTRESOURCEW(idsErr),
                      0, MB_ICONEXCLAMATION | MB_OK);
    return (idsErr) ? E_FAIL : S_OK;
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleMailURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid Mail URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleMailURL(LPTSTR pszCmd)
{
    LPMIMEMESSAGE   pMsg = NULL;
    HRESULT         hr = E_FAIL;

    if (!pszCmd || !*pszCmd)
        goto exit;

    // NOTE: no URLUnescape in this function - it must be done in URL_ParseMailTo to handle
    // URLs of the format:
    //
    //      mailto:foo@bar.com?subject=AT%26T%3dBell&cc=me@too.com
    //
    // so that the "AT%26T" is Unescaped into "AT&T=Bell" *AFTER* the "subject=AT%26T%3dBell&" blob is parsed.
    
    DOUTL(1, TEXT("HandleMailURL - pszCmd = %s"), pszCmd);

    if (SUCCEEDED(HrCreateMessage(&pMsg)))
        {
        if (SUCCEEDED(URL_ParseMailTo(pszCmd, pMsg)))
            {
            if (Initialize_RunDLL(TRUE))
                {
                NCINFO nci = {0};

                nci.ntNote = ntSendNote;
                nci.dwFlags = NCF_SENDIMMEDIATE;   //always on dllentry points...
                nci.pMsg = pMsg;

                hr = HrCreateNote(&nci);

                Uninitialize_RunDLL();
                }
            }
        pMsg->Release();
        }

exit:
    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaMail), 
                      MAKEINTRESOURCEW(idsMailRundllFailed),
                      0, 
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
}

#ifndef WIN16  //RUN16_NEWS

typedef struct tagARTDOWNDLG {
    CNNTPServer  *pNNTPServer;
    LPTSTR       pszArticle;
    LPMIMEMESSAGE pMsg;
    LPSTREAM      pStream;
    DWORD         dwID;
    BOOL          fOK;
} ARTDOWNDLG, * PARTDOWNDLG;

#define DAD_SERVERCB    (WM_USER + 100)

INT_PTR CALLBACK DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PARTDOWNDLG pad = (PARTDOWNDLG)GetWindowLong(hwnd, DWL_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];

    switch (msg)
        {
        case WM_INITDIALOG:
            {
            NNTPNOTIFY not = { NULL, hwnd, DAD_SERVERCB, 0 };
            HRESULT    hr;

            // replace some strings in the group download dialog
            AthLoadString(idsDownloadArtTitle, szRes, sizeof(szRes));
            SetWindowText(hwnd, szRes);
            AthLoadString(idsDownloadArtMsg, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
    
            CenterDialog(hwnd);
            Assert(lParam);
            pad = (PARTDOWNDLG)lParam;
            SetWindowLong(hwnd, DWL_USER, lParam);

            Animate_Open(GetDlgItem(hwnd, idcAnimation), idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);
            AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, 0);
            SetDlgItemText(hwnd, idcProgText, szBuffer);
            // start the group download
            if (SUCCEEDED(hr = pad->pNNTPServer->Article(&not, NULL, pad->pszArticle, pad->pStream)))
                {
                pad->dwID = not.dwID;
                SetForegroundWindow(hwnd);
                }
            else
                EndDialog(hwnd, 0);
            }
            return (TRUE);
            
        case WM_COMMAND:
            Assert(pad);
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
                {                
                Animate_Stop(GetDlgItem(hwnd, idcAnimation));
                EndDialog(hwnd, 0);
                return TRUE;
                }
            break;
            
        case WM_DESTROY:
            Assert(pad);
            if (pad->dwID)
                pad->pNNTPServer->CancelRequest(pad->dwID);
            break;

        case DAD_SERVERCB:
            {
            LPNNTPRESPONSE pResp;
            CNNTPResponse *pNNTPResp;

            if (SUCCEEDED(pad->pNNTPServer->GetAsyncResult(lParam, &pNNTPResp)))
                {
                pNNTPResp->Get(&pResp);

                Assert(pResp->state == NS_ARTICLE);
                if (pResp->fDone)
                    {
                    if (SUCCEEDED(pResp->rIxpResult.hrResult))
                        {
                        pad->fOK = TRUE;
                        }
                    else
                        {
                        int ids;
                        if (IXP_NNTP_NO_SUCH_ARTICLE_NUM == pResp->rIxpResult.uiServerError ||
                            IXP_NNTP_NO_SUCH_ARTICLE_FOUND == pResp->rIxpResult.uiServerError)
                            ids = idsErrNewsExpired;
                        else
                            ids = idsErrNewsCantOpen;

                        AthMessageBoxW(hwnd, 
                                      MAKEINTRESOURCEW(idsAthenaNews), 
                                      MAKEINTRESOURCEW(ids),
                                      0,
                                      MB_OK | MB_ICONEXCLAMATION);

                        }
                    pad->dwID = 0;
                    EndDialog(hwnd, 0);
                    }
                else
                    {
                    AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
                    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, pResp->rArticle.cLines);
                    SetDlgItemText(hwnd, idcProgText, szBuffer);
                    }

                pNNTPResp->Release();
                }
            }
            return (TRUE);        
        }
    return FALSE;        
}

HRESULT HrDownloadArticleDialog(CNNTPServer *pNNTPServer, LPTSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    HRESULT     hr;
    ARTDOWNDLG  add = { 0 };

    if (SUCCEEDED(hr = HrCreateMessage(&add.pMsg)))
        {
        if (SUCCEEDED(hr = MimeOleCreateVirtualStream(&add.pStream)))
            {
            add.pNNTPServer = pNNTPServer;
            add.pszArticle = pszArticle;
            DialogBoxParam(g_hLocRes, 
                           MAKEINTRESOURCE(iddDownloadGroups), 
                           NULL, 
                           DownloadArticleDlg, 
                           (LPARAM)&add);
            if (add.fOK)
                {
                add.pMsg->Load(add.pStream);
                *ppMsg = add.pMsg;
                (*ppMsg)->AddRef();
                hr = S_OK;
                }
            else
                hr = E_FAIL;
            add.pStream->Release();
            }
        else
            {
            AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
            }
        add.pMsg->Release();
        }
    else
        {
        AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
        }

    return hr;
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   LogOffRunDLL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to
//              perform an ExitWindows in the context of another
//              process.  This works around all kinds of nasty shutdown
//              behavior and differences between NT and Win95.
//
///////////////////////////////////////////////////////////////////////
void WINAPI FAR LogOffRunDLL(HWND hwndStub, HINSTANCE hInstance, LPTSTR pszCmd, int nCmdShow)
{    
    HRESULT         hr = S_OK;
    IUserDatabase  *pUserDB;

    // this is required because ShowWindow ignore the params on
    // on the first call per process - this causes our notes to
    // use the nCmdShow from WinExec.  By calling here, we make
    // sure that ShowWindow respects our later calls.  (EricAn)
    ShowWindow(hwndStub, SW_HIDE);

    OleInitialize(0);

    if (SUCCEEDED(CoCreateInstance(CLSID_LocalUsers, NULL, CLSCTX_INPROC_SERVER, IID_IUserDatabase, (LPVOID*)&pUserDB)))
        {
        hr = pUserDB->Authenticate(GetDesktopWindow(), LUA_DIALOG|LUA_FORNEXTLOGON, NULL, NULL, NULL);
        pUserDB->Release();
        }
    if (SUCCEEDED(hr))
        ExitWindowsEx(EWX_LOGOFF, 0);

    OleUninitialize();
}

#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\smapimem.h ===
#ifndef _SMAPIMEM_H_
#define _SMAPIMEM_H_

//  Buffer link overhead.
//  Blocks of memory obtained with MAPIAllocateMore are linked to a
//  block obtained with MAPIAllocateBuffer, so that the whole chain
//  may be freed with one call to MAPIFreeBuffer.

typedef struct _BufInternal * LPBufInternal;
typedef struct _BufInternal
{
    ULONG           ulAllocFlags;
    LPBufInternal   pLink;
} BufInternal;


//  Values for ulAllocFlags. This dword contains two kinds of
//  information:
//  =   In the high-order word, flags telling whether or not
//      the block is the head of an allocation chain, and whether
//      the block contains additional debugging information.
//  =   In the low-order word, an enum telling which heap
//      it was allocated from.

#define ALLOC_WITH_ALLOC        ((ULONG) 0x10000000)
#define ALLOC_WITH_ALLOC_MORE   ((ULONG) 0x20000000)
#define FLAGSMASK               ((ULONG) 0xFFFF0000)
#define GetFlags(_fl)           ((ULONG) (_fl) & FLAGSMASK)

//  Conversion macros

#define INT_SIZE(a) ((a) + sizeof(BufInternal))

#define LPBufExtFromLPBufInt(PBUFINT) \
    ((LPVOID)(((LPBYTE)PBUFINT) + sizeof(BufInternal)))

#define LPBufIntFromLPBufExt(PBUFEXT) \
    ((LPBufInternal)(((LPBYTE)PBUFEXT) - sizeof(BufInternal)))


#ifdef DEBUG

#define TellBadBlock(_p, _s)  \
    { DOUT("MAPIAlloc: memory block [%#08lx] %s", _p, _s); \
      AssertSz(0, "Bad memory block"); }

#define TellBadBlockInt(_p, _s)  \
    { DOUT("MAPIAlloc: memory block [%#08lx] %s", LPBufExtFromLPBufInt(_p), _s); \
      AssertSz(0, "Bad memory block"); }

BOOL FValidAllocChain(LPBufInternal lpBuf);

#else

#define TellBadBlock(_p, _s)
#define TellBadBlockInt(_p, _s)

#endif // DEBUG

SCODE SMAPIAllocateBuffer(ULONG ulSize, LPVOID * lppv);
SCODE SMAPIAllocateMore(ULONG ulSize, LPVOID lpv, LPVOID * lppv);

#endif // _SMAPIMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\enginit.cpp ===
// --------------------------------------------------------------------------------
// Enginit.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spengine.h"
#include "ourguid.h"

HANDLE hSmapiEvent; // Added for Bug# 62129 (v-snatar)

// --------------------------------------------------------------------------------
// SAFECLOSEHANDLE
// --------------------------------------------------------------------------------
#ifndef WIN16
#define SAFECLOSEHANDLE(_handle) \
    if (NULL != _handle) { \
        CloseHandle(_handle); \
        _handle = NULL; \
    }
#else
#define SAFECLOSEHANDLE(_handle) \
    if (NULL != _handle) { \
        CloseEvent(_handle); \
        _handle = NULL; \
    }
#endif
// --------------------------------------------------------------------------------
// ENGINECREATEINFO
// --------------------------------------------------------------------------------
typedef struct tagENGINECREATEINFO {
    HEVENT              hEvent;                 // Event used to synchronize creation
    HRESULT             hrResult;               // Result from SpoolEngineThreadEntry
    PFNCREATESPOOLERUI  pfnCreateUI;            // Function to create the spooler ui object
    CSpoolerEngine     *pSpooler;               // Spooler Engine
    BOOL                fPoll;                  // Whether or not to poll
} ENGINECREATEINFO, *LPENGINECREATEINFO;

// --------------------------------------------------------------------------------
// SpoolerEngineThreadEntry
// --------------------------------------------------------------------------------
#ifndef WIN16
DWORD SpoolerEngineThreadEntry(LPDWORD pdwParam);
#else
unsigned int __stdcall LOADDS_16 SpoolerEngineThreadEntry(LPDWORD pdwParam);
#endif
HTHREAD hThread = NULL;

// --------------------------------------------------------------------------------
// CreateThreadedSpooler
// --------------------------------------------------------------------------------
HRESULT CreateThreadedSpooler(PFNCREATESPOOLERUI pfnCreateUI, ISpoolerEngine **ppSpooler,
                              BOOL fPoll)
{
    // Locals
    HRESULT             hr=S_OK;
    HTHREAD             hThread=NULL;
    DWORD               dwThreadId;
    ENGINECREATEINFO    rCreate;

    // Invalid Arg
    if (NULL == ppSpooler)
        return TrapError(E_INVALIDARG);

    // Initialize the Structure
    ZeroMemory(&rCreate, sizeof(ENGINECREATEINFO));

    rCreate.hrResult = S_OK;
    rCreate.pfnCreateUI = pfnCreateUI;
    rCreate.fPoll = fPoll;

    // Create an Event to synchonize creation
    rCreate.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == rCreate.hEvent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Added Bug# 62129 (v-snatar)
    hSmapiEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Create the inetmail thread
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SpoolerEngineThreadEntry, &rCreate, 0, &dwThreadId);
    if (NULL == hThread)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Wait for SpoolEngineThreadEntry to signal the event
    WaitForSingleObject_16(rCreate.hEvent, INFINITE);

    // Failure
    if (FAILED(rCreate.hrResult))
    {
        hr = TrapError(rCreate.hrResult);
        goto exit;
    }

    // Return the object
    Assert(rCreate.pSpooler);
    *ppSpooler = (ISpoolerEngine *)rCreate.pSpooler;
    rCreate.pSpooler->m_hThread = hThread;

exit:
    // Cleanup
    SAFECLOSEHANDLE(rCreate.hEvent);
    SafeRelease(rCreate.pSpooler);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CloseThreadedSpooler
// ------------------------------------------------------------------------------------
HRESULT CloseThreadedSpooler(ISpoolerEngine *pSpooler)
{
    // Locals
    DWORD       dwThreadId;
    HTHREAD      hThread;

    // Invalid Arg
    if (NULL == pSpooler)
        return TrapError(E_INVALIDARG);

    // Get the Thread Info
    pSpooler->GetThreadInfo(&dwThreadId, &hThread);

    // Assert
    Assert(dwThreadId && hThread);

    // Post quit message
    PostThreadMessage(dwThreadId, WM_QUIT, 0, 0);

    // Wait for event to become signaled
    WaitForSingleObject(hThread, INFINITE);

    // Close the thread handle
    CloseHandle(hThread);

    // Close the Event Created for Simple MAPI purposes
    // Bug #62129 (v-snatar)

    CloseHandle(hSmapiEvent);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// SpoolerEngineThreadEntry
// --------------------------------------------------------------------------------
#ifndef WIN16
DWORD SpoolerEngineThreadEntry(LPDWORD pdwParam) 
#else
unsigned int __stdcall LOADDS_16 SpoolerEngineThreadEntry(LPDWORD pdwParam)
#endif
{  
    // Locals
    MSG                     msg;
    HWND                    hwndUI;
    CSpoolerEngine         *pSpooler=NULL;
    ISpoolerUI             *pUI=NULL;
    LPENGINECREATEINFO      pCreate;

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPENGINECREATEINFO)pdwParam;

    // Initialize COM
    pCreate->hrResult = OleInitialize(NULL);
    if (FAILED(pCreate->hrResult))
    {
        TrapError(pCreate->hrResult);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // Create the Spooler UI
    if (pCreate->pfnCreateUI)
    {
        // Create the UI Object
        pCreate->hrResult = (*pCreate->pfnCreateUI)(&pUI);
        if (FAILED(pCreate->hrResult))
        {
            CoUninitialize();
            TrapError(pCreate->hrResult);
            SetEvent(pCreate->hEvent);
            return 0;
        }
    }

    // Create a Spooler Object
    pCreate->pSpooler = new CSpoolerEngine;
    if (NULL == pCreate->pSpooler)
    {
        CoUninitialize();
        pCreate->hrResult = TrapError(E_OUTOFMEMORY);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // Initialize the Spooler Engine
    pCreate->hrResult = pCreate->pSpooler->Init(pUI, pCreate->fPoll);
    if (FAILED(pCreate->hrResult))
    {
        CoUninitialize();
        TrapError(pCreate->hrResult);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // No UI Yet ?
    if (NULL == pUI)
    {
        // Get the spooler UI object
        SideAssert(SUCCEEDED(pCreate->pSpooler->BindToObject(IID_ISpoolerUI, (LPVOID *)&pUI)));
    }

    // I want to hold onto the spooler
    pSpooler = pCreate->pSpooler;
    pSpooler->AddRef();

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // Give the message to the UI object
        if (pUI->IsDialogMessage(&msg) == S_FALSE && pSpooler->IsDialogMessage(&msg) == S_FALSE)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Raid 67816: OE:TW:Error message stop responding after OE is closed.
    // If a dialog was displayed when the above message loop broke out, then that dialog will
    // have automatically gone away and left the spooler UI window disabled!
    pUI->GetWindow(&hwndUI);
    EnableWindow(hwndUI, TRUE);

    // Shutdown the spooler
    pSpooler->Shutdown();

    // Release the UI Object
    pUI->Close();
    pUI->Release();

    // Release
    pSpooler->Release();

    // Deinit COM
    OleUninitialize();

    // Done
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\tipday.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     TipDay.cpp
//
//  PURPOSE:    Implements the CTipOfTheDay object
//

#include "pch.hxx"
#include "strconst.h"
#include "resource.h"
#include "fldrview.h"
#include "tipday.h"
#include "hotlinks.h"


#ifdef WIN16
// At this moment, these definitions are restricted to this file only
#define GetProp     GetProp32
#define SetProp     SetProp32
#define RemoveProp  RemoveProp32

#define BS_NOTIFY   0L
#endif


CTipOfTheDay::CTipOfTheDay()
    {
    m_cRef = 1;
    m_hwnd = 0;
    m_hwndParent = 0;
    m_hwndNext = 0;
    
    m_ftType = FOLDER_TYPESMAX;
    m_szTitle[0] = 0;
    m_szNextTip[0] = 0;
    
    m_pszTip = NULL;
    m_dwCurrentTip = 0;
    
    m_clrBack = 0;
    m_clrText = RGB(255, 255, 255);
    m_clrLink = RGB(255, 255, 255);
    m_hfLink = 0;
    m_hfTitle = 0;
    m_hfTip = 0;
    m_cyTitleHeight = TIP_ICON_HEIGHT;
    m_cxTitleWidth = 0;
    m_hbrBack = 0;
    }


CTipOfTheDay::~CTipOfTheDay()
    {
    if (IsWindow(m_hwnd))
        {
        AssertSz(!IsWindow(m_hwnd), _T("CTipOfTheDay::~CTipOfTheDay() - The ")
                 _T("tip window should have already been destroyed."));
        DestroyWindow(m_hwnd); 
        }
    
    SafeMemFree(m_pszTip);
    FreeLinkInfo();
    
    if (m_hfLink)
        DeleteFont(m_hfLink);
    if (m_hfTitle)
        DeleteFont(m_hfTitle);
    if (m_hfTip)
        DeleteFont(m_hfTip);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
    
    UnregisterClass(c_szTipOfTheDayClass, g_hLocRes /* g_hInst*/);
    UnregisterClass(BUTTON_CLASS, g_hLocRes /* g_hInst*/);
    }


ULONG CTipOfTheDay::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CTipOfTheDay::Release(void)
    {
    ULONG cRef = m_cRef--;
    
    if (m_cRef == 0)
        delete this;
    
    return (cRef);    
    }    

//
//  FUNCTION:   CTipOfTheDay::HrCreate()
//
//  PURPOSE:    Creates the TipOfTheDay control.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that will be the parent of
//                        the control.
//      <in> ftType     - Type of folder this is for.
//
//  RETURN VALUE:
//      E_UNEXPECTED  - Failed to register a required window class
//      E_OUTOFMEMORY - Could not create the window
//      S_OK          - Everything succeeded.
//
HRESULT CTipOfTheDay::HrCreate(HWND hwndParent, FOLDER_TYPE ftType)
    {
#ifndef WIN16
    WNDCLASSEX wc;
#else
    WNDCLASS wc;
#endif
    
    m_hwndParent = hwndParent;
    m_ftType = ftType;
    
    // Check to see if we need to register the window class for this control
#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hLocRes /* g_hInst*/, c_szTipOfTheDayClass, &wc))
#else
    if ( !GetClassInfo( g_hLocRes /* g_hInst*/, c_szTipOfTheDayClass, &wc ) )
#endif
        {
        wc.style            = 0;
        wc.lpfnWndProc      = TipWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hLocRes /* g_hInst*/;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = NULL; // CreateSolidBrush(GetSysColor(COLOR_INFOBK));
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szTipOfTheDayClass;
        wc.hIcon            = NULL;
#ifndef WIN16
        wc.hIconSm          = NULL;
        
        if (0 == RegisterClassEx(&wc))
#else
        if ( 0 == RegisterClass( &wc ) )
#endif
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrCreate() - RegiserClassEx() failed."));
            return (E_UNEXPECTED);
            }
        }
    
    // We also want to superclass the buttons so we change change the cursor
    // to the Hand people are used to from their web browser
#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hLocRes /* g_hInst*/, BUTTON_CLASS, &wc))    
        {
        if (GetClassInfoEx(g_hLocRes /* g_hInst*/, _T("Button"), &wc))
#else
    if ( !GetClassInfo( g_hLocRes /* g_hInst*/, BUTTON_CLASS, &wc ) )
        {
        if ( GetClassInfo( NULL, "Button", &wc ) )
#endif
            {
            wc.hCursor = LoadCursor(g_hLocRes, MAKEINTRESOURCE(idcurHand));
            wc.lpszClassName = BUTTON_CLASS;

#ifndef WIN16
            if (0 == RegisterClassEx(&wc))
#else
            wc.hInstance = g_hLocRes /* g_hInst*/;
            if ( 0 == RegisterClass( &wc ) )
#endif
                {
                AssertSz(FALSE, _T("CTipOfTheDay::HrCreate() - RegisterClassEx() failed."));
                return (E_UNEXPECTED);
                }
            }
        }
    
    // Create the tip control window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szTipOfTheDayClass, 
                            _T("Tip of the Day"), WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_CLIPSIBLINGS, 
                            0, 0, 100, 100, hwndParent, (HMENU) IDC_TIPCONTROL, 
                            g_hLocRes, this);
    if (!m_hwnd)
        {
        GetLastError();
        AssertSz(m_hwnd, _T("CTipOfTheDay::HrCreate() - Failed to create window."));
        return (E_OUTOFMEMORY);
        }

    return (S_OK);    
    }


LRESULT CALLBACK EXPORT_16 CTipOfTheDay::TipWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
    {
    CTipOfTheDay *pThis = (CTipOfTheDay *) GetProp(hwnd, TIPINFO_PROP);
    
    switch (uMsg)
        {
        case WM_NCCREATE:
            // Get the this pointer that was passed in
            pThis = (CTipOfTheDay *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            Assert(pThis);
            
            // Stuff the this pointer for the object into a property
            SetProp(hwnd, TIPINFO_PROP, pThis);
            pThis->AddRef();                            // Released in WM_DESTROY
            return (TRUE);
            
        HANDLE_MSG(hwnd, WM_CREATE,         pThis->OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           pThis->OnSize);
        HANDLE_MSG(hwnd, WM_COMMAND,        pThis->OnCommand);
        HANDLE_MSG(hwnd, WM_DRAWITEM,       pThis->OnDrawItem);
        HANDLE_MSG(hwnd, WM_DESTROY,        pThis->OnDestroy);
        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, pThis->OnSysColorChange);        
        HANDLE_MSG(hwnd, WM_PAINT,          pThis->OnPaint);        

        case WM_SETTINGCHANGE:
            pThis->OnSysColorChange(hwnd);
            break;
            
        case WM_SETFOCUS:
            if (pThis && IsWindow(pThis->m_hwndNext))
                SetFocus(pThis->m_hwndNext);
            return (0);
            
        HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, pThis->OnCtlColor);
        }
    
    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


//
//  FUNCTION:   CTipOfTheDay::OnCreate()
//
//  PURPOSE:    Does all of the initialization of the control, including loading
//              the tip string, creating child windows, etc.
//
//  PARAMETERS:
//      <in> hwnd           - Handle of the tip window
//      <in> lpCreateStruct - Information from the CreateWindow() call
//
//  RETURN VALUE:
//      TRUE  - Allows the window to be created
//      FALSE - Prevents the window from being created.
//
BOOL CTipOfTheDay::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
    HRESULT hr;
    
    // First load the tip
    if (FAILED(HrLoadTipInfo()))
        return (FALSE);
    
    // Create the child windows
    if (FAILED(HrCreateChildWindows(hwnd)))
        return (FALSE);
    
    // Load the string we should be using for the title - ie "Tip of the Day"
    AthLoadString(idsTipOfTheDay, m_szTitle, ARRAYSIZE(m_szTitle));    
    m_hiTip = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiTipIcon));
    AthLoadString(idsNextTip, m_szNextTip, ARRAYSIZE(m_szNextTip));
    
    // Build our GDI objects/info
    OnSysColorChange(hwnd);
    
    return (TRUE);
    }


//
//  FUNCTION:   CTipOfTheDay::HrLoadTipInfo()
//
//  PURPOSE:    Loads the appropriate tip string into m_pszTip.
//
//  RETURN VALUE:
//      E_UNEXPECTED - For some reason we couldn't find the string in the registry.
//      E_OUTOFMEMORY - Not enough memory to allocate a buffer to store the string.
//      S_OK - The string was loaded.
//
HRESULT CTipOfTheDay::HrLoadTipInfo(void)
    {
    HKEY    hKeyUser = 0, hKey;
    LPCTSTR pszKey, pszKeyUser;
    TCHAR   szValue[16];
    DWORD   cValues;
    DWORD   cValueLen;
    HRESULT hr = S_OK;
    DWORD   dwType;
    DWORD   cbData;
    
    // Preset some default values first
    m_dwCurrentTip = 0;
    SafeMemFree(m_pszTip);
    
    // First load which tip the user should see next
    if (FOLDER_NEWS == m_ftType)
        pszKeyUser = c_szRegNews;
    else
        pszKeyUser = c_szMailPath;   
    
    // Now load the tip string
    if (FOLDER_NEWS == m_ftType)
        pszKey = c_szRegTipStringsNews;
    else
        pszKey = c_szRegTipStringsMail;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey))
        {
        if (ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, 0, 0, NULL, NULL, NULL, 
                                             &cValues, NULL, &cValueLen, NULL, NULL))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - Failed call to RegQueryInfoKey()."));
            hr = E_UNEXPECTED;
            goto exit;
            }
        
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszKeyUser, 0, 
                                          KEY_READ | KEY_WRITE, &hKeyUser))
            {
            cbData = sizeof(DWORD);
            RegQueryValueEx(hKeyUser, c_szRegCurrentTip, 0, &dwType, (LPBYTE) &m_dwCurrentTip, 
                            &cbData);

            m_dwCurrentTip++;
            if (m_dwCurrentTip > cValues)
                m_dwCurrentTip = 1;
            
            RegSetValueEx(hKeyUser, c_szRegCurrentTip, 0, REG_DWORD, (const LPBYTE)  
                          &m_dwCurrentTip, sizeof(DWORD));
            RegCloseKey(hKeyUser);        
            }
        else
            m_dwCurrentTip++;    
            
        // Allocate the buffer for the string
        if (!MemAlloc((LPVOID*) &m_pszTip, sizeof(TCHAR) * (cValueLen + 1)))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - MemAlloc() failed."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
            
        // Now load the actual tip string    
        wnsprintf(szValue, ARRAYSIZE(szValue), _T("%d"), m_dwCurrentTip);        
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, 0, &dwType, 
                                             (LPBYTE) m_pszTip, &cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - Failed to load tip string."));
            hr = E_UNEXPECTED;
            goto exit;
            }
        
        RegCloseKey(hKey);    
        }
    
    return (hr);       
    
exit:
    SafeMemFree(m_pszTip);
    RegCloseKey(hKey);
    
    return (hr);
    }


//
//  FUNCTION:   CTipOfTheDay::HrLoadLinkInfo()
//
//  PURPOSE:    Loads the links that we will display at the bottom of our page
//              into the m_rgLinkInfo array.
//
//  RETURN VALUE:
//      E_UNEXPECTED - For some reason we failed to find the link information
//                     in the registry.
//      E_OUTOFMEMORY - Not enough memory to allocate m_rgLinkInfo.
//      S_OK - m_rgLinkInfo and m_cLinks are set correctly.
//
HRESULT CTipOfTheDay::HrLoadLinkInfo(void)
    {
#if 0
    HKEY    hKey;
    LPCTSTR pszKey;
    DWORD   cValues;
    DWORD   cValueLen;
    DWORD   iLink;
    DWORD   iLinkIndex;
    HRESULT hr = S_OK;
    DWORD   dwType;
    DWORD   cbData;
    TCHAR   szValue[64];
    
    // Open the appropriate key for the tip links
    if (FOLDER_NEWS == m_ftType)
        pszKey = c_szRegTipLinksNews;
    else
        pszKey = c_szRegTipLinksMail;   
    
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey))
        return (E_UNEXPECTED);
    
    // Get the number of values in this key
    if (ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, 0, 0, NULL, NULL, NULL, 
                                         &cValues, NULL, &cValueLen, NULL, NULL))
        {
        AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed call to RegQueryInfoKey()."));
        hr = E_UNEXPECTED;
        goto exit;
        }
    
    // There should always be an even number of values in this key since each
    // link should have a link text and link addr value.
    m_cLinks = (cValues / 2) + (cValues % 2);
    Assert(0 == (cValues % 2));
    
    // Allocate the m_rgLinkInfo array.  If the below assert fails, we are 
    // leaking the m_rgLinkInfo array.
    AssertSz(NULL == m_rgLinkInfo, _T("CTipOfTheDay::HrLoadLinkInfo() - We should only call this once."));
    
    if (!MemAlloc((LPVOID *) &m_rgLinkInfo, sizeof(LINKINFO) * m_cLinks))
        {
        AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
        hr = E_OUTOFMEMORY;
        goto exit;
        }
    ZeroMemory(m_rgLinkInfo, sizeof(LINKINFO) * m_cLinks);    
    
    // Loop through the items and load each string
    iLink = 0;
    for (iLinkIndex = 1; iLinkIndex <= m_cLinks; iLinkIndex++)
        {
        // Allocate the link text array
        if (!MemAlloc((LPVOID*) &(m_rgLinkInfo[iLink].pszLinkText), cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
            
        // Allocate the link address array
        if (!MemAlloc((LPVOID*) &(m_rgLinkInfo[iLink].pszLinkAddr), cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
        
        // Load the link text
        wnsprintf(szValue, ARRAYSIZE(szValue), c_szRegLinkText, iLinkIndex);
        cbData = cValueLen;
        m_rgLinkInfo[iLink].pszLinkText[0] = 0;
        RegQueryValueEx(hKey, szValue, 0, &dwType, (LPBYTE) m_rgLinkInfo[iLink].pszLinkText, &cbData);
        Assert(0 != lstrlen(m_rgLinkInfo[iLink].pszLinkText));

        // Load the link addr
        wnsprintf(szValue, ARRAYSIZE(szValue), c_szRegLinkAddr, iLinkIndex);
        cbData = cValueLen;
        m_rgLinkInfo[iLink].pszLinkAddr[0] = 0;
        RegQueryValueEx(hKey, szValue, 0, &dwType, (LPBYTE) m_rgLinkInfo[iLink].pszLinkAddr, &cbData);
        Assert(0 != lstrlen(m_rgLinkInfo[iLink].pszLinkAddr));
        
        // Make sure we have values.  If not, we dump this data and go on.
        if (0 == lstrlen(m_rgLinkInfo[iLink].pszLinkAddr) || 
            0 == lstrlen(m_rgLinkInfo[iLink].pszLinkText))
            {
            SafeMemFree(m_rgLinkInfo[iLink].pszLinkText);
            SafeMemFree(m_rgLinkInfo[iLink].pszLinkAddr);            
            }
        else        
            iLink++;    
        }
    
    // Store the number of links we actually loaded.
    m_cLinks = iLink;    
    RegCloseKey(hKey);
    return (hr);
    
exit:    
    // Free the linkinfo array
    FreeLinkInfo();
    
    // Close the registry
    RegCloseKey(hKey);
    return (hr);

#endif
    return (E_NOTIMPL);
    }


//
//  FUNCTION:   CTipOfTheDay::FreeLinkInfo()
//
//  PURPOSE:    Frees the m_rgLinkInfo array.
//
void CTipOfTheDay::FreeLinkInfo(void)
    {
#if 0
    if (m_rgLinkInfo && m_cLinks)
        {
        for (DWORD i = 0; i < m_cLinks; i++)
            {
            SafeMemFree(m_rgLinkInfo[i].pszLinkText);
            SafeMemFree(m_rgLinkInfo[i].pszLinkAddr);            
            }
        
        SafeMemFree(m_rgLinkInfo);
        m_cLinks = 0;
        }
#endif
    }


//
//  FUNCTION:   CTipOfTheDay::HrCreateChildWindows()
//
//  PURPOSE:    Creates the child windows needed for the tip and the link 
//              buttons.
//
//  RETURN VALUE:
//      E_OUTOFMEMORY - Could not create the tip window
//      S_OK - Everything was created OK
//
HRESULT CTipOfTheDay::HrCreateChildWindows(HWND hwnd)
    {
    // Create the "Next Tip" button
    m_hwndNext = CreateWindowEx(WS_EX_TRANSPARENT, BUTTON_CLASS, m_szNextTip,
                                WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP | WS_VISIBLE, 
                                0, 0, 10, 10, hwnd, 
                                (HMENU) IDC_NEXTTIP_BUTTON, g_hLocRes, 0);

    return (S_OK);    
    }


//
//  FUNCTION:   CTipOfTheDay::OnDestroy()
//
//  PURPOSE:    This is sent as the tip control is being destroyed.  In
//              response, we remove the properties we set on any of our
//              windows, including the link buttons.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the tip control.
//
void CTipOfTheDay::OnDestroy(HWND hwnd)
    {
#if 0
    // Loop through the tip windows removing their properties
    for (DWORD i = 0; i < m_cLinks; i++)
        {
        Assert(IsWindow(m_rgLinkInfo[i].hwndCtl));
        RemoveProp(m_rgLinkInfo[i].hwndCtl, LINKINFO_PROP);
        }
#endif
    
    // Now remove and Release() our 'this' pointer.  These were AddRef()'d
    // in WM_NCCREATE.
    Assert(IsWindow(m_hwnd));
    RemoveProp(m_hwnd, TIPINFO_PROP);
    Release();
    }


//
//  FUNCTION:   CTipOfTheDay::OnDrawItem()
//
//  PURPOSE:    Draws the link buttons
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the tip control window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
void CTipOfTheDay::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText;
    UINT     uAlign;
    HFONT    hf;
    RECT     rcBtn;
    int      yText;
    LPTSTR   pszText;
    
    Assert(lpDrawItem->CtlType == ODT_BUTTON);
    Assert(lpDrawItem->CtlID >= IDC_LINKBASE_BUTTON || 
           lpDrawItem->CtlID == IDC_NEXTTIP_BUTTON);
    
    // Get the LINKINFO struct from the button prop
    if (lpDrawItem->CtlID == IDC_NEXTTIP_BUTTON)
        pszText = m_szNextTip;
    else
        {
        PLINKINFO pLinkInfo = (PLINKINFO) GetProp(lpDrawItem->hwndItem, LINKINFO_PROP);
        Assert(pLinkInfo);
        Assert(pLinkInfo->hwndCtl == lpDrawItem->hwndItem);
        
        pszText = pLinkInfo->pszLinkText;        
        }
    
    // Set up the DC
    SetBkMode(hdc, TRANSPARENT);
    clrText = SetTextColor(hdc, m_clrLink);
    hf = SelectFont(hdc, m_hfLink);
    
    // Draw the text
    FillRect(hdc, &lpDrawItem->rcItem, m_hbrBack);
    rcBtn = lpDrawItem->rcItem;
    DrawText(hdc, pszText, lstrlen(pszText), &rcBtn, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        
    // Check to see if we should have a focus rect
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        InflateRect(&rcBtn, -1, -1);
        DrawFocusRect(hdc, &rcBtn);
        }
    
    // Restore the DC
    SetTextColor(hdc, clrText);
    SelectFont(hdc, hf);
    }


//
//  FUNCTION:   CTipOfTheDay::OnSysColorChange()
//
//  PURPOSE:    Reloads our colors and fonts to match the system settings.
//
void CTipOfTheDay::OnSysColorChange(HWND hwnd)
    {
    NONCLIENTMETRICS ncm;
    HDC hdc;
    HFONT hf;
    SIZE size;

#ifndef WIN16
    // Get the colors that we need
#if 1
    m_clrBack = GetSysColor(COLOR_INFOBK);
    m_clrText = GetSysColor(COLOR_INFOTEXT);
#else
    m_clrBack = GetSysColor(COLOR_BTNFACE);    
    m_clrText = GetSysColor(COLOR_BTNTEXT);
#endif
#else //!WIN16
    m_clrBack = GetSysColor(COLOR_BTNFACE);    
    m_clrText = GetSysColor(COLOR_BTNTEXT);
#endif //!WIN16

    // Get the border size
    m_dwBorder = GetSystemMetrics(SM_CXBORDER) * 8;

    if (!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = m_clrText;
    
    // Get a new background brush
    if (m_hbrBack)
        {
        DeleteBrush(m_hbrBack);
        m_hbrBack = 0;
        }
    m_hbrBack = CreateSolidBrush(m_clrBack);
    
    // Get the fonts
    ZeroMemory(&ncm, sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);

#ifndef WIN16
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
#else
    {
        HFONT  hfSys;
        hfSys = (HFONT)GetStockObject( ANSI_VAR_FONT );
        GetObject( hfSys, sizeof( LOGFONT ), &ncm.lfMessageFont );
    }
#endif
        {
        m_hfTip = CreateFontIndirect(&ncm.lfMessageFont);
        
        ncm.lfMessageFont.lfUnderline = TRUE;
        m_hfLink = CreateFontIndirect(&ncm.lfMessageFont);

        // Adjust the font for the title text
        ncm.lfMessageFont.lfHeight = -16;
        ncm.lfMessageFont.lfWeight = FW_BOLD;
        ncm.lfMessageFont.lfUnderline = FALSE;
        m_hfTitle = CreateFontIndirect(&ncm.lfMessageFont);
        
        // Get the text metrics as well
        hdc = GetDC(m_hwnd);
        
        hf = SelectFont(hdc, m_hfLink);
        GetTextMetrics(hdc, &m_tmLink);        
        SelectFont(hdc, m_hfTitle);
        GetTextMetrics(hdc, &m_tmTitle);
        
        // Calculate how big the title area is
        GetTextExtentPoint32(hdc, m_szTitle, lstrlen(m_szTitle), &size);
        m_cxTitleWidth = TIP_ICON_WIDTH + (1 * m_dwBorder);
        m_cyTitleHeight = max(TIP_ICON_HEIGHT, m_tmTitle.tmHeight * 2) + (2 * m_dwBorder);

        SelectFont(hdc, hf);
        ReleaseDC(m_hwnd, hdc);
        }
    
    InvalidateRect(hwnd, NULL, TRUE);    
    }


//
//  FUNCTION:   CTipOfTheDay::OnCommand()
//
//  PURPOSE:    Used to handle commands from our controls.  More specificly,
//              we launch URL's when the user clicks a button link.
//
void CTipOfTheDay::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    SHELLEXECUTEINFO rShellExec;
    PLINKINFO pLinkInfo;
    RECT rcClient;
    
    switch (codeNotify)
        {
        // The user clicked on one of our links.  We need to launch the URL.
        case BN_CLICKED:
            if (IDC_NEXTTIP_BUTTON == id)
                {
                if (SUCCEEDED(HrLoadTipInfo()))
                    {
                    InvalidateRect(hwnd, NULL, TRUE);
                    }
                }
            else
                {
                // First get the PLINKINFO for the button
                if (NULL == (pLinkInfo = (PLINKINFO) GetProp(hwndCtl, LINKINFO_PROP)))
                    return;
                    
                ZeroMemory (&rShellExec, sizeof (rShellExec));
                rShellExec.cbSize = sizeof (rShellExec);
                rShellExec.fMask  = SEE_MASK_NOCLOSEPROCESS;
                rShellExec.hwnd   = GetParent(m_hwnd);
                rShellExec.nShow  = SW_SHOWNORMAL;
                rShellExec.lpFile = pLinkInfo->pszLinkAddr;
                rShellExec.lpVerb = NULL; // i.e. "Open"
                ShellExecuteEx (&rShellExec);              
                }
                
            return;
        }
    
    return;    
    }


//
//  FUNCTION:   CTipOfTheDay::OnSize()
//
//  PURPOSE:    Handles moving and sizing our child windows when the control
//              size is changed.
//
//  PARAMETERS:
//      <in> hwnd   - Handle of the control window.
//      <in> state  - Type of sizing that occured.
//      <in> cx, cy - New width and height of the client area.
//
void CTipOfTheDay::OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
    HFONT hf;
    SIZE  size;
    HDC   hdc;
    DWORD i;
    RECT  rc;
    BOOL  fShow = FALSE;
    
    m_cyNextHeight = m_tmLink.tmHeight + (2 * LINK_BUTTON_BORDER);

    hdc = GetDC(m_hwnd);
    hf = SelectFont(hdc, m_hfLink);

    // Position the "Next Tip" button in the bottom right corner
    if (GetTextExtentPoint32(hdc, m_szNextTip, lstrlen(m_szNextTip), &size))
        m_cxNextWidth = size.cx + (2 * LINK_BUTTON_BORDER);
    else
        m_cxNextWidth = 0;
            
    // If the "Next Tip" button would overlap the title, then hide it
    fShow = ((int)(cx - m_dwBorder - m_cxNextWidth) > (int) m_cxTitleWidth);
    ShowWindow(m_hwndNext, fShow ? SW_SHOW : SW_HIDE);

    SetWindowPos(m_hwndNext, 0, cx - m_dwBorder - m_cxNextWidth, 
                 cy - m_dwBorder - m_cyNextHeight,                 
                 m_cxNextWidth, m_cyNextHeight, SWP_NOACTIVATE | SWP_NOZORDER);
                 
    SelectFont(hdc, hf);
    ReleaseDC(m_hwnd, hdc);    

    // Calculate the new rectangle for the tip text
    m_rcTip.left   = m_cxTitleWidth + m_dwBorder;
    m_rcTip.top    = m_dwBorder;
    m_rcTip.right  = cx - (2 * m_dwBorder) - m_cxNextWidth; 
    m_rcTip.bottom = cy - m_dwBorder;

    SetRect(&rc, m_cxTitleWidth + m_dwBorder, 0, cx, cy);
    InvalidateRect(hwnd, &rc, TRUE);
    }


//
//  FUNCTION:   CTipOfTheDay::GetRequiredWidth()
//
//  PURPOSE:    Returns the minimum width the control requires to display 
//              itself correctly.
//
//  RETURN VALUE:
//      Returns the minimum width required for the control in pixels.
//
DWORD CTipOfTheDay::GetRequiredWidth(void)
    {
    // No longer used
    return (0);
    }


//
//  FUNCTION:   CTipOfTheDay::GetRequiredWidth()
//
//  PURPOSE:    Returns the minimum width the control requires to display 
//              itself correctly.
//
//  RETURN VALUE:
//      Returns the minimum width required for the control in pixels.
//
DWORD CTipOfTheDay::GetRequiredHeight(void)
    {
    return (m_cyTitleHeight);
    }


void CTipOfTheDay::OnPaint(HWND hwnd)
    {
    PAINTSTRUCT ps;
    HDC         hdc;
    HFONT       hf;
    COLORREF    clrBack;
    COLORREF    clrText;
    UINT        uAlign;
    RECT        rc;
    RECT        rcClient;
    
    GetClientRect(m_hwnd, &rcClient);
    hdc = BeginPaint(hwnd, &ps);
    
    // See if we need to erase the background
    if (ps.fErase)
        {
        FillRect(hdc, &ps.rcPaint, m_hbrBack);
        }
    
    // Set up the DC
    clrBack = SetBkColor(hdc, m_clrBack);
    clrText = SetTextColor(hdc, m_clrText);
    SetBkMode(hdc, TRANSPARENT);
    uAlign = SetTextAlign(hdc, TA_TOP);
    hf = SelectFont(hdc, m_hfTitle);
    
    // Draw the tip icon
    DrawIcon(hdc, m_dwBorder, max(((m_cyTitleHeight - 32) / 2), 0), m_hiTip);
    
    // A little line to make it look nice
    MoveToEx(hdc, m_cxTitleWidth, m_dwBorder, NULL);
    LineTo(hdc, m_cxTitleWidth, m_cyTitleHeight - m_dwBorder);
    
    // Figure out how big the "Tip of the Day" rect is going to be
    rc.left = TIP_ICON_WIDTH + m_dwBorder;
    rc.top = m_dwBorder;
    rc.right = m_cxTitleWidth - m_dwBorder;
    rc.bottom = m_cyTitleHeight;
    
    // "Tip of the Day" title
//    DrawText(hdc, m_szTitle, lstrlen(m_szTitle), &rc, DT_CENTER | DT_NOPREFIX | DT_NOCLIP | DT_WORDBREAK);

    // Draw the tip text
    SelectFont(hdc, m_hfTip);
    rc = m_rcTip;
    rc.right = rcClient.right;
    FillRect(hdc, &rc, m_hbrBack);
    DrawText(hdc, m_pszTip, lstrlen(m_pszTip), &m_rcTip, DT_CENTER | DT_NOPREFIX | DT_WORDBREAK);
    
    // Restore the DC
    SetBkColor(hdc, clrBack);
    SetTextColor(hdc, clrText);
    SetTextAlign(hdc, uAlign);
    SelectFont(hdc, hf);

    EndPaint(hwnd, &ps);
    }


HBRUSH CTipOfTheDay::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
    {
    Assert(type == CTLCOLOR_STATIC);
    
    SetBkColor(hdc, m_clrBack);
    SetTextColor(hdc, m_clrText);
    SetBkMode(hdc, TRANSPARENT);
    return (m_hbrBack);
    }


//////////////////////////////////////////////////////////////////////////////

CLinkButton::CLinkButton()
    {
    m_cRef = 1;
    m_hwnd = 0;
    m_hwndParent = 0;

    m_pszCaption = NULL;
    m_pszLink = NULL;

    m_clrLink = RGB(0, 0, 0);
    m_clrBack = RGB(255, 255, 255);
    m_hfLink = NULL;
    ZeroMemory(&m_tmLink, sizeof(TEXTMETRIC));
    m_hbrBack = NULL;

    m_dwBorder = 0;
    m_cxWidth = 0;
    m_cyHeight = 0;

    m_cxImage = 0;
    m_cyImage = 0;

#ifdef WIN16
    m_hbmButtons = NULL;
#endif
    }

CLinkButton::~CLinkButton()
    {
    if (m_hfLink)
        DeleteFont(m_hfLink);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
#if IMAGELIST
    if (m_himl)
        ImageList_Destroy(m_himl);
#endif

    SafeMemFree(m_pszCaption);
    SafeMemFree(m_pszLink);
    }

ULONG CLinkButton::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CLinkButton::Release(void)
    {
    ULONG cRef = m_cRef--;
    
    if (m_cRef == 0)
        delete this;
    
    return (cRef);    
    }    

//
//  FUNCTION:   CLinkButton::HrCreate()
//
//  PURPOSE:    Creates the owner drawn button and initializes the class 
//              members with the correct caption and link information.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the button's parent window
//      <in> pszCaption - Text to display on the button
//      <in> pszLink    - URL to execute when the user clicks on the button
//      <in> uID        - Command ID for the button
//
//  RETURNS:
//      Returns S_OK if everything succeeds.
//
HRESULT CLinkButton::HrCreate(HWND hwndParent, LPTSTR pszCaption, LPTSTR pszLink,
                              UINT uID)
    {
    Assert(IsWindow(hwndParent));
    Assert(pszCaption);
    Assert(pszLink);

    // Copy down the provided information
    m_hwndParent = hwndParent;
    m_pszCaption = PszDup(pszCaption);
    m_pszLink = PszDup(pszLink);
    m_uID = uID;

    // Create the button window
    m_hwnd = CreateWindowEx(0, BUTTON_CLASS, m_pszCaption,
                            WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE 
                            | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP, 
                            0, 0, 10, 10, hwndParent, (HMENU) uID, g_hLocRes, 0);

    if (!m_hwnd)
        return (E_OUTOFMEMORY);

    // Set our this pointer as a property of the button so we can retrieve
    // it later
    SetProp(m_hwnd, LINKINFO_PROP, this);

    // Subclass the button so we can clean ourselves up correctly when it 
    // gets destroyed
    WNDPROC pfn = (WNDPROC) SetWindowLong(m_hwnd, GWL_WNDPROC, 
                                          (LONG) ButtonSubClass);
    SetProp(m_hwnd, WNDPROC_PROP, pfn);

    OnSysColorChange();
    
    return (S_OK);
    }


//
//  FUNCTION:   CLinkButton::HrCreate()
//
//  PURPOSE:    Creates the owner drawn button and initializes the class 
//              members with the correct caption and link information.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the button's parent window
//      <in> pszCaption - Text to display on the button
//      <in> uID        - Command ID for the button
//      <in> idBmp      - Id for the bitmap that contains the button image
//      <in> index      - Index of the image in idBmp for this button
//
//  RETURNS:
//      Returns S_OK if everything succeeds.
//
HRESULT CLinkButton::HrCreate(HWND hwndParent, LPTSTR pszCaption, UINT uID, 
                              UINT index, HBITMAP hbmButton, HBITMAP hbmMask, HPALETTE hpal)
    {
    Assert(IsWindow(hwndParent));
    Assert(pszCaption);
    Assert(uID);

    // Copy down the provided information
    m_hwndParent = hwndParent;
    m_pszCaption = PszDup(pszCaption);
    m_uID = uID;
    m_index = index;

    m_cxImage = CX_BUTTON_IMAGE;
    m_cyImage = CY_BUTTON_IMAGE;

    m_hbmButtons = hbmButton;
    m_hbmMask = hbmMask;
    m_hpalButtons = hpal;

    // Create the button window
    m_hwnd = CreateWindowEx(0, BUTTON_CLASS, m_pszCaption,
                            WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE 
                            | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP, 
                            0, 0, 10, 10, hwndParent, (HMENU) uID, g_hLocRes, 0);

    if (!m_hwnd)
        return (E_OUTOFMEMORY);

    // Set our this pointer as a property of the button so we can retrieve
    // it later
    SetProp(m_hwnd, LINKINFO_PROP, this);

    // Subclass the button so we can clean ourselves up correctly when it 
    // gets destroyed
    WNDPROC pfn = (WNDPROC) SetWindowLong(m_hwnd, GWL_WNDPROC, 
                                          (LONG) ButtonSubClass);
    SetProp(m_hwnd, WNDPROC_PROP, pfn);

    OnSysColorChange();
    
    return (S_OK);
    }

//
//  FUNCTION:   CLinkButton::OnDrawItem()
//
//  PURPOSE:    Draws the link button
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the tip control window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
#define ROP_PatMask     0x00E20746      // D <- S==1 ? P : D
#define DESTINATION     0x00AA0029
void CLinkButton::OnDraw(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText, clrBack;
    UINT     uAlign;
    HFONT    hf;
    RECT     rcBtn;
    int      yText;
    HBRUSH   hbr;
    HPALETTE hpalOld;
    
    Assert(lpDrawItem->CtlType == ODT_BUTTON);
    Assert(lpDrawItem->CtlID == m_uID);
    
    // Set up the DC    
    clrText = SetTextColor(hdc, m_clrLink);
    clrBack = SetBkColor(hdc, m_clrBack);
    hf = SelectFont(hdc, m_hfLink);
    
    // Draw the text
    rcBtn = lpDrawItem->rcItem;
    FillRect(hdc, &rcBtn, m_hbrBack);

    // If there was an image set, then draw that first
#if IMAGELIST
    if (m_himl)
        {
        ImageList_Draw(m_himl, m_index, hdc, rcBtn.left, rcBtn.top, ILD_TRANSPARENT);
        rcBtn.top += m_cyImage;
        }
#endif

    // If we're supposed to paint button images, do so now
    if (m_hbmButtons)
        {
        HBRUSH  hbrWhite;
        HDC     hdcMem;
        HBITMAP hbmMemOld;
        HBRUSH  hbrOld;
        HDC     hdcMask;
        HBITMAP hbmMaskOld;

        Assert(m_hpalButtons);

        // Select and realize the palette
        hpalOld = SelectPalette(hdc, m_hpalButtons, TRUE);
        RealizePalette(hdc);

        hbrWhite = CreateSolidBrush(0x00FFFFFF);

#ifndef WIN16
        SetTextColor(hdc, RGB(255, 255, 255));
        SetBkColor(hdc, RGB(0, 0, 0));
#else
        SetTextColor( hdc, RGB( 0, 0, 0 ) );
        SetBkColor( hdc, RGB( 255, 255, 255 ) );
#endif
        
        // Set up a memory DC for the button bitmap
        hdcMem = CreateCompatibleDC(hdc);
        hbmMemOld = SelectBitmap(hdcMem, m_hbmButtons);
        hbrOld = SelectBrush(hdcMem, /* hbrWhite */ m_hbrBack);

#if 1
        // Set up a memory DC for the mask
        hdcMask = CreateCompatibleDC(hdc);
        hbmMaskOld = SelectBitmap(hdcMask, m_hbmMask);

        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem,  CX_BUTTON_IMAGE * m_index, 0, SRCINVERT);
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMask, CX_BUTTON_IMAGE * m_index, 0, SRCAND);
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem,  CX_BUTTON_IMAGE * m_index, 0, SRCINVERT);
/*
        // Combine the mask and the button bitmaps
        BitBlt(hdcMem, 0, 0, CX_BUTTON_IMAGE * 6, CY_BUTTON_IMAGE, hdcMask, 0, 0,
               ROP_PatMask);

        // Paint the final button image on the screen
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem, 
               CX_BUTTON_IMAGE * m_index, 0, SRCCOPY);
*/
        // Clean up the mask memory DC
        SelectBitmap(hdcMask, hbmMaskOld);
        DeleteDC(hdcMask);
#else
        MaskBlt(hdc, 
                0, 
                rcBtn.top, 
                CX_BUTTON_IMAGE, 
                CY_BUTTON_IMAGE,
                hdcMem,
                CX_BUTTON_IMAGE * m_index,
                0,
                m_hbmMask,
                CX_BUTTON_IMAGE * m_index,
                0,
                MAKEROP4(DESTINATION, SRCCOPY));
#endif

        // Clean up the button memory DC
        SelectBrush(hdcMem, hbrOld);
        SelectBitmap(hdcMem, hbmMemOld);
        DeleteDC(hdcMem);
        DeleteBrush(hbrWhite);

        // Reset the palette
        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        rcBtn.top += m_cyImage;
        }

    clrText = SetTextColor(hdc, m_clrLink);
    clrBack = SetBkColor(hdc, m_clrBack);
    DrawText(hdc, m_pszCaption, lstrlen(m_pszCaption), &rcBtn, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        
    // Check to see if we should have a focus rect
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        rcBtn = lpDrawItem->rcItem;
        InflateRect(&rcBtn, -1, -1);
        DrawFocusRect(hdc, &rcBtn);
        }
    
    // Restore the DC
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBack);
    SelectFont(hdc, hf);
    }


//
//  FUNCTION:   CLinkButton::OnSysColorChange()
//
//  PURPOSE:    Reloads our colors and fonts to match the system settings.
//
void CLinkButton::OnSysColorChange(void)
    {
    NONCLIENTMETRICS ncm;
    HDC hdc;
    HFONT hf;
    SIZE size;
    COLORREF clrText;

    // Get the colors that we need
    clrText = GetSysColor(COLOR_BTNTEXT);
    if (!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = clrText;

    m_clrBack = GetSysColor(COLOR_WINDOW);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
    m_hbrBack = CreateSolidBrush(m_clrBack);
    
    // Get the border size
    m_dwBorder = GetSystemMetrics(SM_CXBORDER) * 8;
    
    // Get the fonts
    ZeroMemory(&ncm, sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);

#ifndef WIN16
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
#else
    {
        HFONT  hfSys;
        hfSys = (HFONT)GetStockObject( ANSI_VAR_FONT );
        GetObject( hfSys, sizeof( LOGFONT ), &ncm.lfMessageFont );
    }
#endif
        {
        ncm.lfMessageFont.lfUnderline = TRUE;
        m_hfLink = CreateFontIndirect(&ncm.lfMessageFont);

        // Get the text metrics as well
        hdc = GetDC(m_hwnd);
        
        hf = SelectFont(hdc, m_hfLink);
        GetTextMetrics(hdc, &m_tmLink);        
        
        // Calculate how big the link text area is
        GetTextExtentPoint32(hdc, m_pszCaption, lstrlen(m_pszCaption), &size);
        m_cxWidth = max((DWORD) m_cxImage, (DWORD) (size.cx + (2 * LINK_BUTTON_BORDER)));

        // If we have an image, we don't next the extra spacing
        if (m_cyImage)
            m_cyHeight = m_tmLink.tmHeight + m_cyImage + LINK_BUTTON_BORDER;
        else
            m_cyHeight = m_tmLink.tmHeight + (2 * LINK_BUTTON_BORDER);

        SelectFont(hdc, hf);
        ReleaseDC(m_hwnd, hdc);
        }
    
    InvalidateRect(m_hwnd, NULL, TRUE);    
    }

void CLinkButton::Move(DWORD x, DWORD y)
    {
    SetWindowPos(m_hwnd, 0, x, y, m_cxWidth, m_cyHeight, 
                 SWP_NOZORDER | SWP_NOACTIVATE);
    }


void CLinkButton::OnCommand(void)
    {
#ifndef WIN16
    SHELLEXECUTEINFO rShellExec;

    ZeroMemory (&rShellExec, sizeof (rShellExec));
    rShellExec.cbSize = sizeof (rShellExec);
    rShellExec.fMask  = SEE_MASK_NOCLOSEPROCESS;
    rShellExec.hwnd   = m_hwndParent;
    rShellExec.nShow  = SW_SHOWNORMAL;
    rShellExec.lpFile = m_pszLink;
    rShellExec.lpVerb = NULL; // i.e. "Open"
    ShellExecuteEx (&rShellExec);
#else
    RunBrowser( m_pszLink, FALSE );
#endif //!WIN16
    }

void CLinkButton::Show(BOOL fShow)
    {
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    }

LRESULT CALLBACK EXPORT_16 ButtonSubClass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // If the message is WM_DESTROY, then we need to free the CLinkButton
    // class associated with the button.
    if (uMsg == WM_DESTROY)
        {
        CLinkButton *pLink = (CLinkButton*) GetProp(hwnd, LINKINFO_PROP);
        if (pLink)
            pLink->Release();
        SetProp(hwnd, LINKINFO_PROP, 0);
        }

    // Pass the message on to the original window procedure
    WNDPROC pfn = (WNDPROC) GetProp(hwnd, WNDPROC_PROP);
    if (pfn)
        return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
    else
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT HrLoadButtonBitmap(HWND hwnd, int idBmp, int idMask, HBITMAP* phBtns, 
                           HBITMAP *phMask, HPALETTE *phPalette)
    {
    HRESULT     hr = S_OK;
    HBITMAP     hbmBtn = 0;
    HBITMAP     hbmMask = 0;
    BITMAP      bm;
    HDC         hdc = 0;
    HDC         hdcBitmap = 0;
    DWORD       adw[257];
    int         i, n;
    HPALETTE    hPal = 0;

    // Load the button bitmap
    hbmBtn = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(idBmp), IMAGE_BITMAP,
                                 0, 0, LR_CREATEDIBSECTION);
    if (!hbmBtn)
        {
        Assert(hbmBtn);
        hr = E_INVALIDARG;
        goto exit;
        }

    // Load the mask bitmap
    hbmMask = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(idMask), IMAGE_BITMAP,
                                  0, 0, LR_CREATEDIBSECTION);
    if (!hbmMask)
        {
        Assert(hbmMask);
        hr = E_INVALIDARG;
        goto exit;
        }

#ifndef WIN16
    // Get the dimensions of the bitmaps
    GetObject((HGDIOBJ) hbmBtn, sizeof(BITMAP), &bm);

    // Set up the DC's with the bitmap
    hdc = GetDC(hwnd);
    Assert(hdc != NULL);
    hdcBitmap = CreateCompatibleDC(hdc);
    Assert(hdcBitmap != NULL);

    SelectBitmap(hdcBitmap, hbmBtn);

    // Create a palette for the bitmap
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD) &adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hPal = CreatePalette((LPLOGPALETTE) &adw[0]);
    Assert(hPal);

    // Clean up
    DeleteDC(hdcBitmap);
    ReleaseDC(hwnd, hdc);
#else
    hPal = (HPALETTE)GetStockObject( DEFAULT_PALETTE );
    Assert( hPal );
#endif

    // Set up the return values
    *phBtns = hbmBtn;
    *phMask = hbmMask;
    *phPalette = hPal;

    return (S_OK);

exit:
    // Delete the button bitmap
    if (hbmBtn)
        DeleteBitmap(hbmBtn);

    // Delete the mask
    if (hbmMask)
        DeleteBitmap(hbmMask);

    return (hr);
    }


//
//  FUNCTION:   CLinkButton::OnPaletteChanged()
//
//  PURPOSE:    Sent when another window changes the palette on us.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the folderview window
//      <in> hwndPaletteChange - The window that changed the palette.
//
void CLinkButton::OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
    {
    if (hwnd != hwndPaletteChange)
        InvalidateRect(m_hwnd, NULL, FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\tipday.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     tipday.h
//
//  PURPOSE:    Defines the CTipOfTheDay control.
//


typedef struct {
    LPTSTR pszLinkText;
    LPTSTR pszLinkAddr;
    HWND   hwndCtl;
} LINKINFO, *PLINKINFO;


#define LINKINFO_PROP   _T("Link Info")         // PLINKINFO pointer
#define WNDPROC_PROP    _T("Wndproc")
#define TIPINFO_PROP    _T("CTipOfTheDay")      // 'this' pointer
#define BUTTON_CLASS    _T("Athena Button")

class CTipOfTheDay
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    CTipOfTheDay();
    ~CTipOfTheDay();
    HRESULT HrCreate(HWND hwndParent, FOLDER_TYPE ftType);
    
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    static LRESULT CALLBACK TipWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                       LPARAM lParam);

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
    void OnDestroy(HWND hwnd);
    void OnSysColorChange(HWND hwnd);
    void OnPaint(HWND hwnd);
    HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);
    
    DWORD GetRequiredWidth(void);
    DWORD GetRequiredHeight(void);
    void FreeLinkInfo(void);
    HRESULT HrLoadTipInfo(void);
    HRESULT HrLoadLinkInfo(void);
    HRESULT HrCreateChildWindows(HWND hwnd);
    
    HWND GetHwnd(void) { return m_hwnd; }    
    
private:
    /////////////////////////////////////////////////////////////////////////
    // Private Data    
    ULONG           m_cRef;
    HWND            m_hwnd;
    HWND            m_hwndParent;
    HWND            m_hwndNext;
    FOLDER_TYPE     m_ftType;
    TCHAR           m_szTitle[CCHMAX_STRINGRES];
    TCHAR           m_szNextTip[64];
    
    // Tip string information
    LPTSTR          m_pszTip;
    DWORD           m_dwCurrentTip;

    // Link information
//    DWORD           m_cLinks;
//    PLINKINFO       m_rgLinkInfo;
    
    // Drawing info -- these get reset every WM_SYSCOLORCHANGE
    COLORREF        m_clrBack;
    COLORREF        m_clrText;
    COLORREF        m_clrLink;    
    HFONT           m_hfLink;
    TEXTMETRIC      m_tmLink;
    HFONT           m_hfTitle;
    TEXTMETRIC      m_tmTitle;
    HFONT           m_hfTip;
    HICON           m_hiTip;
    DWORD           m_cyTitleHeight;
    DWORD           m_cxTitleWidth;
    HBRUSH          m_hbrBack;
    DWORD           m_dwBorder;
    DWORD           m_cxNextWidth;
    DWORD           m_cyNextHeight;
    RECT            m_rcTip;
    };



#define IDC_TIPCONTROL                  1001
#define IDC_TIP_STATIC                  1002
#define IDC_NEXTTIP_BUTTON              1003
#define IDC_LINKBASE_BUTTON             1500



#define LINK_BUTTON_BORDER              3       // pixels
#define TIP_ICON_HEIGHT                 32
#define TIP_ICON_WIDTH                  32


/////////////////////////////////////////////////////////////////////////////
// 
// CLinkButton
//
// Creates an owner-drawn button that looks a lot like a web link.
//
class CLinkButton
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    CLinkButton();
    ~CLinkButton();
    HRESULT HrCreate(HWND hwndParent, LPTSTR pszCaption, LPTSTR pszLink, 
                     UINT uID);
    HRESULT HrCreate(HWND hwndParent, LPTSTR pszCaption, UINT uID, UINT index,
                     HBITMAP hbmButton, HBITMAP hbmMask, HPALETTE hpal);

    /////////////////////////////////////////////////////////////////////////
    // Ref Counting
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // Moving, Sizing
    DWORD GetHeight(void)               { return m_cyHeight; }
    DWORD GetWidth(void)                { return m_cxWidth; }
    HWND  GetWindow(void)               { return m_hwnd; }

    void Move(DWORD x, DWORD y);
    void Move(POINT pt)                 { Move(pt.x, pt.y); }

    void Show(BOOL fShow);  

    /////////////////////////////////////////////////////////////////////////
    // Painting
    void OnDraw(HWND hwnd, const DRAWITEMSTRUCT *lpDrawItem);
    HBRUSH OnCtlColorBtn(HWND hwnd)     { return (m_hbrBack); }

    /////////////////////////////////////////////////////////////////////////
    // System changes
    void OnSysColorChange(void);
    void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange);

    /////////////////////////////////////////////////////////////////////////
    // Execute
    void OnCommand(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private Data
    ULONG           m_cRef;             // Ref Count
    HWND            m_hwnd;             // Handle of our button window
    HWND            m_hwndParent;       // Handle of our parent

    // Caption and Link strings and Command ID
    LPTSTR          m_pszCaption;
    LPTSTR          m_pszLink;
    UINT            m_uID;

    // Drawing info -- these get reset every WM_SYSCOLORCHANGE
    COLORREF        m_clrLink;    
    COLORREF        m_clrBack;
    HFONT           m_hfLink;
    TEXTMETRIC      m_tmLink;
    HBRUSH          m_hbrBack;

    DWORD           m_dwBorder;
    DWORD           m_cxWidth;
    DWORD           m_cyHeight;

    UINT            m_index;
    DWORD           m_cxImage;
    DWORD           m_cyImage;

    // GDI Resources passed to us when we are created
    HBITMAP         m_hbmButtons;
    HBITMAP         m_hbmMask;
    HPALETTE        m_hpalButtons;
    };

// #define CX_BUTTON_IMAGE   96
// #define CY_BUTTON_IMAGE   84

#define CX_BUTTON_IMAGE   110 // 104
#define CY_BUTTON_IMAGE   110 // 68


LRESULT CALLBACK ButtonSubClass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT HrLoadButtonBitmap(HWND hwnd, int idBmp, int idMask, HBITMAP* phBtns, 
                           HBITMAP *phMask, HPALETTE *phPalette);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\smapi.cpp ===
//
//  SMAPI.CPP - Simple MAPI implementation
//

#include "pch.hxx"
#include "note.h"
#include <mapi.h>
#include <mapicode.h>
#include <mimeutil.h>
#include <resource.h>
#include <ipab.h>
#include <error.h>
#include <strconst.h>
#include "smapimem.h"
#include <bodyutil.h>
#include <goptions.h>
#include <spoolapi.h>
#include "instance.h"
#include "msgfldr.h"
#include <mailutil.h>
#include <storecb.h>
#include "multiusr.h"
#include <..\help\mailnews.h>
#include <inetcfg.h>
#include "mapidlg.h"

#include "demand.h"

ASSERTDATA

static LPWAB            s_lpWab;
static LPWABOBJECT      s_lpWabObject;
static IAddrBook*       s_lpAddrBook;

extern  HANDLE  hSmapiEvent;
HINITREF    hInitRef=NULL;

HRESULT HrAdrlistFromRgrecip(ULONG nRecips, lpMapiRecipDesc lpRecips, LPADRLIST *ppadrlist);
HRESULT HrRgrecipFromAdrlist(LPADRLIST lpAdrList, lpMapiRecipDesc * lppRecips);
void ParseEmailAddress(LPSTR pszEmail, LPSTR *ppszAddrType, LPSTR *ppszAddress);
void FreePadrlist(LPADRLIST padrlist);
ULONG HrFillMessage(LPMIMEMESSAGE *pmsg, lpMapiMessage lpMessage, BOOL *pfWebPage, BOOL bValidateRecips, BOOL fOriginator);
BOOL HrReadMail (IMessageFolder *pFolder, LPSTR lpszMessageID, lpMapiMessage FAR *lppMessage, FLAGS flFlags);
ULONG HrValidateMessage(lpMapiMessage lpMessage);
BOOL HrSMAPISend(HWND hWnd, IMimeMessage *pMsg);
HRESULT HrFromIDToNameAndAddress(LPTSTR *pszLocalName, LPTSTR *pszLocalAddress, ULONG cbEID, LPENTRYID lpEID);
INT_PTR CALLBACK WarnSendMailDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//  Fix for Bug #62129 (v-snatar)
HRESULT HrSendAndRecv();

typedef enum tagINTERACTIVESTATE
{
    IS_UNINIT,
    IS_INTERACTIVE,
    IS_NOTINTERACTIVE,
} INTERACTIVESTATE;

// Determine if the current process is a service or not
BOOL IsProcessInteractive(void);

///////////////////////////////////////////////////////////////////////
//
// UlSimpleMAPIInit
//
///////////////////////////////////////////////////////////////////////
ULONG UlSimpleMAPIInit(BOOL fInit, HWND hwnd, BOOL fLogonUI)
{
    ULONG   ulRet = SUCCESS_SUCCESS;
    BOOL    bCoIncrementFailure = FALSE;
    
    if (fInit)
    {
        // [PaulHi] 5/17/99  @todo @bug
        // The "SimpleMAPIInit" name is used in debug only builds to track users of
        // OE.  However, if this function (CoIncrementInit) fails (if user doesn't
        // provide identity) then a memory leak will occur because CoDecrementInit()
        // is called with "COutlookExpress" and so the "SimpleMAPIInit" node isn't
        // free'd.  Again, this is for debug binaries only.

        /*
            Yet more cludgyness:

            If SMAPI is not allowed to show logon UI, we ask OE to use the default
            identity.  However, the default identity could have a password on it.
            In this case, SMAPI would like to fail the logon.  Unfortunately, the 
            identity manager does not make it easy to discover if an identity has a
            a password (we would need to grok the registry).  This limitation is 
            currently moot as OE will logon to the default identity without requiring
            the user to supply the required password.  If this is fixed, we will have
            to change this code.
        */
        if (FAILED(CoIncrementInit("SimpleMAPIInit", MSOEAPI_START_SHOWERRORS | 
            ((fLogonUI) ? 0 : MSOEAPI_START_DEFAULTIDENTITY ), NULL, &hInitRef)))
        {
            ulRet = MAPI_E_FAILURE;
            bCoIncrementFailure = TRUE;
            goto exit;
        }

        if (S_OK != ProcessICW(hwnd, FOLDER_LOCAL, TRUE, fLogonUI))
        {
            ulRet = MAPI_E_LOGON_FAILURE;
            goto exit;
        }
        
        if (NULL == s_lpWab)
        {
            if (FAILED(HrCreateWabObject(&s_lpWab)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWab);
            
            if (FAILED(s_lpWab->HrGetAdrBook(&s_lpAddrBook)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpAddrBook);
            
            if (FAILED(s_lpWab->HrGetWabObject(&s_lpWabObject)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWabObject);
        }
        else
        {
            if (FAILED(s_lpWab->HrGetWabObject(&s_lpWabObject)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWabObject);
        }
    }

exit:
    if (FALSE == fInit || (fInit && SUCCESS_SUCCESS != ulRet && !bCoIncrementFailure))
    {
        CoDecrementInit("SimpleMAPIInit", NULL);
    }
    
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// SimpleMAPICleanup
//
///////////////////////////////////////////////////////////////////////
void SimpleMAPICleanup(void)
{
    SafeRelease(s_lpWab);
    s_lpWabObject = NULL;
    s_lpAddrBook = NULL;
}

///////////////////////////////////////////////////////////////////////
//
// Simple MAPI Session Implementation
//
///////////////////////////////////////////////////////////////////////

#define SESSION_MAGIC   0xEA030571

class CSession
{
public:
    CSession();
    ~CSession();
    ULONG UlInit(HWND hwnd, BOOL fLogonUI);

    ULONG                m_cRef;
    DWORD                m_dwSessionMagic;
    IMessageFolder       *m_pfldrInbox;
    BOOL                 m_fDllInited;
};

typedef CSession * PSESS;

CSession::CSession()
{
    m_cRef = 0;
    m_dwSessionMagic = SESSION_MAGIC;
    m_pfldrInbox = NULL;
    m_fDllInited = FALSE;
}

CSession::~CSession()
{
    if (m_pfldrInbox)
        m_pfldrInbox->Release();
    if (m_fDllInited)
        {
        UlSimpleMAPIInit(FALSE, NULL, FALSE);
        }
}

ULONG CSession::UlInit(HWND hwnd, BOOL fLogonUI)
{
    ULONG   ulRet = SUCCESS_SUCCESS;

    ulRet = UlSimpleMAPIInit(TRUE, hwnd, fLogonUI);
    if (SUCCESS_SUCCESS == ulRet)
    {
        m_fDllInited = TRUE;
    }
    
    return ulRet;
}

ULONG UlGetSession(LHANDLE lhSession, PSESS *ppSession, ULONG_PTR ulUIParam, BOOL fLogonUI, BOOL fNeedInbox)
{
    ULONG   ulRet = SUCCESS_SUCCESS;
    PSESS   pSession = NULL;

    if (lhSession && IsBadWritePtr((LPVOID)lhSession, sizeof(CSession)))
    {
        ulRet = MAPI_E_INVALID_SESSION;
        goto exit;
    }
    
    if (lhSession)
    {
        pSession = (PSESS)lhSession;
        if (pSession->m_dwSessionMagic != SESSION_MAGIC)
        {
            ulRet = MAPI_E_INVALID_SESSION;
            goto exit;
        }
    }
    else
    {
        pSession = new CSession();
        if (NULL == pSession)
        {
            ulRet = MAPI_E_INSUFFICIENT_MEMORY;
            goto exit;
        }

        ulRet = pSession->UlInit((HWND) ulUIParam, fLogonUI);
        if (SUCCESS_SUCCESS != ulRet)
        {
            delete pSession;
            goto exit;
        }
    }

    if (fNeedInbox && !pSession->m_pfldrInbox)
    {
        if (FAILED(g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pSession->m_pfldrInbox)))
        {
            ulRet = MAPI_E_FAILURE;
            goto exit;
        }
    }

    pSession->m_cRef++;
    *ppSession = pSession;

    // Set the return value
    ulRet = SUCCESS_SUCCESS;
    
exit:
    return ulRet;    
}

ULONG ReleaseSession(PSESS pSession)
{
    HRESULT hr =S_OK;
    if (NULL == pSession)
        return MAPI_E_INVALID_SESSION;
    if (IsBadWritePtr(pSession, sizeof(CSession)))
        return MAPI_E_INVALID_SESSION;
    if (pSession->m_dwSessionMagic != SESSION_MAGIC)
        return MAPI_E_INVALID_SESSION;
    
    if (--pSession->m_cRef == 0)
    {
        delete pSession;

/*        if(hInitRef)
            IF_FAILEXIT(hr = CoDecrementInit("SimpleMAPIInit", &hInitRef));

        hInitRef = NULL;
*/
    }

    return SUCCESS_SUCCESS;
// exit:
    return(hr);
}

///////////////////////////////////////////////////////////////////////
//
// MAPILogon
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogon(ULONG_PTR ulUIParam,
                           LPSTR lpszProfileName,
                           LPSTR lpszPassword,
                           FLAGS flFlags,
                           ULONG ulReserved,
                           LPLHANDLE lplhSession)
{
    ULONG ulRet = SUCCESS_SUCCESS;
    PSESS pSession = NULL;
    BOOL  fLogonUI;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // If the process is not interactive, they should not have 
    // allowed any UI
    if (!IsProcessInteractive() && fLogonUI)
    {
        ulRet = MAPI_E_FAILURE;
        goto exit;
    }     

    ulRet = UlGetSession(NULL, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    *lplhSession = (LHANDLE)pSession;    
    
    //  Fix for Bug #62129 (v-snatar)
    if (flFlags & MAPI_FORCE_DOWNLOAD)
        HrSendAndRecv();
    
exit:
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPILogoff
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession,
                            ULONG_PTR ulUIParam,
                            FLAGS flFlags,
                            ULONG ulReserved)
{
    return ReleaseSession((PSESS)lhSession);
}

///////////////////////////////////////////////////////////////////////
//
// MAPIFreeBuffer
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID lpv)
{
    LPBufInternal   lpBufInt;
    LPBufInternal   lpT;

    if (!lpv)
        return(0L); //  for callers who don't check for NULL themselves.

    lpBufInt = LPBufIntFromLPBufExt(lpv);

    if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)))
        {
        TellBadBlock(lpv, "fails address check");
        return MAPI_E_FAILURE;
        }
    if (GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC)
        {
        TellBadBlock(lpv, "has invalid allocation flags");
        return MAPI_E_FAILURE;
        }

#ifdef DEBUG
    if (!FValidAllocChain(lpBufInt))
        goto ret;
#endif

    // Free the first block
    lpT = lpBufInt->pLink;
    g_pMalloc->Free(lpBufInt);
    lpBufInt = lpT;

    while (lpBufInt)
        {
        if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)) || GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
            goto ret;

        lpT = lpBufInt->pLink;
        g_pMalloc->Free(lpBufInt);
        lpBufInt = lpT;
        }

ret:
    return SUCCESS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
//
// MAPISendMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession,          // ignored
                              ULONG_PTR ulUIParam,
                              lpMapiMessage lpMessage,
                              FLAGS flFlags,
                              ULONG ulReserved)
{
    ULONG               ulRet = SUCCESS_SUCCESS;
    LPMIMEMESSAGE       pMsg = NULL;
    HRESULT             hr; 
    BOOL                fWebPage;
    PSESS               pSession = NULL;
    BOOL                fLogonUI;
    BOOL                fOleInit = FALSE;

    // validate parameters
    if (NULL == lpMessage || IsBadReadPtr(lpMessage, sizeof(MapiMessage)))
        return MAPI_E_INVALID_MESSAGE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));
    
    // If the process is not interactive, they should not allow any UI
    if (!IsProcessInteractive() && fLogonUI)
    {
        return MAPI_E_FAILURE;
    } 

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!(flFlags & MAPI_DIALOG))
        {
        ulRet = HrValidateMessage(lpMessage);
        if (ulRet)
            return ulRet;
        }    

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    // display warning dialog if app is sending mail without ui and the users
    // wish to be alerted
    if (!(flFlags & MAPI_DIALOG) && !!DwGetOption(OPT_SECURITY_MAPI_SEND))
    {
        if (IDCANCEL == DialogBoxParam(g_hLocRes,MAKEINTRESOURCE(iddMapiSend),
                        NULL, WarnSendMailDlgProc, (LPARAM)lpMessage))
            goto error;
    }

    // Make sure OLE is initialized
    OleInitialize(NULL);
    fOleInit = TRUE;

    // Fill IMimeMessage with the lpMessage structure members
    ulRet = HrFillMessage(&pMsg, lpMessage, &fWebPage, !(flFlags & MAPI_DIALOG), !(flFlags & MAPI_DIALOG));
    if (ulRet)
        goto error;

    if (flFlags & MAPI_DIALOG)
        {
        INIT_MSGSITE_STRUCT rInitSite;
        DWORD               dwAction,
                            dwCreateFlags = OENCF_SENDIMMEDIATE | OENCF_MODAL; // always on dllentry points...

        if (fWebPage)
            dwAction = OENA_WEBPAGE;
        else
            dwAction = OENA_COMPOSE;

        rInitSite.dwInitType = OEMSIT_MSG;
        rInitSite.pMsg = pMsg;
        rInitSite.folderID = FOLDERID_INVALID;
        hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, (HWND)ulUIParam);
        hInitRef = NULL;
        }
    else
        hr = HrSMAPISend((HWND)ulUIParam, pMsg); // Send the Message without displaying it

    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;
    else
        ulRet = MAPI_E_FAILURE;

error:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    // Make sure we clean up OLE afterwords
    if (fOleInit)
        OleUninitialize();
    
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPISendDocuments
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendDocuments(ULONG_PTR ulUIParam,
                                   LPSTR lpszDelimChar,
                                   LPSTR lpszFullPaths,
                                   LPSTR lpszFileNames,
                                   ULONG ulReserved)
{
    ULONG               ulRet = MAPI_E_FAILURE;
    int                 cch;
    LPMIMEMESSAGE       pMsg = NULL;
    HRESULT             hr;
    CStringParser       spPath;
    int                 nCount=0; // Used to find the number of files to be attached
    PSESS               pSession = NULL;
    INIT_MSGSITE_STRUCT rInitSite;
    DWORD               dwAction,
                        dwCreateFlags = OENCF_SENDIMMEDIATE | OENCF_MODAL; //always on dllentry points...
    // check for the Delimiter
    Assert(lpszDelimChar);
    if (lpszDelimChar == NULL)
        return MAPI_E_FAILURE;

    // check for the Paths
    Assert (lpszFullPaths);
    if (lpszFullPaths == NULL)
        return MAPI_E_FAILURE;

    // MAPISendDocuments is documented as always bringing up UI
    // A service should not call this function
    if (!IsProcessInteractive())
        return MAPI_E_LOGIN_FAILURE;
    
    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    ulRet = UlGetSession(NULL, &pSession, ulUIParam, TRUE, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // create an empty message
    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    dwAction = OENA_COMPOSE;

    // ~~~ Do I need to do something with OEMSIT_VIRGIN?
    rInitSite.dwInitType = OEMSIT_MSG;
    rInitSite.pMsg = pMsg;
    rInitSite.folderID = FOLDERID_INVALID;

    // Determine the number of attachments (nCount), indiviual file names and pathnames

    // call pMsg->AttachFile with appropriate parameters nCount times

    // To parse the lpszFullPaths and lpszFileNames use CStringParser class

    spPath.Init(lpszFullPaths, lstrlen(lpszFullPaths), 0);

    //Parse the path for the delimiter

    spPath.ChParse(lpszDelimChar);

    while (spPath.CchValue())
    {
        // Add the attachment

        hr = pMsg->AttachFile(spPath.PszValue(), NULL, NULL);
        if (FAILED(hr))
            goto error;
        nCount++;

        //Parse the path for the delimiter

        spPath.ChParse(lpszDelimChar);
    }

    // set the subject on the message

    if (nCount == 1)
    {
        if (lpszFileNames)
            hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, lpszFileNames);
    }
    else
    {
        TCHAR szBuf[CCHMAX_STRINGRES];
        AthLoadString(idsAttachedFiles, szBuf, ARRAYSIZE(szBuf));
        hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szBuf);
    }

    if (FAILED(hr))
        goto error;

    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, (HWND)ulUIParam);
    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;

error:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIAddress
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession,
                             ULONG_PTR ulUIParam,
                             LPTSTR lpszCaption,
                             ULONG nEditFields,
                             LPTSTR lpszLabels,
                             ULONG nRecips,
                             lpMapiRecipDesc lpRecips,
                             FLAGS flFlags,
                             ULONG ulReserved,
                             LPULONG lpnNewRecips,
                             lpMapiRecipDesc FAR * lppNewRecips)
{
    ULONG               ul, ulRet = MAPI_E_FAILURE;
    HRESULT             hr;
    LPADRLIST           lpAdrList = 0;
    ADRPARM             AdrParms = {0};
    static ULONG        rgulTypes[3] = {MAPI_TO, MAPI_CC, MAPI_BCC};
    PSESS               pSession = NULL;
    BOOL                fLogonUI;

    // Validate Parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (lpszCaption && IsBadStringPtr(lpszCaption, (UINT)0xFFFF))
        return MAPI_E_FAILURE;

    if (nEditFields > 4)
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields == 1 && lpszLabels && IsBadStringPtr(lpszLabels, (UINT)0xFFFF))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields && IsBadWritePtr(lpnNewRecips, (UINT)sizeof(ULONG)))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields && IsBadWritePtr(lppNewRecips, (UINT)sizeof(lpMapiRecipDesc)))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nRecips && IsBadReadPtr(lpRecips, (UINT)nRecips * sizeof(MapiRecipDesc)))
        return MAPI_E_INVALID_RECIPS;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    // init output parameters
    if (nEditFields)
        {
        *lppNewRecips = NULL;
        *lpnNewRecips = 0;
        }

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // build an adrlist from the lpRecips
    if (nRecips)
        {
        ULONG ulMax = MAPI_TO;

        hr = HrAdrlistFromRgrecip(nRecips, lpRecips, &lpAdrList);
        if (hr)
            goto exit;
        Assert(nRecips == lpAdrList->cEntries);

        // we need to grow nEditFields if it isn't big enough
        for (ul = 0; ul < nRecips; ul++)
            {
            if (ulMax < lpRecips[ul].ulRecipClass && lpRecips[ul].ulRecipClass <= MAPI_BCC)
                ulMax = lpRecips[ul].ulRecipClass;
            }
        Assert(ulMax >= MAPI_TO && ulMax <= MAPI_BCC);
        if (ulMax > nEditFields)
            {
            DOUT("MAPIAddress: growing nEditFields from %ld to %ld\r\n", nEditFields, ulMax);
            nEditFields = ulMax;
            }
        }

    // Fill the AdrParm structure

    AdrParms.ulFlags = DIALOG_MODAL;
    AdrParms.lpszCaption = lpszCaption;
    AdrParms.cDestFields = nEditFields == 4 ? 3 : nEditFields;
    if (nEditFields == 1 && lpszLabels && *lpszLabels)
        AdrParms.lppszDestTitles = &lpszLabels;
    AdrParms.lpulDestComps = rgulTypes;

    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    hr = s_lpAddrBook->Address(&ulUIParam, &AdrParms, &lpAdrList);
    if (hr)
        {
        if (MAPI_E_USER_CANCEL == hr)
            ulRet = MAPI_E_USER_ABORT;
        else if (MAPI_E_NO_RECIPIENTS == hr || MAPI_E_AMBIGUOUS_RECIP == hr)
            ulRet = MAPI_E_INVALID_RECIPS;
        goto exit;
        }

    if (nEditFields && lpAdrList && lpAdrList->cEntries)
    {    
        hr = HrRgrecipFromAdrlist(lpAdrList, lppNewRecips);
        if (hr)
            goto exit;

        *lpnNewRecips = lpAdrList->cEntries;
    }

    ulRet = SUCCESS_SUCCESS;

exit:

    FreePadrlist(lpAdrList);

    ReleaseSession(pSession);

    return ulRet;
}



///////////////////////////////////////////////////////////////////////
//
// MAPIDetails
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession,
                             ULONG_PTR ulUIParam,
                             lpMapiRecipDesc lpRecip,
                             FLAGS flFlags,
                             ULONG ulReserved)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    LPSTR                   pszAddrType = 0;
    LPSTR                   pszAddress = 0;
    ULONG                   cbEntryID;
    LPENTRYID               lpEntryID = 0;
    PSESS                   pSession = NULL;
    BOOL                    fLogonUI;

    // Validate  parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (IsBadReadPtr(lpRecip, (UINT)sizeof(MapiRecipDesc)))
        return MAPI_E_INVALID_RECIPS;

    if (lpRecip->ulEIDSize == 0 && !lpRecip->lpszAddress)
        return MAPI_E_INVALID_RECIPS;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    if (lpRecip->ulEIDSize)
        {
        cbEntryID = lpRecip->ulEIDSize;
        lpEntryID = (LPENTRYID)lpRecip->lpEntryID;
        }
    else
        {
        ParseEmailAddress(lpRecip->lpszAddress, &pszAddrType, &pszAddress);

        CHECKHR(hr = s_lpAddrBook->CreateOneOff(lpRecip->lpszName, pszAddrType, pszAddress, 0, &cbEntryID, &lpEntryID));
        }

    CHECKHR(hr = s_lpAddrBook->Details(&ulUIParam, NULL, NULL, cbEntryID, lpEntryID, NULL, NULL, NULL, DIALOG_MODAL));
    ulRet = SUCCESS_SUCCESS;

exit:
    if (pszAddrType)
        MemFree(pszAddrType);
    if (pszAddress)
        MemFree(pszAddress);

    if (lpEntryID && lpEntryID != lpRecip->lpEntryID && NULL != s_lpWabObject)
        s_lpWabObject->FreeBuffer(lpEntryID);

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIResolveName
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession,
                                 ULONG_PTR ulUIParam,
                                 LPSTR lpszName,
                                 FLAGS flFlags,
                                 ULONG ulReserved,
                                 lpMapiRecipDesc FAR *lppRecip)
{
    ULONG                ulRet = SUCCESS_SUCCESS, ulNew;
    LPADRLIST            lpAdrList = 0;
    HRESULT              hr;
    LPADRENTRY           lpAdrEntry;
    PSESS                pSession = NULL;
    BOOL                 fLogonUI;

    // Validate  parameters - Begin    
    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    /*
      HACK:  #68119 Excel doesn't pass in a parent.
      This isn't the best thing to do, but this handle shouldn't be 0.
      The only thing to watch out for is fast actions while this processing
      is happening could make this dialog modal to the wrong window, but
      that us much more unlikely than the bug this fixes.
    */
    if(!ulUIParam)
        ulUIParam = (ULONG_PTR)GetForegroundWindow();

    if (!lpszName || IsBadStringPtr(lpszName, (UINT)0xFFFF) || !*lpszName)
        return MAPI_E_FAILURE;

    if (IsBadWritePtr(lppRecip, (UINT)sizeof(lpMapiRecipDesc)))
        return MAPI_E_FAILURE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate  parameters - End

    *lppRecip = NULL;

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // Allocate memory for lpAdrList

    // Determine number of bytes needed
    ulNew = sizeof(ADRLIST) + sizeof(ADRENTRY);

    // Allocate new buffer
    if (NULL == s_lpWabObject)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
        
    hr = s_lpWabObject->AllocateBuffer(ulNew, (LPVOID *)&lpAdrList);
    if (hr)
        goto exit;

    lpAdrList->cEntries = 1;
    lpAdrEntry = lpAdrList->aEntries;

    // Allocate memory for SPropValue
    hr = s_lpWabObject->AllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpAdrEntry->rgPropVals);
    if (hr)
        goto exit;

    lpAdrEntry->cValues = 1;
    lpAdrEntry->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;

    ULONG cchName = lstrlen(lpszName) + 1;
    hr = s_lpWabObject->AllocateMore(cchName, lpAdrEntry->rgPropVals, (LPVOID*)(&(lpAdrEntry->rgPropVals[0].Value.lpszA)));
    if (FAILED (hr))
        goto exit;

    // Fill in the name
    StrCpyN(lpAdrEntry->rgPropVals[0].Value.lpszA, lpszName, cchName);

     // Call ResolveName of IAddrBook
    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    hr = s_lpAddrBook->ResolveName(ulUIParam, flFlags & MAPI_DIALOG, NULL, lpAdrList);

    if (hr)
        {
        if ((hr == MAPI_E_NOT_FOUND) || (hr == MAPI_E_USER_CANCEL))
            ulRet = MAPI_E_UNKNOWN_RECIPIENT;
        else if (hr == MAPI_E_AMBIGUOUS_RECIP)
            ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
        else
            ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    else if ((lpAdrList->cEntries != 1) || !lpAdrList->aEntries->cValues)
        {
        ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
        goto exit;
        }

    ulRet = HrRgrecipFromAdrlist(lpAdrList, lppRecip);

exit:

    FreePadrlist(lpAdrList);

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIFindNext
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              LPSTR lpszMessageType,
                              LPSTR lpszSeedMessageID,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              LPSTR lpszMessageID)
{
    MESSAGEINFO             MsgInfo={0};
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    MESSAGEID               idMessage;
    MESSAGEID               dwMsgIdPrev;
    PSESS                   pSession = NULL;
    HROWSET                 hRowset=NULL;

    // Validate parameters - begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (lpszSeedMessageID && IsBadStringPtr(lpszSeedMessageID, (UINT)0xFFFF))
        return MAPI_E_INVALID_MESSAGE;

    if (lpszSeedMessageID && (!*lpszSeedMessageID || !IsDigit(lpszSeedMessageID)))
        lpszSeedMessageID = NULL;

    if (IsBadWritePtr(lpszMessageID, 64))
        return MAPI_E_INSUFFICIENT_MEMORY;
    
    // Validate parameters - end

    // We shouldn't need to show login UI, because the session must be valid
    // and a valid session would require a login
    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    hr = pSession->m_pfldrInbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
    {
        ulRet = MAPI_E_NO_MESSAGES;
        goto exit;
    }

    hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);
    if (FAILED(hr) || S_FALSE == hr)
    {
        ulRet = MAPI_E_NO_MESSAGES;
        goto exit;
    }

    if (lpszSeedMessageID)               // If the seed is NULL
    {
        idMessage = (MESSAGEID)((UINT_PTR)StrToUint(lpszSeedMessageID));

        while (1)
        {
            dwMsgIdPrev = MsgInfo.idMessage;

            pSession->m_pfldrInbox->FreeRecord(&MsgInfo);

            hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);

            if (FAILED(hr) || S_FALSE == hr)
            {
                ulRet = MAPI_E_NO_MESSAGES;
                goto exit;
            }

            if (dwMsgIdPrev == idMessage)
                break;
        }
    }

    // Check for Read unread messages only flag
    if (flFlags & MAPI_UNREAD_ONLY)
    {
        while (ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
        {
            // Free MsgInfo
            pSession->m_pfldrInbox->FreeRecord(&MsgInfo);

            // Get the next message
            hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);

            // Not Found
            if (FAILED(hr) || S_FALSE == hr)
            {
                ulRet = MAPI_E_NO_MESSAGES;
                goto exit;
            }
        }
    }            
    
    wnsprintf(lpszMessageID, 64, "%lu", MsgInfo.idMessage);
    ulRet = SUCCESS_SUCCESS;

exit:
    if (pSession && pSession->m_pfldrInbox)
    {
        pSession->m_pfldrInbox->CloseRowset(&hRowset);
        pSession->m_pfldrInbox->FreeRecord(&MsgInfo);
    }

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIReadMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              LPSTR lpszMessageID,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              lpMapiMessage FAR *lppMessage)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    lpMapiMessage           rgMessage = NULL;
    PSESS                   pSession = NULL;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (lpszMessageID && (!*lpszMessageID || !IsDigit(lpszMessageID)))
        return MAPI_E_INVALID_MESSAGE;

    if (IsBadWritePtr(lppMessage,(UINT)sizeof(lpMapiMessage)))
        return MAPI_E_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    if (!HrReadMail(pSession->m_pfldrInbox, lpszMessageID, &rgMessage, flFlags))
        goto exit;

    ulRet = SUCCESS_SUCCESS;

    *lppMessage = rgMessage;

exit:
    if (ulRet != SUCCESS_SUCCESS)
        if (rgMessage)
            MAPIFreeBuffer(rgMessage);

    ReleaseSession(pSession);

    return ulRet;
}


///////////////////////////////////////////////////////////////////////
//
// MAPISaveMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              lpMapiMessage lpMessage,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              LPSTR lpszMessageID)
{
    ULONG           ulRet = MAPI_E_FAILURE;
    HRESULT         hr;
    IMimeMessage   *pMsg = NULL;
    MESSAGEID       msgid;
    PSESS           pSession = NULL;
    HWND            hwnd = (HWND)ulUIParam;
    BOOL            fLogonUI;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow(hwnd))
        hwnd = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (lpszMessageID && *lpszMessageID && !IsDigit(lpszMessageID))
        return MAPI_E_INVALID_MESSAGE;

    if (IsBadReadPtr(lpMessage, (UINT)sizeof(lpMapiMessage)))
        return MAPI_E_FAILURE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

#pragma prefast(suppress:11, "noise")
    if (*lpszMessageID)
        {
        MESSAGEIDLIST List;
        msgid = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));
        List.cMsgs = 1;
        List.prgidMsg = &msgid;
        if (FAILED(hr = pSession->m_pfldrInbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &List, NULL, NOSTORECALLBACK)))
            {
            ulRet = MAPI_E_INVALID_MESSAGE;
            goto exit;
            }
        }

    // Fill IMimeMessage with the lpMessage structure members
    ulRet = HrFillMessage(&pMsg, lpMessage, NULL, FALSE, TRUE);
    if (ulRet)
        goto exit;

    if (FAILED(hr = HrSaveMessageInFolder(hwnd, pSession->m_pfldrInbox, pMsg, 0, &msgid, TRUE)))
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }

    ulRet = SUCCESS_SUCCESS;
    wnsprintf(lpszMessageID, 64, "%lu", msgid);

exit:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    return ulRet;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIDeleteMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession,
                                ULONG_PTR ulUIParam,
                                LPSTR lpszMessageID,
                                FLAGS flFlags,
                                ULONG ulReserved)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    MESSAGEID                   dwMsgID;
    HRESULT                 hr;
    PSESS                   pSession = NULL;
    MESSAGEIDLIST           List;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (!*lpszMessageID || !IsDigit(lpszMessageID))
        return MAPI_E_INVALID_MESSAGE;

    // Validate parameters - End

    // This function requires a valid session that must have been
    // logged in at some point so login UI is not allowed
    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    dwMsgID = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));

    List.cMsgs = 1;
    List.prgidMsg = &dwMsgID;

    hr = DeleteMessagesProgress((HWND)ulUIParam, pSession->m_pfldrInbox, DELETE_MESSAGE_NOPROMPT, &List);

    if (FAILED(hr))
        goto exit;

    ulRet = SUCCESS_SUCCESS;

exit:

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// INTERNAL FUNCTIONS
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
//  SMAPIAllocateBuffer
//
//  Purpose:
//      Allocates a memory buffer that must be freed with MAPIFreeBuffer().
//
//  Arguments:
//      ulSize  in      Size, in bytes, of the buffer to be allocated.
//      lppv    out     Pointer to variable where the address of the
//                      allocated memory will be returned.
//
//  Returns:
//      sc              Indicating error if any (see below)
//
//  Errors:
//      MAPI_E_INSUFFICIENT_MEMORY  Allocation failed.
//
///////////////////////////////////////////////////////////////////////

SCODE SMAPIAllocateBuffer(ULONG ulSize, LPVOID * lppv)
{
    SCODE           sc = S_OK;
    LPBufInternal   lpBufInt;

    //  Don't allow allocation to wrap across 32 bits, or to exceed 64K
    //  under win16.

    if (ulSize > INT_SIZE(ulSize))
        {
        DOUT("SMAPIAllocateBuffer: ulSize %ld is way too big\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        goto ret;
        }

    lpBufInt = (LPBufInternal)g_pMalloc->Alloc((UINT)INT_SIZE(ulSize));

    if (lpBufInt)
        {
        lpBufInt->pLink = NULL;
        lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC;
        *lppv = (LPVOID)LPBufExtFromLPBufInt(lpBufInt);
        }
    else
        {
        DOUT("SMAPIAllocateBuffer: not enough memory for %ld\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        }

ret:
    return sc;
}

///////////////////////////////////////////////////////////////////////
//
//  SMAPIAllocateMore
//
//  Purpose:
//      Allocates a linked memory buffer in such a way that it can be freed
//      with one call to MAPIFreeBuffer (passing the buffer the client
//      originally allocated with SMAPIAllocateBuffer).
//
//  Arguments:
//      ulSize  in      Size, in bytes, of the buffer to be allocated.
//      lpv     in      Pointer to a buffer allocated with SMAPIAllocateBuffer.
//      lppv    out     Pointer to variable where the address of the
//                      allocated memory will be returned.
//
//  Assumes:
//      Validates that lpBufOrig and lppv point to writable memory,
//      and that lpBufOrig was allocated with SMAPIAllocateBuffer.
//
//  Returns:
//      sc              Indicating error if any (see below)
//
//  Side effects:
//      None
//
//  Errors:
//      MAPI_E_INSUFFICIENT_MEMORY  Allocation failed.
//
///////////////////////////////////////////////////////////////////////

SCODE SMAPIAllocateMore(ULONG ulSize, LPVOID lpv, LPVOID * lppv)
{
    SCODE           sc = S_OK;
    LPBufInternal   lpBufInt;
    LPBufInternal   lpBufOrig;

    lpBufOrig = LPBufIntFromLPBufExt(lpv);

#ifdef DEBUG
    if (!FValidAllocChain(lpBufOrig))
        {
        sc = MAPI_E_FAILURE;
        goto ret;
        }
#endif

    //  Don't allow allocation to wrap across 32 bits, or to be
    //  greater than 64K under win16.

    if (ulSize > INT_SIZE(ulSize))
        {
        DOUT("SMAPIAllocateMore: ulSize %ld is way too big\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        goto ret;
        }

    //  Allocate the chained block and hook it to the head of the chain.

    lpBufInt = (LPBufInternal)g_pMalloc->Alloc((UINT)INT_SIZE(ulSize));

    if (lpBufInt)
        {
        lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC_MORE;

        // EnterCriticalSection(&csHeap);

        lpBufInt->pLink = lpBufOrig->pLink;
        lpBufOrig->pLink = lpBufInt;

        // LeaveCriticalSection(&csHeap);

        *lppv = (LPVOID)LPBufExtFromLPBufInt(lpBufInt);
        }
    else
        {
        DOUT("SMAPIAllocateMore: not enough memory for %ld\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        }

ret:
    return sc;
}

#ifdef DEBUG

BOOL FValidAllocChain(LPBufInternal lpBuf)
{
    LPBufInternal   lpBufTemp;

    if (IsBadWritePtr(lpBuf, sizeof(BufInternal)))
        {
        TellBadBlockInt(lpBuf, "fails address check");
        return FALSE;
        }
    if (GetFlags(lpBuf->ulAllocFlags) != ALLOC_WITH_ALLOC)
        {
        TellBadBlockInt(lpBuf, "has invalid flags");
        return FALSE;
        }

    for (lpBufTemp = lpBuf->pLink; lpBufTemp; lpBufTemp = lpBufTemp->pLink)
        {
        if (IsBadWritePtr(lpBufTemp, sizeof(BufInternal)))
            {
            TellBadBlockInt(lpBufTemp, "(linked block) fails address check");
            return FALSE;
            }
        if (GetFlags(lpBufTemp->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
            {
            TellBadBlockInt(lpBufTemp, "(linked block) has invalid flags");
            return FALSE;
            }
        }

    return TRUE;
}

#endif  // DEBUG

/*
 -  HrAdrentryFromPrecip
 -
 *  Purpose:
 *      Copies data from a MapiRecipDesc structure to the property
 *      value array on an ADRENTRY structure.
 *
 *  Arguments:
 *      precip          in      the input structure
 *      padrentry       out     the output structure
 *
 *  Returns:
 *      HRESULT
 *
 *  Errors:
 *      MAPI_E_INVALID_RECIPS
 *      MAPI_E_BAD_RECIPTYPE
 *      others passed through
 */
HRESULT HrAdrentryFromPrecip(lpMapiRecipDesc precip, ADRENTRY *padrentry)
{
    HRESULT         hr;
    LPSPropValue    pprop;
    LPSTR           pszAddress = NULL;

    // Validate lpMapiRecipDesc, ie, ensure that if there isn't an EntryID or
    // an Address there had better be a Display Name, otherwise we fail
    // like MAPI 0 with MAPI_E_FAILURE.

    if ((!precip->lpszAddress || !precip->lpszAddress[0]) &&
        (!precip->ulEIDSize || !precip->lpEntryID) &&
        (!precip->lpszName || !precip->lpszName[0]))
        {
        hr = MAPI_E_INVALID_RECIPS;
        goto ret;
        }

    if (NULL == s_lpWabObject)
        {
        hr = MAPI_E_FAILURE;
        goto ret;
        }
        
    hr = s_lpWabObject->AllocateBuffer(4 * sizeof(SPropValue), (LPVOID*)&padrentry->rgPropVals);
    if (hr)
        goto ret;

    pprop = padrentry->rgPropVals;

    //  Recipient type
    switch ((short)precip->ulRecipClass)
        {
        case MAPI_TO:
        case MAPI_CC:
        case MAPI_BCC:
            pprop->ulPropTag = PR_RECIPIENT_TYPE;
            pprop->Value.ul = precip->ulRecipClass;
            pprop++;
            break;
        default:
            hr = MAPI_E_BAD_RECIPTYPE;
            goto ret;
        }

    // Display Name
    if (precip->lpszName && *precip->lpszName)
        {
        ULONG cchName = lstrlen(precip->lpszName)+1;
        hr = s_lpWabObject->AllocateMore(cchName, padrentry->rgPropVals, (LPVOID*)&pprop->Value.lpszA);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_DISPLAY_NAME;
        StrCpyN(pprop->Value.lpszA, precip->lpszName, cchName);
        pprop++;
        }

    // Email Address
    if (precip->lpszAddress && *precip->lpszAddress)
        {
        ParseEmailAddress(precip->lpszAddress, NULL, &pszAddress);
        ULONG cchAddress = lstrlen(pszAddress)+1;
        hr = s_lpWabObject->AllocateMore(cchAddress, padrentry->rgPropVals, (LPVOID*)&pprop->Value.lpszA);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_EMAIL_ADDRESS;
        StrCpyN(pprop->Value.lpszA, pszAddress, cchAddress);
        pprop++;
        }

    // EntryID
    if (precip->ulEIDSize && precip->lpEntryID)
        {
        hr = s_lpWabObject->AllocateMore(precip->ulEIDSize, padrentry->rgPropVals, (LPVOID*)&pprop->Value.bin.lpb);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_ENTRYID;
        pprop->Value.bin.cb = precip->ulEIDSize;
        CopyMemory(pprop->Value.bin.lpb, precip->lpEntryID, precip->ulEIDSize);
        pprop++;
        }

    padrentry->cValues = (ULONG) (pprop - padrentry->rgPropVals);

    Assert(padrentry->cValues <= 4);

ret:
    if (pszAddress)
        MemFree(pszAddress);
    if ((hr) && (NULL != s_lpWabObject))
        {
        s_lpWabObject->FreeBuffer(padrentry->rgPropVals);
        padrentry->rgPropVals = NULL;
        }

    return hr;
}


/*
 -  HrAdrlistFromRgrecip
 -
 *  Purpose:
 *      Copies a list of simple MAPI recipients to a list of
 *      extended MAPI recipients.
 *
 *  Arguments:
 *      nRecips         in      count of recipient in input list
 *      lpRecips        in      list of recipients to be converted
 *      ppadrlist       out     output list
 *
 *  Returns:
 *      HRESULT
 *
 */
HRESULT HrAdrlistFromRgrecip(ULONG nRecips, lpMapiRecipDesc lpRecips, LPADRLIST *ppadrlist)
{
    HRESULT         hr;
    LPADRLIST       padrlist = NULL;
    lpMapiRecipDesc precip;
    ULONG           i;
    LPADRENTRY      padrentry = NULL;
    ULONG           cbAdrList = sizeof(ADRLIST) + nRecips * sizeof(ADRENTRY);

    *ppadrlist = NULL;
    if (NULL == s_lpWabObject)
        {
        hr = E_FAIL;
        goto exit;
        }
        
    hr = s_lpWabObject->AllocateBuffer(cbAdrList, (LPVOID*)&padrlist);
    if (hr)
        goto exit;
    ZeroMemory(padrlist, cbAdrList);

    //  Copy each entry.
    //  Note that the memory for each recipient's properties must
    //  be linked so that Address() can free it using MAPIFreeBuffer.
    for (i = 0, padrentry = padrlist->aEntries, precip = lpRecips; i < nRecips; i++, precip++, padrentry++)
        {
        //  Copy the entry. Unresolved names will not be resolved.
        hr = HrAdrentryFromPrecip(precip, padrentry);
        if (hr)
            goto exit;

        // increment count so we can effectively blow away the list if a failure
        // occurs.

        padrlist->cEntries++;
        }

    *ppadrlist = padrlist;

exit:
    Assert( !hr || (ULONG)hr > 26 );

    if (hr)
        FreePadrlist(padrlist);

    return hr;
}

HRESULT HrRgrecipFromAdrlist(LPADRLIST lpAdrList, lpMapiRecipDesc * lppRecips)
{
    HRESULT         hr = S_OK;
    lpMapiRecipDesc rgRecips = NULL;
    lpMapiRecipDesc pRecip;
    LPADRENTRY      pAdrEntry;
    LPSPropValue    pProp;
    ULONG           ul, ulProp;

    if (lpAdrList && lpAdrList->cEntries)
        {
        DWORD dwSize = sizeof(MapiRecipDesc) * lpAdrList->cEntries;

        hr = SMAPIAllocateBuffer(dwSize, (LPVOID*)&rgRecips);
        if (FAILED (hr))
            goto exit;
        ZeroMemory(rgRecips, dwSize);

        // Initialize the Padding

        for (ul = 0, pAdrEntry = lpAdrList->aEntries, pRecip = rgRecips; ul<lpAdrList->cEntries; ul++, pAdrEntry++, pRecip++)
            {
            for (ulProp = 0, pProp = pAdrEntry->rgPropVals; ulProp < pAdrEntry->cValues; ulProp++, pProp++)
                {
                ULONG cch;
                switch (PROP_ID(pProp->ulPropTag))
                    {
                    case PROP_ID(PR_ENTRYID):
                        hr = SMAPIAllocateMore(pProp->Value.bin.cb, rgRecips, (LPVOID*)(&(pRecip->lpEntryID)));
                        if (FAILED (hr))
                            goto exit;
                        pRecip->ulEIDSize = pProp->Value.bin.cb;
                        CopyMemory(pRecip->lpEntryID, pProp->Value.bin.lpb, pProp->Value.bin.cb);
                        break;

                    case PROP_ID(PR_EMAIL_ADDRESS):
                        cch = lstrlen(pProp->Value.lpszA)+1;
                        hr = SMAPIAllocateMore(cch, rgRecips, (LPVOID*)(&(pRecip->lpszAddress)));
                        if (FAILED (hr))
                            goto exit;
                        StrCpyN(pRecip->lpszAddress, pProp->Value.lpszA, cch);
                        break;

                    case PROP_ID(PR_DISPLAY_NAME):
                   	   cch = lstrlen(pProp->Value.lpszA)+1;
                        hr = SMAPIAllocateMore(cch, rgRecips,(LPVOID*)(&(pRecip->lpszName)));
                        if (FAILED (hr))
                            goto exit;
                        StrCpyN(pRecip->lpszName, pProp->Value.lpszA, cch);
                        break;

                    case PROP_ID(PR_RECIPIENT_TYPE):
                        pRecip->ulRecipClass = pProp->Value.l;
                        break;

                    default:
                        break;
                    }
                }
            }
        }
exit:
    if (hr)
        {
        MAPIFreeBuffer(rgRecips);
        rgRecips = NULL;
        }
    *lppRecips = rgRecips;
    return hr;
}

void ParseEmailAddress(LPSTR pszEmail, LPSTR *ppszAddrType, LPSTR *ppszAddress)
{
    CStringParser spAddress;
    char          chToken;

    Assert(ppszAddress);

    spAddress.Init(pszEmail, lstrlen(pszEmail), 0);

    // Parse the address for the delimiter

    chToken = spAddress.ChParse(":");

    if (chToken == ':')
        {
        if (ppszAddrType)
            *ppszAddrType = PszDup(spAddress.PszValue());
        spAddress.ChParse(c_szEmpty);
        *ppszAddress = PszDup(spAddress.PszValue());
        }
    else
        {
        if (ppszAddrType)
            *ppszAddrType = PszDup(c_szSMTP);
        *ppszAddress = PszDup(pszEmail);
        }
}


void FreePadrlist(LPADRLIST lpAdrList)
{
    if ((lpAdrList) && (NULL != s_lpWabObject))
        {
        for (ULONG ul = 0; ul < lpAdrList->cEntries; ul++)
            s_lpWabObject->FreeBuffer(lpAdrList->aEntries[ul].rgPropVals);
        s_lpWabObject->FreeBuffer(lpAdrList);
        }
}

ULONG AddMapiRecip(LPMIMEADDRESSTABLE pAddrTable, lpMapiRecipDesc lpRecip, BOOL bValidateRecips)
{
    LPSTR       pszName = NULL, pszAddress = NULL;
    LPSTR       pszNameFree = NULL, pszAddrFree = NULL;
    LPADRLIST   pAdrList = NULL;
    ULONG       ulPropCount;
    ULONG       ulRet = MAPI_E_FAILURE;
    HRESULT     hr;

    if (lpRecip->ulRecipClass > 3 || lpRecip->ulRecipClass < 1)
        return MAPI_E_BAD_RECIPTYPE;

    if (lpRecip->ulEIDSize && lpRecip->lpEntryID && SUCCEEDED(HrFromIDToNameAndAddress(&pszName, &pszAddress, lpRecip->ulEIDSize, (ENTRYID*)lpRecip->lpEntryID)))
        {
        pszNameFree = pszName;
        pszAddrFree = pszAddress;
        }
    else if (lpRecip->lpszAddress && *lpRecip->lpszAddress)
        {
        // we have an email address
        ParseEmailAddress(lpRecip->lpszAddress, NULL, &pszAddress);
        pszAddrFree = pszAddress;

        if (lpRecip->lpszName && *lpRecip->lpszName)
            pszName = lpRecip->lpszName;
        else
            // no name, so make it the same as the address
            pszName = pszAddress;
        }
    else if (lpRecip->lpszName && *lpRecip->lpszName)
        {
        if (bValidateRecips)
            {
            // we have a name, but no address, so resolve it
            hr = HrAdrlistFromRgrecip(1, lpRecip, &pAdrList);
            if (FAILED(hr))
                goto exit;

             // Call ResolveName of IAddrBook
            if (NULL == s_lpAddrBook)
                {
                ulRet = MAPI_E_FAILURE;
                goto exit;
                }
    
            hr = s_lpAddrBook->ResolveName(NULL, NULL, NULL, pAdrList);
            if (hr)
                {
                if (hr == MAPI_E_NOT_FOUND)
                    ulRet = MAPI_E_UNKNOWN_RECIPIENT;
                else if (hr == MAPI_E_AMBIGUOUS_RECIP)
                    ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
                else
                    ulRet = MAPI_E_FAILURE;
                goto exit;
                }
            else if ((pAdrList->cEntries != 1) || !pAdrList->aEntries->cValues)
                {
                ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
                goto exit;
                }
        
            for (ulPropCount = 0; ulPropCount < pAdrList->aEntries->cValues; ulPropCount++)
                {
                switch (pAdrList->aEntries->rgPropVals[ulPropCount].ulPropTag)
                    {
                    case PR_EMAIL_ADDRESS:
                        pszAddress = pAdrList->aEntries->rgPropVals[ulPropCount].Value.lpszA;
                        break;

                    case PR_DISPLAY_NAME:
                        pszName = pAdrList->aEntries->rgPropVals[ulPropCount].Value.lpszA;
                        break;

                    default:
                        break;
                    }
                }
            }
        else
            pszName = lpRecip->lpszName;
        }
    else
        {
        return MAPI_E_INVALID_RECIPS;
        }

    hr = pAddrTable->Append(MapiRecipToMimeOle(lpRecip->ulRecipClass), 
                            IET_DECODED, 
                            pszName, 
                            pszAddress,    
                            NULL);
    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;

exit:
    if (pszNameFree)
        MemFree(pszNameFree);
    if (pszAddrFree)
        MemFree(pszAddrFree);
    if (pAdrList)
        FreePadrlist(pAdrList);
    return ulRet;
}

///////////////////////////////////////////////////////////////////////////////////
//  Given a MapiMessage structure, this function creates a IMimeMessage object and
//  fills it with the appropriate structure members
//
//  Arguments:
//      pMsg            out      IMimeMessage pointer
//      ppStream        out      Stream pointer
//      lpMessage       in       Message structure
//      nc              in/out   NCINFO structure
//
//  Result
//      BOOL - TRUE if successful FALSE if failed
////////////////////////////////////////////////////////////////////////////////////

ULONG HrFillMessage(LPMIMEMESSAGE *pMsg, lpMapiMessage lpMessage, BOOL *pfWebPage, BOOL bValidateRecips, BOOL fOriginator)
{
    BOOL                    bRet = FALSE;

    LPSTREAM                pStream = NULL;
    LPMIMEADDRESSTABLE      pAddrTable = NULL;
    IImnAccount            *pAccount = NULL;
    HRESULT                 hr;
    LPSTR                   pszAddress;
    ULONG                   ulRet = MAPI_E_FAILURE;

    if (pfWebPage)
        *pfWebPage = FALSE;

     // create an empty message
    hr = HrCreateMessage(pMsg);
    if (FAILED(hr))
        goto error;

     // set the subject on the message
    if (lpMessage->lpszSubject)
        {
        hr = MimeOleSetBodyPropA(*pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, lpMessage->lpszSubject);
        if (FAILED(hr))
            goto error;
        }

    // set the body on the message
    if (lpMessage->lpszNoteText && *(lpMessage->lpszNoteText))
        {
        hr = MimeOleCreateVirtualStream(&pStream);
        if (FAILED(hr))
            goto error;

        hr = pStream->Write(lpMessage->lpszNoteText, lstrlen(lpMessage->lpszNoteText), NULL);
        if (FAILED(hr))
            goto error;

        hr = (*pMsg)->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, pStream, NULL);
        if (FAILED(hr))
            goto error;
        }

    // ignore lpMessage->lpszMessageType

    // ignore lpMessage->lpszDateReceived

    // ignore lpMessage->lpszConversationID

    // ignore lpMessage->flFlags

    // ignore lpMessage->lpOriginator

    // set the recipients on the message
    if (lpMessage->nRecipCount || fOriginator)
        {
        ULONG ulRecipRet;

        hr = (*pMsg)->GetAddressTable(&pAddrTable);
        if (FAILED(hr))
            goto error;

        for (ULONG i = 0; i < lpMessage->nRecipCount; i++)
            {
            ulRecipRet = AddMapiRecip(pAddrTable, &lpMessage->lpRecips[i], bValidateRecips);
            if (ulRecipRet != SUCCESS_SUCCESS)
                {
                ulRet = ulRecipRet;
                goto error;
                }
            }
        }

    // set the attachments on the message
    if (lpMessage->nFileCount)
        {
        // special case: no body & one .HTM file - inline the HTML
        if ((!lpMessage->lpszNoteText || !*(lpMessage->lpszNoteText)) &&
            lpMessage->nFileCount == 1 &&
            !(lpMessage->lpFiles->flFlags & MAPI_OLE) &&
            !(lpMessage->lpFiles->flFlags & MAPI_OLE_STATIC) &&
            FIsHTMLFile(lpMessage->lpFiles->lpszPathName))
            {
#if 0
            DWORD dwByteOrder;
            DWORD cbRead;
#endif

            Assert(NULL == pStream);
            hr = CreateStreamOnHFile(lpMessage->lpFiles->lpszPathName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL,
                                     &pStream);
            if (FAILED(hr))
                goto error;

#if 0
            // SBAILEY: Raid-75400 - Try to detect the byte order mark in the html....
            if (SUCCEEDED(pStream->Read(&dwByteOrder, sizeof(DWORD), &cbRead)) && cbRead == sizeof(DWORD))
            {
                // Byte Order
                if (dwByteOrder == 0xfffe)
                {
                    // Create a new stream
                    IStream *pStmTemp=NULL;

                    // Create it
                    if (SUCCEEDED(MimeOleCreateVirtualStream(&pStmTemp)))
                    {
                        // Copy pStream into pStmTemp
                        if (SUCCEEDED(HrCopyStream(pStream, pStmTemp, NULL)))
                        {
                            // Release pStream
                            pStream->Release();

                            // Assume pStmTemp
                            pStream = pStmTemp;

                            // Don't Release pStmTemp
                            pStmTemp = NULL;

                            // Should already be unicode
                            Assert(1200 == lpMessage->lpFiles->ulReserved);

                            // Make sure ulReserved is set to 1200
                            lpMessage->lpFiles->ulReserved = 1200;
                        }
                    }

                    // Cleanup
                    SafeRelease(pStmTemp);
                }
            }

            // Rewind
            HrRewindStream(pStream);
#endif

            // intl hack. If the shell is calling us, then lpFiles->ulReserved contains the codepage of
            // the webpage they're attaching. All other mapi clients should call us with 0 as this param.
            // if ulReserved is a valid CP, we'll convert to a HCHARSET and use that for the message.

            if (lpMessage->lpFiles->ulReserved)
                HrSetMsgCodePage((*pMsg), lpMessage->lpFiles->ulReserved);

            hr = (*pMsg)->SetTextBody(TXT_HTML, (1200 == lpMessage->lpFiles->ulReserved ? IET_UNICODE : IET_INETCSET), NULL, pStream, NULL);
            if (FAILED(hr))
                goto error;

            // we're sending this as a web page
            if (pfWebPage)
                *pfWebPage = TRUE;
            }
        else
            {
            lpMapiFileDesc pFile;
            LPSTREAM       pStreamFile;
            LPTSTR         pszFileName;

            for (ULONG i = 0; i < lpMessage->nFileCount; i++)
                {
                pFile = &lpMessage->lpFiles[i];

                if (pFile->lpszPathName && *(pFile->lpszPathName))
                    {
                    hr = CreateStreamOnHFile(pFile->lpszPathName,
                                             GENERIC_READ,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL,
                                             &pStreamFile);
                    if (FAILED(hr))
                        goto error;

                    if (pFile->lpszFileName && *pFile->lpszFileName)
                        pszFileName = pFile->lpszFileName;
                    else
                        pszFileName = pFile->lpszPathName;

                    hr = (*pMsg)->AttachFile(pszFileName, pStreamFile, NULL);

                    pStreamFile->Release();

                    if (FAILED(hr))
                        goto error;
                    }
                }
            }
        }

    if (fOriginator)
        {
        TCHAR szDisplayName[CCHMAX_DISPLAY_NAME];
        TCHAR szEmailAddress[CCHMAX_EMAIL_ADDRESS];
        TCHAR szAccountName[CCHMAX_DISPLAY_NAME];

        // Get the default account
        if (FAILED(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)))
            goto error;

        // Get Originator Display Name
        if (FAILED(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName))))
            goto error;

        // Get Originator Email Name
        if (FAILED(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress))))
            goto error;

        // Get the account Name
        if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName))))
            goto error;   
            
        // Append Sender
        if (FAILED(hr = pAddrTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL)))
            goto error;
 
        if (FAILED(hr = HrSetAccount(*pMsg, szAccountName)))
            goto error;
        }

    ulRet = SUCCESS_SUCCESS;

    // If you're not a web page (whose charset can be sniffed), set the default charset...
    if((NULL == pfWebPage) || (!(*pfWebPage)))
    {
        if (g_hDefaultCharsetForMail==NULL) 
            ReadSendMailDefaultCharset();

        (*pMsg)->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
    }

error:
    SafeRelease(pStream);
    SafeRelease(pAddrTable);
    SafeRelease(pAccount);

    return ulRet;
}

HRESULT AddRecipient(lpMapiMessage pMessage, lpMapiRecipDesc pRecip, ADDRESSPROPS *pAddress, ULONG ulRecipType)
{
    HRESULT     hr;
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID = NULL;
    LPSTR       pszAddrType = NULL;
    LPSTR       pszAddress = NULL;
    ULONG       cch;

    cch = lstrlen(pAddress->pszFriendly)+1;
    if (FAILED(hr = SMAPIAllocateMore(cch, pMessage, (LPVOID*)&(pRecip->lpszName))))
        goto exit;

    StrCpyN(pRecip->lpszName, pAddress->pszFriendly, cch);

    cch = lstrlen(pAddress->pszEmail)+1;
    if (FAILED(hr = SMAPIAllocateMore(cch, pMessage, (LPVOID*)&(pRecip->lpszAddress))))
        goto exit;

    StrCpyN(pRecip->lpszAddress, pAddress->pszEmail, cch);

    pRecip->ulReserved = 0;
    pRecip->ulRecipClass = ulRecipType;

    ParseEmailAddress(pRecip->lpszAddress, &pszAddrType, &pszAddress);

    if (NULL == s_lpAddrBook)
        {
        hr = E_FAIL;
        goto exit;
        }
    
    if (FAILED(hr = s_lpAddrBook->CreateOneOff(pRecip->lpszName, pszAddrType, pszAddress, 0, &cbEntryID, &lpEntryID)))
        goto exit;

    if (FAILED(hr = SMAPIAllocateMore(cbEntryID, pMessage, (LPVOID*)&(pRecip->lpEntryID))))
        goto exit;

    pRecip->ulEIDSize = cbEntryID;
    CopyMemory(pRecip->lpEntryID, lpEntryID, cbEntryID);

exit:
    if ((lpEntryID) && (NULL != s_lpWabObject))
        s_lpWabObject->FreeBuffer(lpEntryID);
    if (pszAddrType)
        MemFree(pszAddrType);
    if (pszAddress)
        MemFree(pszAddress);
    return hr;
}

HRESULT AddRecipientType(lpMapiMessage pMessage, LPMIMEADDRESSTABLE pAddrTable, DWORD dwAdrType, ULONG ulRecipType)
{
    IMimeEnumAddressTypes  *pEnum;
    ADDRESSPROPS            rAddress;
    HRESULT                 hr = S_OK;

    if (FAILED(hr = pAddrTable->EnumTypes(dwAdrType, IAP_FRIENDLY|IAP_EMAIL, &pEnum)))
        return MAPI_E_FAILURE;

    while (S_OK == pEnum->Next(1, &rAddress, NULL))
        {
        if (SUCCEEDED(hr = AddRecipient(pMessage, &pMessage->lpRecips[pMessage->nRecipCount], &rAddress, ulRecipType)))
            pMessage->nRecipCount++;
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }

    pEnum->Release();
    return hr;
}


HRESULT AddOriginator(lpMapiMessage pMessage, LPMIMEADDRESSTABLE pAddrTable)
{
    IMimeEnumAddressTypes  *pEnum;
    ADDRESSPROPS            rAddress;
    HRESULT                 hr = S_OK;

    if (FAILED(hr = pAddrTable->EnumTypes(IAT_FROM, IAP_FRIENDLY|IAP_EMAIL, &pEnum)))
        return MAPI_E_FAILURE;

    if (S_OK == pEnum->Next(1, &rAddress, NULL))
        {
        hr = AddRecipient(pMessage, pMessage->lpOriginator, &rAddress, MAPI_ORIG);
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }
    else
        {
        if (SUCCEEDED(hr = SMAPIAllocateMore(1, pMessage, (LPVOID*)&(pMessage->lpOriginator->lpszName))))
            {
            pMessage->lpOriginator->lpszAddress = pMessage->lpOriginator->lpszName;
            *pMessage->lpOriginator->lpszName = 0;
            }
        }

    pEnum->Release();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// Called by MAPIReadMail to Read an existing message in the store
// and copy in a MapiMessage structure  
// 
//  Arguments:
//      pFolder          in      pointer to IMessageFolder          
//      lpszMessageID    in      Message ID   
//      lppMessage       out     pointer to lpMapiMessage structure/      
//
//  Result
//      BOOL - TRUE if successful FALSE if failed
////////////////////////////////////////////////////////////////////////////////////

BOOL HrReadMail(IMessageFolder *pFolder, LPSTR lpszMessageID, lpMapiMessage FAR *lppMessage, FLAGS flFlags)
{
    ULONG                   nRecipCount=0, ulCount=0, nBody=0;
    HRESULT                 hr;
    MESSAGEID               dwMsgID;
    MESSAGEINFO             MsgInfo={0};
    IStream                 *pStream = NULL;
    IStream                 *pStreamHTML = NULL;
    IMimeMessage            *pMsg = NULL;
    LPMIMEADDRESSTABLE      pAddrTable = NULL;
    LPSTR                   pszTemp = 0;
    lpMapiMessage           rgMessage;
    ULONG                   ulSize,ulRead;
    PROPVARIANT             rVariant;
    FILETIME                localfiletime;
    SYSTEMTIME              systemtime;
    ULONG                   cAttach=0;
    LPHBODY                 rghAttach = 0;
    lpMapiFileDesc          rgFiles = NULL;
    BOOL                    bRet=FALSE;

    dwMsgID = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));

    MsgInfo.idMessage = dwMsgID;

    if (FAILED(pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL)))
        goto exit;

    if (FAILED(hr = pFolder->OpenMessage(dwMsgID, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK)))
        goto exit;

    // Allocate memory for rgMessage
    if (FAILED(hr = SMAPIAllocateBuffer(sizeof(MapiMessage), (LPVOID*)&rgMessage)))
        goto exit;
    ZeroMemory(rgMessage, sizeof(MapiMessage));

    // Get the subject
    if (SUCCEEDED(hr = MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pszTemp)))
        {
        ULONG cchTemp = lstrlen(pszTemp)+1;
        if (FAILED(hr = SMAPIAllocateMore(cchTemp, rgMessage, (LPVOID*)&(rgMessage->lpszSubject))))
            goto exit;
        StrCpyN(rgMessage->lpszSubject, pszTemp, cchTemp);
        SafeMimeOleFree(pszTemp);
        }

    // Get the body text
    if (!(flFlags & MAPI_ENVELOPE_ONLY))
        {
        if (FAILED(hr = pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
            {
            if (SUCCEEDED(hr = pMsg->GetTextBody(TXT_HTML, IET_INETCSET, &pStreamHTML, NULL)))
                {
                if (FAILED(hr = HrConvertHTMLToPlainText(pStreamHTML, &pStream, CF_TEXT)))
                    goto exit;
                }
            }
        if (pStream)
            {
            if (FAILED(hr = HrGetStreamSize(pStream, &ulSize)))
                goto exit;
            if (FAILED(hr = HrRewindStream(pStream)))
                goto exit;

            if (ulSize>0)
                {
                if (FAILED(hr = SMAPIAllocateMore(ulSize + 1, rgMessage, (LPVOID*)&(rgMessage->lpszNoteText))))
                    goto exit;

                if (FAILED(hr = pStream->Read((LPVOID)rgMessage->lpszNoteText, ulSize, &ulRead)))
                    goto exit;

                rgMessage->lpszNoteText[ulRead] = 0;
                }
            }
        }
    else
        {
        // if we don't call GetTextBody, then the GetAttachments call will consider the bodies as attachments
        if (FAILED(pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, NULL, NULL)))
            pMsg->GetTextBody(TXT_HTML, IET_INETCSET, NULL, NULL);
        }

    // Set the message date / Received Time...
    rVariant.vt = VT_FILETIME;
    if (SUCCEEDED(hr = pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME),0,&rVariant)))
        {
        if (!FileTimeToLocalFileTime(&rVariant.filetime, &localfiletime))
            goto exit;

        if (!FileTimeToSystemTime(&localfiletime, &systemtime))
            goto exit;

        if (FAILED(hr = SMAPIAllocateMore(20, rgMessage, (LPVOID*)&(rgMessage->lpszDateReceived))))
            goto exit;

        wnsprintf(rgMessage->lpszDateReceived,20,"%04.4d/%02.2d/%02.2d %02.2d:%02.2d", systemtime.wYear, systemtime.wMonth, systemtime.wDay, systemtime.wHour, systemtime.wMinute);
        }

    // Set the flags
    if (ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
        rgMessage->flFlags = 0;
    else
        rgMessage->flFlags = MAPI_UNREAD;

    // Get Address Table

    CHECKHR(hr = pMsg->GetAddressTable(&pAddrTable));

    if (FAILED(hr = SMAPIAllocateMore(sizeof(MapiRecipDesc), rgMessage, (LPVOID*)&(rgMessage->lpOriginator))))
        goto exit;
    ZeroMemory(rgMessage->lpOriginator, sizeof(MapiRecipDesc));

    if (FAILED(AddOriginator(rgMessage, pAddrTable)))
        goto exit;

    // Allocate space for the recipients    

    if (FAILED(pAddrTable->CountTypes(IAT_RECIPS, &nRecipCount)))
        goto exit;

    if (nRecipCount)
        {
        if (FAILED(hr = SMAPIAllocateMore(nRecipCount * sizeof(MapiRecipDesc), rgMessage, (LPVOID*)&(rgMessage->lpRecips))))
            goto exit;
        ZeroMemory(rgMessage->lpRecips, nRecipCount * sizeof(MapiRecipDesc));

        // Add the To
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_TO, MAPI_TO)))
            goto exit;

        // Add the Cc
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_CC, MAPI_CC)))
            goto exit;

        // Add the Bcc
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_BCC, MAPI_BCC)))
            goto exit;
        }

    // Fill the lpFiles structure
    if (FAILED(hr = pMsg->GetAttachments(&cAttach, &rghAttach)))
        goto exit;

    if (!(flFlags & (MAPI_SUPPRESS_ATTACH|MAPI_ENVELOPE_ONLY)))
    {
        if (flFlags & MAPI_BODY_AS_FILE)
            nBody = 1;

        if (cAttach + nBody)
        {
            if (FAILED(hr = SMAPIAllocateMore((cAttach + nBody) * sizeof(MapiFileDesc), rgMessage, (LPVOID*)&rgFiles)))
                goto exit;
        }

        // Check if MAPI_BODY_AS_FILE is set in flFlags
        if (flFlags & MAPI_BODY_AS_FILE)
        {
            TCHAR lpszPath[MAX_PATH];
        
            // Create a temporary file
            if (!FBuildTempPath ("msoenote.txt", lpszPath, MAX_PATH, FALSE))
                goto exit;
    
            if FAILED(hr = WriteStreamToFile(pStream, lpszPath, CREATE_ALWAYS, GENERIC_WRITE))
                goto exit;   

            // Reset the body back to NULL

            if (rgMessage->lpszNoteText)
                rgMessage->lpszNoteText[0] = '\0';
                
            // Make this file as the first attachment

            ULONG cchPath = lstrlen(lpszPath) + 1;
            if (FAILED(hr = SMAPIAllocateMore(cchPath, rgMessage, (LPVOID*)&(rgFiles[0].lpszFileName))))
                goto exit;
            if (FAILED(hr = SMAPIAllocateMore(cchPath, rgMessage, (LPVOID*)&(rgFiles[0].lpszPathName))))
                goto exit;

            StrCpyN(rgFiles[0].lpszPathName, lpszPath, cchPath);
            StrCpyN(rgFiles[0].lpszFileName, lpszPath, cchPath);
            rgFiles[0].ulReserved = 0;
            rgFiles[0].flFlags = 0;
            rgFiles[0].nPosition = 0;
            rgFiles[0].lpFileType = NULL;    
        }

        for (ulCount = 0; ulCount < cAttach; ulCount++)
        {
            LPMIMEBODY     pBody=0;
            TCHAR          lp