    return 0;
}

LRESULT CChanges::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_CHANGES_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, (int)wParam, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT CChanges::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    String str;
    for (int iItem = (int)wParam; iItem < (int)lParam; iItem++) {
        LPTSTR pszInfoTip = RECAST(LPTSTR, GetLVItem(iItem));
        if (pszInfoTip) {
            str << pszInfoTip << TEXT("\r\n");
        }
    }
    SetClipboardText(_hwnd, str);
    return 0;
}

LRESULT CChanges::ON_LM_DELETEITEM(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    if (lParam) {
        LocalFree(RECAST(HLOCAL, lParam));
    }
    return 0;
}

LRESULT
CChanges::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETINFOTIP);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    FW_MSG(LM_DELETEITEM);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  We build the hint only on demand since it takes a while and we
//  don't want to slow down the initial query.
//
void CChanges::_BuildHint()
{
    String str;

    if (!_scQuery.IsEmpty()) {
        String strTok, strPath;
        Tokenizer tok(_scQuery);
        while (tok.Token(strTok)) {
            Substring ss;
            if (Parse(TEXT("$p"), strTok, &ss) && ss.Length() > 0) {
                ss.Finalize();          // Strip off the revision specifier
                if (MapToFullDepotPath(strTok, strPath)) {
                    str << TEXT(' ') << QuoteSpaces(strPath);
                }
            }
        }
    }

    _scHint = str;
}

//
//  A private helper class that captures the parsing state machine.
//
class ChangesParseState : public CommentParser
{
public:
    ChangesParseState(HWND hwndChild) : _iItem(-1), _hwndChild(hwndChild) {}

    void Flush()
    {
        if (_iItem >= 0) {
            _strFullDescription.Chomp();
            LVITEM lvi;
            lvi.iItem = _iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            lvi.lParam = RECAST(LPARAM, StrDup(_strFullDescription));
            ListView_SetItem(_hwndChild, &lvi);
        }
        _iItem = -1;
        CommentParser::Reset();
        _strFullDescription.Reset();
    }

    void AddLine(LPCTSTR psz)
    {
        _strFullDescription << psz;
    }

    void AddError(LPCTSTR psz)
    {
        _iItem = _CChanges_AddError(_hwndChild, psz);
    }

    void AddEntry(Substring *rgss)
    {
        LVITEM lvi;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = MAXLONG;
        lvi.iSubItem = 0;
        lvi.pszText = rgss[0].Finalize();
        _iItem = lvi.iItem = ListView_InsertItem(_hwndChild, &lvi);

        if (lvi.iItem >= 0) {
            lvi.iSubItem = 1;
            lvi.pszText = rgss[1].Finalize();
            ListView_SetItem(_hwndChild, &lvi);

            lvi.iSubItem = 2;
            lvi.pszText = rgss[2].Finalize();
            LPTSTR psz = StrChr(lvi.pszText, TEXT('\\'));
            if (psz) {
                lvi.pszText = psz+1;
            }
            ListView_SetItem(_hwndChild, &lvi);

            if (lvi.iItem == 0) {
                ListView_SetCurSel(_hwndChild, 0);  /* Select the first item */
            }
        }
    }

    void SetListViewSubItemText(int iSubItem, LPCTSTR psz)
    {
        if (_iItem >= 0) {
            LVITEM lvi;
            lvi.mask = LVIF_TEXT;
            lvi.iItem = _iItem;
            lvi.iSubItem = iSubItem;
            lvi.pszText = CCAST(LPTSTR, psz);
            ListView_SetItem(_hwndChild, &lvi);
        }
    }

    void SetDev(LPCTSTR psz)
    {
        SetListViewSubItemText(2, psz);
    }

    void SetComment(LPCTSTR psz)
    {
        SetListViewSubItemText(3, psz);
    }

private:
    HWND        _hwndChild;
    int         _iItem;
    BOOL        _fHaveComment;
    String      _strFullDescription;
};


DWORD CALLBACK CChanges::s_BGInvoke(LPVOID lpParam)
{
    CChanges *self = RECAST(CChanges *, lpParam);
    return self->_BGInvoke();
}

BOOL CChanges::_BGGetSdCommandLine(String &str)
{
    str.Reset();
    str << TEXT("changes -l -s submitted ");

    /*
     *  Parse the switches as best we can.
     */
    BOOL fMSeen = FALSE;
    GetOpt opt(TEXT("mu"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('m'):
            fMSeen = TRUE;
            str << TEXT("-m ") << opt.GetValue() << TEXT(" ");
            break;

        case TEXT('i'):
            str << TEXT("-i ");
            break;

        case TEXT('u'):
            if (GlobalSettings.IsVersion(1, 60)) {
                str << TEXT("-u ") << opt.GetValue() << TEXT(" ");
            } else {
                _scUser = opt.GetValue();
            }
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            Help(_hwnd, TEXT("#chang"));
            return FALSE;
        }
    }
L_switch:;

    if (!fMSeen) {
        str << TEXT("-m50 ");
    }

    /*
     *  If no filename is given, use *
     *
     *  The query string will be useful later, so cache that away, too.
     */
    String strQuery;

    if (opt.Finished()) {
        strQuery << TEXT("*");
    } else {
        while (opt.Token()) {
            if (opt.GetValue()[0]) {
               strQuery << ResolveBranchAndQuoteSpaces(opt.GetValue()) << TEXT(" ");
            }
        }
    }

    str << strQuery;
    _scQuery = strQuery;

    return TRUE;
}


DWORD CChanges::_BGInvoke()
{
    String str;
    if (_BGGetSdCommandLine(str)) {
        SDChildProcess proc(str);
        IOBuffer buf(proc.Handle());
        ChangesParseState state(_hwndChild);
        while (buf.NextLine(str)) {
            Substring rgss[3];          // changeno, date, userid
            if (Parse(TEXT("Change $d on $D by $p"), str, rgss)) {
                state.Flush();
                state.AddLine(str);
                if (!_scUser.IsEmpty() &&
                    lstrcmpi(rgss[2].Finalize(), _scUser) != 0) {
                    /* This change is not for us; ignore it */
                } else {
                    state.AddEntry(rgss);
                }
            } else if (str[0] == TEXT('\r')) {
                state.AddLine(str);
            } else if (str[0] == TEXT('\t')) {
                state.AddLine(str);
                str.Chomp();
                state.AddComment(str);
            } else {
                state.Flush();
                str.Chomp();
                state.AddError(str);
            }
        }
        state.Flush();
    } else {
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    BGEndTask();
    return 0;
}

DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CChanges, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\describe.cpp ===
/*****************************************************************************
 *
 *  describe.cpp
 *
 *      View a changelist a description.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class CDescribe
 *
 *****************************************************************************/

//
//  The LPARAM of the listview item has the following form:
//
//  HIWORD = enum CATEGORY
//  LOWORD = original index (to break ties during sorting)
//
enum CATEGORY {
    CAT_HEADER,                 // changelist header
    CAT_MATCHED,                // file that matches the pattern
    CAT_BLANK1,                 // separates matched from unmatched
    CAT_UNMATCHED,              // files that don't match the pattern
    CAT_BLANK2,                 // separates unmatched from unchanged
    CAT_UNCHANGED,              // unmatched files that weren't change
};

class CDescribe : public LVFrame, public BGTask {

    friend DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        DM_RECALC = WM_APP
    };

    typedef LVFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_DM_RECALC(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    CDescribe()
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_DESCRIBE));
    }

    void _ResetChildWidth();
    void _AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu);
    LPTSTR _GetSanitizedLine(int iItem, LPTSTR pszBuf, UINT cch);
    void ViewOneFile();
    void ViewFileLog();
    int _GetBugNumber(int iItem, BOOL fContextMenu);

    static LPTSTR _SanitizeClipboardText(LPTSTR psz);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();

private:
    int         _cxMax;
    int         _iBug;
    Substring   _ssChange;
};

LRESULT CDescribe::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    static const LVFCOLUMN s_rgcol[] = {
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    LRESULT lres;

    if (Parse(TEXT("$d"), _pszQuery, &_ssChange)) {
        String str;
        str << TEXT("sdv describe ") << _ssChange;
        SetWindowText(_hwnd, str);

        lres = super::HandleMessage(uiMsg, wParam, lParam);
        if (lres == 0 &&
            SetWindowMenu(MAKEINTRESOURCE(IDM_DESCRIBE)) &&
            CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                        LVS_NOCOLUMNHEADER,
                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT) &&
            AddColumns(s_rgcol) &&
            (SetWindowRedraw(_hwndChild, FALSE), TRUE) &&
            BGStartTask(s_BGInvoke, this)) {
        } else {
            lres = -1;
        }
    } else {
        Help(_hwnd, TEXT("#descr"));
        lres = -1;
    }
    return lres;
}

LRESULT CDescribe::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

LPTSTR CDescribe::_GetSanitizedLine(int iItem, LPTSTR pszBuf, UINT cch)
{
    LPTSTR pszPath = NULL;
    if (iItem >= 0 &&
        ListView_GetItemText(_hwndChild, iItem, pszBuf, cch)) {
        LPTSTR psz =_SanitizeClipboardText(pszBuf);
        if (psz != pszBuf) {
            pszPath = psz;
        }
    }
    return pszPath;
}

void CDescribe::ViewOneFile()
{
    TCHAR sz[MAX_PATH];
    LPTSTR pszPath = _GetSanitizedLine(GetCurSel(), sz, ARRAYSIZE(sz));
    if (pszPath) {
        WindiffOneChange(pszPath);
    }
}

void CDescribe::ViewFileLog()
{
    TCHAR sz[MAX_PATH];
    LPTSTR pszPath = _GetSanitizedLine(GetCurSel(), sz, ARRAYSIZE(sz));
    if (pszPath) {
        String str;
        LPTSTR pszSharp = StrChr(pszPath, TEXT('#'));
        if (pszSharp) {
            *pszSharp++ = TEXT('\0');
            str << TEXT("-#") << pszSharp << TEXT(' ');
        }
        str << pszPath;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
}

LRESULT CDescribe::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWFILEDIFF:
        ViewOneFile();
        return 0;

    case IDM_VIEWWINDIFF:
        WindiffChangelist(StrToInt(_ssChange._pszMin));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(GetCurSel(), FALSE);
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        ViewFileLog();
        break;

    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  Execute the default context menu item.
//
LRESULT CDescribe::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = RECAST(HMENU, ON_LM_GETCONTEXTMENU(LM_GETCONTEXTMENU, wParam, 0));
    if (hmenu) {
        FORWARD_WM_COMMAND(_hwnd, GetMenuItemID(hmenu, 0), NULL, 0, SendMessage);
        DestroyMenu(hmenu);
    }
    return 0;
}

int CDescribe::_GetBugNumber(int iItem, BOOL fContextMenu)
{
    LPARAM lParam = RECAST(LPARAM, GetLVItem(iItem));
    int iBug = 0;
    if (HIWORD(lParam) == CAT_HEADER && iItem != 0) {
        iBug = ParseBugNumberFromSubItem(_hwndChild, iItem, 0);
    }

    // If no bug number on the selection, use the default bug number
    // for this changelist.

    if (iBug == 0 && !fContextMenu) {
        iBug = _iBug;
    }

    return iBug;
}

void CDescribe::_AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu)
{
    TCHAR sz[MAX_PATH];
    sz[0] = TEXT('\0');
    if (iItem >= 0) {
        ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz));
    }

    //
    //  Disable IDM_VIEWFILEDIFF and IDM_VIEWFILELOG
    //  if this is not a "..." item.
    //
    BOOL fEnable = (Parse(TEXT("... "), sz, NULL) != NULL);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILEDIFF, fEnable, fContextMenu);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);

    //
    //  If a context menu, then nuke IDM_VIEWWINDIFF if this is not
    //  the "Change" item.
    //

    if (fContextMenu && iItem != 0) {
        DeleteMenu(hmenu, IDM_VIEWWINDIFF, MF_BYCOMMAND);
    }

    AdjustBugMenu(hmenu, _GetBugNumber(iItem, fContextMenu), fContextMenu);

    MakeMenuPretty(hmenu);
}

LRESULT CDescribe::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), GetCurSel(), FALSE);
    return 0;
}

LRESULT CDescribe::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_DESCRIBE_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, (int)wParam, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

//
//  If the line begins "...", then strip off everything except for the
//  depot specification.
//
LPTSTR CDescribe::_SanitizeClipboardText(LPTSTR psz)
{
    Substring rgss[2];
    if (Parse(TEXT("... $P#$d"), psz, rgss)) {
        *(rgss[1]._pszMax) = TEXT('\0');
        return rgss[0].Start();
    } else {
        return psz;
    }
}

LRESULT CDescribe::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    String str;
    TCHAR sz[MAX_PATH];

    int iMin = (int)wParam;
    int iMax = (int)lParam;

    // If a single-line copy, then special rules apply
    if (iMin + 1 == iMax) {
        if (ListView_GetItemText(_hwndChild, iMin, sz, ARRAYSIZE(sz))) {
            str << _SanitizeClipboardText(sz);
        }
    } else {
        for (int iItem = iMin; iItem < iMax; iItem++) {
            if (ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz))) {
                str << sz;
            }
            str << TEXT("\r\n");
        }
    }
    SetClipboardText(_hwnd, str);
    return 0;
}

LRESULT CDescribe::ON_DM_RECALC(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    ListView_SetColumnWidth(_hwndChild, 0, LVSCW_AUTOSIZE);
    _cxMax = ListView_GetColumnWidth(_hwndChild, 0);
    _ResetChildWidth();

    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARTIAL;
    lvfi.psz = TEXT("...");

    int iFirst = ListView_FindItem(_hwndChild, -1, &lvfi);
    if (iFirst >= 0) {
        ListView_SetCurSel(_hwndChild, iFirst);
    }

    SetWindowRedraw(_hwndChild, TRUE);

    return 0;
}

void CDescribe::_ResetChildWidth()
{
    RECT rc;
    GetClientRect(_hwndChild, &rc);
    int cxMargins = GetSystemMetrics(SM_CXEDGE) * 2;
    int cxCol = max(_cxMax + cxMargins, rc.right);
    ListView_SetColumnWidth(_hwndChild, 0, cxCol);
}

LRESULT CDescribe::ON_WM_SIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    super::HandleMessage(uiMsg, wParam, lParam);
    if (_cxMax) {
        _ResetChildWidth();
    }
    return 0;
}

LRESULT
CDescribe::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_SIZE);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    FW_MSG(DM_RECALC);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class DescribeParseState
{
    enum PHASE {
        PHASE_HEADERS,              // collecting the header
        PHASE_FILES,                // collecting the files
        PHASE_DIFFS,                // collecting the diffs
    };

public:
    DescribeParseState(HWND hwndChild, LPCTSTR pszPattern)
        : _m(pszPattern)
        , _hwndChild(hwndChild)
        , _iPhase(PHASE_HEADERS)
        , _iLine(0)
        , _iMatch(-1)
        , _iBug(0)
        , _fAnyMatch(FALSE) { }

    void AddLine(LPTSTR psz, int iCat)
    {
        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = _iLine;
        lvi.iSubItem = 0;
        lvi.pszText = psz;
        lvi.lParam = MAKELONG(_iLine, iCat);
        _iLine++;

        ChangeTabsToSpaces(psz);

        ListView_InsertItem(_hwndChild, &lvi);
    }

    void SetMatchLine(LPTSTR psz)
    {
        // Turn the "====" into "..." so we can search for it
        LPTSTR pszDots = psz+1;
        pszDots[0] = TEXT('.');
        pszDots[1] = TEXT('.');
        pszDots[2] = TEXT('.');

        LPTSTR pszSharp = StrChr(pszDots, TEXT('#'));
        if (!pszSharp) return;
        pszSharp[1] = TEXT('\0');   // this wipes out the thing after the '#'

        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARTIAL;
        lvfi.psz = pszDots;

        _iMatch = ListView_FindItem(_hwndChild, 0, &lvfi);

        if (_iMatch >= 0) {
            _cAdded = _cDeleted = 0;
        }
    }

    void FlushMatch()
    {
        if (_iMatch >= 0) {
            String str;
            str.Grow(MAX_PATH-1);
            LVITEM lvi;
            lvi.iItem = _iMatch;
            lvi.mask = LVIF_TEXT | LVIF_PARAM;
            lvi.iSubItem = 0;
            lvi.pszText = str;
            lvi.cchTextMax = str.BufferLength();
            if (ListView_GetItem(_hwndChild, &lvi)) {
                str.SetLength(lstrlen(str));
                str << TEXT(" (") << _cDeleted << TEXT('/') << _cAdded << TEXT(")");
                lvi.pszText = str;
                if (_cDeleted + _cAdded == 0) {
                    lvi.lParam = MAKELONG(LOWORD(lvi.lParam), CAT_UNCHANGED);
                }
                ListView_SetItem(_hwndChild, &lvi);
            }
            _iMatch = -1;
        }
    }

    void ParseLine(String& str)
    {
        Substring rgss[3];

        switch (_iPhase) {
        case PHASE_HEADERS:
            if (Parse(TEXT("... "), str, NULL)) {
                _iPhase = PHASE_FILES;
                goto L_PHASE_FILES;
            }
            if (_iBug == 0 && str[0] == TEXT('\t')) {
                _iBug = ParseBugNumber(str);
            }
            AddLine(str, CAT_HEADER);
            break;

        case PHASE_FILES:
            if (Parse(TEXT("... "), str, NULL)) {
L_PHASE_FILES:
                int iCat;
                if (_m.Matches(str + 4)) {
                    _fAnyMatch = TRUE;
                    iCat = CAT_MATCHED;
                } else {
                    iCat = CAT_UNMATCHED;
                }
                AddLine(str, iCat);
            } else {
                _iPhase = PHASE_DIFFS;
            }
            break;

        case PHASE_DIFFS:
            if (Parse(TEXT("==== "), str, NULL)) {
                SetMatchLine(str);
            } else if (Parse(TEXT("add $d chunks $d lines"), str, rgss)) {
                _cAdded += StrToInt(rgss[1].Finalize());
            } else if (Parse(TEXT("deleted $d chunks $d lines"), str, rgss)) {
                _cDeleted += StrToInt(rgss[1].Finalize());
            } else if (Parse(TEXT("changed $d chunks $d / $d lines"), str, rgss)) {
                _cDeleted += StrToInt(rgss[1].Finalize());
                _cAdded += StrToInt(rgss[2].Finalize());
                FlushMatch();
            }
            break;
        }
    }

    int Finish()
    {
        if (_fAnyMatch) {
            AddLine(TEXT(""), CAT_BLANK1);
        }
        AddLine(TEXT(""), CAT_BLANK2);
        ListView_SortItems(_hwndChild, s_Compare, 0);

        return _iBug;
    }

    static int CALLBACK s_Compare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
    {
        return (int)(lParam1 - lParam2);
    }

private:
    Match       _m;
    HWND        _hwndChild;
    int         _iPhase;
    int         _iLine;
    int         _iMatch;
    int         _iBug;
    int         _cAdded;
    int         _cDeleted;
    BOOL        _fAnyMatch;
};

DWORD CALLBACK CDescribe::s_BGInvoke(LPVOID lpParam)
{
    CDescribe *self = RECAST(CDescribe *, lpParam);
    return self->_BGInvoke();
}

DWORD CDescribe::_BGInvoke()
{
    DescribeParseState state(_hwndChild, _ssChange._pszMax);

    String str;
    str << TEXT("describe ");
    if (GlobalSettings.IsChurnEnabled()) {
        str << TEXT("-ds ");
    } else {
        str << TEXT("-s ");
    }
    str << _ssChange;

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        str.Chomp();
        state.ParseLine(str);
    }

    _iBug = state.Finish();

    PostMessage(_hwnd, DM_RECALC, 0, 0);

    BGEndTask();
    return 0;
}

DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CDescribe, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\filelog.cpp ===
/*****************************************************************************
 *
 *  filelog.cpp
 *
 *      View a filelog.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  LogEntry
 *
 *  A single item in a filelog treelist.
 *
 *****************************************************************************/

class LogEntry : public TreeItem {

public:
    LogEntry(LPCTSTR pszRev,
             LPCTSTR pszChange,
             LPCTSTR pszOp,
             LPCTSTR pszDate,
             LPCTSTR pszDev);
    LogEntry() { }

    int GetRev() const { return _iRev; }

    void SetChildPath(LPCTSTR pszChildPath);
    const StringCache& GetChildPath() const { return _scChildPath; }

    void SetIntegrateType(LPCTSTR pszType);
    void SetIsDonor() { _fDonor = TRUE; }
    void SetComment(LPCTSTR pszComment) { _scComment = pszComment; }
    void SetDev(LPCTSTR pszDev) { _scDev = pszDev; }
    void SetFullDescription(LPCTSTR pszFullDescription) {  _scFullDescription = pszFullDescription; }
    void SetChurn(int cAdded, int cDeleted) { _cAdded = cAdded; _cDeleted = cDeleted; }
    BOOL IsChurnSet() const { return _cAdded >= 0; }

    LRESULT GetDispInfo(NMTREELIST *pdi, int iColumn);
    LRESULT GetInfoTip(NMTREELIST *pdi);

    LPCTSTR GetChange() const { return _scChange; }
    LPCTSTR GetComment() const { return _scComment; }

private:
    void GetRevDispInfo(NMTREELIST *ptl);
    void GetChurnDispInfo(NMTREELIST *ptl);
    void GetImage(NMTREELIST *ptl);
private:
    int         _iRev;                  // File revision number
    int         _cDeleted;              // Number of lines deleted
    int         _cAdded;                // Number of lines added
    int         _iOp;                   // Checkin operation
    BOOL        _fDonor;                // Is integration donor
    StringCache _scChange;              // Change number
    StringCache _scOp;                  // Checkin operation (edit, delete, tc.)
    StringCache _scDate;                // Checkin date
    StringCache _scDev;                 // Checkin dev
    StringCache _scComment;             // Checkin comment
    StringCache _scFullDescription;     // Full checkin description
    StringCache _scChildPath;           // Depot path of child items
};

void LogEntry::SetChildPath(LPCTSTR pszChildPath)
{
    String str(pszChildPath);

    LPTSTR pszSharp = StrChr(str, TEXT('#'));
    if (pszSharp) {
        LPTSTR pszComma = StrChr(pszSharp, TEXT(','));

        if (!pszComma) {
            String strT(pszSharp);
            str << TEXT(",") << strT;
        }
    }

    _scChildPath = str;

    SetExpandable();
}

LogEntryImageMap c_rgleim[] = {
    {   TEXT("?")                   ,      -1       },  // OP_UNKNOWN
    {   TEXT("edit")                ,       0       },  // OP_EDIT
    {   TEXT("delete")              ,       1       },  // OP_DELETE
    {   TEXT("add")                 ,       2       },  // OP_ADD
    {   TEXT("integrate")           ,       3       },  // OP_INTEGRATE
    {   TEXT("merge")               ,       3       },  // OP_MERGE
    {   TEXT("branch")              ,       4       },  // OP_BRANCH
    {   TEXT("copy")                ,       5       },  // OP_COPY
    {   TEXT("ignored")             ,       6       },  // OP_IGNORED
};

int ParseOp(LPCTSTR psz)
{
    int i;
    for (i = ARRAYSIZE(c_rgleim) - 1; i > 0; i--) {
        if (StrCmp(c_rgleim[i]._pszOp, psz) == 0) {
            break;
        }
    }
    return i;
}

void LogEntry::SetIntegrateType(LPCTSTR pszType)
{
    if (_iOp == OP_INTEGRATE) {
        _iOp = ParseOp(pszType);
    }
}

LogEntry::LogEntry(
             LPCTSTR pszRev,
             LPCTSTR pszChange,
             LPCTSTR pszOp,
             LPCTSTR pszDate,
             LPCTSTR pszDev)
    : _iRev(StrToInt(pszRev))
    , _scChange(pszChange)
    , _iOp(ParseOp(pszOp))
    , _scDate(pszDate)
    , _scDev(pszDev)
    , _cAdded(-1)
{
}

void LogEntry::GetImage(NMTREELIST *ptl)
{
    ptl->iSubItem = c_rgleim[_iOp]._iImage;
    ptl->cchTextMax = INDEXTOOVERLAYMASK(_fDonor);
}

//
// Combine the pszParent and the pszRev to form the real pszRev
// Since the rev is the more important thing, I will display it
// in the form
//
//      19 Lab06_DEV/foo.cpp
//
//

void LogEntry::GetRevDispInfo(NMTREELIST *ptl)
{
    OutputStringBuffer str(ptl->pszText, ptl->cchTextMax);
    str << _iRev;
    LogEntry *ple = SAFECAST(LogEntry*, Parent());
    if (ple->GetChildPath()) {
        str << TEXT(" ") << BranchOf(ple->GetChildPath()) <<
               TEXT("/") << FilenameOf(ple->GetChildPath());
    }
}

void LogEntry::GetChurnDispInfo(NMTREELIST *ptl)
{
    if (_cAdded >= 0) {
        OutputStringBuffer str(ptl->pszText, ptl->cchTextMax);
        str << _cDeleted << TEXT('/') << _cAdded;
    }
}


LRESULT LogEntry::GetDispInfo(NMTREELIST *ptl, int iColumn)
{
    switch (iColumn) {
    case -1: GetImage(ptl); break;
    case 0: GetRevDispInfo(ptl); break;
    case 1: ptl->pszText = _scChange; break;
    case 2: ptl->pszText = CCAST(LPTSTR, c_rgleim[_iOp]._pszOp); break;
    case 3: ptl->pszText = _scDate; break;
    case 4: ptl->pszText = _scDev; break;
    case 5: GetChurnDispInfo(ptl); break;
    case 6: ptl->pszText = _scComment; break;
    }
    return 0;
}


LRESULT LogEntry::GetInfoTip(NMTREELIST *ptl)
{
    ptl->pszText = _scFullDescription;
    return 0;
}

/*****************************************************************************
 *
 *  class CFileLog
 *
 *****************************************************************************/

class CFileLog : public TLFrame {

    friend DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        FL_INITIALIZE = WM_APP
    };

    typedef TLFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_FL_INITIALIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    CFileLog() : TLFrame(new LogEntry)
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_FILELOG));
    }

    LogEntry *LEGetCurSel() { return SAFECAST(LogEntry*, TLGetCurSel()); }

    // -ds support was added in version 1.50
    BOOL IsChurnEnabled()
        { return GlobalSettings.IsChurnEnabled() &&
                 GlobalSettings.IsVersion(1, 50); }

    BOOL _ChooseColumns();
    BOOL _ParseQuery();
    LRESULT _FillChildren(LogEntry *pleRoot, LPCTSTR pszRootPath);
    LRESULT _OnItemActivate(LogEntry *ple);
    LRESULT _OnGetContextMenu(LogEntry *ple);

    BOOL _IsViewFileLogEnabled(LogEntry *ple);
    LRESULT _ViewFileLog(LogEntry *ple);
    LRESULT _ViewChangelist(LogEntry *ple);
    void _AdjustMenu(HMENU hmenu, LogEntry *ple, BOOL fContextMenu);

    int _GetChangeNumber(LogEntry *ple);
    int _GetBugNumber(LogEntry *ple);

    struct FLCOLUMN {
        const LVFCOLUMN*    _rgcol;
        const int *         _rgColMap;
        int                 _ccol;
    };

private:
    const FLCOLUMN*     _pflc;
    BOOL                _fIsRestrictedRoot;

    // Used during initialization
    int                 _iHighlightRev;
    LogEntry *          _pleHighlight;
    StringCache         _scSwitches;
    StringCache         _scPath;
};

BOOL CFileLog::_ChooseColumns()
{
    static const LVFCOLUMN c_rgcolChurn[] = {
        { 30 ,IDS_COL_REV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        {  7 ,IDS_COL_OP        ,LVCFMT_LEFT    },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHURN     ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    static const int c_rgiChurn[] = { 0, 1, 2, 3, 4, 5, 6 };

    static const FLCOLUMN c_flcChurn = {
        c_rgcolChurn,
        c_rgiChurn,
        ARRAYSIZE(c_rgiChurn),
    };

    static const LVFCOLUMN c_rgcolNoChurn[] = {
        { 30 ,IDS_COL_REV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        {  7 ,IDS_COL_OP        ,LVCFMT_LEFT    },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    static const int c_rgiNoChurn[] = { 0, 1, 2, 3, 4, 6 };

    static const FLCOLUMN c_flcNoChurn = {
        c_rgcolNoChurn,
        c_rgiNoChurn,
        ARRAYSIZE(c_rgiNoChurn),
    };

    if (IsChurnEnabled()) {
        _pflc = &c_flcChurn;
    } else {
        _pflc = &c_flcNoChurn;
    }

    return AddColumns(_pflc->_rgcol);
}


LRESULT CFileLog::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    if (_ParseQuery()) {
        lres = super::HandleMessage(uiMsg, wParam, lParam);
        if (lres == 0 &&
            _tree.GetRoot() &&
            SetWindowMenu(MAKEINTRESOURCE(IDM_FILELOG)) &&
            CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                        LVS_NOSORTHEADER,
                        LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                        LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
            _ChooseColumns()) {
            PostMessage(_hwnd, FL_INITIALIZE, 0, 0);
        } else {
            lres = -1;
        }
    } else {
        Help(_hwnd, TEXT("#filel"));
        lres = -1;
    }
    return lres;
}

LRESULT CFileLog::ON_FL_INITIALIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _FillChildren(SAFECAST(LogEntry*, _tree.GetRoot()), _scPath);
    _tree.Expand(_tree.GetRoot());

    // Clean out the stuff that's used only for the initial root expand
    _scSwitches = NULL;
    _iHighlightRev = 0;
    if (_pleHighlight) {
        _tree.SetCurSel(_pleHighlight);
    } else {
        ListView_SetCurSel(_hwndChild, 0);
    }
    return 0;
}

int CFileLog::_GetBugNumber(LogEntry *ple)
{
    if (ple) {
        return ParseBugNumber(ple->GetComment());
    } else {
        return 0;
    }
}

int CFileLog::_GetChangeNumber(LogEntry *ple)
{
    if (ple) {
        return StrToInt(ple->GetChange());
    } else {
        return 0;
    }
}

//
//  View Filelog is enabled if it would show you something different
//  from what you're looking at right now.
//
BOOL CFileLog::_IsViewFileLogEnabled(LogEntry *ple)
{
    if (!ple) {
        return FALSE;               // not even an item!
    }

    if (_fIsRestrictedRoot) {
        return TRUE;                // View Filelog shows unrestricted
    }

    //
    //  Short-circuit the common case where you are already at top-level.
    //
    if (ple->Parent() == _tree.GetRoot()) {
        return FALSE;               // You're looking at it already
    }

    //
    //  Watch out for the loopback scenario where you chase integrations
    //  out and then back in...
    //
    LPCTSTR pszRoot = SAFECAST(LogEntry *, _tree.GetRoot())->GetChildPath();
    LPCTSTR pszThis = SAFECAST(LogEntry *, ple->Parent())->GetChildPath();
    int cchRoot = lstrlen(pszRoot);

    if (StrCmpNI(pszRoot, pszThis, cchRoot) == 0 &&
        (pszThis[cchRoot] == TEXT('#') || pszThis[cchRoot] == TEXT('\0'))) {
        return FALSE;
    }

    return TRUE;
}

LRESULT CFileLog::_ViewFileLog(LogEntry *ple)
{
    if (!_IsViewFileLogEnabled(ple)) {
        return 0;
    }

    Substring ss;
    if (Parse(TEXT("$P"), SAFECAST(LogEntry *, ple->Parent())->GetChildPath(), &ss)) {
        String str;
        str << TEXT("-#") << ple->GetRev() << TEXT(" ") << ss;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
    return 0;
}

LRESULT CFileLog::_ViewChangelist(LogEntry *ple)
{
    if (ple) {
        LaunchThreadTask(CDescribe_ThreadProc, ple->GetChange());
    }
    return 0;
}

LRESULT CFileLog::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWDESC:
        return _ViewChangelist(LEGetCurSel());

    case IDM_VIEWFILEDIFF:
        return _OnItemActivate(LEGetCurSel());

    case IDM_VIEWWINDIFF:
        WindiffChangelist(_GetChangeNumber(LEGetCurSel()));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(LEGetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        _ViewFileLog(LEGetCurSel());
        break;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void CFileLog::_AdjustMenu(HMENU hmenu, LogEntry *ple, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(ple), fContextMenu);

    // Disable IDM_VIEWFILELOG if it would just show you the same window
    // you're looking at right now.
    BOOL fEnable = _IsViewFileLogEnabled(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);
}

LRESULT CFileLog::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), LEGetCurSel(), FALSE);
    return 0;
}

LRESULT CFileLog::_OnGetContextMenu(LogEntry *ple)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_FILELOG_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, ple, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT CFileLog::_OnItemActivate(LogEntry *ple)
{
    if (ple) {
        LogEntry *pleParent = SAFECAST(LogEntry*, ple->Parent());

        // Trim the parent path to remove the sharp.
        String strPath(pleParent->GetChildPath());
        LPTSTR pszSharp = StrChr(strPath, TEXT('#'));
        if (pszSharp) {
            strPath.SetLength((int)(pszSharp - strPath));
        }

        // Append the version we care about
        strPath << TEXT('#') << ple->GetRev();

        // And ask windiff to view it

        WindiffOneChange(strPath);
    }
    return 0;
}

LRESULT CFileLog::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMTREELIST *ptl = RECAST(NMTREELIST*, lParam);
    LogEntry *ple;

    switch (ptl->hdr.code) {
    case TLN_GETDISPINFO:
        ple = SAFECAST(LogEntry*, ptl->pti);
        if (ptl->iSubItem < 0) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else if (ptl->iSubItem < _pflc->_ccol) {
            return ple->GetDispInfo(ptl, _pflc->_rgColMap[ptl->iSubItem]);
        } else {
            ASSERT(0); // invalid column
            return 0;
        }

    case TLN_FILLCHILDREN:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _FillChildren(ple, ple->GetChildPath());

    case TLN_ITEMACTIVATE:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _OnItemActivate(ple);

    case TLN_GETINFOTIP:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return ple->GetInfoTip(ptl);

    case TLN_DELETEITEM:
        ple = SAFECAST(LogEntry*, ptl->pti);
        delete ple;
        return 0;

    case TLN_GETCONTEXTMENU:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _OnGetContextMenu(ple);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT
CFileLog::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_NOTIFY);
    FW_MSG(FL_INITIALIZE);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class FileLogParseState : public CommentParser
{
public:
    FileLogParseState() : _pleCurrent(NULL), _pleInsertAfter(NULL) { }

    LogEntry *GetCurrentLogEntry() const { return _pleCurrent; }

    void Flush()
    {
        if (_pleCurrent) {
            //
            //  Trim the trailing CRLF off the last line of the full
            //  description.
            //
            _strFullDescription.Chomp();
            _pleCurrent->SetFullDescription(_strFullDescription);
            _pleCurrent = NULL;
        }
        _cAdded = _cDeleted = 0;
        CommentParser::Reset();
        _strFullDescription.Reset();
    }

    void AddEntry(Tree &tree, LogEntry *pleRoot, String& str, Substring *rgss)
    {
        LPCTSTR pszChildPath = pleRoot->GetChildPath();
        _strFullDescription.Append(pszChildPath, StrCSpn(pszChildPath, TEXT("#")));
        _strFullDescription << TEXT("\r\n") << str;
        LogEntry *ple = new LogEntry(rgss[0].Finalize(),    // Rev
                                     rgss[1].Finalize(),    // Change
                                     rgss[2].Finalize(),    // Op
                                     rgss[3].Finalize(),    // Date
                                     rgss[4].Finalize());   // Dev
        if (ple) {
            if (tree.Insert(ple, pleRoot, _pleInsertAfter)) {
                _pleInsertAfter = _pleCurrent = ple;
            } else {
                delete ple;
            }
        }
    }

    void AddLine(const String& str)
    {
        _strFullDescription << str;
    }

    void SetDev(LPCTSTR psz)
    {
        if (_pleCurrent) {
            _pleCurrent->SetDev(psz);
        }
    }

    void SetComment(LPCTSTR psz)
    {
        if (_pleCurrent) {
            _pleCurrent->SetComment(psz);
        }
    }


    void SetIntegrateType(LPCTSTR pszType, LPCTSTR pszDepotPath)
    {
        if (_pleCurrent) {
            _pleCurrent->SetIntegrateType(pszType);
            _pleCurrent->SetChildPath(pszDepotPath);
        }
    }

    void SetIsDonor()
    {
        if (_pleCurrent) {
            _pleCurrent->SetIsDonor();
        }
    }

    void AddedLines(LPCTSTR psz)
    {
        _cAdded += StrToInt(psz);
    }

    void DeletedLines(LPCTSTR psz)
    {
        _cDeleted += StrToInt(psz);
    }

    void SetChurn()
    {
        if (_pleCurrent) {
            _pleCurrent->SetChurn(_cAdded, _cDeleted);
        }
    }

    void ParseDiffResult(String& str)
    {
        Substring rgss[3];

        if (Parse(TEXT("add $d chunks $d"), str, rgss)) {
            AddedLines(rgss[1].Finalize());
        } else if (Parse(TEXT("deleted $d chunks $d"), str, rgss)) {
            DeletedLines(rgss[1].Finalize());
        } else if (Parse(TEXT("changed $d chunks $d / $d"), str, rgss)) {
            DeletedLines(rgss[1].Finalize());
            AddedLines(rgss[2].Finalize());
            SetChurn();
        }
    }

    BOOL GetFinishDiffCommand(LPCTSTR pszRootPath, String& str)
    {
        if (_pleCurrent && !_pleCurrent->IsChurnSet() && _pleCurrent->GetRev() > 1) {
            str = TEXT("diff2 -ds \"");
            int cchRootPath = StrCSpn(pszRootPath, TEXT("#"));
            str.Append(pszRootPath, cchRootPath);
            str << TEXT("#") << (_pleCurrent->GetRev() - 1) << TEXT("\" \"");
            str.Append(pszRootPath, cchRootPath);
            str << TEXT("#") <<  _pleCurrent->GetRev()      << TEXT("\"");
            return TRUE;
        } else {
            return FALSE;
        }
    }

private:
    int         _cAdded;
    int         _cDeleted;
    LogEntry   *_pleCurrent;
    LogEntry   *_pleInsertAfter;
    String      _strFullDescription;
};

BOOL CFileLog::_ParseQuery()
{
    String str;

    /*
     *  Parse the switches as best we can.
     *
     */
    str.Reset();
    GetOpt opt(TEXT("m#"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('m'):
            _fIsRestrictedRoot = TRUE;
            str << TEXT("-m ") << opt.GetValue() << TEXT(" ");
            break;

        case TEXT('#'):
            _iHighlightRev = StrToInt(opt.GetValue());
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            // Caller will display help for us
            return FALSE;
        }
    }
L_switch:;

    _scSwitches = str;

    str.Reset();
    str << TEXT("sdv filelog ") << _scSwitches << opt.GetTokenizer().Unparsed();
    SetWindowText(_hwnd, str);

    /*
     *  There must be exactly one token remaining and it can't be a
     *  wildcard.
     */
    if (opt.Token() && opt.Finished() && !ContainsWildcards(opt.GetValue())) {
        _scPath = opt.GetValue();
        if (StrChr(_scPath, TEXT('#')) || StrChr(_scPath, TEXT('@'))) {
            _fIsRestrictedRoot = TRUE;
        }

    } else {
        return FALSE;
    }

    return TRUE;
}

LRESULT CFileLog::_FillChildren(LogEntry *pleRoot, LPCTSTR pszRootPath)
{
    LRESULT lres = 0;
    if (!pszRootPath[0]) {
        return -1;
    }

    WaitCursor wait;

    String str("filelog -l ");
    str << _scSwitches;
    if (IsChurnEnabled()) {
        str << TEXT("-ds ");
    }

    str << ResolveBranchAndQuoteSpaces(pszRootPath);

    SDChildProcess proc(str);
    FileLogParseState state;
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {

        Substring rgss[5];  // Rev, Change, Op, Date, Dev
        LPTSTR pszRest;

        if (Parse(TEXT("... #$d change $d $w on $D by $u"), str, rgss)) {
            state.Flush();
            state.AddEntry(_tree, pleRoot, str, rgss);
            if (state.GetCurrentLogEntry() &&
                state.GetCurrentLogEntry()->GetRev() == _iHighlightRev) {
                _pleHighlight = state.GetCurrentLogEntry();
            }
        } else if (Parse(TEXT("$P"), str, rgss)) {
            if (pleRoot->GetChildPath().IsEmpty()) {
                str.Chomp();
                pleRoot->SetChildPath(rgss[0].Finalize());
            }
        } else {
            state.AddLine(str);
            str.Chomp();
            if (str[0] == TEXT('\t')) {
                state.AddComment(str+1);
            } else if ((pszRest = Parse(TEXT("... ... $w from "), str, rgss)) != NULL) {
                state.SetIntegrateType(rgss[0].Finalize(), pszRest);
            } else if (Parse(TEXT("... ... $w into "), str, rgss) ||
                       Parse(TEXT("... ... ignored by "), str, rgss)) {
                state.SetIsDonor();

                // SUBTLE!  We check for "ignored" after "ignored by".
            } else if ((pszRest = Parse(TEXT("... ... ignored "), str, rgss)) != NULL) {
                state.SetIntegrateType("ignored", pszRest);
            } else {
                state.ParseDiffResult(str);
            }
        }
    }

    // "sd filelog -d" doesn't spit out a diff for the last guy,
    // so kick off a special one-shot "sd diff2" to get that diff.
    if (IsChurnEnabled() &&
        state.GetFinishDiffCommand(pszRootPath, str)) {
        SDChildProcess proc2(str);
        if (proc2.IsRunning()) {
            buf.Init(proc2.Handle());
            while (buf.NextLine(str)) {
                state.AddLine(str);
                state.ParseDiffResult(str);
            }
        }
    }

    state.Flush();

    return lres;
}

DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CFileLog, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\lvframe.cpp ===
/*****************************************************************************
 *
 *  lvframe.cpp
 *
 *      Frame window that hosts a listview.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class LVFrame
 *
 *****************************************************************************/

LRESULT
LVFrame::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_NOTIFY);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_CONTEXTMENU);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT LVFrame::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *pnm = RECAST(NMHDR *, lParam);

    if (pnm->idFrom == IDC_LIST) {
        switch (pnm->code) {

        case LVN_ITEMACTIVATE:
            {
                NMITEMACTIVATE *pia = CONTAINING_RECORD(pnm, NMITEMACTIVATE, hdr);
                return SendSelfMessage(LM_ITEMACTIVATE, pia->iItem, 0);
            }
            break;

        case LVN_GETINFOTIP:
            {
                NMLVGETINFOTIP *pgit = CONTAINING_RECORD(pnm, NMLVGETINFOTIP, hdr);
                LPTSTR pszBuf = pgit->pszText;
                SendSelfMessage(LM_GETINFOTIP, pgit->iItem, RECAST(LPARAM, pgit));
                LPTSTR pszInfoTip = pgit->pszText;
                pgit->pszText = pszBuf;
                _it.SetInfoTip(pgit, pszInfoTip);
            }
            return 0;

        case LVN_DELETEITEM:
            {
                NMLISTVIEW *plv = CONTAINING_RECORD(pnm, NMLISTVIEW, hdr);
                SendSelfMessage(LM_DELETEITEM, plv->iItem, plv->lParam);
            }
            return 0;

        default:;
        }
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT LVFrame::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iSel;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_COPY:
        iSel = GetCurSel();
        if (iSel >= 0) {
            SendSelfMessage(LM_COPYTOCLIPBOARD, iSel, iSel + 1);
        }
        return 0;

    case IDM_COPYALL:
        SendSelfMessage(LM_COPYTOCLIPBOARD, 0, ListView_GetItemCount(_hwndChild));
        return 0;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}



LRESULT LVFrame::ON_WM_CONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iItem;
    HMENU hmenu;

    if ((DWORD)lParam == 0xFFFFFFFF) {
        iItem = ListView_GetCurSel(_hwndChild);
        if (iItem < 0) {
            goto fail;
        }

        RECT rc;
        if (!ListView_GetItemRect(_hwndChild, iItem, &rc, LVIR_LABEL)) {
            goto fail;
        }
        MapWindowRect(_hwndChild, HWND_DESKTOP, &rc);
        int cyHalf = (rc.bottom - rc.top)/2;
        lParam = MAKELPARAM(rc.left + cyHalf, rc.top + cyHalf);
    } else {
        LVHITTESTINFO hti;
        hti.pt.x = GET_X_LPARAM(lParam);
        hti.pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwndChild, &hti.pt);
        iItem = ListView_HitTest(_hwndChild, &hti);
        if (iItem < 0) {
            goto fail;
        }
        ListView_SetCurSel(_hwndChild, iItem);
    }

    hmenu = RECAST(HMENU, SendSelfMessage(LM_GETCONTEXTMENU, iItem, 0));
    if (!hmenu) {
        goto fail;
    }

    TrackPopupMenuEx(hmenu,
                     TPM_LEFTALIGN | TPM_TOPALIGN |
                     TPM_RIGHTBUTTON | TPM_NONOTIFY,
                     GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                     _hwnd, NULL);
    DestroyMenu(hmenu);
    return 0;

fail:
    return super::HandleMessage(uiMsg, wParam, lParam);
}

BOOL LVFrame::CreateChild(DWORD dwStyle, DWORD dwExStyle)
{
    _hwndChild = CreateWindowEx(WS_EX_CLIENTEDGE,
                           WC_LISTVIEW, NULL,
                           WS_CHILD | WS_VISIBLE |
                           WS_BORDER | WS_TABSTOP |
                           WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                           dwStyle,
                           0,0,0,0,
                           _hwnd, RECAST(HMENU, IDC_LIST), g_hinst, 0);

    if (!_hwndChild) return FALSE;

    ListView_SetExtendedListViewStyleEx(_hwndChild, dwExStyle, dwExStyle);

    SetFocus(_hwndChild);

    _it.Attach(_hwndChild);

    return TRUE;
}

BOOL LVFrame::AddColumns(const LVFCOLUMN *pcol)
{
    int cxChar = LOWORD(GetDialogBaseUnits());

    for (; pcol->cch; pcol++) {
        LVCOLUMN lvc;
        TCHAR szName[MAX_PATH];
        LoadString(g_hinst, pcol->ids, szName, ARRAYSIZE(szName));

        lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvc.fmt = pcol->fmt;
        lvc.pszText = szName;
        lvc.cx = pcol->cch * cxChar;
        ListView_InsertColumn(_hwndChild, MAXLONG, &lvc);
    }
    return TRUE;
}

void *LVFrame::GetLVItem(int iItem)
{
    LVITEM lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    lvi.lParam = 0;
    ListView_GetItem(_hwndChild, &lvi);
    return RECAST(LPVOID, lvi.lParam);
}

/*****************************************************************************
 *
 *  LVInfoTip
 *
 *****************************************************************************/

void LVInfoTip::Attach(HWND hwnd)
{
    if (SetProp(hwnd, GetSubclassProperty(), RECAST(HANDLE, this))) {
        _wndprocPrev = SubclassWindow(hwnd, SubclassWndProc);
    }

    // Those infotips can get really long, so set the autopop delay
    // to the maximum allowable value.
    HWND hwndTT = ListView_GetToolTips(hwnd);
    if (hwndTT) {
        SendMessage(hwndTT, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAXSHORT);
    }

}

void LVInfoTip::FreeLastTipAlt()
{
    if (_pszLastTipAlt) {
        LPSSTR pszFree = _pszLastTipAlt;
        _pszLastTipAlt = NULL;
        delete [] pszFree;
    }
}

void LVInfoTip::SetInfoTip(NMLVGETINFOTIP *pgit, LPCTSTR pszTip)
{
    _pszLastTip = NULL;
    FreeLastTipAlt();

    if (pgit->pszText != pszTip) {
        if (lstrlen(pszTip) >= pgit->cchTextMax) {
            _pszLastTip = pszTip;
        }
        lstrcpyn(pgit->pszText, pszTip, pgit->cchTextMax);
    }

}

//
//  Convert from TCHAR to SCHAR.
//
inline int T2S(LPCTSTR pszIn, int cchIn, LPSSTR pszOut, int cchOut)
{
#ifdef UNICODE
    return WideCharToMultiByte(CP_ACP, 0, pszIn, cchIn, pszOut, cchOut, NULL, NULL);
#else
    return MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, pszOut, cchOut);
#endif
}

//
//  Make _pszLastTipAlt match _pszLastTip, but of opposite character set.
//
BOOL LVInfoTip::ThunkLastTip()
{
    ASSERT(_pszLastTip);
    FreeLastTipAlt();
    int cch = T2S(_pszLastTip, -1, NULL, 0);
    if (cch) {
        _pszLastTipAlt = new SCHAR[cch];
        if (_pszLastTipAlt &&
            T2S(_pszLastTip, -1, _pszLastTipAlt, cch)) {
            return TRUE;
        }
    }
    return FALSE;
}

LRESULT LVInfoTip::SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LVInfoTip *self = RECAST(LVInfoTip *, GetProp(hwnd, GetSubclassProperty()));
    if (self) {
        LRESULT lres;
        NMHDR *pnm;
        switch (uMsg) {
        case WM_NOTIFY:
            pnm = RECAST(NMHDR *, lParam);
            switch (pnm->code) {
            case TTN_GETDISPINFOA:
            case TTN_GETDISPINFOW:
                lres = CallWindowProc(self->_wndprocPrev, hwnd, uMsg, wParam, lParam);
                if (SendMessage(pnm->hwndFrom, TTM_GETMAXTIPWIDTH, 0, 0) >= 0) {

                    // It's an infotip.  Tweak it to suit our needs.
                    NMTTDISPINFO *ptdi = CONTAINING_RECORD(pnm, NMTTDISPINFO, hdr);

                    // Set the width to the maximum allowed without going single-line.
                    SendMessage(pnm->hwndFrom, TTM_SETMAXTIPWIDTH, 0, MAXLONG);

                    // If we overflowed the returned buffer, then listview used
                    // only a partial infotip.  So fill in the rest here.
                    if (self->_pszLastTip) {
                        if (pnm->code == TTN_GETDISPINFO) {
                            ptdi->lpszText = CCAST(LPTSTR, self->_pszLastTip);
                        } else {
                            if (self->ThunkLastTip()) {
                                ptdi->lpszText = RECAST(LPTSTR, self->_pszLastTipAlt);
                            }
                        }
                    }
                } else {
                    self->_pszLastTip = NULL;
                }
                return lres;
            }
        }
        return CallWindowProc(self->_wndprocPrev, hwnd, uMsg, wParam, lParam);
    } else {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\match.cpp ===
/*****************************************************************************
 *
 *  match.cpp
 *
 *      Highly-specialized depot path matching class
 *
 *****************************************************************************/

#include "sdview.h"

Match::Match(LPCTSTR pszPattern)
{
    Tokenizer tok(pszPattern);
    String str, strPath, strPats;

    while (tok.Token(str)) {
        if (MapToFullDepotPath(str, strPath)) {
            _AddPattern(strPath, strPats);
        }
    }

    _pszzPats = new TCHAR[strPats.Length()];
    if (_pszzPats) {
        CopyMemory(_pszzPats, strPats, strPats.Length() * sizeof(TCHAR));
        _pszEnd = _pszzPats + strPats.Length();
    }
}

BOOL Match::Matches(LPCTSTR pszPath)
{
    LPCTSTR pszPat;

    if (_pszzPats) {
        for (pszPat = _pszzPats;
             pszPat < _pszEnd; pszPat += lstrlen(pszPat) + 1) {
            if (_Matches(pszPat, pszPath)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

#define PAT_END     ((TCHAR)0)
#define PAT_START   ((TCHAR)1)
#define PAT_DOTS    ((TCHAR)2)
#define PAT_STAR    ((TCHAR)3)
#define PAT_BRANCH  ((TCHAR)4)

#define MAX_BACKTRACK 20 // totally arbitrary

void Match::_AddPattern(LPTSTR pszPat, String& strPats)
{
    CharLower(pszPat);

    //
    //  "compile" the pattern by changing "..." to PAT_DOTS and
    //  "%1" and "*" to PAT_STAR.
    //
    //  Oh, and change "//depot/blah/" and "//depot/private/blah/" to
    //  "//depot/<PAT_BRANCH>" so we can track across branches.
    //
    LPTSTR pszIn, pszOut;
    int iWildcards = 0;
    int cSlashes = 0;
    TCHAR pat;
    pszIn = pszOut = pszPat;
    for (;;) {
        switch (*pszIn) {
        case TEXT('\r'):
        case TEXT('\n'):
        case TEXT('\0'):
            goto endcompile;

        case TEXT('.'):
            if (pszIn[1] == TEXT('.') && pszIn[2] == TEXT('.')) {
                pszIn += 3;
                pat = PAT_DOTS;
                goto L_wildcard;
            } else {
                goto L_default;
            }
            break;

        case TEXT('%'):
            if ((UINT)(pszIn[1] - TEXT('1')) < 9) {
                pszIn += 2;
                pat = PAT_STAR;
                goto L_wildcard;
            } else {
                goto L_default;
            }
            break;

        case TEXT('*'):
            pszIn++;
            pat = PAT_STAR;
            goto L_wildcard;

        L_wildcard:
            //
            //  Collapse consecutive wildcards for perf.  Otherwise
            //  a search string of a****b will take exponential
            //  time.
            //
            if (pszOut[-1] == pat) {
                // ** and ...... are the same as * and ... (respectively)
                // so just throw away the second wildcard.
            } else if (pszOut[-1] == (PAT_STAR + PAT_DOTS - pat)) {
                // ...* and *... are the same as "..."
                pszOut[-1] = PAT_DOTS;
            } else if (iWildcards++ < MAX_BACKTRACK) {
                // just a regular ol' wildcard
                *pszOut++ = pat;
            } else {
                *pszOut++ = PAT_DOTS;   // Give up when the limit is reached
                goto endcompile;
            }
            break;

        case TEXT('/'):
            cSlashes++;
            if (cSlashes == 3) {
                if (StringBeginsWith(pszIn, TEXT("/private/"))) {
                    // a private branch
                    *pszOut++ = PAT_BRANCH;
                    pszIn += 9;     // length of "/private/"
                } else {
                    // a main branch
                    *pszOut++ = PAT_BRANCH;
                }
                // Skip over the branch name
                while (*pszIn != TEXT('/') &&
                       *pszIn != TEXT('\r') &&
                       *pszIn != TEXT('\n') &&
                       *pszIn != TEXT('\0')) {
                    pszIn++;
                }
            } else {
                goto L_default;
            }
            break;

        L_default:
        default:
            *pszOut++ = *pszIn++;
        }
    }
endcompile:;
    *pszOut++ = PAT_END;

    // Now add it to the list of patterns we care about
    strPats << PAT_START << Substring(pszPat, pszOut);
}

//
//  This is the fun part -- funky pattern matching.
//
//  The pszPath is assumed to be of the form
//
//      //depot/fully/qualified/path#n
//
//  PAT_DOTS matches any string.
//  PAT_STAR matches any string not including slash.
//
//  This code is adapted from code I wrote back in 1993 for the
//  Windows 95 Netware emulation layer.  I've also seen it stolen
//  by Wininet.  I guess good code never dies.  Or maybe it's just
//  that pattern matching is hard.  (I suspect the latter because
//  the Wininet folks stole the code and then adapted it incorrectly.)
//
BOOL Match::_Matches(LPCTSTR pszPat, LPCTSTR pszPath)
{
    struct Backtrack {
        int iStart;
        int iEnd;
    };

    Backtrack rgbt[MAX_BACKTRACK+1]; /* +1 for PAT_START fake-backtrack point */
    Backtrack *pbt = rgbt;

    int i, j;      /* i = index to pattern, j = index to target */
    int m = lstrlen(pszPath);   /* m = length of target */
    int back;      /* First available slot in backtrack array */
    i = -1;        /* Will be advanced to 0 */
    j = 0;

advance:
    ++i;
    switch (pszPat[i]) {
    case PAT_START:  pbt->iEnd = 0; goto advance;
    case PAT_END:    if (pszPath[j] == TEXT('#')) return TRUE;
                     else goto retreat;

    case PAT_DOTS:   pbt++; // this is a backtracking rule
                     pbt->iStart = j;
                     pbt->iEnd = j = m; goto advance;


    case PAT_STAR:   pbt++; // this is a backtracking rule
                     pbt->iStart = j;
                     while (pszPath[j] != TEXT('/') &&
                            pszPath[j] != TEXT('#') &&
                            pszPath[j] != TEXT('\0')) {
                        j++;
                     }
                     pbt->iEnd = j; goto advance;

    case PAT_BRANCH:        // this is a non-backtracking rule
                     if (pszPath[j] != TEXT('/')) goto retreat;
                     if (StringBeginsWith(&pszPath[j], TEXT("/private/"))) {
                        j += 8;
                     }
                     // Skip over the branch name
                     do {
                        j++;
                     } while (pszPath[j] != TEXT('/') &&
                              pszPath[j] != TEXT('#') &&
                              pszPath[j] != TEXT('\0'));
                     goto advance;

    default:         if (pszPath[j] == pszPat[i]) {
                        j++;
                        goto advance;
                     } else if (pszPath[j] >= TEXT('A') &&
                                pszPath[j] <= TEXT('Z') &&
                                pszPath[j] - TEXT('A') + TEXT('a') == pszPat[i]) {
                        // I hate case-insensitivity
                        j++;
                        goto advance;
                     } else goto retreat;
    }

retreat:
    --i;
    switch (pszPat[i]) {
    case PAT_START:  return FALSE;  // cannot backtrack further
    case PAT_DOTS:
    case PAT_STAR:   if (pbt->iStart == pbt->iEnd) {
                        pbt--;
                        goto retreat;
                     }
                     j = --pbt->iEnd; goto advance;
    default:         goto retreat;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\opened.cpp ===
/*****************************************************************************
 *
 *  opened.cpp
 *
 *      View the list of opened files and pending changes.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  OpenedEntry
 *
 *  We list the changes in descending numerical order, except that
 *  "default" goes at the top of the list (rather than at the bottom,
 *  which is what StrToInt would've given us).
 *
 *****************************************************************************/

MakeStringFormat(ChangeList)
MakeStringFormat(PendingOp)

class OpenedEntry : public TreeItem {

public:
    OpenedEntry(ChangeList clChange, LPCTSTR pszComment);
    OpenedEntry(PendingOp opOp, LPCTSTR pszFile);
    OpenedEntry() { }

    void SetComment(LPCTSTR pszComment) { _scComment = pszComment; }
    void SetFullDescription(LPCTSTR pszFullDescription) {  _scFullDescription = pszFullDescription; }

    LRESULT GetDispInfo(NMTREELIST *pdi, int iColumn);
    LRESULT GetInfoTip(NMTREELIST *pdi);

    LPCTSTR GetChange() const { return _scChange; }
    LPCTSTR GetComment() const { return _scComment; }
    int     GetOp() const { return _iOp; }
    UINT    GetSortKey() const { return _uiSort; }
    BOOL    IsAddLike() const { return _iOp == OP_ADD || _iOp == OP_BRANCH; }
    BOOL    IsDelLike() const { return _iOp == OP_DELETE; }
    BOOL    HasComment() const { return !_scComment.IsEmpty(); }

    static  UINT ComputeSortKey(LPCTSTR pszChange)
        { return (UINT)StrToInt(pszChange) - 1; }

    static  UINT SortKey_DefaultChange() { return (UINT)0-1; }

private:
    void GetImage(NMTREELIST *ptl);
private:
    UINT    _uiSort;                    // Sort key
    int     _iOp;                       // Checkin operation
    StringCache _scChange;              // Change number or operation
    StringCache _scComment;             // Checkin comment or path
    StringCache _scFullDescription;     // Full checkin description
};

OpenedEntry::OpenedEntry(ChangeList clChange, LPCTSTR pszComment)
    : _scChange(clChange)
    , _uiSort(ComputeSortKey(clChange))
    , _iOp(OP_EDIT)
    , _scComment(pszComment)
{
}

OpenedEntry::OpenedEntry(PendingOp opOp, LPCTSTR pszComment)
    : _scChange(opOp)
    , _iOp(ParseOp(opOp))
    , _scComment(pszComment)
{
}

void OpenedEntry::GetImage(NMTREELIST *ptl)
{
    if (_iOp > 0) {
        ptl->iSubItem = c_rgleim[_iOp]._iImage;
    } else {
        ptl->iSubItem = 0;
    }
}

LRESULT OpenedEntry::GetDispInfo(NMTREELIST *ptl, int iColumn)
{
    switch (iColumn) {
    case -1: GetImage(ptl); break;
    case 0: ptl->pszText = _scChange; break;
    case 1: ptl->pszText = _scComment; break;
    }
    return 0;
}


LRESULT OpenedEntry::GetInfoTip(NMTREELIST *ptl)
{
    ptl->pszText = _scFullDescription;
    return 0;
}

/*****************************************************************************
 *
 *  class COpened
 *
 *****************************************************************************/

class COpened : public TLFrame, public BGTask {

    friend DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        OM_INITIALIZED = WM_APP
    };

    typedef TLFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_OM_INITIALIZED(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    COpened() : TLFrame(new OpenedEntry)
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_OPENED));
    }

    OpenedEntry *OEGetCurSel() { return SAFECAST(OpenedEntry*, TLGetCurSel()); }

    LRESULT _FillChildren(OpenedEntry *pleRoot, LPCTSTR pszRootPath);
    LRESULT _OnItemActivate(OpenedEntry *ple);
    LRESULT _OnGetContextMenu(OpenedEntry *ple);

    BOOL _IsViewFileLogEnabled(OpenedEntry *ple);
    LRESULT _ViewFileLog(OpenedEntry *ple);
    void _AdjustMenu(HMENU hmenu, OpenedEntry *ple, BOOL fContextMenu);

    int _GetChangeNumber(OpenedEntry *ple);
    int _GetBugNumber(OpenedEntry *ple);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();
    LPCTSTR _BGParse(StringCache *pscUser);
    void _BGGetChanges(LPCTSTR pszUser);
    void _BGFillInChanges();
    OpenedEntry *_BGFindChange(LPCTSTR pszChange, BOOL fCreate);
    void _BGGetOpened(LPCTSTR pszArgs, LPCTSTR pszUser);

    BOOL  _IsChangeHeader(OpenedEntry *ple)
        { return ple && ple->Parent() == _tree.GetRoot(); }

    BOOL  _IsChangeFile(OpenedEntry *ple)
        { return ple && ple->Parent() != _tree.GetRoot(); }

private:
};

LRESULT COpened::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    static const LVFCOLUMN c_rgcol[] = {
        { 15 ,IDS_COL_CHANGE    ,LVCFMT_LEFT    },
        { 60 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    lres = super::HandleMessage(uiMsg, wParam, lParam);
    if (lres == 0 &&
        _tree.GetRoot() &&
        SetWindowMenu(MAKEINTRESOURCE(IDM_OPENED)) &&
        CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_NOSORTHEADER,
                    LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                    LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
        AddColumns(c_rgcol) &&
        BGStartTask(s_BGInvoke, this)) {
        SetWindowText(_hwnd, TEXT("sdv opened"));
    } else {
        lres = -1;
    }
    return lres;
}

int COpened::_GetBugNumber(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        ple = SAFECAST(OpenedEntry *, ple->Parent());
    }

    if (ple) {
        return ParseBugNumber(ple->GetComment());
    } else {
        return 0;
    }
}

int COpened::_GetChangeNumber(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        ple = SAFECAST(OpenedEntry *, ple->Parent());
    }

    if (ple) {
        return StrToInt(ple->GetChange());
    } else {
        return 0;
    }
}

BOOL COpened::_IsViewFileLogEnabled(OpenedEntry *ple)
{
    if (!_IsChangeFile(ple)) {
        return FALSE;               // not even a file!
    }

    //
    //  Some of the ops create files so there's nothing to see.
    //
    if (ple->IsAddLike()) {
        return FALSE;
    }

    return TRUE;
}

LRESULT COpened::_ViewFileLog(OpenedEntry *poe)
{
    if (!_IsViewFileLogEnabled(poe)) {
        return 0;
    }

    Substring ss;
    if (Parse(TEXT("$P"), poe->GetComment(), &ss)) {
        String str;
        str << TEXT("-#") << ss._pszMax << TEXT(" ") << ss;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
    return 0;
}

LRESULT COpened::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

LRESULT COpened::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case IDM_VIEWFILEDIFF:
        return _OnItemActivate(OEGetCurSel());

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(OEGetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        _ViewFileLog(OEGetCurSel());
        break;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void COpened::_AdjustMenu(HMENU hmenu, OpenedEntry *ple, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(ple), fContextMenu);

    BOOL fEnable = _IsViewFileLogEnabled(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);

    fEnable = _IsChangeFile(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILEDIFF, fEnable, fContextMenu);

    MakeMenuPretty(hmenu);
}

LRESULT COpened::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), OEGetCurSel(), FALSE);
    return 0;
}

LRESULT COpened::_OnGetContextMenu(OpenedEntry *ple)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_OPENED_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, ple, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT COpened::_OnItemActivate(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        //
        //  Map the full depot path to a local file so we can pass it
        //  to windiff.  We can't use "sd diff" because that will fail
        //  on a borrowed enlistment.
        //
        String strLocal;
        if (MapToLocalPath(ple->GetComment(), strLocal)) {
            Substring ss;
            if (Parse(TEXT("$p"), strLocal, &ss)) {
                String str;
                str << TEXT("windiff ");
                if (ple->IsAddLike()) {
                    str << TEXT("nul ");
                } else {
                    str << QuoteSpaces(ple->GetComment());
                }
                str << TEXT(" ");
                if (ple->IsDelLike()) {
                    str << TEXT("nul ");
                } else {
                    str << QuoteSpaces(ss.Finalize());
                }
                SpawnProcess(str);
            }
        }
    }
    return 0;
}

LRESULT COpened::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMTREELIST *ptl = RECAST(NMTREELIST*, lParam);
    OpenedEntry *ple;

    switch (ptl->hdr.code) {
    case TLN_GETDISPINFO:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        if (ptl->iSubItem < 0) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else if (ptl->iSubItem < 2) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else {
            ASSERT(0); // invalid column
            return 0;
        }

    case TLN_ITEMACTIVATE:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return _OnItemActivate(ple);

    case TLN_GETINFOTIP:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return ple->GetInfoTip(ptl);

    case TLN_DELETEITEM:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        delete ple;
        return 0;

    case TLN_GETCONTEXTMENU:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return _OnGetContextMenu(ple);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT COpened::ON_OM_INITIALIZED(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _tree.Expand(_tree.GetRoot());

    //
    //  Also expand the first changelist since it's usually what
    //  you are interested in.
    //
    TreeItem *pti = _tree.GetRoot()->FirstChild();
    if (pti) {
        _tree.Expand(pti);
    }

    return 0;
}

LRESULT
COpened::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_NOTIFY);
    FW_MSG(OM_INITIALIZED);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class PendingChangesParseState
{
public:
    PendingChangesParseState() : _poeCurrent(NULL), _poeInsertAfter(NULL) { }

    OpenedEntry *GetCurrent() const { return _poeCurrent; }

    void Flush(Tree& tree)
    {
        if (_poeCurrent) {
            //
            //  Trim the trailing CRLF off the last line of the full
            //  description.
            //
            _strFullDescription.Chomp();
            _poeCurrent->SetFullDescription(_strFullDescription);
            tree.RedrawItem(_poeCurrent);
            _poeCurrent = NULL;
        }
        _fHaveComment = FALSE;
        _strFullDescription.Reset();
    }

    void AddEntry(Tree &tree, String& str, Substring *rgss)
    {
        OpenedEntry *poe = new OpenedEntry(ChangeList(rgss[0].Finalize()), // Change
                                           NULL);               // Comment
        if (poe) {
            if (tree.Insert(poe, tree.GetRoot(), _poeInsertAfter)) {
                _poeInsertAfter = _poeCurrent = poe;
            } else {
                delete poe;
            }
        }
    }

    void SetEntry(OpenedEntry *poe)
    {
        _poeCurrent = poe;
    }

    void AddLine(const String& str)
    {
        _strFullDescription << str;
    }

    //
    //  We cannot use the CommentParser because we don't have a Dev
    //  column; besides, we don't want to handle proxy checkins here.
    //  Show the real unfiltered checkin comment.
    //
    void AddComment(LPTSTR psz)
    {
        if (_fHaveComment) return;
        if (!_poeCurrent) return;

        //
        //  Ignore leading spaces.
        //
        while (*psz == TEXT('\t') || *psz == TEXT(' ')) psz++;

        //
        //  Skip blank description lines.
        //
        if (*psz == TEXT('\0')) return;

        //
        //  Use the first nonblank comment line as the text and toss the rest.
        //
        //  Change all tabs to spaces because listview doesn't like tabs.
        //
        ChangeTabsToSpaces(psz);

        _poeCurrent->SetComment(psz);
        _fHaveComment = TRUE;
    }

private:
    BOOL        _fHaveComment;
    OpenedEntry*_poeCurrent;
    OpenedEntry*_poeInsertAfter;
    String      _strFullDescription;
};

DWORD CALLBACK COpened::s_BGInvoke(LPVOID lpParam)
{
    COpened *self = RECAST(COpened *, lpParam);
    return self->_BGInvoke();
}

//
//  Returns unparsed string (or NULL)
//  and puts user name in pscUser.
//
//
LPCTSTR COpened::_BGParse(StringCache *pscUser)
{
    /*
     *  Parse the switches as best we can.
     *
     */
    GetOpt opt(TEXT("u"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('u'):
            *pscUser = opt.GetValue();
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            // Caller will display help for us
            return NULL;
        }
    }
L_switch:;

    if (pscUser->IsEmpty()) {
        *pscUser = GlobalSettings.GetUserName();
    }

    String str;
    str << TEXT("sdv opened -u ") << *pscUser;
    SetWindowText(_hwnd, str);

    /*
     *  The rest goes to "sd opened".
     */
    return opt.GetTokenizer().Unparsed();
}

void COpened::_BGGetChanges(LPCTSTR pszUser)
{
    LPCTSTR pszClient = GlobalSettings.GetClientName();
    UINT cchClient = lstrlen(pszClient);

    String str;
    str << TEXT("changes -l -s pending");
    if (GlobalSettings.IsVersion(1, 60)) {
        str << TEXT(" -u ") << QuoteSpaces(pszUser);
    }

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    PendingChangesParseState state;
    while (buf.NextLine(str)) {
        Substring rgss[4];          // changeno, date, domain\userid, client
        if (Parse(TEXT("Change $d on $D by $u@$w"), str, rgss)) {
            state.Flush(_tree);
            if (rgss[3].Length() == cchClient &&
                StrCmpNI(rgss[3].Start(), pszClient, cchClient) == 0) {
                state.AddLine(str);
                state.AddEntry(_tree, str, rgss);
            }
        } else if (state.GetCurrent()) {
            state.AddLine(str);
            if (str[0] == TEXT('\t')) {
                str.Chomp();
                state.AddComment(str);
            }
        }
    }
    state.Flush(_tree);
}

OpenedEntry *COpened::_BGFindChange(LPCTSTR pszChange, BOOL fCreate)
{
    UINT uiKey = OpenedEntry::ComputeSortKey(pszChange);
    OpenedEntry *poeInsertAfter = NULL;

    OpenedEntry *poe = SAFECAST(OpenedEntry *, _tree.GetRoot()->FirstChild());
    if (poe == PTI_ONDEMAND) {
        poe = NULL;
    }

    while (poe) {
        if (poe->GetSortKey() == uiKey) {
            return poe;
        }

        if (poe->GetSortKey() < uiKey) {
            break;
        }
        poeInsertAfter = poe;
        poe = SAFECAST(OpenedEntry *, poe->NextSibling());
    }

    //
    //  Create it if necessary.  (We always create "default".)
    //
    if (fCreate || StrCmp(pszChange, TEXT("default")) == 0) {
        poe = new OpenedEntry(ChangeList(pszChange), NULL);
        if (poe) {
            if (_tree.Insert(poe, _tree.GetRoot(), poeInsertAfter)) {
                return poe;
            }
            delete poe;
        }
    }
    return NULL;
}


void COpened::_BGGetOpened(LPCTSTR pszArgs, LPCTSTR pszUser)
{
    String str, strOrig;
    str << TEXT("opened ") << pszArgs;

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        Substring rgss[6];          // path, version, op, changeno, type, user
        LPTSTR pszRest = Parse(TEXT("$P#$d - $w "), str, rgss);
        if (pszRest) {
            strOrig = str;

            rgss[1].Finalize();             // End of revision (path#version)

            //
            //  Parsing is such sweet sorrow.
            //
            //  "default change" but "change 1234".
            //
            LPTSTR pszRest2;
            if ((pszRest2 = Parse(TEXT("change $d $w"), pszRest, &rgss[3])) ||
                (pszRest2 = Parse(TEXT("$w change $w"), pszRest, &rgss[3]))) {
                *pszRest2++ = TEXT('\0'); // relies on the fact that we didn't chomp
                if (Parse(TEXT("by $p"), pszRest2, &rgss[5])) {
                    // Some nondefault user, how about that
                    rgss[5].Finalize();
                } else {
                    // Default user
                    rgss[5].SetStart(GlobalSettings.GetUserName());
                }
                if (lstrcmpi(rgss[5].Start(), pszUser) == 0) {
                    OpenedEntry *poeParent = _BGFindChange(rgss[3].Finalize(), pszArgs[0]);
                    if (poeParent) {
                        OpenedEntry *poe = new OpenedEntry(PendingOp(rgss[2].Finalize()),
                                                           rgss[0].Start());
                        if (poe) {
                            if (_tree.Insert(poe, poeParent, PTI_APPEND)) {
                                strOrig.Chomp();
                                poe->SetFullDescription(strOrig);
                            } else {
                                delete poe;
                            }
                        }
                    }
                }
            }
        }
    }
}

void COpened::_BGFillInChanges()
{
    String str;
    str << TEXT("describe -s ");
    BOOL fAnyChanges = FALSE;

    OpenedEntry *poe = SAFECAST(OpenedEntry *, _tree.GetRoot()->FirstChild());
    if (poe == PTI_ONDEMAND) {
        poe = NULL;
    }

    while (poe) {
        if (poe->GetSortKey() != OpenedEntry::SortKey_DefaultChange() &&
            !poe->HasComment()) {
            str << poe->GetChange() << TEXT(" ");
            fAnyChanges = TRUE;
        }
        poe = SAFECAST(OpenedEntry *, poe->NextSibling());
    }

    if (fAnyChanges) {
        SDChildProcess proc(str);
        IOBuffer buf(proc.Handle());
        PendingChangesParseState state;
        while (buf.NextLine(str)) {
            Substring rgss[4];          // changeno, domain\userid, client, date
            if (Parse(TEXT("Change $d by $u@$w on $D"), str, rgss)) {
                state.Flush(_tree);
                state.AddLine(str);
                poe = _BGFindChange(rgss[0].Finalize(), FALSE);
                state.SetEntry(poe);
            } else if (state.GetCurrent()) {
                if (str[0] == TEXT('A')) {      // "Affected files"
                    state.Flush(_tree);
                } else {
                    state.AddLine(str);
                    if (str[0] == TEXT('\t')) {
                        str.Chomp();
                        state.AddComment(str);
                    }
                }
            }
        }
        state.Flush(_tree);
    }
}


DWORD COpened::_BGInvoke()
{
    StringCache scUser;
    LPCTSTR pszUnparsed = _BGParse(&scUser);
    if (pszUnparsed) {
        //  If no parameters, then go hunt down all the changelists
        //  so we can find the empty ones, too.  Otherwise, we will
        //  figure them out as we see the results of "sd opened".
        if (!*pszUnparsed) {
            _BGGetChanges(scUser);
        }
        _BGGetOpened(pszUnparsed, scUser);
        PostMessage(_hwnd, OM_INITIALIZED, 0, 0);
        _BGFillInChanges();
    } else {
        Help(_hwnd, TEXT("#opene"));
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    BGEndTask();
    return 0;
}

DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new COpened, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\parse.cpp ===
/*****************************************************************************
 *
 *  parse.cpp
 *
 *      Lame string parser.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  Ctype stuff
 *
 *  The vast majority of characters we encounter are below 128, so use fast
 *  table lookup for those.
 *
 *****************************************************************************/

const BYTE c_rgbCtype[128] = {

    C_NONE , C_NONE , C_NONE , C_NONE , // 00-03
    C_NONE , C_NONE , C_NONE , C_NONE , // 04-07
    C_NONE , C_NONE , C_NONE , C_NONE , // 08-0B
    C_NONE , C_NONE , C_NONE , C_NONE , // 0C-0F
    C_NONE , C_NONE , C_NONE , C_NONE , // 10-13
    C_NONE , C_NONE , C_NONE , C_NONE , // 14-17
    C_NONE , C_NONE , C_NONE , C_NONE , // 18-1B
    C_NONE , C_NONE , C_NONE , C_NONE , // 1C-1F

    C_SPACE, C_NONE , C_NONE , C_NONE , // 20-23
    C_NONE , C_NONE , C_NONE , C_NONE , // 24-27
    C_NONE , C_NONE , C_NONE , C_BRNCH, // 28-2B
    C_NONE , C_DASH , C_NONE , C_BRNCH, // 2C-2F
    C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, // 30-33
    C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, // 34-37
    C_DIGIT, C_DIGIT, C_NONE , C_NONE , // 38-3B
    C_NONE , C_NONE , C_NONE , C_NONE , // 3C-3F

    C_NONE , C_ALPHA, C_ALPHA, C_ALPHA, // 40-43
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 44-47
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 48-4B
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 4C-4F
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 50-53
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 54-57
    C_ALPHA, C_ALPHA, C_ALPHA, C_NONE , // 58-5B
    C_NONE , C_NONE , C_NONE , C_BRNCH, // 5C-5F

    C_NONE , C_ALPHA, C_ALPHA, C_ALPHA, // 60-63
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 64-67
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 68-6B
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 6C-6F
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 70-73
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 74-77
    C_ALPHA, C_ALPHA, C_ALPHA, C_NONE , // 78-7B
    C_NONE , C_NONE , C_NONE , C_NONE , // 7C-7F

};

/*****************************************************************************
 *
 *  _ParseP
 *
 *      Parse a partial depot path.
 *
 *      A partial depot path extends up to the next "#" or "@".
 *
 *      If we find a "//", ":", or "\\" (double backslash) then we have
 *      gone too far and started parsing something else, so backtrack to
 *      the end of the previous word.
 *
 *      A full depot path is a partial depot path that begins with
 *      two slashes.
 *
 *****************************************************************************/

LPCTSTR _ParseP(LPCTSTR pszParse, Substring *rgss)
{
    rgss->SetStart(pszParse);

    LPCTSTR pszLastSpace = NULL;

    while (*pszParse && *pszParse != TEXT('#') && *pszParse != TEXT('@')) {
        if (pszLastSpace) {
            if ((pszParse[0] == TEXT('/') && pszParse[1] == TEXT('/')) ||
                (pszParse[0] == TEXT('\\') && pszParse[1] == TEXT('\\')) ||
                (pszParse[0] == TEXT(':'))) {
                // Back up over the word we ate by mistake
                pszParse = pszLastSpace;
                // Back up over the whitespace we ate by mistake
                while (pszParse >= rgss->Start() && IsSpace(pszParse[-1])) {
                    pszParse--;
                }
                break;
            }
        }
        if (*pszParse == TEXT(' ')) {
            pszLastSpace = pszParse;
        }
        pszParse++;
    }

    rgss->SetEnd(pszParse);             // Null string is possible

    return pszParse;
}

/*****************************************************************************
 *
 *  Parse strings
 *
 *  $D  date
 *  $P  full depot path
 *  $W  optional whitespace (does not consume a Substring slot)
 *  $a  email alias
 *  $b  branch name
 *  $d  digits
 *  $e  end of string (does not consume a Substring slot)
 *  $p  partial depot path, may not be null
 *  $u  user (with optional domain removed)
 *  $w  arbitrary word (whitespace-delimited)
 *
 *  NEED:
 *
 *  $R  maximal file revision specifier
 *  $q  quoted string
 *
 *  NOTE: Some pains were taken to make this a non-backtracking parser.
 *  If you want to add a backtracking rule, try to find a way so you don't.
 *
 *****************************************************************************/

LPTSTR Parse(LPCTSTR pszFormat, LPCTSTR pszParse, Substring *rgss)
{
    SIZE_T siz;
    while (*pszFormat) {

        if (*pszFormat == TEXT('$')) {
            pszFormat++;
            switch (*pszFormat++) {

            //
            //  Keep the switch cases in alphabetical order, please.
            //  Just helps maintain my sanity.
            //

            case TEXT('D'):             // Date
                rgss->SetStart(pszParse);
                if (lstrlen(pszParse) < 19) {
                    return NULL;        // Not long enough to be a date
                }
                pszParse += 19;
                rgss->SetEnd(pszParse);
                rgss++;
                break;

            case TEXT('P'):             // Full depot path
                if (pszParse[0] != TEXT('/') || pszParse[1] != TEXT('/')) {
                    return NULL;        // Must begin with //
                }
                goto L_p;               // Now treat as if it were partial

            case TEXT('W'):             // Optional whitespace
                while (*pszParse && (UINT)*pszParse <= (UINT)TEXT(' ')) {
                    pszParse++;
                }
                break;

            case TEXT('a'):             // Email alias
                rgss->SetStart(pszParse);
                if (IsAlpha(*pszParse)) {   // First char must be alpha
                    while (IsAlias(*pszParse)) {
                        pszParse++;
                    }
                }
                siz = rgss->SetEnd(pszParse);
                if (siz == 0 || siz > 8) {
                    return NULL;        // Must be 1 to 8 chars
                }
                rgss++;
                break;

            case TEXT('b'):             // Branch name
                rgss->SetStart(pszParse);
                while (IsBranch(*pszParse)) {
                    pszParse++;
                }
                siz = rgss->SetEnd(pszParse);
                if (siz == 0) {
                    return NULL;        // Must be at least one char
                }
                rgss++;
                break;

            case TEXT('d'):             // Digits
                rgss->SetStart(pszParse);
                while (IsDigit(*pszParse)) {
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one digit
                }
                rgss++;
                break;

            case TEXT('e'):             // End of string
                if (*pszParse) {
                    return NULL;
                }
                break;

L_p:        case TEXT('p'):             // Partial depot path
                pszParse = _ParseP(pszParse, rgss);
                if (!pszParse) {
                    return NULL;        // Parse failure
                }
                rgss++;
                break;

            case TEXT('u'):             // Userid
                rgss->SetStart(pszParse);
                while (_IsWord(*pszParse) && *pszParse != TEXT('@')) {
                    if (*pszParse == TEXT('\\')) {
                        rgss->SetStart(pszParse+1);
                    }
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one character
                }
                rgss++;
                break;

#if 0
            case TEXT('s'):             // String
                rgss->SetStart(pszParse);
                while ((_IsPrint(*pszParse) || *pszParse == TEXT('\t')) &&
                       *pszParse != *pszFormat) {
                    pszParse++;
                }
                rgss->SetEnd(pszParse); // Null string is okay
                rgss++;
                break;
#endif

            case TEXT('w'):
                rgss->SetStart(pszParse);
                while (_IsWord(*pszParse)) {
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one character
                }
                rgss++;
                break;

            default:                    // ?
                ASSERT(0);
                return NULL;
            }

        } else if (*pszParse == *pszFormat) {
            pszParse++;
            pszFormat++;
        } else {
            return NULL;
        }

    }

    return CCAST(LPTSTR, pszParse);
}

/*****************************************************************************
 *
 *  Tokenizer
 *
 *****************************************************************************/

void Tokenizer::Restart(LPCTSTR psz)
{
    /* Skip spaces */
    while (IsSpace(*psz)) {
        psz++;
    }
    _psz = psz;
}

BOOL Tokenizer::Token(String& str)
{
    str.Reset();

    if (!*_psz) return FALSE;

    //
    //  Quote state:
    //
    //  Bit 0: In quote?
    //  Bit 1: Was previous character part of a run of quotation marks?
    //
    int iQuote = 0;

    //
    //  Wacko boundary case.  The opening quotation mark should not
    //  be counted as part of a run of quotation marks.
    //
    if (*_psz == TEXT('"')) {
        iQuote = 1;
        _psz++;
    }

    while (*_psz && ((iQuote & 1) || !IsSpace(*_psz))) {
        if (*_psz == TEXT('"')) {
            iQuote ^= 1 ^ 2;
            if (!(iQuote & 2)) {
                str << TEXT('"');
            }
        } else {
            iQuote &= ~2;
            str << *_psz;
        }
        _psz++;
    }

    Restart(_psz);              /* Eat any trailing spaces */

    return TRUE;
}

/*****************************************************************************
 *
 *  GetOpt
 *
 *****************************************************************************/

//
//  Returns the switch character, or '\0' if no more switches.
//
//  The option that terminated switch parsing is left in the tokenizer.
//
TCHAR GetOpt::NextSwitch()
{
    if (!_pszUnparsed) {
        LPCTSTR pszTokUndo = _tok.Unparsed();
        if (!_tok.Token(_str)) {
            return TEXT('\0');              // end of command line
        }

        if (_str[0] != TEXT('-')) {
            _tok.Restart(pszTokUndo);       // so caller can re-read it
            _pszValue = _str;               // all future values will go nere
            return TEXT('\0');              // end of command line

        }

        if (_str[1] == TEXT('\0')) {        // base - end switches
            _pszValue = _str;               // all future values will go nere
            return TEXT('\0');              // but do not re-read it
        }

        _pszUnparsed = &_str[1];
    }

    TCHAR tchSwitch = *_pszUnparsed;
    LPCTSTR pszParam;
    for (pszParam = _pszParams; *pszParam; pszParam++) {
        if (tchSwitch == *pszParam) {

            /*
             *  Value can come immediately afterwards or as a separate token.
             */
            _pszValue = _pszUnparsed + 1;

            if (_pszValue[0] == TEXT('\0')) {
                _tok.Token(_str);
                _pszValue = _str;
            }

            _pszUnparsed = NULL;
            return tchSwitch;
        }
    }

    _pszUnparsed++;
    if (!*_pszUnparsed) _pszUnparsed = NULL;
    return tchSwitch;
}

/*****************************************************************************
 *
 *  CommentParser - Parses checkin comments
 *
 *****************************************************************************/

void CommentParser::AddComment(LPTSTR psz)
{
    if (_fHaveComment) return;

    //
    //  Ignore leading spaces.
    //
    while (*psz == TEXT('\t') || *psz == TEXT(' ')) psz++;

    //
    //  Skip blank description lines.
    //
    if (*psz == TEXT('\0')) return;

    //
    //  Okay, here comes the money.  Is this a Gauntlet checkin?
    //
    LPTSTR pszRest = Parse(TEXT("Checkin by - "), psz, NULL);
    if (pszRest) {
        //
        //  You betcha.  This overrides the dev column.
        //
        SetDev(pszRest);
    } else {
        //
        //  No, it's a regular comment.  Use the first nonblank comment
        //  line as the text and toss the rest.
        //
        //  Change all tabs to spaces because listview doesn't like tabs.
        //
        ChangeTabsToSpaces(psz);

        //
        //  If the comment begins with [alias] or (alias), then move
        //  that alias to the developer column.  Digits can optionally
        //  be inserted before the alias.
        //
        Substring rgss[2];

        if ((pszRest = Parse("[$a]$W", psz, rgss)) ||
            (pszRest = Parse("($a)$W", psz, rgss))) {
            SetDev(rgss[0].Finalize());
            psz = pszRest;
        } else if ((pszRest = Parse("$d$W[$a]$W", psz, rgss)) ||
                   (pszRest = Parse("$d$W($a)$W", psz, rgss))) {
            SetDev(rgss[1].Finalize());
            //
            //  Now collapse out the alias.
            //
            lstrcpy(rgss[1].Start()-1, pszRest);
        }

        SetComment(psz);
        _fHaveComment = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\pipe.cpp ===
/*****************************************************************************
 *
 *  pipe.cpp
 *
 *      Run a command, reading its output.
 *
 *****************************************************************************/

#include "sdview.h"

void ChildProcess::Start(LPCTSTR pszCommand)
{
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    HANDLE hWrite;
    BOOL fSuccess = CreatePipe(&_hRead, &hWrite, &sa, 0);
    if (fSuccess) {
        STARTUPINFO si = { 0 };
        PROCESS_INFORMATION pi;
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = hWrite;

        // Dup stdout to stderr in case client closes one of them.
        if (DuplicateHandle(GetCurrentProcess(), hWrite,
                            GetCurrentProcess(), &si.hStdError, 0,
                            TRUE, DUPLICATE_SAME_ACCESS)) {

            TCHAR szCommand[MAX_PATH];
            lstrcpyn(szCommand, pszCommand, ARRAYSIZE(szCommand));

            fSuccess = CreateProcess(NULL, szCommand, NULL, NULL, TRUE,
                                     CREATE_NEW_PROCESS_GROUP | CREATE_NO_WINDOW | DETACHED_PROCESS,
                                     NULL, NULL, &si, &pi);

            if (fSuccess) {
                CloseHandle(pi.hThread);
                _hProcess = pi.hProcess;
                _dwPid = pi.dwProcessId;
            }

            CloseHandle(si.hStdError);
        }
        CloseHandle(hWrite);

    }
}

void ChildProcess::Stop()
{
    if (_hProcess) {
        CloseHandle(_hProcess);
        _hProcess = NULL;
    }

    if (_hRead) {
        CloseHandle(_hRead);
        _hRead = NULL;
    }

    _dwPid = 0;
}

void ChildProcess::Kill()
{
    if (_dwPid) {
        GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, _dwPid);
    }
}

SDChildProcess::SDChildProcess(LPCTSTR pszCommand)
{
    String str;
    str << QuoteSpaces(GlobalSettings.GetSdPath()) << TEXT(" ") <<
                       GlobalSettings.GetSdOpts() << TEXT(" ");

    if (!GlobalSettings.GetFakeDir().IsEmpty()) {
        str << TEXT("-d ") << QuoteSpaces(GlobalSettings.GetFakeDir()) << TEXT(" ");
    }

    str << pszCommand;
    Start(str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\sdview.cpp ===
/*****************************************************************************
 *
 *  sdview.cpp
 *
 *      Lame SD Viewer app.
 *
 *****************************************************************************/

#include "sdview.h"

HINSTANCE   g_hinst;
HCURSOR     g_hcurWait;
HCURSOR     g_hcurArrow;
HCURSOR     g_hcurAppStarting;
LONG        g_lThreads;
UINT        g_wShowWindow;
CGlobals    GlobalSettings;

/*****************************************************************************
 *
 *  Stubs - will be filled in with goodies eventually
 *
 *****************************************************************************/

DWORD CALLBACK CFileOut_ThreadProc(LPVOID lpParameter)
{
    MessageBox(NULL, RECAST(LPTSTR, lpParameter), TEXT("fileout"), MB_OK);
    return EndThreadTask(0);
}

#if 0
DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter)
{
    MessageBox(NULL, RECAST(LPTSTR, lpParameter), TEXT("opened"), MB_OK);
    return EndThreadTask(0);
}

/*****************************************************************************
 *
 *  Eschew the C runtime.  Also, bonus-initialize memory to zero.
 *
 *****************************************************************************/

void * __cdecl operator new(size_t cb)
{
    return RECAST(LPVOID, LocalAlloc(LPTR, cb));
}

void __cdecl operator delete(void *pv)
{
    LocalFree(RECAST(HLOCAL, pv));
}

int __cdecl _purecall(void)
{
    return 0;
}
#endif

/*****************************************************************************
 *
 *  Assertion goo
 *
 *****************************************************************************/

#ifdef DEBUG
void AssertFailed(char *psz, char *pszFile, int iLine)
{
    static BOOL fAsserting = FALSE;

    if (!fAsserting) {
        fAsserting = TRUE;
        String strTitle(TEXT("Assertion failed - "));
        strTitle << pszFile << TEXT(" - line ") << iLine;
        MessageBox(NULL, psz, strTitle, MB_OK);
        fAsserting = FALSE;
    }
}
#endif

/*****************************************************************************
 *
 *  LaunchThreadTask
 *
 *****************************************************************************/

BOOL LaunchThreadTask(LPTHREAD_START_ROUTINE pfn, LPCTSTR pszArgs)
{
    BOOL fSuccess = FALSE;
    LPTSTR psz = StrDup(pszArgs);
    if (psz) {
        InterlockedIncrement(&g_lThreads);
        if (_QueueUserWorkItem(pfn, CCAST(LPTSTR, psz), WT_EXECUTELONGFUNCTION)) {
            fSuccess = TRUE;
        } else {
            LocalFree(psz);
            InterlockedDecrement(&g_lThreads);
        }
    }
    return fSuccess;
}

/*****************************************************************************
 *
 *  EndThreadTask
 *
 *      When a task finishes, exit with "return EndThreadTask(dwExitCode)".
 *      This decrements the count of active thread tasks and terminates
 *      the process if this is the last one.
 *
 *****************************************************************************/

DWORD
EndThreadTask(DWORD dwExitCode)
{
    if (InterlockedDecrement(&g_lThreads) <= 0) {
        ExitProcess(dwExitCode);
    }
    return dwExitCode;
}

/*****************************************************************************
 *
 *  Listview stuff
 *
 *****************************************************************************/

int ListView_GetCurSel(HWND hwnd)
{
    return ListView_GetNextItem(hwnd, -1, LVNI_FOCUSED);
}

void ListView_SetCurSel(HWND hwnd, int iIndex)

{
    ListView_SetItemState(hwnd, iIndex,
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
}

int ListView_GetSubItemText(HWND hwnd, int iItem, int iSubItem, LPTSTR pszBuf, int cch)
{
    LVITEM lvi;
    lvi.iSubItem = iSubItem;
    lvi.pszText= pszBuf;
    lvi.cchTextMax = cch;
    return (int)::SendMessage(hwnd, LVM_GETITEMTEXT, iItem, RECAST(LPARAM, &lvi));
}

void ChangeTabsToSpaces(LPTSTR psz)
{
    while ((psz = StrChr(psz, TEXT('\t'))) != NULL) *psz = TEXT(' ');
}

/*****************************************************************************
 *
 *  LoadPopupMenu
 *
 *****************************************************************************/

HMENU LoadPopupMenu(LPCTSTR pszMenu)
{
    HMENU hmenuParent = LoadMenu(g_hinst, pszMenu);
    if (hmenuParent) {
        HMENU hmenuPopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hmenuPopup;
    } else {
        return NULL;
    }
}

/*****************************************************************************
 *
 *  EnableDisableOrRemoveMenuItem
 *
 *  Enable, disable or remove, accordingly.
 *
 *****************************************************************************/

void EnableDisableOrRemoveMenuItem(HMENU hmenu, UINT id, BOOL fEnable, BOOL fDelete)
{
    if (fEnable) {
        EnableMenuItem(hmenu, id, MF_BYCOMMAND | MF_ENABLED);
    } else if (fDelete) {
        DeleteMenu(hmenu, id, MF_BYCOMMAND);
    } else {
        EnableMenuItem(hmenu, id, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
    }
}

/*****************************************************************************
 *
 *  MakeMenuPretty
 *
 *  Remove separators at the top and at the bottom, and collapse
 *  multiple consecutive separators.
 *
 *****************************************************************************/

void MakeMenuPretty(HMENU hmenu)
{
    BOOL fPrevSep = TRUE;
    int iCount = GetMenuItemCount(hmenu);
    for (int iItem = 0; iItem < iCount; iItem++) {
        UINT uiState = GetMenuState(hmenu, 0, MF_BYPOSITION);
        if (uiState & MF_SEPARATOR) {
            if (fPrevSep) {
                DeleteMenu(hmenu, iItem, MF_BYPOSITION);
                iCount--;
                iItem--;            // Will be incremented by loop control
            }
            fPrevSep = TRUE;
        } else {
            fPrevSep = FALSE;
        }
    }
    if (iCount && fPrevSep) {
        DeleteMenu(hmenu, iCount - 1, MF_BYPOSITION);
    }
}

/*****************************************************************************
 *
 *  JiggleMouse
 *
 *
 *      Jiggle the mouse to force a cursor recomputation.
 *
 *****************************************************************************/

void JiggleMouse()
{
    POINT pt;
    if (GetCursorPos(&pt)) {
        SetCursorPos(pt.x, pt.y);
    }
}

/*****************************************************************************
 *
 *  BGTask
 *
 *****************************************************************************/

BGTask::~BGTask()
{
    if (_hDone) {
        /*
         *  Theoretically we don't need to pump messages because
         *  we destroyed all the windows we created so our thread
         *  should be clear of any windows.  Except that Cicero will
         *  secretly create a window on our thread, so we have
         *  to pump messages anyway...
         */
        while (MsgWaitForMultipleObjects(1, &_hDone, FALSE,
                                         INFINITE, QS_ALLINPUT) == WAIT_OBJECT_0+1) {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CloseHandle(_hDone);
    }
}

BOOL BGTask::BGStartTask(LPTHREAD_START_ROUTINE pfn, LPVOID Context)
{
    ASSERT(!_fPending);
    if (BGConstructed()) {
        /*
         *  Must reset before queueing the work item to avoid a race where
         *  the work item completes before we return from the Queue call.
         */
        ResetEvent(_hDone);
        _fPending = QueueUserWorkItem(pfn, Context, WT_EXECUTELONGFUNCTION);
        if (_fPending) {
            JiggleMouse();
        } else {
            BGEndTask();    // pretend task completed (because it never started)
        }
    }
    return _fPending;
}

void BGTask::BGEndTask()
{
    SetEvent(_hDone);
    _fPending = FALSE;
    JiggleMouse();
}

LRESULT BGTask::BGFilterSetCursor(LRESULT lres)
{
    if (BGTaskPending()) {
        if (GetCursor() == g_hcurArrow) {
            SetCursor(g_hcurAppStarting);
            lres = TRUE;
        }
    }
    return lres;
}

/*****************************************************************************
 *
 *  PremungeFileSpec
 *
 *  Due to complex view specifications this can be led astray when "..."
 *  gets involved.  As a workaround (HACK!) we change "..." to "???",
 *  do the mapping, then map back.
 *
 *  We choose "???" because it has so many magical properties...
 *
 *  -   not a valid filename, so cannot match a local file specification.
 *  -   not a valid Source Depot wildcard, so cannot go wild on the server,
 *  -   not a single question mark, which SD treats as equivalent to "help".
 *  -   same length as "..." so can be updated in place.
 *
 *  Any revision specifiers remain attached to the string.
 *
 *****************************************************************************/

void _ChangeTo(LPTSTR psz, LPCTSTR pszFrom, LPCTSTR pszTo)
{
    ASSERT(lstrlen(pszFrom) == lstrlen(pszTo));
    while ((psz = StrStr(psz, pszFrom)) != NULL) {
        memcpy(psz, pszTo, lstrlen(pszTo) * sizeof(pszTo[0]));
    }
}

void PremungeFilespec(LPTSTR psz)
{
    _ChangeTo(psz, TEXT("..."), TEXT("???"));
}

void PostmungeFilespec(LPTSTR psz)
{
    _ChangeTo(psz, TEXT("???"), TEXT("..."));
}

/*****************************************************************************
 *
 *  MapToXPath
 *
 *****************************************************************************/

BOOL MapToXPath(LPCTSTR pszSD, String& strOut, MAPTOX X)
{
    if (X == MAPTOX_DEPOT) {
        //
        //  Early-out: Is it already a full depot path?
        //
        if (pszSD[0] == TEXT('/')) {
            strOut = pszSD;
            return TRUE;
        }
    }


    //
    //  Borrow strOut to compose the query string.
    //
    Substring ssPath;
    strOut.Reset();
    if (Parse(TEXT("$p"), pszSD, &ssPath) && ssPath.Length() > 0) {
        strOut << ssPath;
    } else {
        return FALSE;
    }

    PremungeFilespec(strOut);

    String str;
    str << TEXT("where ") << QuoteSpaces(strOut);

    WaitCursor wait;
    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        str.Chomp();
        Substring rgss[3];
        if (rgss[2].SetStart(Parse(TEXT("$P $P "), str, rgss))) {
            PostmungeFilespec(str);
            rgss[2].SetEnd(str + str.Length());
            strOut.Reset();
            strOut << rgss[X] << ssPath._pszMax;
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *  MapToLocalPath
 *
 *      MapToXPath does most of the work, but then we have to do some
 *      magic munging if we are running from a fake directory.
 *
 *****************************************************************************/

BOOL MapToLocalPath(LPCTSTR pszSD, String& strOut)
{
    BOOL fSuccess = MapToXPath(pszSD, strOut, MAPTOX_LOCAL);
    if (fSuccess && !GlobalSettings.GetFakeDir().IsEmpty()) {
        if (strOut.BufferLength() < MAX_PATH) {
            if (!strOut.Grow(MAX_PATH - strOut.BufferLength())) {
                return FALSE;       // Out of memory
            }
        }
        LPCTSTR pszRest = strOut + lstrlen(GlobalSettings.GetFakeDir());
        if (*pszRest == TEXT('\\')) {
            pszRest++;
        }
        PathCombine(strOut.Buffer(), GlobalSettings.GetLocalRoot(), pszRest);
        fSuccess = TRUE;
    }
    return fSuccess;
}

/*****************************************************************************
 *
 *  SpawnProcess
 *
 *****************************************************************************/

BOOL SpawnProcess(LPTSTR pszCommand)
{
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi;

    BOOL fSuccess = CreateProcess(NULL, pszCommand, NULL, NULL, FALSE, 0,
                                  NULL, NULL, &si, &pi);
    if (fSuccess) {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    return fSuccess;
}

/*****************************************************************************
 *
 *  WindiffChangelist
 *
 *****************************************************************************/

void WindiffChangelist(int iChange)
{
    if (iChange > 0) {
        String str;
        str << TEXT("windiff.exe -ld") << iChange;
        SpawnProcess(str);
    }
}

/*****************************************************************************
 *
 *  WindiffOneChange
 *
 *****************************************************************************/

void WindiffOneChange(LPTSTR pszPath)
{
    Substring rgss[2];
    if (Parse(TEXT("$P#$d$e"), pszPath, rgss)) {
        String str;
        str << TEXT("windiff.exe ");

        rgss[0].Finalize();
        int iVersion = StrToInt(rgss[1].Start());
        if (iVersion > 1) {
            /* Edit is easy */
            str << QuoteSpaces(rgss[0].Start()) << TEXT("#") << (iVersion - 1);
        } else {
            /* Add uses NUL as the base file */
            str << TEXT("NUL");
        }

        str << TEXT(' ');
        str << QuoteSpaces(rgss[0].Start()) << TEXT("#") << iVersion;

        SpawnProcess(str);
    }
}

/*****************************************************************************
 *
 *  ParseBugNumber
 *
 *  See if there's a bug number in there.
 *
 *      Digits at the beginning - bug number.
 *      Digits after a space or punctuation mark - bug number.
 *      Digits after the word "bug" or the letter "B" - bug number.
 *
 *  A valid bug number must begin with a nonzero digit.
 *
 *****************************************************************************/

int ParseBugNumber(LPCTSTR psz)
{
    Substring ss;
    LPCTSTR pszStart = psz;

    while (*psz) {
        if (IsDigit(*psz)) {
            if (*psz == TEXT('0')) {
                // Nope, cannot begin with zero
            } else if (psz == pszStart) {
                return StrToInt(psz);       // woo-hoo!
            } else switch (psz[-1]) {
            case 'B':
            case 'g':
            case 'G':
                return StrToInt(psz);       // Comes after a B or a G

            default:
                if (!IsAlpha(psz[-1])) {
                    return StrToInt(psz);   // Comes after a space or punctuation
                }
            }
            // Phooey, a digit string beginning with 0; not a bug.
            while (IsDigit(*psz)) psz++;
        } else {
            psz++;
        }
    }

    return 0;
}

/*****************************************************************************
 *
 *  ParseBugNumberFromSubItem
 *
 *      Sometimes we use this just to parse regular numbers since regular
 *      numbers pass the Bug Number Test.
 *
 *****************************************************************************/

int ParseBugNumberFromSubItem(HWND hwnd, int iItem, int iSubItem)
{
    TCHAR sz[MAX_PATH];
    sz[0] = TEXT('\0');
    if (iItem >= 0) {
        ListView_GetSubItemText(hwnd, iItem, iSubItem, sz, ARRAYSIZE(sz));
    }

    return ParseBugNumber(sz);
}

/*****************************************************************************
 *
 *  AdjustBugMenu
 *
 *****************************************************************************/

inline void _TrimAtTab(LPTSTR psz)
{
    psz = StrChr(psz, TEXT('\t'));
    if (psz) *psz = TEXT('\0');
}

void AdjustBugMenu(HMENU hmenu, int iBug, BOOL fContextMenu)
{
    TCHAR sz[MAX_PATH];
    String str;

    if (iBug) {
        str << StringResource(IDS_VIEWBUG_FORMAT);
        wnsprintf(sz, ARRAYSIZE(sz), str, iBug);
        if (fContextMenu) {
            _TrimAtTab(sz);
        }
        ModifyMenu(hmenu, IDM_VIEWBUG, MF_BYCOMMAND, IDM_VIEWBUG, sz);
    } else {
        str << StringResource(IDS_VIEWBUG_NONE);
        ModifyMenu(hmenu, IDM_VIEWBUG, MF_BYCOMMAND, IDM_VIEWBUG, str);
    }
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWBUG, iBug, fContextMenu);
}

/*****************************************************************************
 *
 *  OpenBugWindow
 *
 *****************************************************************************/

void OpenBugWindow(HWND hwnd, int iBug)
{
    String str;
    GlobalSettings.FormatBugUrl(str, iBug);

    LPCTSTR pszArgs = PathGetArgs(str);
    PathRemoveArgs(str);
    PathUnquoteSpaces(str);

    _AllowSetForegroundWindow(-1);
    ShellExecute(hwnd, NULL, str, pszArgs, 0, SW_NORMAL);
}


/*****************************************************************************
 *
 *  SetClipboardText
 *
 *****************************************************************************/

#ifdef UNICODE
#define CF_TSTR     CF_UNICODETEXT
#else
#define CF_TSTR     CF_TEXT
#endif

void SetClipboardText(HWND hwnd, LPCTSTR psz)
{
    if (OpenClipboard(hwnd)) {
        EmptyClipboard();
        int cch = lstrlen(psz) + 1;
        HGLOBAL hglob = GlobalAlloc(GMEM_MOVEABLE, cch * sizeof(*psz));
        if (hglob) {
            LPTSTR pszCopy = RECAST(LPTSTR, GlobalLock(hglob));
            if (pszCopy) {
                lstrcpy(pszCopy, psz);
                GlobalUnlock(hglob);
                if (SetClipboardData(CF_TSTR, hglob)) {
                    hglob = NULL;       // ownership transfer
                }
            }
            if (hglob) {
                GlobalFree(hglob);
            }
        }
        CloseClipboard();
    }
}

/*****************************************************************************
 *
 *  ContainsWildcards
 *
 *  The SD wildcards are
 *
 *      *       (asterisk)
 *      ...     (ellipsis)
 *      %n      (percent sign followed by anything)
 *      (null)  (null string -- shorthand for "//...")
 *
 *****************************************************************************/

BOOL ContainsWildcards(LPCTSTR psz)
{
    if (*psz == TEXT('#') || *psz == TEXT('@') || *psz == TEXT('\0')) {
        return TRUE;            // Null string wildcard
    }

    for (; *psz; psz++) {
        if (*psz == TEXT('*') || *psz == TEXT('%')) {
            return TRUE;
        }
        if (psz[0] == TEXT('.') && psz[1] == TEXT('.') && psz[2] == TEXT('.')) {
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      Downlevel support
 *
 *****************************************************************************/

#ifdef SUPPORT_DOWNLEVEL

/*
 *  If there is no thread pool, then chew an entire thread.
 */
BOOL WINAPI
Emulate_QueueUserWorkItem(LPTHREAD_START_ROUTINE pfn, LPVOID Context, ULONG Flags)
{
    DWORD dwId;
    HANDLE hThread = CreateThread(NULL, 0, pfn, Context, 0, &dwId);
    if (hThread) {
        CloseHandle(hThread);
        return TRUE;
    }
    return FALSE;
}

BOOL WINAPI
Emulate_AllowSetForegroundWindow(DWORD dwProcessId)
{
    return FALSE;
}

QUEUEUSERWORKITEM _QueueUserWorkItem;
ALLOWSETFOREGROUNDWINDOW _AllowSetForegroundWindow;

template<class T>
T GetProcFromModule(LPCTSTR pszModule, LPCSTR pszProc, T Default)
{
    T t;
    HMODULE hmod = GetModuleHandle(pszModule);
    if (pszModule) {
        t = RECAST(T, GetProcAddress(hmod, pszProc));
        if (!t) {
            t = Default;
        }
    } else {
        t = Default;
    }
    return t;
}


#define GetProc(mod, fn) \
    _##fn = GetProcFromModule(TEXT(mod), #fn, Emulate_##fn)

void InitDownlevel()
{
    GetProc("KERNEL32", QueueUserWorkItem);
    GetProc("USER32",   AllowSetForegroundWindow);

}

#undef GetProc

#else

#define InitDownlevel()

#endif

/*****************************************************************************
 *
 *      Main program stuff
 *
 *****************************************************************************/

LONG GetDllVersion(LPCTSTR pszDll)
{
    HINSTANCE hinst = LoadLibrary(pszDll);
    DWORD dwVersion = 0;
    if (hinst) {
        DLLGETVERSIONPROC DllGetVersion;
        DllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
        if (DllGetVersion) {
            DLLVERSIONINFO dvi;
            dvi.cbSize = sizeof(dvi);
            if (SUCCEEDED(DllGetVersion(&dvi))) {
                dwVersion = MAKELONG(dvi.dwMinorVersion, dvi.dwMajorVersion);
            }
        }
        // Leak the DLL - we're going to use him anyway
    }
    return dwVersion;
}

/*****************************************************************************
 *
 *  Globals
 *
 *****************************************************************************/

BOOL InitGlobals()
{
    g_hinst = GetModuleHandle(0);
    g_hcurWait = LoadCursor(NULL, IDC_WAIT);
    g_hcurArrow = LoadCursor(NULL, IDC_ARROW);
    g_hcurAppStarting = LoadCursor(NULL, IDC_APPSTARTING);

    if (GetDllVersion(TEXT("Comctl32.dll")) < MAKELONG(71, 4) ||
        GetDllVersion(TEXT("Shlwapi.dll")) < MAKELONG(71, 4)) {
        TCHAR sz[MAX_PATH];
        LoadString(g_hinst, IDS_IE4, sz, ARRAYSIZE(sz));
//$$//BUGBUG//        MessageBox(NULL, sz, g_szTitle, MB_OK);
        return FALSE;
    }

    InitDownlevel();
    InitCommonControls();

    /*
     *  Get the SW_ flag for the first window.
     */
    STARTUPINFOA si;
    si.cb = sizeof(si);
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    if (si.dwFlags & STARTF_USESHOWWINDOW) {
        g_wShowWindow = si.wShowWindow;
    } else {
        g_wShowWindow = SW_SHOWDEFAULT;
    }

    return TRUE;
}

void TermGlobals()
{
}

/*****************************************************************************
 *
 *  Help
 *
 *****************************************************************************/

void Help(HWND hwnd, LPCTSTR pszAnchor)
{

    TCHAR szSelf[MAX_PATH];
    GetModuleFileName(g_hinst, szSelf, ARRAYSIZE(szSelf));

    String str;
    str << TEXT("res://") << szSelf << TEXT("/tips.htm");

    if (pszAnchor) {
        str << pszAnchor;
    }

    _AllowSetForegroundWindow(-1);
    ShellExecute(hwnd, NULL, str, 0, 0, SW_NORMAL);
}

/*****************************************************************************
 *
 *  CGlobals::Initialize
 *
 *****************************************************************************/

void CGlobals::Initialize()
{
    /*
     *  The order of these three steps is important.
     *
     *  -   We have to get the path before we can call sd.
     *
     *  -   We need the "sd info" in order to determine what
     *      the proper fake directory is.
     */

    _InitSdPath();
    _InitInfo();
    _InitFakeDir();
    _InitServerVersion();
    _InitBugPage();
}

/*****************************************************************************
 *
 *  CGlobals::_InitSdPath
 *
 *  The environment variable "SD" provides the path to the program to use.
 *  The default is "sd", but for debugging, you can set it to "fakesd",
 *  or if you're using that other company's product, you might even want
 *  to set it to that other company's program...
 *
 *****************************************************************************/

void CGlobals::_InitSdPath()
{
    TCHAR szSd[MAX_PATH];
    LPTSTR pszSdExe;

    DWORD cb = GetEnvironmentVariable(TEXT("SD"), szSd, ARRAYSIZE(szSd));
    if (cb == 0 || cb > ARRAYSIZE(szSd)) {
        pszSdExe = TEXT("SD.EXE");      // Default value
    } else {
        pszSdExe = szSd;
    }

    cb = SearchPath(NULL, pszSdExe, TEXT(".exe"), ARRAYSIZE(_szSd), _szSd, NULL);
    if (cb == 0 || cb > ARRAYSIZE(_szSd)) {
        /*
         *  Not found on path, eek!  Just use sd.exe and wait for the
         *  fireworks.
         */
        lstrcpyn(_szSd, TEXT("SD.EXE"), ARRAYSIZE(_szSd));
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitInfo
 *
 *      Collect the results of the "sd info" command.
 *
 *****************************************************************************/

void CGlobals::_InitInfo()
{
    static const LPCTSTR s_rgpsz[] = {
        TEXT("User name: "),
        TEXT("Client name: "),
        TEXT("Client root: "),
        TEXT("Current directory: "),
        TEXT("Server version: "),
    };

    COMPILETIME_ASSERT(ARRAYSIZE(s_rgpsz) == ARRAYSIZE(_rgpszSettings));

    WaitCursor wait;
    SDChildProcess proc(TEXT("info"));
    IOBuffer buf(proc.Handle());
    String str;
    while (buf.NextLine(str)) {
        str.Chomp();
        int i;
        for (i = 0; i < ARRAYSIZE(s_rgpsz); i++) {
            LPTSTR pszRest = Parse(s_rgpsz[i], str, NULL);
            if (pszRest) {
                _rgpszSettings[i] = pszRest;
            }
        }
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitFakeDir
 *
 *      See if the user is borrowing another person's enlistment.
 *      If so, then virtualize the directory (by walking the tree
 *      looking for an sd.ini file) to keep sd happy.
 *
 *      DO NOT WHINE if anything is wrong.  Magical resolution of
 *      borrowed directories is just a nicety.
 *
 *****************************************************************************/

void CGlobals::_InitFakeDir()
{
    /*
     *  If the client root is not a prefix of the current directory,
     *  then cook up a virtual current directory that will keep sd happy.
     */
    _StringCache& pszClientRoot = _rgpszSettings[SETTING_CLIENTROOT];
    _StringCache& pszLocalDir   = _rgpszSettings[SETTING_LOCALDIR];
    if (!pszClientRoot.IsEmpty() && !pszLocalDir.IsEmpty() &&
        !PathIsPrefix(pszClientRoot, pszLocalDir)) {

        TCHAR szDir[MAX_PATH];
        TCHAR szOriginalDir[MAX_PATH];
        TCHAR szSdIni[MAX_PATH];

        szDir[0] = TEXT('\0');

        GetCurrentDirectory(ARRAYSIZE(szDir), szDir);
        if (!szDir[0]) return;      // Freaky

        lstrcpyn(szOriginalDir, szDir, ARRAYSIZE(szOriginalDir));

        do {
            PathCombine(szSdIni, szDir, TEXT("sd.ini"));
            if (PathFileExists(szSdIni)) {

                _pszLocalRoot = szDir;
                //
                //  Now work from the root back to the current directory.
                //
                LPTSTR pszSuffix = szOriginalDir + lstrlen(szDir);
                if (pszSuffix[0] == TEXT('\\')) {
                    pszSuffix++;
                }

                PathCombine(szSdIni, _rgpszSettings[SETTING_CLIENTROOT], pszSuffix);
                _pszFakeDir = szSdIni;
                break;
            }
        } while (PathRemoveFileSpec(szDir));
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitServerVersion
 *
 *****************************************************************************/

void CGlobals::_InitServerVersion()
{
    Substring rgss[5];
    if (Parse(TEXT("$w $d.$d.$d.$d"), _rgpszSettings[SETTING_SERVERVERSION], rgss)) {
        for (int i = 0; i < VERSION_MAX; i++) {
            _rguiVer[i] = StrToInt(rgss[1+i].Start());
        }
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitBugPage
 *
 *****************************************************************************/

void CGlobals::_InitBugPage()
{
    TCHAR szRaid[MAX_PATH];

    DWORD cb = GetEnvironmentVariable(TEXT("SDVRAID"), szRaid, ARRAYSIZE(szRaid));
    if (cb == 0 || cb > ARRAYSIZE(szRaid)) {
        LoadString(g_hinst, IDS_DEFAULT_BUGPAGE, szRaid, ARRAYSIZE(szRaid));
    }

    LPTSTR pszSharp = StrChr(szRaid, TEXT('#'));
    if (pszSharp) {
        *pszSharp++ = TEXT('\0');
    }
    _pszBugPagePre = szRaid;
    _pszBugPagePost = pszSharp;
}

/*****************************************************************************
 *
 *  CommandLineParser
 *
 *****************************************************************************/

class CommandLineParser
{
public:
    CommandLineParser() : _tok(GetCommandLine()) {}
    BOOL ParseCommandLine();
    void Invoke();

private:
    BOOL ParseMetaParam();
    BOOL TokenWithUndo();
    void UndoToken() { _tok.Restart(_pszUndo); }

private:
    Tokenizer   _tok;
    LPCTSTR     _pszUndo;
    LPTHREAD_START_ROUTINE _pfn;
    String      _str;
};

BOOL CommandLineParser::TokenWithUndo()
{
    _pszUndo = _tok.Unparsed();
    return _tok.Token(_str);
}

BOOL CommandLineParser::ParseMetaParam()
{
    switch (_str[2]) {
    case TEXT('s'):
        if (_str[3] == TEXT('\0')) {
            _tok.Token(_str);
            GlobalSettings.SetSdOpts(_str);
        } else {
            GlobalSettings.SetSdOpts(_str+3);
        }
         break;

    case TEXT('#'):
        switch (_str[3]) {
        case TEXT('+'):
        case TEXT('\0'):
            GlobalSettings.SetChurn(TRUE);
            break;
        case TEXT('-'):
            GlobalSettings.SetChurn(FALSE);
            break;
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CommandLineParser::ParseCommandLine()
{
    _tok.Token(_str);       // Throw away program name

    /*
     *  First collect the meta-parameters.  These begin with two dashes.
     */

    while (TokenWithUndo()) {
        if (_str[0] == TEXT('-') && _str[1] == TEXT('-')) {
            if (!ParseMetaParam()) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    /*
     *  Next thing had better be a command!
     */
    if (_stricmp(_str, TEXT("changes")) == 0) {
        _pfn = CChanges_ThreadProc;
    } else if (_stricmp(_str, TEXT("describe")) == 0) {
        _pfn = CDescribe_ThreadProc;
    } else if (_stricmp(_str, TEXT("filelog")) == 0) {
        _pfn = CFileLog_ThreadProc;
    } else if (_stricmp(_str, TEXT("fileout")) == 0) {
        _pfn = CFileOut_ThreadProc;
    } else if (_stricmp(_str, TEXT("opened")) == 0) {
        _pfn = COpened_ThreadProc;
    } else {
        /*
         *  Eek!  Must use psychic powers!
         */

        Substring ss;
        if (_str[0] == TEXT('\0')) {
            /*
             *  If no args, then it's "changes".
             */
            _pfn = CChanges_ThreadProc;
        } else if (_str[0] == TEXT('-')) {
            /*
             *  If it begins with a dash, then it's "changes".
             */
            _pfn = CChanges_ThreadProc;
        } else if (Parse(TEXT("$d$e"), _str, &ss)) {
            /*
             *  If first word is all digits, then it's "describe".
             */
            _pfn = CDescribe_ThreadProc;
        } else if (_tok.Finished() && !ContainsWildcards(_str)) {
            /*
             *  If only one argument that contains no wildcards,
             *  then it's "filelog".
             */
            _pfn = CFileLog_ThreadProc;
        } else {
            /*
             *  If all else fails, assume "changes".
             */
            _pfn = CChanges_ThreadProc;
        }

        UndoToken();                /* Undo all the tokens we accidentally ate */
    }

    return TRUE;
}

void CommandLineParser::Invoke()
{
    LPTSTR psz = StrDup(_tok.Unparsed());
    if (psz) {
        InterlockedIncrement(&g_lThreads);
        ExitThread(_pfn(psz));
    }
}

/*****************************************************************************
 *
 *  Entry
 *
 *      Program entry point.
 *
 *****************************************************************************/

int
WINAPI
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR lpCmdLine,
    IN int nShowCmd
    )
{
    if (InitGlobals()) {
        CommandLineParser parse;
        if (!parse.ParseCommandLine()) {
            Help(NULL, NULL);
        } else {
            GlobalSettings.Initialize();
            parse.Invoke();
        }
    }

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\string.cpp ===
/*****************************************************************************
 *
 *  string.cpp
 *
 *      World's lamest string class.
 *
 *****************************************************************************/

#include "sdview.h"

_String::_String(LPTSTR pszBufOrig, UINT cchBufOrig)
    : _pszBufOrig(pszBufOrig)
    , _pszBuf(pszBufOrig)
    , _cchBuf(cchBufOrig)
{
    Reset();
}

_String::~_String()
{
    if (_pszBuf != _pszBufOrig) {
        LocalFree(_pszBuf);
    }
}

//
//  Notice that Reset does not free the allocated buffer.  Once we've
//  switched to using an allocated buffer, we may as well continue to
//  use it.
//

void _String::Reset()
{
    ASSERT(_cchBuf);
    _cchLen = 0;
    _pszBuf[0] = TEXT('\0');
}

BOOL _String::Append(LPCTSTR psz, int cch)
{
    int cchNeeded = _cchLen + cch + 1;
    if (cchNeeded > _cchBuf)
    {
        LPTSTR pszNew;
        if (_pszBuf != _pszBufOrig) {
            pszNew = RECAST(LPTSTR, LocalReAlloc(_pszBuf, cchNeeded * sizeof(TCHAR), LMEM_MOVEABLE));
        } else {
            pszNew = RECAST(LPTSTR, LocalAlloc(LMEM_FIXED, cchNeeded * sizeof(TCHAR)));
        }

        if (!pszNew) {
            return FALSE;
        }

        if (_pszBuf == _pszBufOrig) {
            memcpy(pszNew, _pszBuf, _cchBuf * sizeof(TCHAR));
        }
        _cchBuf = cchNeeded;
        _pszBuf = pszNew;
    }

    if (psz) {
        lstrcpyn(_pszBuf + _cchLen, psz, cch + 1);
    }
    _cchLen += cch;
    _pszBuf[_cchLen] = TEXT('\0');

    return TRUE;
}

_String& _String::operator<<(int i)
{
    TCHAR sz[64];
    wsprintf(sz, TEXT("%d"), i);
    return *this << sz;
}

//
//  This could be inline but it's not worth it.
//
_String& _String::operator<<(TCHAR tch)
{
    Append(&tch, 1);
    return *this;
}

//
//  This could be inline but it's not worth it.
//
BOOL _String::Append(LPCTSTR psz)
{
    return Append(psz, lstrlen(psz));
}

BOOL _String::Ensure(int cch)
{
    BOOL f;

    if (Length() + cch < BufferLength()) {
        f = TRUE;                           // Already big enough
    } else {
        f = Grow(cch);
        if (f) {
            _cchLen -= cch;
        }
    }
    return f;
}

//
//  Remove any trailing CRLF
//
void _String::Chomp()
{
    if (Length() > 0 && Buffer()[Length()-1] == TEXT('\n')) {
        Trim();
    }
    if (Length() > 0 && Buffer()[Length()-1] == TEXT('\r')) {
        Trim();
    }
}


OutputStringBuffer::~OutputStringBuffer()
{
    if (Buffer() != OriginalBuffer()) {
        lstrcpyn(OriginalBuffer(), Buffer(), _cchBufOrig);
    }
}

/*****************************************************************************
 *
 *  QuoteSpaces
 *
 *      Append the string, quoting it if it contains any spaces
 *      or if it is the null string.
 *
 *****************************************************************************/

_String& operator<<(_String& str, QuoteSpaces qs)
{
    if (qs) {
        if (qs[0] == TEXT('\0') || StrChr(qs, TEXT(' '))) {
            str << '"' << SAFECAST(LPCTSTR, qs) << '"';
        } else {
            str << SAFECAST(LPCTSTR, qs);
        }
    }
    return str;
}

/*****************************************************************************
 *
 *  BranchOf
 *
 *      Given a full depot path, append the branch name.
 *
 *****************************************************************************/

_String& operator<<(_String& str, BranchOf bof)
{
    if (bof && bof[0] == TEXT('/') && bof[1] == TEXT('/')) {
        //
        //  Skip over the word "//depot" -- or whatever it is.
        //  Some admins are stupid and give the root of the depot
        //  some other strange name.
        //
        LPCTSTR pszBranch = StrChr(bof + 2, TEXT('/'));
        if (pszBranch) {
            pszBranch++;
            //
            //  If the next phrase is "private", then we are in a
            //  private branch; skip a step.
            //
            if (StringBeginsWith(pszBranch, TEXT("private/"))) {
                pszBranch += 8;
            }

            LPCTSTR pszSlash = StrChr(pszBranch, TEXT('/'));
            if (pszSlash) {
                str << Substring(pszBranch, pszSlash);
            }
        }
    }
    return str;
}

/*****************************************************************************
 *
 *  FilenameOf
 *
 *      Given a full depot path, possibly with revision tag,
 *      append just the filename part.
 *
 *****************************************************************************/

_String& operator<<(_String& str, FilenameOf fof)
{
    if (fof) {
        LPCTSTR pszFile = StrRChr(fof, NULL, TEXT('/'));
        if (pszFile) {
            pszFile++;
        } else {
            pszFile = fof;
        }
        str.Append(pszFile, StrCSpn(pszFile, TEXT("#")));
    }
    return str;
}

/*****************************************************************************
 *
 *  StringResource
 *
 *      Given a string resource identifier, append the corresponding string.
 *
 *****************************************************************************/

_String& operator<<(_String& str, StringResource sr)
{
    HRSRC hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(1 + sr / 16), RT_STRING);
    if (hrsrc) {
        HGLOBAL hglob = LoadResource(g_hinst, hrsrc);
        if (hglob) {
            LPWSTR pwch = RECAST(LPWSTR, LockResource(hglob));
            if (pwch) {
                UINT ui;
                for (ui = 0; ui < sr % 16; ui++) {
                    pwch += *pwch + 1;
                }
#ifdef UNICODE
                str.Append(pwch+1, *pwch);
#else
                int cch = WideCharToMultiByte(CP_ACP, 0, pwch+1, *pwch,
                                              NULL, 0, NULL, NULL);
                if (str.Grow(cch)) {
                    WideCharToMultiByte(CP_ACP, 0, pwch+1, *pwch,
                                        str.Buffer() + str.Length() - cch,
                                        cch,
                                        NULL, NULL);
                }
#endif
            }
        }
    }

    return str;
}

/*****************************************************************************
 *
 *  ResolveBranchAndQuoteSpaces
 *
 *      If the file specifier contains a "branch:" prefix, resolve it.
 *      Then append the result (with spaces quoted).
 *
 *****************************************************************************/

//
//  The real work happens in the worker function.
//
_String& _ResolveBranchAndQuoteSpaces(_String& strOut, LPCTSTR pszSpec, LPCTSTR pszColon)
{
    String str;
    String strFull;
    LPCTSTR pszSD = pszColon + 1;

    if (MapToFullDepotPath(pszSD, strFull)) {

        //
        //  Copy the word "//depot" -- or whatever it is.
        //  Some admins are stupid and give the root of the depot
        //  some other strange name.
        //
        LPCTSTR pszBranch = StrChr(strFull + 2, TEXT('/'));
        if (pszBranch) {
            pszBranch++;            // Include the slash
            str << Substring(strFull, pszBranch);

            //
            //  Bonus: If the branch name begins with "/" then
            //  we treat it as a private branch.
            //
            if (pszSpec[0] == TEXT('/')) {
                str << "private";
            }
            str << Substring(pszSpec, pszColon);

            //
            //  If the next phrase is "private", then we are in a
            //  private branch; skip a step.
            //
            if (StringBeginsWith(pszBranch, TEXT("private/"))) {
                pszBranch += 8;
            }

            LPCTSTR pszSlash = StrChr(pszBranch, TEXT('/'));
            if (pszSlash) {
                str << pszSlash;
            }
            strOut << QuoteSpaces(str);
        } else {
            str << QuoteSpaces(strFull);
        }
    } else {
        //
        //  If anything went wrong, then just ignore the branch prefix.
        //
        str << QuoteSpaces(pszSD);
    }

    return str;
}

_String& operator<<(_String& str, ResolveBranchAndQuoteSpaces rb)
{
    Substring ss;
    if (Parse(TEXT("$b:"), rb, &ss)) {
        ASSERT(ss._pszMax[0] == TEXT(':'));
        return _ResolveBranchAndQuoteSpaces(str, rb, ss._pszMax);
    } else {
        return str << QuoteSpaces(rb);
    }
}

/*****************************************************************************
 *
 *  _StringCache=
 *
 *****************************************************************************/

_StringCache& _StringCache::operator=(LPCTSTR psz)
{
    if (_psz) {
        LocalFree(_psz);
    }
    if (psz) {
        _psz = StrDup(psz);
    } else {
        _psz = NULL;
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\sdview.h ===
/*
 *   Private headers
 */

#ifndef STRICT
#define STRICT
#endif

#ifndef WIN32_LEAN_AND_MEAN     /* build.exe will define it for us on NT */
#define WIN32_LEAN_AND_MEAN
#endif
#undef WINVER                   /* build process defines this */
#define WINVER 0x0400           /* Windows 95 compatible */
#define _WIN32_WINDOWS  0x0400  /* Windows 95 compatible */
#include <windows.h>            /* Everybody's favourite */
#include <commctrl.h>

#ifndef RC_INVOKED
#include <windowsx.h>           /* Message crackers */
#include <shlwapi.h>
#include <shellapi.h>
#endif

/*****************************************************************************
 *
 *  Resources
 *
 *****************************************************************************/

/*
 *  Icons
 */
#define IDI_SDV                         0x0001

/*
 *  Bitmaps
 */
#define IDB_PLUS                        0x0001
#define IDB_IMAGES                      0x0002

/*
 *  Strings
 */
#define IDS_TITLE                       0x0001
#define IDS_IE4                         0x0002
#define IDS_SD_EXEC_ERR                 0x0003
#define IDS_DEFAULT_BUGPAGE             0x0004
#define IDS_VIEWBUG_FORMAT              0x0005
#define IDS_VIEWBUG_NONE                0x0006

#define IDS_COL_REV                     0x0100
#define IDS_COL_CHANGE                  0x0101
#define IDS_COL_OP                      0x0102
#define IDS_COL_DATE                    0x0103
#define IDS_COL_DEV                     0x0104
#define IDS_COL_CHURN                   0x0105
#define IDS_COL_COMMENT                 0x0106

/*
 * Menus
 */
#define IDM_CHANGES                     1
#define IDM_CHANGES_POPUP               2

#define IDM_DESCRIBE                    3
#define IDM_DESCRIBE_POPUP              4

#define IDM_FILELOG                     5
#define IDM_FILELOG_POPUP               6

#define IDM_OPENED                      7
#define IDM_OPENED_POPUP                8


#define   IDM_EXIT                      100
#define   IDM_EXITALL                   101

#define   IDM_COPY                      102
#define   IDM_COPYALL                   103

#define   IDM_VIEWDESC                  104
#define   IDM_VIEWFILEDIFF              105
#define   IDM_VIEWWINDIFF               106
#define   IDM_VIEWBUG                   107
#define   IDM_VIEWFILELOG               108

#define   IDM_HELP                      200

/*
 * Accelerators
 */
#define IDA_CHANGES                     1
#define IDA_DESCRIBE                    2
#define IDA_FILELOG                     3
#define IDA_OPENED                      4

/*****************************************************************************
 *
 *  Assorted goo
 *
 *****************************************************************************/

#ifndef RC_INVOKED

extern HINSTANCE    g_hinst;
extern HCURSOR      g_hcurWait;
extern HCURSOR      g_hcurArrow;
extern HCURSOR      g_hcurAppStarting;
extern LONG         g_lThreads;
extern TCHAR        g_szTitle[MAX_PATH];
extern UINT         g_wShowWindow;

DWORD EndThreadTask(DWORD dwExitCode);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif

#ifndef NO_VTABLE
#define NO_VTABLE   __declspec(novtable)
#endif

/*
 *  Because C++ syntax is so ugly.
 */
#define SAFECAST(T, p)  static_cast<T>(p)
#define RECAST(T, p)    reinterpret_cast<T>(p)
#define CCAST(T, p)     const_cast<T>(p)

/*****************************************************************************
 *
 *  Utility goo
 *
 *****************************************************************************/

class String;

int ListView_GetCurSel(HWND hwnd);
void ListView_SetCurSel(HWND hwnd, int iIndex);
int ListView_GetSubItemText(HWND hwnd, int iItem, int iSubItem, LPTSTR pszBuf, int cch);
#undef ListView_GetItemText
#define ListView_GetItemText(hwnd, iItem, pszBuf, cch) \
        ListView_GetSubItemText(hwnd, iItem, 0, pszBuf, cch)

void ChangeTabsToSpaces(LPTSTR psz);

void PremungeFilespec(LPTSTR psz);
void PostmungeFilespec(LPTSTR psz);

BOOL ContainsWildcards(LPCTSTR psz);

enum MAPTOX {
    MAPTOX_DEPOT,           //  //depot/path
    MAPTOX_CLIENT,          //  //CLIENT/path
    MAPTOX_LOCAL,           //  C:\src\path
};
BOOL MapToXPath(LPCTSTR pszSD, String& strOut, MAPTOX X);

inline BOOL MapToFullDepotPath(LPCTSTR pszSD, String& strOut)
    { return MapToXPath(pszSD, strOut, MAPTOX_DEPOT); }
inline BOOL MapToClientPath(LPCTSTR pszSD, String& strOut)
    { return MapToXPath(pszSD, strOut, MAPTOX_CLIENT); }
BOOL MapToLocalPath(LPCTSTR pszSD, String& strOut);

void Help(HWND hwnd, LPCTSTR pszAnchor);

BOOL SpawnProcess(LPTSTR pszCommand);
void WindiffChangelist(int iChange);
void WindiffOneChange(LPTSTR pszPath);

int ParseBugNumber(LPCTSTR psz);
int ParseBugNumberFromSubItem(HWND hwnd, int iItem, int iSubItem);
void AdjustBugMenu(HMENU hmenu, int iBug, BOOL fContextMenu);
void OpenBugWindow(HWND hwnd, int iBug);

void JiggleMouse();
HMENU LoadPopupMenu(LPCTSTR pszMenu);
void MakeMenuPretty(HMENU hmenu);
void EnableDisableOrRemoveMenuItem(HMENU hmenu, UINT id, BOOL fEnable, BOOL fDelete);
void SetClipboardText(HWND hwnd, LPCTSTR psz);

// SCHAR is the opposite of TCHAR
#ifdef UNICODE
typedef  CHAR SCHAR;
#else
typedef WCHAR SCHAR;
#endif
typedef SCHAR *LPSSTR;
typedef const SCHAR *LPCSSTR;

/*****************************************************************************
 *
 *  Change types
 *
 *****************************************************************************/

enum {
    OP_UNKNOWN,
    OP_EDIT,
    OP_DELETE,
    OP_ADD,
    OP_INTEGRATE,
    OP_MERGE,
    OP_BRANCH,
    OP_COPY,
    OP_IGNORED,
    OP_MAX,
};


extern struct LogEntryImageMap {
    LPCTSTR _pszOp;
    int     _iImage;
} c_rgleim[];

int ParseOp(LPCTSTR psz);

/*****************************************************************************
 *
 *  Assertion goo
 *
 *****************************************************************************/

#ifdef DEBUG
void AssertFailed(char *psz, char *pszFile, int iLine);
#define ASSERT(f) ((f) || (AssertFailed(#f, __FILE__, __LINE__), 0))
#else
#define ASSERT sizeof
#endif

#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:

/*****************************************************************************
 *
 *  Downlevel OS support (is this still needed?)
 *
 *****************************************************************************/

#undef SUPPORT_DOWNLEVEL
#ifdef SUPPORT_DOWNLEVEL

typedef BOOL (WINAPI *QUEUEUSERWORKITEM)(LPTHREAD_START_ROUTINE, LPVOID, ULONG);
typedef BOOL (WINAPI *ALLOWSETFOREGROUNDWINDOW)(DWORD);

extern QUEUEUSERWORKITEM _QueueUserWorkItem;
extern ALLOWSETFOREGROUNDWINDOW _AllowSetForegroundWindow;

#else

#define _QueueUserWorkItem          QueueUserWorkItem
#define _AllowSetForegroundWindow   AllowSetForegroundWindow

#endif

/*****************************************************************************
 *
 *  Ctype
 *
 *****************************************************************************/

#define C_NONE      0x00
#define C_SPACE     0x01
#define C_DIGIT     0x02
#define C_ALPHA     0x04
#define C_DASH      0x08
#define C_BRNCH     0x10

#define B_DEFAULT   C_NONE              // Characters above 128 are this

extern const BYTE c_rgbCtype[128];

inline BOOL _InOrder(UINT tch1, UINT tch2, UINT tch3)
{
    return tch2 - tch1 <= tch3 - tch1;
}

inline BOOL _Ctype(TCHAR tch, BYTE fl)
{
    UINT ui = (UINT)tch;
    BYTE b;
    if (ui < ARRAYSIZE(c_rgbCtype)) {
        b = c_rgbCtype[ui];
    } else {
        b = B_DEFAULT;
    }
    return b & fl;
}

inline BOOL IsSpace(TCHAR tch)
{
    return _Ctype(tch, C_SPACE);
}

inline BOOL IsDigit(TCHAR tch)
{
    return _Ctype(tch, C_DIGIT);
}

inline BOOL IsNZDigit(TCHAR tch)
{
    return _InOrder(TEXT('1'), tch, TEXT('9'));
}

inline BOOL IsAlpha(TCHAR tch)
{
    return _Ctype(tch, C_ALPHA);
}

inline BOOL IsAlias(TCHAR tch)
{
    return _Ctype(tch, C_DASH | C_DIGIT | C_ALPHA);
}

inline BOOL IsBranch(TCHAR tch)
{
    return _Ctype(tch, C_DASH | C_DIGIT | C_ALPHA | C_BRNCH);
}

inline BOOL _IsPrint(TCHAR tch)
{
    return _InOrder(TEXT(' '), tch, TEXT('~'));
}

#define _IsWord(ch) ((UINT)(ch) > TEXT(' '))

/*****************************************************************************
 *
 *  Commands
 *
 *****************************************************************************/

extern DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CFileOut_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter);

BOOL LaunchThreadTask(LPTHREAD_START_ROUTINE pfn, LPCTSTR pszArgs);

/*****************************************************************************
 *
 *  String, _String, OutputStringBuffer
 *
 *  An extremely lame low-performance string class
 *  Be careful what you do with it since you can't do much.
 *
 *  _String is the base class that does the heavy lifting and shunts long
 *  strings into the heap.
 *
 *  String collects strings into a private buffer (which can overflow into
 *  the heap).
 *
 *  OutputStringBuffer collects strings into the buffer provided
 *  (which can overflow into the heap).  On destruction, copies the result
 *  if necessary back to the buffer provided.
 *
 *****************************************************************************/

class _String
{
public:
    explicit _String(LPTSTR pszBufOrig, UINT cchBufOrig);
    ~_String();
    void Reset();
    operator LPTSTR() const { return _pszBuf; }
    LPTSTR Buffer() const { return _pszBuf; }
    int BufferLength() const { return _cchBuf; }
    _String& operator<<(LPCTSTR psz) { Append(psz); return *this; }
    _String& operator<<(const _String& str) { Append(str); return *this; }
    _String& operator<<(int i);
    _String& operator<<(TCHAR tch);
    _String& operator=(LPCTSTR psz) { Reset(); Append(psz); return *this; }
    int Length() const { return _cchLen; }
    BOOL Append(LPCTSTR psz);
    BOOL Append(const _String& str) { return Append(str, str.Length()); }
    BOOL Append(LPCTSTR psz, int cchLen);
    BOOL Grow(int cchLen) { return Append(NULL, cchLen); }
    BOOL Ensure(int cchLen);
    void Trim(int cchTrim = 1) { _pszBuf[_cchLen -= cchTrim] = TEXT('\0'); }
    void SetLength(int cchLen) { ASSERT(_cchLen < _cchBuf); _cchLen = cchLen; }
    void Chomp();
protected:
    LPTSTR OriginalBuffer() const { return _pszBufOrig; }
private:

    // Disallow the default copy constructor and assignment operator.
    // Since our class has pointers, a block copy is never correct.
    _String(const _String&); // never defined
    _String& operator=(const _String&); // never defined

    LPTSTR  _pszBuf;
    int     _cchLen;
    int     _cchBuf;
    LPTSTR  _pszBufOrig;
};

class String : public _String
{
public:
    explicit String() : _String(_szBuf, ARRAYSIZE(_szBuf)) { }
    explicit String(LPCTSTR psz) : _String(_szBuf, ARRAYSIZE(_szBuf)) { Append(psz); }
    String& operator=(LPCTSTR psz) { _String::operator=(psz); return *this; }

private:
    /* Almost all strings are smaller than this */
    TCHAR   _szBuf[MAX_PATH];
};

class OutputStringBuffer : public _String
{
public:
    OutputStringBuffer(LPTSTR pszBuf, UINT cchBuf)
        : _String(pszBuf, cchBuf)
        , _cchBufOrig(cchBuf) { }
    ~OutputStringBuffer();
private:
    int     _cchBufOrig;
};

/*****************************************************************************
 *
 *  Custom output formats for "str << blah"
 *
 *****************************************************************************/

class _StringFormat {
public:
    operator LPCTSTR() const { return _pszDepotPath; }
    _StringFormat(LPCTSTR pszDepotPath) : _pszDepotPath(pszDepotPath) { }
protected:
    LPCTSTR _pszDepotPath;
};

#define MakeStringFormat(T)                                     \
class T : public _StringFormat {                                \
public:                                                         \
    T(LPCTSTR pszDepotPath) : _StringFormat(pszDepotPath) { }   \
};                                                              \
_String& operator<<(_String& str, T t);                         \

MakeStringFormat(QuoteSpaces)
MakeStringFormat(BranchOf)
MakeStringFormat(FilenameOf)
MakeStringFormat(ResolveBranchAndQuoteSpaces)

class StringResource {
public:
    operator UINT() const { return _ids; }
    StringResource(UINT ids) : _ids(ids) { }
protected:
    UINT _ids;
};
_String& operator<<(_String& str, StringResource sr);

#define StringBeginsWith(psz, sz) (StrCmpN(psz, sz, ARRAYSIZE(sz) - 1) == 0)

/*****************************************************************************
 *
 *  StringCache is a class that babysits a string pointer.
 *
 *  _StringCache is the version that requires explicit
 *  construction/destruction.  It is safe to use in global structures.
 *
 *****************************************************************************/

struct _StringCache {
public:
    _StringCache& operator=(LPCTSTR psz);
    BOOL IsEmpty() const { return _psz == NULL; }
    operator LPTSTR() const { return Value(); }
    LPTSTR Value() const { return IsEmpty() ? TEXT("") : _psz; }

public:
    LPTSTR _psz;
};

class StringCache : public _StringCache
{
public:
    StringCache() { _psz = NULL; }
    StringCache(LPCTSTR psz) { _psz = NULL; *this = psz; }
    ~StringCache() { *this = NULL; }
    StringCache& operator=(LPCTSTR psz)
        { *SAFECAST(_StringCache*,this) = psz; return *this; }
};

/*
 *  match.cpp - Highly-specialized depot path matching class
 */
class Match {
public:
    Match(LPCTSTR pszPattern);
    ~Match() { delete [] _pszzPats; }
    BOOL Matches(LPCTSTR pszPath);

private:
    void _AddPattern(LPTSTR pszPat, String& strPats);
    BOOL _Matches(LPCTSTR pszPat, LPCTSTR pszPath);
private:
    LPTSTR      _pszzPats;
    LPTSTR      _pszEnd;
};

/*
 *  pipe.cpp
 */

class ChildProcess
{
public:
    explicit ChildProcess() { Construct(); }
    explicit ChildProcess(LPCTSTR pszCommand) { Construct(); Start(pszCommand); }
    void Start(LPCTSTR pszCommand);
    ~ChildProcess() { Stop(); }

    BOOL IsRunning() const { return _dwPid; }
    HANDLE Handle() const { return _hRead; }
    void Kill();
    void Stop();

private:
    void Construct()
    {
        _hProcess = NULL;
        _hRead = NULL;
        _dwPid = 0;
    }


private:
    HANDLE  _hRead;
    HANDLE  _hProcess;
    DWORD   _dwPid;
};

class SDChildProcess : public ChildProcess
{
public:
    explicit SDChildProcess(LPCTSTR pszCommand);
};

/*
 *  buffer.cpp
 */

class IOBuffer
{
public:
    IOBuffer(HANDLE hRead) { Init(hRead); }
    void Init(HANDLE hRead) { _hRead = hRead; _cchBufUsed = 0; }
    BOOL NextLine(String &);

private:
    enum {
        _cchBuf = MAX_PATH,
    };

    HANDLE  _hRead;
    TCHAR   _rgchBuf[_cchBuf];
    int     _cchBufUsed;            /* Number of bytes already in buffer */
};

/*****************************************************************************
 *
 *  LVInfoTip - lvframe.cpp
 *
 *  Special hack class to support extra-long infotips in listview.
 *
 *****************************************************************************/

class LVInfoTip
{
public:
    void    Attach(HWND hwnd);
    ~LVInfoTip() { FreeLastTipAlt(); }
    void    SetInfoTip(NMLVGETINFOTIP *pgit, LPCTSTR pszTip);
private:
    void    FreeLastTipAlt();
    BOOL    ThunkLastTip();

    static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LPCTSTR GetSubclassProperty() { return TEXT("LVInfoTip"); }

private:
    WNDPROC     _wndprocPrev;
    BOOL        _fGotInfoTip;
    LPCTSTR     _pszLastTip;
    LPSSTR      _pszLastTipAlt;
};

/*****************************************************************************
 *
 *  TreeList - treelist.cpp
 *
 *  A tree-like listview.
 *
 *****************************************************************************/

/*
 *  We maintain our own tree structure and add/delete items in the
 *  listview as necessary as tree nodes are expanded/collapsed.
 */

#define PTI_ONDEMAND RECAST(TreeItem*, -1)
#define PTI_APPEND   RECAST(TreeItem*, -1)

class TreeItem {
public:
    TreeItem *  Parent() const { return _ptiParent; }
    TreeItem *  NextSibling() const { return _ptiNext; }
    TreeItem *  FirstChild() const { return _ptiChild; }
    TreeItem *  NextVisible();
    BOOL        IsExpanded() const { return _cVisKids > 0; }
    BOOL        IsExpandable() const { return _ptiChild != NULL; }
    BOOL        IsVisible();
    BOOL        IsVisibleOrRoot();
    void        SetExpandable() { SetFirstChild(PTI_ONDEMAND); }
    void        SetNotExpandable() { SetFirstChild(NULL); }

private:
    friend class Tree;

    BOOL        IsSentinel() const { return this == NULL || this == PTI_ONDEMAND; }
    void        SetFirstChild(TreeItem *pti) { ASSERT(_ptiChild->IsSentinel()); _ptiChild = pti; }

private:
    TreeItem *  _ptiParent;
    TreeItem *  _ptiNext;
    TreeItem *  _ptiChild;

    int         _iDepth;
    int         _iVisIndex;
    int         _cVisKids;
};

#define TLN_GETDISPINFO         100     // Get pszText/cchTextMax given pti/iSubItem
#define TLN_FILLCHILDREN        101     // Fill children of pti
#define TLN_ITEMACTIVATE        102     // Default action on pti
#define TLN_GETINFOTIP          103     // Get pszText/cchTextMax given pti
#define TLN_DELETEITEM          104     // Destruct the node
#define TLN_GETCONTEXTMENU      105     // Display a context menu

struct NMTREELIST {
    NMHDR hdr;
    TreeItem *pti;
    int iSubItem;
    LPTSTR pszText;
    int cchTextMax;                     // Doubles as state
};

class Tree {
public:
    Tree(TreeItem *ptiRoot);
    ~Tree();
    TreeItem*   GetRoot() { return _ptiRoot; }
    BOOL Insert(TreeItem *pti, TreeItem *ptiParent, TreeItem *ptiAfter);
    void SetHWND(HWND hwnd);
    int Expand(TreeItem *pti);
    int Collapse(TreeItem *pti);
    int ToggleExpand(TreeItem *pti);
    void RedrawItem(TreeItem *pti);
    TreeItem *GetCurSel();
    void SetCurSel(TreeItem *pti);
    HIMAGELIST SetImageList(HIMAGELIST himl);

public: //$$// make these protected someday
    LRESULT OnGetDispInfo(NMLVDISPINFO *plvd);
    LRESULT OnCacheHint(NMLVCACHEHINT *phint);
    LRESULT OnItemActivate(int iItem);
    LRESULT OnKeyDown(NMLVKEYDOWN *pkd);
    LRESULT OnClick(NMITEMACTIVATE *pia);
    LRESULT OnGetInfoTip(NMLVGETINFOTIP *pgit);
    LRESULT OnGetContextMenu(int iItem);
    LRESULT OnCopyToClipboard(int iMin, int iMax);

private:
    void Recalc(TreeItem *pti);
    void UpdateCache(TreeItem *pti, int iItem);
    LRESULT SendNotify(int code, NMHDR *pnm);
    TreeItem* IndexToItem(int iItem);
    int InsertListviewItem(int iItem);
    void UpdateVisibleCounts(TreeItem *pti, int cDelta);
    void DeleteNode(TreeItem *pti);
    void SendDeleteNotify(TreeItem *pti);

private:
    HWND        _hwnd;
    TreeItem*   _ptiRoot;

    int         _iHint;
    TreeItem*   _ptiHint;
};


/*****************************************************************************
 *
 *  FrameWindow - window.cpp
 *
 *  A window that frames an inner control.  The inner control is resized
 *  to fill the client area.
 *
 *****************************************************************************/

#define FW_MSG(msg) case msg: return ON_##msg(uiMsg, wParam, lParam)

class NO_VTABLE FrameWindow {

public:
    static DWORD RunThread(FrameWindow *self, LPVOID lpParameter);

protected:
    void SetAcceleratorTable(LPCTSTR pszAccel)
    {
        _haccel = LoadAccelerators(g_hinst, pszAccel);
    }

    BOOL SetWindowMenu(LPCTSTR pszMenu)
    {
        return SetMenu(_hwnd, LoadMenu(g_hinst, pszMenu));
    }

    virtual LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual ~FrameWindow() { }

    //
    //  For talking back to yourself (typically from a base class back
    //  to a derived class).  Short-circuits the WndProc wrapper for
    //  perf.  Do not use cross-thread!
    //
    LRESULT SendSelfMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return HandleMessage(uMsg, wParam, lParam);
    }

private:
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    HWND CreateFrameWindow();

protected:
    HWND            _hwnd;
    HWND            _hwndChild;
    HACCEL          _haccel;
    LPTSTR          _pszQuery;
};

/*****************************************************************************
 *
 *  LVFrame - lvframe.cpp
 *
 *  A FrameWindow that frames a listview in report mode.
 *
 *****************************************************************************/

#define LM_ITEMACTIVATE     (WM_USER + 100) // wParam = iItem
#define LM_GETINFOTIP       (WM_USER + 101) // wParam = iItem, lParam -> NMLVGETINFOTIP
#define LM_GETCONTEXTMENU   (WM_USER + 102) // wParam = iItem
#define LM_COPYTOCLIPBOARD  (WM_USER + 103) // wParam = iMin, lParam = iMax (exclusive)
#define LM_DELETEITEM       (WM_USER + 104) // wParam = iItem, lParam = lParam

typedef struct LVFCOLUMN {
    UINT cch;
    UINT ids;
    UINT fmt;
} LVFCOLUMN;

class NO_VTABLE LVFrame : public FrameWindow {

    typedef FrameWindow super;

protected:
    enum { IDC_LIST = 1 };
    BOOL CreateChild(DWORD dwStyle, DWORD dwExStyle);
    BOOL AddColumns(const LVFCOLUMN *rgcol);

    void *GetLVItem(int iItem);
    int GetCurSel() { return ListView_GetCurSel(_hwndChild); }

    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_CONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:
    LVInfoTip   _it;
};

/*****************************************************************************
 *
 *  TLFrame - tlframe.cpp
 *
 *  Wraps the Tree class.  If I were less lazy, I would merge it into
 *  this class, but right now Tree is a separate class because I stole
 *  the code from sdflog...
 *
 *****************************************************************************/

class NO_VTABLE TLFrame : public LVFrame {

    typedef LVFrame super;

protected:
    TLFrame(TreeItem *ptiRoot) : _tree(ptiRoot) { }
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    BOOL CreateChild(DWORD dwStyle, DWORD dwExStyle);
    TreeItem *TLGetCurSel() { return _tree.GetCurSel(); };

private:
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);

protected:
    Tree        _tree;
};

/*****************************************************************************
 *
 *  BGTask
 *
 *****************************************************************************/

class BGTask
{
protected:
    BGTask() : _hDone(CreateEvent(NULL, TRUE, TRUE, NULL)), _fPending(FALSE) { }
    BOOL BGConstructed() const { return _hDone != NULL; }
    BOOL BGTaskPending() const { return _fPending; }
    ~BGTask();
    BOOL BGStartTask(LPTHREAD_START_ROUTINE pfn, LPVOID Context);
    void BGEndTask();
    LRESULT BGFilterSetCursor(LRESULT lres);
private:
    BOOL    _fPending;
    HANDLE  _hDone;
};

/*****************************************************************************
 *
 *  Parser
 *
 *****************************************************************************/

class Substring
{
public:
    LPTSTR _pszMin;         // First character of the substring
    LPTSTR _pszMax;         // One past the last character of the substring

    explicit Substring() { }
    explicit Substring(LPCTSTR pszMin, LPCTSTR pszMax)
        : _pszMin(CCAST(LPTSTR, pszMin)),
          _pszMax(CCAST(LPTSTR, pszMax)) { }

    LPTSTR SetStart(LPCTSTR psz)
    {
        return _pszMin = CCAST(LPTSTR, psz);
    }

    LPTSTR Start() { return _pszMin; }
    SIZE_T Length() const { return _pszMax - _pszMin; }

    SIZE_T SetEnd(LPCTSTR psz)
    {
        _pszMax = CCAST(LPTSTR, psz);
        return Length();
    }

    LPTSTR Finalize()       // This method works only on mutable substrings
    {
        *_pszMax = TEXT('\0');
        return _pszMin;
    }
};

LPTSTR Parse(LPCTSTR pszFormat, LPCTSTR pszParse, Substring *rgss);
inline _String& operator<<(_String& str, Substring ss)
{
    str.Append(ss._pszMin, (int)(ss._pszMax - ss._pszMin));
    return str;
}

/*****************************************************************************
 *
 *  CommentParser - Parses checkin comments
 *
 *****************************************************************************/

class NO_VTABLE CommentParser {

public:

    virtual void SetDev(LPCTSTR psz) = 0;
    virtual void SetComment(LPCTSTR psz) = 0;

    void Reset() { _fHaveComment = FALSE; }
    void AddComment(LPTSTR psz);

    CommentParser() { Reset(); }

private:
    BOOL    _fHaveComment;
};


/*****************************************************************************
 *
 *  Tokenizer
 *
 *****************************************************************************/

class Tokenizer
{
public:
    explicit Tokenizer() { }
    explicit Tokenizer(LPCTSTR psz) { Restart(psz); }
    void Restart(LPCTSTR psz);
    LPCTSTR Unparsed() const { return _psz; }
    BOOL Token(String& str);
    BOOL Finished() const { return !*_psz; }
private:
    LPCTSTR _psz;
};

/*****************************************************************************
 *
 *  GetOpt
 *
 *  pszParams is the list of switches that take parameters.  By default,
 *  switches do not take parameters.
 *
 *****************************************************************************/

class GetOpt
{
public:
    GetOpt(LPCTSTR pszParams, LPCTSTR pszArg)
        : _pszParams(pszParams), _pszUnparsed(NULL), _tok(pszArg) { }
    TCHAR NextSwitch();
    BOOL Token() { return _tok.Token(_str); }
    BOOL Finished() { return _tok.Finished(); }
    LPCTSTR GetValue() const { return _pszValue; }
    Tokenizer GetTokenizer() const { return _tok; }

private:
    LPCTSTR     _pszParams;
    LPTSTR      _pszUnparsed;
    LPTSTR      _pszValue;
    Tokenizer   _tok;
    String      _str;
};

/*****************************************************************************
 *
 *  WaitCursor
 *
 *****************************************************************************/

class WaitCursor
{
public:
    explicit WaitCursor() : _hcur(SetCursor(g_hcurWait)) { }
    ~WaitCursor() { SetCursor(_hcur); }
private:
    HCURSOR _hcur;
};

/*****************************************************************************
 *
 *  Annoying version-checking functions
 *
 *****************************************************************************/

inline BOOL VER1GE(UINT A,
                   UINT a)
{ return A >= a; }

inline BOOL VER2GE(UINT A, UINT B,
                   UINT a, UINT b)
{ return A > a || (A == a && VER1GE(B,b)); }

inline BOOL VER3GE(UINT A, UINT B, UINT C,
                   UINT a, UINT b, UINT c)
{ return A > a || (A == a && VER2GE(B,C,b,c)); }

inline BOOL VER4GE(UINT A, UINT B, UINT C, UINT D,
                   UINT a, UINT b, UINT c, UINT d)
{ return A > a || (A == a && VER3GE(B,C,D,b,c,d)); }


/*****************************************************************************
 *
 *  Globals
 *
 *****************************************************************************/

struct CGlobals
{
public:
    void    Initialize();

    BOOL                IsChurnEnabled() const { return _fChurn; }
    const _StringCache& GetSdOpts()      const { return _pszSdOpts; }
    const _StringCache& GetUserName()    const { return _rgpszSettings[SETTING_USERNAME]; }
    const _StringCache& GetClientName()  const { return _rgpszSettings[SETTING_CLIENTNAME]; }
    const _StringCache& GetClientRoot()  const { return _rgpszSettings[SETTING_CLIENTROOT]; }
    const _StringCache& GetFakeDir()     const { return _pszFakeDir; }
    const _StringCache& GetLocalRoot()   const { return _pszLocalRoot; }
    LPCTSTR             GetSdPath()      const { return _szSd; }
    String&             FormatBugUrl(String& str, int iBug) const
    {
        str << _pszBugPagePre << iBug << _pszBugPagePost;
        return str;
    }

    void    SetChurn(BOOL fChurn) { _fChurn = fChurn; }
    void    SetSdOpts(LPCTSTR psz) { _pszSdOpts = psz; }
    BOOL    IsVersion(UINT major) { return VER1GE(_Major(), major); }
    BOOL    IsVersion(UINT major, UINT minor)
        { return VER2GE(_Major(), _Minor(), major, minor); }


private:
    void _InitSdPath();
    void _InitInfo();
    void _InitFakeDir();
    void _InitServerVersion();
    void _InitBugPage();

    UINT _Major() { return _rguiVer[VERSION_MAJOR]; }
    UINT _Minor() { return _rguiVer[VERSION_MINOR]; }

    enum {
        SETTING_USERNAME,
        SETTING_CLIENTNAME,
        SETTING_CLIENTROOT,
        SETTING_LOCALDIR,
        SETTING_SERVERVERSION,
        SETTING_MAX
    };

    enum {
        VERSION_MAJOR,
        VERSION_MINOR,
        VERSION_BUILD,
        VERSION_QFE,
        VERSION_MAX,
    };

private:
    BOOL    _fChurn;
    _StringCache _pszSdOpts;
    _StringCache _pszLocalRoot;
    _StringCache _pszFakeDir;
    _StringCache _pszBugPagePre;
    _StringCache _pszBugPagePost;
    _StringCache _rgpszSettings[SETTING_MAX];
    UINT    _rguiVer[VERSION_MAX];
    TCHAR   _szSd[MAX_PATH];
};

extern CGlobals GlobalSettings;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\tlframe.cpp ===
/*****************************************************************************
 *
 *  tlframe.cpp
 *
 *      Frame window that hosts a treelist.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  TLFrame
 *
 *****************************************************************************/

LRESULT TLFrame::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *pnm = RECAST(NMHDR *, lParam);

    if (pnm->idFrom == IDC_LIST) {
        switch (pnm->code) {

        case LVN_GETDISPINFO:
            return _tree.OnGetDispInfo(CONTAINING_RECORD(pnm, NMLVDISPINFO, hdr));

        case LVN_ODCACHEHINT:
            return _tree.OnCacheHint(CONTAINING_RECORD(pnm, NMLVCACHEHINT, hdr));

        case LVN_KEYDOWN:
            return _tree.OnKeyDown(CONTAINING_RECORD(pnm, NMLVKEYDOWN, hdr));

        case NM_CLICK:
            return _tree.OnClick(CONTAINING_RECORD(pnm, NMITEMACTIVATE, hdr));
        }
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT TLFrame::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnItemActivate((int)wParam);
}

LRESULT TLFrame::ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnGetInfoTip(RECAST(NMLVGETINFOTIP *, lParam));
}

LRESULT TLFrame::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnGetContextMenu((int)wParam);
}

LRESULT TLFrame::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnCopyToClipboard((int)wParam, (int)lParam);
}

BOOL TLFrame::CreateChild(DWORD dwStyle, DWORD dwExStyle)
{
    BOOL fResult = super::CreateChild(dwStyle | LVS_OWNERDATA, dwExStyle);
    if (fResult) {
        _tree.SetHWND(_hwndChild);
        HIMAGELIST himl = ImageList_LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_IMAGES),
                                               16, 0, RGB(0xFF, 0x00, 0xFF));
        _tree.SetImageList(himl);
        ImageList_SetOverlayImage(himl, 7, 1);
    }
    return fResult;
}

LRESULT
TLFrame::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_NOTIFY);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETINFOTIP);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\global.h ===
// Global definitions for secedit project

#define WM_SECEDITNOTIFY    WM_USER+100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\acledit.c ===
/****************************************************************************

   PROGRAM: TOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "SECEDIT.h"
#include <sedapi.h>

BOOL
EditTokenDefaultAcl(
    HWND    Owner,
    HANDLE  Instance,
    LPWSTR  ObjectName,
    HANDLE  Token,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD   *EditResult
    );



/***************************************************************************\
* ApplySecurity
*
* Purpose : Called by ACL editor to set new default DACL on token
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplySecurity(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE MyToken = (HANDLE)CallbackContext;
    HANDLE Token = NULL;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    NTSTATUS Status;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

    //
    // Get a handle to the token
    //

    Token = OpenToken(MyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token for TOKEN_ADJUST_DEFAULT access\n");
        goto CleanupAndExit;
    }

    DefaultDacl = Alloc(sizeof(TOKEN_DEFAULT_DACL));
    if (DefaultDacl == NULL) {
        goto CleanupAndExit;
    }

    Status = RtlGetDaclSecurityDescriptor (
                    SecDesc,
                    &DaclPresent,
                    &DefaultDacl->DefaultDacl,
                    &DaclDefaulted
                    );
    ASSERT(NT_SUCCESS(Status));

    ASSERT(DaclPresent);

    if (SetTokenInfo(Token, TokenDefaultDacl, (PVOID)DefaultDacl)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    }

CleanupAndExit:

    if (Token != NULL) {
        CloseToken(Token);
    }
    if (DefaultDacl != NULL) {
        Free(DefaultDacl);
    }

    if (*StatusReturn != SED_STATUS_MODIFIED) {
        MessageBox(hwndParent, "Failed to set default DACL", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditDefaultAcl
*
* Purpose : Displays and allows the user to edit the default Acl on the
* passed token.
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Instance,
    HANDLE  MyToken
    )
{
    NTSTATUS Status;
    BOOL    Success = FALSE;
    DWORD   EditResult;
    HANDLE  Token = NULL;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PTOKEN_OWNER Owner = NULL;
    PTOKEN_PRIMARY_GROUP PrimaryGroup = NULL;
    WCHAR string[MAX_STRING_LENGTH];

    //
    // Get the window text so we can use it as the token name
    //

    GetWindowTextW(((PMYTOKEN)MyToken)->hwnd, string, sizeof(string)/sizeof(*string));


    //
    // Get a handle to the token
    //

    Token = OpenToken(MyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token with TOKEN_QUERY access\n");
        goto CleanupAndExit;
    }


    //
    // Read the default DACL from the token
    //

    if (!GetTokenInfo(Token, TokenDefaultDacl, (PPVOID)&DefaultDacl)) {
        DbgPrint("SECEDIT : Failed to read default DACL from token\n");
        goto CleanupAndExit;
    }


    //
    // Get the owner and group of the token
    //

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&Owner)) {
        DbgPrint("SECEDIT : Failed to read owner from token\n");
        goto CleanupAndExit;
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&PrimaryGroup)) {
        DbgPrint("SECEDIT : Failed to read primary group from token\n");
        goto CleanupAndExit;
    }




    //
    // Create a security descriptor
    //

    SecurityDescriptor = Alloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (SecurityDescriptor == NULL) {
        DbgPrint("SECEDIT : Failed to allocate security descriptor\n");
        goto CleanupAndExit;
    }

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(NT_SUCCESS(Status));




    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                        SecurityDescriptor,
                        TRUE,   // DACL present
                        DefaultDacl->DefaultDacl,
                        FALSE   // DACL defaulted
                        );
    ASSERT(NT_SUCCESS(Status));

    //
    // Put the owner and group in the security descriptor to keep the
    // ACL editor happy
    //

    Status = RtlSetOwnerSecurityDescriptor(
                        SecurityDescriptor,
                        Owner->Owner,
                        FALSE // Owner defaulted
                        );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlSetGroupSecurityDescriptor(
                        SecurityDescriptor,
                        PrimaryGroup->PrimaryGroup,
                        FALSE // Owner defaulted
                        );
    ASSERT(NT_SUCCESS(Status));



    ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));

    //
    // Call the ACL editor, it will call our ApplySecurity function
    // to store any ACL changes in the token.
    //

    Success = EditTokenDefaultAcl(
                        hwndOwner,
                        Instance,
                        string,
                        MyToken,
                        SecurityDescriptor,
                        &EditResult
                        );
    if (!Success) {
        DbgPrint("SECEDIT: Failed to edit token DACL\n");
    }

CleanupAndExit:

    if (DefaultDacl != NULL) {
        FreeTokenInfo(DefaultDacl);
    }
    if (SecurityDescriptor != NULL) {
        FreeTokenInfo(SecurityDescriptor);
    }
    if (PrimaryGroup != NULL) {
        FreeTokenInfo(PrimaryGroup);
    }
    if (Owner != NULL) {
        FreeTokenInfo(Owner);
    }

    if (Token != NULL) {
        CloseToken(Token);
    }


    return(Success);
}


/***************************************************************************\
* EditTokenDefaultAcl
*
* Purpose : Displays and allows the user to edit the default Acl on the
* passed token.
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditTokenDefaultAcl(
    HWND    Owner,
    HANDLE  Instance,
    LPWSTR  ObjectName,
    HANDLE  MyToken,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD   *EditResult
    )
{
    DWORD Result;
    SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc;
    GENERIC_MAPPING GenericMapping;
    SED_HELP_INFO sedhelpinfo ;
    SED_APPLICATION_ACCESSES SedAppAccesses ;
    SED_APPLICATION_ACCESS  SedAppAccess[20];
    ULONG i;

    //
    // Initialize the application accesses
    //

    i=0;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ASSIGN_PRIMARY;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Assign Primary";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_DUPLICATE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Duplicate";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_IMPERSONATE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Impersonate";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_QUERY;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Query";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_QUERY_SOURCE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Query source";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_PRIVILEGES;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Privileges";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_GROUPS;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Groups";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_DEFAULT;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Default";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       GENERIC_ALL;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"All Access";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       TOKEN_READ;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Read";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       TOKEN_WRITE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Write";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       0;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"None";
    i++;

    ASSERT((sizeof(SedAppAccess)/sizeof(*SedAppAccess)) >= i);


    SedAppAccesses.Count           = i;
    SedAppAccesses.AccessGroup     = SedAppAccess;
    SedAppAccesses.DefaultPermName = L"Read";


    //
    // Initialize generic mapping
    //

    GenericMapping.GenericRead    = TOKEN_READ;
    GenericMapping.GenericWrite   = TOKEN_WRITE;
    GenericMapping.GenericExecute = TOKEN_EXECUTE;
    GenericMapping.GenericAll     = TOKEN_ALL_ACCESS;

    //
    // Initialize help info
    //

    sedhelpinfo.pszHelpFileName = L"secedit.hlp";
    sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG] = 0 ;


    //
    // Initialize object description
    //

    sedobjdesc.Revision                    = SED_REVISION1;
    sedobjdesc.IsContainer                 = FALSE;
    sedobjdesc.AllowNewObjectPerms         = FALSE;
    sedobjdesc.MapSpecificPermsToGeneric   = FALSE;
    sedobjdesc.GenericMapping              = &GenericMapping;
    sedobjdesc.GenericMappingNewObjects    = &GenericMapping;
    sedobjdesc.HelpInfo                    = &sedhelpinfo;
    sedobjdesc.ObjectTypeName              = L"Token";
    sedobjdesc.ApplyToSubContainerTitle    = L"ApplyToSubContainerTitle";
    sedobjdesc.ApplyToSubContainerHelpText = L"ApplyToSubContainerHelpText";
    sedobjdesc.ApplyToSubContainerConfirmation = L"ApplyToSubContainerConfirmation";
    sedobjdesc.SpecialObjectAccessTitle    = L"Special...";
    sedobjdesc.SpecialNewObjectAccessTitle = L"SpecialNewObjectAccessTitle";


    //
    // Call the ACL editor, it will call our ApplySecurity function
    // to store any ACL changes in the token.
    //

    Result = SedDiscretionaryAclEditor(
                        Owner,
                        Instance,
                        NULL,               // server
                        &sedobjdesc,        // object type
                        &SedAppAccesses,    // application accesses
                        ObjectName,
                        ApplySecurity,      // Callback
                        (ULONG_PTR)MyToken,     // Context
                        SecurityDescriptor,
                        FALSE,              // Couldn't read DACL
                        EditResult
                        );

    if (Result != ERROR_SUCCESS) {
        DbgPrint("SECEDIT: Acleditor failed, error = %d\n", Result);
        SetLastError(Result);
    }

    return (Result == ERROR_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\acledit.h ===
BOOL
EditDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Instance,
    HANDLE  MyToken
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\lsa.h ===
BOOL    LsaInit(VOID);
BOOL    LsaTerminate(VOID);
BOOL    SID2Name(PSID, LPSTR, UINT);
BOOL    PRIV2Name(LUID, LPSTR, UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\window.cpp ===
/*****************************************************************************
 *
 *  window.cpp
 *
 *****************************************************************************/

#include "sdview.h"

LRESULT CALLBACK FrameWindow::WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    FrameWindow *self;

    if (uiMsg == WM_NCCREATE) {
        LPCREATESTRUCT lpcs = RECAST(LPCREATESTRUCT, lParam);
        self = RECAST(FrameWindow *, lpcs->lpCreateParams);
        self->_hwnd = hwnd;
        SetWindowLongPtr(self->_hwnd, GWLP_USERDATA, RECAST(LPARAM, self));
    } else {
        self = RECAST(FrameWindow *, GetWindowLongPtr(hwnd, GWLP_USERDATA));
    }

    if (self) {
        return self->HandleMessage(uiMsg, wParam, lParam);
    } else {
        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }
}

//
//  Default message handler.  Messages land here after passing through
//  all the derived classes.
//
LRESULT FrameWindow::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {

    case WM_NCDESTROY:
        _hwnd = NULL;
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        if (_hwndChild) {
            SetWindowPos(_hwndChild, NULL, 0, 0,
                         GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                         SWP_NOZORDER | SWP_NOACTIVATE);
        }
        return 0;

    case WM_SETFOCUS:
        if (_hwndChild) {
            SetFocus(_hwndChild);
        }
        return 0;

    case WM_CLOSE:
        if (GetKeyState(VK_SHIFT) < 0) {
            g_lThreads = 1;     // force app to exit
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDM_EXIT:
            DestroyWindow(_hwnd);
            break;

        case IDM_EXITALL:
            g_lThreads = 1;     // force app to exit
            DestroyWindow(_hwnd);
            break;
        }
        break;

    case WM_HELP:
        Help(_hwnd, NULL);
        break;
    }

    return DefWindowProc(_hwnd, uiMsg, wParam, lParam);

}

#define CLASSNAME TEXT("SD View")

HWND FrameWindow::CreateFrameWindow()
{
    WNDCLASS wc;
    if (!GetClassInfo(g_hinst, CLASSNAME, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hinst;
        wc.hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SDV));
        wc.hCursor = g_hcurArrow;
        wc.hbrBackground = RECAST(HBRUSH, COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = CLASSNAME;

        if (!RegisterClass(&wc)) {
            return NULL;
        }
    }

    _hwnd = CreateWindow(
            CLASSNAME,                      /* Class Name */
            NULL,                           /* Title */
            WS_CLIPCHILDREN | WS_VISIBLE |
            WS_OVERLAPPEDWINDOW,            /* Style */
            CW_USEDEFAULT, CW_USEDEFAULT,   /* Position */
            CW_USEDEFAULT, CW_USEDEFAULT,   /* Size */
            NULL,                           /* Parent */
            NULL,                           /* No menu */
            g_hinst,                        /* Instance */
            this);                          /* Special parameters */

    return _hwnd;
}


DWORD FrameWindow::RunThread(FrameWindow *self, LPVOID lpParameter)
{
    if (self) {
        self->_pszQuery = RECAST(LPTSTR, lpParameter);

        if (self->CreateFrameWindow()) {
            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0)) {
                if (self->_haccel && TranslateAccelerator(self->_hwnd, self->_haccel, &msg)) {
                } else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
        delete self;
    }

    if (lpParameter) {
        LocalFree(lpParameter);
    }

    return EndThreadTask(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\treelist.cpp ===
/*****************************************************************************
 *
 *  treelist.cpp
 *
 *      A tree-like listview.  (Worst of both worlds!)
 *
 *****************************************************************************/

//
//  state icon: Doesn't get ugly highlight when selected
//          but indent doesn't work unless there is a small imagelist
//
//  image: gets ugly highlight
//      but at least indent works

#include "sdview.h"

TreeItem *TreeItem::NextVisible()
{
    if (IsExpanded()) {
        return FirstChild();
    }

    TreeItem *pti = this;
    do {
        if (pti->NextSibling()) {
            return pti->NextSibling();
        }
        pti = pti->Parent();
    } while (pti);

    return NULL;
}

BOOL TreeItem::IsVisibleOrRoot()
{
    TreeItem *pti = Parent();

    while (pti) {
        ASSERT(pti->IsExpandable());
        if (!pti->IsExpanded())
        {
            return FALSE;
        }
        pti = pti->Parent();
    }

    // Made it all the way to the root without incident
    return TRUE;
}

BOOL TreeItem::IsVisible()
{
    TreeItem *pti = Parent();

    //
    //  The root itself is not visible.
    //
    if (!pti) {
        return FALSE;
    }

    return IsVisibleOrRoot();
}

Tree::Tree(TreeItem *ptiRoot)
    : _ptiRoot(ptiRoot)
    , _iHint(-1)
    , _ptiHint(ptiRoot)
{
    if (_ptiRoot) {
        _ptiRoot->_ptiChild = PTI_ONDEMAND;
        _ptiRoot->_iVisIndex = -1;
        _ptiRoot->_iDepth = -1;
    }
}

Tree::~Tree()
{
    DeleteNode(_ptiRoot);
}

void Tree::SetHWND(HWND hwnd)
{
    _hwnd = hwnd;
    SHFILEINFO sfi;
    HIMAGELIST himl = ImageList_LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_PLUS),
                                           16, 0, RGB(0xFF, 0x00, 0xFF));

    ListView_SetImageList(_hwnd, himl, LVSIL_STATE);
    ListView_SetCallbackMask(_hwnd, LVIS_STATEIMAGEMASK | LVIS_OVERLAYMASK);
}

HIMAGELIST Tree::SetImageList(HIMAGELIST himl)
{
    return RECAST(HIMAGELIST, ListView_SetImageList(_hwnd, himl, LVSIL_SMALL));
}

LRESULT Tree::SendNotify(int code, NMHDR *pnm)
{
    pnm->hwndFrom = _hwnd;
    pnm->code = code;
    pnm->idFrom = GetDlgCtrlID(_hwnd);
    return ::SendMessage(GetParent(_hwnd), WM_NOTIFY, pnm->idFrom, RECAST(LPARAM, pnm));
}


LRESULT Tree::OnCacheHint(NMLVCACHEHINT *phint)
{
    _ptiHint = IndexToItem(phint->iFrom);
    _iHint = phint->iFrom;
    return 0;
}

//
//  pti = the first item that needs to be recalced
//
void Tree::Recalc(TreeItem *pti)
{
    int iItem = pti->_iVisIndex;

    if (_iHint > iItem) {
        _iHint = iItem;
        _ptiHint = pti;
    }

    do {
        pti->_iVisIndex = iItem;
        pti = pti->NextVisible();
        iItem++;
    } while (pti);
}

TreeItem* Tree::IndexToItem(int iItem)
{
    int iHave;
    TreeItem *ptiHave;
    if (iItem >= _iHint && _ptiHint) {
        iHave = _iHint;
        ptiHave = _ptiHint;
        ASSERT(ptiHave->_iVisIndex == iHave);
    } else {
        iHave = -1;
        ptiHave = _ptiRoot;
    }

    while (iHave < iItem && ptiHave) {
        ASSERT(ptiHave->_iVisIndex == iHave);
        ptiHave = ptiHave->NextVisible();
        iHave++;
    }

    return ptiHave;
}

int Tree::InsertListviewItem(int iItem)
{
    LVITEM lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = 0;
    return ListView_InsertItem(_hwnd, &lvi);
}

BOOL Tree::Insert(TreeItem *pti, TreeItem *ptiParent, TreeItem *ptiAfter)
{
    pti->_ptiParent = ptiParent;

    TreeItem **pptiUpdate;

    // Convenience:  PTI_APPEND appends as last child
    if (ptiAfter == PTI_APPEND) {
        ptiAfter = ptiParent->FirstChild();
        if (ptiAfter == PTI_ONDEMAND) {
            ptiAfter = NULL;
        } else if (ptiAfter) {
            while (ptiAfter->NextSibling()) {
                ptiAfter = ptiAfter->NextSibling();
            }
        }
    }

    if (ptiAfter) {
        pti->_iVisIndex = ptiAfter->_iVisIndex + 1;
        pptiUpdate = &ptiAfter->_ptiNext;
    } else {
        pti->_iVisIndex = ptiParent->_iVisIndex + 1;
        pptiUpdate = &ptiParent->_ptiChild;
        if (ptiParent->_ptiChild == PTI_ONDEMAND) {
            ptiParent->_ptiChild = NULL;
        }
    }

    if (ptiParent->IsExpanded()) {
        if (InsertListviewItem(pti->_iVisIndex) < 0) {
            return FALSE;
        }
        ptiParent->_cVisKids++;
    }

    pti->_ptiNext = *pptiUpdate;
    *pptiUpdate = pti;
    pti->_iDepth = ptiParent->_iDepth + 1;

    if (ptiParent->IsExpanded()) {
        Recalc(pti);
    }

    return TRUE;
}

//
//  Update the visible kids count for pti and all its parents.
//  Sop when we find a node that is collapsed (which means
//  the visible kids counter is no longer being kept track of).
//

void Tree::UpdateVisibleCounts(TreeItem *pti, int cDelta)
{
    //
    //  Earlying-out the cDelta==0 case is a clear optimization,
    //  and it's actually important in the goofy scenario where
    //  an expand failed (so the item being updated isn't even
    //  expandable any more).
    //
    if (cDelta) {
        do {
            ASSERT(pti->IsExpandable());
            pti->_cVisKids += cDelta;
            pti = pti->Parent();
        } while (pti && pti->IsExpanded());
    }
}

int Tree::Expand(TreeItem *ptiRoot)
{
    if (ptiRoot->IsExpanded()) {
        return 0;
    }

    if (!ptiRoot->IsExpandable()) {
        return 0;
    }

    if (ptiRoot->FirstChild() == PTI_ONDEMAND) {
        NMTREELIST tl;
        tl.pti = ptiRoot;
        SendNotify(TLN_FILLCHILDREN, &tl.hdr);

        //
        //  If the callback failed to insert any items, then turn the
        //  entry into an unexpandable item.  (We need to redraw it
        //  so the new button shows up.)
        //
        if (ptiRoot->FirstChild() == PTI_ONDEMAND) {
            ptiRoot->SetNotExpandable();
        }
    }

    BOOL fRootVisible = ptiRoot->IsVisibleOrRoot();

    TreeItem *pti = ptiRoot->FirstChild();
    int iNewIndex = ptiRoot->_iVisIndex + 1;
    int cExpanded = 0;

    while (pti) {
        cExpanded += 1 + pti->_cVisKids;
        if (fRootVisible) {
            // Start at -1 so we also include the item itself
            for (int i = -1; i < pti->_cVisKids; i++) {
                InsertListviewItem(iNewIndex);
                iNewIndex++;
            }
        }
        pti = pti->NextSibling();
    }

    UpdateVisibleCounts(ptiRoot, cExpanded);

    if (fRootVisible) {
        Recalc(ptiRoot);

        // Also need to redraw the root item because its button changed
        ListView_RedrawItems(_hwnd, ptiRoot->_iVisIndex, ptiRoot->_iVisIndex);
    }

    return cExpanded;
}

int Tree::Collapse(TreeItem *ptiRoot)
{
    if (!ptiRoot->IsExpanded()) {
        return 0;
    }

    if (!ptiRoot->IsExpandable()) {
        return 0;
    }

    TreeItem *pti = ptiRoot->FirstChild();
    int iDelIndex = ptiRoot->_iVisIndex + 1;
    int cCollapsed = 0;
    BOOL fRootVisible = ptiRoot->IsVisibleOrRoot();

    //
    //  HACKHACK for some reason, listview in ownerdata mode animates
    //  deletes but not insertions.  What's worse, the deletion animation
    //  occurs even if the item being deleted isn't even visible (because
    //  we deleted a screenful of items ahead of it).  So let's just disable
    //  redraws while doing collapses.
    //
    if (fRootVisible) {
        SetWindowRedraw(_hwnd, FALSE);
    }

    while (pti) {
        cCollapsed += 1 + pti->_cVisKids;
        if (fRootVisible) {
            // Start at -1 so we also include the item itself
            for (int i = -1; i < pti->_cVisKids; i++) {
                ListView_DeleteItem(_hwnd, iDelIndex);
            }
        }
        pti = pti->NextSibling();
    }

    UpdateVisibleCounts(ptiRoot, -cCollapsed);

    if (fRootVisible) {
        Recalc(ptiRoot);

        // Also need to redraw the root item because its button changed
        ListView_RedrawItems(_hwnd, ptiRoot->_iVisIndex, ptiRoot->_iVisIndex);

        SetWindowRedraw(_hwnd, TRUE);
    }

    return cCollapsed;
}

int Tree::ToggleExpand(TreeItem *pti)
{
    if (pti->IsExpandable()) {
        if (pti->IsExpanded()) {
            return -Collapse(pti);
        } else {
            return Expand(pti);
        }
    }
    return 0;
}

void Tree::RedrawItem(TreeItem *pti)
{
    if (pti->IsVisible()) {
        ListView_RedrawItems(_hwnd, pti->_iVisIndex, pti->_iVisIndex);
    }
}


LRESULT Tree::OnClick(NMITEMACTIVATE *pia)
{
    if (pia->iSubItem == 0) {
        // Maybe it was a click on the +/- button
        LVHITTESTINFO hti;
        hti.pt = pia->ptAction;
        ListView_HitTest(_hwnd, &hti);
        if (hti.flags & (LVHT_ONITEMICON | LVHT_ONITEMSTATEICON)) {
            TreeItem *pti = IndexToItem(pia->iItem);
            if (pti) {
                ToggleExpand(pti);
            }
        }

    }
    return 0;
}

LRESULT Tree::OnItemActivate(int iItem)
{
    NMTREELIST tl;
    tl.pti = IndexToItem(iItem);
    if (tl.pti) {
        SendNotify(TLN_ITEMACTIVATE, &tl.hdr);
    }
    return 0;
}

//
//  Classic treeview keys:
//
//  Ctrl+(Left, Right, PgUp, Home, PgDn, End, Up, Down) = scroll the
//  window without changing selection.
//
//  Enter = activate
//  PgUp, PgDn, Home, End = navigate
//  Numpad+, Numpad- = expand/collapse
//  Numpad* = expand all
//  Left = collapse focus item or move to parent
//  Right = expand focus item or move down
//  Backspace = move to parent
//
//  We don't mimic it perfectly, but we get close enough that hopefully
//  nobody will notice.
//
LRESULT Tree::OnKeyDown(NMLVKEYDOWN *pkd)
{
    if (GetKeyState(VK_CONTROL) < 0) {
        // Allow key to go through - listview will do the work
    } else {
        TreeItem *pti;
        switch (pkd->wVKey) {

        case VK_ADD:
            pti = GetCurSel();
            if (pti) {
                Expand(pti);
            }
            return 1;

        case VK_SUBTRACT:
            pti = GetCurSel();
            if (pti) {
                Collapse(pti);
            }
            return 1;

        case VK_LEFT:
            pti = GetCurSel();
            if (pti) {
                if (pti->IsExpanded()) {
                    Collapse(pti);
                } else {
                    SetCurSel(pti->Parent());
                }
            }
            return 1;

        case VK_BACK:
            pti = GetCurSel();
            if (pti) {
                SetCurSel(pti->Parent());
            }
            return 1;

        case VK_RIGHT:
            pti = GetCurSel();
            if (pti) {
                if (!Expand(pti)) {
                    pti = pti->NextVisible();
                    if (pti) {
                        SetCurSel(pti);
                    }
                }
            }
            return 1;
        }
    }
    return 0;
}

//
//  Convert the item number into a tree item.
//
LRESULT Tree::OnGetDispInfo(NMLVDISPINFO *plvd)
{
    TreeItem *pti = IndexToItem(plvd->item.iItem);
    ASSERT(pti);
    if (!pti) {
        return 0;
    }

    if (plvd->item.mask & LVIF_STATE) {
        if (pti->IsExpandable()) {
            // State images are 1-based
            plvd->item.state |= INDEXTOSTATEIMAGEMASK(pti->IsExpanded() ? 1 : 2);
        }
    }

    if (plvd->item.mask & LVIF_INDENT) {
        plvd->item.iIndent = pti->_iDepth;
    }

    NMTREELIST tl;
    tl.pti = pti;

    if (plvd->item.mask & (LVIF_IMAGE | LVIF_STATE)) {
        tl.iSubItem = -1;
        tl.cchTextMax = 0;
        SendNotify(TLN_GETDISPINFO, &tl.hdr);
        plvd->item.iImage = tl.iSubItem;
        if (plvd->item.stateMask & LVIS_OVERLAYMASK) {
            plvd->item.state |= tl.cchTextMax;
        }

    }

    if (plvd->item.mask & LVIF_TEXT) {
        tl.iSubItem = plvd->item.iSubItem;
        tl.pszText = plvd->item.pszText;
        tl.cchTextMax = plvd->item.cchTextMax;

        SendNotify(TLN_GETDISPINFO, &tl.hdr);

        plvd->item.pszText = tl.pszText;
    }

    return 0;
}

LRESULT Tree::OnGetInfoTip(NMLVGETINFOTIP *pgit)
{
    TreeItem *pti = IndexToItem(pgit->iItem);
    ASSERT(pti);
    if (pti) {
        NMTREELIST tl;
        tl.pti = pti;
        tl.pszText = pgit->pszText;
        tl.cchTextMax = pgit->cchTextMax;

        SendNotify(TLN_GETINFOTIP, &tl.hdr);

        pgit->pszText = tl.pszText;
    }

    return 0;
}

LRESULT Tree::OnGetContextMenu(int iItem)
{
    TreeItem *pti = IndexToItem(iItem);
    ASSERT(pti);
    if (pti) {
        NMTREELIST tl;
        tl.pti = pti;
        return SendNotify(TLN_GETCONTEXTMENU, &tl.hdr);
    }
    return 0;
}

LRESULT Tree::OnCopyToClipboard(int iMin, int iMax)
{
    TreeItem *pti = IndexToItem(iMin);
    ASSERT(pti);
    if (pti) {
        TreeItem *ptiMax = IndexToItem(iMax);
        String str;
        while (pti != ptiMax) {
            NMTREELIST tl;
            tl.pti = pti;
            tl.pszText = NULL;
            tl.cchTextMax = 0;
            SendNotify(TLN_GETINFOTIP, &tl.hdr);
            if (tl.pszText) {
                str << tl.pszText << TEXT("\r\n");
            }
            pti = pti->NextVisible();
        }
        SetClipboardText(_hwnd, str);
    }
    return 0;
}

TreeItem *Tree::GetCurSel()
{
    int iItem = ListView_GetCurSel(_hwnd);
    if (iItem >= 0) {
        return IndexToItem(iItem);
    }
    return NULL;
}

void Tree::SetCurSel(TreeItem *pti)
{
    if (pti->IsVisible()) {
        ListView_SetCurSel(_hwnd, pti->_iVisIndex);
        ListView_EnsureVisible(_hwnd, pti->_iVisIndex, FALSE);
    }
}

void Tree::DeleteNode(TreeItem *pti)
{
    if (pti) {

        // Nuke all the kids, recursively
        TreeItem *ptiKid = pti->FirstChild();
        if (!ptiKid->IsSentinel()) {
            do {
                TreeItem *ptiNext = ptiKid->NextSibling();
                DeleteNode(ptiKid);
                ptiKid = ptiNext;
            } while (ptiKid);
        }

        // This is moved to a subroutine so we don't eat stack
        // in this highly-recursive function.
        SendDeleteNotify(pti);
    }
}

void Tree::SendDeleteNotify(TreeItem *pti)
{
    NMTREELIST tl;
    tl.pti = pti;
    SendNotify(TLN_DELETEITEM, &tl.hdr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\dlg.h ===
#define IDD_MAIN                    100
#define IDS_USERID                  102
#define IDS_LOGONSESSION            104
#define IDC_DEFAULTOWNER            106
#define IDL_DISABLEDGROUPS          111
#define IDB_DISABLEPRIVILEGE        112
#define IDB_ENABLEPRIVILEGE         113
#define IDL_ENABLEDPRIVILEGES       117
#define IDL_DISABLEDPRIVILEGES      118
#define IDL_ENABLEDGROUPS           123
#define IDB_DISABLEGROUP            124
#define IDB_ENABLEGROUP             125
#define IDC_PRIMARYGROUP            126
#define IDB_MORE                    110
#define IDS_TOKENID                 208
#define IDS_EXPIRATIONTIME          209
#define IDS_TOKENTYPE               210
#define IDS_IMPERSONATION           211
#define IDS_DYNAMICCHARGED          212
#define IDS_DYNAMICAVAILABLE        213
#define IDS_MODIFIEDID              214
#define IDD_MORE                    101
#define IDD_WINDOWLIST              220
#define IDLB_WINDOWLIST             222
#define IDD_ABOUT                   4000
#define IDD_ACTIVEWINDOW            4500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by secedit.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "SECEDIT.h"
#include <string.h>


// Module global that holds handle to LSA once it has been opened.
static LSA_HANDLE  LsaHandle = NULL;

LSA_HANDLE OpenLsa(VOID);
VOID    CloseLsa(LSA_HANDLE);


/****************************************************************************

   FUNCTION: LsaInit

   PURPOSE:  Does any initialization required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaInit(VOID)
{

#ifdef LSA_AVAILABLE
    LsaHandle = OpenLsa();

    return (LsaHandle != NULL);
#endif

    return (TRUE);
}


/****************************************************************************

   FUNCTION: LsaTerminate

   PURPOSE:  Does any cleanup required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaTerminate(VOID)
{

#ifdef LSA_AVAILABLE
    if (LsaHandle != NULL) {
        CloseLsa(LsaHandle);
    }
#endif

    LsaHandle = NULL;

    return(TRUE);
}


#ifdef LSA_AVAILABLE
/****************************************************************************

   FUNCTION: OpenLsa

   PURPOSE:  Opens the Lsa
             Returns handle to Lsa or NULL on failure

****************************************************************************/
LSA_HANDLE OpenLsa(VOID)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ConnectHandle = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open a handle to the LSA.  Specifying NULL for the Server means that the
    // server is the same as the client.
    //

    Status = LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &ConnectHandle
                        );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Open failed 0x%lx\n", Status);
        return NULL;
    }

    return(ConnectHandle);
}


/****************************************************************************

    FUNCTION: CloseLsa

    PURPOSE:  Closes the Lsa

****************************************************************************/
VOID CloseLsa(
    LSA_HANDLE LsaHandle)
{
    NTSTATUS Status;

    Status = LsaClose(LsaHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Close failed 0x%lx\n", Status);
    }

    return;
}
#endif


#ifdef LSA_AVAILABLE
/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    NTSTATUS    Status;
    ANSI_STRING    AnsiName;
    PLSA_REFERENCED_DOMAIN_LIST DomainList;
    PLSA_TRANSLATED_NAME NameList;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }



    Status = LsaLookupSids(LsaHandle, 1, &Sid, &DomainList, &NameList);

    if (NT_SUCCESS(Status)) {

        // Convert to ansi string
        RtlUnicodeStringToAnsiString(&AnsiName, &NameList->Name, TRUE);

        // Free up the returned data
        LsaFreeMemory((PVOID)DomainList);
        LsaFreeMemory((PVOID)NameList);

        // Copy the ansi string into our local variable
        strncpy(String, AnsiName.Buffer, MaxStringBytes);

        // Free up the ansi string
        RtlFreeAnsiString(&AnsiName);

        return(TRUE);
    }

    return(FALSE);
}

#else

#include "..\..\..\inc\seopaque.h"

/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    UCHAR   Buffer[128];
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;  // pointer to opaque structure

    PSID    NextSid = (PSID)Alloc(RtlLengthRequiredSid(1));


    NTSTATUS       Status;
    ANSI_STRING    AnsiName;

    if (NextSid == NULL) {
        DbgPrint("SECEDIT: SID2Name failed to allocate space for SID\n");
        return(FALSE);
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_WORLD_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "World");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Local");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_CREATOR_OWNER_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Creator");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_DIALUP_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Dialup");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_NETWORK_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Network");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_BATCH_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Batch");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_INTERACTIVE_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Interactive");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }


    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Local System");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }



    Free((PVOID)NextSid);


    wsprintf(Buffer, "S-%u-", (USHORT)iSid->Revision );
    lstrcpy(String, Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        wsprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        lstrcat(String, Buffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, "%lu", Tmp);
        lstrcat(String, Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, "-%lu", iSid->SubAuthority[i]);
        lstrcat(String, Buffer);
    }

    return(TRUE);
}
#endif


/****************************************************************************

   FUNCTION: PRIV2Name

   PURPOSE: Converts a PRIVILEGE into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL PRIV2Name(
    LUID    Privilege,
    LPSTR   lpstr,
    UINT    MaxStringBytes)
{
    NTSTATUS        Status;
    STRING          String;
    PUNICODE_STRING UString;

    LSA_HANDLE  PolicyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;



    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL);
    Status = LsaOpenPolicy( NULL, &ObjectAttributes, POLICY_LOOKUP_NAMES, &PolicyHandle);
    Status = LsaLookupPrivilegeName(PolicyHandle, &Privilege, &UString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: LsaLookupPrivilegeName failed, status = 0x%lx\n", Status);
        strcpy(lpstr, "<Unknown>");
    } else {

        //
        // Convert it to ANSI - because that's what the rest of the app is.
        //

        if (UString->Length > (USHORT)MaxStringBytes) {
            DbgPrint("SECEDIT: Truncating returned privilege name: *%Z*\n", UString);
            UString->Length = (USHORT)MaxStringBytes;
            DbgPrint("                                         To: *%Z*\n", UString);
        }

        String.Length = 0;
        String.MaximumLength = (USHORT)MaxStringBytes;
        String.Buffer = lpstr;
        Status = RtlUnicodeStringToAnsiString( &String, UString, FALSE );
        ASSERT(NT_SUCCESS(Status));
        LsaFreeMemory( UString );

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\secedit.h ===
#ifdef WIN32
#define LSA_AVAILABLE
#define NTBUILD
#endif

#ifndef RC_INVOKED
#ifdef NTBUILD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#endif

#include <windows.h>

#ifndef RC_INVOKED
#include <ntlsa.h>
#include <port1632.h>

#include "..\global.h"
#endif

#include "dlg.h"

typedef PVOID   *PPVOID;

// Resource ids
#define IDM_MAINMENU                    3000
#define IDM_ABOUT                       3001
#define IDM_PROGRAMMANAGER              3002
#define IDM_WINDOWLIST                  3003
#define IDM_ACTIVEWINDOW                3004
#define IDI_APPICON                     3005

// Define the maximum length of a resource string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        (MAX_STRING_LENGTH + 1)

#ifndef RC_INVOKED
#include "token.h"
#include "util.h"
#include "lsa.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\token.h ===
typedef struct {
    DWORD                   ProcessId;
    DWORD                   ThreadId;
    PTOKEN_USER             UserId;
    PTOKEN_GROUPS           Groups;
    PTOKEN_OWNER            DefaultOwner;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup;
    PTOKEN_PRIVILEGES       Privileges;
    PTOKEN_STATISTICS       TokenStats;

} MYTOKEN;
typedef MYTOKEN *PMYTOKEN;

HANDLE  OpenMyToken(HWND);
BOOL    CloseMyToken(HWND, HANDLE, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\util.h ===
PVOID   Alloc(SIZE_T);
SIZE_T  GetAllocSize(PVOID);
BOOL    Free(PVOID);

BOOL    LUID2String(LUID, LPSTR, UINT);
BOOL    Time2String(TIME, LPSTR, UINT);
BOOL    TokenType2String(TOKEN_TYPE, LPSTR, UINT);
BOOL    ImpersonationLevel2String(SECURITY_IMPERSONATION_LEVEL, LPSTR, UINT);
BOOL    Dynamic2String(ULONG, LPSTR, UINT);
INT     AddItem(HWND, INT, LPSTR, LONG_PTR, BOOL);
INT     FindSid(HWND, INT, PSID, BOOL);
BOOL    SetHooks(HWND);
BOOL    ReleaseHooks(HWND);

// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define FindLBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, FALSE))

#define FindCBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\secedit.c ===
/****************************************************************************

   PROGRAM: SECEDIT.C

   PURPOSE: Displays the usrs current token and eventually allows the user
            to edit parts of it.

****************************************************************************/


#include "SECEDIT.h"
#include "string.h"

static char pszMainWindowClass[] = "Main Window Class";

HANDLE hInst;

// Global used to store handle to MYTOKEN
HANDLE  hMyToken;



BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, INT);
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL    EditWindowContext(HWND, HWND);
INT_PTR APIENTRY MainDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY MoreDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ListDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ActiveWindowDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    MainDlgInit(HWND, LPARAM);
BOOL    MainDlgEnd(HWND, BOOL);
BOOL    EnablePrivilege(HWND, BOOL);
BOOL    EnableGroup(HWND, BOOL);
BOOL    SetDefaultOwner(HWND);
BOOL    SetPrimaryGroup(HWND);
BOOL    MoreDlgInit(HWND hDlg);
BOOL    DisplayMyToken(HWND, HANDLE);
BOOL    ListDlgInit(HWND);
BOOL    APIENTRY WindowEnum(HWND, LPARAM);
HWND    ListDlgEnd(HWND);



/****************************************************************************

   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

   PURPOSE: calls initialization function, processes message loop

****************************************************************************/

INT
__stdcall
WinMain(
       HINSTANCE hInstance,
       HINSTANCE hPrevInstance,
       LPSTR lpCmdLine,
       INT nCmdShow
       )
{
    MSG Message;

    if (!hPrevInstance) {
        if (!InitApplication(hInstance)) {
            DbgPrint("SECEDIT - InitApplication failed\n");
            return (FALSE);
        }
    }

    if (!InitInstance(hInstance, nCmdShow)) {
        DbgPrint("SECEDIT - InitInstance failed\n");
        return (FALSE);
    }

    while (GetMessage(&Message, NULL, 0, 0)) {
        TranslateMessage(&Message);
        DispatchMessage(&Message);
    }

    return ((int)Message.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL
InitApplication(
               HANDLE hInstance
               )
{
    WNDCLASS  wc;
    NTSTATUS  Status;


    // Register the main window class

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  (LPSTR)IDM_MAINMENU;
    wc.lpszClassName = pszMainWindowClass;

    return (RegisterClass(&wc));
}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL
InitInstance(
            HANDLE hInstance,
            INT nCmdShow
            )
{
    HWND    hwnd;

    // Store instance in global
    hInst = hInstance;

    // Create the main window
    hwnd = CreateWindow(
                       pszMainWindowClass,
                       "Security Context Editor",
                       WS_OVERLAPPEDWINDOW,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       NULL,
                       NULL,
                       hInstance,
                       NULL);

    if (hwnd == NULL) {
        return(FALSE);
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    return (TRUE);
}


/****************************************************************************

    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LONG)

    PURPOSE:  Processes messages for main window

    COMMENTS:

****************************************************************************/

LRESULT
APIENTRY
MainWndProc(
           HWND hwnd,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND    hwndEdit;
    WNDPROC lpProc;

    switch (message) {

        case WM_CREATE:
            SetHooks(hwnd);
            return(0); // Continue creating window
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {

                case IDM_PROGRAMMANAGER:

                    hwndEdit = FindWindow(NULL, "Program Manager");
                    if (hwndEdit == NULL) {
                        DbgPrint("SECEDIT : Failed to find program manager window\n");
                        break;
                    }

                    EditWindowContext(hwnd, hwndEdit);
                    break;

                case IDM_WINDOWLIST:

                    lpProc = (WNDPROC)MakeProcInstance(ListDlgProc, hInst);
                    hwndEdit = (HWND)DialogBox(hInst,(LPSTR)IDD_WINDOWLIST, hwnd, lpProc);
                    FreeProcInstance(lpProc);

                    EditWindowContext(hwnd, hwndEdit);
                    break;

                case IDM_ACTIVEWINDOW:

                    lpProc = (WNDPROC)MakeProcInstance(ActiveWindowDlgProc, hInst);
                    hwndEdit = (HWND)DialogBox(hInst,(LPSTR)IDD_ACTIVEWINDOW, hwnd, lpProc);
                    FreeProcInstance(lpProc);
                    break;

                case IDM_ABOUT:

                    lpProc = (WNDPROC)MakeProcInstance(AboutDlgProc, hInst);
                    DialogBox(hInst,(LPSTR)IDD_ABOUT, hwnd, lpProc);
                    FreeProcInstance(lpProc);
                    break;

                default:
                    break;
            }
            break;

        case WM_SECEDITNOTIFY:
            // Our hook proc posted us a message
            SetForegroundWindow(hwnd);
            EditWindowContext(hwnd, (HWND)wParam);
            break;

        case WM_DESTROY:
            ReleaseHooks(hwnd);
            PostQuitMessage(0);
            break;

        default:
            return(DefWindowProc(hwnd, message, wParam, lParam));

    }

    return 0;
}


/****************************************************************************

    FUNCTION: EditWindowContext

    PURPOSE:  Displays and allows the user to edit the security context
              of the specified window.

              Currently this means editting the security context of the
              process that owns this window

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/

BOOL
EditWindowContext(
                 HWND hwndParent,
                 HWND hwndEdit
                 )
{
    WNDPROC lpProc;

    if (hwndEdit == NULL) {
        DbgPrint("SECEDIT : hwndEdit = NULL\n");
        return(FALSE);
    }

    lpProc = (WNDPROC)MakeProcInstance(MainDlgProc, hInst);
    DialogBoxParam(hInst,(LPSTR)IDD_MAIN, hwndParent, lpProc, (LONG_PTR)hwndEdit);
    FreeProcInstance(lpProc);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MainDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    WM_COMMAND     - application menu (About dialog box)
    WM_DESTROY     - destroy window

    COMMENTS:

****************************************************************************/

INT_PTR
APIENTRY
MainDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    WNDPROC lpProc;

    switch (message) {

        case WM_INITDIALOG:

            if (!MainDlgInit(hDlg, lParam)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    // we're done, drop through to quit dialog....

                case IDCANCEL:

                    MainDlgEnd(hDlg, LOWORD(wParam) == IDOK);

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                case IDB_DISABLEPRIVILEGE:
                case IDB_ENABLEPRIVILEGE:
                    EnablePrivilege(hDlg, LOWORD(wParam) == IDB_ENABLEPRIVILEGE);
                    return(TRUE);
                    break;

                case IDB_DISABLEGROUP:
                case IDB_ENABLEGROUP:
                    EnableGroup(hDlg, LOWORD(wParam) == IDB_ENABLEGROUP);
                    return(TRUE);
                    break;

                case IDC_DEFAULTOWNER:
                    SetDefaultOwner(hDlg);
                    return(TRUE);

                case IDC_PRIMARYGROUP:
                    SetPrimaryGroup(hDlg);
                    return(TRUE);

                case IDB_MORE:

                    lpProc = (WNDPROC)MakeProcInstance(MoreDlgProc, hInst);
                    DialogBox(hInst,(LPSTR)IDD_MORE, hDlg, lpProc);
                    FreeProcInstance(lpProc);
                    return(TRUE);

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

#ifdef NTBUILD
    DBG_UNREFERENCED_PARAMETER(lParam);
#endif
}


/****************************************************************************

    FUNCTION: MainDlgInit(HWND)

    PURPOSE:  Initialises the controls in the main dialog window.

    RETURNS:   TRUE on success, FALSE if dialog should be terminated.

****************************************************************************/
BOOL
MainDlgInit(
           HWND    hDlg,
           LPARAM  lParam
           )
{
    HWND        hwnd = (HWND)lParam;
    CHAR        string[MAX_STRING_BYTES];
    INT         length;

    // Since we use a global to store the pointer to our MYTOKEN
    // structure, check we don't get called again before we have
    // quit out of the last dialog.
    if (hMyToken != NULL) {
        DbgPrint("SECEDIT: Already editting a context\n");
        return(FALSE);
    }

    if (hwnd == NULL) {
        DbgPrint("SECEDIT: Window handle is NULL\n");
        return(FALSE);
    }

    if (!LsaInit()) {
        DbgPrint("SECEDIT - LsaInit failed\n");
        return(FALSE);
    }

    hMyToken = OpenMyToken(hwnd);
    if (hMyToken == NULL) {
        DbgPrint("SECEDIT: Failed to open mytoken\n");

        strcpy(string, "Unable to access security context for\n<");
        length = strlen(string);
        GetWindowText(hwnd, &(string[length]), MAX_STRING_BYTES - length);
        strcat(string, ">");
        MessageBox(hDlg, string, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

        LsaTerminate();
        return(FALSE);
    }

    DisplayMyToken(hDlg, hMyToken);

    // Set the dialog caption appropriately
    GetWindowText(hDlg, string, MAX_STRING_BYTES);
    strcat(string, " for <");
    length = strlen(string);
    GetWindowText(hwnd, &string[length], MAX_STRING_BYTES - length);
    strcat(string, ">");
    SetWindowText(hDlg, string);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MainDlgEnd(HWND)

    PURPOSE:  Do whatever we have to do to clean up when dialog ends

    RETURNS:  TRUE on success, FALSE on failure.

****************************************************************************/
BOOL
MainDlgEnd(
          HWND    hDlg,
          BOOL    fSaveChanges
          )
{
    BOOL Success;

    LsaTerminate();

    Success = CloseMyToken(hDlg, hMyToken, fSaveChanges);

    hMyToken = NULL;

    return(Success);
}


/****************************************************************************

    FUNCTION: DisplayMyToken

    PURPOSE:  Reads data out of mytoken and puts in dialog controls.

    RETURNS:   TRUE on success, FALSE on failure

****************************************************************************/
BOOL
DisplayMyToken(
              HWND    hDlg,
              HANDLE  hMyToken
              )
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    CHAR        string[MAX_STRING_BYTES];
    UINT        GroupIndex;
    UINT        PrivIndex;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    //
    // Authentication ID
    //
    if (pMyToken->TokenStats != NULL) {

        wsprintf(string, "0x%lx-%lx",
                 pMyToken->TokenStats->AuthenticationId.HighPart,
                 pMyToken->TokenStats->AuthenticationId.LowPart);

        SetDlgItemText(hDlg, IDS_LOGONSESSION, string);

    } else {
        DbgPrint("SECEDIT : No token statistics in mytoken\n");
    }

    //
    // Groups
    //
    if (pMyToken->Groups != NULL) {

        for (GroupIndex=0; GroupIndex < pMyToken->Groups->GroupCount; GroupIndex++ ) {

            PSID Sid = pMyToken->Groups->Groups[GroupIndex].Sid;
            ULONG Attributes = pMyToken->Groups->Groups[GroupIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_GROUP_ENABLED) {
                ControlID = IDL_ENABLEDGROUPS;
            } else {
                ControlID = IDL_DISABLEDGROUPS;
            }

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, ControlID, string, GroupIndex);

                // Add this group to default owner combo box if it's valid
                if (Attributes & SE_GROUP_OWNER) {
                    AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LONG_PTR)Sid);
                }

                // Add this group to primary group combo box
                AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);

            } else {
                DbgPrint("SECEDIT: Failed to convert Group sid to string\n");
            }
        }
    } else {
        DbgPrint("SECEDIT : No group info in mytoken\n");
    }


    //
    // User ID
    //
    if (pMyToken->UserId != NULL) {

        PSID    Sid = pMyToken->UserId->User.Sid;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            // Set user-name static text
            SetDlgItemText(hDlg, IDS_USERID, string);

            // Add to default owner combo box
            AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LONG_PTR)Sid);

            // Add to primary group combo box
            AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);

        } else {
            DbgPrint("SECEDIT: Failed to convert User ID SID to string\n");
        }

    } else {
        DbgPrint("SECEDIT: No user id in mytoken\n");
    }


    //
    // Default Owner
    //
    if (pMyToken->DefaultOwner != NULL) {

        PSID    Sid = pMyToken->DefaultOwner->Owner;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_DEFAULTOWNER, Sid);

            if (iItem >= 0) {
                SendMessage(GetDlgItem(hDlg, IDC_DEFAULTOWNER), CB_SETCURSEL, iItem, 0);
            } else {
                DbgPrint("SECEDIT: Default Owner is not userID or one of our groups\n");
            }

        } else {
            DbgPrint("SECEDIT: Failed to convert Default Owner SID to string\n");
        }
    } else {
        DbgPrint("SECEDIT: No default owner in mytoken\n");
    }


    //
    // Primary group
    //

    if (pMyToken->PrimaryGroup != NULL) {

        PSID    Sid = pMyToken->PrimaryGroup->PrimaryGroup;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {
            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_PRIMARYGROUP, Sid);

            if (iItem < 0) {
                // Group is not already in combo-box, add it
                iItem = AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);
            }

            // Select the primary group
            SendMessage(GetDlgItem(hDlg, IDC_PRIMARYGROUP), CB_SETCURSEL, iItem, 0);

        } else {
            DbgPrint("SECEDIT: Failed to convert primary group SID to string\n");
        }
    } else {
        DbgPrint("SECEDIT: No primary group in mytoken\n");
    }


    //
    // Privileges
    //

    if (pMyToken->Privileges != NULL) {

        for (PrivIndex=0; PrivIndex < pMyToken->Privileges->PrivilegeCount; PrivIndex++ ) {

            LUID Privilege = pMyToken->Privileges->Privileges[PrivIndex].Luid;
            ULONG Attributes = pMyToken->Privileges->Privileges[PrivIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_PRIVILEGE_ENABLED) {
                ControlID = IDL_ENABLEDPRIVILEGES;
            } else {
                ControlID = IDL_DISABLEDPRIVILEGES;
            }

            if (PRIV2Name(Privilege, string, MAX_STRING_BYTES)) {

                // Add this privelege to the appropriate list-box
                AddLBItem(hDlg, ControlID, string, PrivIndex);

            } else {
                DbgPrint("SECEDIT: Failed to convert privilege to string\n");
            }
        }
    } else {
        DbgPrint("SECEDIT: No privelege info in mytoken\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnablePrivilege(HWND, fEnable)

    PURPOSE:  Enables or disables one or more privileges.
              If fEnable = TRUE, the selected privileges in the disabled
              privilege control are enabled.
              Vice versa for fEnable = FALSE

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL
EnablePrivilege(
               HWND    hDlg,
               BOOL    fEnable
               )
{
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_PRIVILEGES Privileges;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Privileges = pMyToken->Privileges;
    if (Privileges == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDPRIVILEGES;
        idTo   = IDL_ENABLEDPRIVILEGES;
    } else {
        idFrom = IDL_ENABLEDPRIVILEGES;
        idTo   = IDL_DISABLEDPRIVILEGES;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);


    // Find how many items are selected
    //
    cItems = (int)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems =  (int)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    PrivIndex;
        UCHAR   PrivilegeName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        PrivIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)PrivilegeName);


        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add privilege to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)PrivilegeName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)PrivIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Privileges->Privileges[PrivIndex].Attributes |= SE_PRIVILEGE_ENABLED;
        } else {
            Privileges->Privileges[PrivIndex].Attributes &= ~SE_PRIVILEGE_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnableGroup(HWND, fEnable)

    PURPOSE:  Enables or disables one or more selected groups.
              If fEnable = TRUE, the selected groups in the disabled
              group control are enabled.
              If fEnable = FALSE the selected groups in the enabled
              group control are disabled.

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL
EnableGroup(
           HWND    hDlg,
           BOOL    fEnable
           )
{
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_GROUPS Groups;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Groups = pMyToken->Groups;
    if (Groups == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDGROUPS;
        idTo   = IDL_ENABLEDGROUPS;
    } else {
        idFrom = IDL_ENABLEDGROUPS;
        idTo   = IDL_DISABLEDGROUPS;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);

    // Find how many items are selected
    //
    cItems = (int)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems =  (int)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    GroupIndex;
        UCHAR   GroupName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        GroupIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)GroupName);

        // Check it's not a mandatory group (Can-not be disabled)
        //
        if (Groups->Groups[GroupIndex].Attributes & SE_GROUP_MANDATORY) {
            CHAR    buf[256];
            strcpy(buf, "'");
            strcat(buf, GroupName);
            strcat(buf, "' is a mandatory group and cannot be disabled");
            MessageBox(hDlg, buf, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            continue;   // skip to next group
        }

        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add item to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)GroupName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)GroupIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Groups->Groups[GroupIndex].Attributes |= SE_GROUP_ENABLED;
        } else {
            Groups->Groups[GroupIndex].Attributes &= ~SE_GROUP_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetDefaultOwner()

    PURPOSE:  Sets the default owner to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
SetDefaultOwner(
               HWND    hDlg
               )
{
    HWND    hwnd;
    INT     iItem;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_OWNER DefaultOwner;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    DefaultOwner = pMyToken->DefaultOwner;
    if (DefaultOwner == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_DEFAULTOWNER);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    DefaultOwner->Owner = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetPrimaryGroup()

    PURPOSE:  Sets the primary group to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
SetPrimaryGroup(
               HWND    hDlg
               )
{
    HWND    hwnd;
    INT     iItem;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    PrimaryGroup = pMyToken->PrimaryGroup;
    if (PrimaryGroup == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_PRIMARYGROUP);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    PrimaryGroup->PrimaryGroup = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MoreDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
MoreDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{

    switch (message) {

        case WM_INITDIALOG:

            if (!MoreDlgInit(hDlg)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: MoreDlgInit(HWND)

    PURPOSE:  Initialises the controls in the more dialog window.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
MoreDlgInit(
           HWND    hDlg
           )
{
    CHAR    string[MAX_STRING_BYTES];
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_STATISTICS Statistics;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Statistics = pMyToken->TokenStats;
    if (Statistics == NULL) {
        DbgPrint("SECEDIT: No token statistics in mytoken\n");
        return(FALSE);
    }

    if (LUID2String(Statistics->TokenId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENID, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert tokenid luid to string\n");
    }

    if (Time2String(Statistics->ExpirationTime, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_EXPIRATIONTIME, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert expiration time to string\n");
    }

    if (TokenType2String(Statistics->TokenType, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENTYPE, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert token type to string\n");
    }

    if (Statistics->TokenType == TokenPrimary) {
        SetDlgItemText(hDlg, IDS_IMPERSONATION, "N/A");
    } else {
        if (ImpersonationLevel2String(Statistics->ImpersonationLevel, string, MAX_STRING_BYTES)) {
            SetDlgItemText(hDlg, IDS_IMPERSONATION, string);
        } else {
            DbgPrint("SECEDIT: Failed to convert impersonation level to string\n");
        }
    }

    if (Dynamic2String(Statistics->DynamicCharged, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICCHARGED, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert dynamic charged to string\n");
    }

    if (Dynamic2String(Statistics->DynamicAvailable, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICAVAILABLE, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert dynamic available to string\n");
    }

    if (LUID2String(Statistics->ModifiedId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_MODIFIEDID, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert modifiedid luid to string\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: ListDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
ListDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND    hwndEdit = NULL;

    switch (message) {

        case WM_INITDIALOG:

            if (!ListDlgInit(hDlg)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    hwndEdit = ListDlgEnd(hDlg);

                    // We're done, drop through to enddialog...

                case IDCANCEL:
                    EndDialog(hDlg, (INT_PTR)hwndEdit);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: ListDlgInit(HWND)

    PURPOSE:  Initialise the window list dialog

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
ListDlgInit(
           HWND    hDlg
           )
{
    // Fill the list box with top-level windows and their handles
    EnumWindows(WindowEnum, (LONG_PTR)hDlg);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowEnum

    PURPOSE:  Window enumeration call-back function.
              Adds each window to the window list-box

    RETURNS:  TRUE to continue enumeration, FALSE to stop.

****************************************************************************/
BOOL
APIENTRY
WindowEnum(
          HWND    hwnd,
          LPARAM  lParam
          )
{
    HWND    hDlg = (HWND)lParam;
    CHAR    string[MAX_STRING_BYTES];

    if (GetWindowText(hwnd, string, MAX_STRING_BYTES) != 0) {

        // This window has a caption, so add it to the list-box

        AddLBItem(hDlg, IDLB_WINDOWLIST, string, (LONG_PTR)hwnd);
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: ListDlgEnd(HWND)

    PURPOSE:  Cleans up after window list dialog

    RETURNS:  handle to window the user has selected or NULL

****************************************************************************/
HWND
ListDlgEnd(
          HWND    hDlg
          )
{
    HWND    hwndListBox = GetDlgItem(hDlg, IDLB_WINDOWLIST);
    HWND    hwndEdit;
    INT     iItem;

    // Read selection from list-box and get its hwnd

    iItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);

    if (iItem == LB_ERR) {
        // No selection
        hwndEdit = NULL;
    } else {
        hwndEdit = (HWND)SendMessage(hwndListBox, LB_GETITEMDATA, iItem, 0);
    }

    return (hwndEdit);
}


/****************************************************************************

    FUNCTION: AboutDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for About dialog

****************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
            HWND    hDlg,
            UINT    message,
            WPARAM  wParam,
            LPARAM  lParam
            )
{

    switch (message) {

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: ActiveWindowDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for Active Window Dialog

****************************************************************************/

INT_PTR
APIENTRY
ActiveWindowDlgProc(
                   HWND    hDlg,
                   UINT    message,
                   WPARAM  wParam,
                   LPARAM  lParam
                   )
{
    switch (message) {
        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\token.c ===
/****************************************************************************

   PROGRAM: TOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "SECEDIT.h"

HANDLE  AllocMyToken(VOID);
BOOL    ReadMyToken(HANDLE);
BOOL    WriteMyToken(HWND, HANDLE);
BOOL    FreeMyToken(HANDLE);
HANDLE  OpenToken(HANDLE, ACCESS_MASK);
BOOL    CloseToken(HANDLE);
PVOID   AllocTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS);
BOOL    GetTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS, PPVOID);
BOOL    SetTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS, PVOID);
BOOL    FreeTokenInfo(PVOID);


/****************************************************************************

   FUNCTION: OpenMyToken

   PURPOSE: Opens the token of the process of the specified window.

   RETURNS : Handle to mytoken on success, or NULL on failure.

****************************************************************************/

HANDLE OpenMyToken(
    HWND    hwnd)
{
    DWORD       ThreadId;
    DWORD       ProcessId;
    PMYTOKEN    pMyToken;
    HANDLE      hMyToken;

    ThreadId = GetWindowThreadProcessId(hwnd, &ProcessId);

    DbgPrint("Process Id = %ld, ThreadId = %ld\n", ProcessId, ThreadId);

    if (ThreadId == 0) {
        DbgPrint("SECEDIT: GetWindowThreadProcessId failed\n");
        return(NULL);
    }

    //
    // Build a MYTOKEN structure.

    hMyToken = AllocMyToken();
    if (hMyToken == NULL) {
        return(NULL);
    }

    pMyToken = (PMYTOKEN)hMyToken;

    pMyToken->ProcessId = ProcessId;
    pMyToken->ThreadId = ThreadId;

    if (!ReadMyToken(hMyToken)) {
        DbgPrint("SECEDIT : Failed to read token info\n");
        Free(pMyToken);
        return(NULL);
    }

    return(hMyToken);
}


/****************************************************************************

   FUNCTION: ReadMyToken

   PURPOSE: Reads the token info and stores in mytoken structure

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/

BOOL ReadMyToken(
    HANDLE  hMyToken)
{
    HANDLE      Token;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    Token = OpenToken(hMyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token with TOKEN_QUERY access\n");
        return(FALSE);
    }

    if (!GetTokenInfo(Token, TokenStatistics, (PPVOID)&(pMyToken->TokenStats))) {
        DbgPrint("SECEDIT : Failed to read token statistics from token\n");
    }

    if (!GetTokenInfo(Token, TokenGroups, (PPVOID)&(pMyToken->Groups))) {
        DbgPrint("SECEDIT : Failed to read group info from token\n");
    }

    if (!GetTokenInfo(Token, TokenUser, (PPVOID)&(pMyToken->UserId))) {
        DbgPrint("SECEDIT : Failed to read userid from token\n");
    }

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&(pMyToken->DefaultOwner))) {
        DbgPrint("SECEDIT : Failed to read default owner from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&(pMyToken->PrimaryGroup))) {
        DbgPrint("SECEDIT : Failed to read primary group from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrivileges, (PPVOID)&(pMyToken->Privileges))) {
        DbgPrint("SECEDIT : Failed to read privilege info from token\n");
    }

    CloseToken(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: CloseMyToken

   PURPOSE: Closes the specified mytoken handle
            If fSaveChanges = TRUE, the token information is saved,
            otherwise it is discarded.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseMyToken(
    HWND    hDlg,
    HANDLE  hMyToken,
    BOOL    fSaveChanges)
{
    if (fSaveChanges) {
        WriteMyToken(hDlg, hMyToken);
    }

    return FreeMyToken(hMyToken);
}

/****************************************************************************

   FUNCTION: AllocMyToken

   PURPOSE: Allocates space for mytoken structure.

   RETURNS : HANDLE to mytoken or NULL on failure.

****************************************************************************/

HANDLE AllocMyToken(VOID)
{
    PMYTOKEN    pMyToken;

    pMyToken = (PMYTOKEN)Alloc(sizeof(MYTOKEN));

    return((HANDLE)pMyToken);
}


/****************************************************************************

   FUNCTION: FreeMyToken

   PURPOSE: Frees the memory allocated to mytoken structure.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL FreeMyToken(
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    if (pMyToken->TokenStats != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->TokenStats));
    }

    if (pMyToken->UserId != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->UserId));
    }

    if (pMyToken->PrimaryGroup != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->PrimaryGroup));
    }

    if (pMyToken->DefaultOwner != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->DefaultOwner));
    }

    if (pMyToken->Groups != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Groups));
    }

    if (pMyToken->Privileges != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Privileges));
    }

    Free((PVOID)pMyToken);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: WriteMyToken

   PURPOSE: Writes the token information out to the token

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL WriteMyToken(
    HWND    hDlg,
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    HANDLE      Token;

    //
    // Save default owner and primary group
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_DEFAULT access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change default owner or primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        // Set default owner
        //
        if ((pMyToken->DefaultOwner != NULL) &&
           (!SetTokenInfo(Token, TokenOwner, (PVOID)(pMyToken->DefaultOwner)))) {
            MessageBox(hDlg, "Failed to set default owner", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        // Set primary group
        //
        if ((pMyToken->PrimaryGroup != NULL) &&
           (!SetTokenInfo(Token, TokenPrimaryGroup, (PVOID)(pMyToken->PrimaryGroup)))) {
            MessageBox(hDlg, "Failed to set primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    //
    // Save group info
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_GROUPS);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_GROUPS access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Groups != NULL) &&
           (!SetTokenInfo(Token, TokenGroups, (PVOID)(pMyToken->Groups)))) {
            MessageBox(hDlg, "Failed to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }


    //
    // Change privileges
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_PRIVILEGES);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_PRIVILEGES access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Privileges != NULL) &&
           (!SetTokenInfo(Token, TokenPrivileges, (PVOID)(pMyToken->Privileges)))) {
            MessageBox(hDlg, "Failed to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenToken

   PURPOSE: Opens the token with the specified access

   RETURNS : Handle to token on success, or NULL on failure.

****************************************************************************/

HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess)
{
    NTSTATUS    Status;
    HANDLE      Token;
    HANDLE      Process;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    DWORD       ThreadId = pMyToken->ThreadId;
    DWORD       ProcessId = pMyToken->ProcessId;

    Process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if (Process == NULL) {
        DbgPrint("SECEDIT: OpenProcess failed, last error = %ld\n", GetLastError());
        return(NULL);
    }

    Status = NtOpenProcessToken(
                 Process,
                 DesiredAccess,
                 &Token
                 );

    CloseHandle(Process);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: Failed to open token with access = 0x%x, status = 0x%lx\n", DesiredAccess, Status);
        return(NULL);
    }

    return(Token);
}


/****************************************************************************

   FUNCTION: CloseToken

   PURPOSE: Closes the specified token handle

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseToken(
    HANDLE  Token)
{
    NTSTATUS    Status;

    Status = NtClose(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: AllocTokenInfo

   PURPOSE: Allocates memory to hold the parameter that
            NTQueryInformationToken will return.
            Memory should be freed later using FreeTokenInfo

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID AllocTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass)
{
    NTSTATUS Status;
    ULONG   InfoLength;

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken did NOT return buffer_too_small, status = 0x%lx\n", Status);
#endif
        return(NULL);
    }

    return Alloc(InfoLength);
}


/****************************************************************************

   FUNCTION: FreeTokenInfo

   PURPOSE: Frees the memory previously allocated with AllocTokenInfo

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL FreeTokenInfo(
    PVOID   Buffer)
{
    return(Free(Buffer));
}


/****************************************************************************

   FUNCTION: GetTokenInfo

   PURPOSE: Allocates a buffer and reads the specified data
            out of the token and into it.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;
    ULONG   InfoLength;
    PVOID   Buffer;

    *pBuffer = NULL;    // Prepare for failure

    Buffer = AllocTokenInfo(Token, TokenInformationClass);
    if (Buffer == NULL) {
        return(FALSE);
    }

    BufferSize = (ULONG)GetAllocSize(Buffer);

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 Buffer,                   // TokenInformation
                 BufferSize,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (!NT_SUCCESS(Status)) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken failed, status = 0x%lx\n", Status);
#endif
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    if (InfoLength > BufferSize) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken failed, DataSize > BufferSize");
#endif
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    *pBuffer = Buffer;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: SetTokenInfo

   PURPOSE: Sets the specified information in the given token.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;

    BufferSize = (ULONG)GetAllocSize(Buffer);

    switch (TokenInformationClass) {

    case TokenOwner:
    case TokenPrimaryGroup:
    case TokenDefaultDacl:

        Status = NtSetInformationToken(
                     Token,                    // Handle
                     TokenInformationClass,    // TokenInformationClass
                     Buffer,                   // TokenInformation
                     BufferSize                // TokenInformationLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtSetInformationToken failed, info class = 0x%x, status = 0x%lx\n",
                                TokenInformationClass, Status);
            return(FALSE);
        }
        break;


    case TokenGroups:

        Status = NtAdjustGroupsToken(
                    Token,                      // Handle
                    FALSE,                      // Reset to default
                    (PTOKEN_GROUPS)Buffer,      // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtAdjustGroupsToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    case TokenPrivileges:

        Status = NtAdjustPrivilegesToken(
                    Token,                      // Handle
                    FALSE,                      // Disable all privileges
                    (PTOKEN_PRIVILEGES)Buffer,  // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtAdjustPrivilegesToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    default:

        // Unrecognised information type
        DbgPrint("SECEDIT: SetTokenInfo passed unrecognised infoclass, class = 0x%x\n", TokenInformationClass);

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\seterror\seterror.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

__cdecl main (int argc, LPSTR argv[])
{
  int i;

  if (argc<=1) {
    printf( "Set errorlevel to user-specified integer value.\n" );
    printf( "Usage: %s <errorlevel>\n", argv[0]);
    printf( "   ex: %s 1\n", argv[0]);
    return 1;
  }

  i = atoi( argv[1] );
  return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\app\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "SECEDIT.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID
Alloc(
     SIZE_T   Bytes
     )
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

SIZE_T
GetAllocSize(
            PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL
Free(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

   FUNCTION: LUID2String

   PURPOSE: Converts a LUID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
LUID2String(
           LUID    Luid,
           LPSTR   String,
           UINT    MaxStringBytes
           )
{

    if (Luid.HighPart == 0) {
        wsprintf(String, "0x%lx", Luid.LowPart);
    } else {
        wsprintf(String, "0x%lx%08lx", Luid.HighPart, Luid.LowPart);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Time2String

   PURPOSE: Converts a time into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
Time2String(
           TIME    Time,
           LPSTR   String,
           UINT    MaxStringBytes
           )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields(&Time, &TimeFields);

    if (TimeFields.Year > 2900) {
        strcpy(String, "Never");
    } else {
        wsprintf(String, "%d/%d/%d  %02d:%02d:%02d",
                 TimeFields.Year, TimeFields.Month, TimeFields.Day,
                 TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: TokenType2String

   PURPOSE: Converts a tokentype into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
TokenType2String(
                TOKEN_TYPE TokenType,
                LPSTR   String,
                UINT    MaxStringBytes
                )
{

    switch (TokenType) {

        case TokenPrimary:
            strcpy(String, "Primary");
            break;

        case TokenImpersonation:
            strcpy(String, "Impersonation");
            break;

        default:
            DbgPrint("SECEDIT: TokenType2String fed unrecognised token type : 0x%x\n", TokenType);
            return(FALSE);
            break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ImpersonationLevel2String

   PURPOSE: Converts an impersonation level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
ImpersonationLevel2String(
                         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
                         LPSTR   String,
                         UINT    MaxStringBytes
                         )
{

    switch (ImpersonationLevel) {

        case SecurityAnonymous:
            strcpy(String, "Anonymous");
            break;

        case SecurityIdentification:
            strcpy(String, "Identification");
            break;

        case SecurityImpersonation:
            strcpy(String, "Impersonation");
            break;

        case SecurityDelegation:
            strcpy(String, "Delegation");
            break;

        default:
            DbgPrint("SECEDIT: ImpersonationLevel2String fed unrecognised impersonation level : 0x%x\n", ImpersonationLevel);
            return(FALSE);
            break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Dynamic2String

   PURPOSE: Converts an dynamic quota level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
Dynamic2String(
              ULONG   Dynamic,
              LPSTR   String,
              UINT    MaxStringBytes
              )
{
    wsprintf(String, "%ld", Dynamic);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItem(
       HWND    hDlg,
       INT     ControlID,
       LPSTR   String,
       LONG_PTR Data,
       BOOL    fCBox
       )
{
    HWND    hwnd;
    INT_PTR iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return((INT)iItem);
}


/****************************************************************************

    FUNCTION: FindSid

    PURPOSE:  Searches for the specified Sid in a control.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
INT
FindSid(
       HWND    hDlg,
       INT     ControlID,
       PSID    Sid,
       BOOL    fCBox
       )
{
    HWND    hwnd;
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT     iItem;
        PSID    ItemSid;

        for (iItem =0; iItem < cItems; iItem ++) {

            ItemSid = (PSID)SendMessage(hwnd, GetDataMsg, iItem, 0);
            if (RtlEqualSid(ItemSid, Sid)) {
                return(iItem);
            }
        }
    }

    return(-1);
}


static HHOOK   hHookKeyboard = NULL;

/****************************************************************************

   FUNCTION: SetHooks

   PURPOSE: Installs input hooks

   RETURNS: TRUE on success, FALSE on failure

****************************************************************************/

BOOL
SetHooks(
        HWND    hwnd
        )
{
    HANDLE  hModHookDll;
    HOOKPROC lpfnKeyboardHookProc;

    if (hwnd == NULL) {
        // No-one to notify !
        return(FALSE);
    }

    if (hHookKeyboard != NULL) {
        // Hooks already installed
        return(FALSE);
    }

    hModHookDll = LoadLibrary("SECEDIT.DLL");
    if (hModHookDll == NULL) {
        DbgPrint("Failed to load secedit.dll\n");
        MessageBox(hwnd, "Failed to find secedit.dll.\nActive window context editting disabled.",
                   NULL, MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
        return(FALSE);
    }

    lpfnKeyboardHookProc = (HOOKPROC)GetProcAddress(hModHookDll, "KeyboardHookProc");
    if (lpfnKeyboardHookProc == NULL) {
        DbgPrint("Failed to find keyboard hook entry point in secedit.dll\n");
        return(FALSE);
    }

    // Install sytem-wide keyboard hook
    hHookKeyboard = SetWindowsHookEx(WH_KEYBOARD, lpfnKeyboardHookProc, hModHookDll, 0);
    if (hHookKeyboard == NULL) {
        DbgPrint("SECEDIT: failed to install system keyboard hook\n");
        return(FALSE);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ReleaseHooks

   PURPOSE: Uninstalls input hooks

   RETURNS: TRUE on success, FALSE on failure

****************************************************************************/

BOOL
ReleaseHooks(
            HWND    hwnd
            )
{
    BOOL    Success;

    if (hHookKeyboard == NULL) {
        // Hooks not installed
        return(FALSE);
    }

    Success = UnhookWindowsHookEx(hHookKeyboard);
    if (!Success) {
        DbgPrint("SECEDIT: Failed to release keyboard hook\n");
    }

    // Reset global
    hHookKeyboard = NULL;

    return(Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\dll\hookdll.c ===
/****************************************************************************

   PROGRAM: SECEDIT.C

   PURPOSE: Displays the usrs current token and eventually allows the user
            to edit parts of it.

****************************************************************************/


#include "hookdll.h"


/****************************************************************************

   FUNCTION: KeyboardHookProc

   PURPOSE: Handles keyboard input

   RETURNS: 1 if message should be discarded, 0 for normal processing

****************************************************************************/

LRESULT
APIENTRY
KeyboardHookProc(
    INT     nCode,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    HWND    hwndNotify;
    HWND    hwndEdit;

    if (nCode < 0) {
        return(CallNextHookEx(NULL, nCode, wParam, lParam));
    }

    // Is F11 being pressed ?
    if ((wParam == VK_F11) && ((lParam & (1<<31)) == 0)) {

        // Yes, notify our parent app
        hwndNotify = FindWindow(NULL, "Security Context Editor");

        hwndEdit = GetActiveWindow();

        if (hwndNotify != NULL) {
            PostMessage(hwndNotify, WM_SECEDITNOTIFY, (WPARAM)hwndEdit, 0);

            return(1);  // Stop anyone else getting this key press
        } else {
            DbgPrint("SECEDIT: Keyboard hook could not find app window\n");
        }
    }

    return(CallNextHookEx(NULL, nCode, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\secedit\dll\hookdll.h ===
#ifdef WIN32
#define NTBUILD
#endif

#ifdef NTBUILD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <port1632.h>

#include "..\global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\dll\main.c ===
#include <windows.h>

BOOL APIENTRY LibMain(HANDLE hModule, int nAttach, PCONTEXT pContext)
{
   OSVERSIONINFO osVer;
   osVer.dwOSVersionInfoSize= sizeof( osVer );
   GetVersionEx( &osVer );

   switch (nAttach)
    {
      // Only load on NT 5 or later.
      case  DLL_PROCESS_ATTACH:
          if (osVer.dwPlatformId != VER_PLATFORM_WIN32_NT || osVer.dwMajorVersion <= 4)
          {
             return FALSE;
          }

          break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setlink\setlink.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    setlink.c

Abstract:

    Utility to display or change the value of a symbolic link.

Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <tools.h>

BOOLEAN
__cdecl main(
    IN ULONG argc,
    IN PCHAR argv[]
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING LinkName;
    UNICODE_STRING LinkValue;
    HANDLE Handle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR Buffer[256];
    PWSTR s;
    ULONG ReturnedLength;

    //
    // Check to see whether or not this utility was invoked with the correct
    // number of parameters.  If not, bail out now.
    //

    ConvertAppToOem( argc, argv );
    if (argc < 2 || argc > 3) {
        printf( "Useage:  setlink symbolic-link-name [symbolic-link-value]\n" );
        return FALSE;
    }

    //
    // Begin by attempting to open the existing symbolic link name specified.
    //

    RtlInitString( &AnsiString, argv[1] );
    Status = RtlAnsiStringToUnicodeString( &LinkName,
                                           &AnsiString,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &LinkName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );
    Status = NtOpenSymbolicLinkObject( &Handle,
                                       argc == 2 ? SYMBOLIC_LINK_QUERY :
                                                   SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    //
    // Determine what should be done based on the number of parameters that
    // were given to the program.
    //

    if (argc == 2) {

        //
        // Only one parameter was specified, so display the value of the
        // symbolic link if it exists.
        //

        if (!NT_SUCCESS( Status )) {
            printf( "Symbolic link %wZ does not exist\n", &LinkName );
            return FALSE;
        } else {
            LinkValue.Length = 0;
            LinkValue.MaximumLength = sizeof( Buffer );
            LinkValue.Buffer = Buffer;
            ReturnedLength = 0;
            Status = NtQuerySymbolicLinkObject( Handle,
                                                &LinkValue,
                                                &ReturnedLength
                                              );
            NtClose( Handle );
            if (!NT_SUCCESS( Status )) {
                printf( "Error reading symbolic link %wZ\n", &LinkName );
                printf( "Error status was:  %X\n", Status );
                return FALSE;
            } else {
                printf( "Value of %wZ => %wZ", &LinkName, &LinkValue );
                s = LinkValue.Buffer + ((LinkValue.Length / sizeof( WCHAR )) + 1);
                while (ReturnedLength > LinkValue.MaximumLength) {
                    printf( " ; %ws", s );
                    while (*s++) {
                        ReturnedLength -= 2;
                        }
                    ReturnedLength -= 2;
                    }
                printf( "\n", s );
                return TRUE;
            }
        }

    } else {

        //
        // Three parameters were supplied, so assign a new value to the
        // symbolic link if it exists by first deleting the existing link
        // (mark it temporary and close the handle).  If it doesn't exist
        // yet, then it will simply be created.
        //

        if (NT_SUCCESS( Status )) {
            Status = NtMakeTemporaryObject( Handle );
            if (NT_SUCCESS( Status )) {
                NtClose( Handle );
            }
        }
    }

    //
    // Create a new value for the link.
    //

    ObjectAttributes.Attributes |= OBJ_PERMANENT;
    RtlInitString( &AnsiString, argv[2] );
    Status = RtlAnsiStringToUnicodeString( &LinkValue,
                                           &AnsiString,
                                           TRUE );
    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &LinkValue );
    if (!NT_SUCCESS( Status )) {
        printf( "Error creating symbolic link %wZ => %wZ\n",
                 &LinkName,
                 &LinkValue );
        printf( "Error status was:  %X\n", Status );
    } else {
        NtClose( Handle );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\exe\servers.c ===
/*++

   Filename :  servers.c

   Description: This file will be for testing the servers access.


   Created by:  Wally Ho

   History:     Created on 03/29/99.


   Contains these functions:

   1. IsServerOnline       (IN LPTSTR szMachineName)
   2. ServerOnlineThread   (IN LPTSTR szServerFile)


--*/
#include "setuplogEXE.h"

BOOL
IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare)
/*++

Routine Description:
   This will go through the list of servers specified in setuplogEXE.h
   It will return the first in it sees and reset the global server share
   name.

Arguments:
   The machineName (Filename with build etc) so the test file will get overwritten.
   Manual Server Name: NULL will give default behaviour.

Return Value:
	TRUE for success.
   FALSE for no name.
--*/

{
   DWORD    dw;
   HANDLE   hThrd;
   INT      i;
   TCHAR    szServerFile[ MAX_PATH ];
   DWORD    dwTimeOutInterval;
   i = 0;

   //
   // This should allow for a 
   // manually specified server.
   //
   if (NULL != szSpecifyShare){
       _tcscpy(g_szServerShare,szSpecifyShare);
      return TRUE;

   }
   //
   // Initialize the Server.
   // Variable. Since we are using a single thread
   // to do a time out we don't care about mutexes and
   // sychronization.
   //
   g_bServerOnline = FALSE;

   while ( i < NUM_SERVERS){

      
      _stprintf (szServerFile, TEXT("%s\\%s"),s[i].szSvr,szMachineName );
      //
      // Spawn the thread
      //
      hThrd  = CreateThread(NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) ServerOnlineThread,
                        (LPTSTR) szServerFile,
                        0,
                        &dw);
      //
      // This is in milli seconds so the time out is secs.
      //
      dwTimeOutInterval = TIME_TIMEOUT * 1000;

      s[i].dwTimeOut = WaitForSingleObject (hThrd, dwTimeOutInterval);
      CloseHandle (hThrd);

      //
      // This means the server passed the timeout.
      //
      if (s[i].dwTimeOut != WAIT_TIMEOUT &&
          g_bServerOnline == TRUE){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }
   return FALSE;
}


BOOL
ServerOnlineThread(IN LPTSTR szServerFile)
/*++

Routine Description:
   This create a thread and then time it out to see if we can get to
   a server faster. 

Arguments:
   The machineName so the test file will get overwritten.
Return Value:

--*/
{

   BOOL     bCopy = FALSE;
   TCHAR    szFileSrc [MAX_PATH];
   TCHAR    szServerTestFile [MAX_PATH];

   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   //
   GetModuleFileName (NULL, szFileSrc, MAX_PATH);
   
   //
   // Make a unique test file. 
   //
   _stprintf(szServerTestFile,TEXT("%s.SERVERTEST"),szServerFile);


   bCopy = CopyFile( szFileSrc,szServerTestFile, FALSE);
   if (bCopy != FALSE){
      //
      // If Succeeded Delete the test file.
      //
      DeleteFile(szServerTestFile);
      g_bServerOnline = TRUE;      
      return TRUE;
   }
   else{
      g_bServerOnline = FALSE;
      return FALSE;
   }
}


/*

   INT         i;
   NETRESOURCE NetResource ;


   i = 0;
   while ( i < NUM_SERVERS){
      //
      // Prep the struct.
      //
      ZeroMemory( &NetResource, sizeof( NetResource ) );
      NetResource.dwType = RESOURCETYPE_DISK ;
      NetResource.lpLocalName = "" ;
      NetResource.lpRemoteName = s[i].szSvr;
      NetResource.lpProvider = "" ;

      //
      // Try with default password and user.
      // This should work as its open to everyone.
      //
      s[i].dwNetStatus = WNetAddConnection2( &NetResource,NULL,NULL, 0 );
      //
      // Try default PW / USERID from setuplog.h
      //
      if (s[i].dwNetStatus != 0)
         s[i].dwNetStatus = WNetAddConnection2( &NetResource,LOGSHARE_PW,LOGSHARE_USER,0 );
      WNetCancelConnection2( g_szServerShare, 0, TRUE );

      if (s[i].dwNetStatus == NO_ERROR){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }

   //
   // No Valid name.
   // Return false so we won't write.
   return FALSE;


*/


BOOL IsMSI(VOID)
/*++

Routine Description:

	This will check if its an MSI install.
   It will check for the running process
   and then check for the path.

Arguments:


Return Value:

    BOOL - True if link is good. False otherwise.
--*/
{

	DWORD		   numTasks = 0;
	TASK_LIST	tlist[ MAX_PATH ];
   UINT        i;
   BOOL        bFound = FALSE;
   //
	//	Get the Running Tasks.
	//
	numTasks = GetTaskList(tlist, MAX_PATH);
   //
   // If the MSI process exists log it as such.
   //
   for(i = 1; i <= numTasks; i++){
      if(_tcsstr(tlist[i].ProcessName, TEXT("msiexec.exe"))){
         MessageBox(NULL,tlist[i].ProcessName, TEXT("Caption"),MB_OK);
           lpCmdFrom.b_MsiInstall = TRUE;
         return FALSE;
      }else{
           lpCmdFrom.b_MsiInstall = TRUE;
         return TRUE;
	   }
   }

   return TRUE;
}



DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )

/*++

// Borrowed with modifications from tlist a wesw invention.

  Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    CHAR                         szSubKey[1024];
    LANGID                       lid;
    LPSTR                        p;
    LPSTR                        p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    CHAR                         szProcessName[MAX_PATH];
    DWORD                        dwLimit = dwNumTasks - 1;



    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //
    p = buf;
    while (*p) {
        if (p > buf) {
            for( p2=p-2; isdigit(*p2); p2--) ;
        }
        if (_stricmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            strcpy( szSubKey, p2+1 );
        }
        else
        if (_stricmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            dwProcessIdTitle = atol( p2+1 );
        }
        //
        // next string
        //
        p += (strlen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );
    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = realloc( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD*)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD *)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = min( dwLimit, (DWORD)pObj->NumInstances );

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //
        p = (LPSTR) ((DWORD*)pInst + pInst->NameOffset);

        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName),
                                  NULL,
                                  NULL
                                );

        if (!rc) {
            //
            // if we cant convert the string then use a bogus value
            //
            strcpy( pTask->ProcessName, UNKNOWN_TASK );
        }

        if (strlen(szProcessName)+4 <= sizeof(pTask->ProcessName)) {
            strcpy( pTask->ProcessName, szProcessName );
            strcat( pTask->ProcessName, ".exe" );
        }

        //
        // get the process id
        //
        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD*)pInst + pInst->ByteLength);
        pTask->flags = 0;
        pTask->dwProcessId = *((LPDWORD) ((DWORD*)pCounter + dwProcessIdCounter));
        if (pTask->dwProcessId == 0) {
            pTask->dwProcessId = (DWORD)-2;
        }

        //
        // next process
        //
        pTask++;
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        free( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );
	//
	//	W.Ho added a minus 1 to get it to reflect the
	//	tasks properly.
	//
    return dwNumTasks -1;
}





























/*
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bCFTest;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;

typedef struct _ERRMSG {
   TCHAR szMsg[ MAX_PATH ];
   DWORD dwErr;
} *LPERRMSG, ERRMSG;


BOOL
IsServerOnline(VOID)
/*++

Routine Description:


Arguments:

Return Value:
	NONE.
--
{
#define NUM_SERVERS 6

   INT   i;
   TCHAR    sz[ MAX_PATH ];
   ERRMSG e[12] = {
      {TEXT("Access is denied."), ERROR_ACCESS_DENIED},
      {TEXT("The device specified in the lpLocalName parameter is already connected."), ERROR_ALREADY_ASSIGNED  },
      {TEXT("The device type and the resource type do not match."), ERROR_BAD_DEV_TYPE},
      {TEXT("The value specified in lpLocalName is invalid."), ERROR_BAD_DEVICE},
      {TEXT("The value specified in the lpRemoteName parameter is not valid or cannot be located."), ERROR_BAD_NET_NAME},
      {TEXT("The user profile is in an incorrect format."), ERROR_BAD_PROFILE},
      {TEXT("The system is unable to open the user profile to process persistent connections."),ERROR_CANNOT_OPEN_PROFILE },
      {TEXT("An entry for the device specified in lpLocalName is already in the user profile."), ERROR_DEVICE_ALREADY_REMEMBERED},
      {TEXT("A network-specific error occurred. To get a description of the error, use the WNetGetLastError function."), ERROR_EXTENDED_ERROR},
      {TEXT("The specified password is invalid."), ERROR_INVALID_PASSWORD},
      {TEXT("The operation cannot be performed because either a network component is not started or the specified name cannot be used."),ERROR_NO_NET_OR_BAD_PATH },
      {TEXT("The network is not present."),ERROR_NO_NETWORK}
   };

   SERVERS  s[NUM_SERVERS] ={
      {TEXT("\\\\donkeykongjr\\public"), -1, -1},
      {TEXT("\\\\popcorn\\public"), -1, -1},
      {TEXT("\\\\NotExists\\idwlog"), -1, -1},
      {TEXT("\\\\Paddy\\idwlog"), -1, -1},
      {TEXT("\\\\Bear\\idwlog"), -1, -1},
      {TEXT("\\\\JustTesting\\idwlog"), -1, -1}

   };


   for (i = 0; i < 12; i++) {
      _tprintf(TEXT("Error %s  %lu\n"),e[i].szMsg, e[i].dwErr);
   }

   for (i = 0; i < NUM_SERVERS; i++){
     s[i].dwNetStatus = WNetAddConnection(TEXT("donkeykongjr\\public\0"),NULL,NULL);


     _stprintf(sz,TEXT("%s%s"),s[i].szSvr,TEXT("\\test") );
     s[i].bCFTest = CopyFile(TEXT("c:\\test"),sz,FALSE);
     _tprintf(TEXT("Did this work for %s %s %lu\n"),
         sz,
         s[i].bCFTest? TEXT("WORKED"): TEXT("FAILED"),
         s[i].dwNetStatus
         );
   }

   return FALSE;
}
*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\inc\setuplib.h ===
#define MY_MAX_CNLEN    64
#define MY_MAX_UNLEN    1024
#define USERNAME        "USERNAME"

#define UNKNOWN         "UNKNOWN"
#define BUILD_NUMBER_KEY "SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION"
#define BUILD_NUMBER_BUFFER_LENGTH 80

VOID GetBuildNumber( LPTSTR BuildNumber );
BOOL GetPnPDisplayInfo( LPTSTR pOutputData );
VOID ConnectAndWrite (LPTSTR MachineName, LPTSTR Buffer);
VOID WriteDataToFile (IN LPTSTR  szFileName, IN LPTSTR  szFrom, IN LPNT32_CMD_PARAMS lpCmdL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\exe\setuplog.c ===
/*++

   Filename :  setuplog.c

   Description: This is the main file for the setuplog.c
                  
   Created by:  Wally Ho

   History:     Created on 03/30/99.


   Contains these functions:

   1. GetTargetFile     (LPTSTR szOutPath, LPTSTR szBld)
   2. GetNTSoundInfo    (VOID)
   3. ConnectAndWrite   (LPTSTR MachineName, LPTSTR Buffer)
   4. GetBuildNumber    (LPTSTR szBld)
   5. RandomMachineID   (VOID)
   6. WriteMinimalData  (LPTSTR szFileName)
   7. DeleteDatafile    (LPTSTR szDatafile)
   8. GlobalInit        (VOID)


--*/
#include "setuplogEXE.h"

VOID 
GetTargetFile (LPTSTR szOutPath, LPTSTR szBld)
/*++

   Routine Description:
      The file name is generated based on the calling machine's name
      and the build number being installed. In the "before" case, the generated
      name is saved to c:\setuplog.ini, and this name is in turn read in
      "after" case.

   Arguments:
      Where to write the file.
      The build.

   Return Value:
      NONE
--*/
{
   HANDLE      hFile;
   DWORD       dwLen = MAX_PATH;
   TCHAR       szParam [ MAX_PATH ];
   TCHAR       szComputerName [20];
   TCHAR       szComputerNameBld[30];
   g_pfnWriteDataToFile = (fnWriteData)GetProcAddress (LoadLibrary ("setuplog.dll"),
                                                       "WriteDataToFile");

   GetComputerName (szComputerName, &dwLen);
   //
   // Build the new filename.Consisting of
   // 1. The Computername
   // 2. The build number.
   //

   _stprintf (szOutPath,TEXT("%s"), szComputerName);
   _tcscat (szOutPath, szBld);
   _tcscat (szOutPath, TEXT(".1"));
   //
   //   Combine Computername and the build
   //   To keep DavidShi code from breaking.
   //
   _stprintf(szComputerNameBld,TEXT("%s%s"),szComputerName,szBld);

   if (!lpCmdFrom.b_Cancel ){
      hFile = CreateFile (SAVE_FILE,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_HIDDEN,
                          NULL );
      if (hFile == INVALID_HANDLE_VALUE){
         OutputDebugString ("Unable to write setuplog.ini\n");
         return;
      }

      // Check for Upgrade.
      _stprintf (szParam, TEXT("%s"),   lpCmdFrom.b_Upgrade? TEXT("U"): TEXT("I"));
      WriteFile (hFile, (LPCVOID) szParam, 1, &dwLen, NULL);

      // Check for CD install.
      _stprintf (szParam, TEXT("%s\""),   lpCmdFrom.b_CDrom? TEXT("C"): TEXT("N"));
      WriteFile (hFile, (LPCVOID) szParam, 2, &dwLen, NULL);

      // Write out the platform.
      // I think this get ignored so i may delete it. Its DavidShi code.
      WriteFile (hFile, (LPCVOID)   szPlatform, _tcsclen(szPlatform), &dwLen, NULL);

      // Write out the drive.
      WriteFile (hFile, (LPCVOID)   "\"C:", 3, &dwLen, NULL);
      
      // Write out the computer name and build
      WriteFile (hFile, (LPCVOID)   szComputerNameBld, _tcsclen(szComputerNameBld)+1, &dwLen, NULL);

      // Write the RandomID.
      _stprintf (szParam, TEXT("\r\nMachineID %lu"),   lpCmdFrom.dwRandomID);
      WriteFile (hFile, (LPCVOID)   szParam,_tcsclen(szParam)+1 , &dwLen, NULL);

      // Check for MSI install
      _stprintf (szParam, TEXT("\r\nMSI %s"),   lpCmdFrom.b_MsiInstall? TEXT("Y"): TEXT("N"));
      WriteFile (hFile, (LPCVOID)   szParam,_tcsclen(szParam)+1 , &dwLen, NULL);
      CloseHandle (hFile);
   }
}


VOID 
GetNTSoundInfo()
{
   HKEY    hKey;
   DWORD   dwCbData;
   ULONG   ulType;
   LPTSTR  sSubKey=TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
   INT     i;
   TCHAR   szSubKeyName[ MAX_PATH ];
   TCHAR   szTempString[ MAX_PATH ];

   
   // Get Sound Card Info
   m.nNumWaveOutDevices = 0;
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
      // Loop through the key to see how many wave devices we have, but skip mmdrv.dll.
      for (i = 0; i <= 1; i++){
         if (i != 0)
            _stprintf(szSubKeyName, TEXT("wave%d"),i);
         else
            _tcscpy(szSubKeyName, TEXT("wave"));
 
         dwCbData = sizeof (szTempString);
         if (RegQueryValueEx(hKey, szSubKeyName, 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            break;
         else{
            // We want to skip mmdrv.dll - not relevant.
            if (szTempString[0] && 
                _tcscmp(szTempString, TEXT("mmdrv.dll")))  {
               
               _tcscpy(&m.szWaveDriverName[m.nNumWaveOutDevices][0], szTempString);
               m.nNumWaveOutDevices++;
            }
         }
      }
   }

   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }


   sSubKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){

      // Now grab the sound device string for each wave device
      for (i = 0; i < m.nNumWaveOutDevices; i++){
         dwCbData = sizeof szTempString;
         if (RegQueryValueEx(hKey, m.szWaveDriverName[i], 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            _tcscpy(m.szWaveOutDesc[i], TEXT("Unknown"));
         else
            _tcscpy(m.szWaveOutDesc[i], szTempString);
      }
   }
   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }
   return;
}

VOID
ConnectAndWrite(LPTSTR MachineName,
                LPTSTR Buffer)
/*++

   Routine Description:
      Cconnect to the data share and write the buffer to a file
      named MachineNamebuild.1

   Arguments:
      The MachineName
      The buffer with the data to put in.

   Return Value:
      NONE
--*/
{
   TCHAR      szLogName[ MAX_PATH ];
   HANDLE     hWrite ;
   DWORD      Size, Actual ;
   TCHAR      szWriteFile[2000];

   _tcscpy(szWriteFile,Buffer);

   //
   // Blow through the list of servers.
   // and change the g_szServerShare to match.
   //

   if (TRUE == IsServerOnline(MachineName, NULL)){
      //
      // Set the server name now as we now have it
      // into the outputbuffer
      //
      _stprintf (Buffer+_tcsclen(Buffer),
             TEXT("IdwlogServer:%s\r\n"), g_szServerShare);
    
      _stprintf (szLogName, TEXT("%s\\%s"),g_szServerShare,MachineName );
      
      hWrite = CreateFile( szLogName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                        NULL );
     if ( hWrite != INVALID_HANDLE_VALUE ){
         SetFilePointer( hWrite, 0, NULL, FILE_END );

         Size = _tcsclen( Buffer );
         WriteFile( hWrite, szWriteFile, Size, &Actual, NULL );
         CloseHandle( hWrite );
     }
   }
}


VOID 
GetBuildNumber (LPTSTR szBld)
/*++
    
Routine Description:

   Acquires the Build number from imagehlp.dll

Arguments:

 
Return Value:

  True upon sucessful completion.
  

--*/

{

   VS_FIXEDFILEINFO* pvsFileInfo;
   WIN32_FIND_DATA fd;
   HANDLE   hFind;

   TCHAR    szCurDir [MAX_PATH];
   TCHAR    szFullPath[ MAX_PATH ];
   LPTSTR   ptstr;
   DWORD   dwTemp;
   DWORD   dwLen;
   INT     iBuild;
   LPVOID  lpData;

   _tcscpy (szBld, TEXT("latest"));
   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   // will always assume imagehlp.dll is in its
   // current path or one up.
   //
   GetModuleFileName (NULL, szCurDir, MAX_PATH);

   //
   // This will cull off the setuplog.exe part
   // leaving us with the full path to where
   // setuplog.exe was on the CD or netshare.
   //

   ptstr = szCurDir + strlen(szCurDir);
   while (*ptstr-- != TEXT('\\'));
   ptstr++;
   *ptstr = ('\0');
   _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);
   //
   // On a network share the Imagehlp.dll is one up from where
   // setuplog.exe is located. We will look in both places.
   //

   hFind = FindFirstFile (szFullPath, &fd);

   if (INVALID_HANDLE_VALUE == hFind){
      //
      // Now we know the file in not in the
      // immediate directory. Move up one by
      // culling off one more directory.
      //
      ptstr = szCurDir + _tcsclen(szCurDir);
      while (*ptstr-- != '\\');
      ptstr++;
      *ptstr = '\0';

      _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);

      hFind = FindFirstFile (szFullPath,&fd);
      if (INVALID_HANDLE_VALUE == hFind){
         //
         // In case we cannot find it we will exit.
         //
         _tcscpy (szBld, TEXT("latest"));
         return;
      }
   }

   //
   // Get the buffer info size
   //
   dwLen = GetFileVersionInfoSize (szFullPath, &dwTemp);
   if ( 0 == dwLen ) {
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
   }

   lpData = LocalAlloc (LPTR, dwLen);
   if ( lpData == NULL ) {
     //
     // We have a problem.
     //
     _tcscpy (szBld, TEXT("latest"));
     return;
   }
     //
     // Get the File Version Info
     //
   if(0 == GetFileVersionInfo(szFullPath,0,MAX_PATH,lpData)){
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
   }

   if (0 == VerQueryValue (lpData, "\\", &pvsFileInfo, &dwTemp)) {
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
    }

   //
   // The HIWORD() of this is the build
   // The LOWORD() of this is some garbage? :-)
   //
   iBuild = HIWORD(pvsFileInfo->dwFileVersionLS);


   LocalFree (lpData);
   //
   // Write it back to the buffer.
   //
   _stprintf(szBld, TEXT("%d"),iBuild);
}


DWORD
RandomMachineID(VOID)
/*++

Author: Wallyho.
    
Routine Description:

   Generates a DWORD Random MachineID for each machine

Arguments:
   NONE
 
Return Value:

  The DWORD random ID.
  

--*/

{
   INT i;
   TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD    dwSize;
   INT      iLenCName;
   INT      iNameTotal = 0;

   DWORD    dwMachineID;    
   CHAR     szRandomID[ 4 ]; // need 4 bytes to contain the DWORD.
   struct _timeb tm;


   //
   // This will get us the milliseconds
   //
   _ftime(&tm);
   //
   // Seed the random number generator.
   // We will seed with the seconds + milliseconds at
   // at that time. I was getting the same number 
   // if I pressed the keyboard too fast in testing this.
   // The milli seconds should decrease the expectancy of
   // duplication.
   //
   srand (  (unsigned) time (NULL) + tm.millitm);
   //
   // This will guarantee a mostly random identifier.
   // Even with no computer name. We will tally the
   // ascii decimal value of the computer name and
   // add that to the randomly generated number.
   // The possibility of a dup is greatly decreased
   // since we switched to a dword system.
   // This computername tweak should be unnecessary.
   //
   dwSize = sizeof(szComputerName);
   if (0 == GetComputerName(szComputerName,&dwSize) ){
      //
      // This algorithm will limit the random number to 
      // uppercase ascii alphabet.
      //
      szComputerName[0] = 65 + (rand() % 25);
      szComputerName[1] = 65 + (rand() % 25);
      szComputerName[2] = 65 + (rand() % 25);
      szComputerName[3] = 65 + (rand() % 25);
      szComputerName[4] = 65 + (rand() % 25);
      szComputerName[5] = 65 + (rand() % 25);
      szComputerName[6] = 65 + (rand() % 25);
      szComputerName[7] = TEXT('\0');
   }
   iLenCName = _tcslen (szComputerName);
   //
   // Tally up the individual elements in the file
   //
   for (i = 0; i < iLenCName; i++)
      iNameTotal += szComputerName[i];
   //
   //   Generate four 8 bit numbers.
   //   Add the some random number based on the
   //   computername mod'ed to 0-100.
   //   Limit the 8 bit number to 0-155 to make room
   //   for the 100 from the computer name tweak.
   //   Total per 8 bit is 256.
   //   Do this tweak to only 2.
   //   We will then cast and shift to combine it
   //   into a DWORD.
   //
   szRandomID[0] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[1] =  rand() % 255;
   szRandomID[2] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[3] =  rand() % 255;

   //
   //   This will combine the 4 8bit CHAR into one DWORD 
   //
   dwMachineID  =   (DWORD)szRandomID[0] * 0x00000001 + 
                    (DWORD)szRandomID[1] * 0x00000100 +
                    (DWORD)szRandomID[2] * 0x00010000 +
                    (DWORD)szRandomID[3] * 0x01000000;

   return dwMachineID;
}




VOID 
WriteMinimalData (LPTSTR szFileName)
/*++


   For machines on which setuplog.dll fails to load, just write
   the platform,a time stamp, upgrade, and cpu count.

--*/
{

   TCHAR szOutBuffer[4096];

   _tcscpy (szCPU ,TEXT("1"));


   _stprintf (szOutBuffer,
      TEXT("MachineID:%lu\r\n")  
      TEXT("Source Media:%s\r\n")
      TEXT("Type:%s\r\n")
      TEXT("FromBld:%s\r\n")
      TEXT("Arch:%s\r\n")
      TEXT("Sound:%s\r\n")
      TEXT("NumProcs:%s\r\n")
      TEXT("MSI:%s\r\n"),
           lpCmdFrom.dwRandomID,
           lpCmdFrom.b_CDrom?   TEXT("C"): TEXT("N"),
           lpCmdFrom.b_Upgrade? TEXT("U"): TEXT("I"),
         szPlatform,
         szArch,
         m.nNumWaveOutDevices? m.szWaveDriverName[m.nNumWaveOutDevices-1]: TEXT("None"),
         szCPU,
         lpCmdFrom.b_MsiInstall? TEXT("Y"): TEXT("N")
         );
   ConnectAndWrite (szFileName, szOutBuffer);
}


VOID
DeleteDatafile (LPTSTR szDatafile)
/*++

   Author: 
    
   Routine Description:

      Deletes the file from the server if the user cancels it.

   Arguments:
      The name of the datafile.

 
   Return Value:
      
      NONE
--*/
{
   TCHAR    szPath[MAX_PATH];
   
   _stprintf (szPath,TEXT("%s\\%s"), g_szServerShare,szDatafile);
   DeleteFile (szPath);
}




INT WINAPI
WinMain(HINSTANCE hInst,
        HINSTANCE h,
        LPTSTR     szCmdLine,
        INT       nCmdShow)
{
   
   BOOL  bAfter = FALSE;
   TCHAR szBld[10];
   TCHAR szFileToSave[MAX_PATH];
   OSVERSIONINFO osVer;

   //
   // Initialize Global Variables.
   //
   //   GlobalInit();

   // Spray up a simple help screen for /?
   if ( 0 == _tcscmp(szCmdLine, TEXT("/?")) ||
        0 == _tcscmp(szCmdLine, TEXT("-?")) ){
      
      MessageBox(NULL,TEXT("setuplog upgrade cancel cdrom MSI "),TEXT("Help!"),MB_ICONQUESTION | MB_OK);
      return FALSE;
   }


   SetErrorMode (SEM_FAILCRITICALERRORS);
   //
   // See if Drive C is a HD.
   //
   if (DRIVE_FIXED != GetDriveType (TEXT("C:\\")) ){
       return 0;
   }

   osVer.dwOSVersionInfoSize= sizeof( osVer );
   GetVersionEx( &osVer );
      switch (osVer.dwPlatformId){

      case VER_PLATFORM_WIN32_NT:
            szPlatform = TEXT("Windows NT");

            switch (osVer.dwMajorVersion){
               case 3:
                  szPlatform = TEXT("Windows NT 3.51");
               break;
               case 4:
                  szPlatform = TEXT("Windows NT 4.0");
               break;
               case 5: 
                  szPlatform = szCurBld;
               break;
            }
            GetEnvironmentVariable ( TEXT("NUMBER_OF_PROCESSORS"),   szCPU, 6);
            GetEnvironmentVariable ( TEXT("PROCESSOR_ARCHITECTURE"), szArch, 20);
         break;
      case VER_PLATFORM_WIN32_WINDOWS:
            szPlatform = TEXT("Windows 9x");
            _tcscpy (szArch, "X86");
         break;
      default:
            szPlatform = TEXT("Unknown");
            _tcscpy (szArch, TEXT("Unknown"));
         break;
      }
   
   //
   // This is a very primitive command line processor
   // I'll add to it now to get this working soon.
   // I'll flesh this out to a full parser soon.
   // Wallyho.
   //

   lpCmdFrom.b_Upgrade   = _tcsstr (szCmdLine, TEXT("upgrade")) ? TRUE : FALSE;
   lpCmdFrom.b_Cancel    = _tcsstr (szCmdLine, TEXT("cancel")) ?  TRUE : FALSE;
   lpCmdFrom.b_CDrom     = _tcsstr (szCmdLine, TEXT("cdrom")) ?   TRUE : FALSE;
   lpCmdFrom.b_MsiInstall= _tcsstr (szCmdLine, TEXT("MSI")) ?     TRUE : FALSE;

   if (osVer.dwMajorVersion >= 5){
      _itoa (osVer.dwBuildNumber, szCurBld, sizeof(szCurBld));
   }
    
   //
   // Load the build number in the szBld 
   // Variable.
   //
   GetBuildNumber (szBld);


   //
   // Generate a MachineID upfront to use later.
   //
   lpCmdFrom.dwRandomID = RandomMachineID();


   GetTargetFile (szFileToSave, szBld);
   if (!lpCmdFrom.b_Cancel){

      GetNTSoundInfo ();
      
      if (g_pfnWriteDataToFile)
		  g_pfnWriteDataToFile(szFileToSave, NULL, &lpCmdFrom);
      else 
         WriteMinimalData (szFileToSave);
   }
   else
      DeleteDatafile (szFileToSave);
   return 0;
}



VOID 
GlobalInit(VOID)
/*++

Author: Wallyho.
    
Routine Description:

   Initializes global Values.

Arguments:
   NONE
 
Return Value:

   NONE

--*/

{

//
// Do some global initializations.
//

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\exe\setuplogexe.h ===
/*++

   File:    setuplogEXE.h

   Purpose: To be inclusive of all header files
           without duplication.
  
   Revision History

   Created     Nov 15th, 1998    WallyHo
      Modified    Mar 31st, 1999    WallyHo  for MSI installs.

--*/
#ifndef SETUPLOG_H
#define SETUPLOG_H

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys\timeb.h>
#include <tchar.h>
#include <time.h>
#include <winperf.h>
//******togther for net_api_status ****
//
//*************************************
#include "setuplog.h" // save for DLL and XE

//
// Defines
//

#define DEBUG 0
#define SAVE_FILE "c:\\setuplog.ini"
#define MAX_WAVEOUT_DEVICES 2



//
// Struct Declarations
//

typedef struct _MULTIMEDIA{
   INT nNumWaveOutDevices;                            // # WaveOut Devices ie. # sound cards.
   TCHAR szWaveOutDesc[MAX_WAVEOUT_DEVICES][128];     // WaveOut description
   TCHAR szWaveDriverName[MAX_WAVEOUT_DEVICES][128];  // Wave Driver name
 } *LPMULTIMEDIA, MULTIMEDIA;

//
// GlowBall Variables.
//

#if DEBUG
   TCHAR       szMsgBox [ MAX_PATH ];
#endif
   MULTIMEDIA     m;
   TCHAR          szArch[ 20 ];
   TCHAR          szCPU[ 6 ];
   OSVERSIONINFO  osVer;


//
// GlowBall Statics to prevent multiple inclusions. W.HO
//

static   TCHAR szCurBld[10]   = {TEXT('\0')};
static   fnWriteData g_pfnWriteDataToFile = NULL;
static   LPTSTR szPlatform     = TEXT("Windows NT 5.0");
   



/*********** For GetTaskList *****************/

//
// manafest constants
//
#define TITLE_SIZE          64
#define PROCESS_SIZE        16

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         "software\\microsoft\\windows nt\\currentversion\\perflib"
#define REGSUBKEY_COUNTERS  "Counters"
#define PROCESS_COUNTER     "process"
#define PROCESSID_COUNTER   "id process"
#define UNKNOWN_TASK        "unknown"

//
// task list structure
//

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];

    ULONG       PeakVirtualSize;
    ULONG       VirtualSize;
    ULONG       PageFaultCount;
    ULONG       PeakWorkingSetSize;
    ULONG       WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;

} TASK_LIST, *PTASK_LIST;


typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


//
// Prototypes.
//

VOID     GetTargetFile (LPTSTR szOutPath, LPTSTR szBld);
VOID     GetNTSoundInfo(VOID);
VOID     ConnectAndWrite(LPTSTR MachineName, LPTSTR Buffer);
VOID     GetBuildNumber (LPTSTR szBld);
VOID     WriteMinimalData (LPTSTR szFileName);

VOID     DeleteDatafile (LPTSTR szDatafile);
DWORD    RandomMachineID(VOID);
VOID     GlobalInit(VOID);



// MSI stuff for Joehol
BOOL     IsMSI(VOID);
DWORD    GetTaskList( PTASK_LIST pTask,DWORD dwNumTasks);

#endif SETUPLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\inc\setuplog.h ===
// Definition of constants that the exe and the dll both use.
#define COMPUTERNAME    "COMPUTERNAME"
#define LOGSHARE_USER   "idwuser"
#define LOGSHARE_PW     "idwuser"

extern char * Days[];
extern char * Months[];


//
// GlowBalls
//
   TCHAR          g_szServerShare[ MAX_PATH ];
   BOOL           g_bServerOnline;

#define NUM_SERVERS 6

//
// Struct Declarations
//
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bOnline;
   DWORD dwTimeOut;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;


//
// For the DLL's WriteDataToFile
//
typedef struct _NT32_CMD_PARAMS {
   BOOL    b_Upgrade; 
   BOOL    b_Cancel; 
   BOOL    b_CDrom; 
   BOOL    b_MsiInstall;
   DWORD   dwRandomID;
} *LPNT32_CMD_PARAMS, NT32_CMD_PARAMS;


typedef void 
(*fnWriteData)
(IN LPTSTR szFileName,
 IN LPTSTR szFrom, 
 IN LPNT32_CMD_PARAMS lpCmdL
 );


   //
   // List of servers to search.
   //
static NT32_CMD_PARAMS lpCmdFrom = {FALSE,FALSE,FALSE,FALSE,0};  

#define TIME_TIMEOUT 10

static   SERVERS s[NUM_SERVERS] = {
      {TEXT("\\\\ntcore2\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\hctpro\\idwlog"),         FALSE, -1,-1},
      {TEXT("\\\\donkeykongjr\\idwlog"),   FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
   };
//
// Prototypes
//
BOOL  ServerOnlineThread(IN LPTSTR szServerFile);
BOOL  IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\lib\pnpstuff.h ===
#define BUFFER_LEN         200
#define REG_STR_LEN        100
#define NUM_LOG_CONF_TYPES 4
#define MAX_STR_LEN        300

typedef DWORD NEXTRET;

#define NR_SUCCESS 0x00000000
#define NR_DONE    0x00000001  // no more configurations
#define NR_INVALID 0x00000002  // invalid previous configuration

//
// Structures
//

//
// Stores information about a device's resource descriptors
//
typedef struct _RES_DES_DATA
{
   struct _RES_DES_DATA *Next;
   struct _RES_DES_DATA *Prev;

   PMEM_RESOURCE pmresMEMResource;
   PIO_RESOURCE  piresIOResource;
   PDMA_RESOURCE pdresDMAResource;
   PIRQ_RESOURCE pqresIRQResource;
} RES_DES_DATA, *PRES_DES_DATA;


//
// Stores registry and resource information about a device
//
typedef struct _DEV_INFO
{
   struct _DEV_INFO *Next;
   struct _DEV_INFO *Prev;

   TCHAR szDevNodeID[100];

   TCHAR szDescription[100];
   TCHAR szHardwareID[100];
   TCHAR szService[100];
   TCHAR szClass[100];
   TCHAR szManufacturer[100];
   TCHAR szConfigFlags[100];

   TCHAR szFriendlyName[100];

   PRES_DES_DATA prddForcedResDesData;
   PRES_DES_DATA prddAllocResDesData;
   PRES_DES_DATA prddBasicResDesData;
   PRES_DES_DATA prddBootResDesData;

   DEVNODE dnParent;

   RES_DES_DATA rddOrigConfiguration;
   BOOL boolSavedOrigConfiguration;

   BOOL boolConfigurable;
   BOOL boolDisabled;

} DEV_INFO, *PDEV_INFO;
void CollectDevData();

BOOL ParseEnumerator(IN PTCHAR szEnumBuffer);

BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer);

BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo);

BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData);


BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode);

void RecordFriendlyName(IN PDEV_INFO pdiDevInfo);

BOOL SaveAndDeletePreviousForcedLogConf(IN  LOG_CONF  lcLogConf,
                                        OUT PDEV_INFO pdiDevInfo);

BOOL GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
                   IN     LOG_CONF  lcLogConf,
                   IN     ULONG     ulLogConfType);

BOOL ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                       IN     RES_DES       rdResDes,
                       IN     RESOURCEID    ridResourceID);

BOOL UpdateDeviceList();

void DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes);

BOOL RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                        IN     ULONG     ulLogConfType);

void Cleanup();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\lib\netinfo.c ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include "pnpstuff.h"






//
// Globals
//

DEV_INFO *g_pdiDevList;          // Head of device list



/*++

Routine Description: (21) GetDevNodeInfoAndCreateNewDevInfoNode

   Creates new list node, then gets registry and resource information for
   a specific device and copies it into that node. Finally, adds new node
   to beginning of linked list

Arguments:

    dnDevNode:    the device to find information about
    szDevNodeID:  the registry path name of the device
    szEnumBuffer: name of enumerator this device is under

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer)
{
   LOG_CONF  lcLogConf = 0, lcLogConfNew;
   CONFIGRET cmret, cmret2;
   BOOL      boolForced;
   PDEV_INFO pdiDevInfo=(PDEV_INFO)malloc(sizeof(DEV_INFO));
   int       i;
   BOOL      boolForcedFound = FALSE, boolAllocFound = FALSE;
   USHORT    ushLogConfType[4] = {BOOT_LOG_CONF,
                                  ALLOC_LOG_CONF,
                                  BASIC_LOG_CONF,
                                  FORCED_LOG_CONF};

   if (pdiDevInfo == NULL)
   {

      goto RetFALSE;
   }

   //
   // If this is not a PnP device, skip it
   //
   if (!lstrcmpi(szEnumBuffer, TEXT("Root")))
   {
      free(pdiDevInfo);
      goto RetTRUE;

   }

   //
   // Initialize fields inside the node
   //
   if (!InitializeInfoNode(pdiDevInfo, szDevNodeID, dnDevNode))
   {
      //
      // This is a device we don't want to list. Skip it
      //
      free(pdiDevInfo);
      goto RetTRUE;
   }

   for (i = 0; i < NUM_LOG_CONF_TYPES; i++)
   {
      //
      // Get logical configuration information
      //
      cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                    dnDevNode,
                                    ushLogConfType[i]);

      while (CR_SUCCESS == cmret)
      {
         lcLogConf = lcLogConfNew;

         if (ALLOC_LOG_CONF == ushLogConfType[i])
         {
            boolAllocFound = TRUE;
         }

         if (!(GetResDesList(pdiDevInfo, lcLogConf, ushLogConfType[i])))
         {
            goto RetFALSE;
         }

         cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                      lcLogConf,
                                      0);

         cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      }
   }

   //
   // If device has no Alloc configurations, skip
   // to the next device
   //
   if (!boolAllocFound)
   {



      //free(pdiDevInfo);
      //goto RetTRUE;
   }

   //
   // Insert new pdiDevInfo into Linked List of DevNodes
   //
   if (g_pdiDevList == NULL)
   {
      //
      // DevList is empty
      //
      g_pdiDevList = pdiDevInfo;
   }
   else
   {
      //
      // Add new pdiDevInfo to beginning of linked list
      //
      pdiDevInfo->Next = g_pdiDevList;
      g_pdiDevList->Prev = pdiDevInfo;

      g_pdiDevList = pdiDevInfo;
   }

   RetTRUE:
   return TRUE;

   RetFALSE:
   return FALSE;

} /* GetDevNodeInfoAndCreateNewDevInfoNode */




/*++

Routine Description: (20) ParseEnumerator

   Gets devices listed under enumerator name in registry

Arguments:

    szEnumBuffer: the enumerator name

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL ParseEnumerator(IN PTCHAR szEnumBuffer)
{

  PTCHAR    szDevIDBuffer = NULL;
  PTCHAR    szDevNodeID = NULL;
  ULONG     ulDevIDBufferLen = 0, ulCount = 0, ulStart = 0;
  CONFIGRET cmret = CR_SUCCESS;
  DEVNODE   dnDevNode;

  //
  // Get buffer length
  //
  cmret = CM_Get_Device_ID_List_Size(&ulDevIDBufferLen,
                                     szEnumBuffer,
                                     CM_GETIDLIST_FILTER_ENUMERATOR);

  if (CR_SUCCESS != cmret)
  {
     //ErrorLog(20, TEXT("CM_Get_Device_ID_List_Size"), cmret, NULL);
     goto RetFALSE;
  }

  if ((szDevIDBuffer = malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL ||
      (szDevNodeID   = malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL)
  {
     goto RetFALSE;
  }

  //
  // Get the Device ID List
  //
  cmret = CM_Get_Device_ID_List(szEnumBuffer,
                                szDevIDBuffer,
                                ulDevIDBufferLen,
                                CM_GETIDLIST_FILTER_ENUMERATOR);

  if (CR_SUCCESS != cmret)
  {
     //ErrorLog(20, TEXT("CM_Get_Device_ID_List"), cmret, NULL);
     goto RetFALSE;
  }

  //
  // Note that ulDevIDBufferLen is a loose upper bound. The API may have
  // returned a size greater than the actual size of the list of strings.
  //
  for (ulCount = 0; ulCount < ulDevIDBufferLen; ulCount++)
  {
     ulStart = ulCount;

     if (szDevIDBuffer[ulCount] != '\0')
     {
        cmret = CM_Locate_DevNode(&dnDevNode,
                                  szDevIDBuffer + ulCount,
                                  CM_LOCATE_DEVNODE_NORMAL);

        //
        // Go to the next substring
        //
        while (szDevIDBuffer[ulCount] != TEXT('\0'))
        {
           ulCount++;
        
        }
        // Stop when we reach the double-NULL terminator
        
        if (szDevIDBuffer[ulCount+1] == TEXT('\0'))
        {
            ulCount=ulDevIDBufferLen;
            continue;
        }

        if (cmret == CR_SUCCESS)
        {
           wsprintf(szDevNodeID, TEXT("%s"), szDevIDBuffer + ulStart);

           //
           // Found the DevNode, so add its information to the device list
           //
           if (!(GetDevNodeInfoAndCreateNewDevInfoNode(dnDevNode,
                                                       szDevNodeID,
                                                       szEnumBuffer)))
           {
             goto RetFALSE;
           }
        }
     }
  }

  return TRUE;

  RetFALSE:

  return FALSE;

} /* Parse Enumerator */




void CollectDevData()
{
   CONFIGRET cmret = CR_SUCCESS;
   ULONG     ulIndexNum = 0;
   ULONG     ulEnumBufferLen = 0;
   PTCHAR    szEnumBuffer;

   szEnumBuffer = malloc(sizeof(TCHAR) * MAX_DEVNODE_ID_LEN);

   for (ulIndexNum = 0; cmret == CR_SUCCESS; ulIndexNum++)
   {
      ulEnumBufferLen = MAX_DEVNODE_ID_LEN;
      cmret = CM_Enumerate_Enumerators(ulIndexNum,
                                       szEnumBuffer,
                                       &ulEnumBufferLen,
                                       0);

      if (cmret == CR_SUCCESS)
      {
         ParseEnumerator(szEnumBuffer);
      }
   }

} /* CollectDevData */



/*++

Routine Description: (22) CopyRegistryLine

   Copies one specific string of registry data to new list node

Arguments:

    dnDevNode:      the device to get information about
    ulpropertyType: which registry string to get
    pdiDevInfo:     the new list node

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo)
{
   ULONG     ulRegDataLen = 0, ulRegDataType = 0;
   CONFIGRET cmret = CR_SUCCESS;
   PTCHAR    szRegData = NULL;

   //
   // Get the length of the buffer  don't bother checking return value
   // If RegProperty doesn't exist, we'll just move on
   //
   CM_Get_DevNode_Registry_Property(dnDevNode,
                                    ulPropertyType,
                                    NULL,
                                    NULL,
                                    &ulRegDataLen,
                                    0);

   if (!ulRegDataLen ||
       (szRegData = malloc(sizeof(TCHAR) * ulRegDataLen)) == NULL)
   {
      goto RetFALSE;
   }

   //
   // Now get the registry information
   //
   cmret = CM_Get_DevNode_Registry_Property(dnDevNode,
                                            ulPropertyType,
                                            &ulRegDataType,
                                            szRegData,
                                            &ulRegDataLen,
                                            0);

   if (CR_SUCCESS == cmret)
   {
      if (!(CopyRegDataToDevInfoNode(pdiDevInfo,
                                     ulPropertyType,
                                     szRegData)))
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyRegistryLine */




/*++

Routine Description: (23) CopyRegDataToDevInfoNode

   Copies a registry string to a list node

Arguments:

    pdiDevInfo:     the new list node
    ulPropertyType: which registry string to copy
    szRegData:      the data to be copied

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData)
{
   if (pdiDevInfo == NULL)
   {
      goto RetFALSE;
   }

   switch (ulPropertyType)
   {
      case CM_DRP_DEVICEDESC:

         wsprintf(pdiDevInfo->szDescription, TEXT("%s"), szRegData);
         break;

      case CM_DRP_HARDWAREID:

         wsprintf(pdiDevInfo->szHardwareID, TEXT("%s"), szRegData);
         break;

      case CM_DRP_SERVICE:

         wsprintf(pdiDevInfo->szService, TEXT("%s"), szRegData);
         break;

      case CM_DRP_CLASS:

         wsprintf(pdiDevInfo->szClass, TEXT("%s"), szRegData);
         break;

      case CM_DRP_MFG:

         wsprintf(pdiDevInfo->szManufacturer, TEXT("%s"), szRegData);
         break;

      case CM_DRP_CONFIGFLAGS:

         wsprintf(pdiDevInfo->szConfigFlags, TEXT("%s"), szRegData);
         break;



//         Log(23, SEV2, TEXT("Invalid property type"));
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyRegDataToDevInfoNode */




/*++

Routine Description: (58) InitializeInfoNode

   Initialized fields inside the new node

Arguments:

    pdiDevInfo:  the node
    szDevNodeID: used to find the dnDevNode in the future
    dnDevNode:   the device we're storing information about

Return Value:

    BOOL: TRUE if we should keep this node, FALSE if we should throw it away

--*/
BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode)
{
   if (pdiDevInfo)
   {
      pdiDevInfo->Next = NULL;
      pdiDevInfo->Prev = NULL;

      pdiDevInfo->szDevNodeID[0]    = '\0';
      pdiDevInfo->szDescription[0]  = '\0';
      pdiDevInfo->szHardwareID[0]   = '\0';
      pdiDevInfo->szService[0]      = '\0';
      pdiDevInfo->szClass[0]        = '\0';
      pdiDevInfo->szManufacturer[0] = '\0';
      pdiDevInfo->szConfigFlags[0]  = '\0';
      pdiDevInfo->szFriendlyName[0] = '\0';

      pdiDevInfo->boolSavedOrigConfiguration = FALSE;
      pdiDevInfo->boolDisabled = FALSE;

      pdiDevInfo->prddForcedResDesData = NULL;
      pdiDevInfo->prddAllocResDesData  = NULL;
      pdiDevInfo->prddBasicResDesData  = NULL;
      pdiDevInfo->prddBootResDesData   = NULL;

      //
      // Store devNodeID in pdiDevInfo to get handles to devnode in future
      //
      wsprintf(pdiDevInfo->szDevNodeID, TEXT("%s"), szDevNodeID);

      //
      // Extract information from the registry about this DevNode
      //
      CopyRegistryLine(dnDevNode, CM_DRP_DEVICEDESC,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_HARDWAREID,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_SERVICE,     pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CLASS,       pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_MFG,         pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CONFIGFLAGS, pdiDevInfo);

      RecordFriendlyName(pdiDevInfo);
   }

   //
   // Check the friendly name to see if we want to throw this node away
   //
   if (strcmp(pdiDevInfo->szFriendlyName, "STORAGE/Volume") == 0 ||
       strcmp(pdiDevInfo->szFriendlyName, "Unknown Device") == 0)

   {
      return FALSE;
   }

   return TRUE;

} /* InitializeInfoNode */




/*++

Routine Description: (57) RecordFriendlyName

   Finds the best user friendly name for this device

Arguments:

    pdiDevInfo: node containing all possible names

Return Value:

    void

--*/
void RecordFriendlyName(IN PDEV_INFO pdiDevInfo)
{
   if (pdiDevInfo)
   {
      if (pdiDevInfo->szDescription &&
          pdiDevInfo->szDescription[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szDescription);
      }
      else if (pdiDevInfo->szHardwareID &&
               pdiDevInfo->szHardwareID[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szHardwareID);
      }
      else if (pdiDevInfo->szManufacturer &&
               pdiDevInfo->szManufacturer[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szHardwareID);
      }
      else if (pdiDevInfo->szService &&
               pdiDevInfo->szService[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szService);
      }
      else if (pdiDevInfo->szClass &&
               pdiDevInfo->szClass[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szClass);
      }
      else
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("Unknown Device"));
      }
   }

} /* RecordFriendlyName */





/*++

Routine Description: (24) GetResDesList

   Creates new resource data node and copies resource information to that node

Arguments:

    pdiDevInfo:    the list node which will contain the new resource node
    lcLogConf:     the logical configuration information
    ulLogConfType: FORCED, ALLOC, BOOT, or BASIC logical configuration

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
                   IN     LOG_CONF  lcLogConf,
                   IN     ULONG     ulLogConfType)
{
   CONFIGRET     cmret, cmret2;
   RES_DES       rdResDes = 0, rdResDesNew;
   RESOURCEID    ridResourceID = 0;
   PRES_DES_DATA prddResDesData;

   prddResDesData = (PRES_DES_DATA)malloc(sizeof(RES_DES_DATA));

   if (prddResDesData == NULL)
   {
//      Log(24, SEV2, TEXT("ResDesData malloc failed."));
      goto RetFALSE;
   }

   prddResDesData->Next = NULL;
   prddResDesData->Prev = NULL;

   prddResDesData->pmresMEMResource = NULL;
   prddResDesData->piresIOResource = NULL;
   prddResDesData->pdresDMAResource = NULL;
   prddResDesData->pqresIRQResource = NULL;


   cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                               lcLogConf,
                               ResType_All,
                               &ridResourceID,
                               0);

   //
   // Go through each resource type and copy data to new node
   //
   while (CR_SUCCESS == cmret)
   {
      rdResDes = rdResDesNew;

      if (ridResourceID >= ResType_Mem && ridResourceID <= ResType_IRQ)
      {
         if (!(ProcessResDesInfo(prddResDesData,
                                 rdResDes,
                                 ridResourceID)))
         {
            goto RetFALSE;
         }
      }

      cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                                  rdResDes,
                                  ResType_All,
                                  &ridResourceID,
                                  0);

      cmret2 = CM_Free_Res_Des_Handle(rdResDes);

      if (cmret2 != CR_SUCCESS)
      {
         //ErrorLog(24, TEXT("CM_Free_Res_Des_Handle"), cmret2, NULL);
      }
   }

   //
   // **** change this by making resDesData = pdiDevInfo->----ResDesDAta
   //      and merging into one code
   //

   //
   // Add the new node to the linked list
   //
   switch (ulLogConfType)
   {
      case FORCED_LOG_CONF:

         if (!pdiDevInfo->prddForcedResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddForcedResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddForcedResDesData;
            pdiDevInfo->prddForcedResDesData->Prev = prddResDesData;

            pdiDevInfo->prddForcedResDesData = prddResDesData;
         }
         break;

      case ALLOC_LOG_CONF:

         if (!pdiDevInfo->prddAllocResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddAllocResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddAllocResDesData;
            pdiDevInfo->prddAllocResDesData->Prev = prddResDesData;

            pdiDevInfo->prddAllocResDesData = prddResDesData;
         }
         break;

      case BASIC_LOG_CONF:

         if (!pdiDevInfo->prddBasicResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddBasicResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddBasicResDesData;
            pdiDevInfo->prddBasicResDesData->Prev = prddResDesData;

            pdiDevInfo->prddBasicResDesData = prddResDesData;
         }
         break;

      case BOOT_LOG_CONF:

         if (!pdiDevInfo->prddBootResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddBootResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddBootResDesData;
            pdiDevInfo->prddBootResDesData->Prev = prddResDesData;

            pdiDevInfo->prddBootResDesData = prddResDesData;
         }
         break;

      default:

//         Log(24, SEV2, TEXT("Illegal LogConfType\n - %ul"), ulLogConfType);
         goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* GetResDestList */




/*++

Routine Description: (25) ProcessResDesInfo

   Gets information for one resource descriptor

Arguments:

    prddResDesData: the new resource data node receiving the info
    rdResDes:       the resource descriptor containing the info
    ridResourceID:  tells the resource type (DMA, IO, MEM, IRQ, or CS)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                       IN     RES_DES       rdResDes,
                       IN     RESOURCEID    ridResourceID)
{
   PVOID     pvResDesDataBuffer = NULL;
   ULONG     ulResDesDataBufferLen;
   CONFIGRET cmret;

   cmret = CM_Get_Res_Des_Data_Size(&ulResDesDataBufferLen,
                                    rdResDes,
                                    0);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data_Size"), cmret, NULL);
      goto RetFALSE;
   }

   if ((pvResDesDataBuffer = malloc(sizeof(PVOID) * ulResDesDataBufferLen))
        == NULL)
   {
//      Log(25, SEV2, TEXT("resDesDataBuffer malloc size of %d failed."),
  //                  ulResDesDataBufferLen);
      goto RetFALSE;
   }

   //
   // Get the data
   //
   cmret = CM_Get_Res_Des_Data(rdResDes,
                               pvResDesDataBuffer,
                               ulResDesDataBufferLen,
                               0);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Copy data into ResDesData node
   //
   switch (ridResourceID)
   {
      case ResType_Mem:

         prddResDesData->pmresMEMResource = (PMEM_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_IO:

         prddResDesData->piresIOResource = (PIO_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_DMA:

         prddResDesData->pdresDMAResource = (PDMA_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_IRQ:

         prddResDesData->pqresIRQResource = (PIRQ_RESOURCE)pvResDesDataBuffer;
         break;

      default:

//         Log(25, SEV2, TEXT("Illegal ResourceID - %ul"), ridResourceID);
         goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* ProcessResDesInfo */




/*++

Routine Description: (26) UpdateDeviceList

    Frees resource information for all devices and then collects the
    information again

Arguments:

    none (g_pdiDevList is global head of device list)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL UpdateDeviceList()
{
   PDEV_INFO pdiTmpDevInfo;

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Go through linked list and delete each node's ResDes lists
   //
   while (pdiTmpDevInfo)
   {
      if (pdiTmpDevInfo->prddForcedResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddForcedResDesData);
         pdiTmpDevInfo->prddForcedResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddAllocResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddAllocResDesData);
         pdiTmpDevInfo->prddAllocResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBasicResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBasicResDesData);
         pdiTmpDevInfo->prddBasicResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBootResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBootResDesData);
         pdiTmpDevInfo->prddBootResDesData = NULL;
      }

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Recreate the ResDesLists for each node
   //
   while (pdiTmpDevInfo)
   {
      if (!(RecreateResDesList(pdiTmpDevInfo, FORCED_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, ALLOC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BASIC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BOOT_LOG_CONF)))
         goto RetFALSE;

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* UpdateDeviceList */




/*++

Routine Description: (27) DeleteResDesDataNode

    Deletes a string of RES_DES_DATA structures

Arguments:

    prddTmpResDes: the head of the linked list

Return Value:

    void

--*/
void DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes)
{
   PRES_DES_DATA prddNextResDes;

   while (prddTmpResDes)
   {
      prddNextResDes = prddTmpResDes->Next;

      free (prddTmpResDes);

      prddTmpResDes = prddNextResDes;
   }

} /* DeleteResDesDataNode */



/*++

Routine Description: (56) CopyDataToLogConf

   Calls CM_Add_Res_Des to add a resDes to a lcLogConf

Arguments:

    lcLogConf:     the lcLogConf receiving the resDes
    ridResType:    ResType_Mem, IO, DMA or IRQ
    pvResData:     the new data
    ulResourceLen: size of the data

Return Value:

    BOOL: TRUE if the CM call succeeds, FALSE if not

--*/
BOOL CopyDataToLogConf(IN LOG_CONF   lcLogConf,
                       IN RESOURCEID ridResType,
                       IN PVOID      pvResData,
                       IN ULONG      ulResourceLen)
{
   CONFIGRET cmret;
   RES_DES   rdResDes;

   //
   // Copy the data to the logConf
   //
   cmret = CM_Add_Res_Des(&rdResDes,
                          lcLogConf,
                          ridResType,
                          pvResData,
                          ulResourceLen,
                          0);

   if (CR_SUCCESS != cmret)
   {

      goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyDataToLogConf */



/*++

Routine Description: (28) RecreateResDesList

    Uses CM calls to find ResDes information and creates linked list
    of this information inside of given DEV_INFO

Arguments:

    pdiTmpDevInfo: the node receiving the information
    ulLogConfType: the LogConf type (FORCED_LOG_CONF,
                                     ALLOC_LOG_CONF,
                                     BASIC_LOG_CONF,
                                     BOOT_LOG_CONF)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                        IN     ULONG     ulLogConfType)
{
   CONFIGRET cmret, cmret2;
   DEVNODE   dnDevNode;
   LOG_CONF  lcLogConf, lcLogConfNew;

   //
   // Get handle to the devnode
   //
   cmret = CM_Locate_DevNode(&dnDevNode,
                             pdiTmpDevInfo->szDevNodeID,
                             CM_LOCATE_DEVNODE_NORMAL);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(28, TEXT("CM_Locate_DevNode"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Get logical configuration information
   //
   cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                 dnDevNode,
                                 ulLogConfType);

   while (CR_SUCCESS == cmret)
   {
      lcLogConf = lcLogConfNew;

      if (!(GetResDesList(pdiTmpDevInfo, lcLogConf, ulLogConfType)))
      {
         goto RetFALSE;
      }

      cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                   lcLogConf,
                                   0);

      cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      if (CR_SUCCESS != cmret2)
      {
         //ErrorLog(28, TEXT("CM_Free_Log_Conf"), cmret2, NULL);
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* RecreateResDesList */





void Cleanup()
{
   PDEV_INFO pdiDevInfo = g_pdiDevList;
   PDEV_INFO pdiNextInfoNode;



   while (pdiDevInfo)
   {

      pdiNextInfoNode = pdiDevInfo->Next;

      DeleteResDesDataNode(pdiDevInfo->prddForcedResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddAllocResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBasicResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBootResDesData);

      free(pdiDevInfo);

      pdiDevInfo = pdiNextInfoNode;
   }

} /* Cleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cdburn\cue.h ===
typedef struct CUE_SHEET_LINE {
    UCHAR Address : 4;
    UCHAR Control : 4;

    UCHAR TrackNumber;

    UCHAR Index;

    UCHAR MainDataForm : 6;
    UCHAR SubChannelDataForm : 2;

    UCHAR Reserved : 7;
    UCHAR ScmsAlternateCopyBit : 1;

    UCHAR Min;
    UCHAR Sec;
    UCHAR Frame;
} CUE_SHEET_LINE, *PCUE_SHEET_LINE;

//
// Cue sheet control bit definitions.  Choose no more than one from each group.
//

#define CUE_CTL_2CH_AUDIO_TRACK         0x0
#define CUE_CTL_DATA_TRACK              0x4
#define CUE_CTL_4CH_AUDIO_TRACK         0x8

#define CUE_CTL_NO_PRE_EMPHASIS         0x0
#define CUE_CTL_PRE_EMPHASIS            0x1

#define CUE_CTL_DIGITAL_COPY_PROHIBITED 0x0
#define CUE_CTL_DIGITAL_COPY_PERMITTED  0x2

//
// Cue sheet address values.  Cannot be mixed.
//

#define CUE_ADR_TRACK_INDEX             0x1
#define CUE_ADR_CATALOG_CODE            0x2
#define CUE_ADR_ISRC_CODE               0x3

//
// Values for the main data form.
//

// CD-DA Data Form:
#define CUE_FORM_CDDA_SDATA_2048        0x00
#define CUE_FORM_CDDA_IDATA_0           0x01

// CD Mode 1 Forms:
//  S = initiator send data
//  G = initiator doesn't send data but LUN generates it
//  I = initiator sends data but LUN ignores it and generates its own
//
//  DATA = 2048 byte data frame
//  ECC = 288 byte ECC data
//
//  trailing number is the number of bytes expected to be sent by the initiator
//

#define CUE_FORM_MODE1_SDATA_GECC_2048  0x10
#define CUE_FORM_MODE1_SDATA_IECC_2352  0x11
#define CUE_FORM_MODE1_IDATA_GECC_2048  0x12
#define CUE_FORM_MODE1_IDATA_IECC_2352  0x13
#define CUE_FORM_MODE1_GDATA_GECC_0     0x14

// CD-XA, CD-I Forms:
// SY = sync header of 16 bytes
// SU = sub header of 8 bytes
// DATA<n> = data frame of <n> bytes
// ECC<n> = EDC/ECC area of <n> bytes
//
// trailing number is the number of bytes expected to be sent by the initiator
//

#define CUE_FORM_XA1_GSY_SSU_SDATA2048_IECC280_2336     0x20
#define CUE_FORM_XA2_GSY_SSU_SDATA2324_IECC4_2336       0x20

#define CUE_FORM_XA1_ISY_SSU_SDATA2048_IECC280_2352     0x21
#define CUE_FORM_XA2_ISY_SSU_SDATA2324_IECC4_2352       0x21

#define CUE_FORM_XA1_GSY_SSU_IDATA2048_IECC280_2336     0x22
#define CUE_FORM_XA2_GSY_SSU_IDATA2324_IECC4_2336       0x22

#define CUE_FORM_XA1_ISY_SSU_IDATA2048_IECC280_2352     0x23
#define CUE_FORM_XA2_ISY_SSU_IDATA2324_IECC4_2352       0x23

#define CUE_FORM_XA2_GSY_GSU_GDATA2324_GECC4_0          0x24

// CD-ROM Mode 2 Forms:
// SY = sync header of 16 bytes
// DATA = data frame of 2336 bytes

#define CUE_FORM_MODE2_GSY_SDATA_2336   0x30
#define CUE_FORM_MODE2_ISY_SDATA_2352   0x31
#define CUE_FORM_MODE2_GSY_IDATA_2336   0x32
#define CUE_FORM_MODE2_ISY_IDATA_2352   0x33
#define CUE_FORM_MODE2_GSY_GDATA_0      0x34

//
// Data form of sub channel data.
//

#define CUE_SCFORM_ZEROED_0     0x0
#define CUE_SCFORM_RAW_96       0x1
#define CUE_SCFORM_PACKED_96    0x3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cdburn\burn.h ===
/*
*/

//#include "sptlib.h"

#include <windows.h>  // sdk
#include <devioctl.h> // sdk
#include <ntddscsi.h> // sdk
#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ntddcdvd.h>


#include "cue.h"

typedef struct _OPTIONS {
    ULONG TestBurn             :  1;
    ULONG Erase                :  1;
    ULONG SessionAtOnce        :  1;
    ULONG PrintWrites          :  1;
    ULONG NoPostgap            :  1;
    ULONG Reserved             :  3;
    ULONG BurnSpeed            :  8;  // don't limit to 4x
    ULONG Reserved1            : 16;
    PUCHAR DeviceName ;
    PUCHAR ImageName  ;
} OPTIONS, *POPTIONS;


#define OPTIONS_FLAG_BURN_SPEED_INVALID 0x00
#define OPTIONS_FLAG_BURN_SPEED_DEFAULT 0x04
#define OPTIONS_FLAG_BURN_SPEED_MAX     0xff


typedef struct _CDVD_BUFFER_CAPACITY {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR TotalLength[4];
    UCHAR BlankLength[4];
} CDVD_BUFFER_CAPACITY, *PCDVD_BUFFER_CAPACITY;

typedef struct _CDVD_WRITE_PARAMETERS_PAGE {
    UCHAR PageCode : 6; // 0x05
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;   // 0x32
    UCHAR WriteType : 4;
    UCHAR TestWrite : 1;
    UCHAR LinkSizeValid : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2 : 1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR FixedPacket : 1;
    UCHAR MultiSession :2;
    UCHAR DataBlockType : 4;
    UCHAR Reserved3 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode : 7;
    UCHAR Reserved5           : 1;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7               : 7;
    UCHAR MediaCatalogNumberValid : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8 : 7;
    UCHAR ISRCValid : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
    UCHAR Data[0];
} CDVD_WRITE_PARAMETERS_PAGE, *PCDVD_WRITE_PARAMETERS_PAGE;

typedef struct MSF {
    UCHAR Min;
    UCHAR Sec;
    UCHAR Frame;
} MSF, *PMSF;

__inline
MSF
LbaToMsf(
    IN ULONG Lba
    )
{
    ULONG m, s, f;
    MSF msf;

    m = (Lba / (75 * 60));
    Lba %= (75 * 60);

    s = (Lba / 75);
    f = (Lba % 75);

    msf.Min = (UCHAR) m;
    msf.Sec = (UCHAR) s;
    msf.Frame = (UCHAR) f;

    return msf;
}

__inline
MSF
AddMsf(
    MSF Msf1,
    MSF Msf2
    )
{
    ULONG m = 0, s = 0, f = 0;
    MSF total;

    f = Msf1.Frame + Msf2.Frame;
    if(f >= 75) {
        f -= 75;
        s += 1;
    }

    s = Msf1.Sec + Msf2.Sec;
    if(s >= 60) {
        s -= 60;
        m += 1;
    }

    m = Msf1.Min + Msf2.Min;

    total.Min = (UCHAR) m;
    total.Sec = (UCHAR) s;
    total.Frame = (UCHAR) f;

    return total;
}

DWORD
BurnCommand(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle
    );

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN ULONG NumberOfBlocks,
    IN ULONG FirstLba,
    IN ULONG AdditionalZeroSectors
    );

BOOLEAN
CloseSession(
    IN HANDLE  CdromHandle
    );

BOOLEAN
CloseTrack(
    IN HANDLE CdromHandle,
    IN LONG   Track
    );

BOOLEAN
GetNextWritableAddress(
    IN HANDLE CdromHandle,
    IN UCHAR Track,
    OUT PLONG NextWritableAddress,
    OUT PLONG AvailableBlocks
    );

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    );

BOOLEAN
SendOptimumPowerCalibration(
    IN HANDLE CdromHandle
    );

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    );

BOOLEAN
SetRecordingSpeed(
    IN HANDLE CdromHandle,
    IN DWORD Speed
    );

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    );

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PLONG NumberOfBlocks
    );

BOOLEAN
EraseTargetMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
BurnTrack(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    LONG NumberOfBlocks
    );

BOOLEAN
BurnDisk(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    LONG NumberOfBlocks
    );

BOOLEAN
SendCueSheet(
    IN HANDLE CdromHandle,
    IN ULONG NumberOfBlocks
    );

BOOLEAN
BurnLeadIn(
    IN HANDLE CdromHandle
    );

BOOLEAN
SendWriteCommand(
    IN HANDLE CdromHandle,
    IN LONG Block,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PVOID SenseData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cdburn\burn.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    burn.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <windows.h>
#include <strsafe.h>

#include "burn.h"
#include "sptlib.h"

OPTIONS gOptions;

#define MAX_CD_IMAGE_SIZE  (700 * 1024 * 1024)

#define LEAD_IN_SIZE 150
#define POST_GAP_SIZE 150

#define DEFAULT_WRITE_SIZE  (64 * 1024)

#define IS_TEST_BURN       FALSE

#define BLOCKS_FROM_BYTES(B) ((B) >> 11)
#define BYTES_FROM_BLOCKS(B) ((B) << 11)

typedef struct _SENSE_STUFF {
    UCHAR Sense;
    UCHAR Asc;
    UCHAR Ascq;
    UCHAR Reserved;
} SENSE_STUFF, *PSENSE_STUFF;

SENSE_STUFF AllowedBurnSense[] = {
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0},
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0}
};
#define AllowedBurnSenseEntries (sizeof(AllowedBurnSense)/sizeof(SENSE_STUFF))

SENSE_STUFF AllowedReadDiscInfo[] = {
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_FORMAT_IN_PROGRESS,     0 },
    { SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK,     0, 0                },
    { SCSI_SENSE_UNIT_ATTENTION,  SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION, 0, 0                }
};
#define AllowedReadDiscInfoEntries (sizeof(AllowedReadDiscInfo)/sizeof(SENSE_STUFF))

BOOLEAN
IsSenseDataInTable(
    IN PSENSE_STUFF Table,
    IN LONG         Entries, // in table
    IN PSENSE_DATA  SenseData
    )
{
    LONG i;
    UCHAR sense = SenseData->SenseKey & 0xf;
    UCHAR asc   = SenseData->AdditionalSenseCode;
    UCHAR ascq  = SenseData->AdditionalSenseCodeQualifier;

    for (i = 0; i < Entries; i++ ) {
        if ((Table[i].Sense == sense) &&
            (Table[i].Ascq  == ascq ) &&
            (Table[i].Asc   == asc  )
            ) {
            return TRUE;
        }
    }
    return FALSE;
}


__inline
DWORD
MakeCdSpeed(
    IN DWORD Speed
    )
{
    Speed *= (75 * 2352); // this makes it the proper speed
    Speed +=  500;        // rounding...
    Speed /= 1000;        // yes, this is by 1000, not 1024!
    return Speed;
}



#if DBG
    #define OUTPUT stderr
    #define FPRINTF(x) fprintf x
    #define PRINTBUFFER(x) PrintBuffer x
#else
    #define OUTPUT stdout
    #define FPRINTF(x)
    #define PRINTBUFFER(x)
#endif

VOID
InitializeOptions(
    )
{
    RtlZeroMemory(&gOptions, sizeof(OPTIONS));
    gOptions.BurnSpeed = OPTIONS_FLAG_BURN_SPEED_DEFAULT;
    return;
}

BOOLEAN
ParseCommandLine(
    IN DWORD Count,
    IN PUCHAR Arguments[]
    )
{
    DWORD i;

    HRESULT hr;

    InitializeOptions();

    for(i = 0; i < Count; i++) {

        //
        // If the first character of the argument is a - or a / then
        // treat it as an option.
        //

        if ((Arguments[i][0] == '/') || (Arguments[i][0] == '-')) {

            BOOLEAN validArgument = FALSE;

            Arguments[i][0] = '-'; // allow use of both dash and slash


            if (_strnicmp(Arguments[i], "-speed", strlen("-speed")) == 0)
            {
                LONG tempSpeed;
                //
                // requires another argument, which is the requested speed
                //

                i++; // increment i due to use of second arg

                if (i >= Count)
                {
                    printf("Argument <n> required for '-speed <n>' option, either "
                           "'max' or a decimal number\n");
                } else
                if (_strnicmp(Arguments[i], "max", strlen("max")) == 0)
                {
                    tempSpeed = OPTIONS_FLAG_BURN_SPEED_MAX;
                    validArgument = TRUE;
                } else
                {
                    tempSpeed = atoi(Arguments[i]);
                    if (tempSpeed > 0)
                    {
                        validArgument = TRUE;
                    } else
                    {
                        printf("%s is not a valid speed.  Either 'max' or a positive "
                               "decimal value is requred\n", Arguments[i]);
                    }
                }
                // if
                if (validArgument)
                {
                    gOptions.BurnSpeed = tempSpeed;
                    if (tempSpeed > OPTIONS_FLAG_BURN_SPEED_MAX)
                    {
                        tempSpeed = OPTIONS_FLAG_BURN_SPEED_MAX;
                    }

                    if (gOptions.BurnSpeed == OPTIONS_FLAG_BURN_SPEED_MAX)
                    {
                        printf("Requesting burn at maximum speed\n");
                    } else
                    {
                        printf("Requesting burn at %d speed\n",
                               gOptions.BurnSpeed);
                    }
                }
                // end speed adjustment
            } else
            if (_strnicmp(Arguments[i], "-test", strlen("-test")) == 0)
            {
                printf("Test burn only\n");
                gOptions.TestBurn = 1;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-erase", strlen("-erase")) == 0) {
                printf("Erasing media before burning\n");
                gOptions.Erase = TRUE;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-sao", strlen("-sao")) == 0) {
                printf("Burning image in Session-At-Once (cue-sheet) mode\n");
                gOptions.SessionAtOnce = TRUE;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-print", strlen("-print")) == 0) {
                printf("Printing writes to screen rather than sending them to device\n");
                gOptions.PrintWrites = TRUE;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-imagehaspostgap", strlen("-imagehaspostgap")) == 0) {
                printf("Not adding 150 sector postgap (must be part of image)\n");
                gOptions.NoPostgap = TRUE;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-?", strlen("-?")) == 0) {
                printf("Requesting help\n");
            } else
            {
                printf("Unknown option -- %s\n", Arguments[i]);
            }

            if(!validArgument)
            {
                return FALSE;
            }

        } else if(gOptions.DeviceName == NULL) {

            //
            // The first non-flag argument is the device name.
            //

            gOptions.DeviceName = Arguments[i];

        } else if(gOptions.ImageName == NULL) {

            //
            // The second non-flag argument is the image name.  This is
            // optional if the -erase flag has been provided.
            //

            gOptions.ImageName = Arguments[i];

        } else {

            //
            // Too many non-flag arguments provided.  This must be an error.
            //

            printf("Error: extra argument %s not expected\n", Arguments[i]);
            return FALSE;
        }
    }

    //
    // Validate the command-line arguments.
    //

    if(gOptions.DeviceName == NULL)
    {
        return FALSE;
    }

    if((gOptions.ImageName == NULL) && (!gOptions.Erase))
    {
        printf("Error: must supply image name if not erasing media\n");
        return FALSE;
    }

    return TRUE;
}

int __cdecl main(int argc, char *argv[])
{
    int i = 0;

    HANDLE cdromHandle;
    HANDLE isoImageHandle;
    HRESULT hr;
    char buffer[120]; // ~50 chars for mountvol names

    if(argc < 3) {
usage:
        printf("Usage:\n"
               "\tcdburn <drive> -erase [image [options]]\n"
               "\tcdburn <drive> image [options]\n"
               "Options:\n"
               "\t-erase            Erases the disk before burning (valid for R/W only)\n"
               "\t-sao              Writes the image out in \"session at once\", or cue\n"
               "\t                  sheet, mode (default is \"track at once\")\n"
               "\t-speed            Speed of burn, or 'max' for maximum speed\n"
               //"\t-test          Test burn only, no actual burning\n"
               //"\t-print         [DEBUG] print writes, but not send (UNSUPPORTED)\n"
               "\t-imagehaspostgap  Use if your image already contains a 150 sector postgap\n"
               "\tThe [image] must be provided unless the -erase flag is set.\n"
               "\tIf both an image and -erase are provided, the media will be\n"
               "\terased prior to burning the image to the disc.\n"
               );
        return -1;
    }

    //
    // Parse the command line options.
    //

    if(!ParseCommandLine(argc - 1, argv + 1)) {
        goto usage;
    }

    hr = StringCchPrintf(buffer,
                         sizeof(buffer)/sizeof(buffer[0]),
                         "\\\\.\\%s",
                         gOptions.DeviceName);
    if (!SUCCEEDED(hr)) {
        printf("Device name too long\n");
        return -1;
    }

    cdromHandle = CreateFile(buffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if(cdromHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    if (!SptUtilLockVolumeByHandle(cdromHandle, TRUE)) {
        printf("Unable to lock the volume for exclusive access %d\n",
               GetLastError());
        return -3;
    }

    //
    // If an image name was provided then attempt to open it too
    //

    if(gOptions.ImageName != NULL) {

        isoImageHandle = CreateFile(gOptions.ImageName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
                                    NULL);
        if (isoImageHandle == INVALID_HANDLE_VALUE) {
            printf("Error %d opening image file %s\n",
                    GetLastError(), gOptions.ImageName);
            CloseHandle(cdromHandle);
            return -4;
        }

    } else {
        isoImageHandle = INVALID_HANDLE_VALUE;
    }

    BurnCommand(cdromHandle, isoImageHandle);

    if (isoImageHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(isoImageHandle);
        isoImageHandle = INVALID_HANDLE_VALUE;
    }
    if (cdromHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(cdromHandle);
        cdromHandle = INVALID_HANDLE_VALUE;
    }

    return 0;
}

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    )
{
    DWORD offset = 0;
    PUCHAR buf = Buffer;

    while (Size > 0x10) {
        printf("%08x:"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "\n",
               offset,
               *(buf +  0), *(buf +  1), *(buf +  2), *(buf +  3),
               *(buf +  4), *(buf +  5), *(buf +  6), *(buf +  7),
               *(buf +  8), *(buf +  9), *(buf + 10), *(buf + 11),
               *(buf + 12), *(buf + 13), *(buf + 14), *(buf + 15)
               );
        Size -= 0x10;
        offset += 0x10;
        buf += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *buf);
            spaceIt++;
            buf++;
        }
        printf("\n");

    }
    return;


}

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PLONG NumberOfBlocks
    )
{
    BY_HANDLE_FILE_INFORMATION isoImageInfo;

    if (!GetFileInformationByHandle(IsoImageHandle, &isoImageInfo)) {
        FPRINTF((OUTPUT, "Error %d getting file info for iso image\n",
                 GetLastError()));
        return FALSE;
    }

    if (isoImageInfo.nFileSizeHigh != 0) {
        FPRINTF((OUTPUT, "Error: File too large\n"));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    if ((isoImageInfo.nFileSizeLow % 2048) != 0) {
        FPRINTF((OUTPUT, "Error: The file size is not a multiple of 2048 (%I64d)\n",
                 isoImageInfo.nFileSizeLow));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    FPRINTF((OUTPUT, "File size is %d bytes (%d blocks)\n",
             isoImageInfo.nFileSizeLow,
             isoImageInfo.nFileSizeLow / 2048
             ));

    *NumberOfBlocks = isoImageInfo.nFileSizeLow / 2048;
    return TRUE;

}

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    PDISK_INFORMATION diskInfo;
    DWORD maxSize = sizeof(DISK_INFORMATION);
    DWORD size;

    FPRINTF((OUTPUT, "Verifying blank disc... "));

    diskInfo = LocalAlloc(LPTR, maxSize);
    if (diskInfo == NULL) {
        FPRINTF((OUTPUT, "\nError allocating diskinfo\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(diskInfo, sizeof(DISK_INFORMATION));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
    cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(maxSize >> 8);
    cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(maxSize & 0xff);

    size = maxSize;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)diskInfo, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting disk info\n",
                 GetLastError()));
        LocalFree(diskInfo);
        return FALSE;
    }

    if (diskInfo->LastSessionStatus != 0x00) {
        FPRINTF((OUTPUT, "disc is not blank!\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        LocalFree(diskInfo);
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    LocalFree(diskInfo);
    return TRUE;
}

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    )
{
    PCDVD_WRITE_PARAMETERS_PAGE params = NULL;
    MODE_PARAMETER_HEADER10 header;
    PMODE_PARAMETER_HEADER10 buffer;

    UCHAR mediumTypeCode;


    CDB cdb;
    DWORD bufferSize;
    DWORD maxSize;

    FPRINTF((OUTPUT, "Setting WriteParameters mode page... "));

    bufferSize = sizeof(MODE_PARAMETER_HEADER10);

    RtlZeroMemory(&header, sizeof(MODE_PARAMETER_HEADER10));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)&header, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(1)\n",
                 GetLastError()));
        return FALSE;
    }

    bufferSize =
        (header.ModeDataLength[0] << 8) +
        (header.ModeDataLength[1] & 0xff);
    bufferSize += 2; // sizeof area that tells the remaining size

    maxSize = bufferSize;

    buffer = LocalAlloc(LPTR, bufferSize);
    if (!buffer) {
        FPRINTF((OUTPUT, "\nError -- unable to alloc %d bytes for mode parameters page\n",
                 bufferSize));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(2)\n",
                 GetLastError()));
        LocalFree(buffer);
        return FALSE;
    }

    mediumTypeCode = buffer->MediumType;

    //
    // bufferSize now holds the amount of data returned
    // this should be enough...
    //

    {

        DWORD t =
            (buffer->BlockDescriptorLength[0] >> 8) +
            (buffer->BlockDescriptorLength[1] & 0xff);

        if (t != 0) {
            fprintf(stderr, "BlockDescriptor non-zero! (%x)\n", t);
            SetLastError(1);
            return FALSE;
        }
    }

    //
    // pointer arithmetic here.  (buffer+1) points just past the
    // end of the mode_parameter_header10.
    //

    params = (PCDVD_WRITE_PARAMETERS_PAGE)(buffer + 1);
    FPRINTF((OUTPUT, "buffer = %p  params = %p\n", buffer, params));

    //
    // zero the header, but don't modify any settings that don't
    // need to be modified!
    //

    RtlZeroMemory(buffer, FIELD_OFFSET(MODE_PARAMETER_HEADER10,
                                       BlockDescriptorLength[0]));
    buffer->ModeDataLength[0] = 0;
    buffer->ModeDataLength[1] = 0;
    buffer->MediumType = mediumTypeCode;
    buffer->DeviceSpecificParameter = 0;
    buffer->BlockDescriptorLength[0] = 0;
    buffer->BlockDescriptorLength[1] = 0;

    params->PageLength =
        (UCHAR)
        (bufferSize -
         sizeof(MODE_PARAMETER_HEADER10) -
         RTL_SIZEOF_THROUGH_FIELD( CDVD_WRITE_PARAMETERS_PAGE, PageLength )
         );

    params->LinkSizeValid = 0;
    // params->BufferUnderrunFreeEnabled = 1;
    params->TestWrite     = (TestBurn ? 0x01 : 0x00);
    params->WriteType     = WriteType;

    params->MultiSession  = MultiSession;
    params->Copy          = 0x00; // original disc
    params->FixedPacket   = 0;
    params->TrackMode     = 0x4; // data track, uninterrupted, copy prohibited

    params->DataBlockType = DataBlockType;
    params->SessionFormat = SessionFormat;
    params->MediaCatalogNumberValid = 0x00;
    params->ISRCValid     = 0x00;

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
    cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(bufferSize & 0xff);
    cdb.MODE_SELECT10.PFBit = 1;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, FALSE)) {
        FPRINTF((OUTPUT, "\nError %d sending mode page 0x05 to device\n",
                 GetLastError()));
        LocalFree(buffer);
        return FALSE;
    }
    LocalFree(buffer);
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
GetNextWritableAddress(
    IN HANDLE CdromHandle,
    IN UCHAR Track,
    OUT PLONG NextWritableAddress,
    OUT PLONG AvailableBlocks
    )
{
    TRACK_INFORMATION2 trackInfo;
    LONG nwa, available;
    DWORD size;
    CDB cdb;

    *NextWritableAddress = (LONG)MAXLONG;
    *AvailableBlocks = (LONG)0;

    FPRINTF((OUTPUT, "Verifying track info... "));

    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&trackInfo, sizeof(TRACK_INFORMATION2));
    size = sizeof(TRACK_INFORMATION2);

    cdb.READ_TRACK_INFORMATION.OperationCode = SCSIOP_READ_TRACK_INFORMATION;
    cdb.READ_TRACK_INFORMATION.Track = 0x01;
    cdb.READ_TRACK_INFORMATION.BlockAddress[3] = Track;
    cdb.READ_TRACK_INFORMATION.AllocationLength[0] = (UCHAR)(size >> 8);
    cdb.READ_TRACK_INFORMATION.AllocationLength[1] = (UCHAR)(size & 0xff);


    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)&trackInfo, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting track info\n",
                 GetLastError()));
        PRINTBUFFER(( &trackInfo, sizeof(trackInfo) ));
        return FALSE;
    }

    if (!trackInfo.NWA_V) {
        FPRINTF((OUTPUT, "invalid NextWritableAddress -- may be invalid media?\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }

    nwa = (trackInfo.NextWritableAddress[0] << 24) |
          (trackInfo.NextWritableAddress[1] << 16) |
          (trackInfo.NextWritableAddress[2] <<  8) |
          (trackInfo.NextWritableAddress[3] <<  0);

    available = (trackInfo.FreeBlocks[0] << 24) |
                (trackInfo.FreeBlocks[1] << 16) |
                (trackInfo.FreeBlocks[2] <<  8) |
                (trackInfo.FreeBlocks[3] <<  0);

    FPRINTF((OUTPUT, "pass.\n"));

    *NextWritableAddress = nwa;
    *AvailableBlocks = available;
    return TRUE;
}

BOOLEAN
SendOptimumPowerCalibration(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Setting OPC_INFORMATION..."));

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.SEND_OPC_INFORMATION.OperationCode = SCSIOP_SEND_OPC_INFORMATION;
    cdb.SEND_OPC_INFORMATION.DoOpc = 1;
    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nFailed to send SET_OPC_INFORMATION (%d)\n",
                 GetLastError()));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
SetRecordingSpeed(
    IN HANDLE CdromHandle,
    IN DWORD Speed
    )
{
    CDB cdb;
    DWORD size;
    DWORD kbSpeed;

    FPRINTF((OUTPUT, "Setting CD Speed..."));

    if (Speed == -1) {
        kbSpeed = -1;
    } else {
        kbSpeed = MakeCdSpeed(Speed);
    }

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.SET_CD_SPEED.OperationCode = SCSIOP_SET_CD_SPEED;
    cdb.SET_CD_SPEED.ReadSpeed[0] = 0xff;
    cdb.SET_CD_SPEED.ReadSpeed[1] = 0xff;
    cdb.SET_CD_SPEED.WriteSpeed[0] = (UCHAR)(kbSpeed >> 8);
    cdb.SET_CD_SPEED.WriteSpeed[1] = (UCHAR)(kbSpeed & 0xff);
    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nFailed to send SET_CD_SPEED (%d)\n",
                 GetLastError()));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

VOID
WaitForReadDiscInfoToWork(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    DISK_INFORMATION diskInfo;
    DWORD i;

    //
    // loop using SCSIOP_READ_DISK_INFORMATION (0x51) since
    // that seems to fail for *ALL* drives until the drive is ready
    //

    for (i=0; ; i++) {

        size = sizeof(DISK_INFORMATION);
        RtlZeroMemory(&diskInfo, sizeof(DISK_INFORMATION));
        RtlZeroMemory(&cdb, sizeof(CDB));

        cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
        cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(size >> 8);
        cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(size & 0xff);

        if (SptSendCdbToDevice(CdromHandle, &cdb, 10,
                               (PUCHAR)&diskInfo, &size, TRUE)) {
            FPRINTF((OUTPUT, "ReadDiscInfo Succeeded! (%d seconds)\n", i));
            return;
        }
        // should verify the errors are valid errors (AllowedReadDiscInfo[])?

        // need to sleep here so we don't overload the unit!
        Sleep(1000); // one second
    }
    return;
}


DWORD G_BytesRead;
DWORD G_ErrorCode;

VOID
ReadComplete(
    IN DWORD errorcode,
    IN DWORD bytesread,
    IN LPOVERLAPPED OverL
    )
{
    G_BytesRead = bytesread;
    G_ErrorCode = errorcode;
    SetEvent( OverL->hEvent);
}


BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN ULONG NumberOfBlocks,
    IN ULONG FirstLba,
    IN ULONG AdditionalZeroSectors
    )
{

#define NUMBER_OF_SECTORS_PER_READ  (0x140) // 640k
#define NUMBER_OF_SECTORS_PER_WRITE (0x20)  // 64k

C_ASSERT( NUMBER_OF_SECTORS_PER_READ % NUMBER_OF_SECTORS_PER_WRITE == 0 );

    DWORD bufferSize = NUMBER_OF_SECTORS_PER_READ*2048;   // 640k
    DWORD writeUnit = NUMBER_OF_SECTORS_PER_WRITE*2048;     // 64k

    PUCHAR buffer = NULL;
    PUCHAR buffer2 = NULL;
    PUCHAR BufPtr;

    ULONG postGapSize;

    OVERLAPPED OverL;

    HANDLE ReadEvent;
    ULONG CurrentBuffer = 0;
    ULONG BlocksToWrite;

    BOOLEAN OutstandingRead = FALSE;

    ULONG currentReadBlock;
    ULONG currentWriteBlock = FirstLba;

    DWORD readSize;
    DWORD readBytes;


    if( AdditionalZeroSectors ) {
        postGapSize = AdditionalZeroSectors;
    } else {
        postGapSize = 0;
    }

    FPRINTF((OUTPUT, "Starting write: "));

    buffer = LocalAlloc(LPTR, 2 * bufferSize);
    if (buffer == NULL) {
        FPRINTF((OUTPUT, "unable to allocate write buffer\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    buffer2 = buffer + bufferSize;

    ReadEvent = CreateEvent( NULL, FALSE, FALSE, NULL);

    if (ReadEvent == NULL) {

        FPRINTF((OUTPUT, "Failed to create event %d\n",GetLastError()));
        return FALSE;
    }

    FPRINTF((OUTPUT, "............."));

    SetThreadExecutionState( ES_SYSTEM_REQUIRED  |
                             ES_DISPLAY_REQUIRED |
                             ES_USER_PRESENT
                             );

    RtlZeroMemory( &OverL, sizeof( OverL));

    for (currentReadBlock = 0;
         currentWriteBlock < NumberOfBlocks + postGapSize + FirstLba;
         //((currentReadBlock < (NumberOfBlocks + postGapSize)) || OutstandingRead);
         // NOTHING for third part of the loop....
         ) {

        CDB cdb;

        SetThreadExecutionState( ES_SYSTEM_REQUIRED  |
                                 ES_DISPLAY_REQUIRED |
                                 ES_USER_PRESENT
                                 );

        if (!gOptions.PrintWrites) {
            static CHAR progress[4] =  { '|', '/', '-', '\\' };
            DWORD percent;

            percent = (currentReadBlock < (NumberOfBlocks + postGapSize))
                      ? ((currentReadBlock * 1000) / (NumberOfBlocks + postGapSize))
                      : 1000;

            //                # # # . # % _ d o n e _ *
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
            printf("%c %3d.%d%% done",
                   progress[(currentReadBlock/NUMBER_OF_SECTORS_PER_READ) % 4 ],
                   percent / 10, percent % 10
                   );
            fflush(stdout);
        }

        //
        //  Wait for any previously issued read to complete and check the result.
        //

        if (OutstandingRead)  {

            DWORD Result = WaitForSingleObjectEx( ReadEvent, INFINITE, TRUE);

            if (Result != WAIT_OBJECT_0)  {

                if (Result == WAIT_IO_COMPLETION)  {

                    Result = WaitForSingleObjectEx( ReadEvent, INFINITE, TRUE);
                }

                if (Result != WAIT_OBJECT_0)  {

                    FPRINTF((OUTPUT, "Unexpected result from waitforsingleobjectex %d\n",
                            Result));

                    LocalFree(buffer);
                    return FALSE;
                }
            }

            // check the status

            if ((G_BytesRead != readSize) || G_ErrorCode) {

                FPRINTF((OUTPUT, "error %d or only read %d of %d bytes from file\n",
                        G_ErrorCode, G_BytesRead, readSize));

                LocalFree(buffer);
                return FALSE;
            }

            readBytes = G_BytesRead;

            OutstandingRead = FALSE;
        }

        //
        //  Calculate the amount of data to read into the secondary buffer,  if any.
        //

        if (currentReadBlock >= NumberOfBlocks)  {

            readSize = 0;
            readBytes = 0;

            RtlZeroMemory( CurrentBuffer ? buffer2 : buffer, bufferSize);
        }
        else if ((NumberOfBlocks - currentReadBlock) >= BLOCKS_FROM_BYTES(bufferSize))  {

            readSize = bufferSize;
        }
        else {

            readSize = BYTES_FROM_BLOCKS(NumberOfBlocks - currentReadBlock );
            RtlZeroMemory( CurrentBuffer ? buffer2 : buffer, bufferSize);
        }

        //
        //  Issue an async. read for the secondary buffer, hopefully this will
        //  complete before our active buffer write finishes.
        //

        if (readSize)  {

            OverL.Offset = (DWORD) BYTES_FROM_BLOCKS(currentReadBlock );
            OverL.OffsetHigh = (DWORD) (BYTES_FROM_BLOCKS((ULONG64)currentReadBlock) >> 32);
            OverL.hEvent = ReadEvent;

            if (!ReadFileEx( IsoImageHandle,
                             CurrentBuffer ? buffer2 : buffer,
                             readSize,
                             &OverL,
                             ReadComplete))  {

                FPRINTF((OUTPUT, "Error %d issuing overlapped read read\n", GetLastError()));
                LocalFree(buffer);
                return FALSE;
            }

            OutstandingRead = TRUE;
        }

        //
        // Toggle to the other buffer
        //

        CurrentBuffer ^= 1;

        //
        //  First pass we just want to fill the first buffer,  since we've nothing to write
        //  yet,  so just loop.
        //

        if ((readSize != 0) && (currentReadBlock == 0)) {

            //
            //  Note this can put us >= NumberOfBlocks + postGapSize for absurdly
            //  small images.
            //

            currentReadBlock += BLOCKS_FROM_BYTES(bufferSize );
            continue;
        }

        //
        //  Remember we're writng a buffer behind what we're reading...
        //

        currentWriteBlock = currentReadBlock + FirstLba - BLOCKS_FROM_BYTES(bufferSize);

        BlocksToWrite = NumberOfBlocks + FirstLba + postGapSize - currentWriteBlock;
        if (BlocksToWrite > BLOCKS_FROM_BYTES(bufferSize))  {
            BlocksToWrite = BLOCKS_FROM_BYTES(bufferSize);
        }

        BufPtr = CurrentBuffer ? buffer2 : buffer;

        while (BlocksToWrite)
        {
            ULONG ThisWriteSize;
            BOOL writeCompleted = FALSE;

            while (!writeCompleted) {

                BOOLEAN ignoreError;
                SENSE_DATA senseData;

                RtlZeroMemory(&senseData, sizeof(senseData));

                ThisWriteSize = (BlocksToWrite <= BLOCKS_FROM_BYTES(writeUnit))
                                ? BYTES_FROM_BLOCKS(BlocksToWrite)
                                : writeUnit;

                writeCompleted = SendWriteCommand(CdromHandle,
                                                  currentWriteBlock,
                                                  BufPtr,
                                                  ThisWriteSize,
                                                  &senseData);

                ignoreError = IsSenseDataInTable(AllowedBurnSense,
                                                 AllowedBurnSenseEntries,
                                                 &senseData);
                if ((!writeCompleted) && ignoreError) {
#if 0
                    FPRINTF((OUTPUT,
                             "Continuing on %x/%x/%x\n",
                             senseData.SenseKey & 0xf,
                             senseData.AdditionalSenseCode,
                             senseData.AdditionalSenseCodeQualifier
                             ));
#endif
                    Sleep(100); // 100ms == .1 seconds
                }

                if (!writeCompleted && !ignoreError) {
                    FPRINTF((OUTPUT, "\nError %d in writing LBA 0x%x\n",
                    GetLastError(), currentWriteBlock));
                    LocalFree(buffer);
                    return FALSE;
                }
            } // while(!writeCompleted) loop

            assert( ThisWriteSize <= BlocksToWrite );

            BlocksToWrite -= BLOCKS_FROM_BYTES(ThisWriteSize);
            currentReadBlock += BLOCKS_FROM_BYTES(ThisWriteSize);
            currentWriteBlock += BLOCKS_FROM_BYTES(ThisWriteSize);

            BufPtr += ThisWriteSize;

        } // random block to have local variable writeCompleted

    }

    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
    LocalFree(buffer);

    printf("Finished Writing\nSynchronizing Cache: ");
    fflush(stdout);

    //
    // do the FLUSH_CACHE immediate
    //
    {
        DWORD size;
        CDB cdb;
        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;
        cdb.SYNCHRONIZE_CACHE10.Immediate = 1;
        size = 0;

        if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                                NULL, &size, TRUE)) {
            FPRINTF((OUTPUT, "\nError %d Synchronizing Cache\n",
                    GetLastError()));
            return FALSE;
        }
    }

    WaitForReadDiscInfoToWork(CdromHandle);
    return TRUE;
}

BOOLEAN
CloseTrack(
    IN HANDLE CdromHandle,
    IN LONG   Track
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Closing the track..."));

    if (Track > 0xffff) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
    cdb.CLOSE_TRACK.Immediate = 0;
    cdb.CLOSE_TRACK.Track   = 1;
    cdb.CLOSE_TRACK.Session = 0;
    cdb.CLOSE_TRACK.TrackNumber[0] = (UCHAR)(Track >> 8);
    cdb.CLOSE_TRACK.TrackNumber[1] = (UCHAR)(Track & 0xff);

    size = 0;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d Closing Track\n",
                GetLastError()));
        return FALSE;
    }

    WaitForReadDiscInfoToWork(CdromHandle);

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;


}

BOOLEAN
CloseSession(
    IN HANDLE  CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Closing the disc..."));

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
    cdb.CLOSE_TRACK.Immediate = 1;
    cdb.CLOSE_TRACK.Track   = 0;
    cdb.CLOSE_TRACK.Session = 1;
    size = 0;

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              NULL,
                              &size,
                              NULL,
                              0,
                              TRUE,
                              240)) { // four minutes to close session
        FPRINTF((OUTPUT, "\nError %d Synchronizing Cache\n",
                GetLastError()));
        return FALSE;
    }

    WaitForReadDiscInfoToWork(CdromHandle);

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    )
{
    CDB cdb;
    DWORD size;

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.LoadEject = Eject;
    cdb.START_STOP.Start     = Start;

    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 6,
                            NULL, &size, TRUE)) {
        return FALSE;
    }

    return TRUE;
}

/*
ERROR_BAD_COMMAND
ERROR_INVALID_DATA
ERROR_INVALID_PARAMETER
ERROR_MEDIA_INCOMPATIBLE
ERROR_NOT_ENOUGH_MEMORY

ERROR_OUTOFMEMORY

*/

/*++

Routine Description:

    burns an ISO image to cdrom

Arguments:
    CdromHandle - a file handle to send the ioctl to

    argc - the number of additional arguments (2)

Return Value:

    ERROR_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
DWORD
BurnCommand(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle
    )
{
    LONG numberOfBlocks;
    LONG i;

    BOOLEAN b;
    DWORD status;

////////////////////////////////////////////////////////////////////////////////
// verify the iso image file looks correct
////////////////////////////////////////////////////////////////////////////////
    if ((IsoImageHandle != INVALID_HANDLE_VALUE) &&
        (VerifyIsoImage(IsoImageHandle, &numberOfBlocks) == FALSE)) {
        printf("Error verifying ISO image\n");
        return GetLastError();
    } else {
        assert(gEraseTargetFirst == TRUE);
    }
    printf("Number of blocks in ISO image is %x\n", numberOfBlocks);

////////////////////////////////////////////////////////////////////////////////
// Erase the target media if it's been requested we do so.
////////////////////////////////////////////////////////////////////////////////

    if (gOptions.Erase) {
        printf("Erasing target media\n");
        if(!EraseTargetMedia(CdromHandle)) {
            printf("Error %d erasing target\n", GetLastError());
            return GetLastError();
        }
        printf("Media erased\n");
    }

////////////////////////////////////////////////////////////////////////////////
// verify (as best as possible) that it's blank media
////////////////////////////////////////////////////////////////////////////////

    if(!VerifyBlankMedia(CdromHandle)) {
        printf("Error verifying blank media\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// If there's no image file to be written then we're done.
////////////////////////////////////////////////////////////////////////////////

    if(IsoImageHandle == INVALID_HANDLE_VALUE) {
        return ERROR_SUCCESS;
    }

////////////////////////////////////////////////////////////////////////////////
// set the cd speed to four for now, can later make a cmd-line switch
////////////////////////////////////////////////////////////////////////////////
    if (gOptions.BurnSpeed == OPTIONS_FLAG_BURN_SPEED_MAX) {
        if (!SetRecordingSpeed(CdromHandle, -1)) {
            printf("Error setting the cd speed to max\n");
            return GetLastError();
        }
    } else {

        if (!SetRecordingSpeed(CdromHandle, gOptions.BurnSpeed)) {
            printf("Error setting the cd speed to %d\n", gOptions.BurnSpeed);
            return GetLastError();
        }
    }

////////////////////////////////////////////////////////////////////////////////
// calibrate the drive's power -- this is optional, so let it fail!
////////////////////////////////////////////////////////////////////////////////

    if (!(gOptions.TestBurn)) {
        // don't calibrate for test burns....
        if (!SendOptimumPowerCalibration(CdromHandle)) {
            printf("WARNING: setting optimum power calibration failed\n");
            //return GetLastError();
        }
    }

////////////////////////////////////////////////////////////////////////////////
// start writing
////////////////////////////////////////////////////////////////////////////////

    if (gOptions.SessionAtOnce) {
        b = BurnDisk(CdromHandle, IsoImageHandle, numberOfBlocks);
    } else {
        b = BurnTrack(CdromHandle, IsoImageHandle, numberOfBlocks);
    }

    if(!b) {
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// eject the newly burned cd!
////////////////////////////////////////////////////////////////////////////////


    if (!SendStartStopUnit(CdromHandle, FALSE, TRUE) ||
        !SendStartStopUnit(CdromHandle, TRUE,  TRUE)) {
        printf("Error ejecting/reinserting disc\n");
        return GetLastError();
    }

    printf("burn successful!\n");
    return 0;
}

BOOLEAN
BurnTrack(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    LONG   NumberOfBlocks
    )
{
    LONG availableBlocks;
    LONG firstLba;

////////////////////////////////////////////////////////////////////////////////
// Setup the write mode page
////////////////////////////////////////////////////////////////////////////////
    if (!SetWriteModePage(CdromHandle,
                          (BOOLEAN)gOptions.TestBurn,
                          0x01, // track-at-once
                          0x03, // we close the session/disc ourselves
                          0x08, // 0x08 == Mode 1 (ISO/IEC 10149 == 2048 bytes)
                                // 0x0a == Mode 2 (CDROM XA, Form 1, 2048 bytes)
                          0x00  // 0x00 == CD-DA, CD-ROM, or other data disc
                                // 0x20 == CDROM XA
                          )) {
        printf("Error setting write mode page\n");
        return FALSE;
    }

////////////////////////////////////////////////////////////////////////////////
// get next writable address
////////////////////////////////////////////////////////////////////////////////
    if (!GetNextWritableAddress(CdromHandle, 0xff, &firstLba, &availableBlocks)) {
        printf("Error verifying next writable address\n");
        return FALSE;
    }

    if (firstLba != 0) {
        printf("Error verifying next writable address is zero\n");
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }

////////////////////////////////////////////////////////////////////////////////
// also verify the number of blocks left on the media is sufficiently large
////////////////////////////////////////////////////////////////////////////////
    if (availableBlocks < NumberOfBlocks) {
        printf("Error verifying free blocks on media (%d needed, %d available)\n",
               NumberOfBlocks, availableBlocks);
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }

////////////////////////////////////////////////////////////////////////////////
// burn the main section of data to disc
////////////////////////////////////////////////////////////////////////////////
    {
        ULONG additionalBlocks;
        if ( gOptions.NoPostgap )
        {
            additionalBlocks = 0;
        }
        else
        {
            additionalBlocks = POST_GAP_SIZE;
        }
        if (!BurnThisSession(CdromHandle, IsoImageHandle, NumberOfBlocks, 0, additionalBlocks)) {
            return FALSE;
        }

    }


////////////////////////////////////////////////////////////////////////////////
// set mode page to finalize the disc
////////////////////////////////////////////////////////////////////////////////
    if (!SetWriteModePage(CdromHandle,
                          (BOOLEAN)gOptions.TestBurn,
                          0x01, // track-at-once
                          0x00, // we close the session/disc ourselves
                          0x08, // 0x08 == Mode 1 (ISO/IEC 10149 == 2048 bytes)
                                // 0x0a == Mode 2 (CDROM XA, Form 1, 2048 bytes)
                          0x00  // 0x00 == CD-DA, CD-ROM, or other data disc
                                // 0x20 == CDROM XA
                          )) {
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }


////////////////////////////////////////////////////////////////////////////////
// close the session
////////////////////////////////////////////////////////////////////////////////

    if (!(gOptions.TestBurn)) {
        // don't close anything for test burns.
        if (!CloseSession(CdromHandle)) {
            // if couldn't close session, try closing the track first and
            // then retry closing the session.
            if (!CloseTrack(CdromHandle, 1)) {
                printf("WARNING: error closing the track when session close "
                       "also failed.\n");
                printf("         The disc may or may not be usable -- "
                       "no guarantees\n");
            }
            if (!CloseSession(CdromHandle)) {
                printf("Error closing session -- the disc is almost definitely "
                       "unusable on most drives.  YMMV.\n");
                return FALSE;
            }
        }
    }
    return TRUE;
}

#define ERASE_TIMEOUT (2 * 60)


BOOLEAN
EraseTargetMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;

    ULONG zero = 0;

    BOOL b;
    DWORD status;

    //
    // Send the blank command to the device.
    //

    memset(&cdb, 0, sizeof(cdb));

    cdb.BLANK_MEDIA.OperationCode = SCSIOP_BLANK;
    cdb.BLANK_MEDIA.BlankType = 0x1;  // quick erase
    cdb.BLANK_MEDIA.Immediate = TRUE;

    b = SptSendCdbToDevice(CdromHandle,
                           &cdb,
                           12,
                           NULL,
                           &zero,
                           FALSE);

    if (!b) {
        return FALSE;
    }

    WaitForReadDiscInfoToWork(CdromHandle);

    return TRUE;
}

BOOLEAN
BurnDisk(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    LONG   NumberOfBlocks
    )
{
    LONG availableBlocks;
    LONG firstLba;

    //
    // Setup for a disk-at-once burn.
    //

    if (!SetWriteModePage(CdromHandle,
                          (BOOLEAN)gOptions.TestBurn,
                          0x02, // session-at-once
                          0x00, // no multisession allowed
                          0x08, // 0x08 == Mode 1 (ISO/IEC 10149 == 2048 bytes)
                                // 0x0a == Mode 2 (CDROM XA, Form 1, 2048 bytes)
                          0x00  // 0x00 == CD-DA, CD-ROM, or other data disc
                                // 0x20 == CDROM XA
                          )) {
        printf("Error setting write mode page\n");
        return FALSE;
    }

    //
    // get next writable address
    //

    if (!GetNextWritableAddress(CdromHandle, 0xff, &firstLba, &availableBlocks)) {
        printf("Error verifying next writable address\n");
        return FALSE;
    }

    /*
    //
    // The first LBA should be -150 for SAO writes
    //
    if (firstLba != -150) {
        printf("Error verifying next writable address is -150\n");
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }
    */

    //
    // verify the disc is large enough
    //

    if (availableBlocks < NumberOfBlocks + 150) {
        printf("Error verifying free blocks on media (%d needed, %d available)\n",
               NumberOfBlocks + 150, availableBlocks);
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }

    //
    // Send the cue sheet for our burn.
    //

    if (!SendCueSheet(CdromHandle, NumberOfBlocks)) {
        printf("Error sending cue sheet\n");
        return FALSE;
    }

    //
    // Burn the lead-in to disk.
    //

    if (!BurnLeadIn(CdromHandle)) {
        printf("Error writing lead-in\n");
        return FALSE;
    }

    //
    // Burn the session to disk.
    //

    if (!BurnThisSession(CdromHandle,
                         IsoImageHandle,
                         NumberOfBlocks,
                         0, // start LBA
                         (gOptions.NoPostgap ? 2 : 2 + POST_GAP_SIZE))) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SendCueSheet(
    IN HANDLE CdromHandle,
    IN ULONG NumberOfBlocks
    )
{
    CDB cdb;

    CUE_SHEET_LINE cueSheet[] = {
        {CUE_ADR_TRACK_INDEX, CUE_CTL_DATA_TRACK,    0, 0, CUE_FORM_MODE1_GDATA_GECC_0,    CUE_SCFORM_ZEROED_0, 0, 0, 0x00, 0x00, 0x00},
        {CUE_ADR_TRACK_INDEX, CUE_CTL_DATA_TRACK,    1, 0, CUE_FORM_MODE1_SDATA_GECC_2048, CUE_SCFORM_ZEROED_0, 0, 0, 0x00, 0x00, 0x00},
        {CUE_ADR_TRACK_INDEX, CUE_CTL_DATA_TRACK,    1, 1, CUE_FORM_MODE1_SDATA_GECC_2048, CUE_SCFORM_ZEROED_0, 0, 0, 0x00, 0x02, 0x00},
        {CUE_ADR_TRACK_INDEX, CUE_CTL_DATA_TRACK, 0xaa, 1, CUE_FORM_MODE1_GDATA_GECC_0,    CUE_SCFORM_ZEROED_0, 0, 0, 0xff, 0xff, 0xff}
    };

    ULONG cueSheetSize = sizeof(cueSheet);

    SENSE_DATA senseData;

    MSF msf;
    MSF pregap = {0, 2, 0};

    //
    // Need to add two sectors of runout blocks, and postgap as appropriate
    //
    NumberOfBlocks += 2;
    if ( !(gOptions.NoPostgap) )
    {
        NumberOfBlocks += POST_GAP_SIZE;
    }

    memset(&cdb, 0, sizeof(CDB));

    cdb.SEND_CUE_SHEET.OperationCode = SCSIOP_SEND_CUE_SHEET;
    cdb.SEND_CUE_SHEET.CueSheetSize[0] = (UCHAR)((cueSheetSize >> (8*2)) & 0xff);
    cdb.SEND_CUE_SHEET.CueSheetSize[1] = (UCHAR)((cueSheetSize >> (8*1)) & 0xff);
    cdb.SEND_CUE_SHEET.CueSheetSize[2] = (UCHAR)((cueSheetSize >> (8*0)) & 0xff);

    //
    // Calculate the correct time stamp for the start of the post-gap area.
    //

    msf = LbaToMsf(NumberOfBlocks);
    msf = AddMsf(msf, pregap);

    cueSheet[RTL_NUMBER_OF(cueSheet)-1].Min = msf.Min;
    cueSheet[RTL_NUMBER_OF(cueSheet)-1].Sec = msf.Sec;
    cueSheet[RTL_NUMBER_OF(cueSheet)-1].Frame = msf.Frame;

    printf("Cue Sheet:\n");
    PrintBuffer((PUCHAR) cueSheet, cueSheetSize);

    //
    // Send the cue sheet to the device.
    //

    if(!SptSendCdbToDeviceEx(CdromHandle,
                             &cdb,
                             10,
                             (PUCHAR) cueSheet,
                             &cueSheetSize,
                             &senseData,
                             sizeof(senseData),
                             FALSE,
                             30)) {

        printf("Error: Cue sheet send failed\n");
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
SendWriteCommand(
    IN HANDLE CdromHandle,
    IN LONG Block,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PSENSE_DATA SenseData
    )
{
    CDB cdb;
    FOUR_BYTE b;

    RtlZeroMemory(&cdb, sizeof(CDB));

    b.AsULong = Block;

    if(gOptions.PrintWrites) {
        printf("Writing block %#010x length %#010x\n", Block, Length);
        return TRUE;
    }

    cdb.CDB10.OperationCode = SCSIOP_WRITE;
    cdb.CDB10.LogicalBlockByte0 = b.Byte3;
    cdb.CDB10.LogicalBlockByte1 = b.Byte2;
    cdb.CDB10.LogicalBlockByte2 = b.Byte1;
    cdb.CDB10.LogicalBlockByte3 = b.Byte0;

    cdb.CDB10.TransferBlocksLsb = (UCHAR)BLOCKS_FROM_BYTES(Length);

    if(SptSendCdbToDeviceEx(CdromHandle,
                            &cdb,
                            10,
                            Buffer,
                            &Length,
                            SenseData,
                            sizeof(SENSE_DATA),
                            FALSE,
                            50 // timeout seconds
                            )) {
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOLEAN
BurnLeadIn(
    IN HANDLE CdromHandle
    )
{
    DWORD writeUnit = DEFAULT_WRITE_SIZE;     // 64k

    PUCHAR buffer = NULL;

    LONG currentBlock;
    LONG blocksToWrite = LEAD_IN_SIZE;

    FPRINTF((OUTPUT, "Starting lead-in: "));

    buffer = LocalAlloc(LPTR, writeUnit);
    if (buffer == NULL) {
        FPRINTF((OUTPUT, "unable to allocate write buffer\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    ZeroMemory(buffer, writeUnit);

    FPRINTF((OUTPUT, ".............\n"));

    SetThreadExecutionState( ES_SYSTEM_REQUIRED  |
                             ES_DISPLAY_REQUIRED |
                             ES_USER_PRESENT
                             );

    currentBlock = -LEAD_IN_SIZE;

    do {
        ULONG writeSize;
        BOOLEAN writeCompleted;

        writeSize = min(BLOCKS_FROM_BYTES(DEFAULT_WRITE_SIZE), blocksToWrite);

        do {
            BOOLEAN ignoreError;
            SENSE_DATA senseData;

            RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

            writeCompleted = SendWriteCommand(CdromHandle,
                                              currentBlock,
                                              buffer,
                                              BYTES_FROM_BLOCKS(writeSize),
                                              &senseData);

            ignoreError = IsSenseDataInTable(AllowedBurnSense,
                                             AllowedBurnSenseEntries,
                                             &senseData);
            if ((!writeCompleted) && ignoreError) {
#if 0
                FPRINTF((OUTPUT,
                         "Continuing on %x/%x/%x\n",
                         senseData.SenseKey & 0xf,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier
                         ));
#endif
                Sleep(100); // 100ms == .1 seconds
            }

            if (!writeCompleted && !ignoreError) {
                FPRINTF((OUTPUT, "\nError %d in writing LBA 0x%x\n",
                GetLastError(), currentBlock));
                LocalFree(buffer);
                return FALSE;
            }
        } while(!writeCompleted);

        blocksToWrite -= writeSize;
        currentBlock += writeSize;

    } while(blocksToWrite > 0);

    printf("Finished LeadIn\n");
    fflush(stdout);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cdp\cdp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cdp.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int


#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include <ntddscsi.h>

#include <ntddstor.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddcdvd.h>
#include <ntddmmc.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>
#include "sptlib.h"
#include "cmdhelp.h"

#define MAX_IOCTL_INPUT_SIZE  0x040
#define MAX_IOCTL_OUTPUT_SIZE 0x930  // IOCTL_CDROM_RAW_READ is this large
#define MAX_IOCTL_BUFFER_SIZE (max(MAX_IOCTL_INPUT_SIZE, MAX_IOCTL_OUTPUT_SIZE))
// read no more than 64k at a time -- lots of things just don't support it.
#define MAX_READ_SIZE (64 * 1024)
#define CDRW_WRITE_SECTORS  (32)
#define CDRW_WRITE_BYTES    (CDRW_WRITE_SECTORS*2048)

////////////////////////////////////////////////////////////////////////////////

#define MSF_TO_LBA(Minutes,Seconds,Frames) \
    (ULONG)((60 * 75 * (Minutes) ) + (75 * (Seconds)) + ((Frames) - 150))

#define LBA_TO_MSF(Lba, Minutes, Seconds, Frames)            \
{                                                            \
    (Minutes) = (UCHAR)( ((Lba) + 150) / (60 * 75)      );   \
    (Seconds) = (UCHAR)((((Lba) + 150) % (60 * 75)) / 75);   \
    (Frames)  = (UCHAR)((((Lba) + 150) % (60 * 75)) % 75);   \
}
////////////////////////////////////////////////////////////////////////////////

#ifdef DBG
#define dbg(x) x
#define HELP_ME() fprintf(stderr, "Reached line %4d\n", __LINE__)
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__) */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

typedef struct {
    char *Name;
    char *Description;
    DWORD (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    char                SenseInfoBuffer[18];
    char                DataBuffer[0];          // Allocate buffer space
                                                // after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;


DWORD WaitForReadDiscInfoCommand(HANDLE device, int argc, char *argv[]);
DWORD ShowMrwProgressCommand(HANDLE device, int argc, char *argv[]);
DWORD FormatMrwCommand(HANDLE device, int argc, char *argv[]);
DWORD DvdReadStructure(HANDLE device, int argc, char *argv[]);
DWORD StartStopCommand(HANDLE device, int argc, char *argv[]);
DWORD TestCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadTOCCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadTOCExCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadCdTextCommand(HANDLE device, int argc, char *argv[]);
DWORD PlayCommand(HANDLE device, int argc, char *argv[]);
DWORD PauseResumeCommand(HANDLE device, int argc, char *argv[]);
DWORD SendCommand(HANDLE device, int argc, char *argv[]);
DWORD IoctlCommand(HANDLE device, int argc, char *argv[]);
DWORD ListCommand(HANDLE device, int argc, char *argv[]);
DWORD DiskGetPartitionInfo( HANDLE device, int argc, char *argv[]);
DWORD FormatErrorCommand(HANDLE device, int argc, char *argv[]);
DWORD ImageDiskCommand(HANDLE device, int argc, char *argv[]);
DWORD MrwInitTestPatternCommand(HANDLE device, int argc, char *argv[]);
DWORD MrwInitGaaFileSystem(HANDLE device, int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"cdtext",      "read cd text info                                         ", ReadCdTextCommand         },
    {"dvdstruct",   "Reads a dvd structure from the drive                      ", DvdReadStructure          },
    {"eject",       "spins down and ejects the specified drive                 ", StartStopCommand          },
    {"error",       "provides the error text for a winerror                    ", FormatErrorCommand        },
    {"help",        "help for all commands                                     ", ListCommand               },
    {"ioctl",       "ioctl [quoted hex input] [output] sends an arbitrary ioctl", IoctlCommand              },
    {"image",       "<file>  images the storage device into the file           ", ImageDiskCommand          },
    {"load",        "loads the specified drive                                 ", StartStopCommand          },
    {"mrwformat",    NULL                                                       , FormatMrwCommand          },
    {"mrwgaa",       NULL                                                       , MrwInitGaaFileSystem      },
    {"mrwprogress",  NULL                                                       , ShowMrwProgressCommand    },
    {"mrwtest",      NULL                                                       , MrwInitTestPatternCommand },
    {"partition",   "reads partition information                               ", DiskGetPartitionInfo      },
    {"pause",       "pauses audio playback                                     ", PauseResumeCommand        },
    {"play",        "[start track [end track]] plays audio tracks              ", PlayCommand               },
    {"resume",      "resumes paused audio playback                             ", PauseResumeCommand        },
    {"send",         NULL                                                       , SendCommand               },
    {"start",       "spins up the drive                                        ", StartStopCommand          },
    {"stop",        "spinds down the drive                                     ", StartStopCommand          },
    {"test",         NULL                                                       , TestCommand               },
    {"toc",         "prints the table of contents                              ", ReadTOCCommand            },
    {"tocex",        NULL                                                       , ReadTOCExCommand          },
    {"wait",        "Waits for the READ_DISC_INFO command to work              ", WaitForReadDiscInfoCommand},
//    {"tocex", "[Format [Session/Track [MSF]]] Read toc/cdtext/atip/etc.", ReadTOCExCommand},
    {NULL, NULL, NULL}
    };

#define STATUS_SUCCESS 0

VOID PrintChar( IN UCHAR Char ) {

    if ( (Char >= 0x21) && (Char <= 0x7E) ) {
        printf("%c", Char);
    } else {
        printf("%c", '.');
    }

}

VOID UpdatePercentageDisplay(IN ULONG Numerator, IN ULONG Denominator) {

    ULONG percent;
    ULONG i;

    if (Numerator > Denominator) {
        return;
    }

    // NOTE: Overflow possibility exists for large numerators.

    percent = (Numerator * 100) / Denominator;

    for (i=0;i<90;i++) {
        putchar('\b');
    }
    printf("Complete: ");

    // each block is 2%
    // ----=----1----=----2----=----3----=----4----=----5----=----6----=----7----=----8
    // Complete: .....................

    for (i=1; i<100; i+=2) {
        if (i < percent) {
            putchar(178);
        } else if (i == percent) {
            putchar(177);
        } else {
            putchar(176);
        }
    }

    printf(" %d%% (%8x/%8x)", percent, Numerator, Denominator);
}

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE h;
    char buffer[80]; // ~50 chars for mountvol names

    if(argc < 3) {
        printf("Usage: cdp <drive> <command> [parameters]\n");
        printf("possible commands: \n");
        ListCommand(NULL, argc, argv);
        printf("\n");
        return -1;
    }

    sprintf(buffer, "\\\\.\\%s", argv[1]);
    dbg(printf("Sending command %s to drive %s\n", argv[2], buffer));

    h = CreateFile(buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[2], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 2), &(argv[2]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

//
// take a PVOID as input -- it's cleaner throughout
//
VOID
PrintBuffer(
    IN  PVOID  InputBuffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;
    PUCHAR buffer = InputBuffer;

    while (Size >= 0x10) {

        DWORD i;

        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  ",
                offset,
                *(buffer +  0), *(buffer +  1), *(buffer +  2), *(buffer +  3),
                *(buffer +  4), *(buffer +  5), *(buffer +  6), *(buffer +  7),
                *(buffer +  8), *(buffer +  9), *(buffer + 10), *(buffer + 11),
                *(buffer + 12), *(buffer + 13), *(buffer + 14), *(buffer + 15)
                );

        for (i=0; i < 0x10; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");


        Size -= 0x10;
        offset += 0x10;
        buffer += 0x10;
    }

    if (Size != 0) {

        DWORD i;

        printf("%08x:", offset);

        //
        // print the hex values
        //
        for (i=0; i<Size; i++) {

            if ((i%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *(buffer+i));

        }
        //
        // fill in the blanks
        //
        for (; i < 0x10; i++) {
            printf("   ");
        }
        printf("  ");
        //
        // print the ascii
        //
        for (i=0; i<Size; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");
    }
    return;
}

DWORD StartStopCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    DWORD bufferSize;
    CDB cdb;

    UCHAR loadEject = 0;
    UCHAR start = 0;

    UNREFERENCED_PARAMETER(argc);

    if(strcmp("eject", argv[0]) == 0)  {
        loadEject = 1;
        start = 0;
    } else if(strcmp("load", argv[0]) == 0) {
        loadEject = 1;
        start = 1;
    } else if(strcmp("start", argv[0]) == 0) {
        loadEject = 0;
        start = 1;
    } else if(strcmp("stop", argv[0]) == 0) {
        loadEject = 0;
        start = 0;
    } else {
        assert(0);
    }

    memset(&cdb, 0, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.Immediate     = 0;
    cdb.START_STOP.Start         = start;
    cdb.START_STOP.LoadEject     = loadEject;

    bufferSize = 0;


    if (!SptSendCdbToDevice(device, &cdb, 6, NULL, &bufferSize, FALSE)) {
        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
    }
    return errorValue;
}

DWORD ReadCdTextCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents,
    ATIP, PMA, or CDTEXT data

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  (1-4 is valid)

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD returned;
    LONG bufferSize = 4; // to get the header
    DWORD i;

    CDROM_READ_TOC_EX params;
    BOOLEAN isText = TRUE;
    PUCHAR buffer = NULL;

    UNREFERENCED_PARAMETER(argv);

    if (argc > 3) {
        printf("Too many args\n");
        return 1;
    }

    //
    // set defaults - FORMAT_TOC, 0, 0
    //

    RtlZeroMemory(&params, sizeof(CDROM_READ_TOC_EX));

    params.Msf = 0;
    params.SessionTrack = 1;
    params.Format = 5;

    if(argc > 1) params.SessionTrack = (char)atoi(argv[1]);

    printf("Session = 0x%x\n", params.SessionTrack);

    for (i = 0; i < 2; i++) {

        if (i != 0) {
            LocalFree(buffer);
        }
        buffer = LocalAlloc(LPTR, bufferSize);

        if (buffer == NULL) {
            printf("No Memory %d\n", __LINE__);
            return 1;
        }

        returned = 0;
        if (!DeviceIoControl(device,
                             IOCTL_CDROM_READ_TOC_EX,
                             &params,
                             sizeof(CDROM_READ_TOC_EX),
                             buffer,
                             bufferSize,
                             &returned,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            LocalFree(buffer);
            printf("Eject - error sending IOCTL (%d)\n", errorValue);
            return errorValue;
        }
        bufferSize = (buffer[0] << 8) | (buffer[1]);
        bufferSize += 2;
    }

    if (argc > 2) {
        //
        // this block is for debugging the various idiosynchracies found
        // in CD-TEXT discs. Many discs encode multiple tracks in a single
        // block.  ie. if one song is called "ABBA", the second "Baby", and
        // the third "Longer Name", the Text portion would be encoded as:
        //     Track 1  'ABBA\0Baby\0Lo'
        //     Track 3  'nger Name\0'
        // This effectively "skips" the name available for Track 2 ?!
        // How to work around this....
        //

        {
            HANDLE h;
            DWORD temp;
            h = CreateFile("OUTPUT.TXT",
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

            if(h == INVALID_HANDLE_VALUE) {
                printf("Error %d creating new file \"OUTPUT.TXT\"\n",
                       GetLastError());
                LocalFree(buffer);
                return GetLastError();
            }
            if (!WriteFile(h, buffer, bufferSize, &temp, NULL)) {
                printf("Error %d writing file to disk\n", GetLastError());
                LocalFree(buffer);
                return GetLastError();
            }
            // continue to output to screen....
        }

        for (i=0;
             FIELD_OFFSET(CDROM_TOC_CD_TEXT_DATA, Descriptors[i+1]) < bufferSize;
             i++) {

            PCDROM_TOC_CD_TEXT_DATA_BLOCK block;
            PCDROM_TOC_CD_TEXT_DATA_BLOCK prevBlock;
            DWORD j;

            block = (PCDROM_TOC_CD_TEXT_DATA_BLOCK)(buffer + 4);
            block += i;
            prevBlock = block - 1;

            if (block->Unicode) {
                continue; // ignore unicode -- this is examplary only
            }

            for (j=0;j<12;j++) {
                // replace NULLs with *, Tabs with hashes
                if (block->Text[j] == 0) block->Text[j] = '*';
                if (block->Text[j] == 9) block->Text[j] = '#';
            }

            if (block->SequenceNumber > 0x2b &&
                block->SequenceNumber < 0x32) {

                UCHAR text[13];
                RtlZeroMemory(text, 13);
                RtlCopyMemory(text, block->Text, 12);

                printf("PackType %02x  TrackNo %02x  ExtensionFlag %d\n"
                       "Sequence Number %02x       CharacterPosition %02x\n"
                       "Text: \"%s\"\n\n",
                       block->PackType,
                       block->TrackNumber,
                       block->ExtensionFlag,
                       block->SequenceNumber,
                       block->CharacterPosition,
                       text
                       );

            }
        }
        printf("\n");

    } else {

        for (i=0;
             FIELD_OFFSET(CDROM_TOC_CD_TEXT_DATA, Descriptors[i+1]) < bufferSize;
             i++) {

            PCDROM_TOC_CD_TEXT_DATA_BLOCK block;
            PCDROM_TOC_CD_TEXT_DATA_BLOCK prevBlock;
            DWORD j;

            block = (PCDROM_TOC_CD_TEXT_DATA_BLOCK)(buffer + 4);
            block += i;
            prevBlock = block - 1;

            if (block->Unicode) {
                continue; // ignore unicode -- this is examplary only
            }

            //
            // set the CRC's to zero so we can hack the data inside to more
            // easily handle wierd cases....
            //

            block->CRC[0] = block->CRC[1] = 0;

            //
            // set the tab characters to '*' for now.
            // i have not yet seen one using this "feature" of cd-text
            //

            for (j=0;j<12;j++) {
                if (block->Text[j] == 9) {
                    block->Text[j] = '*';
                }
            }


            if ((i != 0) &&
                (prevBlock->PackType    == block->PackType) &&
                (prevBlock->TrackNumber == block->TrackNumber)
                ) {

                // continuation of previous setting.

            } else
            if ((!(block->ExtensionFlag)) &&
                (block->TrackNumber != 0) &&
                (block->TrackNumber == (prevBlock->TrackNumber + 2)) &&
                (block->PackType    == prevBlock->PackType)
                ) {

                UCHAR *goodText;
                UCHAR *midText;
//                printf("\"\n\"HACK DETECTED! (seq %x & %x)",
//                       prevBlock->SequenceNumber, block->SequenceNumber);

                // hack for when prevBlock has two names encoded....
                // the TrackNumber/PackType are already equal, just
                // move the middle string to the start.

                midText = prevBlock->Text;
                while (*midText != '\0') {
                    midText++;
                }
                midText++;

                goodText = prevBlock->Text;
                while (*midText != '\0') {
                    *goodText++ = *midText++;
                }
                *goodText = '\0';
//                printf(" %s", prevBlock->Text);

                prevBlock->CharacterPosition = 0;
                prevBlock->TrackNumber++;
                prevBlock->ExtensionFlag = 1;
                i-= 2;
                continue; // re-run the previous, modified block

            } else {

                printf("\"\n");
                switch (block->PackType) {
                case CDROM_CD_TEXT_PACK_ALBUM_NAME: {
                    if (block->TrackNumber == 0) {
                        printf("%-12s", "Album Name");
                        printf("    : \"");
                    } else {
                        printf("%-12s", "Track Name");
                        printf("(%02d): \"", block->TrackNumber);
                    }
                    break;
                }
                case CDROM_CD_TEXT_PACK_PERFORMER: {
                    printf("%-12s", "Performer");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_SONGWRITER: {
                    printf("%-12s", "Songwriter");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_COMPOSER: {
                    printf("%-12s", "Composer");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_ARRANGER: {
                    printf("%-12s", "Arranger");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_MESSAGES: {
                    printf("%-12s", "Messages");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_DISC_ID: {
                    printf("%-12s", "Disc ID");
                    printf("    : \"");
                    break;
                }
                case CDROM_CD_TEXT_PACK_GENRE: {
                    printf("%-12s", "Genre");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_UPC_EAN: {
                    if (block->TrackNumber == 0) {
                        printf("%-12s", "UPC/EAN");
                        printf("    : \"");
                    } else {
                        printf("%-12s", "ISRC");
                        printf("(%02d): \"", block->TrackNumber);
                    }
                    break;
                }
                case CDROM_CD_TEXT_PACK_TOC_INFO:
                case CDROM_CD_TEXT_PACK_TOC_INFO2:
                case CDROM_CD_TEXT_PACK_SIZE_INFO:
                default: {
                    isText = FALSE;
                    printf("Unknown type 0x%x: \"", block->PackType);
                }
                } // end switch

                //
                // have to print previous block's info, if available
                //

                if (isText && block->CharacterPosition != 0) {
                    UCHAR text[13];
                    RtlZeroMemory(text, sizeof(text));
                    RtlCopyMemory(text,
                                  prevBlock->Text + 12 - block->CharacterPosition,
                                  block->CharacterPosition * sizeof(UCHAR));
                    printf("%s", text);
                }


            } // end continuation case

            if (isText) {
                UCHAR text[13];
                RtlZeroMemory(text, sizeof(text));
                RtlCopyMemory(text, block->Text, 12);
                printf("%s", text);
            }

        } // end loop through all blocks
        printf("\n");

    } // end normal printout case

    return 0;
}

DWORD ReadTOCExCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents,
    ATIP, PMA, or CDTEXT data

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  (1-4 is valid)

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD returned;
    DWORD bufferSize = 4; // to get the header
    DWORD i;

    CDROM_READ_TOC_EX params;

    UNREFERENCED_PARAMETER(argv);

    if (argc > 4) {
        printf("Too many args\n");
        return 1;
    }

    //
    // set defaults - FORMAT_TOC, 0, 0
    //

    RtlZeroMemory(&params, sizeof(CDROM_READ_TOC_EX));

    if(argc > 3) params.Msf          = (char)atoi(argv[3]);
    if(argc > 2) params.SessionTrack = (char)atoi(argv[2]);
    if(argc > 1) params.Format       = (char)atoi(argv[1]);

    printf("Params.Format       = 0x%x\n", params.Format);
    printf("Params.SessionTrack = 0x%x\n", params.SessionTrack);
    printf("Params.MSF          = 0x%x\n", params.Msf);

    for (i = 0; i < 2; i++) {

        PUCHAR buffer = LocalAlloc(LPTR, bufferSize);

        if (buffer == NULL) {
            printf("No Memory %d\n", __LINE__);
            return 1;
        }

        returned = 0;
        if (!DeviceIoControl(device,
                             IOCTL_CDROM_READ_TOC_EX,
                             &params,
                             sizeof(CDROM_READ_TOC_EX),
                             buffer,
                             bufferSize,
                             &returned,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            LocalFree(buffer);
            printf("Eject - error sending IOCTL (%d)\n", errorValue);
            return errorValue;
        }

        printf("Successfully got %x bytes:\n", returned);
        PrintBuffer(buffer, returned);

        bufferSize = (buffer[0] << 8) | (buffer[1]);
        LocalFree(buffer);
        bufferSize += 2;
        printf("Now getting %x bytes:\n", bufferSize);

    }
    return 0;
}

DWORD ReadTOCCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    DWORD returned = 0;
    CDB cdb;
    CDROM_TOC toc;

    int numTracks, i;
    PTRACK_DATA track;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    printf("Reading Table of Contents\n");

    //
    // Get the 4 byte TOC header
    //

    returned = FIELD_OFFSET(CDROM_TOC, TrackData[0]);
    memset(&cdb, 0, sizeof(CDB));
    cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    cdb.READ_TOC.Msf = 0;
    cdb.READ_TOC.StartingTrack = 0;
    cdb.READ_TOC.AllocationLength[0] = (UCHAR)(returned >> 8);
    cdb.READ_TOC.AllocationLength[1] = (UCHAR)(returned & 0xff);


    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&toc, &returned, TRUE)) {
        errorValue = GetLastError();
        printf("Error %d sending READ_TOC pass through\n", errorValue);
        return errorValue;
    }

    dbg(printf("READ_TOC pass through returned %d bytes\n", returned));
    numTracks = toc.LastTrack - toc.FirstTrack + 1;
    dbg(printf("Getting %d tracks\n", numTracks));


    returned =
        FIELD_OFFSET(CDROM_TOC, TrackData[0]) +
        (numTracks * sizeof(TRACK_DATA));

    memset(&cdb, 0, sizeof(CDB));
    cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    cdb.READ_TOC.Msf = 0;
    cdb.READ_TOC.StartingTrack = 1;
    cdb.READ_TOC.AllocationLength[0] = (UCHAR)(returned >> 8);
    cdb.READ_TOC.AllocationLength[1] = (UCHAR)(returned & 0xff);

    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&toc, &returned, TRUE)) {
        errorValue = GetLastError();
        printf("Error %d sending READ_TOC pass through\n", errorValue);
        return errorValue;
    }

    dbg(printf("READ_TOC pass through returned %d bytes\n", returned));

    printf("TOC Data Length: %d\n", (toc.Length[0] << 16) | (toc.Length[1]));

    printf("First Track Number: %d\n", toc.FirstTrack);
    printf("Last Track Number: %d\n", toc.LastTrack);


    track = &(toc.TrackData[0]);

    printf("Number    ADR  Control    Address (LBA)\n");
    printf("------    ---  -------    -------------\n");

    for(i = 0; i < numTracks; i++) {

        DWORD lba =
            (track->Address[0] << 24) |
            (track->Address[1] << 16) |
            (track->Address[2] <<  8) |
            (track->Address[3] <<  0);
        UCHAR m,s,f;
        LBA_TO_MSF(lba, m, s, f);

        printf("%6d    %3d  %7d      %3d:%02d:%02d\n",
               track->TrackNumber, track->Adr, track->Control,
               m,s,f);

        track++;
    }
    return errorValue;
}

DWORD PlayCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Plays an audio track

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[1] - the starting track.  Starts at zero if this is not here
    argv[2] - the ending track.  Let track if not specified

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(device);
    printf("This command is not implemented\n");
    return 1;
}

DWORD PauseResumeCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    pauses or resumes audio playback

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[0] - "pause" or "resume"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    CDB cdb;

    char resume;

    UNREFERENCED_PARAMETER(argc);

    if(strcmp("pause", argv[0]) == 0) {
        resume = 0;
    } else {
        resume = 1;
    }

    printf("%s cdrom playback\n", (resume ? "Resuming" : "Pausing"));

    //
    // Unfortunately no one defined the PLAY_INDEX command for us so
    // cheat and use MSF
    //

    memset(&cdb, 0, sizeof(CDB));
    cdb.PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
    cdb.PAUSE_RESUME.Action = resume;

    if (!SptSendCdbToDevice(device, &cdb, 10, NULL, 0, FALSE)) {
        errorValue = GetLastError();
        printf("Error %d sending PAUSE_RESUME pass through\n", errorValue);
        return errorValue;
    }

//    dbg(printf("PAUSE_RESUME pass through returned %d bytes\n", returned));

    return errorValue;
}
DWORD ImageDiskCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    creates an image of the device by reading from sector 0 to N.

Arguments:

    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be 2.

    argv[1] - the file to output to

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{

    HANDLE file;
    PUCHAR buffer;
    READ_CAPACITY_DATA capacityData;
    ULONG   dataSize;
    CDB    cdb;

    ULONG   sectorsPerMaxRead;
    ULONG   currentSector;



    if(argc < 2) {
        printf("not correct number of args\n");
        return -1;
    }

    printf("Opening file %s\n", argv[1]);

    file = CreateFile(argv[1],
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_NEW,
                      FILE_FLAG_SEQUENTIAL_SCAN,
                      NULL);

    if (file == INVALID_HANDLE_VALUE) {
        printf("Error %d creating file %s\n", GetLastError(), argv[1]);
        return -2;
    }

    // read the sector size from the device
    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&capacityData, sizeof(READ_CAPACITY_DATA));
    cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
    dataSize = sizeof(READ_CAPACITY_DATA);

    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&capacityData, &dataSize, TRUE)) {
        printf("Error %d getting capacity info\n", GetLastError());
        return -3;
    }
    // convert the numbers
    PrintBuffer(&capacityData, sizeof(READ_CAPACITY_DATA));
    REVERSE_LONG(&capacityData.BytesPerBlock);
    REVERSE_LONG(&capacityData.LogicalBlockAddress);
    if ( (MAX_READ_SIZE % capacityData.BytesPerBlock) != 0 ) {
        printf("Sector size of %x is not power of 2?!\n", capacityData.BytesPerBlock);
        // capacityData.BytesPerBlock = 512;
        return -5;
    }

    buffer = (PUCHAR)malloc(MAX_READ_SIZE);
    if (!buffer) {
        printf("Unable to alloc %x bytes\n", MAX_READ_SIZE);
        return -4;
    }
    sectorsPerMaxRead = MAX_READ_SIZE / capacityData.BytesPerBlock;


    // read the data from disk and dump to file
    for (currentSector = 0; currentSector <= capacityData.LogicalBlockAddress; currentSector += sectorsPerMaxRead) {

        ULONG sectorsThisRead = sectorsPerMaxRead;

        UpdatePercentageDisplay(currentSector, capacityData.LogicalBlockAddress);
        if (currentSector > capacityData.LogicalBlockAddress - sectorsPerMaxRead) {
            sectorsThisRead = capacityData.LogicalBlockAddress - currentSector;
        }

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(buffer, MAX_READ_SIZE);

        cdb.CDB10.OperationCode     = SCSIOP_READ;
        cdb.CDB10.LogicalBlockByte0 = (UCHAR)(currentSector   >> (8*3));
        cdb.CDB10.LogicalBlockByte1 = (UCHAR)(currentSector   >> (8*2));
        cdb.CDB10.LogicalBlockByte2 = (UCHAR)(currentSector   >> (8*1));
        cdb.CDB10.LogicalBlockByte3 = (UCHAR)(currentSector   >> (8*0));
        cdb.CDB10.TransferBlocksMsb = (UCHAR)(sectorsThisRead >> (8*1));
        cdb.CDB10.TransferBlocksLsb = (UCHAR)(sectorsThisRead >> (8*0));

        dataSize = sectorsThisRead * capacityData.BytesPerBlock;
        if (!SptSendCdbToDevice(device, &cdb, 10, buffer, &dataSize, TRUE)) {
            printf("Error %d reading %x sectors starting at %x\n",
                   GetLastError(), sectorsThisRead, currentSector);
            free(buffer);
            return -6;
        }
        if (dataSize != sectorsThisRead * capacityData.BytesPerBlock) {
            printf("Only got %x of %x bytes reading %x sectors starting at %x\n",
                   dataSize, sectorsThisRead * capacityData.BytesPerBlock,
                   sectorsThisRead, currentSector);
            free(buffer);
            return -7;
        }

        dataSize = sectorsThisRead * capacityData.BytesPerBlock;
        if (!WriteFile(file, buffer, dataSize, &dataSize, NULL)) {
            printf("Error %d writing %x bytes starting at sector %x\n",
                   GetLastError(), dataSize, currentSector);
            free(buffer);
            return -8;
        }

        if (dataSize != sectorsThisRead * capacityData.BytesPerBlock) {
            printf("Only wrote %x of %x bytes writing %x sectors starting at %x\n",
                   dataSize, sectorsThisRead * capacityData.BytesPerBlock,
                   sectorsThisRead, currentSector);
            free(buffer);
            return -9;
        }
    }
    UpdatePercentageDisplay(capacityData.LogicalBlockAddress,
                            capacityData.LogicalBlockAddress
                            );
    free(buffer);
    printf("\nSuccess!\n");
    return 0;
}

DWORD SendCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Parses a hex byte string and creates a cdb to send down.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be 2 or 4

    argv[1] - The CDB to send in a quoted hex byte string
              "47 00 00 00 01 00 00 ff 00 00"

    argv[2] - "SET" or "GET"

    argv[3] - for GET commands: the number of bytes (decimal) to
              expect from the target
              for SET commands: a quoted hex byte string to send to
              the target

NOTE:
    Due to the potentially damaging nature of making sending an
    arbitrary SCSI command to an arbitrary device, this command should
    not be documented outside of this source code.

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;

    UCHAR cdbSize;
    CDB   cdb;

    DWORD setData = FALSE;
    PUCHAR returnedData = NULL;

    DWORD i;

    DWORD dataSize = 0;

////////////////////////////////////////////////////////////////////////////////
// verify the arguments
////////////////////////////////////////////////////////////////////////////////

    if ( argc == 4 ) {
        if (strcmp(argv[2], "get") != 0 &&
            strcmp(argv[2], "set") != 0 &&
            strcmp(argv[2], "GET") != 0 &&
            strcmp(argv[2], "SET") != 0 ) {
            printf("argv2 == %s\n", argv[2]);
            argc = 0; // this will cause help to print
        }
        if (strcmp(argv[2], "set") == 0 ||
            strcmp(argv[2], "SET") == 0 ) {
            setData = TRUE;
        }
    }


    if ( argc != 2 && argc != 4 ) {
        printf("requires one or three args:\n"
               "1)\tquoted hex string for cdb\n"
               "2)\t(optional) GET or SET\n"
               "3)\t(optional) GET: number of bytes to expect\n"
                 "\t(optional) SET: quoted hex string for cdb\n");

        printf("\n");
        printf("Example commands:\n"
               "Send STOP_UNIT to eject drive q:\n"
               "\tcdp q: send \"1b 00 00 00 02 00\"\n"
               "Get CDVD_CAPABILITIES_PAGE from drive q:\n"
               "\tcdp q: send \"5a 40 2a 00 00 00 00 00 1a 00\" get 21\n"
               );


        return 1;
    }

    if (!SptUtilLockVolumeByHandle(device, TRUE)) {
        printf("Failed %x\n", GetLastError());
        return 1;
    }

////////////////////////////////////////////////////////////////////////////////
// parse the arguments
////////////////////////////////////////////////////////////////////////////////

    if (!CmdHelpValidateStringHex(argv[1])) {
        printf("Hex string must be two (0-9,a-f) then one space (repeated)\n");
        return 1;
    }

    //
    // Determine the length of the CDB first
    // sscanf returns the number of things read in (ie. cdb size)
    //

    cdbSize = (UCHAR)sscanf(argv[1],
                            "%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
                            cdb.AsByte +  0, cdb.AsByte +  1,
                            cdb.AsByte +  2, cdb.AsByte +  3,
                            cdb.AsByte +  4, cdb.AsByte +  5,
                            cdb.AsByte +  6, cdb.AsByte +  7,
                            cdb.AsByte +  8, cdb.AsByte +  9,
                            cdb.AsByte + 10, cdb.AsByte + 11,
                            cdb.AsByte + 12, cdb.AsByte + 13,
                            cdb.AsByte + 14, cdb.AsByte + 15
                            );

    //
    // now figure out how much memory we need to allocate
    //

    if (argc == 4) {

        if (setData) {

            if (!CmdHelpValidateStringHexQuoted(argv[3])) {
                printf("Hex string must be two (0-9,a-f) then one space (repeated)\n");
                return 1;
            }

            dataSize = strlen(argv[3]);

            if (dataSize % 3) {
                dataSize /= 3;
                dataSize ++;
            } else {
                dataSize /= 3;
            }

            if (dataSize == 0) {
                printf("Cannot set zero bytes of data\n");
                return 1;
            }

        } else {

            i = sscanf(argv[3], "%x", &dataSize);

            if (i != 1) {
                printf("Error scanning second argument\n");
                return 1;
            }

        }
    }

    //
    // allocate the memory we may need
    //

    if (dataSize != 0) {
        returnedData = (PUCHAR)malloc(dataSize);
        if (returnedData == NULL) {
            printf("Unable to allocate %x bytes for data\n", dataSize);
            return 1;
        }
        memset(returnedData, 0, dataSize);
    }

    //
    // now scan in the data to set, if that's what the user wants.
    // note that since it's already been validated, we can presume
    // the format is (number)(number)(space) repeated
    //

    if (setData) {
        ULONG index;
        PCHAR location = argv[3];

        for (index = 0; index < dataSize; index++) {

            if (sscanf(location, "%x", returnedData + index) != 1) {
                printf("sscanf did not return 1 for index %i\n", index);
                return 1;
            }

            if ((*location + 0 == '\0') ||
                (*location + 1 == '\0')) {
                printf("string too short!\n");
                return 1;
            }
            location += 3;

        }
    }



#if DBG
////////////////////////////////////////////////////////////////////////////////
// provide some user feedback
////////////////////////////////////////////////////////////////////////////////
    //
    // it is the amount of data expected back from the command
    //

    printf("\nSending %x byte Command:\n", cdbSize);
    PrintBuffer(cdb.AsByte, cdbSize);
    if (setData) {
        printf("Setting Buffer:\n");
        PrintBuffer(returnedData, dataSize);
    } else {
        printf("Expecting %#x bytes of data\n", dataSize);
    }
#endif // DBG

////////////////////////////////////////////////////////////////////////////////
// send the command
////////////////////////////////////////////////////////////////////////////////

    while (1) {

        UCHAR senseSize = sizeof(SENSE_DATA);
        SENSE_DATA senseData;
        BOOLEAN retry = FALSE;
        DWORD retryDelay = 0;

        if (!SptSendCdbToDeviceEx(device,
                                  &cdb,
                                  cdbSize,
                                  returnedData, &dataSize,
                                  &senseData, senseSize,
                                  (BOOLEAN)(setData ? FALSE : TRUE),
                                  360) // six minutes
            ) {

            errorValue = 0;
            if (senseSize == 0) {
                errorValue = GetLastError();
                if (errorValue == ERROR_SUCCESS) {
                    errorValue = ERROR_IO_DEVICE;
                }
            } else {
                printf("Sense Data: (%x bytes) Sense %x  ASC %x  ASCQ %x\n",
                       senseSize,
                       senseData.SenseKey & 0xf,
                       senseData.AdditionalSenseCode,
                       senseData.AdditionalSenseCodeQualifier);
                PrintBuffer(&senseData, senseSize);
                SptUtilInterpretSenseInfo(&senseData,
                                          senseSize,
                                          &errorValue,
                                          &retry,
                                          &retryDelay);
            }

            if (retry) {
                printf("Command should be retried in %d.%d seconds\n",
                       (retryDelay / 10), (retryDelay % 10));
                Sleep(retryDelay*10);
            } else {
                printf("Error %d sending command via pass through\n", errorValue);
                break;
            }

        }


        if (!setData) {
            printf("(%x bytes returned)\n",dataSize);
            PrintBuffer(returnedData, dataSize);
        } else {
            printf("Successfully sent the command\n");
        }

        break; // out of for loop

    }

    return errorValue;

}

DWORD TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;

    UNREFERENCED_PARAMETER(device);

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    return STATUS_SUCCESS;
}

DWORD ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    UNREFERENCED_PARAMETER(device);
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD DvdReadStructure(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DVD_READ_STRUCTURE readStructure;
    PUCHAR buffer;
    PDVD_DESCRIPTOR_HEADER header;

    DWORD returned;
    DWORD errorValue = STATUS_SUCCESS;

    printf("argument count is %d\n", argc);

    if(argc <= 1) {
        printf("\tValid structure types are Physical, Copyright, DiskKey, "
               "BCA or Manufacturer\n");
        return STATUS_SUCCESS;
    }

    printf("Argv[1] = %s\n", argv[1]);

    buffer = malloc(sizeof(DVD_DISK_KEY_DESCRIPTOR) +
                    sizeof(DVD_DESCRIPTOR_HEADER));

    if (buffer == NULL) {
        printf("Insufficient memory\n");
        return STATUS_SUCCESS;
    }

    header = (PDVD_DESCRIPTOR_HEADER) buffer;

    if(_stricmp("physical", argv[1]) == 0)  {

        if(argc < 1) {

            printf("reading physical descriptor requires layer number\n");
            return STATUS_SUCCESS;
        }

        readStructure.Format = DvdPhysicalDescriptor;
        readStructure.LayerNumber = (UCHAR)atoi(argv[1]);

    } else if(_stricmp("copyright", argv[1]) == 0) {
        readStructure.Format = DvdCopyrightDescriptor;

    } else if(_stricmp("diskkey", argv[1]) == 0) {
        if(argc < 1) {

            printf("reading physical descriptor requires a session ID\n");
            return STATUS_SUCCESS;
        }

        readStructure.Format = DvdPhysicalDescriptor;
        readStructure.SessionId = atoi(argv[1]);

    } else if(_stricmp("bca", argv[1]) == 0) {
        readStructure.Format = DvdBCADescriptor;

    } else if(_stricmp("manufacturer", argv[1]) == 0) {
        readStructure.Format = DvdManufacturerDescriptor;

    } else {
        printf("\tValid structure types are Physical, Copyright, DiskKey, "
               "BCA or Manufacturer\n");
        return STATUS_SUCCESS;
    }

    returned = 0;

    if(!DeviceIoControl(device,
                        IOCTL_DVD_READ_STRUCTURE,
                        &readStructure,
                        sizeof(DVD_READ_STRUCTURE),
                        buffer,
                        sizeof(DVD_DISK_KEY_DESCRIPTOR),
                        &returned,
                        FALSE)) {

        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
        return errorValue;
    }

    printf("DvdReadStructure returned %d bytes\n", returned);

    printf("Header Length is %#08lx\n", header->Length);

    printf("Header @ %p\n", header);

    printf("Data @ %p\n", &(header->Data[0]));

    if(_stricmp("physical", argv[1]) == 0)  {

        PDVD_LAYER_DESCRIPTOR layer = (PDVD_LAYER_DESCRIPTOR) ((PUCHAR) &(header->Data[0]));
        int i;

        printf("\tBook Version: %d\n", layer->BookVersion);
        printf("\tBook Type: %d\n", layer->BookType);
        printf("\tMinimumRate: %d\n", layer->MinimumRate);
        printf("\tDiskSize: %d\n", layer->DiskSize);
        printf("\tLayerType: %d\n", layer->LayerType);
        printf("\tTrackPath: %d\n", layer->TrackPath);
        printf("\tNumberOfLayers: %d\n", layer->NumberOfLayers);
        printf("\tTrackDensity: %d\n", layer->TrackDensity);
        printf("\tLinearDensity: %d\n", layer->LinearDensity);
        printf("\tStartingDataSector: %#08lx\n", layer->StartingDataSector);
        printf("\tEndDataSector: %#08lx\n", layer->EndDataSector);
        printf("\tEndLayerZeroSector: %#08lx\n", layer->EndLayerZeroSector);
        printf("\tBCAFlag: %d\n", layer->BCAFlag);

        printf("\n");

        for(i = 0; i < sizeof(DVD_LAYER_DESCRIPTOR); i++) {
            printf("byte %d: %#x\n", i, header->Data[i]);
        }

    } else if(_stricmp("copyright", argv[1]) == 0) {

    } else if(_stricmp("diskkey", argv[1]) == 0) {

    } else if(_stricmp("bca", argv[1]) == 0) {

    } else if(_stricmp("manufacturer", argv[1]) == 0) {

    }

    printf("final status %d\n", errorValue);

    return errorValue;
}

DWORD DiskGetPartitionInfo(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PARTITION_INFORMATION partitionInformation;

    DWORD returned;
    DWORD errorValue = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    returned = 0;

    if(!DeviceIoControl(device,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0L,
                        &partitionInformation,
                        sizeof(PARTITION_INFORMATION),
                        &returned,
                        FALSE)) {

        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
        return errorValue;
    }

    printf("IOCTL_DISK_GET_PARTITION_INFO returned %d bytes\n", returned);

    printf("Starting Offset = %#016I64x\n", partitionInformation.StartingOffset.QuadPart);
    printf("Partition Length = %#016I64x\n", partitionInformation.PartitionLength.QuadPart);
    printf("Hidden Sectors = %#08lx\n", partitionInformation.HiddenSectors);
    printf("PartitionNumber = %#08lx\n", partitionInformation.PartitionNumber);
    printf("PartitionType = %#08lx\n", partitionInformation.PartitionType);
    printf("BootIndicator = %s\n", partitionInformation.BootIndicator ? "TRUE" : "FALSE");
    printf("RecognizedPartition = %s\n", partitionInformation.RecognizedPartition ? "TRUE" : "FALSE");
    printf("RewritePartition = %s\n", partitionInformation.RewritePartition ? "TRUE" : "FALSE");

    return errorValue;
}

DWORD IoctlCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a specified ioctl.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be two

    argv[0] - ioctl code in hexadecimal
    argv[1] - quoted string, bytes to send, "" if none
    argv[2] - number of bytes to get back [optional]

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{

    ULONG ctlCode = 0;
    ULONG returned;
    ULONG inputSize = 0;
    ULONG outputSize = 0;
    UCHAR buffer[MAX_IOCTL_BUFFER_SIZE];
    BOOLEAN get;


    if (argc < 3) { // n+1 -- require two args, accept three

        ctlCode = 0;

    } else if (!CmdHelpValidateStringHexQuoted(argv[2])) {

        printf("input hex string invalid\n");
        ctlCode = 0;

    } else {

        //
        // retrieve the ioctl
        //

        (void)sscanf(argv[1], "%x", &ctlCode);

    }

    if (argc > 3) { // n+1 -- require three args.
        (void)sscanf(argv[3], "%x", &outputSize);
        printf("output size: %x\n", outputSize);
    } else {
        outputSize = 0;
    }

    if (outputSize > MAX_IOCTL_OUTPUT_SIZE) {

        printf("output size too large\n");
        ctlCode = 0;

    }

    if (ctlCode == 0) {
        printf("args:\n"
               "1)\tioctl in hex\n"
               "2)\tquoted string of bytes to send, \"\" if none\n"
               "3)\tnumber of bytes to expect\n");
        return -1;
    }

    //////////////////////////////////////////////////////////////////////////
    // ioctl and args are valid.
    //

    RtlZeroMemory(buffer, sizeof(UCHAR)*MAX_IOCTL_BUFFER_SIZE);

    if (strlen(argv[2])) {
        inputSize = MAX_IOCTL_INPUT_SIZE;
        if (!CmdHelpScanQuotedHexString(argv[2], buffer, &inputSize)) {
            printf("Error scanning hex string\n");
            return -1;
        }
    } else {
        inputSize = 0;
    }

    // inputSize of zero is valid as input

    printf("Sending ioctl %x to device %p\n"
           "using input buffer %p of size %x\n"
           "and output buffer %p of size %x\n",
           ctlCode, device,
           ((inputSize == 0) ? NULL : buffer),
           inputSize,
           ((outputSize == 0) ? NULL : buffer),
           outputSize);


    if (!DeviceIoControl(device,
                         ctlCode,
                         ((inputSize == 0) ? NULL : buffer),
                         inputSize,
                         ((outputSize == 0) ? NULL : buffer),
                         outputSize,
                         &returned,
                         FALSE)) {
        printf("Failed with %d\n", GetLastError());
        return GetLastError();
    }

    if (returned != 0) {
        printf("Returned data (%x of %x bytes):\n", returned, outputSize);
        PrintBuffer(buffer, returned);
    } else {
        printf("Command completed successfully\n");
    }

    return 0;
}

DWORD FormatErrorCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Gets and displays the message string associated with an error code.

Arguments:
    device - not used, but required :P

    argc - the number of additional arguments.  should be one

    argv[0] - error code in hexadecimal

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    LPVOID stringBuffer = NULL;
    DWORD errorCode = 0;
    DWORD numOfChars = 0;
    DWORD flags;
    ULONG i;

    //
    // verify number of args and give help.
    //

    if (argc != 2) { // n+1
        printf("requires one argument: the error code in *hex*\n"
               "Example commands:\n"
               "\tcdp c: error 80030306\n"
               "\t(DVD Copy Protection Error)\n"
               );
        return 1;
    }
    i = sscanf(argv[1], "%x", &errorCode);
    if (i < 1) {
        printf("Unable to find a valid hex number in '%s'.\n", argv[1]);
        return 1;
    }
    printf("Formatting error code for 0x%x (%d)\n", errorCode, errorCode);


    flags = 0;
    flags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;
    flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    flags |= FORMAT_MESSAGE_IGNORE_INSERTS;

    numOfChars = FormatMessageA(flags,
                                NULL,
                                errorCode,
                                0, // language indifferent
                                (LPSTR)&stringBuffer, // double pointer
                                0,
                                NULL
                                );

    if (stringBuffer == NULL) {
        printf("No buffer returned?\n");
        return -1;
    }

    if (numOfChars == 0) {
        printf("Size zero buffer returned?\n");
        return -1;
    }

    printf("ERROR MESSAGE RETURNED:\n");
    printf("%s\n", stringBuffer);

    LocalFree(stringBuffer);

    return 0;
}

DWORD FormatMrwCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Formats an MRW-Compliant drive and shows percentage complete

Arguments:

    device - drive to format media as MRW in

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{

#define MRW_FORMAT_BUFFER_SIZE 0xc

    CDB cdb;
    ULONG size = MRW_FORMAT_BUFFER_SIZE;
    SENSE_DATA senseData;
    UCHAR formatBuffer[MRW_FORMAT_BUFFER_SIZE];

    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(formatBuffer, size);
    RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

    cdb.CDB6FORMAT.OperationCode = SCSIOP_FORMAT_UNIT;
    cdb.CDB6FORMAT.FormatControl = 0x11; // FmtData == 1, FormatCode = 1

    //formatBuffer[0x0] = 0x00;
    //formatBuffer[0x1] = 0x00; // (same as 0x82)
    //formatBuffer[0x2] = 0x00;
    formatBuffer[0x3] = 0x08;
    formatBuffer[0x4] = 0xff; //---vvv
    formatBuffer[0x5] = 0xff; //   NumberOfBlocks must be set to 0xffffffff
    formatBuffer[0x6] = 0xff; //
    formatBuffer[0x7] = 0xff; //--^^^^
    formatBuffer[0x8] = 0x90; // format code == 0x24 ( << 2 == 0x90 )
    //formatBuffer[0x9] = 0x00;
    //formatBuffer[0xa] = 0x00;
    //formatBuffer[0xb] = 0x00;

    if (!SptSendCdbToDeviceEx(device,
                              &cdb,
                              6,
                              formatBuffer,
                              &size,
                              &senseData,
                              sizeof(SENSE_DATA),
                              FALSE,
                              60)) {
        printf("Unable to format, %x\n", GetLastError());
        printf("Sense Buffer: %02x/%02x/%02x\n",
               senseData.SenseKey,
               senseData.AdditionalSenseCode,
               senseData.AdditionalSenseCodeQualifier);
        PrintBuffer((PUCHAR)&senseData, sizeof(SENSE_DATA));
        return -1;
    } else if (senseData.SenseKey != SCSI_SENSE_NO_SENSE) {
        printf("Sense Buffer: %02x/%02x/%02x\n",
               senseData.SenseKey,
               senseData.AdditionalSenseCode,
               senseData.AdditionalSenseCodeQualifier);
        PrintBuffer((PUCHAR)&senseData, sizeof(SENSE_DATA));
        return -1;
    }

    printf("format command succeeded (%02x/%02x/%02x)\n",
           senseData.SenseKey,
           senseData.AdditionalSenseCode,
           senseData.AdditionalSenseCodeQualifier);

    return ShowMrwProgressCommand(device, argc, argv);
}

DWORD ShowMrwProgressCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Formats an MRW-Compliant drive and shows percentage complete

Arguments:

    device - drive to format media as MRW in

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    CDB cdb;
    SENSE_DATA sense;
    ULONG size;
    ULONG ignoredLoopCount;
    BOOLEAN succeededOnce;
    BOOLEAN senseHeaderPrinted;

    //
    // loop, displaying percentage done.
    //

    ignoredLoopCount = 0;
    succeededOnce = FALSE;
    senseHeaderPrinted = FALSE;
    while (1) {

#if 0
        RtlZeroMemory(&cdb, sizeof(CDB));

        size = 0;
        if (!SptSendCdbToDevice(device,
                                &cdb,
                                6,
                                NULL,
                                &size,
                                TRUE)) {
            printf("\nUnable to send TUR to get percentage done! %x\n",
                   GetLastError());
            return -1;
        }
        Sleep(500);
#endif // 0

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(&sense, sizeof(SENSE_DATA));

        size = sizeof(SENSE_DATA);

        cdb.AsByte[0] = SCSIOP_REQUEST_SENSE;
        cdb.AsByte[4] = (UCHAR)(sizeof(SENSE_DATA));

        if (!SptSendCdbToDevice(device,
                                &cdb,
                                6,
                                (PUCHAR)&sense,
                                &size,
                                TRUE)) {
            printf("\nUnable to get percentage done! %x\n", GetLastError());
            return -1;
        }

        if (sense.AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY &&
            sense.AdditionalSenseCodeQualifier == SCSI_SENSEQ_FORMAT_IN_PROGRESS &&
            (sense.SenseKeySpecific[0] & 0x80)
            ) {

            ULONG done;
            succeededOnce = TRUE;

            if (senseHeaderPrinted) { printf("\n"); }
            senseHeaderPrinted = FALSE;

            done =
                ((sense.SenseKeySpecific[0] & 0x7f) << (8*2)) |
                ((sense.SenseKeySpecific[1] & 0xff) << (8*1)) |
                ((sense.SenseKeySpecific[2] & 0xff) << (8*0)) ;
            UpdatePercentageDisplay(done, 0x10000);
            ignoredLoopCount = 0;

        } else {

            if (!succeededOnce) {

                if (!senseHeaderPrinted) {

                    senseHeaderPrinted = TRUE;
                    printf("\nSenseData not showing format progress yet: %x/%x/%x ",
                           sense.SenseKey,
                           sense.AdditionalSenseCode,
                           sense.AdditionalSenseCodeQualifier
                           );
                }
                printf(".");

            } else {

                if (senseHeaderPrinted) { printf("\n"); }
                senseHeaderPrinted = FALSE;

                ignoredLoopCount++;
                if (ignoredLoopCount > 50) {
                    printf("\nSenseData: %x/%x/%x\n",
                           sense.SenseKey,
                           sense.AdditionalSenseCode,
                           sense.AdditionalSenseCodeQualifier
                           );
                    printf("\nSenseData not as expected.  Format has "
                           "probably completed.\n");
                    return -1;
                }

            }
            // else let it go on
        }

        Sleep(1000);

    } // while(1) loop

}


BOOLEAN
ModeSelect(
    HANDLE Device,
    PVOID  ModePage,
    ULONG  ModePageSize
    )
{
    CDB cdb;
    ULONG tmp;
    ULONG size;
    PMODE_PARAMETER_HEADER10 header;

    tmp = sizeof(MODE_PARAMETER_HEADER10) + ModePageSize;

    header = malloc(tmp);
    if (header == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlZeroMemory(header, tmp);

    tmp -= 2; // sizeof through field
    header->ModeDataLength[0] = (UCHAR)(tmp >> (8*1));
    header->ModeDataLength[1] = (UCHAR)(tmp >> (8*0));

    tmp += 2; // still used for size...

    RtlCopyMemory(header+1, // pointer math
                  ModePage,
                  ModePageSize);


    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
    cdb.MODE_SELECT10.PFBit = 1;
    cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(tmp >> (8*1));
    cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(tmp >> (8*0));
    size = tmp;

    if (!SptSendCdbToDevice(Device,
                            &cdb,
                            10,
                            (PUCHAR)header,
                            &size,
                            FALSE)) {
        printf("Unable to set mode page %x\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
FillDisk(
    HANDLE Device,
    ULONG  Signature
    )
{
    READ_CAPACITY_DATA capacity;
    ULONG currentLba;
    PULONGLONG data;

    //
    // do a READ_CAPACITY to find the drive's sector size
    // and number of LBAs
    //
    {
        CDB cdb;
        ULONG size;
        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(&capacity, sizeof(READ_CAPACITY_DATA));

        cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
        size = sizeof(READ_CAPACITY_DATA);

        if (!SptSendCdbToDevice(Device,
                                &cdb,
                                10,
                                (PUCHAR)&capacity,
                                &size,
                                TRUE)) {
            printf("Unable to get capacity %x\n", GetLastError());
            return FALSE;
        }
        //
        // convert the numbers
        //

        REVERSE_LONG(&capacity.BytesPerBlock);
        REVERSE_LONG(&capacity.LogicalBlockAddress);

        if ( (capacity.BytesPerBlock % 512) != 0 ) {
            printf("Sector size of %x is not a multiple of 512?!\n", capacity.BytesPerBlock);
            // capacity.BytesPerBlock = 512;
            return FALSE;
        }
    }

    //
    // print for kicks...
    //

    printf("  Bytes Per Block %10d (%8x)\n"
           "Number Of Sectors %10d (%8x)\n",
           capacity.BytesPerBlock,
           capacity.BytesPerBlock,
           capacity.LogicalBlockAddress,
           capacity.LogicalBlockAddress
           );

    //
    // allocate a sector's worth of data
    //

    data = (PLONGLONG)malloc( capacity.BytesPerBlock );
    if (data == NULL) {
        printf("Not enough memory to allocate data\n");
        return FALSE;
    }

    for (currentLba = 0x0; currentLba <= capacity.LogicalBlockAddress; currentLba++) {

        CDB cdb;
        PULONGLONG t = data;
        ULONG size;
        ULONG iterate = capacity.BytesPerBlock / sizeof(ULONGLONG);
        ULONG j;

        if ((currentLba % 100) == 0) {
            UpdatePercentageDisplay(currentLba, capacity.LogicalBlockAddress);
        }

        // for the first ULONGLONG of each sector, put "Sector %08x"
        // in plain text.
        sprintf((PCHAR)t,
                 "Sector %08x",
                 currentLba
                 );

        // RtlZeroMemory(data, capacity.BytesPerBlock);
        for (j=1; j < iterate ; j++, t++) {
            *t  = ((ULONGLONG)Signature) << 32; // signature
            *t += currentLba;                // etc.
        }

        //
        // prepare the "write" operation for this sector
        //

        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.CDB10.OperationCode     = SCSIOP_WRITE;
        cdb.CDB10.LogicalBlockByte0 = (UCHAR)(currentLba   >> (8*3));
        cdb.CDB10.LogicalBlockByte1 = (UCHAR)(currentLba   >> (8*2));
        cdb.CDB10.LogicalBlockByte2 = (UCHAR)(currentLba   >> (8*1));
        cdb.CDB10.LogicalBlockByte3 = (UCHAR)(currentLba   >> (8*0));
        cdb.CDB10.TransferBlocksMsb = 0;
        cdb.CDB10.TransferBlocksLsb = 1;

        size = capacity.BytesPerBlock;

        if (!SptSendCdbToDevice(Device, &cdb, 10, (PUCHAR)data, &size, FALSE)) {
            printf("Error %d writing sectors at %x\n",
                   GetLastError(), currentLba);
            free(data);
            return FALSE;
        }
    }
    UpdatePercentageDisplay(capacity.LogicalBlockAddress, capacity.LogicalBlockAddress);
    free(data);
    data = NULL;
    return TRUE;
}

BOOLEAN WriteImageSpt(HANDLE Device, HANDLE FsHandle, ULONG SectorsToWrite)
{
    ULONG currentLba;
    PULONGLONG data;

    //
    // allocate a packet's worth of data
    //

    data = (PULONGLONG)malloc( CDRW_WRITE_BYTES );
    if (data == NULL)
    {
        printf("Not enough memory to allocate data\n");
        return FALSE;
    }

    for (currentLba = 0x0; currentLba <= SectorsToWrite; currentLba += CDRW_WRITE_SECTORS)
    {
        CDB cdb;
        ULONG size;
        ULONG sectorsThisRead;

        sectorsThisRead = SectorsToWrite - currentLba;
        if ( sectorsThisRead > CDRW_WRITE_SECTORS )
        {
            sectorsThisRead = CDRW_WRITE_SECTORS;
        }

        if ((currentLba % 100) == 0) {
            UpdatePercentageDisplay(currentLba, SectorsToWrite);
        }

        // read in the next bits of data
        {
            ULONG bytesToRead;
            ULONG bytesActuallyRead;

            RtlZeroMemory(data, CDRW_WRITE_BYTES);
            bytesToRead = sectorsThisRead * 2048;
            bytesActuallyRead = 0;

            if ( !ReadFile(FsHandle, data, bytesToRead, &bytesActuallyRead, NULL) )
            {
                printf("Failed to read from sector %x of %x\n",
                       currentLba, SectorsToWrite);
                LocalFree(data);
                return FALSE;
            }
            if ( bytesActuallyRead != bytesToRead )
            {
                printf("Only read %x of %x bytes reading from sector %x of %x\n",
                       bytesActuallyRead, bytesToRead,
                       currentLba, SectorsToWrite);
                LocalFree(data);
                return FALSE;
            }
        }

        //
        // prepare the "write" operation for this sector
        //

        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.CDB10.OperationCode     = SCSIOP_WRITE;
        cdb.CDB10.LogicalBlockByte0 = (UCHAR)(currentLba   >> (8*3));
        cdb.CDB10.LogicalBlockByte1 = (UCHAR)(currentLba   >> (8*2));
        cdb.CDB10.LogicalBlockByte2 = (UCHAR)(currentLba   >> (8*1));
        cdb.CDB10.LogicalBlockByte3 = (UCHAR)(currentLba   >> (8*0));
        cdb.CDB10.TransferBlocksMsb = (UCHAR)(sectorsThisRead >> (8*1));
        cdb.CDB10.TransferBlocksLsb = (UCHAR)(sectorsThisRead >> (8*0));
        size = sectorsThisRead * 2048;

        if (!SptSendCdbToDevice(Device, &cdb, 10, (PUCHAR)data, &size, FALSE)) {
            printf("Error %d writing sectors at %x\n",
                   GetLastError(), currentLba);
            free(data);
            return FALSE;
        }
    }
    UpdatePercentageDisplay(SectorsToWrite, SectorsToWrite);

    free(data);
    data = NULL;
    return TRUE;
}

BOOLEAN WriteImage(HANDLE device, HANDLE fsHandle, ULONG sectorsToWrite)
{
    PUCHAR buffer = NULL;
    ULONG currentSector = 0;


    buffer = LocalAlloc(LPTR, CDRW_WRITE_BYTES);
    if (buffer == NULL)
    {
        return FALSE;
    }


    for (currentSector = 0; currentSector < sectorsToWrite; currentSector+=CDRW_WRITE_SECTORS)
    {
        ULONG bytesToRead = 0;
        ULONG bytesActuallyRead = 0;

        if (sectorsToWrite - currentSector >= CDRW_WRITE_SECTORS)
        {
            bytesToRead = CDRW_WRITE_BYTES;
        }
        else
        {
            bytesToRead = (sectorsToWrite - currentSector) * 2048;
            RtlZeroMemory(buffer, CDRW_WRITE_BYTES);
        }

        if (!ReadFile(fsHandle,
                      buffer,
                      bytesToRead,
                      &bytesActuallyRead,
                      NULL)
            )
        {
            printf("Failed to read from sector %x of %x\n",
                   currentSector, sectorsToWrite);
            LocalFree(buffer);
            return FALSE;
        }
        if (bytesActuallyRead != bytesToRead)
        {
            printf("Only read %x of %x bytes readinf from sector %x of %x\n",
                   bytesActuallyRead, bytesToRead,
                   currentSector, sectorsToWrite);
            LocalFree(buffer);
            return FALSE;
        }

        // always write 64k at a time
        bytesToRead = CDRW_WRITE_BYTES;
        if (!WriteFile(device,
                       buffer,
                       bytesToRead,
                       &bytesActuallyRead,
                       NULL))
        {
            printf("Failed to write from sector %x of %x\n",
                   currentSector, sectorsToWrite);
            LocalFree(buffer);
            return FALSE;
        }
        if (bytesActuallyRead != bytesToRead)
        {
            printf("Only wrote %x of %x bytes readinf from sector %x of %x\n",
                   bytesActuallyRead, bytesToRead,
                   currentSector, sectorsToWrite);
            LocalFree(buffer);
            return FALSE;
        }
        printf(".");
    }
    printf("Success!\n");
    LocalFree(buffer);
    return TRUE;
}

DWORD MrwInitGaaFileSystem(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Writes the GAA with the given FS image

Arguments:

    device - drive to write to...

    argc - the number of additional arguments.  should be one

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    MODE_MRW_PAGE savedModePage;
    HANDLE fsHandle = INVALID_HANDLE_VALUE;
    ULONG sectorsToWrite = 0;

    // open the fs to write
    {
        BY_HANDLE_FILE_INFORMATION fileInfo = {0};

        if (argc != 2)
        {
            printf("Requires an image to write\n");
            return -1;
        }
        printf("Opening %s for FS handle\n", argv[1]);
        fsHandle = CreateFile(argv[1],
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (fsHandle == INVALID_HANDLE_VALUE)
        {
            printf("Unable to open FS file (%x)\n", GetLastError());
            return -1;
        }

        if (!GetFileInformationByHandle(fsHandle, &fileInfo))
        {
            printf("Unable to query file info (%x)\n", GetLastError());
            return -1;
        }

        if (fileInfo.nFileSizeHigh != 0)
        {
            printf("File too large (high size not zero)\n");
            return -1;
        }
        if (fileInfo.nFileSizeLow % 2048)
        {
            printf("File not multiple of 2048 bytes in size\n");
            return -1;
        }
        if (fileInfo.nFileSizeLow > (2048 * 32 * 32))
        {
            printf("File size of %x won't fit in GAA (%x)\n",
                   fileInfo.nFileSizeLow,
                   2048*32*32);
            return -1;
        }
        printf("File passed verification\n");
        sectorsToWrite = fileInfo.nFileSizeLow / 2048;
    }

    RtlZeroMemory(&savedModePage, sizeof(MODE_MRW_PAGE));
    savedModePage.PageCode = 0x3f; // illegal value for MODE_SELECT10

    //
    // first use GET_CONFIGURATION to verify that we're
    // actually on an MRW capable device
    //
    {
        #define MRW_FEATURE_DATA_SIZE (sizeof(GET_CONFIGURATION_HEADER)+sizeof(FEATURE_DATA_MRW))
        GET_CONFIGURATION_IOCTL_INPUT input;
        PGET_CONFIGURATION_HEADER header;
        PFEATURE_DATA_MRW mrwFeature;
        UCHAR data[ MRW_FEATURE_DATA_SIZE ];
        DWORD dataSize;
        DWORD expectedSize;
        DWORD feature;
        ULONG size;

        RtlZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
        RtlZeroMemory(&data, MRW_FEATURE_DATA_SIZE);

        input.Feature = FeatureMrw;
        input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
        size = 0;

        if (!DeviceIoControl(device,
                             IOCTL_CDROM_GET_CONFIGURATION,
                             &input,
                             sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                             data,
                             MRW_FEATURE_DATA_SIZE,
                             &size,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            printf("error requesting GET_CONFIG data for MRW feature (%d)\n", errorValue);
            return errorValue;
        }

        header     = (PGET_CONFIGURATION_HEADER)data;
        mrwFeature = (PFEATURE_DATA_MRW)header->Data;

        expectedSize =
            MRW_FEATURE_DATA_SIZE -
            RTL_SIZEOF_THROUGH_FIELD(GET_CONFIGURATION_HEADER, DataLength);
        dataSize =
            (header->DataLength[0] << (8 * 3)) |
            (header->DataLength[1] << (8 * 2)) |
            (header->DataLength[2] << (8 * 1)) |
            (header->DataLength[3] << (8 * 0));

        if ( dataSize < expectedSize ) {
            printf("data size too small -- drive may not support MRW? (%x)\n", expectedSize);
            return -1;
        }

        feature =
            (mrwFeature->Header.FeatureCode[0] << (8 * 1)) |
            (mrwFeature->Header.FeatureCode[1] << (8 * 0));

        if (feature != FeatureMrw) {
            printf("data size too small -- drive may not support MRW? (%x)\n", feature);
            return -1;
        }

        if (!mrwFeature->Write) {
            printf("Drive supports MRW, but as Read-Only\n");
            return -1;
        }
        if (!mrwFeature->Header.Current) {
            printf("Drive supports MRW, but not with the current medium (may need to be formatted MRW first\n");
            return -1;
        }

    } // end verification

    //
    // ensure we're in the correct mode (data area vs. GAA)
    //
    {
        #define MODE_MRW_PAGE_DATA_SIZE (sizeof(MODE_PARAMETER_HEADER10) + sizeof(MODE_MRW_PAGE))
        PMODE_PARAMETER_HEADER10 header;
        PMODE_MRW_PAGE page;
        PUCHAR data [ MODE_MRW_PAGE_DATA_SIZE ];
        CDB cdb;
        ULONG size;
        ULONG t1, t2;

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(data, MODE_MRW_PAGE_DATA_SIZE);

        size = MODE_MRW_PAGE_DATA_SIZE;
        cdb.MODE_SENSE10.OperationCode       = SCSIOP_MODE_SENSE10;
        cdb.MODE_SENSE10.Dbd                 = 1;
        cdb.MODE_SENSE10.PageCode            = MODE_PAGE_MRW;
        cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(MODE_MRW_PAGE_DATA_SIZE >> 8);
        cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(MODE_MRW_PAGE_DATA_SIZE & 0xff);

        PrintBuffer(&cdb, 10);

        if (!SptSendCdbToDevice(device,
                                &cdb,
                                10,
                                (PUCHAR)&data,
                                &size,
                                TRUE)) {
            printf("Unable to get MRW mode page %x\n", GetLastError());

            // FAKE IT FOR NOW... BUGBUG
            header = (PMODE_PARAMETER_HEADER10)data;
            RtlZeroMemory(data, MODE_MRW_PAGE_DATA_SIZE);
            header->ModeDataLength[0] = 0;
            header->ModeDataLength[1] = 0xE;
            page = (PMODE_MRW_PAGE)(header+1);
            page->PageCode = MODE_PAGE_MRW;
            page->PageLength = 0x6;
            page->LbaSpace = 0;
        }

        header = (PMODE_PARAMETER_HEADER10)data;
        t1 = (header->ModeDataLength[0] << (8*1)) |
             (header->ModeDataLength[1] << (8*0)) ;
        t2 = MODE_MRW_PAGE_DATA_SIZE -
             RTL_SIZEOF_THROUGH_FIELD(MODE_PARAMETER_HEADER10, ModeDataLength);

        if (t1 != t2) {
            // size is wrong
            printf("MRW mode page wrong size, %x != %x\n", t1, t2);
            return -1;
        }
        if ((header->BlockDescriptorLength[0] != 0) ||
            (header->BlockDescriptorLength[1] != 0) ) {
            printf("MRW drive force a block descriptor %x %x\n",
                   header->BlockDescriptorLength[0],
                   header->BlockDescriptorLength[1]);
            return -1;
        }

        page = (PMODE_MRW_PAGE)(header+1); // pointer arithmetic
        if (page->PageCode != MODE_PAGE_MRW) {
            printf("MRW mode page has wrong page code, %x != %x\n",
                   page->PageCode, MODE_PAGE_MRW);
            return -1;
        }
        if (page->LbaSpace) {
            printf("MRW mode page is set to GAA\n",
                   page->PageCode, MODE_PAGE_MRW);
            // ModeSelect()...
            //return -1;
        }

        RtlCopyMemory(&savedModePage, page, sizeof(MODE_MRW_PAGE));
    }

    savedModePage.LbaSpace = 1;
    if (!ModeSelect(device, &savedModePage, sizeof(MODE_MRW_PAGE))) {
        printf("Unable to set MRW mode page to use GAA (%x)\n", GetLastError());
        return -1;
    }

    if (!WriteImageSpt(device, fsHandle, sectorsToWrite)) {
        printf("Unable to fill the GAA with the FS (%x)\n", GetLastError());
    }
    printf("\nFinished Writing General Application Area!\n");

    savedModePage.LbaSpace = 0;
    if (!ModeSelect(device, &savedModePage, sizeof(MODE_MRW_PAGE))) {
        printf("Unable to revert from GAA space -- disc may be unusable! (%x)\n",
               GetLastError());
        return -1;
    }
    return 0;
}


DWORD MrwInitTestPatternCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Initializes a disk to contain 64-bit numbers that equate to
    the sector's LBA.

Arguments:

    device - drive to write to...

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    MODE_MRW_PAGE savedModePage;

    RtlZeroMemory(&savedModePage, sizeof(MODE_MRW_PAGE));
    savedModePage.PageCode = 0x3f; // illegal value for MODE_SELECT10

    //
    // first use GET_CONFIGURATION to verify that we're
    // actually on an MRW capable device
    //
    {
        #define MRW_FEATURE_DATA_SIZE (sizeof(GET_CONFIGURATION_HEADER)+sizeof(FEATURE_DATA_MRW))
        GET_CONFIGURATION_IOCTL_INPUT input;
        PGET_CONFIGURATION_HEADER header;
        PFEATURE_DATA_MRW mrwFeature;
        UCHAR data[ MRW_FEATURE_DATA_SIZE ];
        DWORD dataSize;
        DWORD expectedSize;
        DWORD feature;
        ULONG size;

        RtlZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
        RtlZeroMemory(&data, MRW_FEATURE_DATA_SIZE);

        input.Feature = FeatureMrw;
        input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
        size = 0;

        if (!DeviceIoControl(device,
                             IOCTL_CDROM_GET_CONFIGURATION,
                             &input,
                             sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                             data,
                             MRW_FEATURE_DATA_SIZE,
                             &size,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            printf("error requesting GET_CONFIG data for MRW feature (%d)\n", errorValue);
            return errorValue;
        }

        header     = (PGET_CONFIGURATION_HEADER)data;
        mrwFeature = (PFEATURE_DATA_MRW)header->Data;

        expectedSize =
            MRW_FEATURE_DATA_SIZE -
            RTL_SIZEOF_THROUGH_FIELD(GET_CONFIGURATION_HEADER, DataLength);
        dataSize =
            (header->DataLength[0] << (8 * 3)) |
            (header->DataLength[1] << (8 * 2)) |
            (header->DataLength[2] << (8 * 1)) |
            (header->DataLength[3] << (8 * 0));

        if ( dataSize < expectedSize ) {
            printf("data size too small -- drive may not support MRW? (%x)\n", expectedSize);
            return -1;
        }

        feature =
            (mrwFeature->Header.FeatureCode[0] << (8 * 1)) |
            (mrwFeature->Header.FeatureCode[1] << (8 * 0));

        if (feature != FeatureMrw) {
            printf("data size too small -- drive may not support MRW? (%x)\n", feature);
            return -1;
        }

        if (!mrwFeature->Write) {
            printf("Drive supports MRW, but as Read-Only\n");
            return -1;
        }
        if (!mrwFeature->Header.Current) {
            printf("Drive supports MRW, but not with the current medium (may need to be formatted MRW first\n");
            return -1;
        }

    } // end verification

    //
    // ensure we're in the correct mode (data area vs. GAA)
    //

#if 0
    {
        #define MODE_MRW_PAGE_DATA_SIZE (sizeof(MODE_PARAMETER_HEADER10) + sizeof(MODE_MRW_PAGE))
        PMODE_PARAMETER_HEADER10 header;
        PMODE_MRW_PAGE page;
        PUCHAR data [ MODE_MRW_PAGE_DATA_SIZE ];
        CDB cdb;
        ULONG size;
        ULONG t1, t2;

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(data, MODE_MRW_PAGE_DATA_SIZE);

        size = MODE_MRW_PAGE_DATA_SIZE;
        cdb.MODE_SENSE10.OperationCode       = SCSIOP_MODE_SENSE10;
        cdb.MODE_SENSE10.Dbd                 = 1;
        cdb.MODE_SENSE10.PageCode            = MODE_PAGE_MRW;
        cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(MODE_MRW_PAGE_DATA_SIZE >> 8);
        cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(MODE_MRW_PAGE_DATA_SIZE & 0xff);

        PrintBuffer(&cdb, 10);

        if (!SptSendCdbToDevice(device,
                                &cdb,
                                10,
                                (PUCHAR)&data,
                                &size,
                                TRUE)) {
            printf("Unable to get MRW mode page %x\n", GetLastError());

            // FAKE IT FOR NOW... BUGBUG
            header = (PMODE_PARAMETER_HEADER10)data;
            RtlZeroMemory(data, MODE_MRW_PAGE_DATA_SIZE);
            header->ModeDataLength[0] = 0;
            header->ModeDataLength[1] = 0xE;
            page = (PMODE_MRW_PAGE)(header+1);
            page->PageCode = MODE_PAGE_MRW;
            page->PageLength = 0x6;
            page->LbaSpace = 0;
        }

        header = (PMODE_PARAMETER_HEADER10)data;
        t1 = (header->ModeDataLength[0] << (8*1)) |
             (header->ModeDataLength[1] << (8*0)) ;
        t2 = MODE_MRW_PAGE_DATA_SIZE -
             RTL_SIZEOF_THROUGH_FIELD(MODE_PARAMETER_HEADER10, ModeDataLength);

        if (t1 != t2) {
            // size is wrong
            printf("MRW mode page wrong size, %x != %x\n", t1, t2);
            return -1;
        }
        if ((header->BlockDescriptorLength[0] != 0) ||
            (header->BlockDescriptorLength[1] != 0) ) {
            printf("MRW drive force a block descriptor %x %x\n",
                   header->BlockDescriptorLength[0],
                   header->BlockDescriptorLength[1]);
            return -1;
        }

        page = (PMODE_MRW_PAGE)(header+1); // pointer arithmetic
        if (page->PageCode != MODE_PAGE_MRW) {
            printf("MRW mode page has wrong page code, %x != %x\n",
                   page->PageCode, MODE_PAGE_MRW);
            return -1;
        }
        if (page->LbaSpace) {
            printf("MRW mode page is set to GAA\n",
                   page->PageCode, MODE_PAGE_MRW);
            // ModeSelect()...
            return -1;
        }

        RtlCopyMemory(&savedModePage, page, sizeof(MODE_MRW_PAGE));
    }

    savedModePage.LbaSpace = 1;
    if (!ModeSelect(device, &savedModePage, sizeof(MODE_MRW_PAGE))) {
        printf("Unable to set MRW mode page to use GAA (%x)\n", GetLastError());
        return -1;
    }

    if (!FillDisk(device, '\0wrm')) {
        printf("Unable to fill the GAA (%x)\n", GetLastError());
    }
    printf("\nFinished Writing General Application Area!\n");

    savedModePage.LbaSpace = 0;
    if (!ModeSelect(device, &savedModePage, sizeof(MODE_MRW_PAGE))) {
        printf("Unable to revert from GAA space -- disc may be unusable! (%x)\n",
               GetLastError());
        return -1;
    }
#endif // 0

    if (!FillDisk(device, '\0WRM')) {
        printf("Unable to fill the disc (%x)\n", GetLastError());
        return -1;
    }
    printf("\nFinished Writing Defect-managed Area!\n");

    return 0;
}

DWORD
WaitForReadDiscInfoCommand(
    HANDLE device,
    int argc,
    char *argv[]
    )
{
    CDB cdb;
    DWORD size;
    DISK_INFORMATION diskInfo;
    DWORD i;

    //
    // loop using SCSIOP_READ_DISK_INFORMATION (0x51) since
    // that seems to fail for *ALL* drives until the drive is ready
    //

    printf("Waiting for ReadDiscInfo");
    for (i=0; ; i++) {

        size = sizeof(DISK_INFORMATION);
        RtlZeroMemory(&diskInfo, sizeof(DISK_INFORMATION));
        RtlZeroMemory(&cdb, sizeof(CDB));

        cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
        cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(size >> 8);
        cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(size & 0xff);

        if (SptSendCdbToDeviceEx(device, &cdb, 10,
                                 (PUCHAR)&diskInfo, &size,
                                 NULL, 0,
                                 TRUE, 10)) {
            printf("Succeeded! (%d seconds)\n", i);
            return 0;
        }
        // should verify the errors are valid errors (AllowedReadDiscInfo[])?

        // need to sleep here so we don't overload the unit!
        Sleep(1000); // one second
        if (i%10 == 0) {
            printf(".");
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sfp\sfp.c ===
#include <windows.h>

#include <stdio.h>
#include <tchar.h>

#define WINLOGON_KEY_NAME   TEXT("Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SFP_VALUE_NAME      TEXT("SFCDisable")
#define SFP_TEMP_KEY_NAME   TEXT("SFPLoadedAHiveHere")

#define SFP_ENABLED         	0
#define SFP_DISABLED_ALWAYS 	1
#define SFP_DISABLED_ONCE       2
#define SFP_ENABLED_NO_POPUPS	4

VOID PrintSfpState(DWORD State, BOOL fDisplayNotes) {

   switch(State) {
       case SFP_ENABLED: {
           printf("on");
           break;
       }
       case SFP_DISABLED_ALWAYS: {
           printf("off");
	   if(fDisplayNotes) {
               printf("\nNOTE: A kernel debugger MUST be attached for this setting to work");
	   }
           break;
       }
       case SFP_DISABLED_ONCE: {
           printf("off only for next boot");
	   if(fDisplayNotes) {
               printf("\nNOTE: A kernel debugger MUST be attached for this setting to work");
	   }
           break;
       }
       case SFP_ENABLED_NO_POPUPS: {
           printf("on - popups disabled");
           break;
       }
       default: {
           printf("unknown value %#x", State);
           break;
       }
   }
   printf("\n");
}

LONG SetCurrentSfpState(HKEY Key, DWORD State) {

    DWORD length = sizeof(DWORD);

    return RegSetValueEx(Key,
                         SFP_VALUE_NAME,
                         0L,
                         REG_DWORD,
                         (LPBYTE) &State,
                         length);
}

LONG GetCurrentSfpState(HKEY Key, DWORD *State) {

    LONG status;
    DWORD type;
    DWORD value;
    PBYTE buffer = (PBYTE) &value;
    DWORD length = sizeof(DWORD);

    status = RegQueryValueEx(Key,
                             SFP_VALUE_NAME,
                             NULL,
                             &type,
                             buffer,
                             &length);

    if(status != ERROR_SUCCESS) {
        printf("Error %d opening key %s\n", status, SFP_VALUE_NAME);
        return status;

    } else if((type != REG_DWORD) || (length != sizeof(DWORD))) {
        printf("Key %s is wrong type (%d)\n", SFP_VALUE_NAME, type);
        return ERROR_INVALID_DATA;
    }

    *State = value;

    return ERROR_SUCCESS;
}

LONG OpenSfpKey(HKEY RootKey, HKEY *Key) {

    return RegOpenKeyEx(RootKey,
                        WINLOGON_KEY_NAME,
                        0L,
                        KEY_ALL_ACCESS,
                        Key);
}

LONG GetPrivileges(void) {
    
    HANDLE tokenHandle;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if(!LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &luid)) {
        return GetLastError();
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if(!OpenProcessToken(GetCurrentProcess(), 
                         TOKEN_ADJUST_PRIVILEGES,
                         &tokenHandle)) {
        return GetLastError();
    }

    if(!AdjustTokenPrivileges(tokenHandle, 
                              FALSE, 
                              &tp,
                              sizeof(TOKEN_PRIVILEGES),
                              NULL,
                              NULL)) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

LONG LoadSystemHive(PTCHAR HivePath, HKEY *Key) {

    TCHAR buffer[512];

    LONG status;

    status = GetPrivileges();

    if(status != ERROR_SUCCESS) {
        return status;
    }

    _stprintf(buffer, "%s\\System32\\Config\\Software", HivePath);

    //
    // First load the hive into the registry.
    //

    status = RegLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME, buffer);

    if(status != ERROR_SUCCESS) {
        return status;
    }

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                          SFP_TEMP_KEY_NAME,
                          0L,
                          KEY_ALL_ACCESS,
                          Key);

    if(status != ERROR_SUCCESS) {
        RegUnLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME);
    }

    return status;
}

void UnloadSystemHive(void) {
    RegUnLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME);
    return;
}

void PrintUsage(void) {
    printf("sfp [-p installation root] [on | off | offonce | onnopopup]\n");
    printf("\ton        - SFP is on at the next boot\n");
    printf("\toff       - SFP is off at the next boot\n");
    printf("\toffonce   - SFP will be turned off for the next boot and\n");
    printf("\t            will automatically turn back on for subsequent boots\n");
    printf("\tonnopopup - SFP is on at the next boot, with popups disabled\n");
    return;
}

int __cdecl main(int argc, char *argv[]) {

    HKEY rootKey;
    HKEY sfpKey = NULL;

    PTCHAR installationPath = NULL;

    DWORD currentState;
    DWORD stateArgNum = -1;
    DWORD newState = -1;

    LONG status;

    if(argc == 1) {

        //
        // Nothing to do.
        //

    } else if(argc == 2) {
        // can only be changing state.
        stateArgNum = 1;
    } else if(argc == 3) {
        // two args - only valid choice is "-p path"
        if(_tcsicmp(argv[1], "-p") == 0) {
            installationPath = argv[2];
        } else {
            PrintUsage();
            return -1;
        }
    } else if(argc == 4) {
        if(_tcsicmp(argv[1], "-p") != 0) {
            PrintUsage();
            return -1;
        }
        installationPath = argv[2];
        stateArgNum = 3;
    }

    if(stateArgNum != -1) {
        PCHAR arg = argv[stateArgNum];

        if(_tcsicmp(arg, "on") == 0) {
            newState = SFP_ENABLED;
        } else if(_tcsicmp(arg, "off") == 0) {
            newState = SFP_DISABLED_ALWAYS;
        } else if(_tcsicmp(arg, "offonce") == 0) {
            newState = SFP_DISABLED_ONCE;
        } else if(_tcsicmp(arg, "onnopopup") == 0) {
            newState = SFP_ENABLED_NO_POPUPS;
        } else {
            PrintUsage();
            return -1;
        }
    }

    if(installationPath != NULL) {
        status = LoadSystemHive(installationPath, &rootKey);
        if(status != ERROR_SUCCESS) {
            printf("Error %d loading hive at %s\n", status, installationPath);
            return status;
        }
    } else {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SOFTWARE"),
                              0L,
                              KEY_ALL_ACCESS,
                              &rootKey);
        if(status != ERROR_SUCCESS) {
            printf("Error %d opening software key\n", status);
            return status;
        }
    }

    try {
        status = OpenSfpKey(rootKey, &sfpKey);
    
        if(status != ERROR_SUCCESS) {
            printf("Error %d opening %s\n", status, WINLOGON_KEY_NAME);
            leave;
        }
    
        status = GetCurrentSfpState(sfpKey, &currentState);

        if(status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_SUCCESS;
            currentState = SFP_ENABLED;
        }
    
        if(status == ERROR_SUCCESS) {
            printf("Current SFP state is ");
            PrintSfpState(currentState, (stateArgNum == -1) ? TRUE : FALSE);

            if(stateArgNum != -1) {
                status = SetCurrentSfpState(sfpKey, newState);
                if(status == ERROR_SUCCESS) {
                    status = GetCurrentSfpState(sfpKey, &currentState);

                    if(status == ERROR_SUCCESS) {
                        printf("New SFP state is ");
                        PrintSfpState(currentState,TRUE);
                        printf("This change will not take effect until you "
                               "reboot your system\n");
                    }
                } else {
                    printf("Error %d setting SFP state to %d\n", 
                           status, newState);
                }
            }
        } else {
            printf("Error %d getting current SFP state\n", status);
        }
    } finally {
        if(sfpKey != NULL) {
            RegCloseKey(sfpKey);
        }

        UnloadSystemHive();
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\setuplog\lib\setuplib.c ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <time.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlwapi.h>

// For PnP Stuff

#include <devguid.h>
#include <initguid.h>
#include <setupapi.h>
#include <syssetup.h>
#include <regstr.h>
#include <setupbat.h>
#include <cfgmgr32.h>



#include "tchar.h"
#include "string.h"
#include "setuplog.h"
#include "setuplib.h"
#include "pnpstuff.h"

char * Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
char * Months[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

extern   DEV_INFO *g_pdiDevList;          // Head of device list
char     OutputBuffer[ 8192 ];
#define  MAX_WAVEOUT_DEVICES 2

struct {
// Sound Card
  int  nNumWaveOutDevices;                     // Number of WaveOut Devices (~ number of sound cards)
  char szWaveOutDesc[MAX_WAVEOUT_DEVICES][128];// WaveOut description
  char szWaveDriverName[MAX_WAVEOUT_DEVICES][128]; // Wave Driver name
} m;

#define SHORTCUT "IDW Logging Tool.lnk"

char szValidHandle[]    = "\r\nValid Handle\r\n";
char szInvalidHandle[]  = "\r\nInvalid handle. Err: %d\r\n";
char szBadWrite[]       = "WriteFile failed. Err: %d\r\n";
char szGoodWrite[]      = "WriteFile succeeded\r\n";



// From warndoc.cpp:
VOID  
GetNTSoundInfo()
{
    HKEY                hKey;
    DWORD               cbData;
    ULONG               ulType;
    LPTSTR              sSubKey=TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
    INT                 i;
    TCHAR               szSubKeyName[256];
    TCHAR               szTempString[256];


    // Get Sound Card Info
    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
       m.nNumWaveOutDevices = 0;
       // Loop through the key to see how many wave devices we have, but skip mmdrv.dll.
       for (i = 0; i <= 1; i++){
          if (i)
             _stprintf(szSubKeyName, TEXT("wave%d"),i);
          else
             _tcscpy(szSubKeyName, TEXT("wave"));

          cbData = sizeof szTempString;
          if (RegQueryValueEx(hKey, szSubKeyName, 0, &ulType, (LPBYTE)szTempString, &cbData))
              break;
          else{
             if (szTempString[0] // We want to skip mmdrv.dll - not relevant.
                 && _tcscmp(szTempString, TEXT("mmdrv.dll"))){
                strcpy(&m.szWaveDriverName[m.nNumWaveOutDevices][0], szTempString);
                m.nNumWaveOutDevices++;
             }
          }
       }
    }

    if (hKey){
       RegCloseKey(hKey);
       hKey = 0;
    }

    sSubKey = (LPTSTR)TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");
    hKey = 0;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
       // Now grab the sound device string for each wave device
       for (i = 0; i < m.nNumWaveOutDevices; i++){
          cbData = sizeof szTempString;
          if (RegQueryValueEx(hKey, m.szWaveDriverName[i], 0, &ulType, (LPBYTE)szTempString, &cbData))
             _tcscpy(m.szWaveOutDesc[i], TEXT("Unknown"));
          else
             _tcscpy(m.szWaveOutDesc[i], szTempString);
       }
    }

    if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
    }
    return;
}

//
// GetVidInfo reads registry information about the installed
// video cards and produces one string
//
#define HWKEY TEXT("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services")
#define SERVICEKEY TEXT("SYSTEM\\CurrentControlSet\\Services")

#define DESCVAL TEXT("Device Description")
#define TYPEVAL TEXT("HardwareInformation.ChipType")
#define DACVAL  TEXT("HardwareInformation.DacType")
#define MEMVAL  TEXT("HardwareInformation.MemorySize")


VOID 
GetVidInfo (LPTSTR vidinfo)
{

   HKEY     hkHardware;
   HKEY     hkCard;
   DWORD    dwSize;
   TCHAR    szBuf[256];
   WCHAR    szWideBuf[128];
   TCHAR    szSubKey[128];
   DWORD    dwIndex=0;
   DWORD    dwMem;

   *vidinfo = '\0';
   //
   // Look in HWKEY to find out what services are used.
   //
   if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, HWKEY, 0, KEY_READ, &hkHardware))
      return;

   dwSize=128;
   while (ERROR_SUCCESS == RegEnumKeyEx (hkHardware, dwIndex++,szSubKey, &dwSize,NULL,NULL,NULL,NULL)){
      //
      // Append the subkey name to SERVICEKEY. Look up only Device0 for this card
      //
      _stprintf (szBuf, ("%s\\%s\\Device0"), SERVICEKEY, szSubKey);
      RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ, &hkCard);
      //
      // First get the description
      //
      dwSize=256;
      if (ERROR_SUCCESS == RegQueryValueEx (hkCard, DESCVAL, NULL, NULL, szBuf, &dwSize)){
         if (_tcsclen(vidinfo)+dwSize < 254){
            _tcscat (vidinfo, szBuf);
            _tcscat (vidinfo, TEXT(" "));
         }
      }

      //
      // Read the chip type. This is a UNICODE string stored in REG_BINARY format
      //
      dwSize=256;
      lstrcpyW (szWideBuf, L"ChipType:");
      if (ERROR_SUCCESS == RegQueryValueEx (hkCard,TYPEVAL,NULL, NULL, (LPBYTE)(szWideBuf+9), &dwSize)){
         if ((dwSize=lstrlen(vidinfo))+lstrlenW(szWideBuf)<254)         {
            WideCharToMultiByte (CP_ACP, 0,
                              szWideBuf, -1,
                              vidinfo+dwSize, 256-dwSize, NULL,NULL);
            lstrcat (vidinfo, " ");
         }
      }

    //
    // Read the DAC. Another UNICODE string
    //
    dwSize=256;
    lstrcpyW (szWideBuf, L"DACType:");
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard,DACVAL,NULL, NULL, (LPBYTE)(szWideBuf+8), &dwSize)){
        if ((dwSize=lstrlen(vidinfo))+lstrlenW(szWideBuf)<254){
            WideCharToMultiByte (CP_ACP, 0,
                              szWideBuf, -1,
                              vidinfo+dwSize, 256-dwSize, NULL,NULL);
        lstrcat (vidinfo, " ");
        }
    }
    //
    // Read the memory size. This is a binary value.
    //
    dwSize=sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard, MEMVAL, NULL,NULL,(LPBYTE)&dwMem, &dwSize)){
        _stprintf (szBuf, TEXT("Memory:0x%x ;"), dwMem);
        if (_tcsclen(vidinfo)+lstrlen(szBuf)<255)
            _tcscat (vidinfo, szBuf);
    }
    RegCloseKey (hkCard);
    dwSize=128;
   }
   RegCloseKey (hkHardware);
}


//
// Hydra is denoted by "Terminal Server" in the ProductOptions key
//
BOOL 
IsHydra ()
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPTSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) {
        if (_tcscmp( p, TEXT("Terminal Server") ) == 0) {
            rVal = TRUE;
            break;
        }
        p += (_tcslen( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


VOID
GetBuildNumber( LPTSTR BuildNumber )
{

    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize= sizeof( osVer );

    if (GetVersionEx( &osVer )&&osVer.dwMajorVersion >= 5) {
        wsprintf( BuildNumber, TEXT("%d"), osVer.dwBuildNumber );
    } else {
        lstrcpy( BuildNumber, TEXT("") );  // return 0 if unknown
    }


} // GetBuildNumber


/*
BOOL
GetPnPDisplayInfo(
    LPTSTR pOutputData
    )
{
    BOOL            bRet = FALSE;
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD           index = 0;
    TCHAR           RegistryProperty[256];
    ULONG           BufferSize;

    //
    // Let's find all the video drivers that are installed in the system
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    while (hDevInfo != INVALID_HANDLE_VALUE){
        if (bRet) 
            strcat(pOutputData, TEXT(",") );
 
        ZeroMemory(&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiEnumDeviceInfo(hDevInfo,
                                   index++,
                                   &DeviceInfoData))
            break;
        BufferSize = sizeof(RegistryProperty);
        if (CR_SUCCESS ==
                CM_Get_Device_ID(DeviceInfoData.DevInst,
                                 RegistryProperty,
                                 sizeof(RegistryProperty),
                                 0)){
            bRet = TRUE;
            strcat(pOutputData, RegistryProperty);
        }
    }
    return (bRet);
}
*/


VOID 
ConnectAndWrite(LPTSTR MachineName,
                LPTSTR Buffer
    )
{
   NETRESOURCE   NetResource ;
   TCHAR         szLogFile[ MAX_PATH ];
   TCHAR          szBinPath[MAX_PATH];
   TCHAR          szExePath[MAX_PATH];
   TCHAR          szErr[100];

   HANDLE        hWrite = INVALID_HANDLE_VALUE;
   HANDLE        hDebug = INVALID_HANDLE_VALUE;
   BOOL          bRet;
   DWORD         dwError;
   DWORD         Size, Actual ;


   //
   // Blow through the list of servers.
   // and change the g_szServerShare to match.
   //

   if (TRUE == IsServerOnline(MachineName, NULL)){
      
      //
      // Set the server name now as we now have it
      // into the outputbuffer
      //
    _stprintf (Buffer+_tcsclen(Buffer),
             TEXT("IdwlogServer:%s\r\n"), g_szServerShare);
      
      ZeroMemory( &NetResource, sizeof( NetResource ) );
      NetResource.dwType = RESOURCETYPE_DISK ;
      NetResource.lpLocalName = "" ;
      NetResource.lpRemoteName = g_szServerShare;
      NetResource.lpProvider = "" ;

      GetModuleFileName (NULL, szExePath, MAX_PATH);
      // First, try to connect with the current user ID

      dwError = WNetAddConnection2( &NetResource,NULL,NULL,0 );
      if (dwError)
         dwError = WNetAddConnection2( &NetResource,LOGSHARE_PW,LOGSHARE_USER,0 );
      dwError = 0; // Hard reset.

      if ( dwError == 0 ){
         _stprintf (szLogFile,  TEXT("%s\\%s"),g_szServerShare, MachineName );
         hDebug = CreateFile(TEXT("C:\\setuplog.dbg"),
                             GENERIC_WRITE,
                             0, NULL, CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_WRITE_THROUGH,
                             NULL);
         if (hDebug != INVALID_HANDLE_VALUE)
            WriteFile (hDebug, szExePath, _tcsclen(szExePath), &Actual, NULL);
        
         hWrite = CreateFile( szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                           NULL );

         if ( hWrite != INVALID_HANDLE_VALUE ){
            SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
            SECURITY_DESCRIPTOR sd;
            if (hDebug != INVALID_HANDLE_VALUE)
                WriteFile (hDebug, szValidHandle, sizeof(szValidHandle), &Actual, NULL);

            Size = _tcsclen( Buffer );
            bRet = WriteFile( hWrite, Buffer, Size, &Actual, NULL );

            if (!bRet){
                if (hDebug != INVALID_HANDLE_VALUE){
                   _stprintf (szErr, szBadWrite, GetLastError());
                   WriteFile (hDebug, szErr, lstrlen(szErr), &Actual, NULL);
                }
            }
            else{
                if (hDebug != INVALID_HANDLE_VALUE)
                   WriteFile (hDebug, szGoodWrite, sizeof(szGoodWrite), &Actual, NULL);
            }
            CloseHandle( hWrite );
            //
            // We should delete the shortcut to idwlog from startup group.
            //
            SHGetFolderPath (NULL, CSIDL_COMMON_STARTUP, NULL,0,szBinPath);
            PathAppend (szBinPath, SHORTCUT);
            DeleteFile (szBinPath);

            //
            // If this is idwlog.exe, delete the program.
            //  We only need to write once.
            //
            if (strstr (CharLower(szExePath), "idwlog.exe"))
               MoveFileEx ((LPCTSTR)szExePath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }
        else{
            if (hDebug != INVALID_HANDLE_VALUE){
                _stprintf (szErr, szInvalidHandle, GetLastError());
                WriteFile (hDebug, szErr, _tcsclen(szErr), &Actual, NULL);
            }
        }
        WNetCancelConnection2( g_szServerShare, 0, TRUE );
        if (hDebug != INVALID_HANDLE_VALUE)
           CloseHandle (hDebug);
      }
   }
}


VOID
WriteDataToFile (IN LPTSTR  szFileName, 
                 IN LPTSTR  szFrom,
                 IN LPNT32_CMD_PARAMS lpCmdL)
{

    TCHAR          username[MY_MAX_UNLEN + 1];
    TCHAR          userdomain[ DNLEN+2 ];
    TCHAR          architecture[ 16 ];
    SYSTEM_INFO    SysInfo ;

    TCHAR          build_number[256];
    TCHAR          time[ 32 ];
    DWORD          Size;
    DISPLAY_DEVICE displayDevice;
    DWORD          iLoop;
    DEVMODE        dmCurrent;
    TCHAR          displayname[MY_MAX_UNLEN + 1];

    LPTSTR         pch;
    TCHAR          localename[4];   // locale abbreviation
    TCHAR          netcards[256]    = "\0";
    TCHAR          vidinfo[256]     = "\0";
    TCHAR          modem[256]       = "\0";
    TCHAR          scsi[256]        = "\0";
    BOOL           bUSB             = FALSE;
    BOOL           bPCCard          = FALSE;
    BOOL           bACPI            = FALSE;
    BOOL           bIR              = FALSE;
    BOOL           bHydra           = FALSE;
    INT            iNumDisplays     = GetSystemMetrics(SM_CMONITORS); 

    MEMORYSTATUS   msRAM;

    DEV_INFO *pdi;
    strcpy(username, UNKNOWN);
    strcpy(displayname, UNKNOWN);


    if (!GetEnvironmentVariable (USERNAME, username, MY_MAX_UNLEN))
       lstrcpy (username, "Unknown");

    // Get the build number
    if (!szFrom)
       GetBuildNumber (build_number);
    else 
       _tcscpy (build_number, szFrom);

    GetSystemInfo( &SysInfo );

    if ( !GetEnvironmentVariable( "USERDOMAIN", userdomain, sizeof( userdomain) ) )
        _tcscpy (userdomain, "Unknown");
    if ( !GetEnvironmentVariable( "PROCESSOR_ARCHITECTURE", architecture, sizeof( architecture ) ) )
        _tcscpy (architecture, "Unknown");




    // Video Information for ChrisW

    displayDevice.cb = sizeof(DISPLAY_DEVICE);
    iLoop = 0;

    while (EnumDisplayDevices(NULL, iLoop, &displayDevice, 0)) {

        ZeroMemory( &dmCurrent, sizeof(dmCurrent) );
        dmCurrent.dmSize= sizeof(dmCurrent);
        if( EnumDisplaySettings( displayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &dmCurrent ) ){
            if (iLoop == 0) 
                *displayname = 0;
            else
               _tcscat( displayname, TEXT(",") );
            _tcscat( displayname, dmCurrent.dmDeviceName );
        }
        iLoop++;
    }


    // replace spaces so we don't break the perl script the build lab is using
    pch = displayname;
    while (*pch) {
        if (*pch == ' ') *pch = '.';
        pch++;
    }

    GetVidInfo (vidinfo);

        // Get locale abbreviation so we know about language pack usage

    if( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVLANGNAME, localename, sizeof( localename)) == 0 )
        _tcscpy(localename,"unk");

    msRAM.dwLength = sizeof (msRAM);
    GlobalMemoryStatus (&msRAM);
    //
    // Get PNP net card info
    //
    *netcards='\0';
    *scsi='\0';
    CollectDevData ();
    pdi=g_pdiDevList;
    while (pdi){
       if (!lstrcmpi (pdi->szClass, "Net")){
           if (_tcsclen(netcards) + lstrlen(pdi->szDescription) + lstrlen(pdi->szService) < 250){
               _tcscat (netcards, pdi->szDescription);
               _tcscat (netcards, "(");
               _tcscat (netcards, pdi->szService);
               _tcscat (netcards, TEXT(") "));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "SCSIAdapter")){
           if (_tcsclen(scsi) + lstrlen(pdi->szService) < 250){
               _tcscat (scsi, pdi->szService);
               _tcscat (scsi, TEXT(","));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "Modem")){
           if (_tcsclen(modem) + lstrlen(pdi->szDescription) < 250){
               _tcscat (modem, pdi->szDescription);
               _tcscat (modem, TEXT(","));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "USB"))
           bUSB = TRUE;
       else if (!lstrcmpi (pdi->szClass, "Infrared"))
           bIR = TRUE;
       else if (!lstrcmpi (pdi->szClass, "PCMCIA") || !lstrcmpi (pdi->szService, "PCMCIA"))
          bPCCard = TRUE;
       else if (strstr (pdi->szClass, "ACPI") || strstr (pdi->szService, "ACPI"))
          bACPI = TRUE;
      pdi=pdi->Next;
    }

    Cleanup(); //free all the pnp data and restore configuration
    if (!(*netcards))
       _tcscpy (netcards, TEXT("Unknown"));
    //
    // Get Sound info
    GetNTSoundInfo ();
    // format all our data

    bHydra= IsHydra ();

    // fix the number of displays for non Windows 2000 systems
    if (!iNumDisplays)
        iNumDisplays = 1;

    //wsprintf only accepts 1k buffers.
    //  Break these up into more calls to
    // wsprintf to eliminate chance of overflow
    _stprintf (OutputBuffer,
             TEXT("MachineID:%lu\r\n")
             TEXT("Source Media:%s\r\n")
             TEXT("Type:%s\r\nUsername:%s\r\n")
             TEXT("RAM:%d\r\n")
             TEXT("FromBld:%s\r\n")
             TEXT("Arch:%s\r\nNumProcs:%d\r\n")
             TEXT("Vidinfo:%s\r\n"),
                   lpCmdL->dwRandomID,
                   lpCmdL->b_CDrom?  TEXT("C"): TEXT("N"),
                   lpCmdL->b_Upgrade?TEXT("U"):TEXT("I"),
                    username,
                    msRAM.dwTotalPhys/(1024*1024),
                    szFrom?szFrom:build_number,
                    architecture,
                    SysInfo.dwNumberOfProcessors,
                    vidinfo
             );

    _stprintf (OutputBuffer+_tcsclen(OutputBuffer),
             TEXT("VidDriver:%s\r\n")
             TEXT("Locale:%s\r\nSound:%s\r\nNetCards:%s\r\n")
             TEXT("ACPI:%d\r\n")
             TEXT("PCMCIA:%d\r\n")
             TEXT("CPU:%d\r\n")
             TEXT("SCSI:%s\r\n")
             TEXT("USB:%d\r\n")
             TEXT("Infrared:%d\r\n"),
                 displayname,
                 localename,
                 m.nNumWaveOutDevices?m.szWaveDriverName[0]:TEXT("None"),
                 netcards,
                 bACPI,
                 bPCCard,
                 (DWORD)SysInfo.wProcessorLevel,
                 scsi,
                 bUSB,
                 bIR
             );
    _stprintf (OutputBuffer+_tcsclen(OutputBuffer),
             TEXT("Modem:%s\r\n")
             TEXT("Hydra:%d\r\n")
             TEXT("Displays:%d\r\n")
             TEXT("MSI:%s\r\n"),
                    modem,
                    bHydra,
                    iNumDisplays,
                    lpCmdL->b_MsiInstall? TEXT("Y"):TEXT("N")
                    );

   ConnectAndWrite( szFileName, OutputBuffer );
}


BOOL
IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare)
/*++

Routine Description:
   This will go through the list of servers specified in setuplogEXE.h
   It will return the first in it sees and reset the global server share
   name.

Arguments:
   The machineName (Filename with build etc) so the test file will get overwritten.
   Manual Server Name: NULL will give default behaviour.

Return Value:
	TRUE for success.
   FALSE for no name.
--*/

{
   DWORD    dw;
   HANDLE   hThrd;
   INT      i;
   TCHAR    szServerFile[ MAX_PATH ];
   DWORD    dwTimeOutInterval;
   i = 0;

   //
   // This should allow for a 
   // manually specified server.
   //
   if (NULL != szSpecifyShare){
       _tcscpy(g_szServerShare,szSpecifyShare);
      return TRUE;

   }
   //
   // Initialize the Server.
   // Variable. Since we are using a single thread
   // to do a time out we don't care about mutexes and
   // sychronization.
   //
   g_bServerOnline = FALSE;

   while ( i < NUM_SERVERS){

      
      _stprintf (szServerFile, TEXT("%s\\%s"),s[i].szSvr,szMachineName );
      //
      // Spawn the thread
      //
      hThrd  = CreateThread(NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) ServerOnlineThread,
                        (LPTSTR) szServerFile,
                        0,
                        &dw);
      //
      // This is in milli seconds so the time out is secs.
      //
      dwTimeOutInterval = TIME_TIMEOUT * 1000;

      s[i].dwTimeOut = WaitForSingleObject (hThrd, dwTimeOutInterval);
      CloseHandle (hThrd);

      //
      // This means the server passed the timeout.
      //
      if (s[i].dwTimeOut != WAIT_TIMEOUT &&
          g_bServerOnline == TRUE){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }
   return FALSE;
}



BOOL
ServerOnlineThread(IN LPTSTR szServerFile)
/*++

Routine Description:
   This create a thread and then time it out to see if we can get to
   a server faster. 

Arguments:
   The machineName so the test file will get overwritten.
Return Value:

--*/
{

   BOOL     bCopy = FALSE;
   TCHAR    szFileSrc [MAX_PATH];
   TCHAR    szServerTestFile [MAX_PATH];
   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   //
   GetModuleFileName (NULL, szFileSrc, MAX_PATH);
   
   //
   // Make a unique test file. 
   //
   _stprintf(szServerTestFile,TEXT("%s.SERVERTEST"),szServerFile);
   bCopy = CopyFile( szFileSrc,szServerTestFile, FALSE);
   if (bCopy != FALSE){
      //
      // If Succeeded Delete the test file.
      //
      DeleteFile(szServerTestFile);
      g_bServerOnline = TRUE;      
      return TRUE;
   }
   else{
      g_bServerOnline = FALSE;
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cmdhelp\cmdhelp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.c

Abstract:

    A user mode library that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#include "CmdHelpP.h"

static char ValidCharArray[] = {
    ' ',
    '0', '1', '2', '3',
    '4', '5', '6', '7',
    '8', '9', 'a', 'b',
    'c', 'd', 'e', 'f',
    'A', 'B', 'C', 'D',
    'E', 'F'
};
#define MaxValidOctalChars      ( 9) // space + 8 digits
#define MaxValidDecimalHexChars (11) // + 2 digits
#define MaxValidHexChars        (23) // + 12 letters (upper and lower case)
#define MaxValidCharacters      (23) // number of safe chars to access


/*++

Routine Description:

    Validates a string has valid characters
    valid chars are stored in a global static array

--*/
BOOL
PrivateValidateString(
    IN PCHAR String,
    IN DWORD ValidChars
    )
{
    if (ValidChars > MaxValidCharacters) {
        return FALSE;
    }

    if (*String == '\0') {
        return TRUE; // a NULL string is valid
    }

    while (*String != '\0') {
        
        DWORD i;
        BOOL pass = FALSE;

        for (i=0; i<ValidChars; i++) {
            if (*String == ValidCharArray[i]) {
                pass = TRUE;
                break;
            }
        }
        
        if (!pass) {
            return FALSE;
        }
        String++; // look at next character

    }
    return TRUE;
}

BOOL
CmdHelpValidateStringHex(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidHexChars);
}

BOOL
CmdHelpValidateStringDecimal(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidDecimalHexChars);
}

BOOL
CmdHelpValidateStringOctal(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidOctalChars);
}         

BOOL
CmdHelpValidateStringHexQuoted(
    IN PCHAR String
    )
{
    DWORD i;

    if (!PrivateValidateString(String, MaxValidHexChars)) return FALSE;
    
    i=1;
    while (*String != '\0') {
        
        if ((*String == ' ') &&  (i%3)) return FALSE;
        if ((*String != ' ') && !(i%3)) return FALSE;
        i++;      // use next index
        String++; // go to next character

    }
    return TRUE;
}

BOOLEAN
CmdHelpScanQuotedHexString(
    IN  PUCHAR QuotedHexString,
    OUT PUCHAR Data,
    OUT PDWORD DataSize
    )
{
    PUCHAR temp;
    DWORD  availableSize;
    DWORD  requiredSize;
    DWORD  index;

    availableSize = *DataSize;
    *DataSize = 0;

    if (!CmdHelpValidateStringHexQuoted(QuotedHexString)) {
        return FALSE;
    }

    //
    // the number format is (number)(number)(space) repeated,
    // ending with (number)(number)(null)
    // size = 3(n-1) + 2 chars
    //

    requiredSize = strlen(QuotedHexString);
    if (requiredSize % 3 != 2) {
        return FALSE;
    }
        
    requiredSize /= 3;
    requiredSize ++;

    //
    // cannot set zero bytes of data
    //

    if (requiredSize == 0) {
        return FALSE;
    }

    //
    // validate that we have enough space
    //

    if (requiredSize > availableSize) {
        *DataSize = requiredSize;
        return FALSE;
    }

    //
    // the number format is (number)(number)(space) repeated,
    // ending with (number)(number)(null)
    //

    for (index = 0; index < requiredSize; index ++) {

        temp = QuotedHexString + (3*index);

        if (sscanf(temp, "%x", Data+index) != 1) {
            return FALSE;
        }

        if ((*(temp+0) == '\0') || (*(temp+1) == '\0')) {
            // string too short
            return FALSE;
        }

    }
    
    *DataSize = requiredSize;
    return TRUE;
}

VOID
CmdHelpUpdatePercentageDisplay(
    IN ULONG Numerator,
    IN ULONG Denominator
    )
{
    ULONG percent;
    ULONG i;

    if (Numerator > Denominator) {
        return;
    }

    // NOTE: Overflow possibility exists for large numerators.

    percent = (Numerator * 100) / Denominator;

    for (i=0;i<80;i++) {
        putchar('\b');
    }
    printf("Complete: ");
    
    // each block is 2%
    // ----=----1----=----2----=----3----=----4----=----5----=----6----=----7----=----8
    // Complete: .....................

    for (i=1; i<100; i+=2) {
        if (i < percent) {
            putchar(178);
        } else if (i == percent) {
            putchar(177);
        } else {
            putchar(176);
        }
    }

    printf(" %d%% (%x/%x)", percent, Numerator, Denominator);
}

VOID
CmdHelpPrintBuffer(
    IN  PUCHAR Buffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;

    while (Size > 0x10) {
        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "\n",
                offset,
                *(Buffer +  0), *(Buffer +  1), *(Buffer +  2), *(Buffer +  3),
                *(Buffer +  4), *(Buffer +  5), *(Buffer +  6), *(Buffer +  7),
                *(Buffer +  8), *(Buffer +  9), *(Buffer + 10), *(Buffer + 11),
                *(Buffer + 12), *(Buffer + 13), *(Buffer + 14), *(Buffer + 15)
                );
        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *Buffer);
            spaceIt++;
            Buffer++;
        }
        printf("\n");

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\cmdhelp\cmdhelpp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sptlibp.h

Abstract:

    private header for SPTLIB.DLL

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#include <stdio.h>  // required for sscanf() function
#include <windows.h>
#include <cmdhelp.h>

#if 0
#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif
#endif // 0

BOOL
CmdHelpValidateString(
    IN PCHAR String,
    IN DWORD ValidChars
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\dvdburn\burn.h ===
/* Copyright (c) Microsoft Corporation. All rights reserved. */

#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ntddcdvd.h>

typedef enum _DVDBURN_MEDIA_TYPE {
    DvdBurnMediaUnknown        = 0x0,
    DvdBurnMediaRam            = 0x1,
    DvdBurnMediaPlusR          = 0x2,
    DvdBurnMediaPlusRW         = 0x3,
    DvdBurnMediaDashR          = 0x4,
    DvdBurnMediaDashRW         = 0x5,
    DvdBurnMediaDashRWPacket   = 0x6,
} DVDBURN_MEDIA_TYPE, *PDVDBURN_MEDIA_TYPE;

typedef enum _SPT_MODE_PAGE_REQUEST_TYPE {
    ModePageRequestTypeCurrentValues = 0,
    ModePageRequestTypeChangableValues = 1,
    ModePageRequestTypeDefaultValues = 2,
    ModePageRequestTypeSavedValues = 3,
} SPT_MODE_PAGE_REQUEST_TYPE, *PSPT_MODE_PAGE_REQUEST_TYPE;

/*
DvdBurnMediaUnknown
DvdBurnMediaNotSupported
DvdBurnMediaDashRW
DvdBurnMediaDashRWPacket
DvdBurnMediaPlusR
DvdBurnMediaPlusRW
*/

typedef struct _SEND_DVD_STRUCTURE_TIMESTAMP {
    UCHAR DataLength[2];
    UCHAR Reserved1[2];
    UCHAR Reserved2[4];
    UCHAR Year[4];
    UCHAR Month[2];
    UCHAR Day[2];
    UCHAR Hour[2];
    UCHAR Minute[2];
    UCHAR Second[2];
} SEND_DVD_STRUCTURE_TIMESTAMP, *PSEND_DVD_STRUCTURE_TIMESTAMP;



typedef struct _PROGRAM_OPTIONS {
    PUCHAR  DeviceName;
    PUCHAR  ImageName;
    BOOLEAN Erase;
} PROGRAM_OPTIONS, *PPROGRAM_OPTIONS;

DWORD
BurnCommand(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN BOOLEAN Erase
    );

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN DWORD  NumberOfBlocks,
    IN DWORD  FirstLba
    );

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    );

BOOLEAN
ReserveRZone(
    IN HANDLE CdromHandle,
    IN DWORD numberOfBlocks
    );

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    );

BOOLEAN
SendTimeStamp(
    IN HANDLE CdromHandle,
    IN PUCHAR DateString
    );

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    );

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PDWORD NumberOfBlocks
    );

BOOLEAN
VerifyMediaCapacity(
    IN HANDLE CdromHandle,
    IN DWORD  RequiredBlocks
    );

BOOLEAN
WaitForBurnToCompleteAndFinalizeMedia(
    IN HANDLE CdromHandle,
    IN DVDBURN_MEDIA_TYPE MediaType,
    IN ULONG LastWrittenLbaOnMedia
    );

BOOLEAN
SetWriteModePageDao(
    IN HANDLE CdromHandle,
    IN BOOLEAN FinalSession
    );

BOOLEAN
EraseMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
GetMediaType(
    IN HANDLE CdRomHandle,
    IN PDVDBURN_MEDIA_TYPE MediaType
    );

BOOLEAN
QuickFormatPlusRWMedia(
    IN HANDLE CdromHandle,
    IN ULONG NumberOfBlocks
    );

BOOLEAN
ReadDiscInformation(
    IN HANDLE CdromHandle,
    IN PDISC_INFORMATION DiscInfo,
    IN OUT PULONG UsableSize
    );

BOOLEAN
WaitForReadDiscInfoToSucceed(
    IN HANDLE CdromHandle,
    IN ULONG SecondsToAllow
    );

BOOLEAN
SetModePage(
    HANDLE CdromHandle,
    UCHAR * ModePageData,
    ULONG ValidSize
    );

BOOLEAN
SetModePage(
    HANDLE CdromHandle,
    UCHAR * ModePageData,
    ULONG ValidSize
    );

BOOLEAN
GetModePage(
    HANDLE CdromHandle,
    UCHAR ** ModePageData,
    ULONG * ValidSize,
    UCHAR ModePage,
    SPT_MODE_PAGE_REQUEST_TYPE IncomingModePageType
    );

BOOLEAN
SendOPC(
    IN HANDLE CdromHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\dvdburn\burn.c ===
/* Copyright (c) Microsoft Corporation. All rights reserved. */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <sptlib.h>
#include "burn.h"
#include <winioctl.h>
#include <strsafe.h>

#define MIN_WRITE_SECTORS (0x10)

#if DBG
    #define OUTPUT stdout
    #define FPRINTF(x) fprintf x
    #define PRINTBUFFER(x) PrintBuffer x
#else
    #define OUTPUT stdout
    #define FPRINTF(x)
    #define PRINTBUFFER(x)
#endif


#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

__inline
ULONGLONG
GetSystemTimeAsUlonglong(
    void
    )
{
    FILETIME t;
    GetSystemTimeAsFileTime( &t );
    return (((ULONGLONG) t.dwHighDateTime) << 32) + t.dwLowDateTime;
}

typedef struct _SENSE_STUFF {
    UCHAR Sense;
    UCHAR Asc;
    UCHAR Ascq;
    UCHAR Reserved;
} SENSE_STUFF, *PSENSE_STUFF;

SENSE_STUFF AllowedBurnSense[] = {
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0},
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0}
};
#define AllowedBurnSenseEntries (sizeof(AllowedBurnSense)/sizeof(SENSE_STUFF))

SENSE_STUFF AllowedReadDiscInfo[] = {
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_FORMAT_IN_PROGRESS,     0 },
    { SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK,     0, 0                },
    { SCSI_SENSE_UNIT_ATTENTION,  SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION, 0, 0                }
};
#define AllowedReadDiscInfoEntries (sizeof(AllowedReadDiscInfo)/sizeof(SENSE_STUFF))


BOOLEAN
IsSenseDataInTable(
    IN PSENSE_STUFF Table,
    IN LONG         Entries, // in table
    IN PSENSE_DATA  SenseData
    )
{
    LONG i;
    UCHAR sense = SenseData->SenseKey & 0xf;
    UCHAR asc   = SenseData->AdditionalSenseCode;
    UCHAR ascq  = SenseData->AdditionalSenseCodeQualifier;

    for (i = 0; i < Entries; i++ ) {
        if ((Table[i].Sense == sense) &&
            (Table[i].Ascq  == ascq ) &&
            (Table[i].Asc   == asc  )
            ) {
            return TRUE;
        }
    }
    return FALSE;
}

VOID
InitializeOptions(
    IN PROGRAM_OPTIONS * Options
    )
{
    RtlZeroMemory( Options, sizeof(PROGRAM_OPTIONS) );
    return;
}

BOOLEAN
ParseCommandLine(
    IN DWORD Count,
    IN PUCHAR Arguments[],
    OUT PROGRAM_OPTIONS * Options
    )
{
    DWORD i;
    HRESULT hr;

    InitializeOptions(Options);

    if ( Count < 3 )
    {
        // not enough args, just print help
        return FALSE;
    }

    for(i = 1; i < Count; i++) {

        //
        // If the first character of the argument is a - or a / then
        // treat it as an option.
        //

        if ((Arguments[i][0] == '/') || (Arguments[i][0] == '-')) {

            BOOLEAN validArgument = FALSE;

            Arguments[i][0] = '-'; // allow use of both dash and slash


            if (_strnicmp(Arguments[i], "-erase", strlen("-erase")) == 0)
            {
                printf("Erasing media before burning\n");
                Options->Erase = TRUE;
                validArgument = TRUE;
            } else
            if (_strnicmp(Arguments[i], "-?", strlen("-?")) == 0) {
                printf("Requesting help\n");
            } else
            {
                printf("Unknown option '%s'\n", Arguments[i]);
            }

            if(!validArgument)
            {
                return FALSE;
            }

        } else if(Options->DeviceName == NULL) {

            //
            // The first non-flag argument is the device name.
            //

            Options->DeviceName = Arguments[i];

        } else if(Options->ImageName == NULL) {

            //
            // The second non-flag argument is the image name.  This is
            // optional if the -erase flag has been provided.
            //

            Options->ImageName = Arguments[i];

        } else {

            //
            // Too many non-flag arguments provided.  This must be an error.
            //

            printf("Error: extra argument %s not expected\n", Arguments[i]);
            return FALSE;
        }
    }

    //
    // Validate the command-line arguments.
    //

    if(Options->DeviceName == NULL)
    {
        printf("Error: must supply device name.\n");
        return FALSE;
    }

    if(Options->ImageName == NULL)
    {
        printf("Error: must supply image name.\n");
        return FALSE;
    }

    return TRUE;
}




int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE cdromHandle;
    HANDLE isoImageHandle;
    char buffer[120]; // ~50 chars for mountvol names

    PROGRAM_OPTIONS options;

    if (!ParseCommandLine(argc, argv, &options))
    {
        printf("Usage: dvdburn <drive> <image> [/Erase]\n");
        return -1;
    }


    {
        HRESULT hr;
        hr = StringCchPrintf(buffer,
                             RTL_NUMBER_OF(buffer),
                             "\\\\.\\%s",
                             options.DeviceName);
        if (!SUCCEEDED(hr)) {
            printf("Device name too long\n");
            return -1;
        }
    }

    cdromHandle = CreateFile(buffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if(cdromHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    if (!SptUtilLockVolumeByHandle(cdromHandle, TRUE)) {
        printf("Unable to lock the volume for exclusive access %d\n",
               GetLastError());
        return -3;
    }

    isoImageHandle = CreateFile(options.ImageName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);
    if (isoImageHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening image file %s\n",
                GetLastError(), argv[2]);
        CloseHandle(cdromHandle);
        return -4;
    }

    BurnCommand(cdromHandle, isoImageHandle, options.Erase);

    CloseHandle(isoImageHandle);
    CloseHandle(cdromHandle);

    return 0;
}

/*++

Routine Description:

    burns an ISO image to cdrom

Arguments:
    CdromHandle - a file handle to send the ioctl to

    argc - the number of additional arguments (2)

Return Value:

    ERROR_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
DWORD
BurnCommand(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    BOOLEAN Erase
    )
{
    DWORD numberOfBlocks;
    DWORD availableBlocks;
    DVDBURN_MEDIA_TYPE mediaType;
    DWORD nwa;
    LONG i;


////////////////////////////////////////////////////////////////////////////////
// verify the iso image file looks correct
////////////////////////////////////////////////////////////////////////////////
    if (!VerifyIsoImage(IsoImageHandle, &numberOfBlocks)) {
        printf("Error verifying ISO image\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// determine the probable media type from GET_CONFIG
////////////////////////////////////////////////////////////////////////////////
    mediaType = DvdBurnMediaUnknown;
    if (!GetMediaType(CdromHandle, &mediaType)) {
        printf("GetMediaType() failed (%d).  Unable to continue.\n",
               GetLastError());
        return GetLastError();
    }


    switch (mediaType) {

    case DvdBurnMediaRam: {
        printf("Media type: %s\n", "random-access media (DVD-RAM, MRW)");
        break;
    }

    case DvdBurnMediaDashR: {
        printf("Media type: %s\n", "DVD-R");
        break;
    }

    case DvdBurnMediaDashRW: {
        printf("Media type: %s\n", "DVD-RW");
        break;
    }
    case DvdBurnMediaDashRWPacket: {
        printf("Media type: %s\n", "DVD-RW (packet)");
        break;
    }

    case DvdBurnMediaPlusR: {
        printf("Media type: %s\n", "DVD+R");
        break;
    }

    case DvdBurnMediaPlusRW: {
        printf("Media type: %s\n", "DVD+RW");
        break;
    }

    case DvdBurnMediaUnknown: {
        printf("Media type: %s\n", "Unknown Media Type");
        break;
    }

    default: {
        printf("Unknown media type: 0x%02x\n", mediaType);
        mediaType = DvdBurnMediaUnknown;
        break;
    }

    } // end switch(mediaType)


    if (mediaType == DvdBurnMediaUnknown) {
        printf("Media is unknown type, unsupported, or there is no media "
               "in the drive.\n");
        return -1;
    }

////////////////////////////////////////////////////////////////////////////////
// erase the media
////////////////////////////////////////////////////////////////////////////////

    if (Erase) {

        printf("Erasing media\n");

        switch (mediaType) {

        case DvdBurnMediaRam: {
            printf("Erasing random-access media is not a supported option (%s)\n",
                   "(not neccessary)");
            return -1;
            break;
        }

        case DvdBurnMediaDashR: {
            printf("Erasing DVD-R media is not a supported option (%s)\n",
                   "(not possible)");
            return -1;
            break;
        }

        case DvdBurnMediaDashRW:
        case DvdBurnMediaDashRWPacket: {
            if (!EraseMedia(CdromHandle))  {
                printf("Error erasing media DVD-RW media (is it -R?)\n");
                return GetLastError();
            }
            break;
        }

        case DvdBurnMediaPlusR: {
            printf("Erasing DVD+R media is not a supported option (%s)\n",
                   "(not possible)");
            return -1;
            break;
        }

        case DvdBurnMediaPlusRW: {
            printf("Erasing DVD+RW media is not a supported option (%s)\n",
                   "(not neccessary)");
            return -1;
            break;
        }
        } // end switch(mediaType)

        // re-acquire media type after the erase
        // required due to packet-written -RW media types
        mediaType = DvdBurnMediaUnknown;
        if (!GetMediaType(CdromHandle, &mediaType)) {
            printf("Drive failed GET CONFIGURATION command after erase? (%d)\n",
                   GetLastError());
            return GetLastError();
        }

        if (mediaType == DvdBurnMediaUnknown) {
            printf("Media is unknown type, unsupported, or there is "
                   "no media in the drive after the erase.\n");
            return -1;
        }

    } // end erase

////////////////////////////////////////////////////////////////////////////////
// pre-process the media (verify blank, format if needed, setup write)
////////////////////////////////////////////////////////////////////////////////
    printf("Preparing media...\n");

    switch (mediaType) {

        case DvdBurnMediaRam: {
            if (!VerifyMediaCapacity(CdromHandle, numberOfBlocks)) {
                printf("This DVD+RW Media is not large enough to contain the "
                       "entire image you selected.\n");
                return GetLastError();
            }
            break;
        }

        case DvdBurnMediaDashRWPacket: {
            printf("Packet written DVD-RW media needs to be erased before use\n");
            return -1;
        }

        case DvdBurnMediaDashR:
        case DvdBurnMediaDashRW: {

            if (!VerifyBlankMedia(CdromHandle)) {
                printf("DVD-R/RW Media must be blank or erased before use by "
                       "this utility.\n");
                return GetLastError();
            }

            // DVD-R/RW media never verified capacity with this utility because
            // it reserves a zone to burn to (which would fail) if the disc
            // was too small.

            if (!SetWriteModePageDao(CdromHandle, TRUE))  {
                printf("DVD-R/RW media requires setting mode page to use "
                       "DAO writing.\n");
                return GetLastError();
            }

            if (!SendOPC(CdromHandle)) {
                printf("DVD-R/RW media failed to set OPC via SEND_OPC command; "
                       "this error will be ignored, some drives can work "
                       "without this\n");
            }

            // why send a timestamp? -- use a fun date.
            if (!SendTimeStamp(CdromHandle, "20021225000000")) { // YYYYMMDDHHMMSS format
                printf("Error setting timestamp; this error will be ignored, "
                       "some drives can work without this\n");
            }

            // Reserve the RZone for this burn
            if (!ReserveRZone(CdromHandle, numberOfBlocks)) {
                printf("Error reserving zone for burn\n");
                return GetLastError();
            }

            break;
        }

        case DvdBurnMediaPlusRW:
        case DvdBurnMediaPlusR: {

            if ( mediaType == DvdBurnMediaPlusRW )
            {
                // always re-format DVD+RW media for mastering an image
                printf("DVD+RW media will always be formatted.\n");
                printf("Formatting may take 1-2 minutes.\n");
                if (!QuickFormatPlusRWMedia(CdromHandle, numberOfBlocks)) {
                    printf("Error formatting the DVD+R/RW media\n");
                    return GetLastError();
                }
                // verify media capacity
                if (!VerifyMediaCapacity(CdromHandle, numberOfBlocks)) {
                    printf("This DVD+RW Media is not large enough to contain the "
                           "entire image you selected.\n");
                    return GetLastError();
                }
            }
            else
            {
                DISC_INFORMATION discInfo;
                ULONG size = sizeof(DISC_INFORMATION);

                if (!ReadDiscInformation(CdromHandle, &discInfo, &size)) {
                    printf("Unable to read disc information for the DVD+R/RW "
                           "media (%d)\n", GetLastError());
                    return GetLastError();
                }

                if ((discInfo.LastSessionStatus != 0) ||
                    (discInfo.DiscStatus != 0)) {
                    printf("Non-blank DVD+R disc is not supported\n");
                    return ERROR_MEDIA_INCOMPATIBLE;
                }
                if (!ReserveRZone(CdromHandle, numberOfBlocks)) {
                    printf("Error reserving zone for burn\n");
                    return GetLastError();
                }
            }
            // mode page settings do not apply to DVD+R/RW media
            break;
        }

        default: {
            printf("Coding error: unsupported media type %d, line %d\n", mediaType, __LINE__);
            return -1;
            break;
        }
    }

////////////////////////////////////////////////////////////////////////////////
// get NWA via Read RZone Informationcommand, specifying RZone 1 for blank disk
////////////////////////////////////////////////////////////////////////////////

    // Special case -- blank disc is always zero
    nwa = 0;

////////////////////////////////////////////////////////////////////////////////
// start writing
// everything writes from LBA nwa through LBA nwa+NumberOfBlocks
////////////////////////////////////////////////////////////////////////////////

    if (!BurnThisSession(CdromHandle, IsoImageHandle, numberOfBlocks, nwa)) {
        printf("Error burning ISO image\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// post-process the media
////////////////////////////////////////////////////////////////////////////////

    // wait for it to finish
    if (!WaitForBurnToCompleteAndFinalizeMedia(CdromHandle, mediaType, numberOfBlocks)) {
        printf("Error waiting for burn to complete\n");
        return GetLastError();
    }


////////////////////////////////////////////////////////////////////////////////
// eject the newly burned disc!
////////////////////////////////////////////////////////////////////////////////

    if (!SendStartStopUnit(CdromHandle, FALSE, TRUE)) {
        printf("Error ejecting disc\n");
        return GetLastError();
    }

    if (!SendStartStopUnit(CdromHandle, TRUE,  TRUE)) {
        printf("Error reinserting disc\n");
        return GetLastError();
    }

    printf("Burn successful!\n");
    return 0;
}

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN DWORD NumberOfBlocks,
    IN DWORD FirstLba
    )
{
    DWORD bufferSize = 0x800 * MIN_WRITE_SECTORS;  // sixteen blocks per...
    PUCHAR buffer = NULL;
    DWORD i;
    BOOLEAN sleptOnceAlready = FALSE;

    FPRINTF((OUTPUT, "Starting write: "));

    buffer = LocalAlloc(LPTR, bufferSize);
    if (buffer == NULL) {
        FPRINTF((OUTPUT, "unable to allocate write buffer\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    FPRINTF((OUTPUT, "............."));

    for (i = 0; i < NumberOfBlocks; i += MIN_WRITE_SECTORS) {

        CDB cdb;
        DWORD currentSize;
        DWORD readBytes;
        DWORD j;
        SENSE_DATA senseData;
        DWORD tmp;

        if ( i % (8*MIN_WRITE_SECTORS) == 0 ) {
            static CHAR progress[4] =  { '|', '/', '-', '\\' };
            DWORD percent;
            percent = (i*1000) / NumberOfBlocks;
            //                # # # . # % _ d o n e _ *
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
            printf("%c %3d.%d%% done",
                   progress[(i/(8*MIN_WRITE_SECTORS))%4],
                   percent / 10, percent % 10
                   );
            fflush(stdout);
        }

        RtlZeroMemory(buffer, bufferSize);

        if (NumberOfBlocks - i >= MIN_WRITE_SECTORS) {
            currentSize = 0x800 * 0x10;
        } else if (NumberOfBlocks - i > 0) {
            // end of file case -- zero memory first!
            RtlZeroMemory(buffer, bufferSize);
            currentSize = (NumberOfBlocks - i) * 0x800;
        } else {
            FPRINTF((OUTPUT, "INTERNAL ERROR line %d\n", __LINE__));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            LocalFree(buffer);
            return FALSE;
        }

        if (!ReadFile(IsoImageHandle, buffer, currentSize, &readBytes, NULL)) {
            FPRINTF((OUTPUT, "error reading from file %d\n", GetLastError()));
            LocalFree(buffer);
            return FALSE;
        }
        if (readBytes != currentSize) {
            FPRINTF((OUTPUT, "error only read %d of %d bytes\n",
                    readBytes, currentSize));
            LocalFree(buffer);
            return FALSE;
        }

        //
        // must write the full buffer each time for DVD-R,
        // since it's a RESTRICTED_OVERWRITE medium and seems
        // to choke otherwise
        //

        j = 0;
    retryThisWrite:
        j++;

        RtlZeroMemory(&senseData, sizeof(SENSE_DATA));
        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.CDB10.OperationCode = SCSIOP_WRITE;
        cdb.CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&i)->Byte3;
        cdb.CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&i)->Byte2;
        cdb.CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&i)->Byte1;
        cdb.CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&i)->Byte0;

        cdb.CDB10.TransferBlocksLsb = MIN_WRITE_SECTORS;
        tmp = bufferSize;

        //
        // NOTE: we always send full buffer size to ensure 32k alignment
        //
        if (!SptSendCdbToDeviceEx(CdromHandle,
                                  &cdb,
                                  10,
                                  buffer,
                                  &tmp,
                                  &senseData,
                                  sizeof(SENSE_DATA),
                                  FALSE,
                                  10)) {

            FPRINTF((OUTPUT,
                     "Sleeping .25 seconds, LBA %x sense %02x/%02x/%02x\n",
                     i,
                     senseData.SenseKey,
                     senseData.AdditionalSenseCode,
                     senseData.AdditionalSenseCodeQualifier
                     ));

            if (IsSenseDataInTable(AllowedBurnSense,
                                   AllowedBurnSenseEntries,
                                   &senseData)
                //&& (j<300) // 300*.1 seconds == 30 seconds to start writing
                )
            {
                // just sleep a bit...
                if ( sleptOnceAlready )
                {
                    Sleep(100); // 100ms == .1 seconds
                }
                else
                {
                    sleptOnceAlready = TRUE;
                    Sleep(1000); // 1000ms == 1 second
                }

                goto retryThisWrite;
            }

            FPRINTF((OUTPUT, "\nError %d in writing LBA 0x%x (%x times)\n",
                     GetLastError(), i, j));
            LocalFree(buffer);
            return FALSE;
        }


    }
    // yes, the trailing spaces are neccessary
    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b- 100.0%% done  \n");
    printf("Finished Writing\n");
    fflush(stdout);
    LocalFree(buffer);
    return TRUE;
}

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    )
{
    DWORD offset = 0;
    PUCHAR buf = Buffer;

    while (Size > 0x10) {
        printf("%08x:"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "\n",
               offset,
               *(buf +  0), *(buf +  1), *(buf +  2), *(buf +  3),
               *(buf +  4), *(buf +  5), *(buf +  6), *(buf +  7),
               *(buf +  8), *(buf +  9), *(buf + 10), *(buf + 11),
               *(buf + 12), *(buf + 13), *(buf + 14), *(buf + 15)
               );
        Size -= 0x10;
        offset += 0x10;
        buf += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *buf);
            spaceIt++;
            buf++;
        }
        printf("\n");

    }
    return;


}

BOOLEAN
EraseMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD bufferSize;

    printf( "Attempting to blank media...");

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.AsByte[0] = 0xa1;
    cdb.AsByte[1] = 0x11; // minimal blank
    bufferSize = 0;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            NULL, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d blanking media\n",
                 GetLastError()));
        return FALSE;
    }

    if (!WaitForReadDiscInfoToSucceed(CdromHandle, 600))
    {
        FPRINTF((OUTPUT, "\nError %d blanking media\n",
                 GetLastError()));
        return FALSE;
    }
    printf("\n");

    return TRUE;
}


BOOLEAN
SetWriteModePageDao(
    IN HANDLE CdromHandle,
    IN BOOLEAN FinalSession
    )
{
    MODE_CDROM_WRITE_PARAMETERS_PAGE2 * params = NULL;
    ULONG paramsSize = 0;
    BOOLEAN error = FALSE;

    FPRINTF((OUTPUT, "Setting DAO mode in WriteParameters mode page... "));

    if (!GetModePage(CdromHandle,
                     (UCHAR **)&params,
                     &paramsSize,
                     MODE_PAGE_WRITE_PARAMETERS,
                     ModePageRequestTypeDefaultValues))
    {
        error = TRUE;
    }

    if ( !error )
    {
        params->PageLength =
            (UCHAR)
                (paramsSize -
                 RTL_SIZEOF_THROUGH_FIELD( MODE_CDROM_WRITE_PARAMETERS_PAGE2, PageLength )
                 );


        params->LinkSizeValid = 0;
        params->TestWrite     = 0;
        params->WriteType     = 2; // Disc-at-once

        if ( FinalSession )
        {
            params->MultiSession  = 0x00; // no more sessions/borders allowed
        }
        else
        {
            params->MultiSession  = 0x03; // allow more sessions
        }
        params->Copy          = 0x00; // original disc
        params->FixedPacket   = 0;
        params->TrackMode     = 0x4;  // data track, uninterrupted, copy prohibited

        params->DataBlockType = 0x8;  // Mode 1 -- ignored for DVD
        params->SessionFormat = 0x00; // Data Disc -- ignored for DVD
        params->MediaCatalogNumber[0] = 0x00;
        params->ISRC[0]       = 0x00;
        params->BufferUnderrunFreeEnabled = 1;
    }

    if ( !error )
    {
        if (!SetModePage(CdromHandle, (BYTE*)params, paramsSize))
        {
            params->BufferUnderrunFreeEnabled = 0;
            if (!SetModePage(CdromHandle, (BYTE*)params, paramsSize))
            {
                error = TRUE;
            }
            else
            {
                FPRINTF((OUTPUT, "pass (no BUFE).\n"));
            }
        }
        else
        {
            FPRINTF((OUTPUT, "pass.\n"));
        }
    }

    if ( params != NULL )
    {
        LocalFree(params);
    }

    return (!error);
}


BOOLEAN
ReserveRZone(
    IN HANDLE CdromHandle,
    IN DWORD numberOfBlocks
    )
{
    CDB cdb;
    DWORD size = 0;

    FPRINTF((OUTPUT, "Reserving RZone... "));

    if (numberOfBlocks % MIN_WRITE_SECTORS) {
        FPRINTF((OUTPUT, "increasing size by 0x%x blocks... ",
                 MIN_WRITE_SECTORS - (numberOfBlocks % MIN_WRITE_SECTORS)));
        numberOfBlocks /= MIN_WRITE_SECTORS;
        numberOfBlocks *= MIN_WRITE_SECTORS;
        numberOfBlocks += MIN_WRITE_SECTORS;
    }

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.RESERVE_TRACK_RZONE.OperationCode = SCSIOP_RESERVE_TRACK_RZONE;
    cdb.RESERVE_TRACK_RZONE.ReservationSize[0] = (UCHAR)(numberOfBlocks >> 24);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[1] = (UCHAR)(numberOfBlocks >> 16);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[2] = (UCHAR)(numberOfBlocks >>  8);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[3] = (UCHAR)(numberOfBlocks >>  0);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "Error reserving Track/RZone\n"));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));

    return TRUE;
}

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    )
{
    CDB cdb;
    DWORD size = 0;

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.LoadEject = Eject;
    cdb.START_STOP.Start     = Start;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 6,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "Error sending Start/Stop unit\n"));
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SendOPC(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size = 0;
    SENSE_DATA sense;

    FPRINTF((OUTPUT, "Sending OPC... "));


    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&sense, sizeof(SENSE_DATA));

    cdb.SEND_OPC_INFORMATION.OperationCode = SCSIOP_SEND_OPC_INFORMATION;
    cdb.SEND_OPC_INFORMATION.DoOpc = 1;

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              NULL,
                              &size,
                              &sense,
                              sizeof(SENSE_DATA),
                              FALSE,
                              60*4)) // four minute timeout should be sufficient
    {
        FPRINTF((OUTPUT, "Error sending OPC information: %02x/%02x/%02x\n",
                 sense.SenseKey, sense.AdditionalSenseCode,
                 sense.AdditionalSenseCodeQualifier));
        return FALSE;
    }

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
SendTimeStamp(
    IN HANDLE CdromHandle,
    IN PUCHAR DateString
    )
{
    CDB cdb;
    SEND_DVD_STRUCTURE_TIMESTAMP timeStamp;
    DWORD size;

    size = sizeof(SEND_DVD_STRUCTURE_TIMESTAMP);

    FPRINTF((OUTPUT, "Sending Timestamp... "));


    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.AsByte[0] = 0xbf;
    cdb.AsByte[7] = 0x0f; // format == time stamp
    cdb.AsByte[8] = (UCHAR)(size >> 8);
    cdb.AsByte[9] = (UCHAR)(size &  0xff);

    RtlZeroMemory(&timeStamp, sizeof(SEND_DVD_STRUCTURE_TIMESTAMP));
    if (strlen(DateString) != 14) {
        FPRINTF((OUTPUT, "Incorrect string length for date\n"));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    RtlCopyMemory(timeStamp.Year,   DateString+0x00, 4);
    RtlCopyMemory(timeStamp.Month,  DateString+0x04, 2);
    RtlCopyMemory(timeStamp.Day,    DateString+0x06, 2);
    RtlCopyMemory(timeStamp.Hour,   DateString+0x08, 2);
    RtlCopyMemory(timeStamp.Minute, DateString+0x0a, 2);
    RtlCopyMemory(timeStamp.Second, DateString+0x0c, 2);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            (PUCHAR)&timeStamp, &size, FALSE)) {
        FPRINTF((OUTPUT, "Error sending dvd timestamp\n"));
        return FALSE;
    }

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
ReadDiscInformation(
    IN HANDLE CdromHandle,
    IN PDISC_INFORMATION DiscInfo,
    IN OUT PULONG UsableSize
    )
{
    CDB cdb;
    DWORD maxSize = *UsableSize;
    DWORD size;
    SENSE_DATA senseData;

    if ((UsableSize == NULL) ||
        (DiscInfo   == NULL) ) {
        printf("CODE ERROR: Invalid argument to ReadDiscInfo\n");
        return FALSE;
    }

    FPRINTF((OUTPUT, "Getting Disc Info... "));

    *UsableSize = 0;
    RtlZeroMemory(DiscInfo, maxSize);
    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

    cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
    cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(maxSize >> 8);
    cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(maxSize & 0xff);

    size = maxSize;
    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              (PUCHAR)DiscInfo,
                              &size,
                              &senseData,
                              sizeof(SENSE_DATA),
                              TRUE,
                              SPT_DEFAULT_TIMEOUT)) {
        FPRINTF((OUTPUT, "\nError %d getting disc info\n",
                 GetLastError()));
        FPRINTF((OUTPUT, "Sense/ASC/ASCQ == %02x/%02x/%02x\n",
                 senseData.SenseKey,
                 senseData.AdditionalSenseCode,
                 senseData.AdditionalSenseCodeQualifier));
        PRINTBUFFER((&senseData, sizeof(SENSE_DATA)));

        return FALSE;
    }

    // return the minimum of the set:
    //   { input size, returned data, header informed size }
    {

        ULONG t =
            (DiscInfo->Length[0] << (8*1)) |
            (DiscInfo->Length[1] << (8*0));
        t += RTL_SIZEOF_THROUGH_FIELD(DISC_INFORMATION, Length);
        // t is now the size based on the header

        // take lesser of returned data and header info
        if (size > t) {
            size = t;
        }

        // take lesser of input max and above
        if (size > maxSize) {
            size = maxSize;
        }
    }
    *UsableSize = size;
    return TRUE;
}

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    )
{
    DISC_INFORMATION discInfo;
    ULONG size = sizeof(DISC_INFORMATION);

    FPRINTF((OUTPUT, "Verifying blank disc... "));
    if (!ReadDiscInformation(CdromHandle, &discInfo, &size)) {
        return FALSE;
    }

    FPRINTF((OUTPUT, "Disc Info Buffer:\n"));
    PRINTBUFFER((&discInfo, size));

    if (discInfo.LastSessionStatus != 0x00) {
        FPRINTF((OUTPUT, "disc is not blank!\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PDWORD NumberOfBlocks
    )
{
    BY_HANDLE_FILE_INFORMATION isoImageInfo;
    LONGLONG size;

    if (!GetFileInformationByHandle(IsoImageHandle, &isoImageInfo)) {
        FPRINTF((OUTPUT, "Error %d getting file info for iso image\n",
                 GetLastError()));
        return FALSE;
    }

    size  = ((LONGLONG)isoImageInfo.nFileSizeHigh) << 32;
    size |= (LONGLONG)isoImageInfo.nFileSizeLow;

    if ((isoImageInfo.nFileSizeLow % 2048) != 0) {
        FPRINTF((OUTPUT, "Error: The file size is not a multiple of 2048 (%I64d)\n",
                 size));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    FPRINTF((OUTPUT, "File size is %I64d bytes (%d blocks)\n",
             size, size / 2048));

    if ((LONGLONG)((size / 2048) >> 32) != 0) {
        FPRINTF((OUTPUT, "Error: The file is too large (%I64d)\n",
                 size));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }


    *NumberOfBlocks = (DWORD)(size / 2048);
    return TRUE;

}

BOOLEAN
VerifyMediaCapacity(
    IN HANDLE CdromHandle,
    IN DWORD  RequiredBlocks
    )
{
    CDB cdb;
    DWORD size;
    FOUR_BYTE temp1;
    DWORD temp2;
    READ_CAPACITY_DATA capacity;


    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&capacity, sizeof(READ_CAPACITY_DATA));
    size = sizeof(READ_CAPACITY_DATA);

    cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;

    if (!SptSendCdbToDevice(CdromHandle,
                            &cdb,
                            10,
                            (PUCHAR)&capacity,
                            &size,
                            TRUE)) {
        FPRINTF((OUTPUT, "Unable to successfully call READ_CAPACITY (%d)\n",
                 GetLastError()));
        return FALSE;
    }

    // translate into natural endian
    temp1.AsULong = capacity.BytesPerBlock;
    temp2 =
        (temp1.Byte0 << (8*3)) |
        (temp1.Byte1 << (8*2)) |
        (temp1.Byte2 << (8*1)) |
        (temp1.Byte3 << (8*0)) ;

    if (temp2 != 2048) {
        FPRINTF((OUTPUT, "Invalid block size of %x\n", temp2));
        return FALSE;
    }

    // translate into natural endian
    temp1.AsULong = capacity.LogicalBlockAddress;
    temp2 =
        (temp1.Byte0 << (8*3)) |
        (temp1.Byte1 << (8*2)) |
        (temp1.Byte2 << (8*1)) |
        (temp1.Byte3 << (8*0)) ;
    temp2 += 1; // zero-based result from READ_CAPACITY

    if (temp2 < RequiredBlocks) {
        FPRINTF((OUTPUT, "Disc size of %x too small (need %x blocks)\n",
                 temp2, RequiredBlocks));
        return FALSE;
    }
    return TRUE;
}

#define LBA_FOR_FIRST_30_MM_OF_DATA (0x70DE0)
#define SECTORS_FOR_LEADOUT_2_MM_OF_DATA (0xF000) // estimation -- not hard estimate

BOOLEAN
WaitForBurnToCompleteAndFinalizeMedia(
    IN HANDLE CdromHandle,
    DVDBURN_MEDIA_TYPE MediaType,
    ULONG SectorsUsedOnDisc // for time estimates
    )
{
    CDB cdb;
    SENSE_DATA senseData;
    DWORD size;
    DWORD i = 0;
    ULONG estimatedSecondsToCompletion;
    ULONGLONG startSystemTime = GetSystemTimeAsUlonglong();
    ULONGLONG failureSystemTime;

    if ( MediaType == DvdBurnMediaDashRW )
    {
        estimatedSecondsToCompletion = 30 * 60;
    }
    else if ( MediaType == DvdBurnMediaDashR )
    {
        estimatedSecondsToCompletion = 30 * 60;
    }
    else if ( MediaType == DvdBurnMediaPlusR )
    {
        // time to close disc is the time to append the disc to a minimum
        // size apporoximately 30 mm written data and the time to write the leadout.
        if ( SectorsUsedOnDisc >= LBA_FOR_FIRST_30_MM_OF_DATA )
        {
            estimatedSecondsToCompletion = 0;
        }
        else
        {
            estimatedSecondsToCompletion =
                ( LBA_FOR_FIRST_30_MM_OF_DATA - SectorsUsedOnDisc );
        }
        estimatedSecondsToCompletion +=
            SECTORS_FOR_LEADOUT_2_MM_OF_DATA;

        // single-speed DVD is about 8x cdrom speed
        // could ask drive for speed, but just use maximum time of 1x speed
        estimatedSecondsToCompletion /= (8 * 75);

    }
    else if ( MediaType == DvdBurnMediaPlusRW )
    {
        estimatedSecondsToCompletion = 4 * 60;
    }
    else if ( MediaType == DvdBurnMediaRam )
    {
        estimatedSecondsToCompletion = 4 * 60;
    }

    // always allow at least four minutes
    if ( estimatedSecondsToCompletion < 4 * 60 )
    {
        estimatedSecondsToCompletion = 4 * 60;
    }

    failureSystemTime = startSystemTime + (estimatedSecondsToCompletion * _SECOND);

    printf("Waiting for drive to finalize disc (this may take "
           "up to %d minutes)...",
           (estimatedSecondsToCompletion+59)/60
           );

    //
    // send flush_cache to synchronize the media and the drive's cache
    //

    RtlZeroMemory(&cdb, sizeof(cdb));
    cdb.SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;
    cdb.SYNCHRONIZE_CACHE10.Immediate = 1;
    size = 0;

    //
    // wait up to ten minutes (600 seconds) for burn to complete
    // because some units ignore the immediate bit in this command
    //

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              NULL,
                              &size,
                              NULL,
                              0,
                              TRUE,
                              600)) {
        FPRINTF((OUTPUT, "Error %d sending SYNCHRONIZE_CACHE\n",
                 GetLastError()));
        return FALSE;
    }

    if (!WaitForReadDiscInfoToSucceed(CdromHandle, estimatedSecondsToCompletion)) {
        return FALSE;
    }


    {
        ULONGLONG finishSystemTime = GetSystemTimeAsUlonglong();
        ULONGLONG totalSeconds =
            (finishSystemTime - startSystemTime) / _SECOND;
        FPRINTF((OUTPUT, "SYNCH_CACHE finished %I64d seconds into finalization process\n",
                 totalSeconds));
    }


    if ( (MediaType == DvdBurnMediaDashRW) ||
         (MediaType == DvdBurnMediaDashR ) ||
         (MediaType == DvdBurnMediaRam   )
         )
    {
        // DVD-R/RW media in Disc-at-Once mode just requires a SYNCH_CACHE
        // DVD-RAM media just requires a SYNC_CACHE
        printf(".");
    }
    else if ( MediaType == DvdBurnMediaPlusR )
    {
        //
        // DVD+R must close track and then close session
        // DVD+RW only requires a CLOSE_SESSION, and may not have a CLOSE_TRACK
        //
        {
            size = 0;
            RtlZeroMemory(&cdb, sizeof(cdb));
            RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

            cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
            cdb.CLOSE_TRACK.Immediate = 0x1;
            cdb.CLOSE_TRACK.Track   = 0x1;
            cdb.CLOSE_TRACK.TrackNumber[0] = 0;
            cdb.CLOSE_TRACK.TrackNumber[1] = 1;
            if (!SptSendCdbToDeviceEx(CdromHandle,
                                      &cdb,
                                      10,
                                      NULL,
                                      &size,
                                      &senseData,
                                      sizeof(SENSE_DATA),
                                      TRUE,
                                      10)) {
                FPRINTF((OUTPUT, "Error %d sending CLOSE SESSION (ignoring)\n",
                         GetLastError()));
                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
            } else if (senseData.SenseKey != SCSI_SENSE_NO_SENSE) {
                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x (ignoring)\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
            }
            //
            // spin doing a READ_DISC_INFO
            //
            if (!WaitForReadDiscInfoToSucceed(CdromHandle, estimatedSecondsToCompletion)) {
                return FALSE;
            }
        }
        {
            ULONGLONG finishSystemTime = GetSystemTimeAsUlonglong();
            ULONGLONG totalSeconds =
                (finishSystemTime - startSystemTime) / _SECOND;
            FPRINTF((OUTPUT, "CLOSE_TRACK finished %I64d seconds into finalization process\n",
                     totalSeconds));
        }


        //
        // then finalize the disc to be -ROM compatible
        //
        {
            size = 0;
            RtlZeroMemory(&cdb, sizeof(cdb));
            RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

            cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
            cdb.CLOSE_TRACK.Immediate = 0x1;
            cdb.AsByte[2] = ( cdb.AsByte[2] & 0xF8 ) | 0x5; // compatible close

            if (!SptSendCdbToDeviceEx(CdromHandle,
                                      &cdb,
                                      10,
                                      NULL,
                                      &size,
                                      &senseData,
                                      sizeof(SENSE_DATA),
                                      TRUE,
                                      10)) {
                FPRINTF((OUTPUT, "Error %d sending CLOSE SESSION\n",
                         GetLastError()));

                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
                return FALSE;
            } else if (senseData.SenseKey != SCSI_SENSE_NO_SENSE) {
                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
                return FALSE;
            }

            printf(".");

            //
            // spin doing a READ_DISC_INFO
            //
            if (!WaitForReadDiscInfoToSucceed(CdromHandle, estimatedSecondsToCompletion)) {
                return FALSE;
            }
        }
        {
            ULONGLONG finishSystemTime = GetSystemTimeAsUlonglong();
            ULONGLONG totalSeconds =
                (finishSystemTime - startSystemTime) / _SECOND;
            FPRINTF((OUTPUT, "CLOSE_SESSION finished %I64d seconds into finalization process\n",
                     totalSeconds));
        }
    }
    else if ( MediaType == DvdBurnMediaPlusRW )
    {
        //
        // then finalize the disc to be -ROM compatible
        //
        {
            size = 0;
            RtlZeroMemory(&cdb, sizeof(cdb));
            RtlZeroMemory(&senseData, sizeof(SENSE_DATA));

            cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
            cdb.CLOSE_TRACK.Immediate = 0x1;
            cdb.CLOSE_TRACK.Session   = 0x1;
            if (!SptSendCdbToDeviceEx(CdromHandle,
                                      &cdb,
                                      10,
                                      NULL,
                                      &size,
                                      &senseData,
                                      sizeof(SENSE_DATA),
                                      TRUE,
                                      10)) {
                FPRINTF((OUTPUT, "Error %d sending CLOSE SESSION\n",
                         GetLastError()));

                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
                return FALSE;
            } else if (senseData.SenseKey != SCSI_SENSE_NO_SENSE) {
                FPRINTF((OUTPUT, "Sense Buffer: %02x/%02x/%02x\n",
                         senseData.SenseKey,
                         senseData.AdditionalSenseCode,
                         senseData.AdditionalSenseCodeQualifier));
                PRINTBUFFER(((PUCHAR)&senseData, sizeof(SENSE_DATA)));
                return FALSE;
            }

            printf(".");

            //
            // spin doing a READ_DISC_INFO
            //
            if (!WaitForReadDiscInfoToSucceed(CdromHandle, estimatedSecondsToCompletion)) {
                return FALSE;
            }
        }
        {
            ULONGLONG finishSystemTime = GetSystemTimeAsUlonglong();
            ULONGLONG totalSeconds =
                (finishSystemTime - startSystemTime) / _SECOND;
            FPRINTF((OUTPUT, "CLOSE_SESSION finished %I64d seconds into finalization process\n",
                     totalSeconds));
        }
    }
    else
    {
        printf("support for media type %d not written yet?\n", MediaType);
    }

    {
        ULONGLONG finishSystemTime = GetSystemTimeAsUlonglong();
        ULONGLONG totalSeconds =
            (finishSystemTime - startSystemTime) / _SECOND;
        printf("\nSuccess: Finalizing media took %I64d seconds\n",
               totalSeconds);
    }
    return TRUE;
}

BOOLEAN
GetFeature(
    IN HANDLE         CdRomHandle,
    IN FEATURE_NUMBER Feature,
    IN PVOID          Buffer,
    IN OUT PULONG     InSize  // IN = available, OUT = used
    )
{
    GET_CONFIGURATION_IOCTL_INPUT input;
    ULONG returned;
    ULONG size = *InSize;

    *InSize = 0;

    RtlZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
    RtlZeroMemory(Buffer, size);

    input.Feature = Feature;
    input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;

    if (!DeviceIoControl(CdRomHandle,
                         IOCTL_CDROM_GET_CONFIGURATION,
                         &input,
                         sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                         Buffer,
                         size,
                         &returned,
                         FALSE)) {
        FPRINTF((OUTPUT, "Error %d requesting feature %04x\n",
                 GetLastError(), Feature));
        return FALSE;
    }
    *InSize = returned;
    return TRUE;
}

BOOLEAN
GetMediaIsMediaDvdDashRorRW(
    IN HANDLE CdRomHandle
    )
{
    UCHAR headerBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_DVD_RECORDABLE_WRITE)];
    PGET_CONFIGURATION_HEADER header = (PGET_CONFIGURATION_HEADER)headerBuffer;
    PFEATURE_DATA_DVD_RECORDABLE_WRITE data = (PFEATURE_DATA_DVD_RECORDABLE_WRITE)header->Data;
    ULONG size;

    size = 0x10;

    if (!GetFeature(CdRomHandle,
                    FeatureDvdRecordableWrite,
                    headerBuffer,
                    &size)) {
        FPRINTF((OUTPUT, "IsMedia-RW: GetFeature failed %x\n", GetLastError()));
        return FALSE;
    }

    if (size <= sizeof(GET_CONFIGURATION_HEADER)) {
        FPRINTF((OUTPUT, "IsMedia-RW: size too small\n"));
        return FALSE;
    }

    if (!(data->Header.Current)){

        FEATURE_PROFILE_TYPE profile;

        FPRINTF((OUTPUT, "IsMedia-RW: feature not current\n"));

        profile =
            (header->CurrentProfile[0] << (8*1)) |
            (header->CurrentProfile[1] << (8*0)) ;

        //
        // not current but exists, check profile?
        //

        if (profile == ProfileDvdRecordable) {
            FPRINTF((OUTPUT, "IsMedia-RW: Profile is DvdRecordable, continuing\n"));
        }
        else if (profile == ProfileDvdRewritable) {
            FPRINTF((OUTPUT, "IsMedia-RW: Profile is DvdRewritable, continuing\n"));
        }
        else if (profile == ProfileDvdRWSequential) {
            FPRINTF((OUTPUT, "IsMedia-RW: Profile is DvdRWSequential, continuing\n"));
        } else {
            return FALSE;
        }

        // the profile suggests the media *can* be written to, but only if blank'd

        // todo: do more exhaustive search here.

        return TRUE;

    }

    return TRUE;
}

BOOLEAN
GetMediaIsMediaDvdPlusRorRW(
    IN HANDLE CdRomHandle,
    IN BOOLEAN CheckForRW
    )
{
    UCHAR headerBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_DVD_PLUS_RW)];
    PGET_CONFIGURATION_HEADER header = (PGET_CONFIGURATION_HEADER)headerBuffer;
    PFEATURE_DATA_DVD_PLUS_RW data = (PFEATURE_DATA_DVD_PLUS_RW)header->Data;
    ULONG feature;
    ULONG size;
    PUCHAR string;

    // HACK -- overload use of FEATURE_DATA_DVD_PLUS_RW, which has same
    //         structure as +R feature for checked bits.

    size = sizeof(headerBuffer);
    feature = (CheckForRW ? FeatureDvdPlusRW : 0x2B);
    string = (CheckForRW ? "IsMedia+RW" : "IsMedia+R");

    if (!GetFeature(CdRomHandle,
                    feature,
                    headerBuffer,
                    &size)) {
        FPRINTF((OUTPUT, "%s: GetFeature failed %x\n",
                 string, GetLastError()));
        return FALSE;
    }

    if (size <= sizeof(GET_CONFIGURATION_HEADER)) {
        FPRINTF((OUTPUT, "%s: size too small\n", string));
        return FALSE;
    }

    if (!(data->Header.Current)){
        FPRINTF((OUTPUT, "%s: feature not current\n", string));
        return FALSE;
    }

    if (!(data->Write)) {
        FPRINTF((OUTPUT, "%s: write bit not set\n", string));
        return FALSE;
    }
    return TRUE;
}
BOOLEAN
GetMediaIsMediaDvdPlusR(
    IN HANDLE CdRomHandle
    )
{
    return GetMediaIsMediaDvdPlusRorRW(CdRomHandle, FALSE);
}

BOOLEAN
GetMediaIsMediaDvdPlusRW(
    IN HANDLE CdRomHandle
    )
{
    return GetMediaIsMediaDvdPlusRorRW(CdRomHandle, TRUE);
}

BOOLEAN
GetMediaIsMediaDvdRam(
    IN HANDLE CdRomHandle
    )
{
    UCHAR randomReadBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_RANDOM_READABLE)];
    UCHAR defectManagementBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_DEFECT_MANAGEMENT)];
    UCHAR randomWriteBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_RANDOM_WRITABLE)];

    PFEATURE_DATA_RANDOM_READABLE   randomReadFeature       = (PFEATURE_DATA_RANDOM_READABLE)  (randomReadBuffer       + sizeof(GET_CONFIGURATION_HEADER));
    PFEATURE_DATA_DEFECT_MANAGEMENT defectManagementFeature = (PFEATURE_DATA_DEFECT_MANAGEMENT)(defectManagementBuffer + sizeof(GET_CONFIGURATION_HEADER));
    PFEATURE_DATA_RANDOM_WRITABLE   randomWriteFeature      = (PFEATURE_DATA_RANDOM_WRITABLE)  (randomWriteBuffer      + sizeof(GET_CONFIGURATION_HEADER));

    {
        PGET_CONFIGURATION_HEADER headerBuffer =
            (PGET_CONFIGURATION_HEADER)randomWriteBuffer;
        ULONG size = sizeof(randomWriteBuffer);
        FEATURE_NUMBER feature = FeatureRandomWritable;
        UCHAR * string = "IsMediaDvdRam (writable)";

        if (!GetFeature(CdRomHandle,
                        feature,
                        headerBuffer,
                        &size)) {
            FPRINTF((OUTPUT, "%s: GetFeature failed %x\n",
                     string, GetLastError()));
            return FALSE;
        }
        if (size <= sizeof(GET_CONFIGURATION_HEADER)) {
            FPRINTF((OUTPUT, "%s: size too small\n", string));
            return FALSE;
        }
        if (!(randomWriteFeature->Header.Current))
        {
            FPRINTF((OUTPUT, "%s: feature not current\n", string));
            return FALSE;
        }
    }

    {
        PGET_CONFIGURATION_HEADER headerBuffer =
            (PGET_CONFIGURATION_HEADER)randomReadBuffer;
        ULONG size = sizeof(randomReadBuffer);
        FEATURE_NUMBER feature = FeatureRandomReadable;
        UCHAR * string = "IsMediaDvdRam (readable)";

        if (!GetFeature(CdRomHandle,
                        feature,
                        headerBuffer,
                        &size)) {
            FPRINTF((OUTPUT, "%s: GetFeature failed %x\n",
                     string, GetLastError()));
            return FALSE;
        }
        if (size <= sizeof(GET_CONFIGURATION_HEADER)) {
            FPRINTF((OUTPUT, "%s: size too small\n", string));
            return FALSE;
        }
        if (!(randomReadFeature->Header.Current))
        {
            FPRINTF((OUTPUT, "%s: feature not current\n", string));
            return FALSE;
        }
    }

    {
        PGET_CONFIGURATION_HEADER headerBuffer =
            (PGET_CONFIGURATION_HEADER)defectManagementBuffer;
        ULONG size = sizeof(defectManagementBuffer);
        FEATURE_NUMBER feature = FeatureDefectManagement;
        UCHAR * string = "IsMediaDvdRam (defect managed)";

        if (!GetFeature(CdRomHandle,
                        feature,
                        headerBuffer,
                        &size)) {
            FPRINTF((OUTPUT, "%s: GetFeature failed %x\n",
                     string, GetLastError()));
            return FALSE;
        }
        if (size <= sizeof(GET_CONFIGURATION_HEADER)) {
            FPRINTF((OUTPUT, "%s: size too small\n", string));
            return FALSE;
        }
        if (!(defectManagementFeature->Header.Current))
        {
            FPRINTF((OUTPUT, "%s: feature not current\n", string));
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
GetMediaType(
    IN HANDLE CdRomHandle,
    IN PDVDBURN_MEDIA_TYPE MediaType
    )
{

    *MediaType = DvdBurnMediaUnknown;

    // figure out (the hard way) what media is in the drive
    // we need to search for each one in "best" possible order
    //
    if (GetMediaIsMediaDvdPlusRW(CdRomHandle)) {

        FPRINTF((OUTPUT, "Chose DVD+RW due to DVD+RW feature current\n"));
        *MediaType = DvdBurnMediaPlusRW;

    } else
    if (GetMediaIsMediaDvdPlusR(CdRomHandle)) {

        FPRINTF((OUTPUT, "Chose DVD+R due to DVD+R feature current\n"));
        *MediaType = DvdBurnMediaPlusR;

    } else
    if (GetMediaIsMediaDvdDashRorRW(CdRomHandle)) {

        DISC_INFORMATION discInfo;
        ULONG size;

        FPRINTF((OUTPUT, "Chose DVD-R or -RW due to DVD-R/RW feature current\n"));

        // default to rewritable
        *MediaType = DvdBurnMediaDashRW;

        // get the disc info to see if erasable bit is set to 1

        size = sizeof(DISC_INFORMATION);
        if (!ReadDiscInformation(CdRomHandle, &discInfo, &size)) {

            FPRINTF((OUTPUT, "unable to read disc info -- will use -RW "
                     "media type as default\n"));

        } else if (size < sizeof(DISK_INFORMATION)) {

            FPRINTF((OUTPUT, "read disc info too small (%x) -- will use -RW "
                     "media type as default\n", size));

        } else if (discInfo.Erasable) {

            FPRINTF((OUTPUT, "disc is erasable -- will use -RW\n"));

        } else {

            FPRINTF((OUTPUT, "disc is not erasable -- using -R\n"));
            *MediaType = DvdBurnMediaDashR;

        }

        // check if it's formatted for packet-writing
        if (*MediaType == DvdBurnMediaDashRW) {

            UCHAR headerBuffer[sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE)];
            PGET_CONFIGURATION_HEADER header = (PGET_CONFIGURATION_HEADER)headerBuffer;
            PFEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE data = (PFEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE)header->Data;
            ULONG size;

            size = sizeof(headerBuffer);

            if (!GetFeature(CdRomHandle,
                            FeatureRigidRestrictedOverwrite,
                            headerBuffer,
                            &size)) {
                // nothing;
            } else
            if (size <= sizeof(GET_CONFIGURATION_HEADER)) {

                // nothing;

            } else
            if (!(data->Header.Current)) {

                // nothing;

            } else {

                FPRINTF((OUTPUT, "Chose DVD-RW Packet due to Rigid Restricted "
                         "Overwrite feature current\n"));
                *MediaType = DvdBurnMediaDashRWPacket;

            }
        }

    } else
    if (GetMediaIsMediaDvdRam(CdRomHandle)) {

        FPRINTF((OUTPUT, "Chose DVD-RAM due to random read/write and target "
                 "defect management features current\n"));
        *MediaType = DvdBurnMediaRam;

    } else
    {

        FPRINTF((OUTPUT, "Unknown media type\n"));
        *MediaType = DvdBurnMediaUnknown;

    }
    return TRUE;
}

BOOLEAN
QuickFormatPlusRWMedia(
    IN HANDLE CdromHandle,
    IN ULONG NumberOfBlocks
    )
{
    ULONG size = 0xc;
    UCHAR formatBuffer[0xc];
    SENSE_DATA senseData;
    CDB cdb;

    RtlZeroMemory(&senseData, sizeof(SENSE_DATA));
    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&formatBuffer, size);

    cdb.CDB6FORMAT.OperationCode = SCSIOP_FORMAT_UNIT;
    cdb.CDB6FORMAT.FormatControl = 0x11;

    //formatBuffer[0x0] = 0x00;
    //formatBuffer[0x1] = 0x00; // (same as 0x82)
    //formatBuffer[0x2] = 0x00;
    formatBuffer[0x3] = 0x08;
    formatBuffer[0x4] = 0xff; //---vvv
    formatBuffer[0x5] = 0xff; //   NumberOfBlocks must be set to 0xffffffff
    formatBuffer[0x6] = 0xff; //
    formatBuffer[0x7] = 0xff; //--^^^^
    formatBuffer[0x8] = (0x26 << 2); // format code.   ends up 0x98.
    //formatBuffer[0x9] = 0x00;
    //formatBuffer[0xa] = 0x00;
    //formatBuffer[0xb] = 0x00;

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              6,
                              formatBuffer,
                              &size,
                              &senseData,
                              sizeof(SENSE_DATA),
                              FALSE,
                              120)) {  // allow up to two minutes for this.
        printf("Unable to format, %x\n", GetLastError());
        printf("Sense Buffer: %02x/%02x/%02x\n",
               senseData.SenseKey,
               senseData.AdditionalSenseCode,
               senseData.AdditionalSenseCodeQualifier);
        PrintBuffer((PUCHAR)&senseData, sizeof(SENSE_DATA));
        return FALSE;
    } else if (senseData.SenseKey != SCSI_SENSE_NO_SENSE) {
        printf("Sense Buffer: %02x/%02x/%02x\n",
               senseData.SenseKey,
               senseData.AdditionalSenseCode,
               senseData.AdditionalSenseCodeQualifier);
        PrintBuffer((PUCHAR)&senseData, sizeof(SENSE_DATA));
        return FALSE;
    }

    if (!WaitForReadDiscInfoToSucceed(CdromHandle, 600)) {
        return FALSE;
    }

    {
        DISC_INFORMATION discInfo = {0};
        ULONG discInfoSize = sizeof(DISC_INFORMATION);
        if (!ReadDiscInformation(CdromHandle,
                                 &discInfo,
                                 &discInfoSize)) {
            printf("ReadDiscInfo failed after format\n");
            return FALSE;
        }

        // ReadDiscInfo succeeded, check format status.
        // exit with error if it's wrong.

        switch (discInfo.MrwStatus) {

            case 0x0: {
                printf("DVD+RW Disc is not formatted -- format may have "
                       "failed???\n");
                return FALSE;
                break;
            }
            case 0x1: {
                printf("DVD+RW Disc is partially formatted -- format "
                       "succeeded\n");
                return TRUE;
                break;
            }
            case 0x2: {
                printf("DVD+RW Disc is formatting in background -- format "
                       "succeeded\n");
                return TRUE;
                break;
            }
            case 0x3: {
                printf("DVD+RW Disc is fully formatted -- format "
                       "succeeded\n");
                return TRUE;
                break;
            }
            default: {
                printf("DVD+RW Disc has unknown MRW Status of %x\n",
                       discInfo.MrwStatus);
                return FALSE;
                break;
            }
        }
    }

    return FALSE;

}


BOOLEAN
WaitForReadDiscInfoToSucceed(
    IN HANDLE CdromHandle,
    IN ULONG  SecondsToAllow
    )
{
    DISC_INFORMATION discInfo;
    ULONG discInfoSize;
    ULONG i;

    //
    // spin here until READ_DISC_INFO says disc is partially formatted
    // (which implies it is ready to write to)
    //

    for (i=0;i<SecondsToAllow;i++) { // up to 256 seconds for this to occur

        Sleep(1000); // one second wait

        discInfoSize = sizeof(DISC_INFORMATION);
        RtlZeroMemory(&discInfo, discInfoSize);

        if (ReadDiscInformation(CdromHandle, &discInfo, &discInfoSize)) {
            return TRUE;
        }
        printf(".");
    }

    printf("Unable to get a ReadDiscInfo in %d seconds, treating as a failure\n",
           SecondsToAllow
           );

    return FALSE;
}


BOOLEAN
GetModePage(
    HANDLE CdromHandle,
    UCHAR ** ModePageData,
    ULONG * ValidSize,
    UCHAR ModePage,
    SPT_MODE_PAGE_REQUEST_TYPE IncomingModePageType
    )
{
    HRESULT hr = S_OK;
    UCHAR scsiModePageType = 0;

    if ( ModePageData == NULL )
    {
        hr = E_POINTER;
    }
    else
    {
        *ModePageData = NULL;
    }
    if ( ValidSize == NULL )
    {
        hr = E_POINTER;
    }
    else
    {
        *ValidSize = 0;
    }
    if ( ModePage > 0x3F )
    {
        hr = E_INVALIDARG;
    }

    if ( IncomingModePageType == ModePageRequestTypeCurrentValues )
    {
        scsiModePageType = 0;
    }
    else if ( IncomingModePageType == ModePageRequestTypeChangableValues )
    {
        scsiModePageType = 1;
    }
    else if ( IncomingModePageType == ModePageRequestTypeDefaultValues )
    {
        scsiModePageType = 2;
    }
    else if ( IncomingModePageType == ModePageRequestTypeSavedValues )
    {
        scsiModePageType = 3;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        // only now is it safe to use the arguments....
        UCHAR *tmpPage = NULL;
        ULONG requiredSize = 0;

        // first get the size of the requested mode page values
        if ( SUCCEEDED(hr) )
        {
            CDB cdb;
            SENSE_DATA sense;
            MODE_PARAMETER_HEADER10 header;
            ULONG bufferSize;

            bufferSize = sizeof(MODE_PARAMETER_HEADER10);

            RtlZeroMemory( &sense, sizeof(SENSE_DATA) );
            RtlZeroMemory( &header, sizeof(MODE_PARAMETER_HEADER10) );
            RtlZeroMemory( &cdb, sizeof(CDB) );
            cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.Pc = scsiModePageType;
            cdb.MODE_SENSE10.PageCode = ModePage;
            cdb.MODE_SENSE10.Dbd = 1;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);

            if ( !SptSendCdbToDeviceEx(CdromHandle,
                                       &cdb,
                                       10,
                                       (PUCHAR)&header,
                                       &bufferSize,
                                       &sense,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       30
                                       ) )
            {
                hr = E_FAIL;
            }
            else if ( sense.SenseKey != SCSI_SENSE_NO_SENSE )
            {
                hr = E_FAIL;
            }
            else if ( (header.BlockDescriptorLength[0] != 0) ||
                      (header.BlockDescriptorLength[1] != 0)
                      )
            {
                hr = E_FAIL;
            }
            else
            {
                // success!
                bufferSize =
                    (header.ModeDataLength[0] << (8*1)) +
                    (header.ModeDataLength[1] << (8*0)) +
                    RTL_SIZEOF_THROUGH_FIELD( MODE_PARAMETER_HEADER10, ModeDataLength );
                requiredSize = bufferSize;
                hr = S_OK;
            }
        }

        // allocate for the whole page
        if ( SUCCEEDED(hr) )
        {
            tmpPage = (UCHAR *)LocalAlloc(LPTR, requiredSize);
            if ( tmpPage == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // then get the requested mode page values from the device
        if ( SUCCEEDED(hr) )
        {
            CDB cdb;
            SENSE_DATA sense;
            ULONG bufferSize = requiredSize;
            PMODE_PARAMETER_HEADER10 header = (PMODE_PARAMETER_HEADER10)tmpPage;

            RtlZeroMemory(&sense, sizeof(SENSE_DATA));
            RtlZeroMemory(&cdb, sizeof(CDB));

            cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.Pc = scsiModePageType; // default values requested
            cdb.MODE_SENSE10.PageCode = ModePage;
            cdb.MODE_SENSE10.Dbd = 1;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);

            if ( !SptSendCdbToDeviceEx(CdromHandle,
                                       &cdb,
                                       10,
                                       (PUCHAR)header,
                                       &bufferSize,
                                       &sense,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       30
                                       ) )
            {
                hr = E_FAIL;
            }
            else if ( sense.SenseKey != SCSI_SENSE_NO_SENSE )
            {
                if (SUCCEEDED(hr)) { hr = E_FAIL; }
            }
            else if ( (header->BlockDescriptorLength[0] != 0) ||
                      (header->BlockDescriptorLength[1] != 0)
                      )
            {
                hr = E_FAIL;
            }
            else
            {
                // success, verify data length or error out.
                bufferSize =
                    (header->ModeDataLength[0] << (8*1)) +
                    (header->ModeDataLength[1] << (8*0)) +
                    RTL_SIZEOF_THROUGH_FIELD( MODE_PARAMETER_HEADER10, ModeDataLength );
                if ( bufferSize != requiredSize )
                {
                    hr = E_FAIL;
                }
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // don't need nor want to pass the mode page header back to the
            // caller -- it just complexifies things for them.  Copy the
            // memory such that they only get the actual page.

            RtlMoveMemory( tmpPage,
                           tmpPage+sizeof(MODE_PARAMETER_HEADER10),
                           requiredSize-sizeof(MODE_PARAMETER_HEADER10) );

            // requiredSize is now smaller
            requiredSize -= sizeof(MODE_PARAMETER_HEADER10);

            // don't bother re-alloc'ing to free the extra 8-bytes.
            // adds another error path if the realloc fails.
            // tmpPage2 = CoTaskMemRealloc( tmpPage, requiredSize );
            // if ( tmpPage2 != NULL ) { tmpPage = tmpPage2; }

            *ModePageData = tmpPage;
            *ValidSize = requiredSize;
        }


        if ( FAILED(hr) )
        {
            if ( tmpPage != NULL )
            {
                LocalFree( tmpPage );
                tmpPage = NULL;
            }
        }
    }

    if ( FAILED(hr) && GetLastError() == 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }
    return SUCCEEDED(hr);
}

BOOLEAN
SetModePage(
    HANDLE CdromHandle,
    UCHAR * ModePageData,
    ULONG ValidSize
    )
{
    HRESULT hr = S_OK;
    PUCHAR tmpPage = NULL;
    ULONG tmpPageSize = 0;

    if ( ModePageData == NULL )
    {
        hr = E_POINTER;
    }
    if ( (ValidSize > 0x400) || (ValidSize == 0) )
    {
        hr = E_INVALIDARG;
    }

    // allocate the memory required
    if ( SUCCEEDED(hr) )
    {
        tmpPageSize = ValidSize + sizeof(MODE_PARAMETER_HEADER10);
        tmpPage = (PUCHAR)LocalAlloc( LPTR, tmpPageSize );
        if ( tmpPage == NULL )
        {
            tmpPageSize = 0;
            hr = E_OUTOFMEMORY;
        }
        else
        {
            RtlZeroMemory( tmpPage, tmpPageSize );
        }
    }

    // copy the mode page they provided and setup the header
    if ( SUCCEEDED(hr) )
    {
        PMODE_PARAMETER_HEADER10 header = (PMODE_PARAMETER_HEADER10)tmpPage;
        RtlCopyMemory( tmpPage + sizeof(MODE_PARAMETER_HEADER10),
                       ModePageData,
                       ValidSize );

        header->ModeDataLength[0] = 0;
        header->ModeDataLength[1] = 0;
        header->MediumType        = 0;
        header->DeviceSpecificParameter = 0;
        header->BlockDescriptorLength[0] = 0;
        header->BlockDescriptorLength[1] = 0;
    }

    if ( SUCCEEDED(hr) )
    {
        // set the mode page with the given data
        CDB cdb;
        SENSE_DATA sense;
        ULONG tmp = tmpPageSize;
        RtlZeroMemory(&sense, sizeof(SENSE_DATA));
        RtlZeroMemory(&cdb, sizeof(CDB));

        cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
        cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(tmpPageSize >> 8);
        cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(tmpPageSize & 0xff);
        cdb.MODE_SELECT10.PFBit = 1;

        if ( !SptSendCdbToDeviceEx(CdromHandle,
                                   &cdb,
                                   10,
                                   tmpPage,
                                   &tmp,
                                   &sense,
                                   sizeof(SENSE_DATA),
                                   FALSE,
                                   30
                                   ) )
        {
            hr =  E_FAIL;
        }
        else if ( sense.SenseKey != SCSI_SENSE_NO_SENSE )
        {
            if (SUCCEEDED(hr)) { hr = E_FAIL; }
        }
        else
        {
            hr = S_OK;
        }
    }

    if ( tmpPage != NULL )
    {
        LocalFree( tmpPage );
    }


    if ( FAILED(hr) && GetLastError() == 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }
    return SUCCEEDED(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\lib\sptlib.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.c

Abstract:

    A user mode library that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    4/10/2000 - created

--*/

#include "sptlibp.h"

//
// this routine allows safer DeviceIoControl, specifically handling
// overlapped handles.  however, IOCTL_SCSI_PASS_THROUGH and
// IOCTL_SCSI_PASS_THROUGH_DIRECT are blocking calls, so there is
// no support for overlapped IO
//
BOOL
SptpSaferDeviceIoControl(
    IN  HANDLE  VolumeHandle,
    IN  DWORD   IoControlCode,
    IN  LPVOID  InBuffer,
    IN  DWORD   InBufferSize,
    IN  LPVOID  OutBuffer,
    IN  DWORD   OutBufferSize,
    OUT LPDWORD BytesReturned
    );



BOOL
SptUtilValidateCdbLength(
    IN PCDB Cdb,
    IN UCHAR CdbSize
    )
{
    UCHAR commandGroup = (Cdb->AsByte[0] >> 5) & 0x7;


    switch (commandGroup) {
    case 0:
        return (CdbSize ==  6);
    case 1:
    case 2:
        return (CdbSize == 10);
    case 5:
        return (CdbSize == 12);
    default:
        return TRUE;
    }
}

BOOL
SptSendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PUCHAR  Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN GetDataFromDevice
    )
{
    return SptSendCdbToDeviceEx(DeviceHandle,
                             Cdb,
                             CdbSize,
                             Buffer,
                             BufferSize,
                             NULL,
                             0,
                             GetDataFromDevice,
                             SPT_DEFAULT_TIMEOUT
                             );
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptSendCdbToDeviceEx(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN OUT  PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
       OUT  PSENSE_DATA SenseData OPTIONAL,
    IN      UCHAR       SenseDataSize,
    IN      BOOLEAN     GetDataFromDevice,
    IN      DWORD       TimeOut                    // in seconds
    )
{
    PSPTD_WITH_SENSE p;
    DWORD packetSize;
    DWORD returnedBytes;
    BOOL returnValue;
    PSENSE_DATA senseBuffer;

    if ((SenseDataSize == 0) && (SenseData != NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((SenseDataSize != 0) && (SenseData == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (SenseData && SenseDataSize) {
        RtlZeroMemory(SenseData, SenseDataSize);
    }

    if (Cdb == NULL) {
        // cannot send NULL cdb
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (CdbSize < 1 || CdbSize > 16) {
        // Cdb size too large or too small for this library currently
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!SptUtilValidateCdbLength(Cdb, CdbSize)) {
        // OpCode Cdb->AsByte[0] is not size CdbSize
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (BufferSize == NULL) {
        // BufferSize pointer cannot be NULL
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize != 0) && (Buffer == NULL)) {
        // buffer cannot be NULL if *BufferSize is non-zero
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize == 0) && (Buffer != NULL)) {
        // buffer must be NULL if *BufferSize is zero
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize) && GetDataFromDevice) {

        //
        // pre-zero output buffer (not input buffer)
        //

        memset(Buffer, 0, (*BufferSize));
    }

    packetSize = sizeof(SPTD_WITH_SENSE);
    if (SenseDataSize > sizeof(SENSE_DATA)) {
        packetSize += SenseDataSize - sizeof(SENSE_DATA);
    }

    p = (PSPTD_WITH_SENSE)LocalAlloc(LPTR, packetSize);
    if (p == NULL) {
        // could not allocate memory for pass-through
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // this has the side effect of pre-zeroing the output buffer
    // if DataIn is TRUE, the SenseData (always), etc.
    //

    memset(p, 0, packetSize);
    memcpy(p->Sptd.Cdb, Cdb, CdbSize);

    p->Sptd.Length             = sizeof(SCSI_PASS_THROUGH_DIRECT);
    p->Sptd.CdbLength          = CdbSize;
    p->Sptd.SenseInfoLength    = SenseDataSize;

    if (*BufferSize != 0) {
        if (GetDataFromDevice) {
            p->Sptd.DataIn     = SCSI_IOCTL_DATA_IN;  // from device
        } else {
            p->Sptd.DataIn     = SCSI_IOCTL_DATA_OUT; // to device
        }
    } else {
        p->Sptd.DataIn         = SCSI_IOCTL_DATA_UNSPECIFIED;
    }


    p->Sptd.DataTransferLength = (*BufferSize);
    p->Sptd.TimeOutValue       = TimeOut;
    p->Sptd.DataBuffer         = Buffer;
    p->Sptd.SenseInfoOffset    = FIELD_OFFSET(SPTD_WITH_SENSE, SenseData);

    returnedBytes = 0;
    returnValue = SptpSaferDeviceIoControl(DeviceHandle,
                                           IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                           p,
                                           packetSize,
                                           p,
                                           packetSize,
                                           &returnedBytes);

    *BufferSize = p->Sptd.DataTransferLength;

    senseBuffer = &(p->SenseData);

    if (senseBuffer->SenseKey & 0xf) {

        UCHAR length;

        // determine appropriate length to return
        length = senseBuffer->AdditionalSenseLength;
        length += RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
        if (length > SENSE_BUFFER_SIZE) {
            length = SENSE_BUFFER_SIZE;
        }
        length = min(length, SenseDataSize);

        // copy the sense data back to the user regardless
        RtlCopyMemory(SenseData, senseBuffer, length);
        returnValue = FALSE;     // some error (possibly recovered) occurred

    } else if (p->Sptd.ScsiStatus != 0) {  // scsi protocol error

        UCHAR length;

        // determine appropriate length to return
        length = senseBuffer->AdditionalSenseLength;
        length += RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
        if (length > SENSE_BUFFER_SIZE) {
            length = SENSE_BUFFER_SIZE;
        }
        length = min(length, SenseDataSize);

        // copy the sense data back to the user regardless
        RtlCopyMemory(SenseData, senseBuffer, length);
        returnValue = FALSE;     // some error (possibly recovered) occurred

    } else if (!returnValue) {

        // returnValue = returnValue;

    } else {

        // success!

    }

    //
    // free our memory and return
    //

    LocalFree(p);
    return returnValue;
}

/*++

Routine Description:

    NOTE: we default to RETRY==TRUE except for known error classes

Arguments:

Return Value:


--*/
VOID
SptUtilInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    )
{
    DWORD   error;
    DWORD   retryDelay;
    BOOLEAN retry;
    UCHAR   senseKey;
    UCHAR   asc;
    UCHAR   ascq;

    if (SenseDataSize == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_IO_DEVICE;
        goto SetAndExit;

    }

    //
    // default to suggesting a retry in 1/10 of a second,
    // with a status of ERROR_IO_DEVICE.
    //
    retry = TRUE;
    retryDelay = 1;
    error = ERROR_IO_DEVICE;

    //
    // if the device didn't provide any sense this time, return.
    //

    if ((SenseData->SenseKey & 0xf) == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_SUCCESS;
        goto SetAndExit;
    }


    //
    // if we can't even see the sense key, just return.
    // can't use bitfields in these macros, so use next field.
    //

    if (SenseDataSize < FIELD_OFFSET(SENSE_DATA, Information)) {
        goto SetAndExit;
    }

    senseKey = SenseData->SenseKey;


    { // set the size to what's actually useful.
        UCHAR validLength;
        // figure out what we could have gotten with a large sense buffer
        if (SenseDataSize <
            RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)) {
            validLength = SenseDataSize;
        } else {
            validLength =
                RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
            validLength += SenseData->AdditionalSenseLength;
        }
        // use the smaller of the two values.
        SenseDataSize = min(SenseDataSize, validLength);
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCode)) {
        asc = SCSI_ADSENSE_NO_SENSE;
    } else {
        asc = SenseData->AdditionalSenseCode;
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCodeQualifier)) {
        ascq = SCSI_SENSEQ_CAUSE_NOT_REPORTABLE; // 0x00
    } else {
        ascq = SenseData->AdditionalSenseCodeQualifier;
    }

    //
    // interpret :P
    //

    switch (senseKey & 0xf) {

    case SCSI_SENSE_RECOVERED_ERROR: {  // 0x01
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
        } else {
            error = ERROR_SUCCESS;
        }
        retry = FALSE;
        break;
    } // end SCSI_SENSE_RECOVERED_ERROR

    case SCSI_SENSE_NOT_READY: { // 0x02
        error = ERROR_NOT_READY;

        switch (asc) {

        case SCSI_ADSENSE_LUN_NOT_READY: {

            switch (ascq) {

            case SCSI_SENSEQ_BECOMING_READY:
            case SCSI_SENSEQ_OPERATION_IN_PROGRESS: {
                retryDelay = SPT_NOT_READY_RETRY_INTERVAL;
                break;
            }

            case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE:
            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
            case SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS: {
                retry = FALSE;
                break;
            }

            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED: {
                retry = FALSE;
                break;
            }

            } // end switch (senseBuffer->AdditionalSenseCodeQualifier)
            break;
        }

        case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
            error = ERROR_NOT_READY;
            retry = FALSE;
            break;
        }
        } // end switch (senseBuffer->AdditionalSenseCode)

        break;
    } // end SCSI_SENSE_NOT_READY

    case SCSI_SENSE_MEDIUM_ERROR: { // 0x03
        error = ERROR_CRC;
        retry = FALSE;

        //
        // Check if this error is due to unknown format
        //
        if (asc == SCSI_ADSENSE_INVALID_MEDIA) {

            switch (ascq) {

            case SCSI_SENSEQ_UNKNOWN_FORMAT: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                break;
            }

            case SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                //error = ERROR_CLEANER_CARTRIDGE_INSTALLED;
                break;
            }

            } // end switch AdditionalSenseCodeQualifier

        } // end SCSI_ADSENSE_INVALID_MEDIA
        break;
    } // end SCSI_SENSE_MEDIUM_ERROR

    case SCSI_SENSE_ILLEGAL_REQUEST: { // 0x05
        error = ERROR_INVALID_FUNCTION;
        retry = FALSE;

        switch (asc) {

        case SCSI_ADSENSE_ILLEGAL_BLOCK: {
            error = ERROR_SECTOR_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_INVALID_LUN: {
            error = ERROR_FILE_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_COPY_PROTECTION_FAILURE: {
            error = ERROR_FILE_ENCRYPTED;
            //error = ERROR_SPT_LIB_COPY_PROTECTION_FAILURE;
            switch (ascq) {
                case SCSI_SENSEQ_AUTHENTICATION_FAILURE:
                    //error = ERROR_SPT_LIB_AUTHENTICATION_FAILURE;
                    break;
                case SCSI_SENSEQ_KEY_NOT_PRESENT:
                    //error = ERROR_SPT_LIB_KEY_NOT_PRESENT;
                    break;
                case SCSI_SENSEQ_KEY_NOT_ESTABLISHED:
                    //error = ERROR_SPT_LIB_KEY_NOT_ESTABLISHED;
                    break;
                case SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION:
                    //error = ERROR_SPT_LIB_SCRAMBLED_SECTOR;
                    break;
                case SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT:
                    //error = ERROR_SPT_LIB_REGION_MISMATCH;
                    break;
                case SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR:
                    //error = ERROR_SPT_LIB_RESETS_EXHAUSTED;
                    break;
            } // end switch of ASCQ for COPY_PROTECTION_FAILURE
            break;
        }

        } // end switch (senseBuffer->AdditionalSenseCode)
        break;

    } // end SCSI_SENSE_ILLEGAL_REQUEST

    case SCSI_SENSE_DATA_PROTECT: { // 0x07
        error = ERROR_WRITE_PROTECT;
        retry = FALSE;
        break;
    } // end SCSI_SENSE_DATA_PROTECT

    case SCSI_SENSE_BLANK_CHECK: { // 0x08
        error = ERROR_NO_DATA_DETECTED;
        break;
    } // end SCSI_SENSE_BLANK_CHECK

    case SCSI_SENSE_NO_SENSE: { // 0x00
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
            retry   = FALSE;
        } else {
            error = ERROR_IO_DEVICE;
        }
        break;
    } // end SCSI_SENSE_NO_SENSE

    case SCSI_SENSE_HARDWARE_ERROR:  // 0x04
    case SCSI_SENSE_UNIT_ATTENTION: // 0x06
    case SCSI_SENSE_UNIQUE:          // 0x09
    case SCSI_SENSE_COPY_ABORTED:    // 0x0A
    case SCSI_SENSE_ABORTED_COMMAND: // 0x0B
    case SCSI_SENSE_EQUAL:           // 0x0C
    case SCSI_SENSE_VOL_OVERFLOW:    // 0x0D
    case SCSI_SENSE_MISCOMPARE:      // 0x0E
    case SCSI_SENSE_RESERVED:        // 0x0F
    default: {
        error = ERROR_IO_DEVICE;
        break;
    }

    } // end switch(SenseKey)

SetAndExit:

    if (ARGUMENT_PRESENT(SuggestRetry)) {
        *SuggestRetry = retry;
    }
    if (ARGUMENT_PRESENT(SuggestRetryDelay)) {
        *SuggestRetryDelay = retryDelay;
    }
    *ErrorValue = error;

    return;


}

/*++

Routine Description:
    Locks the device for exclusive access.  Uses the same method format and
    chkdsk use to gain exclusive access to the volume.

Arguments:
    VolumeHandle  - Handle to the volume.  Typically created using CreateFile()
                    to a device of the format \\.\D:
    ForceDismount - If TRUE, will try to force dismount the disk without
                    prompting the user.
    Quiet         - If TRUE, will not prompt the user.  Can be used to fail
                    if the volume is already opened without providing the
                    user an opportunity to force the volume to dismount

Return Value:

--*/
BOOL
SptUtilLockVolumeByHandle(
    IN HANDLE  VolumeHandle,
    IN BOOLEAN ForceDismount
    )
{
    ULONG tmp;
    BOOL succeeded;

    tmp = 0;
    succeeded = SptpSaferDeviceIoControl(VolumeHandle,
                                         FSCTL_LOCK_VOLUME,
                                         NULL, 0,
                                         NULL, 0,
                                         &tmp);

    // if we locked the volume successfully, or the user wants to force
    // the FS to become invalid, mark it as such so when the handle closes
    // the FS reverifies the file system.
    // if the lock failed and we're not forcing the issue, the routine
    // will fail.
    if (succeeded || ForceDismount) {

        tmp = 0;
        succeeded = SptpSaferDeviceIoControl(VolumeHandle,
                                             FSCTL_DISMOUNT_VOLUME,
                                             NULL, 0,
                                             NULL, 0,
                                             &tmp);
    }

    return succeeded;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptpSaferDeviceIoControl(
    IN  HANDLE  VolumeHandle,
    IN  DWORD   IoControlCode,
    IN  LPVOID  InBuffer,
    IN  DWORD   InBufferSize,
    IN  LPVOID  OutBuffer,
    IN  DWORD   OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    BOOL succeeded;
    OVERLAPPED overlapped;

    RtlZeroMemory(&overlapped, sizeof(OVERLAPPED));
    overlapped.hEvent = CreateEvent(NULL,  // default SD
                                    TRUE,  // must be manually reset
                                    FALSE, // initially unset
                                    NULL); // unnamed event
    if (overlapped.hEvent == NULL) {
        return FALSE;
    }

    succeeded = DeviceIoControl(VolumeHandle,
                                IoControlCode,
                                InBuffer,
                                InBufferSize,
                                OutBuffer,
                                OutBufferSize,
                                BytesReturned,
                                &overlapped);

    if (!succeeded && (GetLastError() == ERROR_IO_PENDING)) {
        succeeded = GetOverlappedResult( VolumeHandle,
                                         &overlapped,
                                         BytesReturned,
                                         TRUE);
    }

    CloseHandle( overlapped.hEvent );
    overlapped.hEvent = NULL;

    return succeeded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\lib\sptlibp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sptlibp.h

Abstract:

    private header for SPTLIB.DLL

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#ifndef __SPTLIBP_H__
#define __SPTLIBP_H__
#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include <sptlib.h>

#include <windows.h>
#include <winioctl.h>
#include <strsafe.h>

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif

typedef struct _SPTD_WITH_SENSE {
    SCSI_PASS_THROUGH_DIRECT  Sptd;
    SENSE_DATA                SenseData;
    // Allocate buffer space after this
} SPTD_WITH_SENSE, *PSPTD_WITH_SENSE;

#pragma warning(pop)
#endif // __SPTLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\strings\strings.c ===
/* STRINGS.C:
 *  This program dumps all the ascii strings in a
 *  file.
 *
 * History:
 * 05-Jan-1992 IanJa obtained from \\toolsvr\contrib\petes\slm\src\TOOLS
 * 05-Jan-1992 IanJa use buffered reads for small efficiency gain
 * 22-Feb-1992 IanJa Unicode strings too if -U used.
 * 17-Feb-1997 RajeevD added -a option
 */
#include                <stdio.h>       /* Standard I/O definitions */
#include                <stdlib.h>      /* Standard atoi types */
#include                <process.h>

#define EOL             "\n"
#define RDBIN           "rb"
#define isascii(c)      ((c) >= ' ' && (c) <= '~')
                                        /* True if char is printable ascii */
#define isswitch(s)     (((s)[0] == '-') || ((s)[0] == '/'))
                                        /* True if string is switch */
#define swchar(s)       ((s)[1])        /* Switch character */
#define MAXLEN          128             /* Max. minimum "string" length */

char                    prognam[] = "strings";
#define USAGE_FMT       "usage: %s [-a][-U][-O][-l <length>]<file list>\n"

#define BUFSZ           512
char inBuf[BUFSZ];

void
__cdecl main(argc,argv)
int                     argc;
char                    **argv;
  {
    FILE                *fi;
    char                save[MAXLEN];
    int                 strlen;
    char                *p;
    int                 nRead;
    int                 i;
    int                 argi;
    long                offset = 0L;
    int                 threshold = 4;
    int                 foffset = 0;
    int                 fUnicode = 0;
    int                 fAnnotate = 0;

    if(argc == 1)
      {
        fprintf(stderr,USAGE_FMT,argv[0]);
        fprintf(stderr,"  -a\tannotates each match with filename\n");
        exit(1);
      }
    for(argi = 1,i = 1; argi < argc; ++argi)
      {
        if(isswitch(argv[argi]))
          {
            switch(swchar(argv[argi]))
              {
                case 'U':
                  fUnicode = 1;
                  break;

                case 'O':
                  foffset = 1;
                  break;

                case 'l':
                  if (argv[argi][2])
                    {
                      threshold = atoi(&argv[argi][2]);
                    }
                  else if(++argi == argc)
                    {
                      fprintf(stderr,"%s: missing length\n",argv[0]);
                      exit(1);
                    }
                  else
                    {
                      threshold = atoi(argv[argi]);
                    }

                  if(threshold > MAXLEN)
                    {
                      fprintf(stderr, "%s: length %d should be <= %d\n",
                        argv[0], threshold, MAXLEN);
                      exit(1);
                    }
                  break;

                case 'a':
                case 'A':
                    fAnnotate = 1;
                    break;

                case '?':
                  fprintf(stderr,USAGE_FMT,argv[0]);
                  fprintf(stderr,"  -a\tannotates each match with filename\n");
                  exit(1);

                default:
                  fprintf(stderr,"%s: unknown switch \"%s\"\n",
                    argv[0],argv[argi]);
                  exit(1);
              }
          }
        else argv[i++] = argv[argi];
      }
    argc = i;
    for(i = 1; i < argc; ++i)
      {
        if((fi = fopen(argv[i],RDBIN)) == NULL)
          {
            fprintf(stderr,"%s: cannot open \"%s\"\n",argv[0],argv[i]);
            continue;
          }
        if (!fAnnotate)
            fprintf(stdout,"%s:\n",argv[i]);
        strlen = 0;
        save[threshold - 1] = '\0';
        while((nRead = fread(inBuf, 1, BUFSZ, fi)) > 0)
          {
          for (p = inBuf; p < &inBuf[nRead]; p++)
            {
              if(isascii(*p))
                {
                  if(strlen < threshold - 1) save[strlen++] = *p;
                  else
                    {
                      if(strlen++ == threshold - 1)
                        {
                          if (fAnnotate)
                              fprintf (stdout, "%s: ", argv[i]);
                          if(foffset) fprintf(stdout,"%06lx: ",
                            offset - threshold + 1);
                                 fputs(save,stdout);
                        }
                      putc(*p,stdout);
                    }
                }
              else
                {
                  if(strlen >= threshold) fputs(EOL,stdout);
                  strlen = 0;
                }
              ++offset;
            }
          if (fUnicode)
            {
            for (p = inBuf; p < &inBuf[nRead-1]; p++)
              {
                if(isascii(*p) && (p[1] == 0x00))
                  {
                    if(strlen < threshold - 1) save[strlen++] = *p;
                    else
                      {
                        if(strlen++ == threshold - 1)
                          {
                            if (fAnnotate)
                                fprintf (stdout, "%s: ", argv[i]);
                            fprintf(stdout, "U: ");
                            if(foffset) fprintf(stdout,"%06lx: ",
                              offset - threshold + 1);
                                   fputs(save,stdout);
                          }
                        putc(*p,stdout);
                      }
                    ++p;
                  }
                else
                  {
                    if(strlen >= threshold) fputs(EOL,stdout);
                    strlen = 0;
                  }
                ++offset;
              }
            }
          }
        if(strlen >= threshold) fputs(EOL,stdout);
        if (!feof(fi))
          {
            fprintf(stderr,"%s: error reading \"%s\"\n",argv[0],argv[i]);
            continue;
          }
        fclose(fi);
      }
    exit(0);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\srvname\srvname.cxx ===
/*
 * This program is used to edit the names that the NT LM server is using
 *   on the network (while the LM server is running).
 *
 * Type 'srvname -?' for usage
 *
 *   IsaacHe 3/24/94
 *   
 *   Revision Histroy:
 *   JeffJuny 3/20/97: Fix ANSI/Unicode CRT conversion problem
 *   Mmccr    12/7/98: Added -m option, added param to err
 */

extern "C" {
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <lm.h>
#include    <string.h>
#include    <locale.h>
}

/*
 * print out an error message and return
 */
static void
err( char *text, WCHAR *name, ULONG code )
{
    int i;
    char msg[ 100 ];

    i = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );
            
    if( i )
        fprintf( stderr, "%s%ws%ws%s %s\n", text?text:"", name?L" - ":L"", name?name:L"", text?" :":"", msg );
    else
        fprintf( stderr, "%s%ws%ws%s error %X\n", text?text:"", name?L" - ":L"", name?name:L"", text?" :":"", code );
}

/*
 * Print out a handy usage message
 */
void
Usage( void )
{
    fputs(           "Usage: srvname [ options ] [ name ]\n"
                     "  Options:\n"
                     "          -s server   point to 'server'\n" 
                     "          -d          delete 'name' from the server's list\n" 
                     "                        'name' is added by default if -d not present\n" 
                     "          -D domain   have 'name' act as if it is in 'domain'\n" 
                     "          -m multiple Append numbers from 1 to 'multiple' to 'name'\n" 
                     "                        results in machine having multiple + 1 names added\n",
             stderr);
}

__cdecl
main( int argc, char *argv[] )
{
    DWORD retval;
    DWORD NameMultiple = 0;
    DWORD NumberLength = 0;
    LPWSTR TargetServerName = NULL;
    WCHAR serverNameBuf[ 100 ];
    LPWSTR DomainName = NULL;
    WCHAR domainNameBuf[ 100 ];
    WCHAR newServerNameBuf[ 100 ];
    WCHAR safenewServerNameBuf[ 100 ];	
    LPWSTR NewServerName = NULL;
    CHAR *NewName = NULL;
    CHAR ComputerNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwbuflen =sizeof( ComputerNameBuf );
    BOOLEAN DeleteTheName = FALSE;
    PSERVER_INFO_100 si100;
    DWORD j;
    int i;
    WCHAR wtempbuf[5];
    
    char buf[ 500 ];


    setlocale(LC_ALL, "");
    for( i=1; i < argc; i++ ) {
        if( argv[i][0] == '-' || argv[i][0] == '/' ) {
            switch( argv[i][1] ) {
            case 's':
                if( i == argc-1 ) {
                    fputs( "Must supply a server name with -s option\n", stderr );
                    return 1;
                }
                mbstowcs( serverNameBuf, argv[ ++i ], sizeof( serverNameBuf )/sizeof(serverNameBuf[0]) );
                TargetServerName = serverNameBuf;
                break;

            case 'D':
                if( DeleteTheName == TRUE ) {
                    fputs( "-d and -D can not be used together\n", stderr );
                    return 1;
                }

                if( i == argc-1 ) {
                    fputs( "Must supply a domain name with -D option\n", stderr );
                    return 1;
                }
                mbstowcs( domainNameBuf, argv[ ++i ], sizeof( domainNameBuf )/sizeof(domainNameBuf[0]) );
                DomainName = domainNameBuf;
                break;

            case 'm':
                if( i == argc-1 ) {
                    fputs( "Must supply an integer multiple\n", stderr );
                    return 1;
                }

                NameMultiple = atoi(argv[++i]);

                if( NameMultiple <= 0 ) {
                    fputs( "Multiple value is not a valid value\n", stderr );
                    return 1;
                }
                if( NameMultiple > 1024 ) {
                    fputs( "Multiple value must not be larger than 1024\n", stderr );
                    return 1;
                }
                NumberLength = strlen(argv[i]);
                break;

            case 'd':
                DeleteTheName = TRUE;
                break;

            default:
                fprintf( stderr, "%s : invalid option\n", argv[i] );
            case '?':
                Usage( );
                return 1;
            }
        } else if( NewName == NULL ) {
            NewName = argv[i];
            mbstowcs( newServerNameBuf, NewName, sizeof( newServerNameBuf )/sizeof(newServerNameBuf[0]) );
            NewServerName = newServerNameBuf;

        } else {
            Usage( );
            return 1;
        }
    }

    if( DeleteTheName == TRUE && NewName == NULL ) {
        fputs( "You must supply the name to delete\n", stderr );
        return 1;
    }

    if ((NewName == NULL)&&(NameMultiple == 0)) {
        //
        // Print the current list of transports
        //
        DWORD entriesread = 0, totalentries = 0, resumehandle = 0;
        DWORD entriesread1 = 0;
        PSERVER_TRANSPORT_INFO_0 psti0;
        PSERVER_TRANSPORT_INFO_1 psti1;
        DWORD total;

        retval = NetServerTransportEnum ( TargetServerName,
                                          1,
                                          (LPBYTE *)&psti1,
                                          (DWORD)-1,
                                          &entriesread1,
                                          &totalentries,
                                          &resumehandle );

        if( retval != NERR_Success ) {
            entriesread1 = 0;
        }

        resumehandle = 0;
        totalentries = 0;
        retval = NetServerTransportEnum ( TargetServerName,
                                          0,
                                          (LPBYTE *)&psti0,
                                          (DWORD)-1,
                                          &entriesread,
                                          &totalentries,
                                          &resumehandle );

        if( retval != NERR_Success ) {
            err( "Could not get server transports", NULL, retval );
            return retval;
        }

        if( entriesread != totalentries ) {
            fprintf( stderr, "entries read = %d, total entries = %d\n", entriesread, totalentries );
            fputs  (         "Unable to read all the transport names!\n", stderr );
            return 1;
        }

        for( total=i=0; i < (int)entriesread; i++ ) {

            printf( "%-16.16s", psti0[i].svti0_transportaddress );

            if( entriesread1 > (DWORD)i ) {
                printf( "%-16.16ws", psti1[i].svti1_domain);
            }

            printf( " %-58.58ws", psti0[i].svti0_transportname );

            printf( "%4u workstation%s\n", 
                     psti0[i].svti0_numberofvcs,
                     psti0[i].svti0_numberofvcs != 1 ? "s" : "" );

            total += psti0[i].svti0_numberofvcs;
        }
        if( total ) {
            printf( "                                            %s-----\n",
                   entriesread1?"                 ":"" );
            printf( "                                          %s%7u\n",
                   entriesread1?"                 ":"", total );
        }
        return 0;
    }
    else if (NewName == NULL) {
        if (TargetServerName == NULL)
            GetComputerName(newServerNameBuf, &dwbuflen);
        else
            wcscpy(newServerNameBuf, TargetServerName);

        NewServerName = newServerNameBuf;
        wcstombs(ComputerNameBuf, NewServerName, sizeof(ComputerNameBuf));
        NewName = ComputerNameBuf;
    }

    if (strlen(NewName) > MAX_COMPUTERNAME_LENGTH) {
        fputs("The new name you have chosen exceeds the maximum computername length.\n"
              "Please select a different name.\n",
              stderr);
        return 1;
    }
    
    if (NameMultiple > 0) {
        if ((NumberLength + strlen(NewName)) > MAX_COMPUTERNAME_LENGTH) {
            i = MAX_COMPUTERNAME_LENGTH - strlen(NewName);
            i = NumberLength - i;
            fputs( "The Multiple you have chosen when concatinated with the servername\n"
                   "exceeds the maximum computername length.  Try reducing your\n",
                  stderr);
            if ((DWORD) i == NumberLength) {
                fputs( "chosen servernames length.\n", stderr);
            }
            else
                fprintf( stderr, "multiple by %d orders of magnitude\n", i );
            return 1;
         }
    }

    wcscpy(safenewServerNameBuf, NewServerName);

    if( DeleteTheName == FALSE ) {
        for (j = 0; j <= NameMultiple; j++)
        {
            if (j) {
                wcscpy(NewServerName, safenewServerNameBuf);
                _itow(j, wtempbuf, 10);
                wcscat(NewServerName, wtempbuf);
            }
            //
            // Add the new name to all of the transports
            //
            retval = NetServerComputerNameAdd( TargetServerName, DomainName, NewServerName );

            if( retval != NERR_Success ) {
                    err( "NetServerComputerNameAdd", NewServerName, retval );
            }
            else {
                printf("Added Name: %ws on Server: %ws%ws%ws\n", 
                           NewServerName, 
                           TargetServerName, 
                           DomainName?L", Domain: ":L"", 
                           DomainName?DomainName:L"");
            }
        }
        return retval;
    }

    //
    // Must be wanting to delete the name from all the networks.
    //

    //
    //  Make sure we don't delete the 'real name' that the server is known by.  Pre 3.51
    //   servers did not ACL protect this api!
    //
    retval = NetServerGetInfo( TargetServerName, 100, (LPBYTE *)&si100 );
    if( retval != STATUS_SUCCESS ) {
        err( "Can not get target server name", NULL, retval );
        return retval;
    }

    if( si100 == NULL ) {
        fputs( "NetServerGetInfo returned a NULL ptr, but no error!\n", stderr );
        return 1;
    }

    for (j = 0; j <= NameMultiple; j++)
    {
        if (j) {
            wcscpy(NewServerName, safenewServerNameBuf);
            _itow(j, wtempbuf, 10);
            wcscat(NewServerName, wtempbuf);
        }

        if( !_wcsicmp( si100->sv100_name, NewServerName ) ) {
            fprintf( stderr, "The primary name of %ws is %ws.\n",
                    TargetServerName ? TargetServerName : L"this server",
                    NewServerName );
            fputs( "\tYou can not delete the primary name of the server\n", stderr );   
        }
        else {
            retval = NetServerComputerNameDel( TargetServerName, NewServerName );
            if( retval != STATUS_SUCCESS ) {
               err( "NetServerComputerNameDelete", NewServerName, retval );
            }
            else {
                printf("Deleted Name: %ws on Server: %ws%ws%ws\n", 
                           NewServerName, 
                           TargetServerName, 
                           DomainName?L", Domain: ":L"", 
                           DomainName?DomainName:L"");
            }
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\mci\cdmci.cpp ===
#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <strsafe.h>

#include <mmsystem.h>  /* all the MCI stuff */
#include <stdio.h>

// Uses the MCI_STATUS command to get and display the 
// starting times for the tracks on a compact disc. 
// Returns 0L if successful; otherwise, it returns an 
// MCI error code.


DWORD getCDTrackStartTimes()
{
    UINT wDeviceID;
    int i, iNumTracks;
    DWORD dwReturn;
    DWORD dwPosition;
    char szTempString[64];
    char szTimeString[512] = "\0";  // room for 20 tracks
    MCI_OPEN_PARMS mciOpenParms;
    MCI_SET_PARMS mciSetParms;
    MCI_STATUS_PARMS mciStatusParms;

    // Open the device by specifying the device name.

    mciOpenParms.lpstrDeviceType = "cdaudio";
    if (dwReturn = mciSendCommand(NULL, MCI_OPEN,
        MCI_OPEN_TYPE, (DWORD)(LPVOID) &mciOpenParms))
    {
        // Failed to open device. 
        // Don't close device; just return error.
        return (dwReturn);
    }

    // The device opened successfully; get the device ID.
    wDeviceID = mciOpenParms.wDeviceID;

// Set the time format to minute/second/frame (MSF) format. 
    mciSetParms.dwTimeFormat = MCI_FORMAT_MSF;
    if (dwReturn = mciSendCommand(wDeviceID, MCI_SET, 
        MCI_SET_TIME_FORMAT, 
        (DWORD)(LPVOID) &mciSetParms)) 
    {
        mciSendCommand(wDeviceID, MCI_CLOSE, 0, NULL);
        return (dwReturn);
    }

    // Get the number of tracks; 
    // limit to number that can be displayed (20).
    mciStatusParms.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    if (dwReturn = mciSendCommand(wDeviceID, MCI_STATUS, 
        MCI_STATUS_ITEM, (DWORD)(LPVOID) &mciStatusParms)) 
    {
        mciSendCommand(wDeviceID, MCI_CLOSE, 0, NULL);
        return (dwReturn);
    }
    iNumTracks = mciStatusParms.dwReturn;
 
// For each track, get and save the starting location and
// build a string containing starting locations.
    for(i=1; i<=iNumTracks; i++) 
    {
        
        printf("Track %2d -", i);
        
        //
        // get/print the start address
        //

        mciStatusParms.dwItem = MCI_STATUS_POSITION;
        mciStatusParms.dwTrack = i;
        if (dwReturn = mciSendCommand(wDeviceID, 
            MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, 
            (DWORD)(LPVOID) &mciStatusParms)) 
        {
            mciSendCommand(wDeviceID, MCI_CLOSE, 0, NULL);
            return (dwReturn);
        }

        printf("  %02d:%02d:%02d",
               MCI_MSF_MINUTE(mciStatusParms.dwReturn), 
               MCI_MSF_SECOND(mciStatusParms.dwReturn), 
               MCI_MSF_FRAME(mciStatusParms.dwReturn)
               );

        //
        // get/print the track length
        //
        
        mciStatusParms.dwItem = MCI_STATUS_LENGTH;
        mciStatusParms.dwTrack = i;
        if (dwReturn = mciSendCommand(wDeviceID, 
            MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, 
            (DWORD)(LPVOID) &mciStatusParms)) 
        {
            mciSendCommand(wDeviceID, MCI_CLOSE, 0, NULL);
            return (dwReturn);
        }

        printf("  %02d:%02d:%02d",
               MCI_MSF_MINUTE(mciStatusParms.dwReturn), 
               MCI_MSF_SECOND(mciStatusParms.dwReturn), 
               MCI_MSF_FRAME(mciStatusParms.dwReturn)
               );

        //
        // get/print if it's audio or data
        //

        mciStatusParms.dwItem = MCI_CDA_STATUS_TYPE_TRACK ;
        mciStatusParms.dwTrack = i;
        if (dwReturn = mciSendCommand(wDeviceID, 
            MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, 
            (DWORD)(LPVOID) &mciStatusParms)) 
        {
            mciSendCommand(wDeviceID, MCI_CLOSE, 0, NULL);
            return (dwReturn);
        }
        if (mciStatusParms.dwReturn == MCI_CDA_TRACK_AUDIO) {
            printf(" (audio)\n");
        } else {
            printf(" (data )\n");
        }

    }

    // Free memory and close the device.
    if (dwReturn = mciSendCommand(wDeviceID, 
        MCI_CLOSE, 0, NULL)) 
    {
        return (dwReturn);
    }

    return (0L);
}

__cdecl
main(UINT Argc, UCHAR *Argv[])
{
    // Use MessageBox to display starting times.
    printf("Disc Info\n");
    getCDTrackStartTimes();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\sample\spti.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spti.h

Abstract:

    These are the structures and defines that are used in the
    SPTI.C. 

Author:

Revision History:

--*/

#include <sptlib.h>
#include <conio.h>   // for printf, _getch, etc.
#include <strsafe.h> // safer string functions

#if defined(_X86_)
    #define PAGE_SIZE  0x1000
    #define PAGE_SHIFT 12L
#elif defined(_AMD64_)
    #define PAGE_SIZE  0x1000
    #define PAGE_SHIFT 12L
#elif defined(_IA64_)
    #define PAGE_SIZE  0x2000
    #define PAGE_SHIFT 13L
#else
    // undefined platform?
    #define PAGE_SIZE  0x1000
    #define PAGE_SHIFT 12L
#endif

#define MAXIMUM_BUFFER_SIZE 0x990 // 2448, largest single CD sector size, smaller than one page


#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) >= (_b)) ? (_a) : (_b))

//
// neat little hacks to count number of bits set
//
__inline ULONG CountOfSetBits(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#define BOOLEAN_TO_STRING(_b_) \
( (_b_) ? "True" : "False" )

typedef struct SPT_ALIGNED_MEMORY {
    
    PVOID A;     // aligned pointer
    PVOID U;     // unaligned pointer
    PUCHAR File; // file allocated from
    ULONG  Line; // line number allocated from

} SPT_ALIGNED_MEMORY, *PSPT_ALIGNED_MEMORY;


//
// Allocates a device-aligned buffer
//
#define AllocateAlignedBuffer(Allocation,AlignmentMask,Size) \
 pAllocateAlignedBuffer(Allocation,AlignmentMask,Size,__FILE__, __LINE__)

BOOL
pAllocateAlignedBuffer(
    PSPT_ALIGNED_MEMORY Allocation,
    ULONG AlignmentMask,
    SIZE_T AllocationSize,
    PUCHAR File,
    ULONG Line
    );

//
// Free's a previously-allocated aligned buffer
//
VOID
FreeAlignedBuffer(
    PSPT_ALIGNED_MEMORY Allocation
    );


//
// Prints a buffer to the screen in hex and ASCII
//
VOID
PrintBuffer(
    IN  PVOID  InputBuffer,
    IN  SIZE_T Size
    );

//
// Prints the formatted message for a given error code
//
VOID
PrintError(
    ULONG Error
    );

//
// Prints the device descriptor in a formatted manner
//
VOID
PrintDeviceDescriptor(
    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor
    );

//
// Prints the adapter descriptor in a formatted manner
//
VOID
PrintAdapterDescriptor(
    PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptor
    );

//
// Gets (and prints) the device and adapter descriptor
// for a device.  Returns the alignment mask (required
// for allocating a properly aligned buffer).
//
BOOL
GetAlignmentMaskForDevice(
    HANDLE DeviceHandle,
    PULONG AlignmentMask
    );



#if 0
VOID   PrintInquiryData(PVOID);
VOID   PrintStatusResults(BOOL, DWORD, PSCSI_PASS_THROUGH_WITH_BUFFERS, ULONG);
VOID   PrintSenseInfo(PSCSI_PASS_THROUGH_WITH_BUFFERS);
#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\spt\sample\spti.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spti.c

Abstract:

    Win32 application that can communicate directly with SCSI devices via
    IOCTLs.  

Author:


Environment:

    User mode.

Notes:


Revision History:

--*/

#include "spti.h"


PUCHAR BusTypeStrings[] = {
    "Unknown",
    "Scsi",
    "Atapi",
    "Ata",
    "1394",
    "Ssa",
    "Fibre",
    "Usb",
    "RAID",
    "Not Defined",
};
#define NUMBER_OF_BUS_TYPE_STRINGS (sizeof(BusTypeStrings)/sizeof(BusTypeStrings[0]))


typedef struct _SPTI_OPTIONS {
    
    PUCHAR  PortName;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN LockVolume;
    BOOLEAN ForceLock;

} SPTI_OPTIONS, *PSPTI_OPTIONS;

typedef enum _RETURN_VALUE {
    RETURN_BAD_ARGS = -1,
    RETURN_NAME_TOO_LONG = -2,
    RETURN_UNABLE_TO_OPEN_DEVICE = -3,
    RETURN_UNABLE_TO_LOCK_VOLUME = -4,
    RETURN_UNABLE_TO_GET_ALIGNMENT_MASK = -5,

} RETURN_VALUE, *PRETURN_VALUE;

BOOL
LockVolume(
    HANDLE DeviceHandle,
    PSPTI_OPTIONS Options
    )
{
    BOOL lockSucceeded;

    lockSucceeded = SptUtilLockVolumeByHandle(DeviceHandle, FALSE);

    if (!lockSucceeded && !Options->ForceLock)
    {

        // save the error, and restore after getting user input
        ULONG lastError = GetLastError();
        int input;

        do {
            printf("This program cannot run because the volume is in use\n"
                   "by another process.  It may run if this volume is\n"
                   "dismounted first.\n"
                   "ALL OPENED HANDLES TO THIS VOLUME WOULD THEN BE INVALID.\n"
                   "Would you like to force a dismount on this volume? (Y/N) "
                   );
            input = _getch();
            input = toupper( input );

        } while ( (input != EOF) &&
                  (input != 'Y') &&
                  (input != 'N') );

        if (input == 'Y')
        {
            Options->ForceLock = TRUE;
        }

        // now restore the error from the IOCTL
        SetLastError(lastError);
    }

    if (!lockSucceeded && Options->ForceLock)
    {
        lockSucceeded = SptUtilLockVolumeByHandle(DeviceHandle, TRUE);
    }
    return lockSucceeded;
}

BOOL
ParseArguments(
    int argc,
    char * argv[],
    PSPTI_OPTIONS Options
    )
{
    int i;

    if (Options == NULL)
    {
        return FALSE;
    }

    RtlZeroMemory( Options, sizeof(SPTI_OPTIONS) );
    Options->ForceLock = FALSE;
    Options->LockVolume = FALSE;
    Options->PortName = NULL;
    Options->SharedRead = FALSE;
    Options->SharedWrite = FALSE;



    // loop through the arguments....

    for (i = 1; i < argc; i++)
    {
        if ( (argv[i][0] == '/') || (argv[i][0] == '-') )
        {
            // switch found.  parse it.
            PUCHAR option = &(argv[i][1]);

            if (_strnicmp(option, "r", strlen("r")) == 0)
            {
                Options->SharedRead = TRUE;
            }
            else if (_strnicmp(option, "w", strlen("w")) == 0)
            {
                Options->SharedWrite = TRUE;
            }
            else if (_strnicmp(option, "lock", strlen("lock")) == 0)
            {
                Options->LockVolume = TRUE;
            }
            else if (_strnicmp(option, "forcelock", strlen("forcelock")) == 0)
            {
                Options->ForceLock = TRUE;
            }
            else
            {
                printf("Unknown option: %s\n", argv[i]);
                return FALSE;
            }
        }
        else
        {
            // previously set one?
            if (Options->PortName != NULL)
            {
                printf("Can only have one non-option argument.\n"
                       "Two were supplied: '%s', '%s'\n",
                       Options->PortName,
                       argv[i]
                       );
                return FALSE;
            }
            else
            {
                // set to this argument
                Options->PortName = argv[i];
            }
        }
    } // end argument loop

    // validate non-conflicting options.
    if (Options->ForceLock || Options->LockVolume)
    {
        // locking the volume requires shared read/write access
        if ( (( Options->SharedRead) && (!Options->SharedWrite)) ||
             ((!Options->SharedRead) && ( Options->SharedWrite)) )
        {
            printf("Locking the volume requires both read and write shared "
                   "access\n");
            return FALSE;
        }
        Options->LockVolume = TRUE;
    }
    
    // validate a port name was supplied
    if ( Options->PortName == NULL )
    {
        printf("A port name is a required argument\n");
        return FALSE;
    }

    // if they passed neither read nor write, set both as default
    if ((!Options->SharedRead) && (!Options->SharedWrite))
    {
        Options->SharedRead  = TRUE;
        Options->SharedWrite = TRUE;
    }

    return TRUE;
}

//
// Prints the built-in help for this program
//
VOID
PrintUsageInfo(
    char * programName
    )
{
    printf("Usage:  %s <port-name> [-r | -w | -lock | -forcelock]\n", programName );
    printf("Examples:\n");
    printf("    %s g:          (open the G: drive in SHARED READ/WRITE mode)\n", programName);
    printf("    %s i:     r    (open the I: drive in SHARED READ mode)\n", programName);
    printf("    %s r:     lock (lock the R: volume for exclusive access\n", programName);
    printf("    %s Tape0  w    (open the tape class driver in SHARED WRITE mode)\n", programName);
    printf("    %s Scsi2:      (open the miniport driver specified)\n", programName);
}

//
// don't print non-printable chars
//
VOID PrintChar( IN UCHAR Char ) {
    if ( (Char >= 0x21) && (Char <= 0x7E) ) {
        printf("%c", Char);
    } else {
        printf("%c", '.');
    }
}

//
// Prints a buffer to the screen in hex and ASCII
//
VOID
PrintBuffer(
    IN  PVOID  InputBuffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;
    PUCHAR buffer = InputBuffer;

    while (Size >= 0x10) {

        DWORD i;

        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  ",
                offset,
                *(buffer +  0), *(buffer +  1), *(buffer +  2), *(buffer +  3),
                *(buffer +  4), *(buffer +  5), *(buffer +  6), *(buffer +  7),
                *(buffer +  8), *(buffer +  9), *(buffer + 10), *(buffer + 11),
                *(buffer + 12), *(buffer + 13), *(buffer + 14), *(buffer + 15)
                );

        for (i=0; i < 0x10; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");


        Size -= 0x10;
        offset += 0x10;
        buffer += 0x10;
    }

    if (Size != 0) {

        DWORD i;

        printf("%08x:", offset);

        //
        // print the hex values
        //
        for (i=0; i<Size; i++) {

            if ((i%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *(buffer+i));

        }
        // add an extra space for half-way mark
        if (Size <= 0x8)
        {
            printf(" ");
        }

        //
        // fill in the blanks
        //
        for (; i < 0x10; i++) {
            printf("   ");
        }
        printf("  ");
        //
        // print the ascii
        //
        for (i=0; i<Size; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");
    }
    return;
}

//
// Prints the formatted message for a given error code
//
VOID
PrintError(
    ULONG ErrorCode
    )
{
    UCHAR errorBuffer[80];
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          ErrorCode,
                          0,
                          errorBuffer,
                          sizeof(errorBuffer),
                          NULL
                          );

    if (count != 0) {
        printf("%s\n", errorBuffer);
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }
}

//
// Prints the device descriptor in a formatted manner
//
VOID
PrintAdapterDescriptor(
    PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptor
    )
{
    ULONG trueMaximumTransferLength;
    PUCHAR busType;

    if (AdapterDescriptor->BusType <= NUMBER_OF_BUS_TYPE_STRINGS) {
        busType = BusTypeStrings[AdapterDescriptor->BusType];
    } else {
        busType = BusTypeStrings[NUMBER_OF_BUS_TYPE_STRINGS-1];
    }

    // subtract one page, as transfers do not always start on a page boundary
    if (AdapterDescriptor->MaximumPhysicalPages > 1) {
        trueMaximumTransferLength = AdapterDescriptor->MaximumPhysicalPages - 1;
    } else {
        trueMaximumTransferLength = 1;
    }
    // make it into a byte value
    trueMaximumTransferLength <<= PAGE_SHIFT;

    // take the minimum of the two
    if (trueMaximumTransferLength > AdapterDescriptor->MaximumTransferLength) {
        trueMaximumTransferLength = AdapterDescriptor->MaximumTransferLength;
    }

    // always allow at least a single page transfer
    if (trueMaximumTransferLength < PAGE_SIZE) {
        trueMaximumTransferLength = PAGE_SIZE;
    }

    puts("\n            ***** STORAGE ADAPTER DESCRIPTOR DATA *****");
    printf("              Version: %08x\n"
           "            TotalSize: %08x\n"
           "MaximumTransferLength: %08x (bytes)\n"
           " MaximumPhysicalPages: %08x\n"
           "  TrueMaximumTransfer: %08x (bytes)\n"
           "        AlignmentMask: %08x\n"
           "       AdapterUsesPio: %s\n"
           "     AdapterScansDown: %s\n"
           "      CommandQueueing: %s\n"
           "  AcceleratedTransfer: %s\n"
           "             Bus Type: %s\n"
           "    Bus Major Version: %04x\n"
           "    Bus Minor Version: %04x\n",
           AdapterDescriptor->Version,
           AdapterDescriptor->Size,
           AdapterDescriptor->MaximumTransferLength,
           AdapterDescriptor->MaximumPhysicalPages,
           trueMaximumTransferLength,
           AdapterDescriptor->AlignmentMask,
           BOOLEAN_TO_STRING(AdapterDescriptor->AdapterUsesPio),
           BOOLEAN_TO_STRING(AdapterDescriptor->AdapterScansDown),
           BOOLEAN_TO_STRING(AdapterDescriptor->CommandQueueing),
           BOOLEAN_TO_STRING(AdapterDescriptor->AcceleratedTransfer),
           busType,
           AdapterDescriptor->BusMajorVersion,
           AdapterDescriptor->BusMinorVersion);


    

    printf("\n\n");
}

//
// Prints the adapter descriptor in a formatted manner
//
VOID
PrintDeviceDescriptor(
    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor
    )
{
    PUCHAR vendorId = "";
    PUCHAR productId = "";
    PUCHAR productRevision = "";
    PUCHAR serialNumber = "";
    PUCHAR busType;

    if (DeviceDescriptor->BusType <= NUMBER_OF_BUS_TYPE_STRINGS) {
        busType = BusTypeStrings[DeviceDescriptor->BusType];
    } else {
        busType = BusTypeStrings[NUMBER_OF_BUS_TYPE_STRINGS-1];
    }

    if ((DeviceDescriptor->ProductIdOffset != 0) &&
        (DeviceDescriptor->ProductIdOffset != -1)) {
        productId        = (PUCHAR)(DeviceDescriptor);
        productId       += (ULONG_PTR)DeviceDescriptor->ProductIdOffset;
    }
    if ((DeviceDescriptor->VendorIdOffset != 0) &&
        (DeviceDescriptor->VendorIdOffset != -1)) {
        vendorId         = (PUCHAR)(DeviceDescriptor);
        vendorId        += (ULONG_PTR)DeviceDescriptor->VendorIdOffset;
    }
    if ((DeviceDescriptor->ProductRevisionOffset != 0) &&
        (DeviceDescriptor->ProductRevisionOffset != -1)) {
        productRevision  = (PUCHAR)(DeviceDescriptor);
        productRevision += (ULONG_PTR)DeviceDescriptor->ProductRevisionOffset;
    }
    if ((DeviceDescriptor->SerialNumberOffset != 0) &&
        (DeviceDescriptor->SerialNumberOffset != -1)) {
        serialNumber     = (PUCHAR)(DeviceDescriptor);
        serialNumber    += (ULONG_PTR)DeviceDescriptor->SerialNumberOffset;
    }


    puts("\n            ***** STORAGE DEVICE DESCRIPTOR DATA *****");
    printf("              Version: %08x\n"
           "            TotalSize: %08x\n"
           "           DeviceType: %08x\n"
           "   DeviceTypeModifier: %08x\n"
           "       RemovableMedia: %s\n"
           "      CommandQueueing: %s\n"
           "            Vendor Id: %s\n"
           "           Product Id: %s\n"
           "     Product Revision: %s\n"
           "        Serial Number: %s\n"
           "             Bus Type: %s\n"
           "       Raw Properties: %s\n",
           DeviceDescriptor->Version,
           DeviceDescriptor->Size,
           DeviceDescriptor->DeviceType,
           DeviceDescriptor->DeviceTypeModifier,
           BOOLEAN_TO_STRING(DeviceDescriptor->RemovableMedia),
           BOOLEAN_TO_STRING(DeviceDescriptor->CommandQueueing),
           vendorId,
           productId,
           productRevision,
           serialNumber,
           busType,
           (DeviceDescriptor->RawPropertiesLength ? "Follow" : "None"));
    
    if (DeviceDescriptor->RawPropertiesLength != 0) {
        PrintBuffer(DeviceDescriptor->RawDeviceProperties,
                    DeviceDescriptor->RawPropertiesLength);
    }

    printf("\n\n");
}

//
// Gets (and prints) the device and adapter descriptor
// for a device.  Returns the alignment mask (required
// for allocating a properly aligned buffer).
//
BOOL
GetAlignmentMaskForDevice(
    IN HANDLE DeviceHandle,
    OUT PULONG AlignmentMask
    )
{
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor = NULL;
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    STORAGE_DESCRIPTOR_HEADER header = {0};

    BOOL ok = TRUE;
    BOOL failed = TRUE;
    ULONG i;

    *AlignmentMask = 0; // default to no alignment

    // Loop twice:
    //  First, get size required for storage adapter descriptor
    //  Second, allocate and retrieve storage adapter descriptor
    //  Third, get size required for storage device descriptor
    //  Fourth, allocate and retrieve storage device descriptor
    for (i=0;i<4;i++) {

        PVOID buffer;
        ULONG bufferSize;
        ULONG returnedData;
        
        STORAGE_PROPERTY_QUERY query = {0};

        switch(i) {
            case 0: {
                query.QueryType = PropertyStandardQuery;
                query.PropertyId = StorageAdapterProperty;
                bufferSize = sizeof(STORAGE_DESCRIPTOR_HEADER);
                buffer = &header;
                break;
            }
            case 1: {
                query.QueryType = PropertyStandardQuery;
                query.PropertyId = StorageAdapterProperty;
                bufferSize = header.Size;
                if (bufferSize != 0) {
                    adapterDescriptor = LocalAlloc(LPTR, bufferSize);
                    if (adapterDescriptor == NULL) {
                        goto Cleanup;
                    }
                }
                buffer = adapterDescriptor;
                break;
            }
            case 2: {
                query.QueryType = PropertyStandardQuery;
                query.PropertyId = StorageDeviceProperty;
                bufferSize = sizeof(STORAGE_DESCRIPTOR_HEADER);
                buffer = &header;
                break;
            }
            case 3: {
                query.QueryType = PropertyStandardQuery;
                query.PropertyId = StorageDeviceProperty;
                bufferSize = header.Size;

                if (bufferSize != 0) {
                    deviceDescriptor = LocalAlloc(LPTR, bufferSize);
                    if (deviceDescriptor == NULL) {
                        goto Cleanup;
                    }
                }
                buffer = deviceDescriptor;
                break;
            }
        }

        // buffer can be NULL if the property queried DNE.
        if (buffer != NULL) {
            RtlZeroMemory(buffer, bufferSize);
            
            // all setup, do the ioctl
            ok = DeviceIoControl(DeviceHandle,
                                 IOCTL_STORAGE_QUERY_PROPERTY,
                                 &query,
                                 sizeof(STORAGE_PROPERTY_QUERY),
                                 buffer,
                                 bufferSize,
                                 &returnedData,
                                 FALSE);
            if (!ok) {
                if (GetLastError() == ERROR_MORE_DATA) {
                    // this is ok, we'll ignore it here
                } else if (GetLastError() == ERROR_INVALID_FUNCTION) {
                    // this is also ok, the property DNE
                } else if (GetLastError() == ERROR_NOT_SUPPORTED) {
                    // this is also ok, the property DNE
                } else {
                    // some unexpected error -- exit out
                    goto Cleanup;
                }
                // zero it out, just in case it was partially filled in.
                RtlZeroMemory(buffer, bufferSize);
            }
        }
    } // end i loop

    // adapterDescriptor is now allocated and full of data.
    // deviceDescriptor is now allocated and full of data.
    
    if (adapterDescriptor == NULL) {
        printf("   ***** No adapter descriptor supported on the device *****\n");
    } else {
        PrintAdapterDescriptor(adapterDescriptor);
        *AlignmentMask = adapterDescriptor->AlignmentMask;
    }
    
    if (deviceDescriptor == NULL) {
        printf("   ***** No device descriptor supported on the device  *****\n");
    } else {
        PrintDeviceDescriptor(deviceDescriptor);
    }
    
    failed = FALSE;

Cleanup:
    if (adapterDescriptor != NULL) {
        LocalFree( adapterDescriptor );
    }
    if (deviceDescriptor != NULL) {
        LocalFree( deviceDescriptor );
    }
    
    return (!failed);
}


BOOL
pAllocateAlignedBuffer(
    PSPT_ALIGNED_MEMORY Allocation,
    ULONG AlignmentMask,
    SIZE_T AllocationSize,
    PUCHAR File,
    ULONG Line
    )
{
    SIZE_T allocSize;

    if (Allocation->A != NULL)
    {
        // ASSERT(FALSE);
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    if (Allocation->U != NULL)
    {
        // ASSERT(FALSE);
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    if (Allocation->File != NULL)
    {
        // ASSERT(FALSE);
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    if (Allocation->Line != 0)
    {
        // ASSERT(FALSE);
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RtlZeroMemory(Allocation, sizeof( SPT_ALIGNED_MEMORY ));

    if ( AllocationSize > (((SIZE_T)-1) >> 2) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (AlignmentMask == ((ULONG)-1))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (CountOfSetBits(AlignmentMask+1) != 1)
    {
        printf("Alignment mask (%x) is invalid -- all bits from the highest set "
               "bit must be set to one\n", AlignmentMask);
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Allocate a buffer large enough to guarantee that there exists
    // within the allocation an aligned address with sufficient length
    //
    Allocation->U = LocalAlloc( LPTR, AllocationSize + AlignmentMask );
    if (Allocation->U == NULL)
    {
        return FALSE;
    }

    //
    // Now fill in the remainder of the structure
    //
    Allocation->A = (PVOID)( ((ULONG_PTR)Allocation->U) + AlignmentMask );
    Allocation->A = (PVOID)( ((ULONG_PTR)Allocation->A) & (~((ULONG_PTR)AlignmentMask)) );
    Allocation->File = File;
    Allocation->Line = Line;
    
    return TRUE;
}

VOID
FreeAlignedBuffer(
    PSPT_ALIGNED_MEMORY Allocation
    )
{
    // ASSERT( Allocation->U != NULL );
    // ASSERT( Allocation->A != NULL );
    // ASSERT( Allocation->File != NULL );
    // ASSERT( Allocation->Line != 0    );

    if (Allocation->U != NULL)
    {
        LocalFree( Allocation->U );
    }
    RtlZeroMemory( Allocation, sizeof(SPT_ALIGNED_MEMORY) );
    return;
}










int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE deviceHandle;
    SPTI_OPTIONS options;
    ULONG alignmentMask;
    RtlZeroMemory(&options, sizeof(SPTI_OPTIONS));


    // first, verify we have proper arguments
    if (!ParseArguments(argc, argv, &options))
    {
        PrintUsageInfo(argv[0]);
        return RETURN_BAD_ARGS;
    }

    // open the device as requested
    {
        #define MAX_LENGTH 250
        
        UCHAR buffer[MAX_LENGTH];
        HRESULT hr;
        DWORD shareFlags;
        
        hr = StringCchPrintf(buffer,
                             sizeof(buffer)/sizeof(buffer[0]),
                             "\\\\.\\%s",
                             options.PortName
                             );
        if (!SUCCEEDED(hr)) {
            puts("Port name exceeded internal length limit");
            return RETURN_NAME_TOO_LONG;
        }

        shareFlags = 0;
        if (options.SharedRead)
        {
            SET_FLAG( shareFlags, FILE_SHARE_READ );
        }
        if (options.SharedWrite)
        {
            SET_FLAG( shareFlags, FILE_SHARE_WRITE );
        }

        deviceHandle = CreateFile(buffer,
                                  GENERIC_READ | GENERIC_WRITE,
                                  shareFlags,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

        if(deviceHandle == INVALID_HANDLE_VALUE) {
            printf("Error opening device %s\n", buffer);
            PrintError(GetLastError());
            return RETURN_UNABLE_TO_OPEN_DEVICE;
        }

    }

    // lock the volume if requested
    if (options.LockVolume)
    {
        if (!LockVolume(deviceHandle, &options))
        {
            puts("Error locking volume");
            PrintError(GetLastError());
            return RETURN_UNABLE_TO_LOCK_VOLUME;
        }
    }

    // get device information, such as the alignment mask
    if (!GetAlignmentMaskForDevice(deviceHandle, &alignmentMask))
    {
        puts("Unable to get alignment mask for device");
        PrintError(GetLastError());
        return RETURN_UNABLE_TO_GET_ALIGNMENT_MASK;
    }

    printf("\n"
           "            *****     Detected Alignment Mask    *****\n"
           "            *****             was %08x       *****\n\n",
           alignmentMask);





    puts("");
    puts("            ***** MODE SENSE10 -- return all pages *****");
    puts("            *****       with SenseInfo buffer      *****\n");
    {
        SPT_ALIGNED_MEMORY alignedAllocation;
        DWORD allocationSize = MAXIMUM_BUFFER_SIZE;


        RtlZeroMemory( &alignedAllocation, sizeof(SPT_ALIGNED_MEMORY) );

        if (!AllocateAlignedBuffer(&alignedAllocation,
                                   alignmentMask,
                                   allocationSize))
        {
            puts("Unable to allocate memory for MODE_SENSE10");
            PrintError(GetLastError());
        }
        else
        {
            CDB cdb;
            SENSE_DATA sense;
            RtlZeroMemory( &cdb, sizeof(CDB) );
            RtlZeroMemory( &sense, sizeof(SENSE_DATA) );

            cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.PageCode = MODE_SENSE_RETURN_ALL;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(allocationSize >> (8*1));
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(allocationSize >> (8*0));
            
            if (!SptSendCdbToDeviceEx(deviceHandle,
                                      &cdb,
                                      sizeof( cdb.MODE_SENSE10 ),
                                      alignedAllocation.A,
                                      &allocationSize,
                                      &sense,
                                      sizeof( SENSE_DATA ),
                                      TRUE,
                                      SPT_MODE_SENSE_TIMEOUT))
            {
                puts("Unable to send command to device");

                if (GetLastError() == ERROR_SUCCESS)
                {
                    puts("Inquiry data may be valid\n");
                    printf("Failed %02x/%02x/%02x, full sense data:\n",
                           sense.SenseKey,
                           sense.AdditionalSenseCode,
                           sense.AdditionalSenseCodeQualifier
                           );
                    PrintBuffer(&sense, sizeof(SENSE_DATA));
                }
                else
                {
                    PrintError(GetLastError());
                }

            }
            else if (sense.SenseKey != SCSI_SENSE_NO_SENSE)
            {
                printf("Failed %02x/%02x/%02x, full sense data:\n",
                       sense.SenseKey,
                       sense.AdditionalSenseCode,
                       sense.AdditionalSenseCodeQualifier
                       );
                PrintBuffer(&sense, sizeof(SENSE_DATA));
            }
            else
            {
                printf("%x bytes returned:\n", allocationSize);
                PrintBuffer(alignedAllocation.A, allocationSize);
            }

            FreeAlignedBuffer( &alignedAllocation );
        }
    }

    puts("");
    puts("            ***** MODE SENSE10 -- return all pages *****");
    puts("            *****      without SenseInfo buffer    *****\n");
    {
        SPT_ALIGNED_MEMORY alignedAllocation;
        DWORD allocationSize = MAXIMUM_BUFFER_SIZE;

        RtlZeroMemory( &alignedAllocation, sizeof(SPT_ALIGNED_MEMORY) );

        if (!AllocateAlignedBuffer(&alignedAllocation,
                                   alignmentMask,
                                   allocationSize))
        {
            puts("Unable to allocate memory for MODE_SENSE10");
            PrintError(GetLastError());
        }
        else
        {
            CDB cdb;
            RtlZeroMemory( &cdb, sizeof(CDB) );

            cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.PageCode = MODE_SENSE_RETURN_ALL;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(allocationSize >> (8*1));
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(allocationSize >> (8*0));
            
            if (!SptSendCdbToDeviceEx(deviceHandle,
                                      &cdb,
                                      sizeof( cdb.MODE_SENSE10 ),
                                      alignedAllocation.A,
                                      &allocationSize,
                                      NULL,
                                      0,
                                      TRUE,
                                      SPT_MODE_SENSE_TIMEOUT))
            {
                PrintError(GetLastError());
                puts("Unable to send command to device");
            }
            else
            {
                printf("%x bytes returned:\n", allocationSize);
                PrintBuffer(alignedAllocation.A, allocationSize);
            }

            FreeAlignedBuffer( &alignedAllocation );
        }
    }

    puts("");
    puts("            *****      TEST UNIT READY      *****\n");
    puts("            *****    DataBufferLength = 0   *****\n\n");
    {
        CDB cdb;
        SENSE_DATA sense;
        DWORD allocationSize = 0;
        RtlZeroMemory( &cdb, sizeof(CDB) );
        RtlZeroMemory( &sense, sizeof(SENSE_DATA) );

        cdb.CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        if (!SptSendCdbToDeviceEx(deviceHandle,
                                  &cdb,
                                  sizeof( cdb.CDB6GENERIC ),
                                  NULL,
                                  &allocationSize,
                                  &sense,
                                  sizeof( SENSE_DATA ),
                                  FALSE, // not sending anything to the device
                                  SPT_DEFAULT_TIMEOUT))
        {
            puts("Unable to send command to device");
            
            if (GetLastError() == ERROR_SUCCESS)
            {
                puts("Inquiry data may be valid\n");
                printf("Failed %02x/%02x/%02x, full sense data:\n",
                       sense.SenseKey,
                       sense.AdditionalSenseCode,
                       sense.AdditionalSenseCodeQualifier
                       );
                PrintBuffer(&sense, sizeof(SENSE_DATA));
            }
            else
            {
                PrintError(GetLastError());
            }
        }
        else if (sense.SenseKey != SCSI_SENSE_NO_SENSE)
        {
            printf("Failed %02x/%02x/%02x, full sense data:\n",
                   sense.SenseKey,
                   sense.AdditionalSenseCode,
                   sense.AdditionalSenseCodeQualifier
                   );
            PrintBuffer(&sense, sizeof(SENSE_DATA));
        }
        else
        {
            printf("%x bytes returned\n", allocationSize);
        }
    }

    
    puts("");
    puts("            ***** MODE SENSE10 -- return C/DVD *****");
    puts("            *****    capabalities page only    *****\n");
    {
        SPT_ALIGNED_MEMORY alignedAllocation;
        DWORD allocationSize = MAXIMUM_BUFFER_SIZE;

        RtlZeroMemory( &alignedAllocation, sizeof(SPT_ALIGNED_MEMORY) );

        if (!AllocateAlignedBuffer(&alignedAllocation,
                                   alignmentMask,
                                   allocationSize))
        {
            puts("Unable to allocate memory for MODE_SENSE10");
            PrintError(GetLastError());
        }
        else
        {
            CDB cdb;
            SENSE_DATA sense;
            RtlZeroMemory( &cdb, sizeof(CDB) );
            RtlZeroMemory( &sense, sizeof(SENSE_DATA) );

            cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(allocationSize >> (8*1));
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(allocationSize >> (8*0));
            
            if (!SptSendCdbToDeviceEx(deviceHandle,
                                      &cdb,
                                      sizeof( cdb.MODE_SENSE10 ),
                                      alignedAllocation.A,
                                      &allocationSize,
                                      &sense,
                                      sizeof( SENSE_DATA ),
                                      TRUE,
                                      SPT_MODE_SENSE_TIMEOUT))
            {
                puts("Unable to send command to device");

                if (GetLastError() == ERROR_SUCCESS)
                {
                    puts("Inquiry data may be valid\n");
                    printf("Failed %02x/%02x/%02x, full sense data:\n",
                           sense.SenseKey,
                           sense.AdditionalSenseCode,
                           sense.AdditionalSenseCodeQualifier
                           );
                    PrintBuffer(&sense, sizeof(SENSE_DATA));
                }
                else
                {
                    PrintError(GetLastError());
                }
            }
            else if (sense.SenseKey != SCSI_SENSE_NO_SENSE)
            {
                printf("Failed %02x/%02x/%02x, full sense data:\n",
                       sense.SenseKey,
                       sense.AdditionalSenseCode,
                       sense.AdditionalSenseCodeQualifier
                       );
                PrintBuffer(&sense, sizeof(SENSE_DATA));
            }
            else
            {
                printf("%x bytes returned:\n", allocationSize);
                PrintBuffer(alignedAllocation.A, allocationSize);
            }

            FreeAlignedBuffer( &alignedAllocation );
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\socode.c ===
/****************************** Module Header ******************************\
* Module Name: socode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* What a hack!
* This should be provided as a library, DLL or as C file to be included
*  by anyone using this.
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

#define T1 "\t"
#define T2 "\t\t"
#define T3 "\t\t\t"
#define L01(sz1) #sz1,
#define L11(sz1) T1 #sz1,
#define L21(sz1) T2 #sz1,
#define L31(sz1) T3 #sz1,
#define L02(sz1, sz2) #sz1 ", " #sz2,
#define L12(sz1, sz2) T1 #sz1 ", " #sz2,

char * gpszHeader [] = {

L01(typedef struct tagSTRUCTUREOFFSETSTABLE {)
L11(    char * pszField;)
L11(    unsigned long dwOffset;)
L02(} STRUCTUREOFFSETSTABLE, *PSTRUCTUREOFFSETSTABLE;\r\n)

L01(typedef struct tagSTRUCTURESTABLE {)
L11(    char * pszName;)
L11(    unsigned long dwSize;)
L11(    PSTRUCTUREOFFSETSTABLE psot;)
L02(} STRUCTURESTABLE, *PSTRUCTURESTABLE;\r\n)

NULL
} ;

char * gpszTail [] = {
L01(#include "dsocode.c")
NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\soglobal.c ===
/****************************** Module Header ******************************\
* Module Name: soglobal.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* Globals
\***************************************************************************/

char gszStructTag [] = "typedef struct";

char gszPrecomph [] = "#include \"precomp.h\"\r\n#pragma hdrstop\r\n\r\n";
char gszIncInput [] = "#include \"%s\"\r\n\r\n";

char gszStructDef [] = "static STRUCTUREOFFSETSTABLE gsot";
char gszStructDefFmt [] = "%s%s%s";
char gszStructBegin [] = " [] = {\r\n";
char gszStructEnd [] = ")}\r\n};\r\n\r\n";
char gszStructFieldOffsetFmt [] = "    {\"%s\", FIELD_OFFSET(%s, %s)},\r\n";
char gszStructAbsoluteOffsetFmt [] = "    {\"%s\", %#lx},\r\n";
char gszStructLastRecord [] = "    {NULL, sizeof(";

/*
 * Setting the high order bit signals an offset relative to the
 *  previous field offset.
 */
char gszStructRelativeOffsetFmt [] = "    {\"%s\", 0x80000000 + sizeof(%s)},\r\n";
char gszStructArrayRelativeOffsetFmt [] = "    {\"%s\", 0x80000000 + (sizeof(%s) * %s)},\r\n";


char gszTableDef [] = "STRUCTURESTABLE gst [] = {\r\n";
char gszTableEntryFmt [] = "    {\"%s\", sizeof(%s), gsot%s},\r\n";
char gszTableEnd [] = "    {NULL, 0, NULL}\r\n};\r\n\r\n";


#define SOSL(ps) {sizeof(ps) - 1, ps, 0}
STRUCTLIST gpslEmbeddedStructs [] = {
    SOSL("OEMINFO"),
    SOSL("POINT"),
    SOSL("RECT"),
    {0, NULL, 0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\sofile.c ===
/****************************** Module Header ******************************\
* Module Name: sofile.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* soWriteOutputFileHeader
*
\***************************************************************************/
BOOL soWriteOutputFileHeader (PWORKINGFILES pwf)
{
    char ** ppszHeader;

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        return TRUE;
    }

    if (   !soWriteFile(pwf->hfileOutput, "/*********************************************************************\\\r\n")
        || !soWriteFile(pwf->hfileOutput, "* File: %s\r\n", pwf->pszOutputFile)
        || !soWriteFile(pwf->hfileOutput, "* Generated by StructO on %s at %s\r\n", __DATE__, __TIME__)
        || !soWriteFile(pwf->hfileOutput, "\\*********************************************************************/\r\n\r\n")) {

        return FALSE;
   }

   if (pwf->dwOptions & SOWF_INLCLUDEPRECOMPH) {
       if (!soWriteFile(pwf->hfileOutput, gszPrecomph)) {
           return FALSE;
       }
   }

   /*
    * structure definitions for generated tables
    */
   ppszHeader = gpszHeader;
   while (*ppszHeader != NULL) {
       if (!soWriteFile(pwf->hfileOutput, *ppszHeader)
            || !soWriteFile(pwf->hfileOutput, "\r\n")) {

           return FALSE;
       }
       ppszHeader++;
   }


   return TRUE;
}
/*********************************************************************
* soUnmapFile
*
\***************************************************************************/
void soUnmapFile (PFILEMAP pfm)
{
    if (pfm->pmapStart != NULL) {
        UnmapViewOfFile(pfm->pmap);
        pfm->pmapStart = NULL;
        pfm->pmap = NULL;
        pfm->pmapEnd = NULL;
    }

    if (pfm->hmap != NULL) {
        CloseHandle(pfm->hmap);
        pfm->hmap = NULL;
    }

    if (pfm->hfile != INVALID_HANDLE_VALUE) {
        CloseHandle(pfm->hfile);
        pfm->hfile = INVALID_HANDLE_VALUE;
    }
}
/*********************************************************************
* soMapFile
*
\***************************************************************************/
BOOL soMapFile (char * pszFile, PFILEMAP pfm)
{
    DWORD dwFileSize;

    pfm->hfile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (pfm->hfile == INVALID_HANDLE_VALUE) {
        soLogMsg(SOLM_APIERROR, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(pfm->hfile, NULL);
    if (dwFileSize == 0xFFFFFFFF) {
        soLogMsg(SOLM_APIERROR, "GetFileSize");
        goto CleanupAndFail;
    }

    pfm->hmap = CreateFileMapping(pfm->hfile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pfm->hmap == NULL) {
        soLogMsg(SOLM_APIERROR, "CreateFileMapping");
        goto CleanupAndFail;
    }

    pfm->pmapStart = MapViewOfFile(pfm->hmap, FILE_MAP_READ, 0, 0, 0);
    if (pfm->pmapStart == NULL) {
        soLogMsg(SOLM_APIERROR, "MapViewOfFile");
        goto CleanupAndFail;
    }
    pfm->pmap = pfm->pmapStart;
    pfm->pmapEnd = pfm->pmapStart + dwFileSize;

    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soMapFile failed. File: '%s'", pszFile);
    soUnmapFile (pfm);
    return FALSE;
}
/*********************************************************************
* soBuildStructsList
*
\***************************************************************************/
BOOL soBuildStructsList (PWORKINGFILES pwf)
{
    static char gszEOL [] = "\r\n";

    char * pmap, * pStruct;
    FILEMAP fm;
    PSTRUCTLIST psl;
    PVOID pTemp;
    UINT uAlloc, uCount, uSize;


    soLogMsg (SOLM_NOEOL, "Building structs list from %s ...", pwf->pszStructsFile);

    if (!soMapFile (pwf->pszStructsFile, &fm)) {
        goto CleanupAndFail;
    }

    /*
     * Let's guess a number of structures
     */
#define SO_LISTSIZE 20
     uAlloc = SO_LISTSIZE;

    /*
     * Allocate list
     */
    pwf->psl = (PSTRUCTLIST) LocalAlloc(LPTR, sizeof(STRUCTLIST) * (uAlloc + 1));
    if (pwf->psl == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        goto CleanupAndFail;
    }

    /*
     * Load structure names
     */
    pmap = fm.pmapStart;
    psl = pwf->psl;
    uCount = 0;
    while (pmap < fm.pmapEnd) {
        /*
         * Name should start at first column
         */
        if (!soIsIdentifierChar(*pmap)) {
            /*
             * Skip this line
             */
             pmap = soFindTag(pmap, fm.pmapEnd, gszEOL);
             if (pmap == NULL) {
                 break;
             }
             pmap += sizeof(gszEOL) - 1;
             continue;
        }

        /*
         * Find the name
         */
        pStruct = soGetIdentifier (pmap, fm.pmapEnd, &uSize);
        if (pStruct == NULL) {
            soLogMsg(SOLM_ERROR, "soGetIdentifier failed.");
            goto CleanupAndFail;
        }

        /*
         * Grow the list if needed
         */
         if (uCount >= uAlloc) {
             soLogMsg (SOLM_APPEND, ".");
             uAlloc += SO_LISTSIZE;
             pTemp = LocalReAlloc(pwf->psl, sizeof(STRUCTLIST) * (uAlloc + 1), LMEM_MOVEABLE | LMEM_ZEROINIT);
             if (pTemp == NULL) {
                 soLogMsg(SOLM_APIERROR, "LocalReAlloc");
                 goto CleanupAndFail;
             }
             pwf->psl = (PSTRUCTLIST)pTemp;
             psl = pwf->psl + uCount;
         }

        /*
         * Copy it
         */
        psl->uSize = uSize;
        psl->pszName = soCopyTagName (pStruct, uSize);
        if (psl->pszName == NULL) {
            goto CleanupAndFail;
        }

        psl++;
        uCount++;
        pmap = pStruct + uSize;
    }

    /*
     * Make sure it found at least one struct
     */
    if (uCount == 0) {
        soLogMsg(SOLM_ERROR, "Failed to get structure name");
        goto CleanupAndFail;
    }

    /*
     * Let's save some memory
     */
    if (uCount < uAlloc) {
        pTemp = LocalReAlloc(pwf->psl, sizeof(STRUCTLIST) * (uCount + 1), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pTemp == NULL) {
            soLogMsg(SOLM_APIERROR, "LocalReAlloc");
            goto CleanupAndFail;
        }
        pwf->psl = (PSTRUCTLIST)pTemp;
    }

    soUnmapFile (&fm);
    soLogMsg (SOLM_NOLABEL, ".");
    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soBuildStructsList failed. File: '%s'", pwf->pszStructsFile);
    soUnmapFile (&fm);
    /*
     * The process is going away so never mind the heap
     */
    return FALSE;
}
/*********************************************************************
* soIncludeInputFile
*
* Add #include <pszInputFile Name>.<pszIncInputFileExt> to output file
\***************************************************************************/
BOOL soIncludeInputFile (PWORKINGFILES pwf)
{
    BOOL fRet;
    char * pszIncFile, * pDot;
    UINT uInputFileNameSize;

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        return TRUE;
    }

    /*
     * Allocate a buffer to build the name
     */
    uInputFileNameSize = lstrlen(pwf->pszInputFile);
    pszIncFile = (char *) LocalAlloc(LPTR,
                          uInputFileNameSize + lstrlen(pwf->pszIncInputFileExt) + 2);
    if (pszIncFile == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        return FALSE;
    }

    /*
     * Copy file name
     */
    pDot = soFindChar (pwf->pszInputFile, pwf->pszInputFile + uInputFileNameSize, '.');
    if (pDot == NULL) {
        strcpy(pszIncFile, pwf->pszInputFile);
        strcat(pszIncFile, ".");
    } else {
        strncpy(pszIncFile, pwf->pszInputFile, (UINT)(pDot - pwf->pszInputFile + 1));
    }

    /*
     * Copy extension and write it to output file
     */
     strcat(pszIncFile, pwf->pszIncInputFileExt);
     fRet = soWriteFile(pwf->hfileOutput, gszIncInput, pszIncFile);

     LocalFree(pszIncFile);
     return fRet;
}
/*********************************************************************
* soOpenWorkingFiles
*
\***************************************************************************/
BOOL soOpenWorkingFiles (PWORKINGFILES pwf)
{
    char szTempPath [MAX_PATH];
    char szTempFile [MAX_PATH];
    DWORD dwFileSize;

    /*
     * Load the structures list if provided and not built already
     */
    if ((pwf->pszStructsFile != NULL) && (pwf->psl == NULL)) {
        if (!soBuildStructsList(pwf)) {
            goto CleanupAndFail;
        }
    }

    /*
     * Map input file
     */
    if (!soMapFile (pwf->pszInputFile, (PFILEMAP) &(pwf->hfileInput))) {
        goto CleanupAndFail;
    }


    /*
     * Open output file if not open already
     */
    if (pwf->hfileOutput == INVALID_HANDLE_VALUE) {
        pwf->hfileOutput = CreateFile(pwf->pszOutputFile, GENERIC_WRITE, 0, NULL,
                            (pwf->dwOptions & SOWF_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);
        if (pwf->hfileOutput == INVALID_HANDLE_VALUE) {
            soLogMsg(SOLM_APIERROR, "CreateFile");
            soLogMsg(SOLM_ERROR, "Failed to open output file: %s", pwf->pszOutputFile);
            goto CleanupAndFail;
        }

        if (pwf->dwOptions & SOWF_APPENDOUTPUT) {
            if (0xFFFFFFFF == SetFilePointer (pwf->hfileOutput, 0, 0, FILE_END)) {
                soLogMsg(SOLM_APIERROR, "SetFilePointer");
                goto CleanupAndFail;
            }
        } else {
            if (!soWriteOutputFileHeader(pwf)) {
                goto CleanupAndFail;
            }
        }
    }


    /*
     * #include input file if requested
     */
    if (pwf->dwOptions & SOWF_INCLUDEINPUTFILE) {
        if (!soIncludeInputFile(pwf)) {
            goto CleanupAndFail;
        }
    }

    /*
     * Create temp file if not created already
     */
    if (pwf->hfileTemp == INVALID_HANDLE_VALUE) {
        if (!GetTempPath(sizeof(szTempPath) - 1, szTempPath)) {
            soLogMsg(SOLM_APIERROR, "GetTempPath");
            goto CleanupAndFail;
        }

        if (!GetTempFileName(szTempPath, "sot", 0, szTempFile)) {
            soLogMsg(SOLM_APIERROR, "GetTempFileName");
            soLogMsg(SOLM_ERROR, "Failed to get temp file name. szTempPath: %s.", szTempPath);
            goto CleanupAndFail;
        }

        pwf->hfileTemp = CreateFile(szTempFile, GENERIC_WRITE | GENERIC_READ, 0, NULL,
                            CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE,  NULL);
        if (pwf->hfileTemp == INVALID_HANDLE_VALUE) {
            soLogMsg(SOLM_APIERROR, "CreateFile");
            soLogMsg(SOLM_ERROR, "Failed to create temp file: '%s'", szTempFile);
            goto CleanupAndFail;
        }

        if (!soWriteFile(pwf->hfileTemp, "%s", gszTableDef)) {
            goto CleanupAndFail;
        }
    }


    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soOpenWorkingFiles Failed");
    soCloseWorkingFiles (pwf, SOCWF_CLEANUP);
    return FALSE;
}

/*********************************************************************
* soCloseWorkingFiles
*
\***************************************************************************/
BOOL soCloseWorkingFiles (PWORKINGFILES pwf, DWORD dwFlags)
{

   if (dwFlags & SOCWF_CLEANUP) {
       if (pwf->hfileTemp != INVALID_HANDLE_VALUE) {
            CloseHandle(pwf->hfileTemp);
            pwf->hfileTemp = INVALID_HANDLE_VALUE;
       }
       if (pwf->hfileOutput != INVALID_HANDLE_VALUE) {
            CloseHandle(pwf->hfileOutput);
            pwf->hfileOutput = INVALID_HANDLE_VALUE;
       }
       if (pwf->psl != NULL) {
           // Never mind cleanning the heap. The process is going away.
       }
   }

   soUnmapFile((PFILEMAP) &(pwf->hfileInput));

   return TRUE;
}
/*********************************************************************
* soWriteFile
*
\***************************************************************************/
BOOL __cdecl soWriteFile(HANDLE hfile, char *pszfmt, ...)
{
    static char gszbuff [1024+1];

    BOOL fRet = TRUE;
    va_list va;
    DWORD dwWritten;

    va_start(va, pszfmt);
    vsprintf(gszbuff, pszfmt, va);

    if (!WriteFile(hfile, gszbuff, strlen(gszbuff), &dwWritten, NULL)) {
        soLogMsg(SOLM_APIERROR, "WriteFile");
        soLogMsg(SOLM_ERROR, "buffer not written: %s.", gszbuff);
        fRet = FALSE;
    }

    va_end(va);
    return fRet;
}
/*********************************************************************
* soCopyStructuresTable
*
\***************************************************************************/
BOOL soCopyStructuresTable (PWORKINGFILES pwf)
{
    static char szTemp[1024];

    char ** ppszTail;
    DWORD dwFileSize, dwRead, dwWritten;
    PSTRUCTLIST psl;
    UINT uLoops;

    soLogMsg (SOLM_NOEOL, "Writting structs table ...");

    /*
     * If there are no structures, bail.
     * If there was a struct list, fail
     */
    if (pwf->uTablesCount == 0) {
        if (pwf->psl != NULL) {
            soLogMsg(SOLM_ERROR, "None of the structures in '%s' was found", pwf->pszStructsFile);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        soLogMsg (SOLM_DEFAULT, "%d Structures found.", pwf->uTablesCount);
        return TRUE;
    }

   /*
     * Let them know if we didn't find any of the structures in the list
     */
    if (pwf->psl != NULL) {
        psl = pwf->psl;
        while (psl->uSize != 0) {
            if (psl->uCount == 0) {
                soLogMsg(SOLM_WARNING, "Structure not found: %s", psl->pszName);
            }
            psl++;
        }
    }

    if (!soWriteFile(pwf->hfileTemp, "%s", gszTableEnd)) {
        goto MsgAndFail;
    }

   /*
    * Move to beginning of temp file
    */
   dwFileSize = GetFileSize(pwf->hfileTemp, NULL);
   if (dwFileSize == 0xFFFFFFFF) {
       soLogMsg(SOLM_APIERROR, "GetFileSize");
       goto MsgAndFail;
   }

   if (0xFFFFFFFF == SetFilePointer (pwf->hfileTemp, 0, 0, FILE_BEGIN)) {
       soLogMsg(SOLM_APIERROR, "SetFilePointer");
       goto MsgAndFail;
   }

   /*
    * Append temp file to output file
    */
   uLoops = 0;
   while (dwFileSize != 0) {
       if (!ReadFile(pwf->hfileTemp, szTemp, sizeof(szTemp), &dwRead, NULL)) {
           soLogMsg(SOLM_APIERROR, "ReadFile");
           goto MsgAndFail;
       }

       if (!WriteFile(pwf->hfileOutput, szTemp, dwRead, &dwWritten, NULL)) {
           soLogMsg(SOLM_APIERROR, "WriteFile");
           goto MsgAndFail;
       }

       dwFileSize -= dwRead;
       if (++uLoops == 50) {
           uLoops = 0;
           soLogMsg (SOLM_APPEND, ".");
       }
   }
   soLogMsg (SOLM_NOLABEL, ".");

   soLogMsg (SOLM_DEFAULT, "%d Tables generated.", pwf->uTablesCount);

   /*
    * Write file tail (code)
    */
   ppszTail = gpszTail;
    while (*ppszTail != NULL) {
    if (!soWriteFile(pwf->hfileOutput, *ppszTail)
         || !soWriteFile(pwf->hfileOutput, "\r\n")) {

        return FALSE;
    }
    ppszTail++;
}


   return TRUE;

MsgAndFail:
   soLogMsg(SOLM_ERROR, "soCopyStructuresTable failed.");
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\structo.c ===
/****************************** Module Header ******************************\
* Module Name: structo.c
*
* Structure parser - struct field name-offset tabel generator.
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* soProcessParameters
*
\***************************************************************************/
UINT soProcessParameters(int argc, LPSTR argv[], PWORKINGFILES pwf)
{
    char c, *p;
    int  argcParm = argc;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p) {
                switch (toupper(c)) {
                    case 'I':
                        if (pwf->pszIncInputFileExt != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -i parameter");
                            goto PrintHelp;
                        }
                        pwf->dwOptions |= SOWF_INCLUDEINPUTFILE;
                        argc--, argv++;
                        pwf->pszIncInputFileExt = *argv;
                        break;

                    case 'L':
                        pwf->dwOptions |= SOWF_LISTONLY;
                        break;

                    case 'O':
                        if (pwf->pszOutputFile != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -o parameter");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        pwf->pszOutputFile = *argv;
                        break;

                    case 'P':
                        pwf->dwOptions |= SOWF_INLCLUDEPRECOMPH;
                        break;

                    case 'S':
                        if (pwf->pszStructsFile != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -s parameter");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        pwf->pszStructsFile = *argv;
                        break;

                    default:
                        soLogMsg(SOLM_ERROR, "Invalid parameter: %c", c);
                        // Fall through

                    case '?':
                        goto PrintHelp;
                }
            } /* while (c = *++p) */
        } else { /* if switch */
            pwf->pszInputFile = *argv;
            break;
        }
    } /* while (--argc) */

    if ((pwf->pszInputFile == NULL) || (pwf->pszOutputFile == NULL)) {
        goto PrintHelp;
    }

    if ((pwf->dwOptions & SOWF_LISTONLY) && (pwf->pszStructsFile != NULL)) {
        soLogMsg(SOLM_ERROR, "Cannot use -s and -l together ");
        goto PrintHelp;
    }

    return argcParm - argc;

PrintHelp:
    soLogMsg(SOLM_DEFAULT, "Structure Field Name-Offset Table Generator");
    soLogMsg(SOLM_NOLABEL, "Usage: structo [options] <-o OutputFile> InputFile1 ...");
    soLogMsg(SOLM_NOLABEL, "\tInputFile - Preprocessed C header file");
    soLogMsg(SOLM_NOLABEL, "\t[-i ext] #include input file name using extension ext");
    soLogMsg(SOLM_NOLABEL, "\t[-l] Build structure list only");
    soLogMsg(SOLM_NOLABEL, "\t<-o OutputFile> required");
    soLogMsg(SOLM_NOLABEL, "\t[-p] #include \"precomp.h\" and #pragma hdrstop  in output file");
    soLogMsg(SOLM_NOLABEL, "\t[-s StructFile] Struct names text file.");
    return 0;
}
/*********************************************************************
* soGenerateTable
*
\***************************************************************************/
BOOL soGenerateTable (PWORKINGFILES pwf)
{
    char * pTag;
    UINT uLoops;



    if (!soOpenWorkingFiles(pwf)) {
        return FALSE;
    }

    soLogMsg (SOLM_NOEOL, "Processing %s ...", pwf->pszInputFile);

    uLoops = 0;
    while (pTag = soFindTag(pwf->pmap, pwf->pmapEnd, gszStructTag)) {
        pwf->pmap = pTag;
        pTag = soParseStruct (pwf);
        if (pTag == NULL) {
            break;
        }
        pwf->pmap = pTag;
        if (++uLoops == 50) {
            soLogMsg (SOLM_APPEND, ".");
            uLoops = 0;
        }
    }

    soLogMsg (SOLM_NOLABEL, ".");

    soCloseWorkingFiles(pwf, SOCWF_DEFAULT);
    return TRUE;
}
/*********************************************************************
* InitWF
\***************************************************************************/
BOOL InitWF (PWORKINGFILES pwf)
{
    ZeroMemory (pwf, sizeof(WORKINGFILES));
    pwf->hfileInput = INVALID_HANDLE_VALUE ;
    pwf->hfileOutput = INVALID_HANDLE_VALUE ;
    pwf->hfileTemp = INVALID_HANDLE_VALUE ;

    return TRUE;
}
/*********************************************************************
* main
*
\***************************************************************************/
int __cdecl main (int argc, char *argv[])
{
    BOOL fGenerated = TRUE;
    int argcProcessed;
    WORKINGFILES wf;

    InitWF(&wf);

    do {
        argcProcessed = soProcessParameters(argc, argv, &wf);
        if (argcProcessed == 0) {
            break;
        }
        argc -= argcProcessed;
        argv += argcProcessed;

        if (!soGenerateTable(&wf)) {
            fGenerated = FALSE;
            break;
        }

        wf.dwOptions |= SOWF_APPENDOUTPUT;

    } while (argc > 1);

    if (fGenerated && (wf.hfileTemp != INVALID_HANDLE_VALUE)) {
        fGenerated = soCopyStructuresTable (&wf);
        if (fGenerated) {
            soLogMsg (SOLM_DEFAULT, "%s has been succesfully generated.", wf.pszOutputFile);
        }
    }

    soCloseWorkingFiles (&wf, SOCWF_CLEANUP);
    return !fGenerated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\soutil.c ===
/****************************** Module Header ******************************\
* Module Name: soutil.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"
/*********************************************************************
* soLosgMsg
\***************************************************************************/
void __cdecl soLogMsg(DWORD dwFlags, char *pszfmt, ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (!(dwFlags & SOLM_NOLABEL)) {
        if (gfAppending) {
            fprintf(stdout, "\r\n");
        }
        fprintf(stdout, "STRUCTO: ");
    }

    if (dwFlags & SOLM_ERROR) {
        fprintf(stdout, "Error: ");
    } else if (dwFlags & SOLM_WARNING) {
        fprintf(stdout, "Warning: ");
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    if (dwFlags & SOLM_API) {
        soLogMsg (SOLM_NOLABEL | SOLM_NOEOL, " Failed. GetLastError: %d", GetLastError());
    }

    gfAppending = (dwFlags & SOLM_NOEOL);
    if (!gfAppending) {
        fprintf(stdout, "\r\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\suck\suck.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// #define SEE_EM 1

#define MAX_FILENAME_LENGTH       127

#define MAX_TIMEANDSIZE           50        /* mm-dd-yyyy hh-mm-ss */

#define MAX_FILENAME_PER_BLOCK  1000
#define MAX_MEMBLOCKS            100

#define MAX_THREADS               29

#define MAX_COMMAND_LINE        1024
#define MAX_ARGS                  20

// kenhia 15-Mar-1996: add support for -#:<share>
//
// splante 15-Oct-1996: changed support to the "ntbuilds" server
#if defined(_ALPHA_) || defined(_X86_)
    #define PLATFORM_SPECIFIC_SHARES { "ntbuilds", "ntbuilds", "ntbuilds", "ntbuilds", "ntbuilds", NULL }
#endif
#ifndef PLATFORM_SPECIFIC_SHARES
    #pragma message( "WARNING: Platform Specific shares disabled" )
    #define PLATFORM_SPECIFIC_SHARES {NULL}
#endif


typedef struct _filename FILENAME;

typedef union _virtual_pointer {
    FILENAME    *mem_ptr;
    DWORD       disk_ptr;
} VIRTPTR;

struct _filename {
    DWORD       dwStatus;
    DWORD       dwCopy;
    VIRTPTR     fnParent;
    VIRTPTR     fnChild;
    VIRTPTR     fnSibling;
    DWORD       dwFileSizeLow;
    DWORD       dwFileSizeHigh;
    FILETIME    ftFileTime;
    DWORD       dwDATFileSizeLow;
    DWORD       dwDATFileSizeHigh;
    FILETIME    ftDATFileTime;
    DWORD       dwFileNameLen;
    CHAR        cFileName[MAX_FILENAME_LENGTH+1];
};

typedef struct _memblock MEMBLOCK;
struct _memblock {
    HANDLE      hMem;
    LPSTR       lpBase;
};

typedef struct _fileheader {
    VIRTPTR     fnRoot;             // Pointer to root node
} FILEHEADER;


#define SUCK_INI_FILE           ".\\suck.ini"
#define SUCK_DAT_FILE           ".\\suck.dat"

#define DIRECTORY   (DWORD)0x80000000
#define STARTED     (DWORD)0x40000000
#define COPIED      (DWORD)0x20000000

CRITICAL_SECTION cs;
CRITICAL_SECTION pcs;

INT cAvailable = 0;
FILENAME *lpBaseCurrent = NULL;
INT nMemBlocks = 0;
FILENAME *fnRoot = NULL;

LONG nFiles       = 0;
LONG nDirectories = 0;
LONG nDuplicates  = 0;
LONG nStraglers   = 0;

BOOL fCopying            = FALSE;
BOOL fScriptMode         = FALSE;
BOOL fLogTreeDifferences = FALSE;
BOOL fUpdateINIBase      = FALSE;
BOOL fDestroy            = FALSE;
BOOL fUseDAT             = TRUE;

// DavidP 23-Jan-1998: BEGIN Allow multiple levels of quiet
BOOL fQuietMode      = FALSE;
BOOL fProgressMode   = FALSE;
INT  nConsoleWidth   = 0;
CHAR chLineEnd       = '\n';
// DavidP 23-Jan-1998: END Allow multiple levels of quiet

FILE *SuckDATFile = NULL;
#define MAX_EXCLUDES 1024
CHAR gExcludes[MAX_EXCLUDES+1] = { '\0'};

FILETIME ftZero = { 0, 0};


MEMBLOCK mbBlocks[MAX_MEMBLOCKS];

DWORD dwMasks[] = {
    0x00000001,
    0x00000002,
    0x00000004,
    0x00000008,
    0x00000010,
    0x00000020,
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000200,
    0x00000400,
    0x00000800,
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x00010000,
    0x00020000,
    0x00040000,
    0x00080000,
    0x00100000,
    0x00200000,
    0x00400000,
    0x00800000,
    0x01000000,
    0x02000000,
    0x04000000,
    0x08000000,
    0x10000000,
};

CHAR chPath[MAX_THREADS][MAX_PATH];
DWORD dwTotalSizes[MAX_THREADS];

BOOL EverybodyBailOut = FALSE;

BOOL fProblems[MAX_THREADS];

FILENAME *AllocateFileName()
{
    FILENAME    *lpResult;

    /*
    ** Allocate a new FILENAME
    */
    if ( cAvailable == 0 ) {

        mbBlocks[nMemBlocks].hMem = GlobalAlloc( GMEM_FIXED | GMEM_ZEROINIT,
                                                 MAX_FILENAME_PER_BLOCK * sizeof(FILENAME) );
        if ( mbBlocks[nMemBlocks].hMem == (HANDLE)0 ) {
            fprintf(stderr,"Memory Allocation Failed in AllocateFileName\n");
            exit(1);
        }
        mbBlocks[nMemBlocks].lpBase = GlobalLock( mbBlocks[nMemBlocks].hMem );

        lpBaseCurrent = (FILENAME *)mbBlocks[nMemBlocks].lpBase;

        cAvailable = MAX_FILENAME_PER_BLOCK;

        nMemBlocks++;
    }

    lpResult = lpBaseCurrent;

    --cAvailable;

    lpBaseCurrent++;

    return( lpResult );
}

VOID FreeFileNames()
{
    while ( nMemBlocks ) {
        --nMemBlocks;
        GlobalUnlock( mbBlocks[nMemBlocks].hMem );
        GlobalFree( mbBlocks[nMemBlocks].hMem );
    }
}

VOID
AddFile(
       FILENAME            *fn,
       LPWIN32_FIND_DATA   lpwfd,
       DWORD               mask
       )
{
    CHAR        *pdest;
    CHAR        *psrc;
    INT         count;
    INT         maximum;
    FILENAME    *fnCurrent;
    FILENAME    *fnChild;
    DWORD       dwFileNameLen;
    CHAR        NewName[MAX_FILENAME_LENGTH+1];
    FILENAME    *fnChildOriginally;

    if ( *lpwfd->cFileName == '.' ) {
        return;
    }

    dwFileNameLen = strlen(lpwfd->cFileName);
    if (dwFileNameLen > MAX_FILENAME_LENGTH) {
        fprintf(stderr, "File name %s too long (%u > %u), complain to BobDay\n",
                lpwfd->cFileName, dwFileNameLen, MAX_FILENAME_LENGTH);
        return;
    }

    strncpy( NewName, lpwfd->cFileName, sizeof (NewName) / sizeof (NewName[0]) );
    NewName [(sizeof (NewName) / sizeof (NewName[0])) - 1] = 0;

    fnChild = fn->fnChild.mem_ptr;
    fnChildOriginally = fnChild;

    while ( fnChild ) {
        if ( fnChild->dwFileNameLen == dwFileNameLen &&
             !strcmp(NewName, fnChild->cFileName)
           ) {
            fnChild->dwStatus |= mask;           // Atomic instruction
            if ( fnChild->ftFileTime.dwLowDateTime == ftZero.dwLowDateTime
                 && fnChild->ftFileTime.dwHighDateTime == ftZero.dwHighDateTime ) {
                EnterCriticalSection( &cs );
                fnChild->dwFileSizeLow     = lpwfd->nFileSizeLow;
                fnChild->dwFileSizeHigh    = lpwfd->nFileSizeHigh;
                fnChild->ftFileTime        = lpwfd->ftLastWriteTime;
                LeaveCriticalSection( &cs );
            }
            nDuplicates++;
            return;
        }

        fnChild = fnChild->fnSibling.mem_ptr;
    }

    // Probably not there...  Enter the critical section now to prove it

    EnterCriticalSection( &cs );

    // Most common case, nobody has changed this directory at all.

    if ( fn->fnChild.mem_ptr != fnChildOriginally ) {

        // Otherwise, make another scan inside the critical section.

        fnChild = fn->fnChild.mem_ptr;

        while ( fnChild ) {
            if ( fnChild->dwFileNameLen == dwFileNameLen &&
                 !strcmp(NewName, fnChild->cFileName)
               ) {
                fnChild->dwStatus |= mask;           // Atomic instruction
                nDuplicates++;
                LeaveCriticalSection( &cs );
                return;
            }

            fnChild = fnChild->fnSibling.mem_ptr;
        }

    }

    fnCurrent = AllocateFileName();

    strcpy( fnCurrent->cFileName, NewName );
    fnCurrent->dwFileNameLen     = dwFileNameLen;
    fnCurrent->dwFileSizeLow     = lpwfd->nFileSizeLow;
    fnCurrent->dwFileSizeHigh    = lpwfd->nFileSizeHigh;
    fnCurrent->ftFileTime        = lpwfd->ftLastWriteTime;
    fnCurrent->dwDATFileSizeLow  = 0;
    fnCurrent->dwDATFileSizeHigh = 0;
    fnCurrent->ftDATFileTime     = ftZero;

    fnCurrent->dwCopy         = 0;

    fnCurrent->fnParent.mem_ptr  = fn;
    fnCurrent->fnChild.mem_ptr   = NULL;

    fnCurrent->fnSibling.mem_ptr = fn->fnChild.mem_ptr;
    fn->fnChild.mem_ptr = fnCurrent;

    if ( lpwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        fnCurrent->dwStatus = DIRECTORY;
        nDirectories++;
    } else {
        fnCurrent->dwStatus = 0;
        nFiles++;
    }
    fnCurrent->dwStatus |= mask;

#ifdef SEE_EM
    { char text[MAX_FILENAME_LENGTH+1];
        memcpy( text, fnCurrent->cFileName, MAX_FILENAME_LENGTH );
        text[MAX_FILENAME_LENGTH] = '\0';

        if ( fnCurrent->dwStatus & DIRECTORY ) {
            printf("Munged  DirName = %08lX:[%s]\n", fnCurrent, text );
        } else {
            printf("Munged FileName = %08lX:[%s]\n", fnCurrent, text );
        }
    }
#endif
    LeaveCriticalSection( &cs );

}

BOOL
Excluded(
        WIN32_FIND_DATA *pwfd
        )
{
    CHAR *pszScan = gExcludes;
    while (*pszScan) {
        if ((pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            _stricmp(pszScan, pwfd->cFileName) == 0) {
            return(TRUE);
        }
        pszScan = strchr(pszScan, 0) + 1;
    }
    return(FALSE);
}

VOID
EnumFiles(
         LPSTR           lpSearch,
         FILENAME        *fnParent,
         DWORD           mask,
         UINT            iThread
         )
{
    WIN32_FIND_DATA wfd;
    HANDLE          hFind;
    CHAR            NewName[MAX_PATH];
    CHAR            *pch;
    CHAR            *pchSpot;
    BOOL            f;
    FILENAME        *fnChild;
    DWORD           rc;

#ifdef SEE_EM
    printf("Enuming <%s>\n", lpSearch );
#endif

    strcpy( NewName, lpSearch );
    pch = NewName + strlen(NewName) - 1;

    if ( *pch != '\\' && *pch != '/' && *pch != ':' ) {
        *++pch = '\\';
    }
    strcpy( ++pch, "*.*" );
    pchSpot = pch;


    do {
        hFind = FindFirstFile( NewName, &wfd );

        if ( hFind != INVALID_HANDLE_VALUE ) {
            break;
        }

        rc = GetLastError();
        switch ( rc ) {
            default:
                printf("%s: Error: GetLastError = %08ld  What does it mean?\n", NewName, rc );
            case ERROR_SHARING_PAUSED:
            case ERROR_BAD_NETPATH:
            case ERROR_BAD_NET_NAME:
            case ERROR_NO_LOGON_SERVERS:
            case ERROR_VC_DISCONNECTED:
            case ERROR_UNEXP_NET_ERR:
                if ( !fProblems[iThread] ) {
                    printf("Error accesing %s, switching to silent retry\n", lpSearch );
                    fProblems[iThread] = TRUE;
                }
                if (EverybodyBailOut) {
                    return;
                }
                Sleep( 10000 );      // Wait for 10 seconds
                break;
                break;
        }

    } while ( TRUE );

    if ( hFind != NULL ) {
        do {
            if (!Excluded(&wfd))
                AddFile( fnParent, &wfd, mask );
            f = FindNextFile( hFind, &wfd );
        } while ( f );
    }

    FindClose( hFind );

    fnChild = fnParent->fnChild.mem_ptr;
    while ( fnChild ) {

        /*
        ** If its a directory and it was one of "our" directories, then enum it
        */
        if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY
             && (fnChild->dwStatus & mask) == mask ) {
            pch = pchSpot;

            strcpy( pch, fnChild->cFileName );
#ifdef SEE_EM
            printf("NewName = <%s>\n", NewName );
#endif
            EnumFiles( NewName, fnChild, mask, iThread );
        }
        fnChild = fnChild->fnSibling.mem_ptr;
    }

}

BOOL
CopyCheck(
         CHAR        *pchPath,
         FILENAME    *fnCurrent
         )
{
    WORD        wFatDate;
    WORD        wFatTime;
    WORD        wDATFatDate;
    WORD        wDATFatTime;
    BOOL        b;

    if ( fnCurrent->dwDATFileSizeLow != fnCurrent->dwFileSizeLow ) {
        return( TRUE );
    }
    if ( fnCurrent->dwDATFileSizeHigh != fnCurrent->dwFileSizeHigh ) {
        return( TRUE );
    }
    b = FileTimeToDosDateTime( &fnCurrent->ftDATFileTime, &wDATFatDate, &wDATFatTime );
    if ( !b ) {
        return( TRUE );
    }
    b = FileTimeToDosDateTime( &fnCurrent->ftFileTime, &wFatDate, &wFatTime );
    if ( !b ) {
        return( TRUE );
    }

    if ( wDATFatTime != wFatTime ) {
        return( TRUE );
    }
    if ( wDATFatDate != wFatDate ) {
        return( TRUE );
    }
    return( FALSE );
}

DWORD
CopyThem(
        FILENAME    *fnDir,
        CHAR        *chDest,
        CHAR        *chSrc,
        DWORD       nThread,
        DWORD       mask,
        BOOL        f1stPass
        )
{
    CHAR        *pch;
    CHAR        *pchSpotDest;
    CHAR        *pchSpotSrc;
    CHAR        chTemp[MAX_PATH];
    CHAR        chTempName[20];
    BOOL        fCopyIt;
    FILENAME    *fnChild;
    BOOL        fCopy;
    BOOL        fCopied;
    BOOL        fRenamed;
    BOOL        fDeleted;
    BOOL        fAttrib;
    DWORD       dwCount;
    DWORD       dwAttribs;
    DWORD       dw;

    fnChild = fnDir->fnChild.mem_ptr;

    pchSpotDest = chDest + strlen(chDest);
    pchSpotSrc  = chSrc  + strlen(chSrc);

    dwCount = 0;

    while ( fnChild && !EverybodyBailOut) {

        fCopyIt = TRUE;

        if ( f1stPass ) {
            if ( (fnChild->dwStatus & STARTED) == STARTED ) {
                fCopyIt = FALSE;
            }
        } else {
            if ( (fnChild->dwStatus & COPIED) == COPIED ) {
                fCopyIt = FALSE;
            }
        }

        //
        // If the file doesn't exist on this thread's source location, then
        // don't try to copy it.
        //
        if ( (fnChild->dwStatus & mask) != mask ) {
            fCopyIt = FALSE;
        }

        if ( fCopyIt ) {
            //            if ( f1stPass && (fnChild->dwStatus & STARTED) == STARTED ) {
            //                fCopyIt = FALSE;
            //            } else {
            //                fnChild->dwStatus |= STARTED;
            //            }
            //            LeaveCriticalSection( &pcs );
        }

        if ( fCopyIt ) {
            pch = pchSpotDest;

            strcpy( pch, fnChild->cFileName );
            strcpy( pchSpotSrc, pchSpotDest );

            if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY ) {
                CreateDirectory( chDest, NULL );
                strcat( pchSpotDest, "\\" );
                strcat( pchSpotSrc, "\\" );
                dwCount += CopyThem( fnChild, chDest, chSrc, nThread, mask, f1stPass );
            } else {
                fnChild->dwStatus |= STARTED;

                strcpy( chTemp, chDest );
                *(chTemp+(pchSpotDest-chDest)) = '\0';

                sprintf( chTempName, "suck%02lX.tmp", mask );
                strcat( chTemp, chTempName );

                //
                // Check if we need to copy this file
                //
                fCopy = CopyCheck( chDest, fnChild );

                if ( fScriptMode ) {
                    dwCount++;
                    EnterCriticalSection( &pcs );
                    fnChild->dwStatus |= COPIED;
                    if ( fCopy ) {
                        if ( !fQuietMode ) {
                            printf("copy %s %s\n", chSrc, chDest );
                        }
                        dwTotalSizes[nThread-1] += fnChild->dwFileSizeLow;
                    } else {
                        if ( !fQuietMode ) {
                            printf("rem copy %s %s\n", chSrc, chDest );
                        }
                    }
                    LeaveCriticalSection( &pcs );
                } else {
                    dwCount++;

                    if ( fCopy ) {

                        dwAttribs = GetFileAttributes( chTemp );
                        if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                            dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                            fAttrib = SetFileAttributes( chTemp, dwAttribs );
                        }
                        fCopied = CopyFile( chSrc, chTemp, FALSE );

                        if ( !fCopying ) {
                            EnterCriticalSection( &pcs );
                            if ( !fCopying ) {
                                fCopying = TRUE;
                                printf("Copying files...\n" );
                            }
                            LeaveCriticalSection( &pcs );
                        }

                        if ( !fCopied ) {
                            dw = GetLastError();
                            printf("%s => %s\t[COPY ERROR %08lX]\n", chSrc, chTemp, dw );

                            dwAttribs = GetFileAttributes( chTemp );
                            if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                fAttrib = SetFileAttributes( chTemp, dwAttribs );
                            }
                            DeleteFile( chTemp );

                            switch ( dw ) {
                                case ERROR_BAD_NETPATH:
                                case ERROR_BAD_NET_NAME:
                                    if ( !fProblems[nThread-1] ) {
                                        printf("Error accesing %s, switching to silent attempts\n", chSrc );
                                        fProblems[nThread-1] = TRUE;
                                    }
                                    Sleep( 10000 );      // Wait for 10 seconds
                                    break;
                                default:
                                    break;
                            }

                        } else {

                            EnterCriticalSection( &pcs );

                            if ( (fnChild->dwStatus & COPIED) == COPIED ) {
                                //
                                // Copy was done by somebody else
                                //
                                dwAttribs = GetFileAttributes( chTemp );
                                if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                    dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                    fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                }
                                fDeleted = DeleteFile( chTemp );

                            } else {
                                //
                                // Copy was done by us, attempt rename
                                //
                                fAttrib = TRUE;
                                if ( fDestroy ) {
                                    dwAttribs = GetFileAttributes( chDest );
                                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                        fAttrib = SetFileAttributes( chDest, dwAttribs );
                                    }
                                }
                                if ( !fAttrib ) {
                                    dw = GetLastError();
                                    printf("%s => %s\t[ATTRIBUTE CHANGE ERROR %08lX(%s)\n", chSrc, chDest, dw, chDest );
                                    dwAttribs = GetFileAttributes( chTemp );
                                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                        fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                    }
                                    fDeleted = DeleteFile( chTemp );
                                } else {
                                    fDeleted = DeleteFile( chDest );
                                    if ( !fDeleted ) {
                                        dw = GetLastError();
                                        fnChild->dwStatus |= COPIED;
                                    }

                                    if ( fDeleted || dw == ERROR_FILE_NOT_FOUND ) {

                                        fRenamed = MoveFile( chTemp, chDest );

                                        if ( fRenamed ) {
                                            fnChild->dwStatus |= COPIED;
                                            if ( !fQuietMode ) {
                                                // DavidP 23-Jan-1998: Allow multiple levels of quiet
                                                printf("%*s\r%s => %s\t[OK]%c", nConsoleWidth, "", chSrc, chDest, chLineEnd );
                                            }
                                            dwTotalSizes[nThread-1] += fnChild->dwFileSizeLow;
                                        } else {
                                            dw = GetLastError();
                                            printf("%s => %s\t[RENAME ERROR %08lX (%s)]\n", chSrc, chDest, dw, chTemp );
                                            dwAttribs = GetFileAttributes( chTemp );
                                            if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                                dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                                fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                            }
                                            fDeleted = DeleteFile( chTemp );
                                        }
                                    } else {
                                        dw = GetLastError();
                                        printf("%s => %s\t[DELETE ERROR %08lX (%s)]\n", chSrc, chDest, dw, chDest );
                                        dwAttribs = GetFileAttributes( chTemp );
                                        if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                            dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                            fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                        }
                                        fDeleted = DeleteFile( chTemp );
                                    }
                                }
                            }
                            LeaveCriticalSection( &pcs );
                        }
                    } else {
                        EnterCriticalSection( &pcs );
                        if ( !fCopying ) {
                            fCopying = TRUE;
                            printf("Copying files...\n" );
                        }
                        fnChild->dwStatus |= COPIED;
                        if ( !fQuietMode ) {
                            // DavidP 23-Jan-1998: Allow multiple levels of quiet
                            // printf("%*s\r%s => %s\t[OK]%c", nConsoleWidth, "", chSrc, chDest, chLineEnd );
                        }
                        LeaveCriticalSection( &pcs );
                    }
                }
            }

            *pchSpotDest = '\0';
            *pchSpotSrc  = '\0';
        }

        fnChild = fnChild->fnSibling.mem_ptr;
    }
    return( dwCount );
}

DWORD
WINAPI
ThreadFunction(
              LPVOID  lpParameter
              )
{
    LPSTR           lpSearch;
    DWORD           mask;
    DWORD           dw;
    CHAR            chDest[MAX_PATH];
    CHAR            chSrc[MAX_PATH];
    DWORD           dwCount;

    dw = (DWORD)(DWORD_PTR)lpParameter;

    lpSearch = chPath[dw];
    mask = dwMasks[dw-1];

    EnumFiles( lpSearch, fnRoot, mask, dw-1 );

    strcpy( chDest, chPath[0] );
    strcpy( chSrc, chPath[dw] );

    CopyThem( fnRoot, chDest, chSrc, dw, mask, TRUE );

    strcpy( chDest, chPath[0] );
    strcpy( chSrc, chPath[dw] );

    do {
        dwCount = CopyThem( fnRoot, chDest, chSrc, dw, mask, FALSE );
    } while ( dwCount != 0 && !EverybodyBailOut);

    EverybodyBailOut = TRUE;
    return( 0 );
}


VOID
EnumStraglers(
             LPSTR       lpPath,
             FILENAME    *fn,
             DWORD       dwTotalMask
             )
{
    FILENAME    *fnChild;
    CHAR        NewName[MAX_PATH];
    CHAR        *pch;
    CHAR        *pchSpot;

    pchSpot = lpPath + strlen(lpPath);

    fnChild = fn->fnChild.mem_ptr;
    while ( fnChild ) {

        pch = pchSpot;

        strcpy( pch, fnChild->cFileName );
        if ( (fnChild->dwStatus & dwTotalMask) != dwTotalMask ) {
            if ( fLogTreeDifferences ) {
                printf( "File %s is not on all source locations\n", lpPath );
            }
            nStraglers++;
        }
        if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY ) {
            strcat( pch, "\\" );
            EnumStraglers( lpPath, fnChild, dwTotalMask );
        }
        fnChild = fnChild->fnSibling.mem_ptr;
    }
}

VOID
DumpStraglers(
             DWORD       dwTotalMask
             )
{
    CHAR        cPath[MAX_PATH];

    strcpy( cPath, "<SRC>\\" );

    EnumStraglers( cPath, fnRoot, dwTotalMask );

    if ( nStraglers != 0 ) {
        printf("Files found on some source locations, but not on others\n");
        printf("Run SUCK with -x option to enumerate differences.\n");
    }
}

void
EnumDATFileData(
               FILENAME    *fnParent,
               DWORD       dwDiskPtr
               )
{
    FILENAME    fnDiskName;
    FILENAME    *fnChild = &fnDiskName;
    FILENAME    *fnCurrent;
    int         iSeek;
    int         iCount;

    //
    // Read in this level from the DAT file
    //
    while ( dwDiskPtr != 0 ) {

        // Seek to this entry

        iSeek = fseek( SuckDATFile, dwDiskPtr, SEEK_SET );

        if ( iSeek != 0 ) {
            printf("SUCK.DAT seek error, remove and restart\n");
            exit(3);
        }

        // Read in this entry

        iCount = fread( (void *)fnChild, sizeof(FILENAME), 1, SuckDATFile );
        if ( iCount != 1 ) {
            printf("SUCK.DAT read error, remove and restart\n");
            exit(4);
        }

#ifdef SEE_EM
        printf("Reading record [%s], at %08lX Child %08lX Sib %08lX\n", fnChild->cFileName, dwDiskPtr, fnChild->fnChild.disk_ptr, fnChild->fnSibling.disk_ptr );
        printf("Size = %d\n", fnChild->dwFileSizeLow );
#endif

        //
        // Add this file node to the tree
        //

        fnCurrent = AllocateFileName();


        fnCurrent->dwStatus          = fnChild->dwStatus;
        fnCurrent->dwCopy            = 0;

        fnCurrent->fnParent.mem_ptr  = fnParent;
        fnCurrent->fnChild.mem_ptr   = NULL;

        fnCurrent->fnSibling.mem_ptr = fnParent->fnChild.mem_ptr;

        fnCurrent->dwFileSizeLow     = 0;
        fnCurrent->dwFileSizeHigh    = 0;
        fnCurrent->ftFileTime        = ftZero;
        fnCurrent->dwDATFileSizeLow  = fnChild->dwFileSizeLow;
        fnCurrent->dwDATFileSizeHigh = fnChild->dwFileSizeHigh;
        fnCurrent->ftDATFileTime     = fnChild->ftFileTime;

        fnCurrent->dwFileNameLen     = fnChild->dwFileNameLen;
        strcpy( fnCurrent->cFileName, fnChild->cFileName );

        fnParent->fnChild.mem_ptr = fnCurrent;

        if ( (fnCurrent->dwStatus & DIRECTORY) == DIRECTORY ) {
            nDirectories++;
            //
            // Load this directories children
            //
            EnumDATFileData( fnCurrent, fnChild->fnChild.disk_ptr );
        } else {
            fnCurrent->dwStatus = 0;
            nFiles++;
        }

        // Move to next sibling at this level

        dwDiskPtr = fnChild->fnSibling.disk_ptr;
    }
}

void
LoadFileTimesAndSizes(
                     BOOL        fUseSuckDATFile
                     )
{
    CHAR        cPath[MAX_PATH];
    FILEHEADER  fileheader;
    int         iCount;

    //
    // Initialize the tree root
    //
    fnRoot = AllocateFileName();

    fnRoot->fnParent.mem_ptr  = NULL;
    fnRoot->fnChild.mem_ptr   = NULL;
    fnRoot->fnSibling.mem_ptr = NULL;
    strcpy( fnRoot->cFileName, "<ROOT>" );

    // Look for SUCK.DAT

    if ( fUseSuckDATFile ) {
        SuckDATFile = fopen( SUCK_DAT_FILE, "rb" );
    } else {
        SuckDATFile = NULL;
    }

    if ( SuckDATFile != NULL ) {
        //
        // If file exists, then load the data from it.
        //
        printf("Loading Previous Statistics...\n");

        iCount = fread( &fileheader, sizeof(fileheader), 1, SuckDATFile );

        if ( iCount != 1 ) {
            printf("Error reading SUCK.DAT file, remove and restart\n");
            exit(1);
        }

        EnumDATFileData( fnRoot, fileheader.fnRoot.disk_ptr );

        fclose( SuckDATFile );

    }
}

int
EnumFileTimesAndSizes(
                     DWORD       dwDiskPtr,
                     FILENAME    *fn
                     )
{
    FILENAME    fnDiskName;
    FILENAME    *fnChild = &fnDiskName;
    FILENAME    *fnCurrent;
    VIRTPTR     fnChildPtr;
    VIRTPTR     fnSiblingPtr;
    int         nRecords;
    int         nChildren;
    int         iCount;

    //
    // The 1st guy in the list will be at the end of the list
    //
    fnSiblingPtr.disk_ptr = 0;
    nRecords = 0;

    fnCurrent = fn->fnChild.mem_ptr;
    while ( fnCurrent ) {

        *fnChild = *fnCurrent;

        if ( (fnCurrent->dwStatus & DIRECTORY) == DIRECTORY ) {
            nChildren = EnumFileTimesAndSizes( dwDiskPtr, fnCurrent );
            nRecords += nChildren;
            dwDiskPtr += nChildren * sizeof(FILENAME);
            if ( nRecords == 0 ) {
                fnChildPtr.disk_ptr = 0;
            } else {
                // Point to previous one, it was our child
                fnChildPtr.disk_ptr = dwDiskPtr - sizeof(FILENAME);
            }
        } else {
            fnChildPtr.disk_ptr = 0;
        }
        fnChild->fnChild.disk_ptr = fnChildPtr.disk_ptr;

        fnChild->fnSibling.disk_ptr = fnSiblingPtr.disk_ptr;
        fnSiblingPtr.disk_ptr = dwDiskPtr;

#ifdef SEE_EM
        printf("Writing record [%s], at %08lX Child %08lX Sib %08lX\n", fnChild->cFileName, dwDiskPtr, fnChild->fnChild.disk_ptr, fnChild->fnSibling.disk_ptr );
        printf("Size = %d\n", fnChild->dwFileSizeLow );
#endif

        iCount = fwrite( fnChild, sizeof(FILENAME), 1, SuckDATFile );
        if ( iCount != 1 ) {
            printf("SUCK.DAT error writing data\n");
            exit(1);

        }
        dwDiskPtr += sizeof(FILENAME);
        nRecords++;

        fnCurrent = fnCurrent->fnSibling.mem_ptr;
    }
    return( nRecords );
}

VOID
UpdateFileTimesAndSizes(
                       VOID
                       )
{
    CHAR        cPath[MAX_PATH];
    FILEHEADER  fileheader;
    int         iSeek;
    int         iCount;
    DWORD       dwDiskPtr;
    int         nChildren;

    printf("Updating Statistics...\n");

    SuckDATFile = fopen( SUCK_DAT_FILE, "wb+" );
    if ( SuckDATFile == NULL ) {
        printf( "Error creating file '%s', update aborted\n", SUCK_DAT_FILE );
        return;
    }

    fileheader.fnRoot.disk_ptr = 0;             // Temporary...

    iCount = fwrite( &fileheader, sizeof(fileheader), 1, SuckDATFile );
    if ( iCount != 1 ) {
        printf("SUCK.DAT error writing header\n");
        exit(1);
    }

    dwDiskPtr = sizeof(fileheader);

    nChildren = EnumFileTimesAndSizes( dwDiskPtr, fnRoot );
    dwDiskPtr += nChildren * sizeof(FILENAME);

    if ( nChildren == 0 ) {
        dwDiskPtr = 0;
    } else {
        dwDiskPtr -= sizeof(FILENAME);
    }

    fileheader.fnRoot.disk_ptr = dwDiskPtr;     // Now update for real...

    iSeek = fseek( SuckDATFile, 0, SEEK_SET );

    if ( iSeek != 0 ) {
        printf("SUCK.DAT error seeking to write header\n");
        exit(3);
    }

    iCount = fwrite( &fileheader, sizeof(fileheader), 1, SuckDATFile );
    if ( iCount != 1 ) {
        printf("SUCK.DAT error writing header\n");
        exit(1);
    }

    fclose( SuckDATFile );
}

CHAR *NewArgv[MAX_ARGS];
CHAR chCommand[MAX_COMMAND_LINE+1];

VOID
LookForLastCommand(
                  INT     *pargc,
                  CHAR    **pargv[]
                  )
{
    CHAR    *pSpace;
    CHAR    *pNextArg;

    GetPrivateProfileString("Init", "LastCommand", "", chCommand, MAX_COMMAND_LINE, SUCK_INI_FILE );
    if ( strlen(chCommand) == 0 ) {
        return;
    }

    pNextArg = chCommand;
    *pargv = NewArgv;
    (*pargv)[1] = "";

    *pargc = 1;

    do {
        (*pargc)++;
        pSpace = strchr( pNextArg, ' ' );
        if ( pSpace ) {
            *pSpace = '\0';
        }

        (*pargv)[(*pargc)-1] = pNextArg;
        pNextArg = pSpace + 1;
    } while ( pSpace != NULL );
}

VOID
UpdateLastCommandLine(
                     INT     argc,
                     CHAR    *argv[]
                     )
{
    CHAR    chLastCommand[MAX_COMMAND_LINE+1];
    INT     nArg;

    chLastCommand[0] = '\0';

    nArg = 1;

    while ( nArg < argc ) {
        strcat( chLastCommand, argv[nArg] );
        nArg++;
        if ( nArg != argc ) {
            strcat( chLastCommand, " " );
        }
    }
    WritePrivateProfileString("Init", "LastCommand", chLastCommand, SUCK_INI_FILE );
}


VOID
ReplaceEnvironmentStrings(
                         CHAR    *pText
                         )
{
    CHAR    *pOpenPercent;
    CHAR    *pClosePercent;
    CHAR    chBuffer[MAX_PATH];
    CHAR    *pSrc;
    CHAR    *pEnvString;

    chBuffer[0] = '\0';
    pSrc = pText;

    do {
        pOpenPercent = strchr( pSrc, '%' );
        if ( pOpenPercent == NULL ) {
            strcat( chBuffer, pSrc );
            break;
        }
        pEnvString = pOpenPercent + 1;
        pClosePercent = strchr( pEnvString, '%' );
        if ( pClosePercent == NULL ) {
            strcat( chBuffer, pSrc );
            break;
        }
        if ( pEnvString == pClosePercent ) {
            strcat( chBuffer, "%" );
        } else {
            *pOpenPercent  = '\0';
            *pClosePercent = '\0';

            strcat( chBuffer, pSrc );
            GetEnvironmentVariable( pEnvString,
                                    chBuffer + strlen(chBuffer),
                                    MAX_PATH );
        }
        pSrc = pClosePercent+1;
    } while ( TRUE );

    strcpy( pText, chBuffer );
}


DWORD
DiffTimes(
         SYSTEMTIME *start,
         SYSTEMTIME *end
         )
{
    DWORD nSecStart;
    DWORD nSecEnd;

    nSecStart = start->wHour*60*60 +
                start->wMinute*60 +
                start->wSecond;

    nSecEnd = end->wHour*60*60 +
              end->wMinute*60 +
              end->wSecond;

    return nSecEnd - nSecStart;
}

VOID
Usage(
     VOID
     )
{
    fputs("SUCK: Usage  suck [-options] <dest> <src> [<src>...]\n"
          "      (maximum of 29 src directories)\n"
          "\n"
          "  where options are:   x - List source differences (if any)\n"
          "                       s - Produce script, don't copy\n"
          "                       q - Quiet mode (no stdout)\n"
          "                       p - Display progress on one line\n"
          "                         (cannot be used with -q or -s)\n"
          "                       z - Copy over readonly files\n"
          "                       e - Exclude directory\n"
          "                         e.g. -eidw -emstools\n"
          , stderr);
}

VOID
ArgError(
        INT    nArg,
        CHAR * pszArg
        )
{
    fprintf( stderr, "\nError in arg #%d - '%s'\n\n", nArg, pszArg );
    Usage();
    exit(1);
}

int
__cdecl
main(
    int         argc,
    char        *argv[]
    )
{
    HANDLE      hThreads[MAX_THREADS];
    DWORD       dwThreadId;
    DWORD       nThreads;
    INT         nArg;
    DWORD       nPaths;
    CHAR        *pch;
    CHAR        *pch2;
    DWORD       dwTotalMask;
    OFSTRUCT    ofs;
    BOOL        fUpdateCommandLine = TRUE;
    CHAR *      pchNextExclude = gExcludes;
    SYSTEMTIME  stStart;
    SYSTEMTIME  stEnd;
    DWORD       nSeconds;
    DWORD       nMinutes;
    // kenhia 15-Mar-1996: add support for -#:<share>
    CHAR *      PlatformPoundArray[] = PLATFORM_SPECIFIC_SHARES;
    DWORD       nPound = 0;
    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    DWORD       dwConsoleMode      = 0;
    BOOL        fWasConsoleModeSet = FALSE;
    HANDLE      hStdOut            = NULL;

    if ( argc < 2 ) {
        LookForLastCommand( &argc, &argv );
        fUpdateCommandLine = FALSE;
    }

    if ( argc < 3 ) {
        Usage();
        exit(1);
    }

    nArg = 1;
    nPaths = 0;

    while ( nArg < argc ) {

        pch = argv[nArg];

        if ( *pch == '-' ) {
            BOOL fExitSwitchLoop = FALSE;
            pch++;
            while ( *pch && !fExitSwitchLoop) {
                switch ( *pch ) {
                    case 's':
                        // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fProgressMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fScriptMode = TRUE;
                        break;
                    case 'q':
                        // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fProgressMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fQuietMode = TRUE;
                        break;
                    case 'p': // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fQuietMode || fScriptMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fProgressMode = TRUE;
                        chLineEnd = '\r';
                        break;
                    case 'x':
                        fLogTreeDifferences = TRUE;
                        break;
                    case 'y':
                        fUpdateINIBase = TRUE;
                        break;
                    case 'z':
                        fDestroy = TRUE;
                        break;
                    case 'e':
                        if ( pchNextExclude - gExcludes + strlen(++pch) + 2 > MAX_EXCLUDES ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        strcpy(pchNextExclude, pch);
                        pchNextExclude += strlen(pchNextExclude)+1;
                        *pchNextExclude = 0;
                        fExitSwitchLoop = TRUE;
                        break;

                        // kenhia 15-Mar-1996: add support for -#:<share>
                    case '#':
                        pch++;
                        if ( *pch != ':' ) {
                            Usage();
                            exit(1);
                        }
                        while ( PlatformPoundArray[nPound] ) {
                            if ( nPaths >= MAX_THREADS ) {
                                Usage();
                                exit(1);
                            }
                            strcpy( chPath[nPaths], "\\\\" );
                            strcat( chPath[nPaths], PlatformPoundArray[nPound] );
                            strcat( chPath[nPaths], "\\" );
                            strcat( chPath[nPaths], pch+1 );

                            pch2 = chPath[nPaths] + strlen(chPath[nPaths]) - 1;
                            if ( *pch2 != '\\' && *pch2 != '/' && *pch2 != ':' ) {
                                *++pch2 = '\\';
                                *++pch2 = '\0';
                            }

                            ReplaceEnvironmentStrings( chPath[nPaths] );

                            nPound++;
                            nPaths++;
                        }
                        fExitSwitchLoop = TRUE;
                        break;

                    default:
                        Usage();
                        exit(1);
                }
                pch++;
            }
        } else {
            if ( nPaths >= MAX_THREADS ) {
                Usage();
                exit(1);
            }

            strcpy( chPath[nPaths], argv[nArg] );

            pch = chPath[nPaths] + strlen(chPath[nPaths]) - 1;

            if ( *pch != '\\' && *pch != '/' && *pch != ':' ) {
                *++pch = '\\';
                *++pch = '\0';
            }

            ReplaceEnvironmentStrings( chPath[nPaths] );

            nPaths++;
        }
        nArg++;
    }

    nThreads = --nPaths;

    if ( nThreads == 0 ) {
        Usage();
        exit(1);
    }

    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    if ( fProgressMode ) {
        hStdOut = GetStdHandle( STD_OUTPUT_HANDLE );
        if ( hStdOut != INVALID_HANDLE_VALUE ) {
            CONSOLE_SCREEN_BUFFER_INFO csbi;
            if ( GetConsoleScreenBufferInfo( hStdOut, &csbi ) ) {
                nConsoleWidth = csbi.dwSize.X - 1;
            }
        }
        fWasConsoleModeSet = GetConsoleMode( hStdOut, &dwConsoleMode );
        if ( fWasConsoleModeSet ) {
            SetConsoleMode( hStdOut, dwConsoleMode & ~ENABLE_WRAP_AT_EOL_OUTPUT );
        }
    }

    InitializeCriticalSection( &cs );
    InitializeCriticalSection( &pcs );

    printf("Streamlined Utility for Copying Kernel v1.1 (%d %s)\n", nThreads, (nThreads == 1 ? "thread" : "threads") );

    GetSystemTime( &stStart );

    LoadFileTimesAndSizes( fUseDAT );

    dwTotalMask = 0;
    while ( nPaths ) {

        hThreads[nPaths-1] = CreateThread( NULL,
                                           0L,
                                           ThreadFunction,
                                           (LPVOID)UlongToPtr(nPaths),
                                           0,
                                           &dwThreadId );
        dwTotalMask |= dwMasks[nPaths-1];

        --nPaths;
    }

    WaitForMultipleObjects( nThreads,
                            hThreads,
                            TRUE,          // WaitAll
                            (DWORD)-1 );

    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    if ( fProgressMode ) {
        printf("%*s\r", nConsoleWidth, "");
        if ( fWasConsoleModeSet ) {
            SetConsoleMode( hStdOut, dwConsoleMode );
        }
    }

    printf("Copy complete, %ld file entries\n", nFiles+nDirectories);

    nPaths = 0;
    while ( nPaths < nThreads ) {
        printf("%11ld bytes from %s\n", dwTotalSizes[nPaths], chPath[nPaths+1] );
        nPaths++;
    }

    nPaths = nThreads;
    while ( nPaths ) {
        nPaths--;
        CloseHandle( hThreads[nPaths] );
    }

    DumpStraglers( dwTotalMask );

    if ( fUpdateINIBase ) {
        UpdateFileTimesAndSizes();
    }

    FreeFileNames();

    DeleteCriticalSection( &cs );
    DeleteCriticalSection( &pcs );

    if ( fUpdateCommandLine ) {
        UpdateLastCommandLine( argc, argv );
    }

    GetSystemTime( &stEnd );

    nSeconds = DiffTimes( &stStart, &stEnd );

    nMinutes = nSeconds / 60;
    nSeconds = nSeconds % 60;
    printf("Done, Elapsed time: %02d:%02d\n", nMinutes, nSeconds);

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\soparse.c ===
/****************************** Module Header ******************************\
* Module Name: soparse.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* Function Prototypes
\***************************************************************************/

/*********************************************************************
* soFindChar
\***************************************************************************/
char * soFindChar (char * pmap, char * pmapEnd, char c)
{
    while (pmap < pmapEnd) {
        if (*pmap != c) {
            pmap++;
        } else {
            return pmap;
        }
    }

    return NULL;
}
/*********************************************************************
* soFindTag
\***************************************************************************/
char * soFindTag (char * pmap, char * pmapEnd, char * pszTag)
{
    char * pszNext;
    char * pmapTag;


    do {
        /*
         * Find first char
         */
        pmapTag = soFindChar (pmap, pmapEnd, *pszTag);
        if (pmapTag == NULL) {
            return NULL;
        }
        pmap = pmapTag + 1;
        pszNext = pszTag + 1;

        /*
         * First found, compare the rest
         */
        while (pmap < pmapEnd) {
            if (*pmap != *pszNext) {
                break;
            } else {
                pmap++;
                pszNext++;
                if (*pszNext == '\0') {
                    return pmapTag;
                }
            }
        }

    } while (pmap < pmapEnd);

   return NULL;
}
/*********************************************************************
* soFindFirstCharInTag
*
* Finds the first occurrence of any character in pszTag
\***************************************************************************/
char * soFindFirstCharInTag (char * pmap, char * pmapEnd, char * pszTag)
{
    char * pszNext;

    while (pmap < pmapEnd) {
        /*
         * Compare current char to all chars in pszTag
         */
        pszNext = pszTag;
        do {
            if (*pmap == *pszNext++) {
                return pmap;
            }
        } while (*pszNext != '\0');

        pmap++;
    }

    return NULL;
}
/*********************************************************************
* soFindBlockEnd
*
* Finds the end of a {} () etc block
\***************************************************************************/
char * soFindBlockEnd (char * pmap, char * pmapEnd, char * pszBlockChars)
{
    if (*pmap != *pszBlockChars) {
        soLogMsg(SOLM_ERROR, "Not at the beginning of block");
        return NULL;
    }

    do {
        /*
         * Find next block char (i.e, { or })
         */
        pmap++;
        pmap = soFindFirstCharInTag (pmap, pmapEnd, pszBlockChars);
        if (pmap == NULL) {
            break;
        }

        /*
         * If at the end of the block, done
         */
        if (*pmap == *(pszBlockChars + 1)) {
            return pmap;
        }

        /*
         * Nested block, recurse.
         */
        pmap = soFindBlockEnd (pmap, pmapEnd, pszBlockChars);
    } while (pmap != NULL);

    soLogMsg(SOLM_ERROR, "Failed to find block end");
    return NULL;

}
/*********************************************************************
* soIsIdentifierChar
\***************************************************************************/
BOOL soIsIdentifierChar (char c)
{
    return (   ((c >= 'a') && (c <= 'z'))
            || ((c >= 'A') && (c <= 'Z'))
            || ((c >= '0') && (c <= '9'))
            ||  (c == '_'));
}
/*********************************************************************
* soSkipBlanks
\***************************************************************************/
char * soSkipBlanks(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        switch (*pmap) {
            case ' ':
            case '\r':
            case '\n':
                pmap++;
                break;

            default:
                return pmap;
        }
    }

    return NULL;
}
/*********************************************************************
* soSkipToIdentifier
*
* Finds the beginning of the next identifier or return pmap if
*  already on an indetifier
\***************************************************************************/
char * soSkipToIdentifier(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        if (soIsIdentifierChar(*pmap)) {
            return pmap;
        } else {
            pmap++;
        }
    }

    return NULL;
}
/*********************************************************************
* soSkipIdentifier
*
* Finds the end of the current identifier
\***************************************************************************/
char * soSkipIdentifier(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        if (soIsIdentifierChar(*pmap)) {
            pmap++;
        } else {
            return pmap;
        }
    }

    return pmapEnd;
}
/*********************************************************************
* soGetIdentifier
*
* Returns the beginning of the current or next identifier and its size
\***************************************************************************/
char * soGetIdentifier (char * pmap, char * pmapEnd, UINT * puSize)
{
    char * pTag, * pTagEnd;

    pTag = soSkipToIdentifier(pmap, pmapEnd);
    if (pTag == NULL) {
        return NULL;
    }

    pTagEnd = soSkipIdentifier(pTag, pmapEnd);

    *puSize = (UINT)(pTagEnd - pTag);
    return pTag;

}
/*********************************************************************
* soCopyTagName
\***************************************************************************/
char * soCopyTagName (char * pTagName, UINT uTagSize)
{
    char * pszName;

    pszName = (char *) LocalAlloc(LPTR, uTagSize+1);
    if (pszName == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        soLogMsg(SOLM_ERROR, "soCopytagName allocation failed. Size:%d", uTagSize);
        return NULL;
    }
    strncpy(pszName, pTagName, uTagSize);
    return pszName;
}
/*********************************************************************
* soFindBlock
\***************************************************************************/
BOOL soFindBlock (char * pmap, char *pmapEnd, char * pszBlockChars, PBLOCK pb)
{
    static char gszBlockBeginChar [] = " ;";

    /*
     * Find the beginning of the block or a ;
     */
    *gszBlockBeginChar = *pszBlockChars;
    pb->pBegin = soFindFirstCharInTag (pmap, pmapEnd, gszBlockBeginChar);
    if (pb->pBegin == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to find beginning of block");
        return FALSE;
    }

    /*
     * If no block found, done
     */
    if (*(pb->pBegin) == ';') {
        /*
         * Make pb->pBegin point to whatever follows
         */
        (pb->pBegin)++;
        pb->pEnd = pb->pBegin;
        return TRUE;
    }

    /*
     * Find the end of block
     */
    pb->pEnd = soFindBlockEnd(pb->pBegin, pmapEnd, pszBlockChars);
    if (pb->pEnd == NULL) {
        return FALSE;
    }

    return TRUE;
}
/*********************************************************************
* soGetStructListEntry
\***************************************************************************/
PSTRUCTLIST soGetStructListEntry (char * pTag, UINT uTagSize, PSTRUCTLIST psl)
{

    while (psl->uSize != 0) {
        if ((psl->uSize == uTagSize) && !strncmp(pTag, psl->pszName, uTagSize)) {
            (psl->uCount)++;
            return psl;
        }
        psl++;
    }

    return NULL;
}
/*********************************************************************
* soGetBlockName
*
* Finds the beginning, end, name and name size of a structure or union.
*  if any after pmap.
*
\***************************************************************************/
BOOL soGetBlockName (char * pmap, char * pmapEnd, PBLOCK pb)
{
    char * pNextTag;

    if (!soFindBlock (pmap, pmapEnd, "{}", pb)) {
        return FALSE;
    }

    /*
     * If there was no block (the structure body is not here), done
     */
    if (pb->pBegin == pb->pEnd) {
        pb->pName = NULL;
        return TRUE;
    }

    pNextTag = soSkipBlanks(pb->pEnd + 1, pmapEnd);
    if (pNextTag == NULL) {
        /*
         * It might be at the end of the file..... but it was expecting
         *  a name or a ;
         */
        soLogMsg(SOLM_ERROR, "Failed to find union terminator or name");
        return FALSE;
    }

    /*
     * If it's unamed, done
     */
    if (*pNextTag == ';') {
        pb->pName = NULL;
        return TRUE;
    }

    pb->pName = soGetIdentifier(pNextTag, pmapEnd, &(pb->uNameSize));
    if (pb->pName == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to get block name");
        return FALSE;
    }

    return TRUE;
}
/*********************************************************************
* soFreepfiPointers
*
\***************************************************************************/
void soFreepfiPointers (PFIELDINFO pfi)
{
    if (pfi->dwFlags & SOFI_ALLOCATED) {
        LocalFree(pfi->pType);
    }
    if (pfi->dwFlags & SOFI_ARRAYALLOCATED) {
        LocalFree(pfi->pArray);
    }
}
/*********************************************************************
* soParseField
*
\***************************************************************************/
char * soParseField (PWORKINGFILES pwf, PFIELDINFO pfi, char * pTag, char * pTagEnd)
{
    static char gszpvoid [] = "void *";
    static char gszdword [] = "DWORD";

    BOOL fUseFieldOffset, fBitField, fTypeFound, fArray;
    BLOCK block;
    char * pTagName, * pszFieldName;
    char * pNextTag, * pType;
    UINT uTags, uTagSize, uTagsToName, uTypeSize;


    fUseFieldOffset = TRUE;
    uTags = 0;
    uTagsToName = 1;
    fTypeFound = FALSE;
    do {
        /*
         * Find next indetifier, move past it and get the following char
         */
        uTags++;
        pTagName = soGetIdentifier(pTag+1, pwf->pmapEnd, &uTagSize);
        if (pTagName == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get field name");
            return NULL;
        }

        pTag = pTagName + uTagSize;
        if (pTag >= pTagEnd) {
            break;
        }

        pNextTag = soSkipBlanks(pTag, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get field termination");
            return NULL;
        }

        /*
         * Type check.
         * (LATER: Let's see how long we can get away with assuming that the type
         *  is the first tag....)
         * Remember where the type is
         */
        if (!fTypeFound) {
            pType = pTagName;
            uTypeSize = uTagSize;
            fTypeFound = TRUE;
        }

        if (uTags == 1) {
            if (!strncmp(pTagName, "union", uTagSize)) {
                /*
                 * Get the union name
                 */
                if (!soGetBlockName(pTagName, pwf->pmapEnd, &block)) {
                    return NULL;
                }
                if (block.pName != NULL) {
                    /*
                     * Named union. Add this name to the table
                     */
                    pTagName = block.pName;
                    uTagSize = block.uNameSize;
                    fUseFieldOffset = FALSE;
                    fTypeFound = FALSE;
                    break;
                } else {
                    /*
                     * Parse and add the fields in this union
                     */
                    fTypeFound = FALSE;
                }


            } else if (!strncmp(pTagName, "struct", uTagSize)) {
                /*
                 * Get the structure name
                 */
                if (!soGetBlockName(pTagName, pwf->pmapEnd, &block)) {
                    return NULL;
                }
                if (block.pBegin == block.pEnd) {
                    /*
                     * The structure body is not here. We need one more
                     *  identifier to get to the field name. Also, this
                     *  field must (?) be a pointer to the struct we're
                     *  parsing
                     */
                    uTagsToName++;
                    pType = gszpvoid;
                    uTypeSize = sizeof(gszpvoid) - 1;

                } else if (block.pName != NULL) {
                    /*
                     * Named structure. Add this name to the table
                     */
                    pTagName = block.pName;
                    uTagSize = block.uNameSize;
                    fUseFieldOffset = FALSE;
                    fTypeFound = FALSE;
                    break;
                } else {
                    /*
                     * Parse and add the fields in this struct
                     */
                    fTypeFound = FALSE;
                }

            } else {

                /*
                 * Cannot get the offset of strucutres like RECT, POINT, etc.
                 */
                 fUseFieldOffset = (NULL == soGetStructListEntry(pTagName, uTagSize, gpslEmbeddedStructs));
            }
        } else { /* if (uTags == 1) */
            /*
             * Does this look like a function prototype?
             */
            if (*pTagName == '(') {
                pTag = soFindChar (pTagName + 1, pwf->pmapEnd, ')');
                if (pTag == NULL) {
                    soLogMsg(SOLM_ERROR, "Failed to find closing paren");
                    return NULL;
                }
                pTag++;
                uTagSize = (UINT)(pTag - pTagName);
                fUseFieldOffset = FALSE;
                break;
            }
        }  /* if (uTags == 1) */


        /*
         * If this is followed by a terminator, this must be the field name
         */
    } while (   (*pNextTag != ';') && (*pNextTag != '[')
             && (*pNextTag != '}') && (*pNextTag != ':'));


    if (pTag >= pTagEnd) {
        return pTag;
    }

    fBitField = (*pNextTag == ':');
    fArray = (*pNextTag == '[');

    /*
     * Cannot use FIELD_OFFSET on bit fields or unamed structs
     */
    fUseFieldOffset &= (!fBitField && (uTags > uTagsToName));

    /*
     * If this is a bit field, make the size be part of the name
     */
    if (fBitField) {
        pNextTag = soSkipBlanks(pNextTag + 1, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get bit field size");
            return NULL;
        }
        pNextTag = soSkipIdentifier(pNextTag + 1, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to skip bit field size");
            return NULL;
        }
        uTagSize = (UINT)(pNextTag - pTagName);
    }

    /*
     * Copy field name
     */
    pszFieldName = soCopyTagName (pTagName, uTagSize);
    if (pszFieldName == NULL) {
        return NULL;
    }

    if (fUseFieldOffset) {
        /*
         * Use FIELD_OFFSET macro
         */
        if (!soWriteFile(pwf->hfileOutput, gszStructFieldOffsetFmt, pszFieldName, pfi->pszStructName, pszFieldName)) {
            return NULL;
        }

    } else {
        /*
         * If this is the first field or if this is a bit field
         *  preceded by another bit field
         */
        if ((pfi->pType == NULL)
                || (fBitField && (pfi->dwFlags & SOFI_BIT))) {
            /*
             * Write 0 or the mask to signal a 0 relative offset from
             *  the previous field
             */
            if (!soWriteFile(pwf->hfileOutput, gszStructAbsoluteOffsetFmt, pszFieldName,
                    ((pfi->dwFlags & SOFI_BIT) ?  0x80000000 : 0))) {

                return NULL;
            }

        } else {
            /*
             * Write a relative offset from the previous field
             * Copy type name if not done already
             */
            if (!(pfi->dwFlags & SOFI_ALLOCATED)) {
                pfi->pType = soCopyTagName (pfi->pType, pfi->uTypeSize);
                if (pfi->pType == NULL) {
                    return NULL;
                }
                pfi->dwFlags |= SOFI_ALLOCATED;
            }

             /*
              * If the last field was NOT an array
              */
             if (!(pfi->dwFlags & SOFI_ARRAY)) {
                if (!soWriteFile(pwf->hfileOutput, gszStructRelativeOffsetFmt, pszFieldName, pfi->pType)) {
                    return NULL;
                }
             } else {
                /*
                 * Copy the array size if not done already
                 */
                 if (!(pfi->dwFlags & SOFI_ARRAYALLOCATED)) {
                    pfi->pArray = soCopyTagName (pfi->pArray, pfi->uArraySize);
                    if (pfi->pArray == NULL) {
                        return NULL;
                    }
                    pfi->dwFlags |= SOFI_ARRAYALLOCATED;
                 }

                 if (!soWriteFile(pwf->hfileOutput, gszStructArrayRelativeOffsetFmt, pszFieldName, pfi->pType, pfi->pArray)) {
                    return NULL;
                 }
            } /* if ((pfi->pType == NULL) || (pfi->dwFlags & SOFI_BIT)) */
        }

    } /* if (fUseFieldOffset) */

    /*
     * Save the field info wich migth be needed to calculate the offset
     *  to following fields. See gszStruct*RelativeOffsetFmt.
     */
    soFreepfiPointers(pfi);
    pfi->dwFlags = 0;
    if (fBitField) {
        /*
         * LATER: Let's see how long we can get away with assuming that
         *  bit fields take a DWORD. This only matters when a !fUseFieldOffset
         *  is preceded by a bit field.
         */
        pfi->dwFlags = SOFI_BIT;
        pfi->pType = gszdword;
        pfi->uTypeSize = sizeof(gszdword) - 1;
    } else {
        pfi->pType = pType;
        pfi->uTypeSize = uTypeSize;

        if (fArray) {
            pfi->dwFlags = SOFI_ARRAY;
            if (!soFindBlock (pNextTag, pwf->pmapEnd, "[]", &block)) {
                return NULL;
            }
            if (block.pBegin + 1 >= block.pEnd) {
                soLogMsg(SOLM_ERROR, "Missing array size", pfi->pszStructName, pszFieldName);
                return NULL;
            }
            pfi->pArray = pNextTag + 1;
            pfi->uArraySize = (UINT)(block.pEnd - block.pBegin - 1);
        }
    } /* if (fBitField) */

    LocalFree(pszFieldName);

    /*
     * Move past the end of this field
     */
    pTag = soFindChar (pTagName + 1, pwf->pmapEnd, ';');
    if (pTag == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to find ';' after field name");
        return NULL;
    }
    pTag++;

    return pTag;

    soLogMsg(SOLM_ERROR, ". Struct:%s Field:%s", pfi->pszStructName, pszFieldName);

}
/*********************************************************************
* soParseStruct
\***************************************************************************/
char * soParseStruct (PWORKINGFILES pwf)
{

    BLOCK block;
    char * pTag, ** ppszStruct;
    FIELDINFO fi;
    PSTRUCTLIST psl;

    if (!soGetBlockName(pwf->pmap, pwf->pmapEnd, &block)) {
        return NULL;
    }

    /*
     * If there was no block (the structure body is not here), done
     */
    if (block.pBegin == block.pEnd) {
        return block.pBegin;
    }

    /*
     * Fail if no name.
     */
    if (block.pName == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to get structure name");
        return NULL;
    }

    /*
     * If there is a struct list, check if in the list
     * If in the list, check that we haven't found it already.
     * If not in the list, done.
     */
     if (pwf->psl != NULL) {
        psl = soGetStructListEntry(block.pName, block.uNameSize, pwf->psl);
        if (psl != NULL) {
            if (psl->uCount > 1) {
                soLogMsg(SOLM_ERROR, "Struct %s already defined", psl->pszName);
                return NULL;
            }
        } else {
            return block.pEnd;
        }
     }

    /*
     * Make a null terminated string for the name.
     */
    ZeroMemory(&fi, sizeof(fi));
    fi.pszStructName = soCopyTagName (block.pName, block.uNameSize);
    if (fi.pszStructName == NULL) {
        return NULL;
    }


    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        if (!soWriteFile(pwf->hfileOutput, "%s\r\n", fi.pszStructName)) {
            goto CleanupAndFail;
        }
        goto DoneWithThisOne;
    }

    /*
     * Write structure offsets table definition and entry in strucutres table
     */
    if (!soWriteFile(pwf->hfileOutput, gszStructDefFmt, gszStructDef, fi.pszStructName, gszStructBegin)) {
        goto CleanupAndFail;
    }

    if (!soWriteFile(pwf->hfileTemp, gszTableEntryFmt, fi.pszStructName, fi.pszStructName, fi.pszStructName)) {
        goto CleanupAndFail;
    }

    /*
     * Parse the fields
     */
    pTag = block.pBegin + 1;
    while (pTag < block.pEnd) {
        pTag = soParseField (pwf, &fi, pTag, block.pEnd);
        if (pTag == NULL) {
            goto CleanupAndFail;
        }
    }

    /*
     * Write structure last record and end
     */
    if (!soWriteFile(pwf->hfileOutput, "%s%s%s", gszStructLastRecord, fi.pszStructName, gszStructEnd)) {
        goto CleanupAndFail;
    }


DoneWithThisOne:
    (pwf->uTablesCount)++;

    LocalFree(fi.pszStructName);
    soFreepfiPointers(&fi);

    /*
     * Move past the end of the structure
     */
    pTag = soFindChar(block.pName + block.uNameSize, pwf->pmapEnd, ';');
    return (pTag != NULL ? pTag + 1 : NULL);

CleanupAndFail:
    LocalFree(fi.pszStructName);
    soFreepfiPointers(&fi);
    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\structo\structo.h ===
/****************************** Module Header ******************************\
* Module Name: structo.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include <stdio.h>
#include <stddef.h>
#include <windows.h>

/***************************************************************************\
 * Defines
\***************************************************************************/
// Working files
#define SOWF_APPENDOUTPUT       0x0001
#define SOWF_INCLUDEINPUTFILE   0x0002
#define SOWF_INLCLUDEPRECOMPH   0x0004
#define SOWF_LISTONLY           0x0008

// soCloseWorkingFiles
#define SOCWF_DEFAULT      0x0
#define SOCWF_CLEANUP      0x1

// soLogMsg
#define SOLM_DEFAULT      0x0000
#define SOLM_NOLABEL      0x0001
#define SOLM_ERROR        0x0002
#define SOLM_WARNING      0x0004
#define SOLM_API          0x0008
#define SOLM_APIERROR     (SOLM_API | SOLM_ERROR)
#define SOLM_NOEOL        0x0010
#define SOLM_APPEND       (SOLM_NOLABEL | SOLM_NOEOL)

// Field info
#define SOFI_ALLOCATED          0x0001
#define SOFI_ARRAY              0x0002
#define SOFI_ARRAYALLOCATED     0x0004
#define SOFI_BIT                0x0008

/***************************************************************************\
 * Structures
\***************************************************************************/
typedef struct _FILEMAP
{
    /*
     * hfileInput is assumed to be the first field of this structure
     */
    union {
        HANDLE hfileInput;
        HANDLE hfile;
    };
    HANDLE hmap;
    char * pmapStart;
    char * pmap;
    char * pmapEnd;
} FILEMAP, * PFILEMAP;

typedef struct _STRUCTLIST
{
    UINT uSize;
    char * pszName;
    UINT uCount;
} STRUCTLIST, * PSTRUCTLIST;

typedef struct _WORKINGFILES
{
    DWORD dwOptions;
    char * pszInputFile;
    FILEMAP;
    char * pszOutputFile;
    HANDLE hfileOutput;
    HANDLE hfileTemp;
    char * pszStructsFile;
    PSTRUCTLIST psl;
    DWORD uTablesCount;
    char * pszIncInputFileExt;
} WORKINGFILES, * PWORKINGFILES;

typedef struct _BLOCK
{
    char * pBegin;
    char * pEnd;
    char * pName;
    UINT   uNameSize;
} BLOCK, * PBLOCK;

typedef struct _FIELDINFO
{
    char * pszStructName;
    char * pType;
    DWORD dwFlags;
    UINT uTypeSize;
    char * pArray;
    UINT uArraySize;
} FIELDINFO, * PFIELDINFO;

/***************************************************************************\
 * Globals
\***************************************************************************/
// socode.c
extern char * gpszHeader [];
extern char * gpszTail [];

// soglobal.c
extern char gszPrecomph [];
extern char gszIncInput [];

extern char gszStructTag [];
extern char gszStructDef [];
extern char gszStructDefFmt [];
extern char gszStructBegin [];
extern char gszStructEnd [];
extern char gszStructFieldOffsetFmt [];
extern char gszStructAbsoluteOffsetFmt [];
extern char gszStructLastRecord [];
extern char gszStructRelativeOffsetFmt [];
extern char gszStructArrayRelativeOffsetFmt [];

extern char gszTableDef [];
extern char gszTableEntryFmt [];
extern char gszTableEnd [];
extern STRUCTLIST gpslEmbeddedStructs [];

/***************************************************************************\
 * Funtion Prototypes
\***************************************************************************/
// sofile.c
BOOL soCopyStructuresTable (PWORKINGFILES pwf);
BOOL soCloseWorkingFiles (PWORKINGFILES pwf, DWORD dwFlags);
BOOL soOpenWorkingFiles (PWORKINGFILES pwf);
BOOL __cdecl soWriteFile(HANDLE hfile, char *pszfmt, ...);

// soparse.c
char * soCopyTagName (char * pTagName, UINT uTagSize);
char * soFindChar (char * pmap, char * pmapEnd, char c);
char * soFindTag (char * pmap, char * pmapEnd, char * pszTag);
char * soGetIdentifier (char * pmap, char * pmapEnd, UINT * puSize);
BOOL soIsIdentifierChar (char c);
char * soParseStruct (PWORKINGFILES pwf);

// soutil.c
void __cdecl soLogMsg(DWORD dwFlags, char *pszfmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\supporttools\setup\customaction\suptools\dbgwrap.h ===
// dbgwrap.h
// wrapper for outputting debug info

void LogUIMessage(LPSTR szStr) {
#ifdef _DEBUG
	OutputDebugString(szStr);
#endif
}

void PASvprintf(LPCSTR lpszFmt, va_list lpParms) {
	char rgchBuf[8192];
    // Get it into a string
	vsprintf(rgchBuf, lpszFmt, lpParms);
	LogUIMessage(rgchBuf);
}

void PASprintf(LPCSTR lpszFmt, ...)  {
    va_list arglist;
    va_start(arglist, lpszFmt);
    PASvprintf(lpszFmt, arglist);
    va_end(arglist);
}
//void PASprintf(LPCSTR lpszFormat, ...);
#ifdef _DEBUG
#define DEBUGMSG(cond,printf_exp) ((void)((cond)?(PASprintf printf_exp),1:0))
#else
#define DEBUGMSG(cond,printf_exp) 
#endif
//Eg:
//DEBUGMSG(1, ("%C", ptok->rgwch[i]));
//DEBUGMSG(1, ("\r\n   0:%d 1:%d 2:%d 3:%d 4:%d\r\n", pch->rgdwCompressLen[0], pch->rgdwCompressLen[1], pch->rgdwCompressLen[2], pch->rgdwCompressLen[3], pch->rgdwCompressLen[4]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\symlink\makefile.inc ===
$(O)\mklnk.res: mklnk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\supporttools\setup\customaction\suptools\suptools.cpp ===
// SupTools.cpp : Defines the entry point for the DLL application.
//

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <MsiQuery.h>
#include <psapi.h>
#include "dbgwrap.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#include "objbase.h"
#include "atlbase.h"

//
// CLSID for PCHUpdate
//
const CLSID CLSID_PCHUpdate = { 0x833E4012,0xAFF7,0x4AC3,{ 0xAA,0xC2,0x9F,0x24,0xC1,0x45,0x7B,0xCE } };


//
// dispatch interface entries
//
#define DISPID_HCU_BASE                             0x08030000

#define DISPID_HCU_BASE_UPDATE                      (DISPID_HCU_BASE + 0x0000)
#define DISPID_HCU_BASE_ITEM                        (DISPID_HCU_BASE + 0x0100)
#define DISPID_HCU_BASE_EVENTS                      (DISPID_HCU_BASE + 0x0200)

#define DISPID_HCU_LATESTVERSION               		(DISPID_HCU_BASE_UPDATE + 0x10)
#define DISPID_HCU_CREATEINDEX                 		(DISPID_HCU_BASE_UPDATE + 0x11)
#define DISPID_HCU_UPDATEPKG                   		(DISPID_HCU_BASE_UPDATE + 0x12)
#define DISPID_HCU_REMOVEPKG                   		(DISPID_HCU_BASE_UPDATE + 0x13)
#define DISPID_HCU_REMOVEPKGBYID               		(DISPID_HCU_BASE_UPDATE + 0x14)


//
// custom macros
//

#define SAFE_RELEASE( pointer ) \
        if ( (pointer) != NULL )    \
        {   \
            (pointer)->Release();   \
            (pointer) = NULL;       \
        }   \
        1


//
// DLL entry point
// 

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

// globAL VARIABLES
TCHAR g_tszTitle[1024] = _T("");

///////////////////////////////////////////////////////////
// IsHSCAppRunningEnum - msi custom action
// Checks if the Help and Support Center app is running
///////////////////////////////////////////////////////////

BOOL CALLBACK IsHSCAppRunningEnum( HWND hwnd, LPARAM lParam )
{
	DWORD	dwID;
	TCHAR	tszTitle[1024] = _T("");
	HWND	hParent	= NULL;	
	
	GetWindowThreadProcessId(hwnd, &dwID);
	// if this the desired process ID
	if(dwID == (DWORD)lParam) {
		// get handle to root window
		hParent = GetAncestor(hwnd, GA_ROOTOWNER);
		if (hParent) {
			if ( GetWindowText(hParent, tszTitle, sizeof(tszTitle)) ) { 
				if SUCCEEDED(StringCchCopy(g_tszTitle, 1024, tszTitle)) {
					DEBUGMSG(1, ("\r\nNeed to shutdown app: %s", g_tszTitle));
					return FALSE;
				}
			} 
		} 
	}

	return TRUE ;
}

///////////////////////////////////////////////////////////
// IsHSCAppRunning - msi custom action
// Checks if the Help and Support Center app is running
///////////////////////////////////////////////////////////

UINT __stdcall IsHSCAppRunning(MSIHANDLE hInstall)
{
	TCHAR	tszHSCAppPath[MAX_PATH + 1];
	TCHAR    tszHelpDir[] = _T("\\PCHEALTH\\HELPCTR\\Binaries\\");
	TCHAR	tszProcessName[MAX_PATH+1] = _T("");
	TCHAR	tszModulePath[MAX_PATH] = _T("");
	TCHAR	tszHSCApp[] = _T("HelpCtr.exe");
	TCHAR	tszProperty[] = _T("HSCAPPRUNNING");
	TCHAR	tszPropTitle[] = _T("HSCAPPTITLE");
	DWORD	aProcesses[1024], cbNeededTotal, cProcesses;
	HMODULE hMod;
    	DWORD 	cbNeeded;
	HANDLE	hProcess = NULL;
	HRESULT	hr;
    	unsigned int i;
	
	// Prepare HSCAppPath 
	if (!(GetWindowsDirectory(tszHSCAppPath, MAX_PATH+1))) { return ERROR_INSTALL_FAILURE; }
	hr = StringCchCat(tszHSCAppPath, MAX_PATH, tszHelpDir);
	if (FAILED(hr)) { return ERROR_INSTALL_FAILURE; 	}
	hr = StringCchCat(tszHSCAppPath, MAX_PATH, tszHSCApp);
	if (FAILED(hr)) { return ERROR_INSTALL_FAILURE; 	}
	
	// Enumerate all processes 
	if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeededTotal ) ) {
		// return error
       	return ERROR_INSTALL_FAILURE;
	}

    	// Calculate how many process identifiers were returned.
    	cProcesses = cbNeededTotal / sizeof(DWORD);
    	// Iterate through the process list.
    	for ( i = 0; i < cProcesses; i++ ) {
    		// Get a handle to the process.
		hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i] );
		if ( hProcess ) {
			// GET MODULE HANDLE
			if( EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
				// Get the process name.
				if ( GetModuleBaseName( hProcess, hMod, tszProcessName, sizeof(tszProcessName))) {
					// Get process path
					if (GetModuleFileNameEx( hProcess, hMod, tszModulePath, sizeof(tszModulePath))) {
						// if both process name and path matches
						if ( (0 == _tcsicmp(tszProcessName, tszHSCApp)) && (0 == _tcsicmp(tszModulePath, tszHSCAppPath)) ) {
							// set msi property and get window title
							MsiSetProperty(hInstall, tszProperty, _T("1")); 	
							EnumWindows((WNDENUMPROC)IsHSCAppRunningEnum, (LPARAM)aProcesses[i]);
							if ( _tcsicmp(g_tszTitle, _T(""))) {
								MsiSetProperty(hInstall, tszPropTitle, g_tszTitle);
							} else { 	
								DEBUGMSG(1, ("\r\nDetected HSC running, but failed to obtain window title"));
								return ERROR_INSTALL_FAILURE;
							}
							break;
						}
					} else { 	DEBUGMSG(1, ("\r\nGetModuleFileNameEx failed. GetLastError returned %u\n", GetLastError() )); 
					}
				} else { 	DEBUGMSG(1, ("\r\nGetModuleBaseName failed. GetLastError returned %u\n", GetLastError() ));
				}
			}else { DEBUGMSG(1, ("\r\nEnumProcessModules failed. GetLastError returned %u\n", GetLastError() ));
			}
			// done with the handle
			CloseHandle(hProcess);
		} else { 	DEBUGMSG(1, ("\r\nOpenProcess failed. GetLastError returned %u\n", GetLastError() ));
		}
	} 
	return ERROR_SUCCESS; 
}

///////////////////////////////////////////////////////////
// IsHSCAppRunning - msi custom action
// Checks if the Help and Support Center app is running
///////////////////////////////////////////////////////////

UINT __stdcall UpdatePackage(MSIHANDLE hInstall)
{
	DWORD dwError = 0;
	DWORD dwLength = 0;
    HRESULT hr = S_OK;
    IUnknown* pUnknown = NULL;
    IDispatch* pPCHUpdate = NULL;
    UINT nResult = ERROR_SUCCESS;
    LPTSTR pszCabFileName = NULL;
	BOOL bNeedProxySecurity = FALSE;

    // method execution specific variables
    CComVariant pvars[ 2 ];
    DISPPARAMS disp = { pvars, NULL, 2, 0 };

    //
    // initialize the COM library
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( FAILED( hr ) )
    {
        return ERROR_INSTALL_FAILURE;
    }

    //
    // initialize the security of the COM/OLE
    //
    //////////////////////////////////////////////////////////////////////////////
    // *) We don't care which authentication service we use
    // *) We want to identify the callers.
    // *) For package installation let's use the thread token for outbound calls
    //////////////////////////////////////////////////////////////////////////////
    hr = CoInitializeSecurity( NULL, -1, NULL, NULL, 
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DYNAMIC_CLOAKING, NULL );
    if ( FAILED( hr ) )
    {
		//
		// since this function will be called by MSI, the calling application would have alredy
		// set the security which makes this function to fail -- so, instead of breaking at this
		// point, we flag here so that CoSetProxyBlanket will be called
		//
		bNeedProxySecurity = TRUE;
    }

    //
    // get the interface pointer to the PCHUPDATE interface
    hr = CoCreateInstance( CLSID_PCHUpdate, NULL, CLSCTX_ALL, IID_IUnknown, (void **) &pUnknown );
    if ( FAILED( hr ) )
    {
        nResult = ERROR_INSTALL_FAILURE;
        goto cleanup;
    }

	//
	// call the CoSetProxyBlanket function -- do this only if needed
	if ( bNeedProxySecurity == TRUE )
	{
		hr = CoSetProxyBlanket( pUnknown, 
			RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, 
			RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DYNAMIC_CLOAKING );
		if ( FAILED( hr ) )
		{
	        nResult = ERROR_INSTALL_FAILURE;
			goto cleanup;
		}
	}

	//
    // get the dispatch interface pointer
    hr = pUnknown->QueryInterface(IID_IDispatch, (void **) &pPCHUpdate);
    if ( FAILED( hr ) )
    {
        nResult = ERROR_INSTALL_FAILURE;
        goto cleanup;
    }

	//
	// call the CoSetProxyBlanket function -- do this only if needed
	if ( bNeedProxySecurity == TRUE )
	{
		hr = CoSetProxyBlanket( pPCHUpdate, 
			RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, 
			RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DYNAMIC_CLOAKING );
		if ( FAILED( hr ) )
	    {
			nResult = ERROR_INSTALL_FAILURE;
			goto cleanup;
		}
	}

	//
	// default length
	dwLength = 255;


get_cabinet_name:
	
	//
	// allocate memory to get the cabinet name
	pszCabFileName = new TCHAR[ dwLength + 1 ];
    if ( pszCabFileName == NULL )
    {
		nResult = ERROR_INSTALL_FAILURE;
		goto cleanup;
    }

    // ...
	ZeroMemory( pszCabFileName, (dwLength + 1) * sizeof( TCHAR ) );

	//
	// get the appropriate cab file name
	dwError = MsiGetProperty( hInstall, _T( "HSCCabinet" ), pszCabFileName, &dwLength );
	if ( dwError == ERROR_MORE_DATA && dwLength == 255 )
	{
		// buffer is not sufficient -- allocate more memory and call again
		delete [] pszCabFileName;
		pszCabFileName = NULL;

		// ...
		goto get_cabinet_name;
	}
	else if ( dwError != ERROR_SUCCESS )
	{
		nResult = ERROR_INSTALL_FAILURE;
		goto cleanup;
	}

    //
    // prepare the input parameters for UpdatePkg method
    pvars[ 0 ] = true;
    pvars[ 1 ] = pszCabFileName;

    //
    // execute the function
    pPCHUpdate->Invoke( DISPID_HCU_UPDATEPKG, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL );

    //
    // success
    nResult = ERROR_SUCCESS;

    //
    // cleanup section
    //

cleanup:

    //
    // release the interface pointers
    SAFE_RELEASE( pUnknown );
	SAFE_RELEASE( pPCHUpdate );

    // release memory allocated for cabinet name
    if ( pszCabFileName != NULL )
    {
        delete [] pszCabFileName;
        pszCabFileName = NULL;
    }

    //
    // uninitialize the COM library
    CoUninitialize();

    // return
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\symlink\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "common.h"

BOOLEAN
MassageLinkValue(
    IN LPCWSTR lpLinkName,
    IN LPCWSTR lpLinkValue,
    OUT PUNICODE_STRING NtLinkName,
    OUT PUNICODE_STRING NtLinkValue,
    OUT PUNICODE_STRING DosLinkValue
    )
{
    PWSTR FilePart;
    PWSTR s, sBegin, sBackupLimit;
    NTSTATUS Status;
    USHORT nSaveNtNameLength;
    ULONG nLevels;

    //
    // Initialize output variables to NULL
    //

    RtlInitUnicodeString( NtLinkName, NULL );
    RtlInitUnicodeString( NtLinkValue, NULL );

    //
    // Translate link name into full NT path.
    //

    if (!RtlDosPathNameToNtPathName_U( lpLinkName,
                                       NtLinkName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    //
    // All done if no link value.
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        return TRUE;
        }

    //
    // If the target is a device, do not allow the link.
    //

    if (RtlIsDosDeviceName_U( (PWSTR)lpLinkValue )) {
        return FALSE;
        }

    //
    // Convert to DOS path to full path, and get Nt representation
    // of DOS path.
    //

    if (!RtlGetFullPathName_U( lpLinkValue,
                               DosLinkValue->MaximumLength,
                               DosLinkValue->Buffer,
                               NULL
                             )
       ) {
        return FALSE;
        }
    DosLinkValue->Length = wcslen( DosLinkValue->Buffer ) * sizeof( WCHAR );

    //
    // Verify that the link value is a valid NT name.
    //

    if (!RtlDosPathNameToNtPathName_U( DosLinkValue->Buffer,
                                       NtLinkValue,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    return TRUE;
}


BOOL
CreateSymbolicLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpLinkValue,
    BOOLEAN IsMountPoint,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A symbolic link is established using CreateSymbolicLink.

Arguments:

    lpLinkName - Supplies the DOS file name where the symbolic link is desired.  This
        name must not exists as a file/directory.

    lpLinkValue - Points to an DOS name which is the value of the symbolic link.  This
        name may or may not exist.

    lpSecurityAttributes - Points to a SECURITY_ATTRIBUTES structure that specifies
        the security attributes for the directory to be created. The file system must
        support this parameter for it to have an effect.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ULONG FileAttributes;
    ULONG OpenOptions;
    ULONG ReparseDataLength;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    //
    // Ensure that both names were passed.
    //

    if (!ARGUMENT_PRESENT( lpLinkName ) || !ARGUMENT_PRESENT( lpLinkValue )) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    //
    // Convert link name and value paths into NT versions
    //

    DosLinkValue.Buffer = FullPathLinkValue;
    DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
    DosLinkValue.Length = 0;
    if (!MassageLinkValue( lpLinkName,
                           lpLinkValue,
                           &NtLinkName,
                           &NtLinkValue,
                           &DosLinkValue
                         )
       ) {
        if (DosLinkValue.Length == 0) {
            SetLastError( ERROR_INVALID_NAME );
            }
        else {
            SetLastError( ERROR_PATH_NOT_FOUND );
            }

        RtlFreeUnicodeString( &NtLinkName );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtLinkName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    if (ARGUMENT_PRESENT( lpSecurityAttributes )) {
        ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE;

    //
    // Open link name.  Must NOT exist.
    //

    Status = NtCreateFile( &FileHandle,
                           FILE_LIST_DIRECTORY | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES |
                                FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_CREATE,
                           OpenOptions,
                           NULL,
                           0
                         );

    //
    // Free the buffer for the link name as we are done with it.
    //

    RtlFreeUnicodeString( &NtLinkName );

    if (!NT_SUCCESS( Status )) {
        SetLastError( ERROR_INVALID_NAME );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    //
    // Allocate a buffer to set the reparse point.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer) -
                         REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        NtLinkValue.Length + sizeof(UNICODE_NULL) +
                        DosLinkValue.Length + sizeof(UNICODE_NULL);
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
        RtlAllocateHeap( RtlProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength
                       );
    if (ReparseBufferHeader == NULL) {
        NtClose( FileHandle );
        RtlFreeUnicodeString( &NtLinkValue );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    //
    // Set the reparse point with symbolic link tag.
    //

    if (IsMountPoint) {
        ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
        }
    else {
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // No support for symbolic links in NT 5.0 Beta 1
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //
        // ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SYMBOLIC_LINK;
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = NtLinkValue.Length;
    RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                   NtLinkValue.Buffer,
                   NtLinkValue.Length
                 );
    RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                     NtLinkValue.Length + sizeof(UNICODE_NULL),
                   DosLinkValue.Buffer,
                   DosLinkValue.Length
                 );
    RtlFreeUnicodeString( &NtLinkValue );

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_SET_REPARSE_POINT,
                              ReparseBufferHeader,
                              REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength,
                              NULL,
                              0
                            );

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    NtClose( FileHandle );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    return TRUE;
}


BOOL
SetSymbolicLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpLinkValue
    )

/*++

Routine Description:

    A symbolic link is established using CreateSymbolicLink.

Arguments:

    lpLinkName - Supplies the DOS file name where the symbolic link is located.  This
        name must exist as a symbolic link to a file/directory.

    lpLinkValue - Points to an DOS name which is the value of the symbolic link.  This
        name may or may not exist.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ACCESS_MASK FileAccess;
    ULONG OpenOptions;
    ULONG ReparseDataLength;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    //
    // Ensure that link name was passed.
    //

    if (!ARGUMENT_PRESENT( lpLinkName )) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    //
    // Convert link name and value paths into NT versions
    //

    DosLinkValue.Buffer = FullPathLinkValue;
    DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
    DosLinkValue.Length = 0;
    if (!MassageLinkValue( lpLinkName,
                           lpLinkValue,
                           &NtLinkName,
                           &NtLinkValue,
                           &DosLinkValue
                         )
       ) {
        if (DosLinkValue.Length == 0) {
            SetLastError( ERROR_INVALID_NAME );
            }
        else {
            SetLastError( ERROR_PATH_NOT_FOUND );
            }

        RtlFreeUnicodeString( &NtLinkName );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtLinkName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_FOR_BACKUP_INTENT |
                  FILE_OPEN_REPARSE_POINT |
                  FILE_SYNCHRONOUS_IO_NONALERT |
                  FILE_NON_DIRECTORY_FILE;

    //
    // If no link value specified, then deleting the link
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        FileAccess = DELETE | SYNCHRONIZE;
        }
    else {
        FileAccess = FILE_WRITE_DATA | FILE_READ_ATTRIBUTES |
                     FILE_WRITE_ATTRIBUTES | SYNCHRONIZE;
        }

    //
    // Open link name.  Must exists.
    //

    Status = NtOpenFile( &FileHandle,
                         FileAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         OpenOptions
                       );

    //
    // Free the buffer for the link name as we are done with it.
    //

    RtlFreeUnicodeString( &NtLinkName );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString( &NtLinkValue );
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        FILE_DISPOSITION_INFORMATION Disposition;
        //
        // Delete the link
        //
#undef DeleteFile
        Disposition.DeleteFile = TRUE;

        Status = NtSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       &Disposition,
                                       sizeof( Disposition ),
                                       FileDispositionInformation
                                     );
        NtClose( FileHandle );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }
        else {
            return TRUE;
            }
        }

    //
    // Allocate a buffer to set the reparse point.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer) -
                         REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        NtLinkValue.Length + sizeof(UNICODE_NULL) +
                        DosLinkValue.Length + sizeof(UNICODE_NULL);
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
        RtlAllocateHeap( RtlProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength
                       );
    if (ReparseBufferHeader == NULL) {
        RtlFreeUnicodeString( &NtLinkValue );
        NtClose( FileHandle );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    //
    // Set the reparse point with symbolic link tag.
    //

    ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SYMBOLIC_LINK;
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = NtLinkValue.Length;
    RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                   NtLinkValue.Buffer,
                   NtLinkValue.Length
                 );
    RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                     NtLinkValue.Length + sizeof(UNICODE_NULL),
                   DosLinkValue.Buffer,
                   DosLinkValue.Length
                 );
    RtlFreeUnicodeString( &NtLinkValue );

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_SET_REPARSE_POINT,
                              ReparseBufferHeader,
                              REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength,
                              NULL,
                              0
                            );

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    NtClose( FileHandle );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    return TRUE;
}




DWORD
QuerySymbolicLinkW(
    LPCWSTR lpLinkName,
    LPWSTR lpBuffer,
    DWORD nBufferLength
    )

/*++

Routine Description:

    An existing file can be queried for its symbolic link value using QuerySymbolicLink.

Arguments:

    lpLinkName - Supplies the file name of the file to be queried.

    lpBuffer - Points to a buffer where the symbolic link is to be returned.

    nBufferSize - Length of the buffer being passed by the caller.

Return Value:

    If the function suceeds, the return value is the length, in characters, of the
    string copied to lpBuffer, not including the terminating null character. If the
    lpBuffer is too small, the return value is the size of the buffer, in characters,
    required to hold the name.

    Zero is returned if the operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ULONG OpenOptions;
    PWSTR pathBuffer;
    USHORT pathLength;
    USHORT NtPathLength;
    USHORT ReturnLength;
    PVOID FreeBuffer;
    REPARSE_DATA_BUFFER ReparseInfo;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;

    if (!ARGUMENT_PRESENT( lpLinkName )) {
        SetLastError( ERROR_INVALID_NAME );
        return 0;
        }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U( lpLinkName,
                                                              &FileName,
                                                              NULL,
                                                              &RelativeName
                                                            );

    if (!TranslationStatus) {
        SetLastError( ERROR_PATH_NOT_FOUND );
        return 0;
        }
    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL
                              );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    //
    // Open as file for read access.
    //

    Status = NtOpenFile( &FileHandle,
                         FILE_READ_DATA | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         OpenOptions | FILE_NON_DIRECTORY_FILE
                       );

    //
    // Free the buffer for the name as we are done with it.
    //

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );

    if (!NT_SUCCESS( Status )) {
        SetLastError( ERROR_INVALID_NAME );
        return 0;
        }

    //
    // Query with zero length to get reparse point tag and required buffer length
    //

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_GET_REPARSE_POINT,
                              NULL,
                              0,
                              (PVOID)&ReparseInfo,
                              sizeof( ReparseInfo )
                            );

    //
    // Verify that the reparse point buffer brings back a symbolic link or a
    // mount point, and that we got the required buffer length back via 
    // IoStatus.Information
    //

    ReparseBufferHeader = NULL;
    if ((Status != STATUS_BUFFER_OVERFLOW) ||
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // No support for symbolic links in NT 5.0 Beta 1
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //
        // (ReparseInfo.ReparseTag != IO_REPARSE_TAG_SYMBOLIC_LINK) ||
        //
        (ReparseInfo.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT)
       ) {
        Status = STATUS_OBJECT_NAME_INVALID;
        }
    else {
        //
        // Allocate a buffer to hold reparse point information
        //

        ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
            RtlAllocateHeap( RtlProcessHeap(),
                             0,
                             REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseInfo.ReparseDataLength
                           );
        if (ReparseBufferHeader == NULL) {
            //
            // Not enough memory.  Fail the call.
            //

            Status = STATUS_NO_MEMORY;
            }
        else {
            //
            // Now query the reparse point information into our allocated buffer.
            // This should not fail.
            //

            Status = NtFsControlFile( FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      FSCTL_GET_REPARSE_POINT,
                                      NULL,
                                      0,
                                      (PVOID)ReparseBufferHeader,
                                      REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseInfo.ReparseDataLength
                                    );
            }
        }

    //
    // Done with file handle.
    //

    NtClose( FileHandle );

    //
    // Return any failure to caller
    //

    if (!NT_SUCCESS( Status )) {
        if (ReparseBufferHeader != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
            }

        return 0;
        }

    //
    // See if this is an old style symbolic link reparse point, which only stored the
    // NT path name.  If so, return an error, as we dont have a DOS path to return
    //

    pathBuffer = (PWSTR)(
                    (PCHAR)ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer +
                    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset
                    );
    pathLength = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;

    //
    // Sanity check the length. As the tag is fine we do not zero the buffer.
    //

    ReturnLength = pathLength / sizeof( WCHAR );

    //
    // If amount to return is less than callers buffer length, copy the Dos path
    // to the callers buffer
    //

    if (ReturnLength < nBufferLength) {
        RtlMoveMemory( (PUCHAR)lpBuffer,
                       (PCHAR)pathBuffer,
                       pathLength
                     );
        }
    else {
        //
        // If we are failing for insufficient buffer length, tell them how much
        // space they really need including the terminating null character.
        //
        ReturnLength += 1;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        }

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    return ReturnLength;
}


VOID
GetCommandLineArgs(
    LPDWORD NumberOfArguments,
    LPWSTR Arguments[]
    )
{
    LPWSTR  lpstrCmd;
    WCHAR   ch;
    WCHAR   ArgumentBuffer[ MAX_PATH ];
    LPWSTR  p;

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
       }
    while (ch != L' ' && ch != L'\t' && ch != L'\0');

    *NumberOfArguments = 0;
    while (ch != '\0') {
        //  skip over any following white space
        while (ch != L'\0' && _istspace(ch)) {
            ch = *lpstrCmd++;
        }
        if (ch == L'\0') {
            break;
        }

        p = ArgumentBuffer;
        do {
            *p++ = ch;
            ch = *lpstrCmd++;
        } while (ch != L' ' && ch != L'\t' && ch != L'\0');
        *p = L'\0';
        Arguments[ *NumberOfArguments ] = malloc( (_tcslen( ArgumentBuffer ) + 1) * sizeof( WCHAR ) );
        if (Arguments[ *NumberOfArguments ]) {
            _tcscpy( Arguments[ *NumberOfArguments ], ArgumentBuffer );
            *NumberOfArguments += 1;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\symlink\common.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

VOID
GetCommandLineArgs(
    LPDWORD NumberOfArguments,
    LPWSTR Arguments[]
    );

//
// API calls to create and query symbolic links and to create hard links.
//

BOOL
CreateSymbolicLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpLinkValue,
    BOOLEAN IsMountPoint,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
SetSymbolicLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpLinkValue
    );

DWORD
QuerySymbolicLinkW(
    LPCWSTR lpExistingName,
    LPWSTR lpBuffer,
    DWORD nBufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\symlink\symlink.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a task killer application.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "common.h"

VOID
Usage(
    VOID
    );

DWORD NumberOfArguments;
PWSTR Arguments[ 128 ];

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    PWSTR s, *pArgs;
    BOOLEAN IsMountPoint = FALSE;
    PWSTR LinkName, TargetPath;
    WCHAR TargetPathBuffer[ MAX_PATH ];

    GetCommandLineArgs( &NumberOfArguments, Arguments );

    if (NumberOfArguments == 0) {
        Usage();
        return 1;
        }

    pArgs = &Arguments[ 0 ];
    s = *pArgs;
    if (s && (*s == L'-' || *s == L'/')) {
        _tcslwr( ++s );
        if (*s == L'm') {
            IsMountPoint = TRUE;
            NumberOfArguments -= 1;
            s = *++pArgs;
            }
        else
        if (*s == L'?') {
            Usage();
            return 0;
            }
        else {
            Usage();
            return 1;
            }
        }

    if (NumberOfArguments > 2) {
        Usage();
        return 1;
        }

    LinkName = s;
    if (NumberOfArguments == 2) {
        TargetPath = *++pArgs;
        CreateSymbolicLinkW( LinkName, TargetPath, IsMountPoint, NULL );
        }
    else {
        QuerySymbolicLinkW( LinkName, TargetPathBuffer, MAX_PATH );
        }
    return 0;
}


VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr, "Microsoft (R) Windows NT (TM) Version 5.0 MKLNK\n" );
    fprintf( stderr, "Copyright (C) 1997 Microsoft Corp. All rights reserved\n\n" );
    fprintf( stderr, "usage: SYMLINK [-m] fileName [targetPath]\n\n" );
    fprintf( stderr, "           -m specifies to create a mount point link\n" );
    fprintf( stderr, "              instead of a symbolic link\n\n" );
    fprintf( stderr, "           fileName\n" );
    fprintf( stderr, "              This is the name of the symbolic link\n" );
    fprintf( stderr, "               to be created, modified or queried.\n" );
    fprintf( stderr, "               \n" );
    fprintf( stderr, "           targetPath\n" );
    fprintf( stderr, "              If not specified, this program displays\n" );
    fprintf( stderr, "              the current targetPath associated with \n" );
    fprintf( stderr, "              the named symbolic link.\n" );
    fprintf( stderr, "              If specified, either creates a new symbolic\n" );
    fprintf( stderr, "              link that points to this targetPath\n" );
    fprintf( stderr, "              or if the named symbolic link already exists,\n" );
    fprintf( stderr, "              modifies its targetPath to the new value.\n" );
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sync\sync.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sync.c

Abstract:

    This is the main module for the Win32 sync command.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include "sync.h"


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    BOOLEAN fEject;
    char *p;
    int i;
    char c;
    char DrivePath[ 4 ];

    if (argc > 1 &&
        (!_stricmp( argv[1], "-e" ) || !_stricmp( argv[1], "/e" ))
       ) {
        argc -= 1;
        argv += 1;
        fEject = TRUE;
        }
    else {
        fEject = FALSE;
        }

    if ( argc > 1 ) {
        while (--argc) {
            p = *++argv;
            if ( isalpha(*p) ) {
                sprintf( DrivePath, "%c:", *p );
                SyncVolume( DrivePath, fEject );
                }
            }
        }
    else {
        for(i=0;i<26;i++){
            c = (CHAR)i + (CHAR)'a';
            sprintf( DrivePath, "%c:", i+'A' );
            switch (GetDriveType( DrivePath )) {
            case DRIVE_REMOVABLE:
                if (i <2) {
                    break;
                    }

            case DRIVE_FIXED:
                SyncVolume( DrivePath, fEject );
                break;
            }
        }
    }

    return( 0 );
}

void
SyncVolume(
    PCHAR DrivePath,
    BOOLEAN EjectMedia
    )
{
    UCHAR VolumePath[16];
    HANDLE VolumeHandle;
    DWORD ReturnedByteCount;


    _strupr( DrivePath );
    sprintf( VolumePath, "\\\\.\\%s", DrivePath );
    VolumeHandle = CreateFile( VolumePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                             );
    if (VolumeHandle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "SYNC: Unable to open %s volume (%u)\n", DrivePath, GetLastError() );
        return;
        }

    printf( "Syncing %s ... ", DrivePath );
    if (!FlushFileBuffers( VolumeHandle )) {
        printf( "flush failed (%u)\n", GetLastError() );
        }
    else
    if (!DeviceIoControl( VolumeHandle,
                          FSCTL_LOCK_VOLUME,
                          NULL,
                          0,
                          NULL,
                          0,
                          &ReturnedByteCount,
                          NULL
                        )
       ) {
        printf( "lock volume failed (%u)\n", GetLastError() );
        }
    else
    if (!DeviceIoControl( VolumeHandle,
                          FSCTL_DISMOUNT_VOLUME,
                          NULL,
                          0,
                          NULL,
                          0,
                          &ReturnedByteCount,
                          NULL
                        )
       ) {
        printf( "dismount volume failed (%u)\n", GetLastError() );
        }
    else
    if (EjectMedia && !DeviceIoControl( VolumeHandle,
                                        IOCTL_DISK_EJECT_MEDIA,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        &ReturnedByteCount,
                                        NULL
                                      )
       ) {
        printf( "eject media failed (%u)\n", GetLastError() );
        }
    else {
        printf( "done.  Okay to remove drive.\n" );
        }

    CloseHandle( VolumeHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sync\sync.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winnt.h

Abstract:

    This is the main header file for the Win32 sync command.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


int
ProcessParameters(
    int argc,
    char *argv[]
    );

void
SyncVolume( PCHAR DrivePath, BOOLEAN EjectMedia );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\cmdline.h ===
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

struct ARGUMENTS
{
   char *szArg;
   short sArgumentNumber;
   ARGUMENTS *pNext;
   ARGUMENTS *pPrevious;
};

class kCommandLine
{
private:
    short sNumberOfArgs;
    short sNumberOfDrives;
    ARGUMENTS *pArgListBegin;
    ARGUMENTS *pArgListCurrent;
    void Add(char *wszArgpass);
    void Remove(ARGUMENTS *);
    void FindLast();
    WORD FillArgumentList();
    void DebugOutf(char *szFormat, ...);
    ARGUMENTS *GetNext();
    ARGUMENTS *GetPrevious();

public:
    char *szCommandLine;
    char *GetNextArgument();
    void Rewind();
    char *GetSwitchValue(char *, BOOL bCaseInsensitive);
    BOOL IsSpecified(char *, BOOL bCaseInsensitive);
    char *GetArgumentByNumber(WORD wArgNum);
    WORD GetArgumentNumber(TCHAR *Argument, BOOL CaseInsensitive);
    WORD GetNumberOfArguments();
    kCommandLine();
    ~kCommandLine();
      
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\cmdline.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "cmdline.h"

kCommandLine::kCommandLine()
{
    pArgListBegin = (ARGUMENTS *)malloc(sizeof(ARGUMENTS));
    
    if(pArgListBegin) {	
    	pArgListBegin->pNext = NULL;
    	pArgListBegin->szArg = NULL;
    	pArgListBegin->sArgumentNumber = 0;
    	pArgListBegin->pPrevious = NULL;
    	pArgListCurrent = pArgListBegin;
	
        sNumberOfDrives = 0;
        szCommandLine = (char *)malloc((lstrlen(GetCommandLine()) + sizeof(TCHAR)));
    
        if(szCommandLine) {
    	    lstrcpy(szCommandLine, (char *)GetCommandLine());
    	
            if (sNumberOfArgs = GetNumberOfArguments()) {
                WORD wArgNums = 0;   
                wArgNums = FillArgumentList();
            }
        }
    }
}

kCommandLine::~kCommandLine()
{
    if(szCommandLine)
    	free (szCommandLine);
    Rewind();
    if(pArgListCurrent->szArg)
    	free (pArgListCurrent->szArg);
    while (GetNext())
    {
        if(pArgListCurrent->pPrevious)
        	free (pArgListCurrent->pPrevious);  
        if(pArgListCurrent->szArg)
        	free (pArgListCurrent->szArg);
    }
    if(pArgListCurrent)
    	free (pArgListCurrent);
}

void kCommandLine::DebugOutf(char *szFormat, ...)
{
    char szBuffer[MAX_PATH * 4];
    va_list va;
    va_start (va,szFormat);
    vsprintf (szBuffer, szFormat, va);
    va_end (va);
#ifdef DEBUG
    OutputDebugString (szBuffer);
#endif
}

WORD kCommandLine::GetNumberOfArguments()
{
    WORD wSpaceCounter = 0;
    for (WORD wCounter = 4; szCommandLine[wCounter] !=NULL; wCounter++)
        if ( ((szCommandLine[wCounter]=='/') || (szCommandLine[wCounter]=='-')) && szCommandLine[wCounter+1]!=NULL)
            wSpaceCounter++;
    return wSpaceCounter;
}

WORD kCommandLine::FillArgumentList()
{
    WORD wCounter;
    WORD TKCounter;
    WORD wArgNumCounter = 0;
    char szHolder[MAX_PATH * 2];
    szHolder[0] = NULL;
    wCounter = 4;

    for (Rewind(); szCommandLine[wCounter] != NULL; wCounter++)
    {
        if(szCommandLine[wCounter] == '/')
        {
            {
            WORD TempwCounter;
            WORD TempHolderCounter;
            TCHAR TempHolder[MAX_PATH];
            TempHolderCounter = 0;
            TempwCounter=wCounter;
            while ( (szCommandLine[TempwCounter] != ' ') && (szCommandLine[TempwCounter] != NULL) )
            {
                TempHolder[TempHolderCounter] = szCommandLine[TempwCounter];
                TempHolderCounter++;
                TempwCounter++;
            }
            TempHolder[TempHolderCounter] = '\0';
            if (' ' == TempHolder[strlen(TempHolder) - 1])
            {
                TempHolder[strlen(TempHolder)-1] = '\0';
            }
            Add(TempHolder);
            wCounter = TempwCounter;
            }

            while ( (szCommandLine[wCounter] != NULL) && (szCommandLine[wCounter] != ' ') )
            {
                wCounter++;
            }
            wCounter++;
            wArgNumCounter++;
            WORD wTK=0;
            for (TKCounter = 0; TKCounter < 256; TKCounter++)
            {
                szHolder[TKCounter] = '\0';
            }
            while ( (szCommandLine[wCounter] != '/') && (szCommandLine[wCounter] != NULL) )
            {
                szHolder[wTK] = szCommandLine[wCounter];
                wCounter++;
                wTK++;
            }
            if (szHolder[wTK] == ' ')
            {
                szHolder[wTK-1] = NULL;
            }
            if (' ' == szHolder[strlen(szHolder) - 1])
            {
                szHolder[strlen(szHolder)-1] = '\0';
            }
            Add(szHolder);
            wCounter--;
        }
    }//end of for loop
#ifdef _DEBUG
    DebugOutf("FillArgumentList=%d\r\n",wArgNumCounter);
#endif
    return wArgNumCounter;
}

void kCommandLine::Rewind()
{
    pArgListCurrent=pArgListBegin;
}

void kCommandLine::Add(char *szArgpass)
{

    //MessageBox(GetFocus(), szArgpass, "Add", MB_OK);

    FindLast();
    if (pArgListCurrent != pArgListBegin)
    {
        pArgListCurrent->pNext = (ARGUMENTS *)malloc(sizeof ARGUMENTS);
        if(!pArgListCurrent->pNext)
        	return;
        pArgListCurrent->pNext->pPrevious = pArgListCurrent;
        pArgListCurrent = pArgListCurrent->pNext;
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass) + 1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = pArgListCurrent->pPrevious->sArgumentNumber + 1;
    }
    else if (pArgListCurrent==pArgListBegin && !pArgListCurrent->szArg)
    {
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass)+1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = 1;
        pArgListCurrent->pPrevious = NULL;
    }
    else if (pArgListCurrent == pArgListBegin && pArgListCurrent->szArg)
    {
        pArgListCurrent->pNext = (ARGUMENTS *)malloc(sizeof ARGUMENTS);
        if(!pArgListCurrent->pNext)
        	return;
        pArgListCurrent->pNext->pPrevious = pArgListCurrent;
        pArgListCurrent = pArgListCurrent->pNext;
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass)+1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = 2;
    }
#ifdef _DEBUG
    DebugOutf("Arg[%d]=|%s|",pArgListCurrent->sArgumentNumber, pArgListCurrent->szArg);
    DebugOutf(" ArgPass=|%s|\r\n",szArgpass);
#endif
}

void kCommandLine::FindLast()
{
    for(Rewind(); pArgListCurrent->pNext; pArgListCurrent=pArgListCurrent->pNext);
}

WORD kCommandLine::GetArgumentNumber(TCHAR *Argument, BOOL CaseInsensitive)
{
    TCHAR Temp[MAX_PATH * 4];
   
    if (!Argument) 
        return 0;
    Rewind();
    if (CaseInsensitive)
    {
        _strlwr (Argument);
    }
    while (pArgListCurrent)
    {
        if (pArgListCurrent->szArg)
        {
            lstrcpy(Temp, pArgListCurrent->szArg);
            _strlwr(Temp);
            if (!lstrcmp(Temp, Argument))
            {
                return pArgListCurrent->sArgumentNumber;
            }
        }
        pArgListCurrent=pArgListCurrent->pNext;
    }
    return 0;
}

char *kCommandLine::GetNextArgument()
{
    if (pArgListCurrent->pNext)
    {
        pArgListCurrent = pArgListCurrent->pNext;
        return pArgListCurrent->szArg;
    }
    else 
        return NULL;
}

char *kCommandLine::GetSwitchValue(char *szArgpass, BOOL bCaseInsensitive)
{
    Rewind();
    if (bCaseInsensitive)
        _strlwr(szArgpass);
    if (pArgListCurrent->szArg)
    {
        if (!strcmp(szArgpass, pArgListCurrent->szArg) && pArgListCurrent->pNext)
        {
            return pArgListCurrent->pNext->szArg;
        }
        while (GetNext())
        {
            if (!strcmp(szArgpass, pArgListCurrent->szArg) && pArgListCurrent->pNext)
                return pArgListCurrent->pNext->szArg;
        }
    }
    //fallthrough
    return NULL;
}

char *kCommandLine::GetArgumentByNumber(WORD wNumber)
{
    Rewind();
    if (pArgListCurrent->szArg)
    {
        if (pArgListCurrent->sArgumentNumber == wNumber)
        {
            return pArgListCurrent->szArg;
        }
        while (GetNext())
        {
            if (pArgListCurrent->sArgumentNumber == wNumber)
            {
                return pArgListCurrent->szArg;
            }
        }
    }
    //fallthrough
    return NULL;
}

BOOL kCommandLine::IsSpecified(char *szArgpass, BOOL bCaseInsensitive)
{
    char szTemp[MAX_PATH * 4];
    Rewind();
    if (bCaseInsensitive)
        _strlwr(szArgpass);
    if (pArgListCurrent->szArg)
    {
        strcpy(szTemp, pArgListCurrent->szArg);
        if (bCaseInsensitive)
            _strlwr(szTemp);
        //MessageBox(GetFocus(), szArgpass, szTemp, MB_OK);
        if (!strcmp(szArgpass, szTemp))
            return TRUE;
        while (GetNext()) 
        {
            strcpy(szTemp, pArgListCurrent->szArg);
            if (bCaseInsensitive)
                _strlwr(szTemp);
            //MessageBox(GetFocus(), szArgpass, szTemp, MB_OK);
            if (!strcmp(szArgpass, szTemp))
                return TRUE;
        }
    }
    //fallthrough
    return FALSE;
}

ARGUMENTS *kCommandLine::GetNext()
{
    if (pArgListCurrent->pNext)
        pArgListCurrent = pArgListCurrent->pNext;
    else
        return NULL;
    return pArgListCurrent;
}

ARGUMENTS *kCommandLine::GetPrevious()
{
    if (pArgListCurrent->pPrevious)
        pArgListCurrent = pArgListCurrent->pPrevious;
    else
        return NULL;
    return pArgListCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\devwalk.cpp ===
#include "globals.h"

kWin9xDevWalk::kWin9xDevWalk(kLogFile *Proc)
{
    LogProc=Proc;
}

kWin9xDevWalk::~kWin9xDevWalk()
{
}

int kWin9xDevWalk::Go()
{
    if(!LoadResourceFile ("c:\\syspar16.exe", "EXEResource1" ))
        return FALSE;

    _spawnl (_P_WAIT, "c:\\syspar16.exe", "c:\\syspar16.exe", "_spawnl", "two", NULL);
    AppendToLogFile("c:\\sp16temp.tmz");

    DeleteFile ("c:\\sp16temp.tmz");
    DeleteFile ("c:\\syspar16.exe");
    return TRUE;
}

BOOL kWin9xDevWalk::LoadResourceFile(PSTR FilePath,PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    HANDLE hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
    {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}

kNT5DevWalk::kNT5DevWalk(kLogFile *Proc)
{
LogProc=Proc;
}

kNT5DevWalk::~kNT5DevWalk()
{
}

int kNT5DevWalk::Go()
{
    if(!LoadResourceFile("c:\\syspar32.exe", "EXEResource2" ))
        return FALSE;
    
    _spawnl(_P_WAIT, "c:\\syspar32.exe", "c:\\syspar32.exe", "_spawnl", "two", NULL);
    AppendToLogFile("c:\\sp32temp.tmz");
    DeleteFile("c:\\sp32temp.tmz");
    DeleteFile("c:\\syspar32.exe");
    return TRUE;
}

BOOL kNT5DevWalk::LoadResourceFile(PSTR FilePath,PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    HANDLE hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
    {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}

void kNT5DevWalk::AppendToLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

void kWin9xDevWalk::AppendToLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

//DWORD WalkLogConfForResources(

/*
DWORD EnumerateClasses(ULONG ulIndex)
{
GUID *pClassID=(GUID*)malloc(sizeof(GUID));
char szBuf[500];
ULONG ulSize=499;
DWORD dwRet=0;

dwRet=CM_Enumerate_Classes(ulIndex, pClassID, 0);
CM_Get_Class_Name(pClassID, szBuf, &ulSize, 0);
//printf("CLASS = %s\r\n", szBuf);
GetClassDevs(szBuf);
return dwRet;
}

DWORD GetClassDevs(CHAR *szClassName)
{
HDEVINFO hDevInfo;
LPGUID pguid;
DWORD dwSize=0;
SetupDiClassGuidsFromName(szClassName, pguid, 100, &dwSize);
//SetupDiBuildClassInfoList(NULL, pguid, 1, &dwSize);
//hDevInfo = SetupDiGetClassDevs(szClassName, NULL, NULL, DIGCF_ALLCLASSES);
printf("Need %d more GUIDs for class %s \r\n", dwSize, szClassName);
hDevInfo = SetupDiGetClassDevs(pguid, NULL, NULL, NULL);
printf("hDevInfo=%d\r\n",hDevInfo);
printf("GUid? %c%c%c%c%c%c%c\r\n", pguid->Data4[0],
   pguid->Data4[1], 
   pguid->Data4[2], 
   pguid->Data4[3], 
   pguid->Data4[4], 
   pguid->Data4[5], 
   pguid->Data4[6],  
   pguid->Data4[7]);
return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\genapwlk.cpp ===
// General app walking helper routines to be used in 9xapwlk.cpp and ntappwlk.cpp
#include "globals.h"
#include <objidl.h>


CLASS_GeneralAppWalk::CLASS_GeneralAppWalk(kLogFile *Proc, HWND hIn)
{
    LogProc=Proc;
    gHandleToMainWindow=hIn;
}

BOOL CLASS_GeneralAppWalk::OpenRegistry(void)
{
   DWORD Return;

   lstrcpy(RootKeyString, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
   Return=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
         RootKeyString,
         0,
         KEY_READ,
         &HandleToUninstallKeyRoot);
   if (Return==ERROR_SUCCESS)
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
   return TRUE;
}

BOOL CLASS_GeneralAppWalk::Walk(void)
{
if (OpenRegistry())
   {
   CurrentKey=0;
   LogProc->LogString(",#Uninstall_APPS,,\r\n");
   while ( TRUE == NextKey() );
   RegCloseKey(HandleToUninstallKeyRoot);
   }
return WalkStartMenu();
}

BOOL CLASS_GeneralAppWalk::NextKey(void) {
    PTCHAR KeyName = NULL;
    DWORD SizeOfName = MAX_PATH * 4;
    
    if(!GetCurrentWinDir())
        return FALSE;

    KeyName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!KeyName)
        return FALSE;
  
    if (ERROR_SUCCESS != RegEnumKeyEx(HandleToUninstallKeyRoot, CurrentKey, KeyName, &SizeOfName, NULL, NULL, NULL, NULL)) {
        HeapFree(GetProcessHeap(), NULL, KeyName);
        return FALSE;
    }
    
    CurrentKey++;
    GetUninstallValues(KeyName);
    HeapFree(GetProcessHeap(), NULL, KeyName);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::GetUninstallValues(TCHAR *KeyName)
{
   HKEY UninstallKey;
   char FullKey[1024];
   PUCHAR ProductName=(PUCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
   DWORD ProductSize=1024;
   DWORD Return=0;
   DWORD Type=REG_SZ;

   lstrcpy(FullKey, RootKeyString);
   lstrcat(FullKey, "\\");
   lstrcat(FullKey, KeyName);
   Return=RegOpenKeyEx(HKEY_LOCAL_MACHINE, FullKey, 0, KEY_READ, &UninstallKey);
   if (ERROR_SUCCESS == Return)
   {
      Return = RegQueryValueEx(UninstallKey, "DisplayName", NULL, &Type,
         ProductName, &ProductSize);
      if (ERROR_SUCCESS == Return)
      {
         LogProc->StripCommas((TCHAR*)ProductName);
//         printf("Product = %s\r\n", ProductName);
         LogProc->LogString(",%s,\r\n", ProductName);
         HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
         RegCloseKey(UninstallKey);
         return TRUE;
      }
      else
      {
//         printf("Product = %s\r\n", szName);
         LogProc->StripCommas((TCHAR*)KeyName);
         LogProc->LogString(",%s,\r\n", KeyName);
         HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
         RegCloseKey(UninstallKey);
         return TRUE;
         //Check for other ways to get product name
      }
   }
   else
   {
      HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
      RegCloseKey(UninstallKey);
      return FALSE;
   }
   HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
   RegCloseKey(UninstallKey);
   return FALSE;
}


BOOL CLASS_GeneralAppWalk::WalkStartMenu(void)
{
    LogProc->LogString(",#StartMenu_APPS,,\r\n");
    PTCHAR Windir = NULL;
    UINT Size = 512;

    if(!GetCurrentWinDir())
        return FALSE;

    Windir = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
    
    if(!Windir)
        return FALSE;

    wsprintf(Windir, "%s\\Start Menu", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    wsprintf(Windir, "%s\\profiles", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);
    
    wsprintf(Windir, "%s\\Documents and Settings", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    lstrcpy(Windir, g_WindowsDirectory);
    Windir[2]='\0';
    lstrcat(Windir, "\\Documents and Settings");
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    /*
    if (S_OK == SHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT, Windir)) {
        StartMenuLen = lstrlen(Windir);
        WalkDir(Windir, NULL);
    }

    if (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU,NULL, SHGFP_TYPE_CURRENT, Windir)) {
        StartMenuLen = lstrlen(Windir);
        WalkDir(Windir, NULL);
    }
    */

    HeapFree(GetProcessHeap(), NULL, Windir);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::WalkDir(TCHAR *TempPath, TCHAR *File)
{
    WORD PathLen;
    PTCHAR Path = NULL;
    HANDLE HandleToSearch;
    WIN32_FIND_DATA FindFile;
    TCHAR CurrentDirectory[MAX_PATH];
    Path = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH *4);

    if(!Path)
        return FALSE;
        
    SetErrorMode (SEM_FAILCRITICALERRORS);
    lstrcpy(Path, TempPath);
    PathLen = (UINT)lstrlen(Path);
    Path = Path + PathLen - 1;

    if (Path[0] != '\\')
        lstrcat(Path, "\\");
    Path = Path - PathLen + 1;

    if (File)
        lstrcat(Path, File);

    if (SetCurrentDirectory(Path))
    {
        GetCurrentDirectory(MAX_PATH, CurrentDirectory);
        HandleToSearch = FindFirstFile("*.*", &FindFile);
        if (lstrcmp(FindFile.cFileName,".") && lstrcmp(FindFile.cFileName,".."))
        {
            if ( FILE_ATTRIBUTE_DIRECTORY == (FindFile.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
            {
                WalkDir(Path, FindFile.cFileName);
            }
            else
            {
                TCHAR *cT1 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                TCHAR *cT2 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                lstrcpy(cT2, Path);
                if (cT2[lstrlen(cT2)-1] != '\\')
                    lstrcat(cT2, "\\");
                lstrcat(cT2, FindFile.cFileName);
                if (EndsInLnk(cT2))
                    ResolveIt(cT2, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT2);
            }
        }
        while (FindNextFile(HandleToSearch, &FindFile))
        {
            if (lstrcmp(FindFile.cFileName,".") && lstrcmp(FindFile.cFileName,".."))
            {
                if(FILE_ATTRIBUTE_DIRECTORY == (FindFile.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
                {
                    PathLen = (UINT)lstrlen(Path);
                    Path = Path + PathLen - 1;
                    if (Path[0] != '\\')
                        lstrcat(Path, "\\");
                    Path = Path - PathLen + 1;
                    WalkDir(Path, FindFile.cFileName);
            }
            else
            {
                TCHAR *cT1 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                TCHAR *cT2 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                lstrcpy(cT2, Path);
                if (cT2[lstrlen(cT2)-1] != '\\')
                    lstrcat(cT2, "\\");
                lstrcat(cT2, FindFile.cFileName);
                if (EndsInLnk(cT2))
                {
                    ResolveIt(cT2, cT1);
                }
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT2);
            }
        }
    }
    FindClose(HandleToSearch);
    }
    HeapFree(GetProcessHeap(), NULL, Path);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::EndsInLnk(TCHAR *File)
{
TCHAR szTO[1024];
lstrcpy(szTO, File);

if ( (szTO[lstrlen(szTO)-4] == '.') &&
   ((szTO[lstrlen(szTO)-3] == 'l') || (szTO[lstrlen(szTO)-3] == 'L')) &&
   ((szTO[lstrlen(szTO)-2] == 'n') || (szTO[lstrlen(szTO)-2] == 'N')) &&
   ((szTO[lstrlen(szTO)-1] == 'k') || (szTO[lstrlen(szTO)-1] == 'K')) )
   {
   return TRUE;
   }
else return FALSE;
}

HRESULT CLASS_GeneralAppWalk::ResolveIt(LPCSTR LinkFile, LPSTR Path)
{
    HRESULT HandleToResult;
    IShellLink *ShellLink;
    WIN32_FIND_DATA wfd;
    UINT uiPrevErrorMode = 0;
#ifdef MAXDEBUG
    LogProc->LogString("Working on %s:\r\n", lpszLinkFile);
#endif

    *Path = '\0';
    HandleToResult = CoInitialize(NULL);
    HandleToResult = CoCreateInstance(  CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IShellLink, (LPVOID *)&ShellLink );
    if (SUCCEEDED(HandleToResult))
    {
        IPersistFile *ppf;
        HandleToResult = ShellLink->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf );
        if (SUCCEEDED(HandleToResult))
        {
            WCHAR wsz[MAX_PATH];
            MultiByteToWideChar( CP_ACP, 0, LinkFile, -1, wsz, MAX_PATH );   // Load the file.
            HandleToResult = ppf->Load(wsz, STGM_READ );
            if (SUCCEEDED(HandleToResult))
            {
//              HandleToResult = ShellLink->Resolve(g_MainWindow, SLR_ANY_MATCH | SLR_NO_UI);
//              if (SUCCEEDED(HandleToResult))
//              {
                    HandleToResult = ShellLink->GetPath(Path, 1024, &wfd, SLGP_SHORTPATH );
                    //              HandleToResult = ShellLink->GetDescription(Path, 1024);
                    WORD wLen=(UINT)lstrlen(Path);
                    Path += wLen - 4;
                    TCHAR szExt[10];
                    lstrcpy (szExt, Path);
                    if ( (szExt[0] == '.') &&
                       ((szExt[1] == 'e') || (szExt[1] == 'E')) &&
                       ((szExt[2] == 'x') || (szExt[2] == 'X')) &&
                       ((szExt[3] == 'e') || (szExt[3] == 'E')) )
        //              if (!lstrcmp(lpszPath, ".EXE"))
                    {
                        uiPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                        Path -= wLen - 4;
                        LinkFile += StartMenuLen + 1;
    //                  LinkFile[strlen(lpszLinkFile)-4]='\0';
                        TCHAR szTemp[1024];
                        lstrcpy (szTemp, LinkFile);
                        szTemp[lstrlen (szTemp) - 4] = '\0';

                        //crop off preceding \'s
                        if (szTemp[0] == '\\')
                        {
                            TCHAR szTwo[1024];
                            for (DWORD dwi = 0; dwi<(DWORD)lstrlen (szTemp); dwi++)
                            {
                                szTwo[dwi] = szTemp[dwi + 1];
                            }
                            szTwo[dwi + 1] = '\0';
                            lstrcpy (szTemp, szTwo);
                        }
                        //crop off preceding \'s
                        if (szTemp[0] == '\\')
                        {
                            TCHAR szTwo[1024];
                            for (DWORD dwi=0; dwi<(DWORD)lstrlen(szTemp); dwi++)
                            {
                                szTwo[dwi]=szTemp[dwi+1];
                            }
                            szTwo[dwi+1]='\0';
                            lstrcpy(szTemp, szTwo);
                        }
                        // nuke duplicate \'s in file name
                        for (DWORD dwArgh = 0; dwArgh < 5; dwArgh++)
                        {
                            BOOL Glob1, Glob2, Glob3;
                            Glob1 = Glob2 = Glob3 =TRUE;
                            TCHAR szFin[1024];
                            for (DWORD dw1 = 0; (dw1 < (DWORD)lstrlen(szTemp)) && (Glob1 == TRUE); dw1++)
                            {
                                szFin[dw1] = szTemp[dw1];
                                if (szTemp[dw1] == '\\' && szTemp[dw1+1] == '\\')
                                {
                                    for (DWORD dwThree = 0; dwThree < (DWORD)lstrlen(szTemp); dwThree++)
                                    {
                                        szFin[dw1 + dwThree] = szTemp[dw1+dwThree + 1];
                                    }
                                szFin[dwThree + 1] = '\0';
                                lstrcpy (szTemp, szFin);
                                Glob1 = FALSE;
                                }
                            }
                        }

                        LogProc->StripCommas (szTemp);
                        LogProc->LogString(",%s", szTemp);
    #ifdef MAXDEBUG
                        LogProc->LogString("\r\nGetting version: %s\r\n", lpszLinkFile);
    #endif
                        GetAppVer (Path);
                        LinkFile -= StartMenuLen;
                        SetErrorMode(uiPrevErrorMode);

                    }
                    else
                    {
                        Path -= wLen - 4;
                    }
//              }
            }
        }
        ppf->Release();
    }
    ShellLink->Release();
    return HandleToResult;
}

BOOL CLASS_GeneralAppWalk::GetAppVer(LPSTR AppName)
{
    DWORD dwVerInfoSize;
    DWORD dwZero;
    LPVOID lpvFileInfo;
    DWORD dwRetCode;
    PDWORD pdwVerBuf;
    UINT uLen;
    DWORD dwTranslation;
    TCHAR szString[MAX_PATH * 4];
    TCHAR szFullString[MAX_PATH * 4];
    TCHAR szTempString[MAX_PATH * 4];

    dwVerInfoSize = GetFileVersionInfoSize(AppName, &dwZero);

    if (!dwVerInfoSize) {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        return TRUE;
    }
    
    lpvFileInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwVerInfoSize);

    if(!lpvFileInfo) {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        return TRUE;
    }        

    dwRetCode = GetFileVersionInfo(AppName, dwZero, dwVerInfoSize, lpvFileInfo);

    if (!dwRetCode)
    {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
        return TRUE;
    }

    uLen = 0;
    pdwVerBuf = 0;
    dwRetCode = VerQueryValue(lpvFileInfo, (LPSTR)"\\VarFileInfo\\Translation", (LPVOID*)&pdwVerBuf, &uLen);

    if (!dwRetCode || !pdwVerBuf)
    {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
        return TRUE;
    }
        
    dwTranslation = *pdwVerBuf;

    wsprintf (szString, "\\StringFileInfo\\%04x%04x\\", LOWORD (dwTranslation), HIWORD(dwTranslation));
    wsprintf (szFullString, "%sOriginalFileName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy (szTempString, (TCHAR *)pdwVerBuf);
          
        if (0 != lstrlen (szTempString) )
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }

    wsprintf(szFullString, "%sFileVersion", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);
            
        if (0 != lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }

    wsprintf(szFullString, "%sProductName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (0 != lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    wsprintf(szFullString, "%sProductVersion", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (0 != strlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    wsprintf(szFullString, "%sCompanyName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    LogProc->LogString(",\r\n");
    HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::GetCurrentWinDir(void)
{
    HINSTANCE hInst2 = NULL;
    LPFNDLLFUNC2 fProc = NULL;
    
    hInst2 = LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);

    if(hInst2)
        fProc = (LPFNDLLFUNC2)GetProcAddress(hInst2, "GetSystemWindowsDirectoryA");

    if(fProc) {
        if(!fProc(g_WindowsDirectory, MAX_PATH)) {
            FreeLibrary(hInst2);
            return FALSE;
        }
    }
    else {
        if(!GetWindowsDirectory(g_WindowsDirectory, MAX_PATH))
            return FALSE;
    }
    
    if ( '\\' == g_WindowsDirectory[lstrlen(g_WindowsDirectory) - sizeof(TCHAR)] ) {
        g_WindowsDirectory[lstrlen(g_WindowsDirectory) - sizeof(TCHAR)] = '\0';
    }
    
    if(hInst2)
        FreeLibrary(hInst2);
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\nt4dev.cpp ===
#include "globals.h"

kNT4DevWalk::kNT4DevWalk(kLogFile *Proc, HWND hIn)
{
LogProc=Proc;
hMainWnd=hIn;
}

BOOL kNT4DevWalk::Begin()
{
    DWORD dwRet = 0;
    dwCurrentKey = 0;
    dwLevel2Key = 0;
    lstrcpy(szRootKeyString, "SYSTEM\\CurrentControlSet\\Enum\\Root");

    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRootKeyString, 0, KEY_READ, &hkeyRoot))
        return REG_SUCCESS;
    else 
        return REG_FAILURE;
        
    return REG_FAILURE;
}

BOOL kNT4DevWalk::Walk()
{
    DWORD dwIndex = 0;
    PTCHAR pName = NULL, pFull = NULL;
    DWORD dwSizeName = MAX_PATH * 4;
    
    pName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeName);
    
    if(!pName)
        return FALSE;
        
    pFull = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeName);

    if(!pFull) {
        HeapFree(GetProcessHeap(), NULL, pName);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, dwIndex, pName, &dwSizeName, NULL, NULL, NULL, NULL)) {
        wsprintf(pFull, "SYSTEM\\CurrentControlSet\\Enum\\Root\\%s", pName);
            
        if (!lstrcmp(pName, "Control")) {
            GetKeyValues(pFull);
        }
            
        SearchSubKeys(pFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    
    HeapFree(GetProcessHeap(), NULL, pName);
    HeapFree(GetProcessHeap(), NULL, pFull);
    return TRUE;
}

BOOL kNT4DevWalk::SearchSubKeys(PTCHAR szName)
{
    HKEY hKeyTemp;
    DWORD dwIndex = 0;
    PTCHAR szName2 = NULL;
    DWORD dwSizeName = MAX_PATH * 4;
    
    szName2 = (PTCHAR)malloc(MAX_PATH * 4);
    
    if(!szName2)
        return FALSE;
        
    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hKeyTemp))
    {
        free(szName2);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hKeyTemp, dwIndex, szName2, &dwSizeName, NULL, NULL, NULL, NULL))
    {
        TCHAR szFull[MAX_PATH * 4];
        wsprintf(szFull, "%s\\%s", szName, szName2);

        if (ERROR_SUCCESS == lstrcmp(szName2, "Control"))
        {
            GetKeyValues(szName);
            SearchSubKeys(szFull);
            dwSizeName = MAX_PATH * 4;
            dwIndex++;
        }
    }
    free(szName2);
    return TRUE;
}

BOOL kNT4DevWalk::GetKeyValues(PTCHAR szName)
{
    HKEY hkeyUninstallKey;
    TCHAR szFullKey[MAX_PATH * 4];
    PTCHAR szProductName = NULL;
    DWORD dwProductSize = MAX_PATH * 4;
    DWORD dwType = REG_SZ;
    
    szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!szProductName)
        return FALSE;
        
    wsprintf(szFullKey, "%s\\%s", szRootKeyString, szName);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hkeyUninstallKey))
    {
        LogProc->LogString(",%s,", szName);
        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;
    
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "Class", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->LogString("%s,", szProductName);
        }         
        else 
        {
            LogProc->LogString("NULL,");
        }

        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "DeviceDesc", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");

        lstrcpy(szProductName, "");
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "HardWareID", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName)!=0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");
        
        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "Mfg", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");
        
        szProductName[0] = 0;
        wsprintf(szFullKey, "%s\\Control", szName);
        HKEY hkTemp;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkTemp))
        {
            dwProductSize = MAX_PATH * 4;

            if (ERROR_SUCCESS == RegQueryValueEx(hkTemp, "ActiveService", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
                && lstrlen(szProductName) != 0)
            {
                LogProc->StripCommas(szProductName);
                LogProc->LogString("%s,\r\n", szProductName);
            }         
            else
                LogProc->LogString("NULL,\r\n");
            
            szProductName[0] = 0;
            RegCloseKey(hkTemp);
        }
        else 
            LogProc->LogString("NULL,\r\n");
    }
    else 
    {
        HeapFree(GetProcessHeap(), NULL, szProductName);
        return REG_FAILURE;
    }

    HeapFree(GetProcessHeap(), NULL, szProductName);
    RegCloseKey(hkeyUninstallKey);
    return REG_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\geninfo.cpp ===
#include "globals.h"
#include "cmdline.h"
#include "resource.h"
#include <regstr.h>
TCHAR g_WindowsDirectory[MAX_PATH];
BOOL g_WalkStartMenu;
#define NOT_CASE_SENSITIVE TRUE
#define CASE_SENSITIVE FALSE
typedef struct MYTIMESTRUCT
{
	TCHAR szMonth[10];
	TCHAR szDay[10];
	TCHAR szYear[10];
	TCHAR szHour[10];
	TCHAR szMinute[10];
	TCHAR szSecond[10];
	TCHAR szMillisecond[10];
}MyTimeStruct;

PTCHAR GetUniqueFileName( void );
void FillMyTime(MYTIMESTRUCT *MyTime);

BOOL CLASS_GeneralInfo::Go(void)
{
   BOOL ReturnValue;
   HWND HandleToStatic;
   TCHAR Status[MAX_PATH * 4];
   CLASS_GeneralAppWalk AppWalk(LogProc, gHandleToMainWindow);
   kCommandLine CommandLine;
   HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_STATUS);
   wsprintf(Status, TEXT("Sysparse is now collecting information.  During this process, it will not respond to mouse or keyboard commands, and may appear to be hung for up to 15 minutes."));
   if(INVALID_HANDLE_VALUE != HandleToStatic)
      SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);
   HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_HELP);
   wsprintf(Status, TEXT(""));
   if(INVALID_HANDLE_VALUE != HandleToStatic)
      SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);

   ReturnValue = DetermineArgumentValidity();
   if (FALSE == ReturnValue) 
       return FALSE;
   ReturnValue = InitLogFile();
   if (FALSE == ReturnValue) 
       return FALSE;
   //
   // From this point forward we init'd the log file and will always write a section label and a value for each value request,
   // whether that value is a default (usually "Unknown" or "Blank") or the actual value requested.
   //
   
   WriteVersions();
   GetUUID();
   WriteArguments();
   WriteFreeDiskSpace();
   WriteVolumeType();
   WriteMemorySize();
   WriteOSVersion();

      
   switch (OSVersion)
   {
        case Win95:
        {
            TCHAR lWindir[MAX_PATH];
            HANDLE File;
            WIN32_FIND_DATA w32fd;

            GetSystemDirectory(lWindir, MAX_PATH);
            if ( '\\' == lWindir[lstrlen(lWindir)-1] )
            {
                lWindir[lstrlen(lWindir)-1]='\0';
            }
            lstrcat(lWindir, "\\cfgmgr32.dll");
            File = FindFirstFile(lWindir, &w32fd);
            if (INVALID_HANDLE_VALUE != File)
            {
                LogProc->LogString("\r\n,#Syspar32,,\r\n");
                kNT5DevWalk MainNT5DevWalk(LogProc);
                MainNT5DevWalk.Go();
            }
            else
            {
                LogProc->LogString("\r\n,#Syspar16,,\r\n");
                kWin9xDevWalk MainWin9xDevWalk(LogProc);
                MainWin9xDevWalk.Go();
            }
        break;              
        }
        case NT4:
        {
            kNT4DevWalk MainNT4DevWalk(LogProc, gHandleToMainWindow);
            if (MainNT4DevWalk.Begin())
                MainNT4DevWalk.Walk();
        break;
        }
        case Win2000:
        case Whistler:
        {
            LogProc->LogString("\r\n,#Syspar32,,\r\n");
            kNT5DevWalk MainNT5DevWalk(LogProc);
            MainNT5DevWalk.Go();
            kNT5NetWalk MainNT5NetWalk(LogProc, gHandleToMainWindow);
            if (MainNT5NetWalk.Begin()) 
                MainNT5NetWalk.Walk();
        break;
        }
        case Win98:
        {
            LogProc->LogString("\r\n,#Syspar32,,\r\n");
            kNT5DevWalk MainNT5DevWalk(LogProc);
            
            MainNT5DevWalk.Go();
        break;
        }
    }

    WIN32_FIND_DATA *fd2 = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    WIN32_FIND_DATA *fd3 = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!fd2)
        return FALSE;
    if(!fd3) {
        free(fd2);
        return FALSE;
    }
       
    FindFirstFile(LogProc->szFile, fd3);
    TCHAR szAr[MAX_PATH * 4];
    TCHAR szLogFilePath[MAX_PATH * 4];
    TCHAR szCurDirectory[MAX_PATH];

	//add specified file name 
	if (CommandLine.IsSpecified(TEXT("/n"),NOT_CASE_SENSITIVE))
		lstrcpy(szAr,CommandLine.GetSwitchValue(TEXT("/n"),NOT_CASE_SENSITIVE));
	else if (CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        // Whistler - Generate Unique filename (ComputerName+UserName+Time)
		lstrcpy(szAr, GetUniqueFileName());
	else
		lstrcpy(szAr, Profile);
	
	if (!(CommandLine.IsSpecified(TEXT("/x"),NOT_CASE_SENSITIVE)))
		lstrcat(szAr, PlatformExtension);
	
    szAr[8]='\0';

	if(CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE))
        lstrcpy(szLogFilePath, CommandLine.GetSwitchValue(TEXT("/w"),NOT_CASE_SENSITIVE));
    else
      	lstrcpy(szLogFilePath, WindowsDirectory);

	//	if(GetCurrentDirectory(MAX_PATH, szCurDirectory))
	//		lstrcpy(szArp, szCurDirectory);
			
	if(szLogFilePath[lstrlen(szLogFilePath) - 1] != '\\')
        lstrcat(szLogFilePath, "\\");

   	lstrcat(szLogFilePath, szAr);

    if (CommandLine.IsSpecified(TEXT("/l"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFilePath, ".log");
	else
        lstrcat(szLogFilePath, ".csv");
    
    if(CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        szLogFilePath[lstrlen(szLogFilePath) - (4 * sizeof(TCHAR))] = '\0';

    if (FindFirstFile(szLogFilePath, fd2) != INVALID_HANDLE_VALUE)
    {
        if ( (lstrlen(fd3->cFileName) > 12) && (NT4 != OSVersion) && (Win2000 != OSVersion) )
        {
            FILE *fGetFile, *fPutFile;
            DWORD dwRet = 0;
            DWORD dwBytesWrit;
            TCHAR szBuffer[50000];
            fGetFile = fopen(szLogFilePath, "r");
            fPutFile = fopen(LogProc->szFile, "a+");
            if (fGetFile && fPutFile)
            {
                while (fgets(szBuffer, 50000, fGetFile))
                {
                    fputs(szBuffer, fPutFile);
                }
                fclose(fPutFile);
                fclose(fGetFile);
            }
            else
            {
                if (fPutFile)
                    fclose(fPutFile);
                if (fGetFile)
                    fclose(fGetFile);
            }
            if (fPutFile)
                fclose(fPutFile);
            if (fGetFile)
                fclose(fGetFile);
            DeleteFile(szLogFilePath);
        }
        if(fd2)
            free(fd2);
        if(fd3)
            free(fd3);
    }

    if (g_WalkStartMenu)
    {
        AppWalk.Walk();
    }
    LogProc->LogString(",#Stop parsing here,,\r\n");

#ifndef NOCHKUPGRD
    if ( (RunChkupgrd) && (!CommandLine.IsSpecified(TEXT("/donotrun1"), TRUE)) )
    {
        TCHAR szUpgr[512];
        lstrcpy(szUpgr, LogProc->szLogDir);
        lstrcat(szUpgr, "\\chkupgrd.exe");
        LoadResourceFile(szUpgr, "EXEResource3" );
        _spawnl(_P_WAIT, szUpgr, szUpgr, "", "", NULL);
        DeleteFile(szUpgr);
        LogProc->LogString("\r\n,#Chkupgrd.log,,\r\n");

        if (Win2000 != OSVersion)
        {
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\winnt32.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\config.dmp");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
        }
        else
        {
            GetWindowsDirectory(szUpgr, 512);
            if ( '\\' == szUpgr[lstrlen(szUpgr)-1] )
            {
                szUpgr[lstrlen(szUpgr)-1]='\0';
            }
            lstrcat(szUpgr, "\\winnt32.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            GetWindowsDirectory(szUpgr, 512);
            if ( '\\' == szUpgr[lstrlen(szUpgr)-1] )
            {
                szUpgr[lstrlen(szUpgr)-1]='\0';
            }
            lstrcat(szUpgr, "\\config.dmp");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
        }

        LogProc->LogString("\r\n,#END_Chkupgrd.log,,\r\n");
    }
#endif

#ifndef ALPHA
        if ( (RunDevdump) && (!CommandLine.IsSpecified(TEXT("/donotrun2"),NOT_CASE_SENSITIVE)) && (Win2000==OSVersion))
#else
        if ( ((!RunDevdump) || (CommandLine.IsSpecified(TEXT("/donotrun2"),NOT_CASE_SENSITIVE))) && (Win2000==OSVersion))
#endif
        {
            TCHAR szEx[512];
            TCHAR szUpgr[512];
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.exe");
            LoadResourceFile(szUpgr, "EXEResource4" );
            lstrcpy(szEx, szUpgr);
            lstrcat(szUpgr, " ");
            lstrcat(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.log /T");
            _spawnl(_P_WAIT, szEx, szUpgr, "", "", NULL);
            DeleteFile(szUpgr);
            LogProc->LogString("\r\n,#DevDump.log,,\r\n");
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            LogProc->LogString("\r\n,#END_DevDump.log,,\r\n");
        }

        HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_STATUS);
        wsprintf(Status, TEXT("Logfile \"%s\" has been written to disk."), LogProc->szFile);
        //
        // If the filepath is specified on the command line, we are likely running under Winnt32
        // so we hide the files to set a good example to ISV's - bug #229053
        //
        if(CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE)) {
            SetFileAttributes(LogProc->szFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
            SetFileAttributes(szRegFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }
        SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);

       return TRUE;
}

CLASS_GeneralInfo::CLASS_GeneralInfo(kLogFile *Proc, HWND hIn)
{
    LogProc=Proc;
    gHandleToMainWindow = hIn;
    GetCurrentWindowsDirectory();
    //RunDevdump = TRUE;
    RunDevdump = FALSE; // Disabled devdump due to whistler bug 355359
    RunChkupgrd = TRUE;
    AutoRun = FALSE;
    RunMinimized = FALSE;
    OverWrite = FALSE;
    UseComputerName = FALSE;
}

// Initialize the global WindowsDirectory variable
void CLASS_GeneralInfo::GetCurrentWindowsDirectory(void)
{
   HINSTANCE hInst2=LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
   LPFNDLLFUNC2 fProc = (LPFNDLLFUNC2)GetProcAddress(hInst2, "GetSystemWindowsDirectoryA");

   if (hInst2 && fProc)
   {
      fProc(WindowsDirectory, MAX_PATH);
   }
   else
   {
      GetWindowsDirectory(WindowsDirectory, MAX_PATH);
   }
   if ( '\\' == WindowsDirectory[lstrlen(WindowsDirectory)-1] )
   {
      WindowsDirectory[lstrlen(WindowsDirectory)-1]='\0';
   }
   lstrcpy(g_WindowsDirectory, WindowsDirectory);
}

void CLASS_GeneralInfo::DetermineOS(void)
{
    OSVERSIONINFO osV;

    osV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osV))
    {
        switch (osV.dwPlatformId)
        {
            case VER_PLATFORM_WIN32s:
                OSVersion = Unknown;
            break; 
            case VER_PLATFORM_WIN32_WINDOWS:
            {
                if (osV.dwMinorVersion == 0)
                {
                    OSVersion = Win95;
                }
                else if (osV.dwMinorVersion == 10)
                {
                    OSVersion = Win98;
                }
            }
            break;
            case VER_PLATFORM_WIN32_NT:
            {
                if (osV.dwMajorVersion == 4)
                {
                    OSVersion = NT4;
                }
                else if (osV.dwMajorVersion == 5)
                {
                    if(LOWORD(osV.dwBuildNumber) == 2195)
                        OSVersion = Win2000;
                    else if(LOWORD(osV.dwBuildNumber) >= 2196)
                        OSVersion = Whistler;
                    else
                        OSVersion = Unknown;
                }
            }
            break;
            default:
                OSVersion = Unknown;
            break;
        }
    }
    else 
    {
        OSVersion = Unknown;
    }
}

BOOL CLASS_GeneralInfo::InitLogFile(void)
{
    TCHAR szLogFileName[MAX_PATH * 4];
    TCHAR Windy[MAX_PATH * 4];
    TCHAR szCurDirectory[MAX_PATH];
    WIN32_FIND_DATA FileData;
    HANDLE HandleToSearch;
    kCommandLine CommandLine;

    DetermineOS();

    //default to windir
	lstrcpy(szLogFileName, WindowsDirectory);

	if (CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE))
        lstrcpy(szLogFileName, CommandLine.GetSwitchValue(TEXT("/w"),NOT_CASE_SENSITIVE));

		//if (GetCurrentDirectory(MAX_PATH, szCurDirectory))
		//	lstrcpy(CSV, szCurDirectory);
    if(szLogFileName[lstrlen(szLogFileName) -1] != '\\')
   		lstrcat(szLogFileName, "\\");
   
    if (CommandLine.IsSpecified(TEXT("/n"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFileName,CommandLine.GetSwitchValue(TEXT("/n"),NOT_CASE_SENSITIVE));
    // For Whistler Pre-Beta1 test - Generate Unique filename (ComputerName+UserName+Time)
    else if (CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
	    lstrcat(szLogFileName, GetUniqueFileName());
    else
		lstrcat(szLogFileName, Profile);

    lstrcpy(szRegFile, szLogFileName);
    lstrcat(szRegFile, TEXT(".reg"));

    switch (OSVersion)
    {
        case Win95:
            lstrcpy(PlatformExtension, TEXT("-w95"));
         break;
        case Win98:
            lstrcpy(PlatformExtension, TEXT("-w98"));
         break;
        case NT4:
            lstrcpy(PlatformExtension, TEXT("-nt4"));
         break;
        case Win2000:
            lstrcpy(PlatformExtension, TEXT("-w2k"));
         break;
        default:
            lstrcpy(PlatformExtension, TEXT("-unk"));
         break;
    }

	if (!(CommandLine.IsSpecified(TEXT("/x"),NOT_CASE_SENSITIVE)))
		lstrcat(szLogFileName, PlatformExtension);

	if (CommandLine.IsSpecified(TEXT("/l"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFileName, ".log");
	else
		lstrcat(szLogFileName, ".csv");

    if(CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        szLogFileName[lstrlen(szLogFileName) - (4 * sizeof (TCHAR))] = '\0';

    HandleToSearch = FindFirstFile(szLogFileName, &FileData);
    if (TRUE == OverWrite)
        DeleteFile(szLogFileName);
    else if (INVALID_HANDLE_VALUE != HandleToSearch)
    {
        //ask to overwrite
        TCHAR ErrorMessage[MAX_PATH * 4];
        int RetVal;

        wsprintf(ErrorMessage, TEXT("Overwrite %s?"), szLogFileName);
        RetVal=MessageBox(gHandleToMainWindow, ErrorMessage, TEXT("Sysparse"), MB_YESNO);
        if (IDYES == RetVal)
            DeleteFile(szLogFileName);
        else if (IDNO == RetVal)
            return FALSE;
    }
    if(HandleToSearch)
        FindClose(HandleToSearch);
    lstrcpy(Windy, WindowsDirectory);
    LogProc->InitFile(szLogFileName, Windy);
    return TRUE;
}

void CLASS_GeneralInfo::InitHelpers(void)
{

}

void CLASS_GeneralInfo::DetermineCommandLine(void)
{

}

BOOL CLASS_GeneralInfo::FillInArguments(void)
{
    kCommandLine CommandLine;
    TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    TCHAR CurrentDirectory[MAX_PATH];
    HANDLE FileSearch;
    WIN32_FIND_DATA FileData;
    BOOL PrePopulateFileFound = FALSE;
    DWORD NameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;

    lstrcpy(Corporation, "");
    lstrcpy(Email, "");
    lstrcpy(Manufacturer, "");
    lstrcpy(Model, "");
    lstrcpy(NumComp, "");
    lstrcpy(SiteID, "");
    lstrcpy(Profile, "");
    lstrcpy(BetaID, "");
    lstrcpy(MachineType, "");
    SiteIDIndex=0;
    MachineTypeIndex=0;

    if (0 != GetModuleFileName(NULL, CurrentDirectory, MAX_PATH))
    {
        DWORD NameCounter;

        NameCounter = lstrlen(CurrentDirectory);
        while ( ('\\' != CurrentDirectory[NameCounter]) && (0 != NameCounter) )
            NameCounter--;
        CurrentDirectory[NameCounter]='\0';
        if ('\\' != CurrentDirectory[lstrlen(CurrentDirectory)-1] )
        {
            lstrcat(CurrentDirectory, "\\sysparsq");
        }
        else
        {
            lstrcat(CurrentDirectory, "sysparsq");
        }
        FileSearch=FindFirstFile(CurrentDirectory, &FileData);
        if (INVALID_HANDLE_VALUE != FileSearch)
        {
            //found the INI
            ReadInFileInfo(CurrentDirectory);
            FindClose(FileSearch);
            PrePopulateFileFound = TRUE;
        } 
        else
        {
            lstrcat(CurrentDirectory, TEXT(".ini"));
            FileSearch = FindFirstFile(CurrentDirectory, &FileData);
            if (INVALID_HANDLE_VALUE != FileSearch)
            {
                //found the INI
                ReadInFileInfo(CurrentDirectory);
                FindClose(FileSearch);
                PrePopulateFileFound = TRUE;
            }
        }
        if (CommandLine.IsSpecified("/p",NOT_CASE_SENSITIVE))
        {
            PTCHAR Switch;
            TCHAR Message1[MAX_PATH * 4], Message2[MAX_PATH * 4];
            DWORD ret;
            HANDLE SearchHandle;
            WIN32_FIND_DATA Data;

            Switch = CommandLine.GetSwitchValue("/p",NOT_CASE_SENSITIVE);
            if(!Switch)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            lstrcpy (CurrentDirectory, Switch);
            //"/p filename" file to copy input values from

            SearchHandle = FindFirstFile(CurrentDirectory, &Data);
            if (INVALID_HANDLE_VALUE != SearchHandle)
            {
                PrePopulateFileFound = TRUE;
                ReadInFileInfo(CurrentDirectory);
            }
            else
            {
                wsprintf(Message2, "Could not find file %s specified with /p switch", CurrentDirectory);
                MessageBox(NULL, Message2, "Sysparse", MB_OK);
                return FALSE;
            }
            if(FileSearch)
                FindClose(FileSearch);
        }
/*
//fill this in with the above routine.  (put it in a seperate routine and call it from here.)
      else if (CommandLine.IsSpecified("-p",TRUE))
      {
         TCHAR *Switch;
         Switch=CommandLine.GetSwitchValue("-p",TRUE);
         lstrcpy(CurrentDirectory, Switch);
         PrePopulateFileFound=TRUE;
      }
*/

      //No file to prepopulate sysparse with, find out if
      //there are any commandline arguments to look at
      if (CommandLine.IsSpecified("/a",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-a",NOT_CASE_SENSITIVE))
         AutoRun = TRUE;

      if (CommandLine.IsSpecified("/m",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-m",NOT_CASE_SENSITIVE))
            RunMinimized = TRUE;
 
        if (CommandLine.IsSpecified("/c",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-c",NOT_CASE_SENSITIVE) || (TRUE == UseComputerName) )
        {
            UseComputerName = TRUE;
            
            if (GetComputerName(ComputerName, &NameBufferSize))
            {
                lstrcpy(Profile, ComputerName);
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }
      
        if (CommandLine.IsSpecified(TEXT("/o"),NOT_CASE_SENSITIVE) || CommandLine.IsSpecified(TEXT("-o"), NOT_CASE_SENSITIVE))
            OverWrite = TRUE;

        if (CommandLine.IsSpecified(TEXT("/s"),NOT_CASE_SENSITIVE) || CommandLine.IsSpecified(TEXT("-s"), NOT_CASE_SENSITIVE))
            g_WalkStartMenu = FALSE;

        if (CommandLine.IsSpecified("/1",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Corporation, CommandLine.GetSwitchValue("/1",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION), WM_SETTEXT, 0, (LPARAM)Corporation);
        }
        else if (CommandLine.IsSpecified("-1",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Corporation, CommandLine.GetSwitchValue("-1",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION), WM_SETTEXT, 0, (LPARAM)Corporation);
        }

        if (CommandLine.IsSpecified("/2",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Email, CommandLine.GetSwitchValue("/2",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL), WM_SETTEXT, 0, (LPARAM)Email);
        }
        else if (CommandLine.IsSpecified("-2",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Email, CommandLine.GetSwitchValue("-2",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL), WM_SETTEXT, 0, (LPARAM)Email);
        }

        if (CommandLine.IsSpecified("/6",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Manufacturer, CommandLine.GetSwitchValue("/6",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER), WM_SETTEXT, 0, (LPARAM)Manufacturer);
        }
        else if (CommandLine.IsSpecified("-6",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Manufacturer, CommandLine.GetSwitchValue("-6",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER), WM_SETTEXT, 0, (LPARAM)Manufacturer);
        }
      
        if (CommandLine.IsSpecified("/7",NOT_CASE_SENSITIVE))
        { 
            lstrcpy(Model, CommandLine.GetSwitchValue("/7",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL), WM_SETTEXT, 0, (LPARAM)Model);
        }
        else if (CommandLine.IsSpecified("-7",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Model, CommandLine.GetSwitchValue("-7",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL), WM_SETTEXT, 0, (LPARAM)Model);
        }
      
        if (CommandLine.IsSpecified("/9",NOT_CASE_SENSITIVE))
        {
            lstrcpy(NumComp, CommandLine.GetSwitchValue("/9",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP), WM_SETTEXT, 0, (LPARAM)NumComp);
        } 
        else if (CommandLine.IsSpecified("-9",NOT_CASE_SENSITIVE))
        {
            lstrcpy(NumComp, CommandLine.GetSwitchValue("-9",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP), WM_SETTEXT, 0, (LPARAM)NumComp);
        }

        if (CommandLine.IsSpecified("/3",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
         
            lstrcpy(Temp, CommandLine.GetSwitchValue("/3",NOT_CASE_SENSITIVE));
            SiteIDIndex=(UINT)_ttoi(Temp);
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID), CB_SETCURSEL, SiteIDIndex+1, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }
        else if (CommandLine.IsSpecified("-3",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            lstrcpy(Temp, CommandLine.GetSwitchValue("-3",NOT_CASE_SENSITIVE));
            SiteIDIndex = (UINT)_ttoi(Temp);
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID), CB_SETCURSEL, SiteIDIndex+1, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }

        if (CommandLine.IsSpecified("/4",NOT_CASE_SENSITIVE))
        {
            if (!UseComputerName)
            {
                lstrcpy(Profile, CommandLine.GetSwitchValue("/4",NOT_CASE_SENSITIVE));
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }
        else if (CommandLine.IsSpecified("-4",NOT_CASE_SENSITIVE))
        {
            if (!UseComputerName)
            {
                lstrcpy(Profile, CommandLine.GetSwitchValue("-4",NOT_CASE_SENSITIVE));
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }

        if (CommandLine.IsSpecified("/5",NOT_CASE_SENSITIVE))
        {
            lstrcpy(BetaID, CommandLine.GetSwitchValue("/5",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID), WM_SETTEXT, 0, (LPARAM)BetaID);
        }
        else if (CommandLine.IsSpecified("-5",NOT_CASE_SENSITIVE))
        {
            lstrcpy(BetaID, CommandLine.GetSwitchValue("-5",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID), WM_SETTEXT, 0, (LPARAM)BetaID);
        }

        if (CommandLine.IsSpecified("/8",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            lstrcpy (Temp, CommandLine.GetSwitchValue ("/8",NOT_CASE_SENSITIVE));
            MachineTypeIndex = (UINT)_ttoi(Temp);
            SendMessage (GetDlgItem (gHandleToMainWindow, IDC_COMBO_TYPE), CB_SETCURSEL, MachineTypeIndex + 1, 0);
        }
        else if (CommandLine.IsSpecified("-8",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            SendMessage (GetDlgItem (gHandleToMainWindow, IDC_COMBO_TYPE), CB_SETCURSEL, MachineTypeIndex + 1, 0);
        }
    }
    return TRUE;      
}

BOOL CLASS_GeneralInfo::ReadInFileInfo(PTCHAR pFileName)
{
    TCHAR AutoRunText[MAX_PATH * 4];
    HWND HandleToControl;
    DWORD ret;

    if(!pFileName)
        return FALSE;
        
    if(!lstrlen(pFileName))
        return FALSE;
        
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Corp\"", "", Corporation, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Make\"", "", Manufacturer, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Model\"", "", Model, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#UserID\"", "", Email, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"##machines_on_profile\"", "", NumComp, MAX_PATH * 4, pFileName);
    ret = 0;
    while ('\0' != NumComp[ret])
    {
        if ( (NumComp[ret] < 48) || (NumComp[ret] > 57) )
        {
            TCHAR Error[MAX_PATH * 4];
            wsprintf(Error, "##machines_on_profile in %s is not valid", pFileName);
            MessageBox(NULL, Error, "Sysparse", MB_OK);
            return FALSE;
        }
        ret++;
    }

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Event\"", "", SiteID, MAX_PATH * 4, pFileName);
    if (0 != lstrlen(SiteID))
    {
        if (INVALID_HANDLE_VALUE != (HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID)))
            SiteIDIndex = (USHORT)SendMessage(HandleToControl, CB_FINDSTRINGEXACT, -1, (LPARAM)SiteID);

        if (CB_ERR == SiteIDIndex)
        {
            MessageBox(gHandleToMainWindow, "SiteID (#Event) specified in INI is invalid", "Sysparse", MB_OK);
            return FALSE;
        }
        else
        {
            SendMessage(HandleToControl, CB_SETCURSEL, SiteIDIndex, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }
    }
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Profile\"", "", Profile, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Location\"", "", BetaID, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#MachineType\"", "", MachineType, MAX_PATH * 4, pFileName);

    if (0 != lstrlen(MachineType))
    {
        if (INVALID_HANDLE_VALUE != (HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_TYPE)))
            MachineTypeIndex = (USHORT)SendMessage(HandleToControl, CB_FINDSTRINGEXACT, -1, (LPARAM)MachineType);

        if (CB_ERR == MachineTypeIndex)
        {
            MessageBox(gHandleToMainWindow, "MachineType (#Event) specified in INI is not valid", "Sysparse", MB_OK);
            return FALSE;
        }
        else if(INVALID_HANDLE_VALUE != HandleToControl)
        {
            SendMessage(HandleToControl, CB_SETCURSEL, MachineTypeIndex, 0);
        }
        else {
            return FALSE;
        }
    }

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#AutoRun\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        AutoRun = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#OverWriteCSV\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        OverWrite = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#RunMinimized\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunMinimized = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#UseComputerName\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        UseComputerName = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#donotrun1\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunChkupgrd=FALSE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#donotrun2\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunDevdump=FALSE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#MachineUUID\"", "", OriginalMachineUUID, MAX_PATH * 4, pFileName);

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Corporation);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Email);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Manufacturer);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Model);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)NumComp);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Profile);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)BetaID);
    return TRUE;
}

BOOL CLASS_GeneralInfo::DetermineArgumentValidity(void)
{
    BOOL ReturnValue;
    DWORD Counter;

    ReturnValue = CopyInput();

    if (FALSE == ReturnValue)
      return FALSE;

    Counter=0;
    while (Profile[Counter]!='\0')
    {
        if (Profile[Counter] != 'a' &&
            Profile[Counter] != 'b' &&
            Profile[Counter] != 'c' &&
            Profile[Counter] != 'd' &&
            Profile[Counter] != 'e' &&
            Profile[Counter] != 'f' &&
            Profile[Counter] != 'g' &&
            Profile[Counter] != 'h' &&
            Profile[Counter] != 'i' &&
            Profile[Counter] != 'j' &&
            Profile[Counter] != 'k' &&
            Profile[Counter] != 'l' &&
            Profile[Counter] != 'm' &&
            Profile[Counter] != 'n' &&
            Profile[Counter] != 'o' &&
            Profile[Counter] != 'p' &&
            Profile[Counter] != 'q' &&
            Profile[Counter] != 'r' &&
            Profile[Counter] != 's' &&
            Profile[Counter] != 't' &&
            Profile[Counter] != 'u' &&
            Profile[Counter] != 'v' &&
            Profile[Counter] != 'w' &&
            Profile[Counter] != 'x' &&
            Profile[Counter] != 'y' &&
            Profile[Counter] != 'z' &&
            Profile[Counter] != 'A' &&
            Profile[Counter] != 'B' &&
            Profile[Counter] != 'C' &&
            Profile[Counter] != 'D' &&
            Profile[Counter] != 'E' &&
            Profile[Counter] != 'F' &&
            Profile[Counter] != 'G' &&
            Profile[Counter] != 'H' &&
            Profile[Counter] != 'I' &&
            Profile[Counter] != 'J' &&
            Profile[Counter] != 'K' &&
            Profile[Counter] != 'L' &&
            Profile[Counter] != 'M' &&
            Profile[Counter] != 'N' &&
            Profile[Counter] != 'O' &&
            Profile[Counter] != 'P' &&
            Profile[Counter] != 'Q' &&
            Profile[Counter] != 'R' &&
            Profile[Counter] != 'S' &&
            Profile[Counter] != 'T' &&
            Profile[Counter] != 'U' &&
            Profile[Counter] != 'V' &&
            Profile[Counter] != 'W' &&
            Profile[Counter] != 'X' &&
            Profile[Counter] != 'Y' &&
            Profile[Counter] != 'Z' &&
            Profile[Counter] != '0' &&
            Profile[Counter] != '1' &&
            Profile[Counter] != '2' &&
            Profile[Counter] != '3' &&
            Profile[Counter] != '4' &&
            Profile[Counter] != '5' &&
            Profile[Counter] != '6' &&
            Profile[Counter] != '7' &&
            Profile[Counter] != '8' &&
            Profile[Counter] != '9' &&
            Profile[Counter] != ' ' &&
            Profile[Counter] != '_' &&
            Profile[Counter] != '-' )
        {
            Profile[Counter]=TEXT('_');
        }
        Counter++;
    }

    return TRUE;
}

void CLASS_GeneralInfo::ChangeSpaces(TCHAR *Input)
{
    TCHAR Temp[MAX_PATH * 4];
    DWORD Counter;
    DWORD Len;

    Counter = 0;
    Len = lstrlen(Temp);
    lstrcpy(Temp, Input);
    while (('\0' != Temp[Counter]) && (Counter != Len))
    {
       if ( ' ' == Temp[Counter] )
          Temp[Counter]='_';

      Counter++;
    }
    lstrcpy(Input, Temp);
}

BOOL CLASS_GeneralInfo::CopyInput(void)
{
    HWND HandleToControl;
    TCHAR Holder[MAX_PATH * 4];
    DWORD Retval;

    HandleToControl=GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Corporation);
    if (0 == lstrlen(Corporation))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Corporation", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Email);
    if (0 == lstrlen(Email))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for E-mail", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl=GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Manufacturer);
    if (0 == lstrlen(Manufacturer))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Manufacturer", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Model);
    if (0 == lstrlen(Model))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Model", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP);
    if (HandleToControl)
    {
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)NumComp);
    }
    if (0 == lstrlen(NumComp))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for # Computers", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID);
    if (HandleToControl)
    {
        SiteIDIndex=(unsigned short)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);
    }
#ifndef SB
    if (0 == SiteIDIndex)
    {
        MessageBox(gHandleToMainWindow, "Please select a value for Site ID", "Sysparse", MB_OK);
        return FALSE;
    }
#else
    if (0 != SiteIDIndex)
    {
        MessageBox(gHandleToMainWindow, "Please select a value for Site ID", "Sysparse", MB_OK);
        return FALSE;
    }
#endif
    else
        SendMessage(HandleToControl, CB_GETLBTEXT, SiteIDIndex, (LPARAM)SiteID);

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE);
    if (HandleToControl)
        Retval=(DWORD)SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Profile);

    if (0 == Retval)
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Profile", "Sysparse", MB_OK);
        return FALSE;
    }

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)BetaID);

    if (0 == lstrlen(BetaID))
    {
        MessageBox(gHandleToMainWindow, TEXT("Please enter a value for Beta ID"), TEXT("Sysparse"), MB_OK);
        return FALSE;
    }

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_TYPE);

    if (HandleToControl)
        MachineTypeIndex = (unsigned short)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);

    if (0 == MachineTypeIndex)
    {
        MessageBox(gHandleToMainWindow, TEXT("Please select a value for MachineType"), TEXT("Sysparse"), MB_OK);
        return FALSE;
    }
    else
        SendMessage(HandleToControl, CB_GETLBTEXT, MachineTypeIndex, (LPARAM)MachineType);

    return TRUE;
}

void CLASS_GeneralInfo::WriteVersions(void)
{
    SYSTEMTIME SysTime;
#ifdef INTERNAL
    LogProc->LogString(TEXT(",#Sysparse_Version,,\r\n,02.05.02I,\r\n"));
#else
    LogProc->LogString(TEXT(",#Sysparse_Version,,\r\n,02.05.02E,\r\n"));
#endif
    LogProc->LogString(TEXT(",#ParseTime,,\r\n"));
    GetSystemTime(&SysTime);
    LogProc->LogString (TEXT(",%2d/%2d/%4d %2d:%2d:%2d,\r\n"), SysTime.wMonth, SysTime.wDay, SysTime.wYear, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
}

void CLASS_GeneralInfo::WriteGeneralInfo(void)
{

}

void CLASS_GeneralInfo::GetUUID(void)
{
    HKEY hOpen;
    LONG lRet;
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\SysParse"), 0, KEY_ALL_ACCESS, &hOpen);

    if (ERROR_SUCCESS == lRet)
    {
        UCHAR *szreg = (UCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
        TCHAR szFile[MAX_PATH];
        TCHAR szfilecont[50000];
        DWORD dwlen = MAX_PATH * 4;
        DWORD dwType;
        LPTSTR szval = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
        lstrcpy(szval, TEXT("#MachineUuid"));
        lRet = RegQueryValueEx(hOpen, szval, NULL, &dwType, szreg, &dwlen);
        if (ERROR_SUCCESS == lRet)
        {
            LogProc->LogString(TEXT(",#MachineUUID,,\r\n"));
            LogProc->LogString(TEXT(",%s,\r\n"), szreg);
            RegSetValueEx(hOpen, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile)+1);
            RegSetValueEx(hOpen, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation)+1);
            RegSetValueEx(hOpen, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email)+1);
            RegSetValueEx(hOpen, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp)+1);
            RegSetValueEx(hOpen, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer)+1);
            RegSetValueEx(hOpen, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model)+1);
            RegSetValueEx(hOpen, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID)+1);
            RegSetValueEx(hOpen, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType)+1);
        }
        else
        {
            LogProc->LogString(TEXT(",#MachineUUID,,\r\n"));
            UUID uuid;
            LONG wRet;
            UCHAR *szuuid = 0x0;
            wRet = UuidCreate(&uuid);
            if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
            {
                wRet=UuidToString(&uuid, &szuuid);
                if (RPC_S_OK == wRet)
                    LogProc->LogString(TEXT(",%s,\r\n"),szuuid);
                else 
                    LogProc->LogString(TEXT(",blank,\r\n"));
            }
            else 
                LogProc->LogString(TEXT(",blank,\r\n"));

            HKEY hKey;
            DWORD dwDisp;
            RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\SysParse"), 0, TEXT("SZ_KEY"), 0, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);
            RegSetValueEx(hKey, TEXT("#MachineUuid"), 0, REG_SZ, szuuid, lstrlen((const char *)szuuid) + 1);
            lstrcpy((TCHAR *) szreg, (TCHAR *)szuuid);

            RegSetValueEx(hOpen, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile) + 1);
            RegSetValueEx(hOpen, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation) + 1);
            RegSetValueEx(hOpen, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email) + 1);
            RegSetValueEx(hOpen, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp) + 1);
            RegSetValueEx(hOpen, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer) + 1);
            RegSetValueEx(hOpen, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model) + 1);
            RegSetValueEx(hOpen, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID) + 1);
            RegSetValueEx(hOpen, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType) + 1);

           if (INVALID_HANDLE_VALUE != hKey ) 
               RegCloseKey(hKey);
        }
        if (INVALID_HANDLE_VALUE != hOpen)
            RegCloseKey(hOpen);

        HANDLE hFile;
        DWORD dwBytesWrit;
        hFile = CreateFile(szRegFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile!=INVALID_HANDLE_VALUE)
        {
            wsprintf(szfilecont, TEXT("REGEDIT4\r\n\r\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse]\r\n"));
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineUuid\"=\"%s\"\r\n"), szreg);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Profile\"=\"%s\"\r\n"), Profile);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Corp\"=\"%s\"\r\n"), Corporation);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#UserID\"=\"%s\"\r\n"), Email);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"##machines_on_profile\"=\"%s\"\r\n"), NumComp);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Make\"=\"%s\"\r\n"), Manufacturer);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Model\"=\"%s\"\r\n"), Model);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Event\"=\"%s\"\r\n"), SiteID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Location\"=\"%s\"\r\n"), BetaID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineType\"=\"%s\"\r\n"), MachineType);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            CloseHandle(hFile);
        }
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szreg);
    }
    else
    {
        LogProc->LogString(",#MachineUUID,,\r\n");
        UUID uuid;
        LONG wRet;
        UCHAR *szuuid = 0x0;
        wRet = UuidCreate(&uuid);
        if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
        {
            wRet = UuidToString(&uuid, &szuuid);
            if (RPC_S_OK == wRet)
                LogProc->LogString(",%s,\r\n",szuuid);
            else 
                LogProc->LogString(",blank,\r\n");
        }
        else 
            LogProc->LogString(",blank,\r\n");
        HKEY hKey;
        DWORD dwDisp;
        TCHAR szFile[MAX_PATH];
        RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\SysParse", 0, "SZ_KEY", 0, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);
        RegSetValueEx(hKey, "#MachineUuid", 0, REG_SZ, szuuid, lstrlen((const char *)szuuid) + 1);
        RegSetValueEx(hKey, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile) + 1);
        RegSetValueEx(hKey, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation) + 1);
        RegSetValueEx(hKey, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email) + 1);
        RegSetValueEx(hKey, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp) + 1);
        RegSetValueEx(hKey, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer) + 1);
        RegSetValueEx(hKey, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model) + 1);
        RegSetValueEx(hKey, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID) + 1);
        RegSetValueEx(hKey, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType) + 1);

        if (INVALID_HANDLE_VALUE != hKey)
            RegCloseKey(hKey);
        HANDLE hFile;
        DWORD dwBytesWrit;
        TCHAR szfilecont[50000];
        hFile = CreateFile(szRegFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile!=INVALID_HANDLE_VALUE)
        {
            wsprintf(szfilecont, TEXT("REGEDIT4\r\n\r\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse]\r\n"));
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineUuid\"=\"%s\"\r\n"), szuuid);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Profile\"=\"%s\"\r\n"), Profile);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Corp\"=\"%s\"\r\n"), Corporation);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#UserID\"=\"%s\"\r\n"), Email);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"##machines_on_profile\"=\"%s\"\r\n"), NumComp);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Make\"=\"%s\"\r\n"), Manufacturer);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Model\"=\"%s\"\r\n"), Model);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Event\"=\"%s\"\r\n"), SiteID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Location\"=\"%s\"\r\n"), BetaID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineType\"=\"%s\"\r\n"), MachineType);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            CloseHandle(hFile);
        }
    }

    LONG wRet;
    UUID uuid;
    UCHAR *szuuid = 0x0;
    LogProc->LogString(",#PassUUID,,\r\n");
    wRet = UuidCreate(&uuid);
    if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
    {
        wRet = UuidToString(&uuid, &szuuid);
        if (RPC_S_OK == wRet)
            LogProc->LogString(",%s,\r\n",szuuid);
        else 
            LogProc->LogString(",blank,\r\n");
    }
    else
        LogProc->LogString(",blank,\r\n");
}

void CLASS_GeneralInfo::WriteArguments(void)
{
    LogProc->StripCommas(Profile);
    LogProc->LogString(",#Profile,,\r\n,%s,\r\n",Profile);
    LogProc->StripCommas(Email);
    LogProc->LogString(",#UserID,,\r\n,%s,\r\n",Email);
    LogProc->StripCommas(NumComp);
    LogProc->LogString(",##machines_on_profile,,\r\n,%s,\r\n",NumComp);
    LogProc->StripCommas(Corporation);
    LogProc->LogString(",#Corp,,\r\n,%s,\r\n",Corporation);
    LogProc->StripCommas(Model);
    LogProc->LogString(",#Model,,\r\n,%s,\r\n",Model);
    LogProc->StripCommas(BetaID);
    LogProc->LogString(",#Location,,\r\n,%s,\r\n",BetaID);
    LogProc->LogString(",#BetaID,,\r\n,%s,\r\n",BetaID);
    LogProc->StripCommas(MachineType);
    LogProc->LogString(",#MachineType,,\r\n,%s,\r\n",MachineType);
    LogProc->StripCommas(SiteID);
    LogProc->LogString(",#Event,,\r\n,%s,\r\n",SiteID);
    LogProc->StripCommas(Manufacturer);
    LogProc->LogString(",#Make,,\r\n,%s,\r\n",Manufacturer);
}

void CLASS_GeneralInfo::WriteFreeDiskSpace(void)
{
    TCHAR szWindir[MAX_PATH * 4];
    lstrcpy(szWindir, WindowsDirectory);
    if (0 != lstrlen(szWindir) )
    {
        ULARGE_INTEGER uliCaller, uliNumBytes, uliNumFreeBytes;
        HINSTANCE hInst2 = LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
        LPFNDLLFUNC1 fProc=(LPFNDLLFUNC1)GetProcAddress(hInst2, "GetDiskFreeSpaceExA");
        if (hInst2 && fProc)
        {
            fProc("c:\\", &uliCaller, &uliNumBytes, &uliNumFreeBytes);
            char szTemp[MAX_PATH * 4];
            strcpy(szTemp, szWindir);
            szTemp[3] = '\0';
            LogProc->LogString(",#WinDir_Free_Space,,\r\n");
            LogProc->StripCommas(szWindir);
            LogProc->LogString(",%s,\r\n", szWindir);
            LogProc->LogString(",%I64d,\r\n", uliNumFreeBytes.QuadPart);
        }
        else
        {
            DWORD dwSPC, dwPBS, dwNFC, dwTNC;
            GetDiskFreeSpace("c:\\", &dwSPC, &dwPBS, &dwNFC, &dwTNC);
            char szTemp[MAX_PATH * 4];
            strcpy(szTemp, szWindir);
            szTemp[3] = '\0';
            GetDiskFreeSpace(szTemp,&dwSPC, &dwPBS, &dwNFC, &dwTNC);
            LogProc->LogString(",#WinDir_Free_Space,,\r\n");
            LogProc->StripCommas(szWindir);
            LogProc->LogString(",%s,\r\n", szWindir);
            LogProc->LogString(",%d,\r\n", dwSPC*dwPBS*dwNFC);
        }
    }
}

void CLASS_GeneralInfo::WriteVolumeType(void)
{
    TCHAR szWind[MAX_PATH];
    TCHAR szVol[MAX_PATH];
    TCHAR szVolName[MAX_PATH];
    DWORD dwSer, dwLen, dwFlags;
    
    lstrcpy(szWind, WindowsDirectory);
    //
    // Lop off all but "%DriveLetter%:\"
    //
    szWind[3] = '\0';
    GetVolumeInformation(szWind, szVol, MAX_PATH, &dwSer, &dwLen, &dwFlags, szVolName, MAX_PATH);
    LogProc->LogString(",#WinDir_Volume_Type,,\r\n");
    LogProc->StripCommas(szVolName);
    LogProc->LogString(",%s,\r\n", szVolName);
}

void CLASS_GeneralInfo::WriteMemorySize(void)
{
    LogProc->LogString(",#Total_Memory,,\r\n");
    MEMORYSTATUS MemStat;
    GlobalMemoryStatus(&MemStat);   
    LogProc->LogString(",%d,\r\n",MemStat.dwTotalPhys);
}

void CLASS_GeneralInfo::WriteOSVersion(void)
{
    TCHAR szFullKey[MAX_PATH];
    PTCHAR szProductName = NULL;
    PTCHAR szString = NULL;        
    TCHAR szinf[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HKEY hKeyReg;
    LPOSVERSIONINFO osv = NULL;
    DWORD dwstringwrit, dwFileSize = 0, dwType, dwProductSize = 0;
   
    lstrcpy(szFullKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"));

    LogProc->LogString(TEXT(",#OS_Version,,\r\n"));
    
    if ((Win2000 != OSVersion) && (NT4 != OSVersion) && (Whistler != OSVersion))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
            
            if(szProductName)
            {
                RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);
            }
            
            RegCloseKey(hKeyReg);
        }
    }
    else
    {
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
            
            if(szProductName)
            {
                RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);
            }
            
            RegCloseKey(hKeyReg);
        }
    }


    //
    // Ensure there is a value to write, otherwise write a default to avoid parser issues
    //
    if (dwProductSize)
    {
        LogProc->StripCommas(szProductName);
        LogProc->LogString(TEXT(",%s,\r\n"), szProductName);
    }
    else
    {
        if (Win2000 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 2000,\r\n"));
        else if (Whistler == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows Whistler,\r\n"));
        else if (Win95 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 95,\r\n"));
        else if (Win98 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 98,\r\n"));
        else if (NT4 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows NT4,\r\n"));
        else 
            LogProc->LogString(TEXT(",Unknown,\r\n"));
    }

    if(szProductName)
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szProductName);

    if ( (Win2000 == OSVersion) || (NT4 == OSVersion) )
    {
        LogProc->LogString(",#NTType..\r\n");

        lstrcpy(szFullKey, TEXT("System\\CurrentControlSet\\Control\\ProductOptions"));

        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
                
            if(!szProductName)
            {
                RegCloseKey(hKeyReg);
                LogProc->LogString(",Workstation,\r\n");
                goto GET_PREV_OS;
            }
            
            RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);

            if(dwProductSize)
            {
                if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize))
                {
                    LogProc->StripCommas(szProductName);
                    LogProc->LogString(",%s,\r\n", szProductName);
                }
            }
            else
                LogProc->LogString(",Workstation,\r\n");

            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szProductName);
            RegCloseKey(hKeyReg);
        }
        else
            LogProc->LogString(",Workstation,\r\n");
    }
    
GET_PREV_OS:
    //
    // Get the previous OS info, if any
    //
    LogProc->LogString(",#Prev_OS,,\r\n");
    lstrcpy(szinf, WindowsDirectory);
    lstrcat(szinf, TEXT("\\system32\\$winnt$.inf"));
    hFile = CreateFile(szinf, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {    
        LogProc->LogString(",Unknown,\r\n");
    
   
    dwFileSize = GetFileSize(hFile, NULL);
    szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize); 
    
    if(!szString)
    {
        LogProc->LogString(",Unknown,\r\n");
    }
    
    if(ReadFile(hFile, szString, dwFileSize, &dwstringwrit, NULL))
    {
        PTCHAR szLoc;
        PTCHAR szLoc2;
        PTCHAR szBuf = NULL;
        TCHAR szFin[MAX_PATH];
        //
        // Find the address for "buildnumber" within $winnt$.inf
        //
        szLoc = strstr(szString, "BuildNumber");
        szBuf = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize); 

        if (szLoc && szBuf)
        {
            //
            // Find the address within that for the first double-quote
            //
            szLoc2 = strstr(szLoc, "\"");
            if (szLoc2)
            {
                //
                // Copy the rest of the string to the buffer
                //
                lstrcpy(szBuf, szLoc2);
                //
                // Just for fun...
                //
                szBuf[0] = '#';
                //
                // Find the last "
                //
                for ( DWORD i = 0; szBuf[i] != '\"'; i++);
                //
                // Terminate the string
                //
                szBuf[i] = '\0';
                //
                // Now, character by character, copy the string to the new buffer - this avoids the # at the beginning
                // of the string
                //
                for (i = 0; i < strlen(szBuf); i++)
                    szFin[i] = szBuf[i + 1];
                //
                // Strip any commas and write to the logfile
                //
                LogProc->StripCommas(szFin);
                LogProc->LogString(",%s,\r\n", szFin);
            }
            else
                LogProc->LogString(",Unknown,\r\n");
        }
        else
            LogProc->LogString(",Unknown,\r\n");
            
        if(szBuf)
            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuf);
    }
    else
        LogProc->LogString(",Unknown,\r\n");


    CloseHandle(hFile);
    }

    if(szString)
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szString);
        
    osv = (LPOSVERSIONINFO)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(OSVERSIONINFO));
    
    if(!osv)
    {
        LogProc->LogString(",#OS_Major_Version,,\r\n,Unknown,\r\n" ",#OS_Minor_Version,,\r\n,Unknown,\r\n" ",#OS_Build_Number,,\r\n,Unknown,\r\n" ",#OS_Platform_ID,,\r\n,Unknown,\r\n" ",#OS_Extra_Info,,\r\n,Unknown,\r\n");
    }
    else
    {
        osv->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(osv);
        LogProc->StripCommas(osv->szCSDVersion);
        LogProc->LogString(",#OS_Major_Version,,\r\n,%d,\r\n" ",#OS_Minor_Version,,\r\n,%d,\r\n" ",#OS_Build_Number,,\r\n,%d,\r\n" ",#OS_Platform_ID,,\r\n,%d,\r\n" ",#OS_Extra_Info,,\r\n,%s,\r\n", osv->dwMajorVersion, osv->dwMinorVersion, LOWORD(osv->dwBuildNumber), osv->dwPlatformId, osv->szCSDVersion);
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, osv);
    }
}

void CLASS_GeneralInfo::CatLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

BOOL CLASS_GeneralInfo::LoadResourceFile(PSTR FilePath, PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    HANDLE hfFile = INVALID_HANDLE_VALUE;
        
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
   {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}


PTCHAR GetUniqueFileName( void )
{
	MYTIMESTRUCT MyTime;
    DWORD dwLen = MAX_PATH;
    static TCHAR szUniqueFileName[MAX_PATH] = {'\0'};

    if(!GetComputerName(szUniqueFileName, &dwLen))
        lstrcpy(szUniqueFileName, "ErrorRetrievingComputerName");

    lstrcat(szUniqueFileName+lstrlen(szUniqueFileName), "_");

    if(!GetUserName(szUniqueFileName+lstrlen(szUniqueFileName), &dwLen))
        lstrcat(szUniqueFileName, "ErrorRetrievingUsername");
    
    FillMyTime(&MyTime);

    wsprintf(szUniqueFileName+lstrlen(szUniqueFileName), "_%s%s%s%s%s%s%s.Sysparse", MyTime.szMonth, MyTime.szDay, MyTime.szYear, MyTime.szHour, MyTime.szMinute, MyTime.szSecond, MyTime.szMillisecond);
    return(szUniqueFileName);
}

void FillMyTime(MYTIMESTRUCT *MyTime)
{
	LPSYSTEMTIME lpSystemTime = (LPSYSTEMTIME)malloc(sizeof(LPSYSTEMTIME));
	TCHAR szTemp[MAX_PATH] = {0};

	GetSystemTime(lpSystemTime);
    if(!lpSystemTime)
        return;
        
	if(lpSystemTime->wMonth <= 9)
	{
		lstrcpy(MyTime->szMonth, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMonth);
		lstrcat(MyTime->szMonth, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMonth);
		lstrcpy(MyTime->szMonth, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wDay <= 9)
	{
		lstrcpy(MyTime->szDay, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wDay);
		lstrcat(MyTime->szDay, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wDay);
		lstrcpy(MyTime->szDay, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wYear <= 9)
	{
		lstrcpy(MyTime->szYear, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wYear);
		lstrcat(MyTime->szYear, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wYear);
		lstrcpy(MyTime->szYear, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wHour <= 9)
	{
		lstrcpy(MyTime->szHour, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wHour);
		lstrcat(MyTime->szHour, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wHour);
		lstrcpy(MyTime->szHour, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wMinute <= 9)
	{
		lstrcpy(MyTime->szMinute, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMinute);
		lstrcat(MyTime->szMinute, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMinute);
		lstrcpy(MyTime->szMinute, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wSecond <= 9)
	{
		lstrcpy(MyTime->szSecond, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wSecond);
		lstrcat(MyTime->szSecond, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wSecond);
		lstrcpy(MyTime->szSecond, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wMilliseconds <= 9)
	{
		lstrcpy(MyTime->szMillisecond, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMilliseconds);
		lstrcat(MyTime->szMillisecond, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMilliseconds);
		lstrcpy(MyTime->szMillisecond, szTemp);
	}
    if(lpSystemTime)
        free(lpSystemTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\nt5net.cpp ===
#include "globals.h"

kNT5NetWalk::kNT5NetWalk(kLogFile *Proc, HWND hIn)
{
LogProc=Proc;
hMainWnd=hIn;
}

BOOL kNT5NetWalk::Begin()
{
DWORD dwRet=0;
dwCurrentKey=0;
dwLevel2Key=0;
strcpy(szRootKeyString, "SYSTEM\\CurrentControlSet\\Control\\Network");
dwRet=RegOpenKeyEx(
   HKEY_LOCAL_MACHINE, 
   szRootKeyString,
   0, 
   KEY_READ, 
   &hkeyRoot);
if (dwRet==ERROR_SUCCESS)
   {
//MessageBox(GetFocus(), "Returning REG_SUCCESS", "SP", MB_OK);
   return REG_SUCCESS;
   }      
else 
   {
   char szMessage[1024];
   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, dwRet, 
      NULL, szMessage, 1024, 0);
   printf("**********\r\n");
   printf("%s[%d] Error: %s", __FILE__, __LINE__, szMessage);
   printf("**********\r\n");
//MessageBox(GetFocus(), "Returning REG_FAIL", "SP", MB_OK);
   return REG_FAILURE;
   }
//else if (dwPlatform==PLATFORM_NT)
//MessageBox(GetFocus(), "Returning REG_FAIL", "SP", MB_OK);
return REG_FAILURE;
}

BOOL kNT5NetWalk::Walk()
{
    DWORD dwIndex = 0;
    PTCHAR szName = NULL;
    DWORD dwSizeName = MAX_PATH * 4;

    LogProc->LogString(",#NT5_Net_Components,,\r\n");
    
    szName = (PTCHAR)malloc(dwSizeName);
    
    if(!szName) {
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, dwIndex, szName, &dwSizeName, NULL, NULL, NULL, NULL))
    {
        TCHAR szFull[MAX_PATH * 4];
        wsprintf(szFull, "SYSTEM\\CurrentControlSet\\Control\\Network\\%s", szName);
        GetKeyValues(szFull);
        SearchSubKeys(szFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    return TRUE;
}

BOOL kNT5NetWalk::SearchSubKeys(PTCHAR szName)
{
    HKEY hKeyTemp;
    DWORD dwRet = 0;
    PTCHAR szName2 = NULL;
    DWORD dwIndex = 0;
    DWORD dwSizeName = MAX_PATH * 4;
    TCHAR szFull[MAX_PATH * 4];

    if(!szName)
        return FALSE;
        
    szName2 = (PTCHAR)malloc(MAX_PATH * 4);
    
    if(!szName2)
        return FALSE;
        
    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hKeyTemp)) {
        free(szName2);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hKeyTemp, dwIndex, szName2, &dwSizeName, NULL, NULL, NULL, NULL)) {
        wsprintf(szFull, "%s\\%s", szName, szName2);
        GetKeyValues(szFull);
        SearchSubKeys(szFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    
    free(szName2);
    return TRUE;
}

BOOL kNT5NetWalk::GetKeyValues(char *szName)
{
HKEY hkeyUninstallKey;
char szFullKey[1024];
PUCHAR szProductName=(PUCHAR)malloc(1024);
DWORD dwProductSize=1024;
DWORD dwRet=0;
DWORD dwType=REG_SZ;
strcpy(szFullKey, szRootKeyString);
strcat(szFullKey, "\\");
strcat(szFullKey, szName);
dwRet=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, 
   KEY_READ, &hkeyUninstallKey);
if (dwRet==ERROR_SUCCESS)
   {
   dwRet=RegQueryValueEx(hkeyUninstallKey, "ComponentId", NULL, &dwType,
      szProductName, &dwProductSize);
   if (dwRet==ERROR_SUCCESS)
      {
      printf("Product = %s\r\n", szProductName);
LogProc->StripCommas((char*)szProductName);
      LogProc->LogString(",%s,\r\n", szProductName);
      free(szProductName);
      RegCloseKey(hkeyUninstallKey);
      return REG_SUCCESS;
      }         
/*
   else 
      {
      printf("Product = %s\r\n", szName);
LogProc->StripCommas(szName);
      LogProc->LogString(",%s,\r\n", szName);
      free(szProductName);
      RegCloseKey(hkeyUninstallKey);
      return REG_SUCCESS;
      //Check for other ways to get product name
      }
*/
   }
else 
   {
   char szMessage[1024];
   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, dwRet, 
      NULL, szMessage, 1024, 0);
   printf("**********\r\n");
   printf("%s[%d] Error: %s",__FILE__, __LINE__, szMessage);
   printf("**********\r\n");
   free(szProductName);
   RegCloseKey(hkeyUninstallKey);
   return REG_FAILURE;
   }
free(szProductName);
RegCloseKey(hkeyUninstallKey);
return REG_FAILURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\globals.h ===
#ifndef GLOBALS_H
#define GLOBALS_H

//Use alpha to build axp version.  can use w/ internal or sb flags.  
//use sb or internal to build those specific versions.  Default is external.
//#define INTERNAL
//#define SB
//#define ALPHA
#define NOCHKUPGRD

#include <windows.h>
#include <dbt.h>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>
#include "cfgmgr32.h"
#include <objbase.h>
#include <objidl.h>
#include <shlobj.h>
#include <setupapi.h>
#include <tchar.h>
//#include <e:\root\dev\inc16\setupx.h>

//#define BRYANPARSE

//#define NOCREDE
//#define LOWORD(l)   ((WORD) (l)) 

#define ENUM_SUCCESS            0
#define ENUM_SIBLINGFAILURE     1
#define ENUM_CHILDFAILURE       2
#define ENUM_POSTFAILURE        3
#define ENUM_GENFAILURE         4

#define PLATFORM_9X 0
#define PLATFORM_NT4 1
#define PLATFORM_NT5 2

#define REG_SUCCESS TRUE
#define REG_FAILURE FALSE

#define SYSP_MAX_STR_LEN 1024

//#define szLogFile "c:\\windows\\desktop\\logger.csv"

BOOL LogString(char *szFile, char *szString, ...);
void DebugOutf(char *szFormat, ...);
int EnumerateDevices(DEVNODE dnDevNodeTraverse, int j, DEVNODE dnParentNode);
DWORD EnumerateClasses(ULONG ulIndex);
HRESULT ResolveIt(HWND hwnd, LPCSTR lpszLinkFile, LPSTR lpszPath);

DWORD GetClassDevs(CHAR *szClassName);
extern BOOL g_WalkStartMenu;
//BOOL WalkStartMenu;
//TCHAR g_WindowsDirectory[];

//HWND g_MainWindow;


class kLogFile
{
public:
   BOOL LogString(TCHAR *szString, ...);
   BOOL InitFile(TCHAR *szTempFile, TCHAR* szTempDir);
   kLogFile();
   ~kLogFile();
   TCHAR *szFile;
   BOOL StripCommas(TCHAR *szString);
   void ValidateString(PTCHAR pString, int dwLen);
   TCHAR *szLogDir;
private:
};

class kWin9xDevWalk
{
public:
   int Go();
   kLogFile *LogProc;
   kWin9xDevWalk(kLogFile *Proc);
   BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
   void AppendToLogFile(PTCHAR szFile);
   ~kWin9xDevWalk();
private:
};

class kNT5DevWalk
{
public:
   int Go();
   kLogFile *LogProc;
   kNT5DevWalk(kLogFile *Proc);
   BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
   void AppendToLogFile(PTCHAR szFile);
   ~kNT5DevWalk();
private:
};

/*
class kWin9xAppWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   HKEY hkeyRoot;
   BOOL bRegStat;
   char szRootKeyString[1024]; 
   BOOL Begin(WORD dwPlatform);
   BOOL NextKey(WORD wPlatform);
   BOOL Walk(WORD wPlatform);
   BOOL GetUninstallValues(WORD wPlatform, char* szName);
   kWin9xAppWalk(kLogFile *Proc, HWND hIn);
   kLogFile *LogProc;
   HWND hMainWnd;
   BOOL WalkDir(char *szTempPath, char *szFile);
   BOOL WalkStartMenu();
   HRESULT ResolveIt(LPCSTR lpszLinkFile, LPSTR lpszPath);
   BOOL EndsInLnk(char *szFile);
   void GetAppVer(LPSTR pszAppName);
private:
};
*/

class kNT5AppWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   HKEY hkeyRoot;
   BOOL bRegStat;
   char szRootKeyString[1024]; 
   BOOL Begin();
   BOOL NextKey();
   BOOL Walk();
   BOOL GetUninstallValues(char* szName);
   kNT5AppWalk(kLogFile *Proc, HWND hIn);
   kLogFile *LogProc;
   HWND hMainWnd;
   BOOL WalkDir(char *szTempPath, char *szFile);
   BOOL WalkStartMenu();
   HRESULT ResolveIt(LPCSTR lpszLinkFile, LPSTR lpszPath);
   BOOL EndsInLnk(char *szFile);
   void GetAppVer(LPSTR pszAppName);

//   BOOL GetNetStrings();
private:
};

class kNT5NetWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   DWORD dwLevel2Key;
   HKEY hkeyRoot;
   char szRootKeyString[1024]; 
   kLogFile *LogProc;
   HWND hMainWnd;

   kNT5NetWalk(kLogFile *Proc, HWND hIn);
   BOOL Begin();
   BOOL Walk();
   BOOL SearchSubKeys(char *szName);
   BOOL GetKeyValues(char* szName);
private:
};

class kNT4DevWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   DWORD dwLevel2Key;
   HKEY hkeyRoot;
   char szRootKeyString[1024]; 
   kLogFile *LogProc;
   HWND hMainWnd;

   kNT4DevWalk(kLogFile *Proc, HWND hIn);
   BOOL Begin();
   BOOL Walk();
   BOOL SearchSubKeys(char *szName);
   BOOL GetKeyValues(char* szName);
private:
};

typedef UINT (CALLBACK* LPFNDLLFUNC1)(LPCTSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
typedef UINT (CALLBACK* LPFNDLLFUNC2)(LPTSTR, UINT);

class CLASS_GeneralAppWalk
{
public:
        BOOL OpenRegistry(void);
        BOOL GetUninstallValues(TCHAR *KeyName);
        BOOL NextKey(void);
        BOOL Walk(void);
        CLASS_GeneralAppWalk(kLogFile *LogProc, HWND hIn);
        BOOL WalkStartMenu(void);
        BOOL WalkDir(TCHAR *TempPath, TCHAR *File);
        BOOL EndsInLnk(TCHAR *File);
        HRESULT ResolveIt(LPCSTR LinkFile, LPSTR Path);
        BOOL GetAppVer(LPSTR AppName);
        BOOL GetCurrentWinDir(void);
        TCHAR g_WindowsDirectory[MAX_PATH];

private:
        HKEY HandleToUninstallKeyRoot;
        kLogFile *LogProc;
        HWND gHandleToMainWindow;
        DWORD CurrentKey;
        TCHAR RootKeyString[1024];
        WORD StartMenuLen;

};

typedef enum {
        Win95,
        Win98,
        NT4,
        Win2000,
        Whistler,
        Unknown
        } ENUM_OS_VERSION;



class CLASS_GeneralInfo
{
public:
        CLASS_GeneralInfo(kLogFile *LogProc, HWND hIn);
        void GetCurrentWindowsDirectory(void);
        void DetermineOS(void);
        BOOL InitLogFile(void);
        BOOL FillInArguments(void);
        BOOL DetermineArgumentValidity(void);
        void WriteVersions(void);
        void DetermineCommandLine(void);
        BOOL CopyInput(void);
        void GetUUID(void);
        void WriteArguments(void);
        void WriteFreeDiskSpace(void);
        void WriteVolumeType(void);
        void WriteMemorySize(void);
        void WriteOSVersion(void);

/*
        WriteDevices
        WriteApps
*/
        void InitHelpers(void);
        void AbuseOtherApps(void);
        BOOL Go(void);
        void ChangeSpaces(TCHAR *Input);
        BOOL ReadInFileInfo(TCHAR *FileName);
        void WriteGeneralInfo(void);
        BOOL AutoRun;
        BOOL RunMinimized;


private:
        HWND gHandleToMainWindow;
        kLogFile *LogProc;
        TCHAR WindowsDirectory[MAX_PATH]; //no trailing "\"
        ENUM_OS_VERSION OSVersion;
        TCHAR Corporation[1024];
        TCHAR Email[1024];
        TCHAR Manufacturer[1024];
        TCHAR Model[1024];
        TCHAR NumComp[1024];
        TCHAR SiteID[1024];
        WORD SiteIDIndex;
        TCHAR Profile[1024];
        TCHAR BetaID[1024];
        TCHAR MachineType[1024];
        WORD MachineTypeIndex;
        TCHAR OriginalMachineUUID[1024];
        TCHAR szRegFile[1024];
        TCHAR PlatformExtension[12];
        BOOL RunChkupgrd;
        BOOL RunDevdump;
        void CatLogFile(TCHAR *szFile);
        BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
        BOOL OverWrite;
        BOOL UseComputerName;

};


#endif //GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sysparse.rc
//
#define IDD_DIALOG_SYSPARSE             101
#define IDR_ACCELERATOR1                103
#define IDC_EDIT_CORPORATION            1000
#define IDC_EDIT_EMAIL                  1001
#define IDC_EDIT_MAKE                   1002
#define IDC_EDIT_MANUFACTURER           1002
#define IDC_EDIT_MODEL                  1003
#define IDC_EDIT_NUMCOMP                1004
#define IDC_EDIT_PROFILE                1005
#define IDC_EDIT_BETAID                 1006
#define IDC_COMBO_SITEID                1011
#define IDC_COMBO_TYPE                  1012
#define IDC_BUTTON_GO                   1013
#define IDC_BUTTON_EXIT                 1014
#define IDC_BUTTON_HELP                 1015
#define IDC_STATIC_PROFILE              1016
#define IDC_STATIC_BETAID               1017
#define IDC_STATIC_STATUS               1018
#define IDC_STATIC_HELP                 1019
#define ID_ACCEL40001                   40001
#define ID_ACCEL40002                   40002
#define ID_ACCEL40003                   40003
#define ID_ACCEL40004                   40004
#define ID_ACCEL40005                   40005
#define ID_ACCEL40007                   40007
#define ID_ACCEL40008                   40008
#define ID_ACCEL40009                   40009
#define ID_ACCEL40010                   40010
#define ID_ACCEL40011                   40011
#define ID_ACCEL40012                   40012
#define ID_ACCEL40013                   40013
#define ID_ACCEL40014                   40014
#define ID_ACCEL40015                   40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\logger.cpp ===
//logger.cpp

#include "globals.h"

BOOL kLogFile::StripCommas(PTCHAR szString)
{
    for (int i = 0; i <= (int)lstrlen(szString); i++)
    {
        if (szString[i] == ',')
            szString[i] = ' ';  //Replace comma with a space to make SQL friendly string
    }
    return TRUE;
}

BOOL kLogFile::LogString(PTCHAR szString, ...)
{
    HANDLE hFile;
    DWORD dwRet = 0;
    DWORD dwBytesWrit;
    PTCHAR szBuffer = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!szBuffer)
        return FALSE;
        
    va_list va;
    va_start(va,szString);
    vsprintf(szBuffer, szString, va);
    va_end(va);

    hFile = CreateFile(szFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        
        if(!WriteFile(hFile, szBuffer, lstrlen(szBuffer), &dwBytesWrit, NULL))
        {
            CloseHandle(hFile);
            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
            return FALSE;
        }
        
        if ((DWORD)lstrlen(szBuffer) != dwBytesWrit)
            LogString(",ERROR: String lengths differ,\r\n");
    }
    else
    {
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
        CloseHandle(hFile);  
        return FALSE;
    }
    
    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);     
    return TRUE;
}

kLogFile::InitFile(PTCHAR szTempFile, PTCHAR szTempDir)
{
    if (!szTempFile || !szTempDir)
        return FALSE;
        
    if ((lstrlen(szTempFile) <= 0) || (lstrlen(szTempDir) <= 0))
        return FALSE;
        
    szFile = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lstrlen(szTempFile) + 1) * sizeof(TCHAR));
        
    if(!szFile)
        return FALSE;
            
    szLogDir = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lstrlen(szTempDir) + 1) * sizeof(TCHAR));
        
    if(!szLogDir)
    {
        free(szFile);
        return FALSE;
    }   
    
    lstrcpy(szFile, szTempFile);
    lstrcpy(szLogDir, szTempDir);
    return TRUE;
}

kLogFile::kLogFile()
{
    szFile = NULL;
    szLogDir = NULL;
}

kLogFile::~kLogFile()
{
    if(szFile)
	    HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, szFile);
	if(szLogDir)
	    HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, szLogDir);
	    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sysparse\sysparse.cpp ===
#include "globals.h"
#include "resource.h"
#include "cmdline.h"

HWND g_MainWindow;
HINSTANCE g_GlobalInst;
BOOL g_HideWindow = FALSE;

INT_PTR CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
void FillInCombos(void);

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    static char szAppName[] = "SysParse";
    MSG msg;
    SetErrorMode (SEM_FAILCRITICALERRORS);
    SetErrorMode (SEM_NOOPENFILEERRORBOX);

    g_GlobalInst = hInstance;
    g_WalkStartMenu = TRUE;
    g_MainWindow = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG_SYSPARSE), NULL, WndProc);

    kCommandLine CommandLine;

    //Do we start minimized?
    if ( CommandLine.IsSpecified(TEXT("/m"), TRUE) || CommandLine.IsSpecified(TEXT("-m"), TRUE) )
        g_HideWindow = TRUE;
        

    while (GetMessage (&msg, NULL, 0, 0))
    {
        if (!IsWindow(g_MainWindow) || !IsDialogMessage(g_MainWindow, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }
    return 0;
}

INT_PTR CALLBACK WndProc (HWND DlgWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static HDC hdc;
    PAINTSTRUCT ps;
    BOOL bCreate;

    static kLogFile LogFile;
    static CLASS_GeneralInfo GeneralInfo((kLogFile*)&LogFile, DlgWnd);
    static enum _EnumProfile {eprofile, easset}EnumProfile;
    static enum _EnumBetaID {flocation, fasset, fevent, fbetaid}EnumBetaID;

    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            EnumProfile = eprofile;
            EnumBetaID = fbetaid;
            g_MainWindow = DlgWnd;
            if ( g_HideWindow == TRUE) {
                ShowWindow(g_MainWindow, SW_HIDE);
            }
            FillInCombos();
            if (!GeneralInfo.FillInArguments())
                PostQuitMessage(0);
            if (TRUE == GeneralInfo.RunMinimized)
                ShowWindow(DlgWnd, SW_MINIMIZE);
            if (TRUE == GeneralInfo.AutoRun)
                SetTimer(DlgWnd, 20, 20, NULL);
        }
        case WM_CREATE:
            return 0;
        case WM_DESTROY:
            PostQuitMessage (0);
            return 0;
        case WM_CLOSE:
            PostQuitMessage (0);
            return 0;
        case BN_CLICKED:
            return 0;
        case WM_TIMER:
        {
            switch (wParam)
            {
                case 1:
                    return 0;
                break;
                case 20:
                    KillTimer(DlgWnd, 20);
                    //do autorun stuff here.                    
                    GeneralInfo.Go();
                    SendMessage(DlgWnd, WM_CLOSE, 0, 0);
                    return 0;
                break;
                default:
                    return 0;
                break;
            }
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON_GO:
                {
                    GeneralInfo.Go();
                    return 0;
                }
                case IDC_BUTTON_EXIT:
                {
                    PostQuitMessage(0);
                    return 0;
                }
                case IDC_BUTTON_HELP:
                {
                    if (DlgWnd)
                    {
                        MessageBox(DlgWnd, "Copyright (c) 1999 - 2001 Microsoft Corp.\n\nFull instructions for running Sysparse can be found on the Sysparse website.\n\nBe aware that Sysparse may take up to 15 minutes to run and will call what appears to be Windows 2000 Setup and a blank MS-DOS window.\n\nSysparse Website:\nHTTP://winfo.microsoft.com/SysParse\nAccount:SysParser\nPassword:SysParser\n(Account name and password are case sensitive.)\n\nCommandline switches:\n/m - run minimized\n/a - autorun\n/o - automatically overwrite CSV\n/c - use computer name for profile\n/p <filename> - use <filename> as input file\n/w - write log to current directory\n/l - use .log extension rather than .csv\n/n<filename> - use <filename> (and .csv or .log) for output\n/x - suppress platform extension\n/1 through /9 - use text following each number for the corresponding data (spaces not allowed)\n/donotrun1 - Windows 2000 Upgrade Compatibility Report\n/donotrun2 - Extended Windows 2000 Device Analysis\n/s - Do not do app walk", "Sysparse", MB_OK);
                    }
                    return 0;
                }
                case IDC_COMBO_SITEID:
                {
                    TCHAR Temp[MAX_PATH];
                    HWND HandleToControl;
                    DWORD dwCR;

                    HandleToControl = (HWND)GetDlgItem(g_MainWindow, IDC_COMBO_SITEID);
                    dwCR = (DWORD)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);
                    if ((CB_ERR != dwCR))
                    {
                        HWND StaticProfile, StaticBetaID;
                        TCHAR act[MAX_PATH];
                        SendMessage(HandleToControl, CB_GETLBTEXT, dwCR, (LPARAM)(LPCTSTR)act);
                        _tcslwr(act);
                        StaticProfile = GetDlgItem(g_MainWindow, IDC_STATIC_PROFILE);
                        StaticBetaID = GetDlgItem(g_MainWindow, IDC_STATIC_BETAID);
                        if (!lstrcmp(act, TEXT("ntrecon")) || !lstrcmp(act, TEXT("oobe")) || !lstrcmp(act, TEXT("internal")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Location:");
                            EnumProfile = eprofile;
                            EnumBetaID = flocation;
                        }
                        else if (!lstrcmp(act, TEXT("whql")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Asset #:");
                            EnumProfile = eprofile;
                            EnumBetaID = fasset;
                        }
                        else if (!lstrcmp(act, TEXT("msevent")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Event:");
                            EnumProfile = eprofile;
                            EnumBetaID = fevent;
                        }
                        else if (!lstrcmp(act, TEXT("ihv")) || !lstrcmp(act, TEXT("sb")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Beta ID:");
                            EnumProfile = eprofile;
                            EnumBetaID = fbetaid;
                        }
                        else if (!lstrcmp(act, TEXT("inventory")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Asset #:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Location:");
                            EnumProfile = easset;
                            EnumBetaID = flocation;
                        }
                        else
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Beta ID:");
                            EnumProfile = eprofile;
                            EnumBetaID = fbetaid;
                        }
                    }
                    HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                     SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Use either Corp, OEM, SB (System Builder) or BetaSite, depending of your line of business.\nMore Descriptions can be found on the SysParse Web Site (See Help).");
                }
                break;
                case IDC_EDIT_PROFILE:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        switch (EnumProfile)
                        {
                            case eprofile:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Unique profile name that describes exactly what the target system is and does.\nExample: \nDev_Machine_Type#2_NT4");
                            break;
                            case easset:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"MS or Vendor Asset tag on CPU.\nExample: \nV33498");
                            break;
                        }
                    }
                }
                break;
                case IDC_EDIT_BETAID:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        switch (EnumBetaID)
                        {
                            case fbetaid:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"BetaID for the user or corporation running SysParse.\nExample: \n441743");
                            break;
                            case flocation:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Physical location of this machine.\nExample: \n27N/ 2793 / Row 8 Machine 3 or NTRecon Houston Apex Computers");
                            break;
                            case fevent:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Type or name of event where SysParse is being run.\nExample: \n1-5-99 San Diego Plugfest");
                            break;
                            case fasset:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"MS or Vendor Asset tag on CPU.\nExample: \nV33498");
                            break;
                        }
                    }
                }
                break;
                case IDC_EDIT_MANUFACTURER:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Manufacturer of the target system\nExample:\nAwesome Computers");
                    }
                }
                break;
                case IDC_EDIT_CORPORATION:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Stock ticker name of company running SysParse.  If no stock ticker name is available, spell out the entire name.\nExample: \nMSFT or Halcyon Systems");
                    }
                }
                break;
                case IDC_EDIT_MODEL:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Model information of the target system.\nExample: \nLaptop 20LMC");
                    }
                }
                break;
                case IDC_COMBO_TYPE:
                {
                    HWND HandleToControl;
                    HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Example: \nDesktop, Mobile, Server, Workstation");
                }
                break;
                case IDC_EDIT_NUMCOMP:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Number of computers installed at your site represented by this exact machine profile (for example, 50).\nSystem Manufacturers should set this value to 1.");
                    }
                }
                break;
                case IDC_EDIT_EMAIL:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Electronic-mail address of contact responsible for running SysParse\nExample: \njohndoe@microsoft.com");
                    }
                }
                break;
            }
        }
    }
    return 0;
}


void FillInCombos(void)
{
    TCHAR Name[50];
    HWND HandleToControl;

    HandleToControl=GetDlgItem(g_MainWindow, IDC_COMBO_SITEID);
#ifndef SB
    lstrcpy(Name, "");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "CORP");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "OEM");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "BetaSite");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "IHV");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "WHQL");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#ifdef INTERNAL
    lstrcpy(Name, "NTRECON");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "OOBE");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "WHQL");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "MSEvent");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Internal");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Inventory");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "SB");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#endif //Internal
#endif //SB

#ifdef SB
    lstrcpy(Name, "SB");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#endif

    HandleToControl = GetDlgItem(g_MainWindow, IDC_COMBO_TYPE);
    lstrcpy(Name, "");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Desktop");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Mobile");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Server");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Workstation");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\systrack\process.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: process.cxx
// author: silviuc
// created: Mon Nov 09 16:03:42 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "systrack.hxx"


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define TRACK_PROCESS_TABLE_SIZE 256
#define TRACK_PROCESS_HISTORY_SIZE 60

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

class TRACK_PROCESS_INFORMATION
{
  public:

    union {
        ULONG Key;
        ULONG Id;
    };

    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> Threads;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> Handles;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> WorkingSetSize;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> VirtualSize;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> PagefileUsage;

  public:

    bool VerifyThreads (SIZE_T DeltaValue) {
        return Threads.Delta (DeltaValue);
    }

    bool VerifyHandles (SIZE_T DeltaValue) {
        return Handles.Delta (DeltaValue);
    }

    bool VerifyWorkingSetSize (SIZE_T DeltaValue) {
        return WorkingSetSize.Delta (DeltaValue);
    }

    bool VerifyVirtualSize (SIZE_T DeltaValue) {
        return VirtualSize.Delta (DeltaValue);
    }

    bool VerifyPagefileUsage (SIZE_T DeltaValue) {
        return PagefileUsage.Delta (DeltaValue);
    }


    void Print (UNICODE_STRING Name) {
        static unsigned Calls = 0;

        if (Calls % 25 == 0)
          {
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            printf ("%-15s %-5s %-13s %-11s %-11s %-11s %-11s \n", 
                    "Process", "Id", "Handles", "Threads", 
                    "WSet(Mb)", "Vsize(Mb)", "Pfile(Mb)");
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            fflush( stdout );
          }

        Calls++;

        printf ("%-15ws %-5u ", Name.Buffer, Key);
        printf ("%-6u %-6u %-5u %-5u %-5u %-5u %-5u %-5u %-5u %-5u\n",
                Handles.Last(),
                Handles.First(),
                Threads.Last(),
                Threads.First(),
                WorkingSetSize.Last() / 0x100000,
                WorkingSetSize.First() / 0x100000,
                VirtualSize.Last() / 0x100000,
                VirtualSize.First() / 0x100000,
                PagefileUsage.Last() / 0x100000,
                PagefileUsage.First() / 0x100000);
        fflush( stdout );

        DebugMessage ("systrack: %ws (%u): Hndl: %u +%d, Thrd: %u +%d, "
                      "Wset: %u +%d, Vsize: %u +%d, Pfile: %u +%d\n",
                      Name.Buffer,
                      Key,
                      Handles.Last(),
                      Handles.Last() - Handles.First(),
                      Threads.Last(),
                      Threads.Last() - Threads.First(),
                      WorkingSetSize.Last() / 0x100000,
                      ( (int)WorkingSetSize.Last() - (int)WorkingSetSize.First()) / 0x100000,
                      VirtualSize.Last() / 0x100000,
                      ( (int)VirtualSize.Last() - (int)VirtualSize.First()) / 0x100000,
                      PagefileUsage.Last() / 0x100000,
                      ( (int)PagefileUsage.Last() - (int)PagefileUsage.First()) / 0x100000);
                      
    }
};

typedef TRACK_PROCESS_INFORMATION * PTRACK_PROCESS_INFORMATION;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

Table<TRACK_PROCESS_INFORMATION, TRACK_PROCESS_TABLE_SIZE> ProcessTable;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

void 
SystemProcessTrack (


    ULONG Period,
    ULONG DeltaHandles,
    ULONG DeltaThreads,
    ULONG DeltaWorkingSetSize,
    SIZE_T DeltaVirtualSize,
    SIZE_T DeltaPagefileUsage)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_PROCESS_INFORMATION Info;
    BOOL FinishNextTime = FALSE;
    BOOL PrintThreads, PrintHandles, PrintWSSize, PrintVirtSize, PrintPageFile;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_PROCESS_INFORMATION)QuerySystemProcessInformation();
    
        //
        // Loop over the processes and see if something changed.
        //
        
        for (FinishNextTime = FALSE;
             FinishNextTime == FALSE;
             Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            PTRACK_PROCESS_INFORMATION Process;

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // Skip over the idle process.
            //
            
            if (Info->UniqueProcessId == 0)
                continue;
            
            //
            // Add process to the process table.
            //
            
            Process = ProcessTable.Add (PtrToUlong(Info->UniqueProcessId));
            assert_ (Process != 0);

            Process->Threads.Add (Info->NumberOfThreads);
            Process->Handles.Add (Info->HandleCount);
            Process->WorkingSetSize.Add (Info->WorkingSetSize);
            Process->VirtualSize.Add (Info->VirtualSize);
            Process->PagefileUsage.Add (Info->PagefileUsage);

            PrintThreads = FALSE;
            if (Process->VerifyThreads (DeltaThreads)) {

                PrintThreads = TRUE;
            }

            PrintHandles = FALSE;
            if (Process->VerifyHandles (DeltaHandles)) {

                PrintHandles = TRUE;
            }

            PrintWSSize = FALSE;
            if (Process->VerifyWorkingSetSize (DeltaWorkingSetSize)) {
                
                PrintWSSize = TRUE;
            }

            PrintVirtSize = FALSE;
            if (Process->VerifyVirtualSize (DeltaVirtualSize)) {
                
                PrintVirtSize = TRUE;
            }

            PrintPageFile = FALSE;
            if (Process->VerifyPagefileUsage (DeltaPagefileUsage)) {

                PrintPageFile = TRUE;
            }

            if( PrintThreads || PrintHandles || PrintWSSize || PrintVirtSize || PrintPageFile ) {
                 
                Process->Print(Info->ImageName);
                
                if( PrintThreads ) {
                    Process->Threads.Reset (Info->NumberOfThreads);
                }

                if( PrintHandles ) {
                    Process->Handles.Reset (Info->HandleCount);
                }

                if( PrintWSSize ) {
                    Process->WorkingSetSize.Reset (Info->WorkingSetSize);
                }

                if( PrintVirtSize ) {
                    Process->VirtualSize.Reset (Info->VirtualSize);
                }

                if( PrintPageFile ) {
                    Process->PagefileUsage.Reset (Info->PagefileUsage);
                }
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}


void 
SystemProcessIdTrack (

    ULONG Period,
    ULONG ProcessId,
    ULONG DeltaHandles,
    ULONG DeltaThreads,
    ULONG DeltaWorkingSetSize,
    SIZE_T DeltaVirtualSize,
    SIZE_T DeltaPagefileUsage)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_PROCESS_INFORMATION Info;
    BOOL FinishNextTime = FALSE;
    BOOL PrintThreads, PrintHandles, PrintWSSize, PrintVirtSize, PrintPageFile;

    for ( ; ; )
      {
        //
        // SystemProcessInformation
        //
        
        Info = (PSYSTEM_PROCESS_INFORMATION)QuerySystemProcessInformation();
    
        //
        // Loop over the processes and see if something changed.
        //
        
        for (FinishNextTime = FALSE;
             FinishNextTime == FALSE;
             Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            PTRACK_PROCESS_INFORMATION Process;

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // Skip over the idle process.
            //
            
            if (Info->UniqueProcessId == 0)
                continue;

            //
            // If this is not the process we want to track
            // skip it.
            //
            
            if ((ULONG_PTR)(Info->UniqueProcessId) != ProcessId)
                continue;

            //
            // Add process to the process table.
            //

            Process = ProcessTable.Add (PtrToUlong(Info->UniqueProcessId));
            assert_ (Process != 0);

            Process->Threads.Add (Info->NumberOfThreads);
            Process->Handles.Add (Info->HandleCount);
            Process->WorkingSetSize.Add (Info->WorkingSetSize);
            Process->VirtualSize.Add (Info->VirtualSize);
            Process->PagefileUsage.Add (Info->PagefileUsage);

            PrintThreads = FALSE;
            if (Process->VerifyThreads (DeltaThreads)) {

                PrintThreads = TRUE;
            }

            PrintHandles = FALSE;
            if (Process->VerifyHandles (DeltaHandles)) {

                PrintHandles = TRUE;
            }

            PrintWSSize = FALSE;
            if (Process->VerifyWorkingSetSize (DeltaWorkingSetSize)) {
                
                PrintWSSize = TRUE;
            }

            PrintVirtSize = FALSE;
            if (Process->VerifyVirtualSize (DeltaVirtualSize)) {
                
                PrintVirtSize = TRUE;
            }

            PrintPageFile = FALSE;
            if (Process->VerifyPagefileUsage (DeltaPagefileUsage)) {

                PrintPageFile = TRUE;
            }

            if( PrintThreads || PrintHandles || PrintWSSize || PrintVirtSize || PrintPageFile ) {
                 
                Process->Print(Info->ImageName);
                
                if( PrintThreads ) {
                    Process->Threads.Reset (Info->NumberOfThreads);
                }

                if( PrintHandles ) {
                    Process->Handles.Reset (Info->HandleCount);
                }

                if( PrintWSSize ) {
                    Process->WorkingSetSize.Reset (Info->WorkingSetSize);
                }

                if( PrintVirtSize ) {
                    Process->VirtualSize.Reset (Info->VirtualSize);
                }

                if( PrintPageFile ) {
                    Process->PagefileUsage.Reset (Info->PagefileUsage);
                }
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}


//
// end of module: process.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\systrack\pooltag.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: pooltag.cxx
// author: silviuc
// created: Wed Nov 11 13:45:37 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "systrack.hxx"
#include "pooltag.hxx"


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define TRACK_POOLTAG_TABLE_SIZE 16384
#define TRACK_POOLTAG_HISTORY_SIZE 60

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

class TRACK_POOLTAG_INFORMATION
{
  public:
    
    union {
        UCHAR Tag[4];
        ULONG Key;
    };

    SIZE_T LastNonPagedUsed;
    SIZE_T LastPagedUsed;

    History<SIZE_T, TRACK_POOLTAG_HISTORY_SIZE> PagedUsed;
    History<SIZE_T, TRACK_POOLTAG_HISTORY_SIZE> NonPagedUsed;

  public:

    bool VerifyNonPagedUsed (SIZE_T DeltaValue) {
        return NonPagedUsed.Delta (DeltaValue);
    }

    bool VerifyPagedUsed (SIZE_T DeltaValue) {
        return PagedUsed.Delta (DeltaValue);
    }

    void Print () {

        static unsigned Calls = 0;
        UCHAR * TagChar;
        ULONG FirstIndex, LastIndex;


        TagChar = (UCHAR *)(& Key);

        if (Calls % 25 == 0)
          {
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            printf ("%-4s  %-16s  %-16s \n", "Tag", "NP pool", "P pool");
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            fflush( stdout );
          }

        Calls++;

        printf ("%c%c%c%c  ",
                TagChar[0],
                TagChar[1],
                TagChar[2],
                TagChar[3]);

        printf ("%-8u %-8u %-8u %-8u\n",
                NonPagedUsed.Last(),
                NonPagedUsed.First(),
                PagedUsed.Last(),
                PagedUsed.First());
        
        fflush( stdout );

        DebugMessage ("systrack: pool: %c%c%c%c: NP: %u +%d, P: %u +%d\n",
                TagChar[0],
                TagChar[1],
                TagChar[2],
                TagChar[3],
                NonPagedUsed.Last(),
                NonPagedUsed.Last() - NonPagedUsed.First(),
                PagedUsed.Last(),
                PagedUsed.Last() - PagedUsed.First());
    }
};

typedef TRACK_POOLTAG_INFORMATION* PTRACK_POOLTAG_INFORMATION;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

Table<TRACK_POOLTAG_INFORMATION, TRACK_POOLTAG_TABLE_SIZE> PoolTable;

//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Pool tag table
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

void 
SystemPoolTrack (

    ULONG Period,
    ULONG Delta)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_POOLTAG_INFORMATION Info;
    BOOL PagedDelta, NonPagedDelta;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_POOLTAG_INFORMATION)QuerySystemPoolTagInformation();
    
        if (Info == NULL) {
          printf ("Probably pool tags are not enabled on this machine.\n");
          exit (1);
        }
    
        //
        // Loop over the tags and see if something changed.
        //
        
        {
            ULONG Index;
          
            for (Index = 0; Index < Info->Count; Index++) {

                PTRACK_POOLTAG_INFORMATION Tag;

                Tag = PoolTable.Add (Info->TagInfo[Index].TagUlong);
                if (Tag == NULL)
                    printf ("Cannot add pool table entry \n");
                  
                Tag->PagedUsed.Add (Info->TagInfo[Index].PagedUsed);
                Tag->NonPagedUsed.Add (Info->TagInfo[Index].NonPagedUsed);

                NonPagedDelta = FALSE;
                if (Tag->VerifyNonPagedUsed (Delta)) {
                    NonPagedDelta = TRUE;
                }

                PagedDelta = FALSE;
                if (Tag->VerifyPagedUsed (Delta)) {
                    PagedDelta = TRUE;
                }

                if( NonPagedDelta || PagedDelta ) {
                    
                    Tag->Print();

                    if( NonPagedDelta ) {
                        Tag->NonPagedUsed.Reset (Info->TagInfo[Index].NonPagedUsed);
                    }

                    if( PagedDelta ) {
                        Tag->PagedUsed.Reset (Info->TagInfo[Index].PagedUsed);
                    }
                }
            }
        }
        
        //
        // Sleep a little bit.
        //

        Sleep (Period);
      }
}

bool MatchTag (

    UCHAR * Pattern,
    UCHAR * Tag)
{
    unsigned Index;

    for (Index = 0; Index < 4; Index++)
      {
        if (Pattern[Index] == '*')
            return true;
        else if (Pattern[Index] == '?')
            continue;
        else if (Tag[Index] == Pattern[Index])
            continue;
        else
            return false;
      }

    return true;
}


void 
SystemPoolTagTrack (

    ULONG Period,
    UCHAR * PatternTag,
    ULONG Delta)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_POOLTAG_INFORMATION Info;
    BOOL NonPagedUsedDelta, PagedUsedDelta;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_POOLTAG_INFORMATION)QuerySystemPoolTagInformation();

        if (Info == NULL) {
          printf ("Probably pool tags are not enabled on this machine.\n");
          exit (1);
        }
    
        //
        // Loop over the tags and see if something changed.
        //
        
        {
            ULONG Index;
          
            for (Index = 0; Index < Info->Count; Index++) {

                PTRACK_POOLTAG_INFORMATION Tag;

                if (! MatchTag (PatternTag, (UCHAR *)(& (Info->TagInfo[Index].TagUlong))))
                    continue;

                Tag = PoolTable.Add (Info->TagInfo[Index].TagUlong);
                if (Tag == NULL)
                    printf ("Cannot add pool table entry \n");
                  
                Tag->PagedUsed.Add (Info->TagInfo[Index].PagedUsed);
                Tag->NonPagedUsed.Add (Info->TagInfo[Index].NonPagedUsed);
                
                NonPagedUsedDelta = FALSE;
                if (Tag->VerifyNonPagedUsed (Delta)) {
                    NonPagedUsedDelta = TRUE;
                }

                PagedUsedDelta = FALSE;
                if (Tag->VerifyPagedUsed (Delta)) { 
                    PagedUsedDelta = TRUE;

                }

                if( NonPagedUsedDelta || PagedUsedDelta ) {

                    Tag->Print();

                    if( NonPagedUsedDelta ) {

                        Tag->NonPagedUsed.Reset (Info->TagInfo[Index].NonPagedUsed);
                    }

                    if( PagedUsedDelta ) {
                        Tag->PagedUsed.Reset (Info->TagInfo[Index].PagedUsed);
                    }
                }
            }
        }
        
        //
        // Sleep a little bit.
        //

        Sleep (Period);
      }
}



//
// end of module: pooltag.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\systrack\memory.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: memory.cxx
// author: silviuc
// created: Fri Nov 20 19:41:38 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "memory.hxx"
#include "systrack.hxx"



void TrackPerformanceCounter (
    
    char * Name,
    ULONG Id,
    ULONG Period,
    LONG Delta)
{
    PSYSTEM_PERFORMANCE_INFORMATION Info;
    History<ULONG_PTR, 60> History;

    for ( ; ; )
      {
        //
        // SystemPerformanceInformation
        //
        
        Info = (PSYSTEM_PERFORMANCE_INFORMATION)QuerySystemPerformanceInformation();

        switch (Id) {

          case TRACK_AVAILABLE_PAGES: History.Add (Info->AvailablePages); break;
          case TRACK_COMMITTED_PAGES: History.Add (Info->CommittedPages); break;
          case TRACK_COMMIT_LIMIT: History.Add (Info->CommitLimit); break;
          case TRACK_PAGE_FAULT_COUNT: History.Add (Info->PageFaultCount); break;
          case TRACK_SYSTEM_CALLS: History.Add (Info->SystemCalls); break;
          case TRACK_TOTAL_SYSTEM_DRIVER_PAGES: History.Add (Info->TotalSystemDriverPages); break;
          case TRACK_TOTAL_SYSTEM_CODE_PAGES: History.Add (Info->TotalSystemCodePages); break;

          default: printf ("Invalid track performance Id \n"); exit (2); break;
        }

        if (Delta < 0) {
          
            //
            // We are looking for decreasing counters
            //

            if ((History.Last() < History.First()) && 
                ( (int)History.First() - (int)History.Last() > -Delta)) {

                printf ("%s: %u -%u \n",
                        Name,
                        History.Last(),
                        History.First() - History.Last());

                fflush( stdout );

                DebugMessage ("systrack: %s: %u -%d \n",
                              Name,
                              History.Last(),
                              History.First() - History.Last());

                History.Reset (History.Last ());
            }
        }
        else {

            //
            // We are looking for increasing counters
            //

            if ((History.Last() > History.First()) && 
                ( (int)History.Last() - (int)History.First() > Delta)) {

                printf ("%s: %u +%u \n",
                        Name,
                        History.Last(),
                        History.Last() - History.First());

                fflush( stdout );

                DebugMessage ("systrack: %s: %u +%d \n",
                              Name,
                              History.Last(),
                              History.Last() - History.First());

                History.Reset (History.Last ());
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}



//
// end of module: memory.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\systrack\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
SYSTRACK_BIN_DIR=binD
!ELSE
SYSTRACK_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(SYSTRACK_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(SYSTRACK_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(SYSTRACK_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(SYSTRACK_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ctfile.c ===
#include "ct.h"
#include <memory.h>

/*********************************************************************
* CtUnmapFile
*
*********************************************************************/
void
CtUnmapFile(
    PFILEMAP pfm)
{
    if (pfm->pmap != NULL) {
        UnmapViewOfFile(pfm->pmap);
        
        pfm->pmap    = NULL;
        pfm->pmapEnd = NULL;
    }

    if (pfm->hmap != NULL) {
        CloseHandle(pfm->hmap);
        pfm->hmap = NULL;
    }

    if (pfm->hfile != INVALID_HANDLE_VALUE) {
        CloseHandle(pfm->hfile);
        pfm->hfile = INVALID_HANDLE_VALUE;
    }
}

/*********************************************************************
* CtMapFile
*
*********************************************************************/
BOOL
CtMapFile(
    char* pszFile,
    PFILEMAP pfm)
{
    DWORD dwFileSize;

    pfm->hfile = CreateFile(
                        pszFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                        NULL);
    
    if (pfm->hfile == INVALID_HANDLE_VALUE) {
        LogMsg(LM_APIERROR, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(pfm->hfile, NULL);

    if (dwFileSize == 0xFFFFFFFF) {
        LogMsg(LM_APIERROR, "GetFileSize");
        goto CleanupAndFail;
    }

    pfm->hmap = CreateFileMapping(
                        pfm->hfile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL);
    
    if (pfm->hmap == NULL) {
        LogMsg(LM_APIERROR, "CreateFileMapping");
        goto CleanupAndFail;
    }

    pfm->pmap = MapViewOfFile(
                        pfm->hmap,
                        FILE_MAP_READ,
                        0,
                        0,
                        0);
    
    if (pfm->pmap == NULL) {
        LogMsg(LM_APIERROR, "MapViewOfFile");
        goto CleanupAndFail;
    }
    pfm->pmapEnd = pfm->pmap + dwFileSize;

    return TRUE;

CleanupAndFail:
    LogMsg(LM_ERROR, "CtMapFile failed. File: '%s'", pszFile);
    CtUnmapFile(pfm);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ct.h ===
#include "windows.h"

#ifdef _CTUI
#include "commctrl.h"
#endif // _CTUI

#define LM_ERROR    0x0001
#define LM_WARNING  0x0002
#define LM_PRINT    0x0004
#define LM_APIERROR 0x0008

typedef struct tagFILEMAP {
    HANDLE hfile;
    HANDLE hmap;
    char*  pmap;
    char*  pmapEnd;
} FILEMAP, *PFILEMAP;

typedef struct tagTag {
    char*           pszTag;
    UINT            uCallCount;
    UINT            uCallMax;
    struct tagTag** ppCall;
    UINT            uCalleeCount;
    UINT            uCalleeMax;
    struct tagTag** ppCallee;
    BOOL            bWalked;
} Tag, *PTag;

void __cdecl LogMsg(DWORD dwFlags, char *pszfmt, ...);

void CtUnmapFile(PFILEMAP pfm);
BOOL CtMapFile(char* pszFile, PFILEMAP pfm);

int ProcessInputFile(PFILEMAP pfm);

PTag FindTag(char* pszTag, int* pPos);
void ListCallerTree(char* pszTag, int nLevels, BOOL bIndent);
void ListCalleeTree(char* pszTag, int nLevels, BOOL bIndent);
void CheckUserRule(void);
void CheckUnnecessaryXXX(void);
void FreeMemory(void);


LPVOID Alloc(DWORD size);
LPVOID ReAlloc(PVOID pSrc, DWORD size, DWORD newSize);
BOOL   Free(LPVOID p);
BOOL   InitMemManag(void);
void   FreeMemManag(void);

#ifdef _CTUI
void PopulateCombo(HWND hwnd);

void CreateTree(char* pszRoot, BOOL bCaller);
void AddLevel(HTREEITEM hParent, PTag pTagP, BOOL bCaller);
#endif // _CTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\systrack\systrack.cxx ===
//
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1998
//

//
// module: systrack.cxx
// author: silviuc
// created: Mon Nov 09 12:20:41 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <common.ver>

#define VERSION_DEFINITION_MODULE
#include "version.hxx"

#define DEBUGINFO_DEFINITION_MODULE
#include "debug.hxx"

#include "pooltag.hxx"
#include "process.hxx"
#include "memory.hxx"
#include "systrack.hxx"

#define BUFFER_SIZE_STEP    ( 128 * 1024 )

void PrintCurrentTime ();
void PrintSystemBasicInformation ();
void PrintSystemPerformanceInformation ();
void PrintSystemProcessInformation (BOOL ShortDump);
void PrintSystemPoolDetailedInformation ();
void PrintSystemPoolTagInformation ();
void PrintProcessStackInformation ();

VOID
GetProcessStackInfo (
    PSYSTEM_PROCESS_INFORMATION Info,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize,
    PBOOL ErrorsFound
    );

//
// Functions:
//
//     Help
//
// Decription:
//
//     Prints help information to the stdout. Exits with status code 1.
//

static void
Help ()
{
    static char help_text [] =
"                                                                          \n"
"systrack - System resource tracking --" BUILD_MACHINE_TAG "\n"
VER_LEGALCOPYRIGHT_STR "\n"
"                                                                          \n"
"    systrack [INFO-CLASS]                                                 \n"
"                                                                          \n"
"    <> : if no class specified, print process information.                \n"
"    /system : print system basic information.                             \n"
"    /process : print process information.                                 \n"
"    /stack : print stack usage information for all processes.             \n"
"    /performance: print performance information.                          \n"
"    /pool : print pool tag information (pool tags should be enabled).     \n"
"    /pooldetailed : print pool information (only checked builds).         \n"
"    /all : print everything.                                              \n"
"                                                                          \n"
"    /trackpool PERIOD DELTA                                               \n"
"    /trackpooltag PERIOD PATTERN DELTA                                    \n"
"    /trackprocess PERIOD HANDLE THREAD WSET VSIZE PFILE                   \n"
"    /trackprocessid PERIOD ID HANDLE THREAD WSET VSIZE PFILE              \n"
"    /trackavailablepages PERIOD DELTA                                     \n"
"    /trackcommittedpages PERIOD DELTA                                     \n"
"    /trackcommitlimit PERIOD DELTA                                        \n"
"    /trackpagefaultcount PERIOD DELTA                                     \n"
"    /tracksystemcalls PERIOD DELTA                                        \n"
"    /tracktotalsystemdriverpages PERIOD DELTA                             \n"
"    /tracktotalsystemcodepages PERIOD DELTA                               \n"
"                                                                          \n"
"    /help TOPIC  detailed help for the topic (e.g. process, trackpool,    \n"
"                 trackprocessid, etc.).                                   \n"
"    ?, /?        help                                                     \n"
"    -version     version information                                      \n"
"                                                                          \n"
"Examples:                                                                 \n"
"                                                                          \n"
"    systrack /trackpool 1000 10000                                        \n"
"                                                                          \n"
"        Polls every 1000ms the kernel pools and will print every pool tag \n"
"        whose pool usage increased by more than 10000 bytes.              \n"
"                                                                          \n"
"    systrack /trackpooltag 1000 \"G*\" 10000                              \n"
"                                                                          \n"
"        Polls every 1000ms the kernel pools and will print every pool tag \n"
"        that matches the pattern if its pool usage increased by more      \n"
"        than 10000 bytes.                                                 \n"
"                                                                          \n"
"    systrack /trackprocess 1000 5 5 1000000 1000000 1000000               \n"
"                                                                          \n"
"        Polls every 1000ms the processes running and prints every process \n"
"        whose handle count increased by more than 5 or thread count       \n"
"        increased by more than 5 or working set size increased by more    \n"
"        than 1000000 or virtual size increased by more than 1000000 or    \n"
"        pagefile usage increased by more than 1000000.                    \n"
"                                                                          \n"
"    systrack /trackprocessid 1000 136 5 5 1000000 1000000 1000000         \n"
"                                                                          \n"
"        Polls every 1000ms the process with id 136 and reports if the     \n"
"        handle count increased by more than 5 or thread count             \n"
"        increased by more than 5 or working set size increased by more    \n"
"        than 1000000 or virtual size increased by more than 1000000 or    \n"
"        pagefile usage increased by more than 1000000.                    \n"
"                                                                          \n"
"                                                                          \n";

    printf (help_text);
    exit (1);
}


//
// Functions:
//
//     DetailedHelp
//
// Decription:
//
//     Prints help information to the stdout for a specific topic.
//     Exits with status code 1.
//

static void
DetailedHelp (

    char * Topic)
{
    char * help_text;

    if (_stricmp (Topic, "system") == 0) {
      help_text =
          "systrack /system                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "process") == 0) {
      help_text =
          "systrack /proces                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "performance") == 0) {
      help_text =
          "systrack /performance                                                \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackprocess") == 0) {
      help_text =
          "systrack /trackprocess                                               \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackprocessid") == 0) {
      help_text =
          "systrack /system                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackpool") == 0) {
      help_text =
          "systrack /trackpool                                                  \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackpooltag") == 0) {
      help_text =
          "systrack /trackpooltag                                               \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else {
      printf ("Unknown help topic %s \n", Topic);
      exit (1);
    }


    printf (help_text, VERSION_INFORMATION_VERSION);
    exit (1);
}


//
// Function:
//
//     main
//
// Description:
//
//     ?, -?, /? - print help information.
//     -version - print version information
//
//     default (system, process, pool)
//     /process
//     /stack
//     /system
//     /performance
//     /pool
//     /pooldetailed
//
//

void _cdecl
main (int argc, char *argv[])
{
    if (argc == 2 && _stricmp (argv[1], "?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "/?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "-?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "-h") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "/h") == 0)
        Help ();
    // if (argc == 3 && _stricmp (argv[1], "/help") == 0)
    //     DetailedHelp (argv[2]);

    if (argc == 2 && _stricmp (argv[1], "-version") == 0)
        dump_version_information ();

    try
      {
        //
        // Here comes the code ...
        //

        PrintCurrentTime ();

        if (argc == 1)
          {
            //
            // <> default options
            //

            // PrintSystemBasicInformation ();
            PrintSystemProcessInformation (TRUE);
            // PrintSystemPoolTagInformation ();
          }
        else if (argc == 2 && _stricmp (argv[1], "/stack") == 0)
          {
            //
            // /stack option
            //

            PrintProcessStackInformation ();
          }
        else if (argc == 2 && _stricmp (argv[1], "/all") == 0)
          {
            //
            // /all option
            //

            PrintSystemBasicInformation ();
            PrintSystemPerformanceInformation ();
            PrintSystemProcessInformation (FALSE);
            PrintSystemPoolTagInformation ();
            PrintSystemPoolDetailedInformation ();
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackpool") == 0)
          {
            //
            // /trackpool PERIOD DELTA
            //

            ULONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Delta == 0)
                Delta = 8192;

            if (Period == 0)
                Period = 1000;

            SystemPoolTrack (Period, Delta);
          }
        else if (argc == 5 && _stricmp (argv[1], "/trackpooltag") == 0)
          {
            //
            // /trackpooltag PERIOD PATTERN DELTA
            //

            ULONG Delta;
            ULONG Period;
            UCHAR * Pattern;

            Period = atoi (argv[2]);
            Pattern = (UCHAR *)(argv[3]);
            Delta = atoi (argv[4]);

            if (Delta == 0)
                Delta = 8192;

            if (Period == 0)
                Period = 1000;

            SystemPoolTagTrack (Period, Pattern, Delta);
          }
        else if (argc == 8 && _stricmp (argv[1], "/trackprocess") == 0)
          {
            //
            // /trackprocess PERIOD HANDLES THREADS WSET VSIZE PFILE
            //

            ULONG DeltaHandles;
            ULONG DeltaThreads;
            ULONG DeltaWorkingSet;
            SIZE_T DeltaVirtualSize;
            SIZE_T DeltaPagefileUsage;
            ULONG Period;

            Period = atoi (argv[2]);
            DeltaHandles = atoi (argv[3]);
            DeltaThreads = atoi (argv[4]);
            DeltaWorkingSet = atoi (argv[5]);
            DeltaVirtualSize = atoi (argv[6]);
            DeltaPagefileUsage = atoi (argv[7]);

            if (Period == 0)
                Period = 1000;

            if (DeltaHandles == 0)
                DeltaHandles = 32;

            if (DeltaThreads == 0)
                DeltaThreads = 8;

            if (DeltaWorkingSet == 0)
                DeltaWorkingSet = 0x100000;

            if (DeltaVirtualSize == 0)
                DeltaVirtualSize = 0x100000;

            if (DeltaPagefileUsage == 0)
                DeltaPagefileUsage = 0x100000;

            SystemProcessTrack (Period,
                                DeltaHandles, DeltaThreads, DeltaWorkingSet,
                                DeltaVirtualSize, DeltaPagefileUsage);
          }
        else if (argc == 9 && _stricmp (argv[1], "/trackprocessid") == 0)
          {
            //
            // /trackprocessid PERIOD ID HANDLES THREADS WSET VSIZE PFILE
            //

            ULONG ProcessId;
            ULONG DeltaHandles;
            ULONG DeltaThreads;
            ULONG DeltaWorkingSet;
            SIZE_T DeltaVirtualSize;
            SIZE_T DeltaPagefileUsage;
            ULONG Period;

            Period = atoi (argv[2]);
            ProcessId = atoi (argv[3]);
            DeltaHandles = atoi (argv[4]);
            DeltaThreads = atoi (argv[5]);
            DeltaWorkingSet = atoi (argv[6]);
            DeltaVirtualSize = atoi (argv[7]);
            DeltaPagefileUsage = atoi (argv[8]);

            if (Period == 0)
                Period = 1000;

            if (ProcessId == 0) {
              printf ("Bad process id %s\n", argv[3]);
              exit (1);
            }

            if (DeltaHandles == 0)
                DeltaHandles = 32;

            if (DeltaThreads == 0)
                DeltaThreads = 8;

            if (DeltaWorkingSet == 0)
                DeltaWorkingSet = 0x100000;

            if (DeltaVirtualSize == 0)
                DeltaVirtualSize = 0x100000;

            if (DeltaPagefileUsage == 0)
                DeltaPagefileUsage = 0x100000;

            SystemProcessIdTrack (Period, ProcessId,
                                  DeltaHandles, DeltaThreads, DeltaWorkingSet,
                                  DeltaVirtualSize, DeltaPagefileUsage);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackavailablepages") == 0)
          {
            //
            // /trackavailablepages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track decreasing values therefore delta should be negative.
            //

            TrackPerformanceCounter (argv[1], TRACK_AVAILABLE_PAGES, Period, -Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackcommittedpages") == 0)
          {
            //
            // /trackcommittedpages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_COMMITTED_PAGES, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackcommitlimit") == 0)
          {
            //
            // /trackcommitlimit PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_COMMIT_LIMIT, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackpagefaultcount") == 0)
          {
            //
            // /trackpagefaultcount PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_PAGE_FAULT_COUNT, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracksystemcalls") == 0)
          {
            //
            // /tracksystemcalls PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_SYSTEM_CALLS, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracktotalsystemdriverpages") == 0)
          {
            //
            // /tracktotalsystemdriverpages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_TOTAL_SYSTEM_DRIVER_PAGES, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracktotalsystemcodepages") == 0)
          {
            //
            // /tracktotalsystemcodepages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_TOTAL_SYSTEM_CODE_PAGES, Period, Delta);
          }
        else
          {
            for (int Count = 1; Count < argc; Count++)
              {
                if (_stricmp (argv[Count], "/system") == 0)
                    PrintSystemBasicInformation ();
                else if (_stricmp (argv[Count], "/performance") == 0)
                    PrintSystemPerformanceInformation ();
                else if (_stricmp (argv[Count], "/process") == 0)
                    PrintSystemProcessInformation (TRUE);
                else if (_stricmp (argv[Count], "/pool") == 0)
                    PrintSystemPoolTagInformation ();
                else if (_stricmp (argv[Count], "/pooldetailed") == 0)
                    PrintSystemPoolDetailedInformation ();
                else
                    Help ();
              }
          }
      }
    catch (...)
      {
        printf ("unexpected exception ...\n");
        fflush (stdout);
        exit (1);
      }

    exit (0);
}


//
// Function:
//
//     PrintCurrentTime
//
// Description:
//
//     Prints current time, machine name, etc.
//
//

void PrintCurrentTime ()
{
    TCHAR MachineName [32];
    LPCTSTR TimeString;
    time_t Time;
    DWORD Result;

    if (GetEnvironmentVariable (TEXT("COMPUTERNAME"), MachineName, sizeof MachineName) == 0)
        strcpy (MachineName, "unknown");

    time (&Time);
    TimeString = asctime (localtime (&Time));

    printf ("Systrack - System resource tracking, %s\n", VERSION_INFORMATION_VERSION);
    printf ("Machine: %s\n", MachineName);
    printf ("Time: %s\n", TimeString);
    fflush( stdout );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


//
// Macro:
//
//     _dump_, _dump_quad_ (object, field)
//
// Description:
//
//     Handy macros to dump the fields of a structure.
//

#define _dump_(object,field) printf ("%-30s %08X (%u)\n", #field, (ULONG)(object->field), (ULONG)(object->field))

#define _dump_quad_(object,field) printf ("%-30s %I64X (%I64u)\n", #field, (object->field.QuadPart), (object->field.QuadPart))


//
// Local:
//
//     InfoBuffer
//
// Description:
//
//     Large enough structure to hold theinformation returned by
//     NtQuerySystemInformation. I've opted for this solution because
//     systrack can run under heavy stress conditions and we do not
//     to allocate big chunks of memory dynamically in such a situation.
//
//     Note. If we decide to multithread the application we will need a
//     critical section to protect the information buffer.
//     CRITICAL_SECTION InfoBufferLock;
//

static TCHAR InfoBuffer [0x40000];

//
// Local:
//
//     PoolTagInformationBuffer
//
// Description:
//
//     Buffer for NtQuerySystemInformation( SystemPoolTagInformation ).
//     Its size is grown by QueryPoolTagInformationIterative if necessary.
//     The length of the buffer is held in PoolTagInformationBufferLength.
//

static TCHAR *PoolTagInformationBuffer = NULL;

//
// Local:
//
//     PoolTagInformationBufferLength
//
// Description:
//
//     The current length of PoolTagInformationBuffer.
//

size_t PoolTagInformationBufferLength = 0;


//
// Function:
//
//     QueryPoolTagInformationIterative
//
// Description:
//
// ARGUMENTS:
//
//     CurrentBuffer - a pointer to the buffer currently used for
//                     NtQuerySystemInformation( SystemPoolTagInformation ).
//                     It will be allocated if NULL or its size grown
//                     if necessary.
//
//      CurrentBufferSize - a pointer to a variable that holds the current
//                      size of the buffer.
//
// RETURNS:
//
//      NTSTATUS returned by NtQuerySystemInformation or
//      STATUS_INSUFFICIENT_RESOURCES if the buffer must grow and the
//      heap allocation for it fails.
//

NTSTATUS
QueryPoolTagInformationIterative(
    TCHAR **CurrentBuffer,
    size_t *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( TCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (TCHAR *) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;

        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            free( *CurrentBuffer );

            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (TCHAR *) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}

//
// Function:
//
//     QuerySystemPoolTagInformation
//
// Description:
//
//     Fills InfoBuffer with SystemPoolTagInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemPoolTagInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemPoolTagInformation
    //

    Status = QueryPoolTagInformationIterative(
        &PoolTagInformationBuffer,
        &PoolTagInformationBufferLength );

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(pooltag): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? PoolTagInformationBuffer : NULL;
}


//
// Function:
//
//     QuerySystemProcessInformation
//
// Description:
//
//     Fills InfoBuffer with SystemProcessInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemProcessInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (
        SystemProcessInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(process): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? InfoBuffer : NULL;
}


//
// Function:
//
//     QuerySystemPerformanceInformation
//
// Description:
//
//     Fills InfoBuffer with SystemPerformanceInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemPerformanceInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemPerformanceInformation
    //

    Status = NtQuerySystemInformation (
        SystemPerformanceInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(performance): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? InfoBuffer : NULL;
}


//
// Function:
//
//     PrintSystemBasicInformation
//
// Description:
//
//     Prints SystemPerformanceInformation.
//
//

void PrintSystemBasicInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System basic information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
        SystemBasicInformation,
        InfoBuffer,
        sizeof (SYSTEM_BASIC_INFORMATION),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_BASIC_INFORMATION Info = (PSYSTEM_BASIC_INFORMATION)InfoBuffer;

      _dump_(Info, PageSize);
      _dump_(Info, NumberOfPhysicalPages);
      _dump_(Info, LowestPhysicalPageNumber);
      _dump_(Info, HighestPhysicalPageNumber);
      _dump_(Info, AllocationGranularity);
      _dump_(Info, MinimumUserModeAddress);
      _dump_(Info, MaximumUserModeAddress);
      _dump_(Info, ActiveProcessorsAffinityMask);
      _dump_(Info, NumberOfProcessors);
    }
}


//
// Function:
//
//     PrintSystemPerformanceInformation
//
// Description:
//
//     Prints systemPerformanceInformation.
//

void PrintSystemPerformanceInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System performance information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPerformanceInformation
    //

    Status = NtQuerySystemInformation (
        SystemPerformanceInformation,
        InfoBuffer,
        sizeof (SYSTEM_PERFORMANCE_INFORMATION),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Performance): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_PERFORMANCE_INFORMATION Info = (PSYSTEM_PERFORMANCE_INFORMATION)InfoBuffer;

      _dump_quad_ (Info, IdleProcessTime);
      _dump_quad_ (Info, IoReadTransferCount);
      _dump_quad_ (Info, IoWriteTransferCount);
      _dump_quad_ (Info, IoOtherTransferCount);

      _dump_ (Info, IoReadOperationCount);
      _dump_ (Info, IoWriteOperationCount);
      _dump_ (Info, IoOtherOperationCount);
      _dump_ (Info, AvailablePages);
      _dump_ (Info, CommittedPages);
      _dump_ (Info, CommitLimit);
      _dump_ (Info, PeakCommitment);
      _dump_ (Info, PageFaultCount);
      _dump_ (Info, CopyOnWriteCount);
      _dump_ (Info, TransitionCount);
      _dump_ (Info, CacheTransitionCount);
      _dump_ (Info, DemandZeroCount);
      _dump_ (Info, PageReadCount);
      _dump_ (Info, PageReadIoCount);
      _dump_ (Info, CacheReadCount);
      _dump_ (Info, CacheIoCount);
      _dump_ (Info, DirtyPagesWriteCount);
      _dump_ (Info, DirtyWriteIoCount);
      _dump_ (Info, MappedPagesWriteCount);
      _dump_ (Info, MappedWriteIoCount);
      _dump_ (Info, PagedPoolPages);
      _dump_ (Info, NonPagedPoolPages);
      _dump_ (Info, PagedPoolAllocs);
      _dump_ (Info, PagedPoolFrees);
      _dump_ (Info, NonPagedPoolAllocs);
      _dump_ (Info, NonPagedPoolFrees);
      _dump_ (Info, FreeSystemPtes);
      _dump_ (Info, ResidentSystemCodePage);
      _dump_ (Info, TotalSystemDriverPages);
      _dump_ (Info, TotalSystemCodePages);
      _dump_ (Info, NonPagedPoolLookasideHits);
      _dump_ (Info, PagedPoolLookasideHits);
#if 0
      _dump_ (Info, Spare3Count);
#endif
      _dump_ (Info, ResidentSystemCachePage);
      _dump_ (Info, ResidentPagedPoolPage);
      _dump_ (Info, ResidentSystemDriverPage);
      _dump_ (Info, CcFastReadNoWait);
      _dump_ (Info, CcFastReadWait);
      _dump_ (Info, CcFastReadResourceMiss);
      _dump_ (Info, CcFastReadNotPossible);
      _dump_ (Info, CcFastMdlReadNoWait);
      _dump_ (Info, CcFastMdlReadWait);
      _dump_ (Info, CcFastMdlReadResourceMiss);
      _dump_ (Info, CcFastMdlReadNotPossible);
      _dump_ (Info, CcMapDataNoWait);
      _dump_ (Info, CcMapDataWait);
      _dump_ (Info, CcMapDataNoWaitMiss);
      _dump_ (Info, CcMapDataWaitMiss);
      _dump_ (Info, CcPinMappedDataCount);
      _dump_ (Info, CcPinReadNoWait);
      _dump_ (Info, CcPinReadWait);
      _dump_ (Info, CcPinReadNoWaitMiss);
      _dump_ (Info, CcPinReadWaitMiss);
      _dump_ (Info, CcCopyReadNoWait);
      _dump_ (Info, CcCopyReadWait);
      _dump_ (Info, CcCopyReadNoWaitMiss);
      _dump_ (Info, CcCopyReadWaitMiss);
      _dump_ (Info, CcMdlReadNoWait);
      _dump_ (Info, CcMdlReadWait);
      _dump_ (Info, CcMdlReadNoWaitMiss);
      _dump_ (Info, CcMdlReadWaitMiss);
      _dump_ (Info, CcReadAheadIos);
      _dump_ (Info, CcLazyWriteIos);
      _dump_ (Info, CcLazyWritePages);
      _dump_ (Info, CcDataFlushes);
      _dump_ (Info, CcDataPages);
      _dump_ (Info, ContextSwitches);
      _dump_ (Info, FirstLevelTbFills);
      _dump_ (Info, SecondLevelTbFills);
      _dump_ (Info, SystemCalls);

    }
}


//
// Function:
//
//     PrintSystemProcessInformation
//
// Description:
//
//     Prints SystemProcessInformation.
//
// Details:
//
//     These are the fields of a SYSTEM_PROCESS_INFORMATION structure:
//
//     ULONG NextEntryOffset;
//     ULONG NumberOfThreads;
//     LARGE_INTEGER SpareLi1;
//     LARGE_INTEGER SpareLi2;
//     LARGE_INTEGER SpareLi3;
//     LARGE_INTEGER CreateTime;
//     LARGE_INTEGER UserTime;
//     LARGE_INTEGER KernelTime;
//     UNICODE_STRING ImageName;
//     KPRIORITY BasePriority;
//     HANDLE UniqueProcessId;
//     HANDLE InheritedFromUniqueProcessId;
//     ULONG HandleCount;
//     ULONG SessionId;
//     ULONG SpareUl3;
//     SIZE_T PeakVirtualSize;
//     SIZE_T VirtualSize;
//     ULONG PageFaultCount;
//     ULONG PeakWorkingSetSize;
//     ULONG WorkingSetSize;
//     SIZE_T QuotaPeakPagedPoolUsage;
//     SIZE_T QuotaPagedPoolUsage;
//     SIZE_T QuotaPeakNonPagedPoolUsage;
//     SIZE_T QuotaNonPagedPoolUsage;
//     SIZE_T PagefileUsage;
//     SIZE_T PeakPagefileUsage;
//     SIZE_T PrivatePageCount;
//     LARGE_INTEGER ReadOperationCount;
//     LARGE_INTEGER WriteOperationCount;
//     LARGE_INTEGER OtherOperationCount;
//     LARGE_INTEGER ReadTransferCount;
//     LARGE_INTEGER WriteTransferCount;
//     LARGE_INTEGER OtherTransferCount;
//

void PrintSystemProcessInformation (

    BOOL ShortDump)
{
    NTSTATUS Status;
    ULONG RealLength;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOL FinishNextTime = FALSE;

    if (ShortDump)
      {
        printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
        printf ("System process information \n");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
      }
    else
      {
        printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
        printf ("System process information \n");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
      }

    fflush( stdout );

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
        SystemBasicInformation,
        &SysInfo,
        sizeof (SysInfo),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
      }

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (
        SystemProcessInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Process): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_PROCESS_INFORMATION Info = (PSYSTEM_PROCESS_INFORMATION)InfoBuffer;

      if (ShortDump)
        {
          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s\n",
                  "Process",
                  "Id",
                  "Sess",
                  "Pri",
                  "Thrds",
                  "Faults",
                  "Handles",
                  "Utime",
                  "Ktime",
                  "Wset",
                  "Vsize",
                  "Pfile",
                  "I/O");

          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s\n",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "%",
                  "%",
                  "pages",
                  "Mb",
                  "Mb",
                  "x1000");
        }
      else
        {
          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s %-5s %-5s\n",
                  "Process",
                  "Id",
                  "Sess",
                  "Pri",
                  "Thrds",
                  "Faults",
                  "Handles",
                  "Utime",
                  "Ktime",
                  "Wset",
                  "Vsize",
                  "Pfile",
                  "I/O",
                  "Npool",
                  "Ppool");

          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s %-5s %-5s\n",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "%",
                  "%",
                  "pages",
                  "Mb",
                  "Mb",
                  "x1000",
                  "Mb",
                  "Mb");
        }

      if (ShortDump)
        {
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
          printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
        }
      else
        {
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
        }

      fflush( stdout );

      for (FinishNextTime = FALSE ;
           FinishNextTime == FALSE;
           Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset))
        {
          if (Info->NextEntryOffset == 0)
              FinishNextTime = TRUE;

          //
          // User time vs Kernel time.
          //

          ULONG UserPercent, KernelPercent;

          UserPercent = (ULONG)((Info->UserTime.QuadPart) * 100
              / (Info->UserTime.QuadPart + Info->KernelTime.QuadPart));
          KernelPercent = 100 - UserPercent;

          //
          // I/O total count.
          //

          LARGE_INTEGER IoTotalCount;

          IoTotalCount.QuadPart = Info->ReadOperationCount.QuadPart
              + Info->WriteOperationCount.QuadPart
              + Info->OtherOperationCount.QuadPart;

          IoTotalCount.QuadPart /= 1000;

          //
          // Image name (special case the idle process).
          //

          if (Info->ImageName.Buffer == NULL)
              printf ("%-15s ", "Idle");
          else
              printf ("%-15ws ", Info->ImageName.Buffer);

          //
          // Print the stuff.
          //

          if (ShortDump)
            {
              printf ("%-5I64u %-5u %-4u %-5u %-8u %-8u %-5u %-5u %-6u %-5u %-5u %-5I64u\n",
                      (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                      Info->SessionId,
                      Info->BasePriority,
                      Info->NumberOfThreads,
                      Info->PageFaultCount,
                      Info->HandleCount,
                      UserPercent,
                      KernelPercent,
                      Info->WorkingSetSize / SysInfo.PageSize,
                      Info->VirtualSize / 0x100000,
                      Info->PagefileUsage / 0x100000,
                      (IoTotalCount.QuadPart));
            }
          else
            {
              printf ("%-5I64u %-5u %-4u %-5u %-8u %-8u %-5u %-5u %-6u %-5u %-5u %-5I64u %-5u %-5u\n",
                      (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                      Info->SessionId,
                      Info->BasePriority,
                      Info->NumberOfThreads,
                      Info->PageFaultCount,
                      Info->HandleCount,
                      UserPercent,
                      KernelPercent,
                      Info->WorkingSetSize / SysInfo.PageSize,
                      Info->VirtualSize / 0x100000,
                      Info->PagefileUsage / 0x100000,
                      (IoTotalCount.QuadPart),
                      Info->QuotaNonPagedPoolUsage / 0x100000,
                      Info->QuotaPagedPoolUsage / 0x100000);
            }

          fflush( stdout );
        }
    }
}


//
// Function:
//
//     PrintSystemPoolDetailedInformation
//
// Description:
//
//     Prints systemNonPagedPoolInformation and systemPagedPoolInformation.
//     The function returns something meaningful only on checked builds.
//
//     typedef struct _SYSTEM_POOL_ENTRY {
//         BOOLEAN Allocated;
//         BOOLEAN Spare0;
//         USHORT AllocatorBackTraceIndex;
//         ULONG Size;
//         union {
//             UCHAR Tag[4];
//             ULONG TagUlong;
//             PVOID ProcessChargedQuota;
//         };
//     } SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;
//
//     typedef struct _SYSTEM_POOL_INFORMATION {
//         SIZE_T TotalSize;
//         PVOID FirstEntry;
//         USHORT EntryOverhead;
//         BOOLEAN PoolTagPresent;
//         BOOLEAN Spare0;
//         ULONG NumberOfEntries;
//         SYSTEM_POOL_ENTRY Entries[1];
//     } SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;
//

void PrintSystemPoolDetailedInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System pool detailed information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPoolInformation
    //

    Status = NtQuerySystemInformation (
        SystemNonPagedPoolInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(NonPagedPool): error %08X\n", Status);
        return;
      }

    {
      ULONG Index;
      PSYSTEM_POOL_INFORMATION Info = (PSYSTEM_POOL_INFORMATION)InfoBuffer;

      for (Index = 0; Index < Info->NumberOfEntries; Index++)
        {
          if (Index != 0 && Index%5 == 0)
              printf ("\n");

          printf ("%c%c%c%c %-5u ",
                  Info->Entries[Index].Tag[0],
                  Info->Entries[Index].Tag[1],
                  Info->Entries[Index].Tag[2],
                  Info->Entries[Index].Tag[3],
                  Info->Entries[Index].Size);
        }

      fflush( stdout );
    }
}


//
// Function:
//
//     PrintSystemPoolTagInformation
//
// Description:
//
//     Prints SystemPoolTagInformation.
//
//     typedef struct _SYSTEM_POOLTAG {
//         union {
//             UCHAR Tag[4];
//             ULONG TagUlong;
//         };
//         ULONG PagedAllocs;
//         ULONG PagedFrees;
//         SIZE_T PagedUsed;
//         ULONG NonPagedAllocs;
//         ULONG NonPagedFrees;
//         SIZE_T NonPagedUsed;
//     } SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;
//
//     typedef struct _SYSTEM_POOLTAG_INFORMATION {
//         ULONG Count;
//         SYSTEM_POOLTAG TagInfo[1];
//     } SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;
//

void PrintSystemPoolTagInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System pool tag information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("%-4s     %-8s %-8s %-8s %-8s %-8s %-8s\n",
            "Tag",
            "NP used", "P used",
            "NP alloc", "NP free",
            "P alloc", "P free");
    printf ("%-4s     %-8s %-8s %-8s %-8s %-8s %-8s\n",
            "",
            "x bytes", "x bytes",
            "x ops", "x ops",
            "x ops", "x ops");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPoolTagInformation
    //

    Status = NtQuerySystemInformation (
        SystemPoolTagInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(PoolTag): error %08X\n", Status);
        return;
      }

    {
      ULONG Index;
      PSYSTEM_POOLTAG_INFORMATION Info = (PSYSTEM_POOLTAG_INFORMATION)InfoBuffer;

      for (Index = 0; Index < Info->Count; Index++)
        {
          printf ("%c%c%c%c     %-8u %-8u %-8u %-8u %-8u %-8u\n",
                  Info->TagInfo[Index].Tag[0],
                  Info->TagInfo[Index].Tag[1],
                  Info->TagInfo[Index].Tag[2],
                  Info->TagInfo[Index].Tag[3],
                  Info->TagInfo[Index].NonPagedUsed,
                  Info->TagInfo[Index].PagedUsed,
                  Info->TagInfo[Index].NonPagedAllocs,
                  Info->TagInfo[Index].NonPagedFrees,
                  Info->TagInfo[Index].PagedAllocs,
                  Info->TagInfo[Index].PagedFrees);
        }

      fflush( stdout );
    }
}




//
// Function:
//
//     PrintProcessStackInformation
//
// Description:
//
//     Prints stack usage information for each process.
//



BOOL
ComputeMaxStackInProcess (

    DWORD Pid,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize);


VOID 
PrintProcessStackInformation (
    VOID
    )
{
    NTSTATUS Status;
    ULONG RealLength;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOL FinishNextTime = FALSE;
    BOOL ErrorsFound = FALSE;
    SIZE_T MaxStack = 0;
    SIZE_T TotalStack = 0;
    BOOLEAN WasEnabled;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    printf ("Process stack information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
                                      SystemBasicInformation,
                                      &SysInfo,
                                      sizeof (SysInfo),
                                      &RealLength);

    if (! NT_SUCCESS(Status)) {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
    }

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (SystemProcessInformation,
                                       InfoBuffer,
                                       sizeof InfoBuffer,
                                       &RealLength);

    if (! NT_SUCCESS(Status)) {
        printf ("NtQuerySystemInformation(Process): error %08X\n", Status);
        return;
    }

    //
    // Get debug privilege.
    //

    Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &WasEnabled);

    if (! NT_SUCCESS(Status)) {
        printf("Failed to enable debug privilege (%X) \n", Status);
    }

    {
        PSYSTEM_PROCESS_INFORMATION Info = (PSYSTEM_PROCESS_INFORMATION)InfoBuffer;

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "",
                "",
                "",
                "",
                "",
                "",
                "Total",
                "Max");

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "Process",
                "Id",
                "Sess",
                "Pri",
                "Thrds",
                "Handles",
                "stack",
                "stack");

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "",
                "",
                "",
                "",
                "",
                "",
                "Kb",
                "Kb");

        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

        for (FinishNextTime = FALSE ;
            FinishNextTime == FALSE;
            Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // User time vs Kernel time.
            //

            ULONG UserPercent, KernelPercent;

            UserPercent = (ULONG)((Info->UserTime.QuadPart) * 100
                                  / (Info->UserTime.QuadPart + Info->KernelTime.QuadPart));
            KernelPercent = 100 - UserPercent;

            //
            // I/O total count.
            //

            LARGE_INTEGER IoTotalCount;

            IoTotalCount.QuadPart = Info->ReadOperationCount.QuadPart
                                    + Info->WriteOperationCount.QuadPart
                                    + Info->OtherOperationCount.QuadPart;

            IoTotalCount.QuadPart /= 1000;

            //
            // Image name (special case the idle process).
            //

            if (Info->ImageName.Buffer == NULL) {

                printf ("%-15s ", "Idle");
            }
            else {

                printf ("%-15ws ", Info->ImageName.Buffer);
            }

            //
            // Compute stack info by iterating all threads in the process.
            //

            GetProcessStackInfo (Info, &MaxStack, &TotalStack, &ErrorsFound);
            
            //
            // Print the stuff.
            //

            printf ("%-5I64u %-5u %-4u %-5u %-8u %-5u %-5u\n",
                    (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                    Info->SessionId,
                    Info->BasePriority,
                    Info->NumberOfThreads,
                    Info->HandleCount,
                    (ULONG)(TotalStack/1024),
                    (ULONG)(MaxStack/1024));

        }
    }

    printf(
        "                                                                      \n"
        " * Total stack: total committed memory used for stacks by all threads \n"
        "       in the process.                                                \n"
        " * Max stack: the biggest committed stack in the process.             \n"
        "                                                                      \n");
}


VOID
GetProcessStackInfo (
    PSYSTEM_PROCESS_INFORMATION Info,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize,
    PBOOL ErrorsFound
    )
{
    ULONG Ti;
    HANDLE Id;
    HANDLE Thread;
    HANDLE Process;
    THREAD_BASIC_INFORMATION ThreadInfo;
    TEB TebInfo;
    SIZE_T BytesRead;
    BOOL ReadResult;
    NTSTATUS Status;
    SIZE_T StackSize;
    BOOLEAN WasEnabled;

    *MaxSize = 0;
    *TotalSize = 0;
    *ErrorsFound = FALSE;

    //
    // Open the process.
    // 

    Process = OpenProcess (PROCESS_VM_READ,
                           FALSE,
                           HandleToUlong(Info->UniqueProcessId));

    if (Process == FALSE) {
        //printf("Failed to open process %p (error %u) \n", Info->UniqueProcessId, GetLastError());
        *ErrorsFound = TRUE;
        return;
    }

    //
    // Iterate all threads in the process and for each determine the
    // thread ID, open the thread and query for TEB address. Finally
    // read user mode stack sizes from the TEB.
    //

    for (Ti = 0; Ti < Info->NumberOfThreads; Ti += 1) {

        Id = ((PSYSTEM_THREAD_INFORMATION)(Info + 1) + Ti)->ClientId.UniqueThread;

        Thread = OpenThread (THREAD_QUERY_INFORMATION, 
                             FALSE, 
                             HandleToUlong(Id));

        if (Thread == NULL) {
            //printf("failed to open thread %u \n", GetLastError());
            *ErrorsFound = TRUE;
            continue;
        }

        Status = NtQueryInformationThread (Thread,
                                           ThreadBasicInformation,
                                           &ThreadInfo,
                                           sizeof ThreadInfo,
                                           NULL);


        if (!NT_SUCCESS(Status)) {
            //printf("query thread failed with %X \n", Status);
            *ErrorsFound = TRUE;
            CloseHandle (Thread);
            continue;
        }

        ReadResult = ReadProcessMemory (Process,
                                        ThreadInfo.TebBaseAddress,
                                        &TebInfo,
                                        sizeof TebInfo,
                                        &BytesRead);

        if (ReadResult == FALSE) {
            //printf("failed to read teb with %u \n", GetLastError());
            *ErrorsFound = TRUE;
            CloseHandle (Thread);
            continue;
        }

        StackSize = (SIZE_T)(TebInfo.NtTib.StackBase) - (SIZE_T)(TebInfo.NtTib.StackLimit);

        *TotalSize += StackSize;

        if (StackSize > *MaxSize) {
            *MaxSize = StackSize;
        }

        CloseHandle (Thread);
    }

    CloseHandle (Process);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     DebugMessage
//
// Description:
//
//     Printf like function that prints a message into debugger.
//

void __cdecl DebugMessage (char *fmt, ...)
{
    va_list prms;
    char Buffer [1024];

    va_start (prms, fmt);
    vsprintf (Buffer, fmt, prms);
    OutputDebugString (Buffer);
    va_end (prms);
}


//
// end of module: systrack.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ctutil.c ===
#include "ct.h"
#include <stdio.h>
#include <stddef.h>

HANDLE g_hHeap;

/*********************************************************************
* LogMsg
*
*********************************************************************/
void __cdecl
LogMsg(
    DWORD dwFlags,
    char *pszfmt,
    ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (dwFlags & LM_ERROR) {
        fprintf(stdout, "Error: ");
    } else if (dwFlags & LM_WARNING) {
        fprintf(stdout, "Warning: ");
    } else if (dwFlags & LM_APIERROR) {
        fprintf(stdout, "API error: ");
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    fprintf(stdout, "\n");
}

/*********************************************************************
* Alloc
*
*********************************************************************/
LPVOID
Alloc(
        DWORD size)
{
    LPVOID p;

    p = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, size);

    return p;
}

/*********************************************************************
* ReAlloc
*
*********************************************************************/
LPVOID
ReAlloc(
    PVOID pSrc,
    DWORD size,
    DWORD newSize)
{
    PVOID pDest;

    pDest = Alloc(newSize);

    if (pDest != NULL) {
        if (size > newSize)
            size = newSize;

        memcpy(pDest, pSrc, size);

        Free(pSrc);
    }
    return pDest;
}

/*********************************************************************
* Free
*
*********************************************************************/
BOOL
Free(
    LPVOID p)
{
    return HeapFree(g_hHeap, 0, p);
}

/*********************************************************************
* InitMemManag
*
*********************************************************************/
BOOL
InitMemManag(
    void)
{
    g_hHeap = HeapCreate(0, 1024 * 1024 * 8, 1024 * 1024 * 64);

    if (g_hHeap == NULL)
        return FALSE;

    return TRUE;
}

/*********************************************************************
* FreeMemManag
*
*********************************************************************/
void
FreeMemManag(
    void)
{
    HeapDestroy(g_hHeap);
    g_hHeap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ct\ct.c ===
#include "ct.h"

#include <stdlib.h>

FILEMAP gfm;

char* g_pszInputFile;
char* g_pszCaller;
char* g_pszCallee;
int   g_nLevel = 1;
BOOL  g_bApplyUserRule = FALSE;

/*********************************************************************
* ParseCommandLine
*
*********************************************************************/
BOOL
ParseCommandLine(
    int           argc,
    LPSTR         argv[])
{
    char c, *p;
    int  argcParm = argc;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p) {
                switch (toupper(c)) {
                    case 'I':
                        if (g_pszInputFile != NULL) {
                            LogMsg(LM_ERROR, "-i already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszInputFile = *argv;
                        break;

                    case 'R':
                        if (g_pszCaller != NULL) {
                            LogMsg(LM_ERROR, "-r already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCaller = *argv;
                        break;

                    case 'U':
                        g_bApplyUserRule = TRUE;
                        break;

                    case 'E':
                        if (g_pszCallee != NULL) {
                            LogMsg(LM_ERROR, "-e already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCallee = *argv;
                        break;

                    case 'L':
                        {
                            char* pszLevel;

                            argc--, argv++;
                            pszLevel = *argv;

                            g_nLevel = atoi(pszLevel);

                            break;
                        }

                    default:
                        LogMsg(LM_ERROR, "Invalid parameter: %c", c);

                    case '?':
                        goto PrintHelp;
                }
            }
        }
    }

    if (g_pszInputFile == NULL) {
        g_pszInputFile = "calltree.out";
    }

    return TRUE;

PrintHelp:
    LogMsg(LM_PRINT, "\nCaller/Callee tree generator");
    LogMsg(LM_PRINT, "Version 2.0\n");
    LogMsg(LM_PRINT, "Usage: ct [-i input_file] -e function -r function -l level\n");
    LogMsg(LM_PRINT, "\t-i input_file - calltree.out generated by the linker");
    LogMsg(LM_PRINT, "\t-e function   - dump the callee tree for the function");
    LogMsg(LM_PRINT, "\t-r function   - dump the caller tree for the function");
    LogMsg(LM_PRINT, "\t-l level      - how deep to go on the tree");
    LogMsg(LM_PRINT, "\t-u            - allpy ntuser rule[s]");
    LogMsg(LM_PRINT, "\nExamples");
    LogMsg(LM_PRINT, "ct -e xxxMoveEvent -l 10");
    LogMsg(LM_PRINT, "ct -i userk.out -r xxxSwitchDesktop -l 2");
    LogMsg(LM_PRINT, "ct -i w32.out -e xxxMoveEvent -r xxxSwitchDesktop -l 2");
    return FALSE;
}

/*********************************************************************
* main
*
*********************************************************************/
int __cdecl
main(
    int argc,
    char *argv[])
{
    if (!InitMemManag()) {
        LogMsg(LM_ERROR, "Memory initialization failed");
        return 0;
    }

    if (!ParseCommandLine(argc, argv))
        return 0;
    
    if (!CtMapFile(g_pszInputFile, &gfm))
        return 0;

    ProcessInputFile(&gfm);

    if (g_pszCaller != NULL)
        ListCallerTree(g_pszCaller, g_nLevel, 1);
    
    if (g_pszCallee != NULL)
        ListCalleeTree(g_pszCallee, g_nLevel, 1);
    
    if (g_bApplyUserRule) {
        CheckUserRule();
        CheckUnnecessaryXXX();
    }
    
    CtUnmapFile(&gfm);

    FreeMemory();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ctui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctui.rc
//

#define IDD_DIALOG                      101
#define IDI_ICON                        102
#define IDC_TREE                        1000
#define IDC_COMBO1                      1001
#define IDC_CALLER                      1002
#define IDC_CALLEE                      1003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\parser.c ===
#include "ct.h"

#include <conio.h>
#include <stdio.h>

#define MAX_TOKEN_LEN   1024

char   g_szToken[MAX_TOKEN_LEN];
char   g_szTokenLink[MAX_TOKEN_LEN];
int    g_TokenLen = 0;

int  g_TagsCount = 0;
int  g_TagsMax = 0;

#define TAGS_DELTA   128
#define CALL_DELTA   4

PTag* g_pTags; // in order

/*************************************************************************
*   SkipSpaces
*
*   skips all the white chars from the current position down.
*
*************************************************************************/
void
SkipSpaces(
    DWORD* pi,
    char*  p)
{
    DWORD i = *pi;

    while (p[i] == ' ' || p[i] == '\t') {
        i++;
    }
    *pi = i;
}

char g_szFunction[ 256 ];
char g_szClass[ 256 ];


/*************************************************************************
*   LinkName2Name
*
*************************************************************************/
void
LinkName2Name(
    char* szLinkName,
    char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
    BOOL  fIsNew = FALSE;
    BOOL  fIsDelete = FALSE;
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;

    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            g_szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    g_szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                g_szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        g_szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", g_szFunction, g_szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", g_szFunction, g_szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", g_szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", g_szClass, g_szFunction);
    } else {
        sprintf(szName, "%s", g_szFunction);
    }
}

/*************************************************************************
*   GetToken
*
*************************************************************************/
int
GetToken(
    DWORD* pi,
        char*  p)
{
    DWORD i = *pi;

    SkipSpaces(&i, p);

    g_TokenLen = 0;

    while (p[i] != '\n' && p[i] != '\r' &&
           p[i] != ' '  && p[i] != '\t') {

        g_szTokenLink[g_TokenLen++] = p[i];

        i++;
    }

    g_szTokenLink[g_TokenLen++] = 0;

    LinkName2Name(g_szTokenLink, g_szToken);
    g_TokenLen = lstrlen(g_szToken);

    *pi = i;

    return g_TokenLen;
}

/*************************************************************************
*   DumpTags
*
*************************************************************************/
void
DumpTags(
    void)
{
    PTag pTag;
    int  i;

    LogMsg(LM_PRINT, "Dump tags\n"
        "--------------------------------------");

    for (i = 0; i < g_TagsCount; i++)
    {
        pTag = g_pTags[i];

        LogMsg(LM_PRINT, "%8x %s", pTag, pTag->pszTag);
    }

    LogMsg(LM_PRINT, "--------------------------------------\n");
}

/*************************************************************************
*   FindTag
*
*************************************************************************/
PTag
FindTag(
    char* pszTag,
    int*  pPos)
{
    int l, m, r;
    int val;

    if (g_TagsCount == 0) {
        if (pPos != NULL)
            *pPos = 0;
        return NULL;
    }

    l = 0;
    r = g_TagsCount - 1;

    while (l <= r) {

        m = (r + l) / 2;

        val = lstrcmp(pszTag, g_pTags[m]->pszTag);

        if (val == 0) {
            if (pPos != NULL)
                *pPos = m;

            return g_pTags[m];
        }

        if (val < 0)
            r = m - 1;
        else
            l = m + 1;
    }

    if (pPos != NULL)
        if (val < 0)
            *pPos = m;
        else
            *pPos = m + 1;

    return NULL;
}

/*************************************************************************
*   ResortTags
*
*************************************************************************/
void
ResortTags(
    PTag pTag)
{
    PTag* pArray;
    int   pos;

    g_TagsCount--;

    FindTag(pTag->pszTag, &pos);

    pArray = g_pTags + pos;

    memmove(pArray + 1, pArray, sizeof(PTag) * (g_TagsCount - pos));

    memmove(pArray, &pTag, sizeof(PTag));

    g_TagsCount++;
}

/*************************************************************************
*   IsInArray
*
*************************************************************************/
BOOL
IsInArray(
    PTag* ppTags,
    int   nCount,
    PTag  pTag)
{
    int i;

    for (i = 0; i < nCount; i++) {
        if (ppTags[i] == pTag)
            return TRUE;
    }
    return FALSE;
}

/*************************************************************************
*   AddToArray
*
*************************************************************************/
BOOL
AddToArray(
    DWORD* pCount,
    DWORD* pMax,
    PVOID* ppArray,
    DWORD  size,
    PVOID  pElem,
    UINT   delta)
{
    PVOID pArray;

    if (*pCount == *pMax) {
        if (*pCount == 0) {
            pArray = Alloc(delta * size);
        } else {
            pArray = ReAlloc(
                *ppArray,
                *pMax * size,
                (*pMax + delta) * size);
        }
        if (pArray == NULL) {
            LogMsg(LM_ERROR, "Out of memory in AddToArray");
            return FALSE;
        }

        *ppArray = pArray;
        (*pMax) += delta;
    } else {
        pArray = *ppArray;
    }

    memmove((char*)pArray + *pCount * size, &pElem, size);

    (*pCount)++;

    return TRUE;
}

/*************************************************************************
*   GetTag
*
*************************************************************************/
PTag
GetTag(
    DWORD* pi,
    char*  p)
{
    PTag pTag;

    /*
     * parse the token first
     */
    GetToken(pi, p);

    /*
     * if the there is a ptag for the token just return it
     */
    pTag = FindTag(g_szToken, NULL);

    if (pTag != NULL)
        return pTag;

    /*
     * create a ptag for the token
     */

    pTag = (PTag)Alloc(sizeof(Tag));
    if (pTag == NULL)
        return NULL;

    pTag->pszTag = (char*)Alloc((g_TokenLen + 1) * sizeof(char));

    lstrcpy(pTag->pszTag, g_szToken);

    if (AddToArray(
            &g_TagsCount,
            &g_TagsMax,
            (PVOID*)&g_pTags,
            sizeof(PTag),
            pTag,
            TAGS_DELTA)) {

        ResortTags(pTag);
    }

    return pTag;
}

/*************************************************************************
*   ProcessLine
*
*************************************************************************/
BOOL
ProcessLine(
    int    nLine,
    DWORD* pi,
    char*  p,
    char*  pEnd)
{
    DWORD  i = *pi;
    int    ind;
    PTag   pTag;
    PTag   pTagC;

    /*
     * ignore the first 4 tokens of a line
     */
    for (ind = 0; ind < 4; ind++)
        GetToken(&i, p);

    pTag = GetTag(&i, p);
    if (pTag) {
        while (p[i] != '\n' && p[i] != '\r') {
            pTagC = GetTag(&i, p);
            if (pTagC) {
                if (!IsInArray(pTag->ppCall, pTag->uCallCount, pTagC)) {
                    AddToArray(
                        &pTag->uCallCount,
                        &pTag->uCallMax,
                        (PVOID*)&pTag->ppCall,
                        sizeof(PTag),
                        (PVOID)pTagC,
                        CALL_DELTA);
                }
        
                if (!IsInArray(pTagC->ppCallee, pTagC->uCalleeCount, pTag)) {
                    AddToArray(
                        &pTagC->uCalleeCount,
                        &pTagC->uCalleeMax,
                        (PVOID*)&pTagC->ppCallee,
                        sizeof(PTag),
                        (PVOID)pTag,
                        CALL_DELTA);
                }
            }
        }
    
        while (p[i] == '\n' || p[i] == '\r') {
            i++;
        }
    
        *pi = i;
    }

    return TRUE;
}

/*************************************************************************
*   RemoveWalkFlags
*
*************************************************************************/
void
RemoveWalkFlags(
    void)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        pTag->bWalked = FALSE;
    }
}

#ifndef _CTUI

/*************************************************************************
*   ListCallerTreeRec
*
*************************************************************************/
void
ListCallerTreeRec(
    PTag pTag,
    int  nLevels,
    int  nIndent)
{
    int  i;
    PTag pTagC;
    char szIndent[256];

    /*
     * prepare for indentation
     */
    if (nIndent > 0) {
        memset(szIndent, ' ', nIndent);
        szIndent[nIndent] = 0;

        LogMsg(LM_PRINT, "%s%s", szIndent, pTag->pszTag);
    }

    /*
     * return if we're done with the levels
     */
    if (nLevels == 0)
        return;

    /*
     * return if we get into recursion
     */
    if (pTag->bWalked == TRUE)
        return;

    pTag->bWalked = TRUE;

    if (nIndent > 0)
        nIndent++;

    /*
     * recurse on the children
     */
    for (i = 0; i < (int)pTag->uCallCount; i++) {

        pTagC = pTag->ppCall[i];

        ListCallerTreeRec(pTagC, nLevels - 1, nIndent);
    }

    return;
}

/*************************************************************************
*   ListCallerTree
*
*************************************************************************/
void
ListCallerTree(
    char* pszTag,
        int   nLevels,
        BOOL  bIndent)
{
    int  i;
    PTag pTag;
    PTag pTagC;

    pTag = FindTag(pszTag, NULL);

    if (pTag == NULL) {
        LogMsg(LM_ERROR, "Tag %s not found", pszTag);
        return;
    }

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "%s calls:", pTag->pszTag);

    if (nLevels <= 0)
        return;

    pTag->bWalked = TRUE;

    for (i = 0; i < (int)pTag->uCallCount; i++) {

        pTagC = pTag->ppCall[i];

        ListCallerTreeRec(pTagC, nLevels - 1, bIndent);
    }

    RemoveWalkFlags();

    LogMsg(LM_PRINT, "-------------------------------------\n");

    return;
}

/*************************************************************************
*   ListCalleeTreeRec
*
*************************************************************************/
void
ListCalleeTreeRec(
    PTag pTag,
    int  nLevels,
    int  nIndent)
{
    int  i;
    PTag pTagC;
    char szIndent[256];

    /*
     * prepare for indentation
     */
    if (nIndent > 0) {
        memset(szIndent, ' ', nIndent);
        szIndent[nIndent] = 0;

        LogMsg(LM_PRINT, "%s%s", szIndent, pTag->pszTag);
    }

    /*
     * return if we're done with the levels
     */
    if (nLevels == 0)
        return;

    /*
     * return if we get into recursion
     */
    if (pTag->bWalked == TRUE)
        return;

    pTag->bWalked = TRUE;

    if (nIndent > 0)
        nIndent++;

    /*
     * recurse on the children
     */
    for (i = 0; i < (int)pTag->uCalleeCount; i++) {

        pTagC = pTag->ppCallee[i];

        ListCalleeTreeRec(pTagC, nLevels - 1, nIndent);
    }

    return;
}

/*************************************************************************
*   ListCalleeTree
*
*************************************************************************/
void
ListCalleeTree(
    char* pszTag,
    int   nLevels,
    BOOL  bIndent)
{
    int  i;
    PTag pTag;
    PTag pTagC;

    pTag = FindTag(pszTag, NULL);

    if (pTag == NULL) {
        LogMsg(LM_ERROR, "Tag %s not found", pszTag);
        return;
    }
    LogMsg(LM_PRINT, "-------------------------------------\n"
           "%s is called by:", pTag->pszTag);

    if (nLevels <= 0)
        return;

    pTag->bWalked = TRUE;

    for (i = 0; i < (int)pTag->uCalleeCount; i++) {

        pTagC = pTag->ppCallee[i];

        ListCalleeTreeRec(pTagC, nLevels - 1, bIndent);
    }

    RemoveWalkFlags();

    LogMsg(LM_PRINT, "-------------------------------------\n");

    return;
}

#endif // _CTUI

/*************************************************************************
*   ProcessInputFile
*
*************************************************************************/
int
ProcessInputFile(
    PFILEMAP pfm)
{
    DWORD i;
    int   nLine = 0;

    i = 0;

    while (i < (DWORD)(pfm->pmapEnd - pfm->pmap - 2)) {
        ProcessLine(nLine++, &i, pfm->pmap, pfm->pmapEnd);
    }

    return 0;
}

/*************************************************************************
*   FreeMemory
*
*************************************************************************/
void
FreeMemory(
    void)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        Free(pTag->pszTag);

        if (pTag->ppCall) {
            Free(pTag->ppCall);
        }
        if (pTag->ppCallee) {
            Free(pTag->ppCallee);
        }
        Free(pTag);
    }
    Free(g_pTags);

    FreeMemManag();
}

#ifndef _CTUI

/*************************************************************************
*   StartsWith
*
*************************************************************************/
BOOL
StartsWith(
    char* pszStart,
    char* pszTag)
{
    int lenS, lenT, i;

    lenS = lstrlen(pszStart);
    lenT = lstrlen(pszTag);

    if (lenS > lenT) {
        return FALSE;
    }

    for (i = 0; i < lenS; i++) {
        if (pszStart[i] != pszTag[i]) {
            return FALSE;
        }
    }
    return TRUE;
}

/*************************************************************************
*   CheckUserRule
*
*   Display functions that do not start with NtUser/zzz/xxx and call
*   functions that start with zzz/xxx
*
*************************************************************************/
void
CheckUserRule(
    void)
{
    int  i, j;
    PTag pTag;
    PTag pTagC;

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "Check for ntuser rule in the kernel\n");

    /*
     * walk the tags to find a non xxx/zzz function that directly
     * calls an xxx/zzz function
     */
    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        if (StartsWith("xxx", pTag->pszTag) ||
            StartsWith("zzz", pTag->pszTag) ||
            StartsWith("NtUser", pTag->pszTag)) {
            continue;
        }

        /*
         * see if we didn't already display a message for this tag
         */
        if (pTag->bWalked) {
            continue;
        }

        for (j = 0; j < (int)pTag->uCallCount; j++) {
            pTagC = pTag->ppCall[j];

            if (!StartsWith("xxx", pTagC->pszTag) &&
                !StartsWith("zzz", pTagC->pszTag)) {

                continue;
            }
            LogMsg(LM_PRINT, "%-40s calls : %s",
                   pTag->pszTag, pTagC->pszTag);

            break;
        }
    }
    RemoveWalkFlags();
}

/*************************************************************************
*   CheckUnnecessaryXXX
*
*   Display functions that do not start with NtUser/zzz/xxx and call
*   functions that start with zzz/xxx
*
*************************************************************************/
void
CheckUnnecessaryXXX(
    void)
{
    int  i, j;
    PTag pTag;
    PTag pTagC;

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "Check for unnecessary xxx functions in the kernel\n");

    /*
     * walk the tags to find a non xxx/zzz function that directly
     * calls an xxx/zzz function
     */
    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        if (!StartsWith("xxx", pTag->pszTag) &&
            !StartsWith("zzz", pTag->pszTag)) {
            continue;
        }

        /*
         * see if we didn't already display a message for this tag
         */
        if (pTag->bWalked) {
            continue;
        }

        for (j = 0; j < (int)pTag->uCallCount; j++) {
            pTagC = pTag->ppCall[j];

            if (StartsWith("xxx", pTagC->pszTag) ||
                StartsWith("zzz", pTagC->pszTag) ||
                StartsWith("LeaveCrit", pTagC->pszTag)) {

                break;
            }
        }
        if (j >= (int)pTag->uCallCount) {
            LogMsg(LM_PRINT, "%-40s should not be an xxx/zzz function",
                   pTag->pszTag);
        }
    }
    RemoveWalkFlags();
}

#else // _CTUI

/*************************************************************************
*   PopulateCombo
*
*************************************************************************/
void
PopulateCombo(
    HWND hwnd)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pTag->pszTag);
    }
}
#endif // _CTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ctui\ctui.c ===
/***************************************************************************
* Caller/Callee tree views
*
* Written by Corneliu Lupu
\**************************************************************************/

#include "ct.h"

#include <stdlib.h>

#include "resource.h"

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndTree;

FILEMAP   gfm;
char*     g_pszInputFile;

BOOL      g_bCaller;

char      g_szTag[256];

POINT     g_ptLast;

/*
 * Static Variables
 */

/*********************************************************************
* CtuiDlgProc
*
*********************************************************************/
INT_PTR FAR PASCAL
CtuiDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            RECT  rc;
            HICON hIcon;

            g_hDlg = hdlg;

            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

            SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

            g_hwndTree = GetDlgItem(hdlg, IDC_TREE);

            SendDlgItemMessage(hdlg, IDC_CALLEE, BM_SETCHECK, BST_CHECKED, 0);

            g_bCaller = FALSE;

            GetWindowRect(hdlg, &rc);
            g_ptLast.x = rc.right - rc.left;
            g_ptLast.y = rc.bottom - rc.top;

            SetTimer(hdlg, (UINT_PTR)hdlg, 100, NULL);

            break;
        }
    case WM_TIMER:
        if (wParam == (WPARAM)hdlg) {
            KillTimer(hdlg, (UINT_PTR)hdlg);

            SetCursor(LoadCursor(NULL, IDC_WAIT));

            ProcessInputFile(&gfm);

            PopulateCombo(GetDlgItem(hdlg, IDC_COMBO1));

            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_TREE) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            case TVN_KEYDOWN:
                {
                    HTREEITEM   hItem;
                    TV_ITEM     item;
                    PTag        pTag;
                    LONG_PTR        lItem;
                    TV_KEYDOWN* ptvkd = (TV_KEYDOWN*)lParam;

                    /*
                     * use 'F1' to update the selection in the combobox
                     * with the current item
                     */
                    if (ptvkd->wVKey == VK_F1) {
                        hItem = TreeView_GetSelection(g_hwndTree);

                        if (hItem == NULL)
                            break;

                        /*
                         * Ask for pTag in lParam
                         */
                        item.hItem = hItem;
                        item.mask  = TVIF_PARAM;
                        if (!TreeView_GetItem(g_hwndTree, &item))
                            break;

                        pTag = (PTag)item.lParam;

                        /*
                         * Find the string in the combobox
                         */
                        lItem = SendMessage(GetDlgItem(hdlg, IDC_COMBO1),
                                    CB_FINDSTRINGEXACT,
                                    (WPARAM)-1,
                                    (LPARAM)pTag->pszTag);

                        if (lItem == CB_ERR)
                            break;

                        /*
                         * Select the item found
                         */
                        SendMessage(GetDlgItem(hdlg, IDC_COMBO1),
                                    CB_SETCURSEL,
                                    lItem,
                                    0);

                        /*
                         * Update the tree view
                         */
                        lstrcpy(g_szTag, pTag->pszTag);
                        if (*g_szTag) {
                            CreateTree(g_szTag, g_bCaller);
                        }
                    }
                    break;
                }
            case TVN_GETDISPINFO:
                {
                    TV_DISPINFO* pdi = (TV_DISPINFO*)lParam;
                    PTag         pTag;

                    pTag = (PTag)pdi->item.lParam;

                    /*
                     * Supply the text for the tree view control
                     */
                    if (pdi->item.mask & TVIF_TEXT) {
                        pdi->item.pszText    = pTag->pszTag;
                        pdi->item.cchTextMax = lstrlen(pTag->pszTag) + 1;
                    }

                    break;
                }
            case TVN_ITEMEXPANDING:
                {
                    NM_TREEVIEW* ptv = (NM_TREEVIEW*)lParam;
                    TV_ITEM*     pi;
                    HTREEITEM    hChild;
                    PTag         pTag;

                    pi = &ptv->itemNew;

                    pTag = (PTag)pi->lParam;

                    hChild = TreeView_GetChild(g_hwndTree, pi->hItem);

                    if (hChild == NULL) {
                        AddLevel(pi->hItem, pTag, g_bCaller);
                    }
                    break;
                }
            }
        }
        break;

    case WM_SIZE:
        {
            int  dx, dy;
            RECT rcMaster, rcTree;

            if (g_ptLast.x == 0 && g_ptLast.y == 0)
                return TRUE;

            if (wParam == SIZE_MINIMIZED)
                return TRUE;

            /*
             * Make the dialog resizable
             */
            GetWindowRect(hdlg, &rcMaster);

            dx = (rcMaster.right  - rcMaster.left) - g_ptLast.x;
            dy = (rcMaster.bottom - rcMaster.top) - g_ptLast.y;

            g_ptLast.x = rcMaster.right - rcMaster.left;
            g_ptLast.y = rcMaster.bottom - rcMaster.top;

            GetWindowRect(g_hwndTree, &rcTree);

            SetWindowPos(g_hwndTree,
                         NULL,
                         0,
                         0,
                         rcTree.right - rcTree.left + dx,  // resize x
                         rcTree.bottom - rcTree.top + dy,  // resize y
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

            return TRUE;
        }

    case WM_COMMAND:
        switch (wNotifyCode) {
        case CBN_SELCHANGE:
            {
                INT_PTR nSel = SendMessage(GetDlgItem(hdlg, IDC_COMBO1), CB_GETCURSEL, 0, 0);

                /*
                 * Update the tree view with the new selection
                 */
                SendMessage(GetDlgItem(hdlg, IDC_COMBO1), CB_GETLBTEXT, nSel, (LPARAM)g_szTag);

                if (*g_szTag) {
                    CreateTree(g_szTag, g_bCaller);
                }

                return TRUE;
            }
        }
        switch (wCode) {
        case IDC_CALLER:
            if (!g_bCaller) {
                CreateTree(g_szTag, TRUE);
                g_bCaller = TRUE;
            }
            return TRUE;

        case IDC_CALLEE:
            if (g_bCaller) {
                CreateTree(g_szTag, FALSE);
                g_bCaller = FALSE;
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************
* WinMain
*
*********************************************************************/
int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    InitCommonControls();

    g_hInstance = hInst;

    if (!InitMemManag()) {
        LogMsg(LM_ERROR, "Memory initialization failed");
        return 0;
    }

    g_pszInputFile = lpszCmd;

    if (*g_pszInputFile == 0) {
        g_pszInputFile = "calltree.out";
    }

    if (!CtMapFile(g_pszInputFile, &gfm))
        return 0;

    DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG), NULL, CtuiDlgProc);

    CtUnmapFile(&gfm);

    FreeMemory();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\takeown\takeown.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Takeown.c

Abstract:

    Implements a recovery scheme to give an Administrator
    access to a file that has been denied to all.

Author:

    Robert Reichel (robertre)   22-Jun-1992

Environment:

    Must be run from an Administrator account in order
    to perform reliably.

Revision History:


--*/
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

BOOL
AssertTakeOwnership(
    HANDLE TokenHandle
    );

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    );

BOOL
VariableInitialization();


#define VERBOSE 0



PSID AliasAdminsSid = NULL;
PSID SeWorldSid;

static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;



VOID __cdecl
main (int argc, char *argv[])
{


    BOOL Result;
    LPSTR lpFileName;
    SECURITY_DESCRIPTOR SecurityDescriptor;
//    CHAR Dacl[256];
    HANDLE TokenHandle;


    //
    // We expect a file...
    //
    if (argc <= 1) {

        printf("Must specify a file name");
        return;
    }


    lpFileName = argv[1];

#if VERBOSE

    printf("Filename is %s\n", lpFileName );

#endif



    Result = VariableInitialization();

    if ( !Result ) {
        printf("Out of memory\n");
        return;
    }




    Result = GetTokenHandle( &TokenHandle );

    if ( !Result ) {

        //
        // This should not happen
        //

        printf("Unable to obtain the handle to our token, exiting\n");
        return;
    }






    //
    // Attempt to put a NULL Dacl on the object
    //

    InitializeSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );



//    Result = InitializeAcl ( (PACL)Dacl, 256, ACL_REVISION2 );
//
//    if ( !Result ) {
//        printf("Unable to initialize Acl, exiting\n");
//        return;
//    }
//
//
//    Result = AddAccessAllowedAce (
//                 (PACL)Dacl,
//                 ACL_REVISION2,
//                 GENERIC_ALL,
//                 AliasAdminsSid
//                 );
//
//
//
//    if ( !Result ) {
//        printf("Unable to create required ACL, error code = %d\n", GetLastError());
//        printf("Exiting\n");
//        return;
//    }


    Result = SetSecurityDescriptorDacl (
                 &SecurityDescriptor,
                 TRUE,
                 NULL,
                 FALSE
                 );



    if ( !Result ) {
        printf("SetSecurityDescriptorDacl failed, error code = %d\n", GetLastError());
        printf("Exiting\n");
        return;
    }

    Result = SetFileSecurity(
                 lpFileName,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( !Result ) {

#if VERBOSE

        printf("SetFileSecurity failed, error code = %d\n", GetLastError());

#endif

    } else {

        printf("Successful, protection removed\n");
        return;
    }



    //
    // That didn't work.
    //


    //
    // Attempt to make Administrator the owner of the file.
    //


    Result = SetSecurityDescriptorOwner (
                 &SecurityDescriptor,
                 AliasAdminsSid,
                 FALSE
                 );

    if ( !Result ) {
        printf("SetSecurityDescriptorOwner failed, lasterror = %d\n", GetLastError());
        return;
    }


    Result = SetFileSecurity(
                 lpFileName,
                 OWNER_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( Result ) {

#if VERBOSE

        printf("Owner successfully changed to Admin\n");

#endif

    } else {

        //
        // That didn't work either.
        //

#if VERBOSE

        printf("Opening file for WRITE_OWNER failed\n");
        printf("Attempting to assert TakeOwnership privilege\n");

#endif

        //
        // Assert TakeOwnership privilege, then try again
        //

        Result = AssertTakeOwnership( TokenHandle );

        if ( !Result ) {
            printf("Could not enable SeTakeOwnership privilege\n");
            printf("Log on as Administrator and try again\n");
            return;
        }

        Result = SetFileSecurity(
                     lpFileName,
                     OWNER_SECURITY_INFORMATION,
                     &SecurityDescriptor
                     );

        if ( Result ) {

#if VERBOSE
            printf("Owner successfully changed to Administrator\n");

#endif

        } else {

            printf("Unable to assign Administrator as owner\n");
            printf("Log on as Administrator and try again\n");
            return;
        }

    }

    //
    // Try to put a benign DACL onto the file again
    //

    Result = SetFileSecurity(
                 lpFileName,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( !Result ) {

        //
        // something is wrong
        //

        printf("SetFileSecurity unexpectedly failed, error code = %d\n", GetLastError());

    } else {

        printf("Successful, protection removed\n");
        return;
    }
}





BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    )
{

    HANDLE ProcessHandle;
    BOOL Result;

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        return( FALSE );
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 TokenHandle
                 );

    if ( !Result ) {

        CloseHandle(ProcessHandle);

        //
        // This should not happen
        //

        return FALSE;

    }

    CloseHandle(ProcessHandle);

    return( TRUE );
}


BOOL
AssertTakeOwnership(
    HANDLE TokenHandle
    )
{
    LUID TakeOwnershipValue;
    BOOL Result;
    TOKEN_PRIVILEGES TokenPrivileges;

    //
    // First, assert TakeOwnership privilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeTakeOwnershipPrivilege",
                 &TakeOwnershipValue
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        printf("Unable to obtain value of TakeOwnership privilege\n");
        printf("Error = %d\n",GetLastError());
        printf("Exiting\n");
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = TakeOwnershipValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;




    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

    if ( GetLastError() != NO_ERROR ) {

#if VERBOSE

        printf("GetLastError returned %d from AdjustTokenPrivileges\n", GetLastError() );

#endif

        return FALSE;

    } else {

#if VERBOSE

        printf("TakeOwnership privilege enabled\n");

#endif

    }

    return( TRUE );
}


BOOL
VariableInitialization()
{

    BOOL Result;

    Result = AllocateAndInitializeSid(
                 &SepNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &AliasAdminsSid
                 );

    if ( !Result ) {
        return( FALSE );
    }


    Result = AllocateAndInitializeSid(
                 &SepWorldSidAuthority,
                 1,
                 SECURITY_WORLD_RID,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &SeWorldSid
                 );

    if ( !Result ) {
        return( FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tc\tc.c ===
/* tc.c - general purpose tree copy program
 *
 *  tc.c recursively walks the source tree and copies the entire structure
 *  to the destination tree, creating directories as it goes along.
 *
 *      2/18/86         dan lipkie  correct error msg v[0] -> v[1]
 *      2/18/86         dan lipkie  allow for out of space on destination
 *      4/11/86         dan lipkie  add /h switch
 *      4/13/86         dan lipkie  allow all switches to use same switch char
 *      17-Jun-1986     dan lipkie  add /n, allow ^C to cancel
 *      11-Jul-1986     dan lipkie  add /s
 *      21-Jul-1986     dan lipkie  add MAXDIRLEN
 *      06-Nov-1986     mz          add /L
 *      13-May-1987     mz          add /F
 *      15-May-1987     mz          Make /F display dirs too
 *      11-Oct-1989     reubenb     fix /L parsing (?)
 *                                  add some void declarations
 *      19-Oct-1989     mz
 *
 */
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>


// Forward Function Declartions...
void CopyNode( char *, struct findType *, void * );
void MakeDir( char * );
void __cdecl Usage( char *, ... );
void errorexit( char *, unsigned, unsigned, unsigned );
void ChkSpace( int, LONGLONG );
int  FormDest( char * );

char const rgstrUsage[] = {
    "Usage: TC [/adhijnqrstAFLS] src-tree dst-tree\n"
    "    /a  only those files with the archive bit on are copied\n"
    "    /b  copies to inuse files are delayed to reboot\n"
    "    /d  deletes source files/directories as it copies them\n"
    "    /h  copy hidden directories, implied by /d\n"
    "    /i  ignore hidden, has nothing to do with hidden dir\n"
    "    /j  ignore system files, has nothing to do with hidden dir\n"
    "    /n  no subdirectories\n"
    "    /q  silent operation.  Normal mode displays activity\n"
    "    /r  read-only files are overwritten\n"
    "    /s  structure only\n"
    "    /t  only those files with source time > dest time are copied\n"
    "    /A  allow errors from copy (won't delete if /d present)\n"
    "    /F  list files that would be copied\n"
    "    /L  large disk copy (no full disk checking)\n"
    "    /S  produce batch script to do copy"
    };

flagType    fReboot = FALSE;            // TRUE => delay reboot
flagType    fDelete = FALSE;            // TRUE => delete/rmdir source after
flagType    fQuiet = FALSE;             // TRUE => no msg except for error
flagType    fArchive = FALSE;           // TRUE => copy only ARCHIVEed files
flagType    fTime = FALSE;              // TRUE => copy later dated files
flagType    fHidden = FALSE;            // TRUE => copy hidden directories
flagType    fNoSub = FALSE;             // TRUE => do not copy subdirect
flagType    fStructure = FALSE;         // TRUE => copy only directory
flagType    fInCopyNode = FALSE;        // TRUE => prevent recursion
flagType    fIgnoreHidden = FALSE;      // TRUE => don't consider hidden
flagType    fIgnoreSystem;              // TRUE => don't consider system
flagType    fOverwriteRO;               // TRUE => ignore R/O bit
flagType    fLarge = FALSE;             // TRUE => disables ChkSpace
flagType    fFiles = FALSE;             // TRUE => output files
flagType    fScript = FALSE;            // TRUE => output files as script
flagType    fAllowError = FALSE;        // TRUE => fcopy errors ignored
flagType    fRebootNecessary = FALSE;   // TRUE => reboot ultimately necessary



char source[MAX_PATH];
char dest[MAX_PATH];
char tempdir[MAX_PATH];
char tempfile[MAX_PATH];
int  drv;

int srclen, dstlen;


/*  Usage takes a variable number of strings, terminated by zero,
 *  e.g. Usage ("first ", "second ", 0);
 */
void __cdecl Usage( char *p, ... )
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "TC: ");
        while (*rgstr)
            fprintf(stderr, "%s", *rgstr++);
        fprintf(stderr, "\n");
        }
    fputs(rgstrUsage, stderr);
    exit (1);
}

void errorexit (fmt, a1, a2, a3)
char *fmt;
unsigned a1, a2, a3;
{
    fprintf (stderr, fmt, a1, a2, a3);
    fprintf (stderr, "\n");
    exit (1);
}


/* chkspace checks to see if there is enough space on drive d to hold a file
 * of size l.  If not, requests a disk swap
 */
void ChkSpace (d, l)
int d;
LONGLONG l;
{
    char *pend;
    char pathStr[MAX_PATH];
    int i;

    if (!fLarge)
        while (freespac (d) < sizeround (l, d)) {
            _cprintf ("Please insert a new disk in drive %c: and strike any key",
                     d + 'A'-1);
            if (_getch () == '\003')  /* ^C */
                exit (1);
            _cprintf ("\n\r");
            pend = pathStr;
            drive(dest, pend);
            pend += strlen(pend);
            path(dest, pend);
            if (fPathChr(pathStr[(i = (strlen(pathStr) - 1))]) && i > 2)
                pathStr[i] = '\0';
            MakeDir(pathStr);
            }
}


__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf;
    char *p;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while (c && fSwitChr (*v[ 0 ])) {
        p = v[ 0 ];
        SHIFT(c,v);
        while (*++p)
            switch (*p) {
                case 'b':
                    fReboot = TRUE;
                    break;
                case 'd':
                    fDelete = TRUE;
                    /* fall through; d => h */
                case 'h':
                    fHidden = TRUE;
                    break;
                case 'S':
                    fScript = TRUE;
                    /*  Fall through implies FILES and QUIET */
                case 'F':
                    fFiles = TRUE;
                    /*  Fall through implies QUIET */
                case 'q':
                    fQuiet = TRUE;
                    break;
                case 'a':
                    fArchive = TRUE;
                    break;
                case 't':
                    fTime = TRUE;
                    break;
                case 'n':
                    fNoSub = TRUE;
                    break;
                case 's':
                    fStructure = TRUE;
                    break;
                case 'i':
                    fIgnoreHidden = TRUE;
                    break;
                case 'j':
                    fIgnoreSystem = TRUE;
                    break;
                case 'r':
                    fOverwriteRO = TRUE;
                    break;
                case 'L':
                    fLarge = TRUE;
                    break;
                case 'A':
                    fAllowError = TRUE;
                    break;
                default:
                    Usage ( "Invalid switch - ", p, 0 );
                }
        }

    if (fStructure && fDelete)
        Usage ("Only one of /d and /s may be specified at a time", 0);
    if (c != 2)
        Usage (0);
    if (rootpath (v[0], source))
        Usage ("Invalid source", v[0], 0);
    if (rootpath (v[1], dest))
        Usage ("Invalid dest", v[1], 0);  /* M000 */
    srclen = strlen (source);
    dstlen = strlen (dest);
    if (!strcmp(source, dest))
        Usage ("Source == dest == ", source, 0);
    fbuf.fbuf.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    drv = toupper(*dest) - 'A' + 1;
    CopyNode (source, &fbuf, NULL);

    return( fRebootNecessary ? 2 : 0 );
}

/* copy node walks the source node and its children (recursively)
 * and creats the appropriate parts on the dst node
 */
void
CopyNode (
    char            *p,
    struct findType *pfb,
    void            *dummy
    )
{
    char *pend;
    int attr;
    flagType fCopy;
    flagType fDestRO;

    DWORD Status;
    char *pszError;

    FormDest (p);
    if (TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        /*  If we're to exclude subdirectories, and we're in one then
         *      skip it altogether
         */
        if (fNoSub && fInCopyNode)
            return;
        fInCopyNode = TRUE;

        /*  Skip the . and .. entries; they're useless
         */
        if (!strcmp (pfb->fbuf.cFileName, ".") || !strcmp (pfb->fbuf.cFileName, ".."))
            return;

        /*  if we're excluding hidden and this one is then
         *      skip it altogether
         */
        if (!fHidden && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
            return;

        /*  if we're not just outputting the list of files then
         *      Make sure that the destination dir exists
         */
    if ( !fFiles ) {
        ChkSpace(drv, 256);
    }
    MakeDir (dest);

    pend = strend (p);
    if (!fPathChr (pend[-1]))
        strcat (p, "\\");
    strcat (p, "*.*");
    forfile (p, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, CopyNode, NULL);
    *pend = '\0';

    /*  if we're not just outputting files then
     *      if we're to delete this node then
     *          ...
     */
    if (!fFiles)
        if (fDelete)
            if (_rmdir (p) == -1)
                Usage ("Unable to rmdir ", p, " - ", error (), 0);
    }
    else
    if (!fStructure) {
        if (_access(p, 04) == -1)        /* If we can read the source */
            Usage ("Unable to peek status of ", p, " - ", error (), 0);

        /*  do not copy the file if:
         *      fIgnoreHidden && hidden
         *      fIgnoreSystem && system
         *      fArchive and archive bit not set
         *      dest exists &&
         *          fTime && src <= dest time ||
         *          dest is readonly && !fOverwriteRO
         */

        fCopy = (flagType)TRUE;
        fDestRO = (flagType)FALSE;
        /* If destination exists, check the time of the destination to
         * see if we should copy the file
         */
        if (_access (dest, 00) != -1 ) {
            struct _stat srcbuf;
            struct _stat dstbuf;
            /* We have now determined that both the source and destination
             * exist, we now want to check to see if the destination is
             * read only, and if the /T switch was specified if the
             * destination is newer than the source.
             */
            if (_stat (p, &srcbuf) != -1) {/* if source is stat'able */
                if (_stat (dest, &dstbuf) != -1 ) { /* and destination too, */
                    attr = GetFileAttributes( dest ); /* get dest's flag */
                    fDestRO = (flagType)TESTFLAG ( attr, FILE_ATTRIBUTE_READONLY ); /* Flag dest R.O. */
                    if ( fTime && srcbuf.st_mtime <= dstbuf.st_mtime)
                        fCopy = FALSE;
                    else
                        if ( fDestRO && !fOverwriteRO ) {
                            if (!fQuiet)
                                printf ("%s => not copied, destination is read only\n", p);
                            fCopy = FALSE;
                        }
                }
            }
        }
        if (fCopy && fIgnoreHidden && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
            fCopy = FALSE;
        if (fCopy && fIgnoreSystem && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_SYSTEM))
            fCopy = FALSE;
        if (fCopy && fArchive && !TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE))
            fCopy = FALSE;
        if (fCopy) {
            if (!fFiles) {
                if (fDestRO) {
                    RSETFLAG (attr, FILE_ATTRIBUTE_READONLY);
                    SetFileAttributes( dest, attr );
                }
                _unlink(dest);
                ChkSpace(drv, FILESIZE(pfb->fbuf));
                }
            if (!fQuiet)
                printf ("%s => %s\t", p, dest);

            Status = NO_ERROR;
            pszError = "[OK]";

            if (fFiles) {
                if (fScript)
                    printf ("copy %s %s\n", p, dest);
                else
                    printf ("file %s\n", p, dest);
                }
            else
            if (!CopyFile (p, dest, FALSE)) {
                pszError = error ();
                Status = GetLastError ();

                //  If we received a sharing violation, we try to perform
                //  a boot-delayed copy.

                do {
                    if (Status != ERROR_SHARING_VIOLATION)
                        continue;

                    if (!fReboot)
                        continue;

                    Status = NO_ERROR;
                    pszError = "[reboot necessary]";

                    //  We attempt to delay this operation until reboot.
                    //  Since there is at least one DLL that we cannot
                    //  rename in this fashion, we perform delayed DELETE
                    //  of unused files.

                    //  get a temp name in the same directory
                    upd (dest, ".", tempdir);
                    if (GetTempFileName (tempdir, "tc", 0, tempfile) == 0) {
                        pszError = error ();
                        Status = GetLastError ();
                        continue;
                        }

                    //  rename dest file to temp name
                    if (!MoveFileEx (dest, tempfile, MOVEFILE_REPLACE_EXISTING)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (tempfile);
                        continue;
                        }

                    //  copy again
                    if (!CopyFile (p, dest, TRUE)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (dest);
                        MoveFile (tempfile, dest);
                        continue;
                        }

                    //  mark temp for delete
                    if (!MoveFileEx (tempfile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (dest);
                        MoveFile (tempfile, dest);
                        continue;
                        }

                     fRebootNecessary = TRUE;
                } while (FALSE);

                }

            /*  Display noise if we're not quiet
             */
            if (!fQuiet)
                printf ("%s\n", pszError);

            /*  If we got an error and we're not supposed to ignore them
             *      quit and report error
             */
            if (Status != NO_ERROR)
                if (!fAllowError)
                    Usage ("Unable to copy ", p, " to ", dest, " - ", pszError, 0);
                else
                    printf ("Unable to copy %s to %s - %s\n", p, dest, pszError);

            /*  If we're not just producing a file list and no error on copy
             */
            if (!fFiles && Status == NO_ERROR) {

                /*  If we're supposed to copy archived files and archive was
                 *      set, go reset the source
                 */
                if (fArchive && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE)) {
                    RSETFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE);
                    if( SetFileAttributes( p, pfb->fbuf.dwFileAttributes ) == -1 )
                        Usage ("Unable to set ", p, " attributes - ", error (), 0);
                }

                /*  Copy attributes from source to destination
                 */
                SetFileAttributes( dest, pfb->fbuf.dwFileAttributes );

                /*  If we're supposed to delete the entry
                 */
                if (fDelete) {

                    /*  If the source was read-only then
                     *      reset the source RO bit
                     */
                    if (TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))
                        if( SetFileAttributes( p, 0 ) == -1 )
                            Usage ("Unable to set attributes of ", " - ", error (), 0);

                    /*  Delete source and report error
                     */
                    if (_unlink (p) == -1)
                        Usage ("Unable to del ", p, " - ", error (), 0);
                    }
                }
            }
        }
    dummy;
}

/* given a source pointer, form the correct destination from it
 *
 * cases to consider:
 *
 *  source        dest            p              realdest
 * D:\path1     D:\path2    D:\path1\path3    D:\path2\path3
 * D:\          D:\path1    D:\path2\path3    D:\path1\path2\path3
 * D:\path1     D:\         D:\path1\path2    D:\path2
 * D:\          D:\         D:\               D:\
 */
FormDest (p)
char *p;
{
    char *subsrc, *dstend;

    subsrc = p + srclen;
    if (fPathChr (*subsrc))
        subsrc++;
    dstend = dest + dstlen;
    if (fPathChr (dstend[-1]))
        dstend--;
    *dstend = '\0';
    if (*subsrc != '\0') {
        _strlwr(subsrc);
        strcat (dest, "\\");
        strcat (dest, subsrc);
        }
    return( 0 );
}

/* attempt to make the directory in pieces */
void    MakeDir (p)
char *p;
{
    struct _stat dbuf;
    char *pshort;
    int i;

    if (strlen (p) > 3) {

        if (_stat (p, &dbuf) != -1)
            if (!TESTFLAG (dbuf.st_mode, S_IFDIR))
                Usage (p, " is a file", 0);
            else
                return;

        pshort = strend (p);
        while (pshort > p)
            if (fPathChr (*pshort))
                break;
            else
                pshort--;
        /* pshort points to last path separator */
        *pshort = 0;
        MakeDir (p);
        *pshort = '\\';
        if (!fQuiet)
            printf ("Making %s\t", p);
        if (fFiles)
            if (fScript)
                printf ("mkdir %s\n", p);
            else
                printf ("dir %s\n", p);
        else {
            i = _mkdir (p);
            if (!fQuiet)
                printf ("%s\n", i != -1 ? "[OK]" : "");
            if (i == -1)
                Usage ("Unable to mkdir ", p, " - ", error (), 0);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tags\ctui\tvutil.c ===
#include "ct.h"

extern HWND g_hwndTree;

HTREEITEM g_hTree;

/*********************************************************************
* AddItem
*
*********************************************************************/
HTREEITEM AddItem(
    HTREEITEM hParent,
    PTag      pTag,
    BOOL      bCaller)
{
    HTREEITEM       hItem;
    TV_ITEM         tvi;
    TV_INSERTSTRUCT is;
  
    // The .pszText, .iImage, and .iSelectedImage are filled in.
    tvi.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN;
    tvi.pszText   = LPSTR_TEXTCALLBACK;
    tvi.lParam    = (LPARAM)pTag;
    
    tvi.cChildren = 0;
    
    if (bCaller) {
        if (pTag->ppCall != NULL)
            tvi.cChildren = 1;
    } else {
        if (pTag->ppCallee != NULL)
            tvi.cChildren = 1;
    }
    
    // Insert the item into the tree.
    
    is.hInsertAfter = TVI_LAST;
    is.hParent      = hParent;
    is.item         = tvi;
    
    hItem = TreeView_InsertItem(g_hwndTree, &is);
    
    return hItem;
}

/*********************************************************************
* DestroyTree
*
*********************************************************************/
void
DestroyTree(
    void)
{
    TreeView_DeleteAllItems(g_hwndTree);
    g_hTree = NULL;
}

/*********************************************************************
* AddLevel
*
*********************************************************************/
void
AddLevel(
    HTREEITEM hParent,
    PTag      pTagP,
    BOOL      bCaller)
{
    PTag pTagC;
    int  i;
    
    if (bCaller) {
        for (i = 0; i < (int)pTagP->uCallCount; i++) {
            pTagC = pTagP->ppCall[i];

            AddItem(hParent, pTagC, TRUE);
        }
    } else {
        for (i = 0; i < (int)pTagP->uCalleeCount; i++) {
            pTagC = pTagP->ppCallee[i];

            AddItem(hParent, pTagC, FALSE);
        }
    }
}

/*********************************************************************
* CreateTree
*
*********************************************************************/
void
CreateTree(
    char* pszRoot,
    BOOL  bCaller)
{
    PTag pTag;
    
    if (g_hTree) {
        DestroyTree();
    }
    
    pTag = FindTag(pszRoot, NULL);

    if (pTag == NULL) {
        return;
    }
    
    g_hTree = AddItem(NULL, pTag, bCaller);

    AddLevel(g_hTree, pTag, bCaller);

    TreeView_Expand(g_hwndTree, g_hTree, TVE_EXPAND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\timtp\amd64\xsum.asm ===
include xsum.amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tail\tail.c ===
/* tail - first n lines to STDOUT
 *
 *   15-May-1994 PeterWi    Cloned from head.c
 *
 *   1-Apr-1997 v-charls (intel) Added the -f option
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <sys\stat.h>
#include <fcntl.h>
#include <windows.h>

int Tail(char *pszFile, int nLines, BOOL fBanner, BOOL keepOpen);

#define BUFSZ 4096

void Usage(void);

void
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int  nArg;
    int  cLines = 10;  // default
    int  nFiles = 0;
    int  nErr = 0;
    int  keepOpen = FALSE;  // default

    if ((argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/'))) {
        if (argv[1][1] == '?') {
            Usage( );
            exit( 0 );
        }

        if (argv[1][1] == 'f') {
            keepOpen = TRUE;
        }
        else {
            cLines = atoi( argv[1]+1 );
        }

        nArg = 2;
    }
    else {
        nArg = 1;
    }

    nFiles = argc - nArg;

    //
    // May only keep open exactly one file
    //
    if ((nFiles != 1) && (keepOpen)) {
        Usage( );
        exit( 0 );
    }

    if (nFiles < 1) {
        nErr += Tail( NULL, cLines, FALSE, keepOpen );
    }
    else while (nArg < argc) {
        nErr += Tail( argv[nArg], cLines, (nFiles > 1), keepOpen );
        nArg++;
    }

    if (nErr)
    {
        exit( 2 );
    }
    else
    {
        exit( 0 );
    }
}

void Usage( void )
{
    printf( "usage: TAIL [switches] [filename]*\n"
            "   switches: [-?] display this message\n"
            "             [-n] display last n lines of each file (default 10)\n"
            "             [-f filename] keep checking filename for new lines\n"
            );
}

int Tail( char *pszFile, int nLines, BOOL fBanner, BOOL keepOpen )
{
    int fd;
    int nErr = 0;
    LONGLONG offset;
    int cRead;
    int amt;
    int i;
    int nFound;
    char buff[BUFSZ];
    struct _stati64 fileStat;
    LONGLONG oldSize;
    LONGLONG toRead;


    /*
     * Open file for reading
     */

    if ( pszFile ) {
        if ( (fd = _open( pszFile, O_RDONLY | O_TEXT, 0 )) == -1 ) {
            fprintf( stderr, "TAIL: can't open %s\n", pszFile );
            return 1;
        }
    }
    else {
        fd = 0;
    }

    /*
     * Banner printed if there is more than one input file
     */

    if ( fBanner ) {
        fprintf( stdout, "==> %s <==\n", pszFile );
    }

    if ( (offset = _lseeki64( fd, 0, SEEK_END )) == -1L ) {
        fprintf( stderr, "TAIL: lseeki64() failed %d\n", errno );
        nErr++;
        goto CloseOut;
    }


    // Backup BUFSZ bytes from end of file and see how many lines we have

    if ( _fstati64( fd, &fileStat ) == -1L ) {
        fprintf( stderr, "TAIL: fstati64() failed\n" );
        nErr++;
        goto CloseOut;
    }

    // empty files are a special case, there's nowhere to seek to

    if (fileStat.st_size == 0) {

        // in keepOpen mode wait here for some data to show up

        if (keepOpen) {
            do {
                if ( _fstati64( fd, &fileStat ) == -1L ) {
                    fprintf( stderr, "TAIL: fstat() failed\n" );
                    nErr++;
                    goto CloseOut;
                }
                SleepEx( 1000, TRUE );
            } while (fileStat.st_size == 0);
        }

        // otherwise move along, nothing to do

        else {
            goto CloseOut;
        }
    }

    //
    // Save it away for later comparison...
    //

    oldSize = fileStat.st_size;

    offset = 0;
    nFound = 0;

    // stop when found the req'd no. of lines or when backed up to
    // the start of the file.

    while ( (nFound <= nLines) && (offset < fileStat.st_size) ) {
        offset += BUFSZ;

        if ( offset > fileStat.st_size ) {
            offset = fileStat.st_size;
        }

        if ( _lseeki64( fd, -offset, SEEK_END ) == -1L ) {
            fprintf( stderr, "TAIL: lseeki64() failed\n" );
            nErr++;
            goto CloseOut;
        }

        if ( (cRead = _read( fd, buff, BUFSZ )) == -1 ) {
            fprintf( stderr, "TAIL: read() failed\n" );
            nErr++;
            goto CloseOut;
        }

        // count back nLines

        i = cRead;

        while ( --i >= 0 ) {
            if ( buff[i] == '\n' ) {
                if ( ++nFound > nLines ) {
                    break;
                }
            }
        }
    }

    i++; // either 1 past start of file or sitting on '\n'. In either
         // case we must advance 1.

    // print from the current index to the end of file.

    while ( cRead != 0 ) {
        if ( _write( 1, &buff[i], cRead - i ) == -1 ) {
            fprintf( stderr, "TAIL: write() failed\n" );
            nErr++;
            goto CloseOut;
        }

        i = 0; // after first buff, all buffers are of cRead bytes

        if ( (cRead = _read( fd, buff, BUFSZ )) == -1 ) {
            fprintf( stderr, "TAIL: read() failed\n" );
            nErr++;
            goto CloseOut;
        }
    }

    if ( fBanner ) {
        fprintf(stdout, "\n");
    }

    if (keepOpen) {
        while (1) {
            if ( _fstati64( fd, &fileStat ) == -1L ) {
                fprintf( stderr, "TAIL: fstat() failed\n" );
                nErr++;
                goto CloseOut;
            }

            toRead = fileStat.st_size - oldSize;

            while (toRead) {
                if (toRead > BUFSZ) {
                    amt = BUFSZ;
                }
                else {
                    amt = (int)toRead;
                }

                if ( (cRead = _read( fd, buff, amt )) == -1 ) {
                    fprintf( stderr, "TAIL: read() failed\n" );
                    nErr++;
                    goto CloseOut;
                }

                if ( cRead == 0 )   { // found EOF
                    break; 
                }

                if (_write( 1, buff, cRead ) != cRead ) {
                    fprintf( stderr, "TAIL: write() failed\n" );
                    nErr++;
                    goto CloseOut;
                }

                toRead -= cRead;
            }

            oldSize = fileStat.st_size;

            SleepEx( 1000, TRUE );
        }
    }

CloseOut:
    if ( _close( fd ) == -1 ) {
        fprintf( stderr, "TAIL: close() failed\n" );
    }

    return nErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\thunk32\thunk32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    thunk32.c

Abstract:
    This file exists simply to allow for the building of thunk32.lib.
    It contains the extra entrypoints needed in kernel32.lib for the
    Win95 Thunk compiler.

Author:
    BryanT - 2/15/95 for CameronF

Revision History:

--*/

void __stdcall K32Thk1632Epilog( void ) {}
void __stdcall K32Thk1632Prolog( void ) {}
void __stdcall MapLS( int arg1 ) {}
void __stdcall MapSL( int arg1 ) {}
void __stdcall UnMapLS( int arg1 ) {}
void __stdcall MapSLFix( int arg1 ) {}
void __stdcall Callback4( int arg1 ) {}
void __stdcall UnMapSLFixArray( int arg1, int arg2 ) {}
void __stdcall Callback8( int arg1, int arg2 ) {}
void __stdcall Callback12( int arg1, int arg2, int arg3 ) {}
void __stdcall Callback16( int arg1, int arg2, int arg3, int arg4 ) {}
void __stdcall Callback20( int arg1, int arg2, int arg3, int arg4,
                           int arg5 ) {}
void __stdcall ThunkConnect32( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6 ) {}
void __stdcall Callback24( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6 ) {}
void __stdcall Callback28( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7 ) {}
void __stdcall Callback32( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8 ) {}
void __stdcall Callback36( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9 ) {}
void __stdcall Callback40( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10 ) {}
void __stdcall Callback44( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11 ) {}
void __stdcall Callback48( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12 ) {}
void __stdcall Callback52( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13 ) {}
void __stdcall Callback56( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14 ) {}
void __stdcall Callback60( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14, int arg15 ) {}
void __stdcall Callback64( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14, int arg15, int arg16 ) {}

void __cdecl FT_Exit0 (void) {}
void __cdecl FT_Exit12(void) {}
void __cdecl FT_Exit16(void) {}
void __cdecl FT_Exit20(void) {}
void __cdecl FT_Exit24(void) {}
void __cdecl FT_Exit28(void) {}
void __cdecl FT_Exit32(void) {}
void __cdecl FT_Exit36(void) {}
void __cdecl FT_Exit4 (void) {}
void __cdecl FT_Exit40(void) {}
void __cdecl FT_Exit44(void) {}
void __cdecl FT_Exit48(void) {}
void __cdecl FT_Exit52(void) {}
void __cdecl FT_Exit56(void) {}
void __cdecl FT_Exit8(void) {}
void __cdecl FT_Prolog(void) {}
void __cdecl FT_Thunk(void) {}
void __cdecl MapHInstLS(void) {}
void __cdecl MapHInstLS_PN(void) {}
void __cdecl MapHInstSL(void) {}
void __cdecl MapHInstSL_PN(void) {}
void __cdecl QT_Thunk(void) {}
void __cdecl SMapLS(void) {}
void __cdecl SMapLS_IP_EBP_12(void) {}
void __cdecl SMapLS_IP_EBP_16(void) {}
void __cdecl SMapLS_IP_EBP_20(void) {}
void __cdecl SMapLS_IP_EBP_24(void) {}
void __cdecl SMapLS_IP_EBP_28(void) {}
void __cdecl SMapLS_IP_EBP_32(void) {}
void __cdecl SMapLS_IP_EBP_36(void) {}
void __cdecl SMapLS_IP_EBP_40(void) {}
void __cdecl SMapLS_IP_EBP_8(void) {}
void __cdecl SUnMapLS(void) {}
void __cdecl SUnMapLS_IP_EBP_12(void) {}
void __cdecl SUnMapLS_IP_EBP_16(void) {}
void __cdecl SUnMapLS_IP_EBP_20(void) {}
void __cdecl SUnMapLS_IP_EBP_24(void) {}
void __cdecl SUnMapLS_IP_EBP_28(void) {}
void __cdecl SUnMapLS_IP_EBP_32(void) {}
void __cdecl SUnMapLS_IP_EBP_36(void) {}
void __cdecl SUnMapLS_IP_EBP_40(void) {}
void __cdecl SUnMapLS_IP_EBP_8(void) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\timtp\timtp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    timt.c

Abstract:

    This module contains native NT performance tests for the system
    calls and context switching.

Author:

    David N. Cutler (davec) 23-Nov-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windef.h"
#include "winbase.h"

//
// Define locals constants.
//

#define CHECKSUM_BUFFER_SIZE   (1 << 16)
#define CHECKSUM_ITERATIONS 4000
#define CHECKSUM_IP_ITERATIONS 40000000
#define EVENT_CLEAR_ITERATIONS 3000000
#define EVENT_CREATION_ITERATIONS 400000
#define EVENT_OPEN_ITERATIONS 200000
#define EVENT_QUERY_ITERATIONS 2000000
#define EVENT_RESET_ITERATIONS 2000000
#define EVENT1_SWITCHES 300000
#define EVENT2_SWITCHES 200000
#define EVENT3_SWITCHES 400000
#define IO_ITERATIONS 350000
#define MUTANT_SWITCHES 200000
#define SLIST_ITERATIONS 20000000
#define SEMAPHORE1_SWITCHES 300000
#define SEMAPHORE2_SWITCHES 600000
#define SYSCALL_ITERATIONS 6000000
#define TIMER_OPERATION_ITERATIONS 500000
#define UNALIGNED_ITERATIONS 400000000
#define WAIT_SINGLE_ITERATIONS 2000000
#define WAIT_MULTIPLE_ITERATIONS 2000000

//
// Define event desired access.
//

#define DESIRED_EVENT_ACCESS (EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE)

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    LARGE_INTEGER StartCycles;
    LARGE_INTEGER StopCycles;
    ULONG ContextSwitches;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

//
// Define test prototypes.
//

VOID
ChecksumTest (
    VOID
    );

VOID
EventClearTest (
    VOID
    );

VOID
EventCreationTest (
    VOID
    );

VOID
EventOpenTest (
    VOID
    );

VOID
EventQueryTest (
    VOID
    );

VOID
EventResetTest (
    VOID
    );

VOID
Event1SwitchTest (
    VOID
    );

VOID
Event2SwitchTest (
    VOID
    );

VOID
Event3SwitchTest (
    VOID
    );

VOID
Io1Test (
    VOID
    );

VOID
MutantSwitchTest (
    VOID
    );

VOID
Semaphore1SwitchTest (
    VOID
    );

VOID
Semaphore2SwitchTest (
    VOID
    );

LONG
SetProcessPrivilege (
    TCHAR *PrivilegeName
    );

VOID
SlistTest (
    VOID
    );

VOID
SystemCallTest (
    VOID
    );

VOID
TimerOperationTest (
    VOID
    );

VOID
UnalignedTest1 (
    VOID
    );

VOID
UnalignedTest2 (
    VOID
    );

VOID
WaitSingleTest (
    VOID
    );

VOID
WaitMultipleTest (
    VOID
    );

//
// Define thread routine prototypes.
//

NTSTATUS
Event1Thread1 (
    IN PVOID Context
    );

NTSTATUS
Event1Thread2 (
    IN PVOID Context
    );

NTSTATUS
Event2Thread1 (
    IN PVOID Context
    );

NTSTATUS
Event2Thread2 (
    IN PVOID Context
    );

NTSTATUS
Event3Thread1 (
    IN PVOID Context
    );

NTSTATUS
Event3Thread2 (
    IN PVOID Context
    );

NTSTATUS
MutantThread1 (
    IN PVOID Context
    );

NTSTATUS
MutantThread2 (
    IN PVOID Context
    );

NTSTATUS
Semaphore1Thread1 (
    IN PVOID Context
    );

NTSTATUS
Semaphore1Thread2 (
    IN PVOID Context
    );

NTSTATUS
Semaphore2Thread1 (
    IN PVOID Context
    );

NTSTATUS
Semaphore2Thread2 (
    IN PVOID Context
    );

NTSTATUS
TimerThread (
    IN PVOID Context
    );

//
// Define utility routine prototypes.
//

NTSTATUS
xCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    IN KPRIORITY Priority
    );

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    );

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    );

//
// Define external routine prototypes.
//

ULONG
ComputeTimerTableIndex32 (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentTime,
    IN PULONGLONG DueTime
    );

ULONG
ComputeTimerTableIndex64 (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentTime,
    IN PULONGLONG DueTime
    );

ULONG
ChkSum (
    IN ULONG Sum,
    IN PUSHORT Buffer,
    IN ULONG Length
    );

ULONG
tcpxsum (
    IN ULONG Sum,
    IN PVOID Buffer,
    IN ULONG Length
    );


//
// Define static storage.
//

HANDLE EventHandle1;
HANDLE EventHandle2;
HANDLE EventPairHandle;
HANDLE MutantHandle;
HANDLE SemaphoreHandle1;
HANDLE SemaphoreHandle2;
HANDLE Thread1Handle;
HANDLE Thread2Handle;
HANDLE TimerEventHandle;
HANDLE TimerTimerHandle;
HANDLE TimerThreadHandle;
USHORT ChecksumBuffer[CHECKSUM_BUFFER_SIZE / sizeof(USHORT)];

VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    KPRIORITY Priority = LOW_REALTIME_PRIORITY + 8;
    NTSTATUS Status;

    //
    // Set process privilege to increase priority.
    //

    if (SetProcessPrivilege(SE_INC_BASE_PRIORITY_NAME) != 0) {
        printf("Failed to set process privilege to increase priority\n");
        goto EndOfTest;
    }

    //
    // set priority of current thread.
    //

    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadPriority,
                                    &Priority,
                                    sizeof(KPRIORITY));

    if (!NT_SUCCESS(Status)) {
        printf("Failed to set thread priority during initialization\n");
        goto EndOfTest;
    }

    //
    // Create an event object to signal the timer thread at the end of the
    // test.
    //

    Status = NtCreateEvent(&TimerEventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event during initialization\n");
        goto EndOfTest;
    }

    //
    // Create a timer object for use by the timer thread.
    //

    Status = NtCreateTimer(&TimerTimerHandle,
                           TIMER_ALL_ACCESS,
                           NULL,
                           NotificationTimer);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create timer during initialization\n");
        goto EndOfTest;
    }

    //
    // Create and start the background timer thread.
    //

    Status = xCreateThread(&TimerThreadHandle,
                           TimerThread,
                           LOW_REALTIME_PRIORITY + 12);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create timer thread during initialization\n");
        goto EndOfTest;
    }

    //
    // Execute performance tests.
    //

//    ChecksumTest();
//    EventClearTest();
//    EventCreationTest();
//    EventOpenTest();
//    EventQueryTest();
//    EventResetTest();
//    Event1SwitchTest();
//    Event2SwitchTest();
//    Event3SwitchTest();
//    Io1Test();
//    MutantSwitchTest();
//    Semaphore1SwitchTest();
//    Semaphore2SwitchTest();
//    SlistTest();
//    SystemCallTest();
//    TimerOperationTest();
//    WaitSingleTest();
//    WaitMultipleTest();
    UnalignedTest1();
    UnalignedTest2();

    //
    // Set timer event and wait for timer thread to terminate.
    //

    Status = NtSetEvent(TimerEventHandle, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to set event in main loop\n");
        goto EndOfTest;
    }

    Status = NtWaitForSingleObject(TimerThreadHandle,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to wait for timer thread at end of test\n");
    }

    //
    // Close event, timer, and timer thread handles.
    //

EndOfTest:
    NtClose(TimerEventHandle);
    NtClose(TimerTimerHandle);
    NtClose(TimerThreadHandle);
    return;
}

VOID
ChecksumTest (
    VOID
    )

{

    LONG Count;
    LONG Index;
    PERFINFO PerfInfo;
    ULONG Sum1;
    ULONG Sum2 = 0;
    PUCHAR Source;

    //
    // Initialize the checksum buffer.
    //

    for (Index = 0; Index < (CHECKSUM_BUFFER_SIZE / sizeof(USHORT)); Index += 1) {
        ChecksumBuffer[Index] = (USHORT)rand();
    }

    Source = (PUCHAR)&ChecksumBuffer[0];
    Source += 1;

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Checksum (aligned) Benchmark",
                   CHECKSUM_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly checksum buffers of varying sizes.
    //

    for (Count = 0; Count < CHECKSUM_ITERATIONS; Count += 1) {
        for (Index = 1024; Index >= 2 ; Index -= 1) {
            Sum2 = tcpxsum(Sum2, &ChecksumBuffer[0], Index);
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Checksum (unaligned) Benchmark",
                   CHECKSUM_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly checksum buffers of varying sizes.
    //

    for (Count = 0; Count < CHECKSUM_ITERATIONS; Count += 1) {
        for (Index = 1024; Index >= 2 ; Index -= 1) {
            Sum2 = tcpxsum(Sum2, Source, Index);
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Ip Header Checksum (aligned) Benchmark",
                   CHECKSUM_IP_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly checksum buffers of varying sizes.
    //

    for (Count = 0; Count < CHECKSUM_IP_ITERATIONS; Count += 1) {
        Sum1 = tcpxsum(0, &ChecksumBuffer[0], 20);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Ip Header Checksum (unaligned) Benchmark",
                   CHECKSUM_IP_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly checksum buffers of varying sizes.
    //

    for (Count = 0; Count < CHECKSUM_IP_ITERATIONS; Count += 1) {
        Sum2 = tcpxsum(0, Source, 20);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
EventClearTest (
    VOID
    )

{

    HANDLE EventHandle;
    LONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Create an event for clear operations.
    //

    Status = NtCreateEvent(&EventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for clear test\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Clear Event Benchmark",
                   EVENT_CLEAR_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly clear an event.
    //

    for (Index = 0; Index < EVENT_RESET_ITERATIONS; Index += 1) {
        Status = NtClearEvent(EventHandle);

        if (!NT_SUCCESS(Status)) {
            printf("       Clear event bad status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of clear event test.
    //

EndOfTest:
    NtClose(EventHandle);
    return;
}

VOID
EventCreationTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Event Creation Benchmark",
                   EVENT_CREATION_ITERATIONS,
                   &PerfInfo);

    //
    // Create an event and then close it.
    //

    for (Index = 0; Index < EVENT_CREATION_ITERATIONS; Index += 1) {
        Status = NtCreateEvent(&EventHandle1,
                               DESIRED_EVENT_ACCESS,
                               NULL,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to create event object for event creation test.\n");
            goto EndOfTest;
        }

        NtClose(EventHandle1);
    }


    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of event creation test.
    //

EndOfTest:
    return;
}

VOID
EventOpenTest (
    VOID
    )

{

    ANSI_STRING EventName;
    ULONG Index;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PERFINFO PerfInfo;
    NTSTATUS Status;
    UNICODE_STRING UnicodeEventName;

    //
    // Create a named event for event open test.
    //

    RtlInitAnsiString(&EventName, "\\BaseNamedObjects\\EventOpenName");
    Status = RtlAnsiStringToUnicodeString(&UnicodeEventName,
                                          &EventName,
                                          TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create UNICODE string for event open test\n");
        goto EndOfTest;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeEventName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateEvent(&EventHandle1,
                           DESIRED_EVENT_ACCESS,
                           &ObjectAttributes,
                           SynchronizationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for event open test.\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Event Open Benchmark",
                   EVENT_OPEN_ITERATIONS,
                   &PerfInfo);

    //
    // Open a named event and then close it.
    //

    for (Index = 0; Index < EVENT_OPEN_ITERATIONS; Index += 1) {
        Status = NtOpenEvent(&EventHandle2,
                             EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                             &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to open event for open event test\n");
            goto EndOfTest;
        }

        NtClose(EventHandle2);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of event open test.
    //

EndOfTest:
    NtClose(EventHandle1);
    return;
}

VOID
EventQueryTest (
    VOID
    )

{

    HANDLE EventHandle;
    EVENT_BASIC_INFORMATION EventInformation;
    LONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Create an event for query operations.
    //

    Status = NtCreateEvent(&EventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for query test\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Query Event Benchmark",
                   EVENT_QUERY_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly query an event.
    //

    for (Index = 0; Index < EVENT_QUERY_ITERATIONS; Index += 1) {
        Status = NtQueryEvent(EventHandle,
                              EventBasicInformation,
                              &EventInformation,
                              sizeof(EVENT_BASIC_INFORMATION),
                              NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Query event bad status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of query event test.
    //

EndOfTest:
    NtClose(EventHandle);
    return;
}

VOID
EventResetTest (
    VOID
    )

{

    HANDLE EventHandle;
    LONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Create an event for reset operations.
    //

    Status = NtCreateEvent(&EventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for reset test\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parameters.
    //

    StartBenchMark("Reset Event Benchmark",
                   EVENT_RESET_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly reset an event.
    //

    for (Index = 0; Index < EVENT_RESET_ITERATIONS; Index += 1) {
        Status = NtResetEvent(EventHandle,
                              NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Reset event bad status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of reset event test.
    //

EndOfTest:
    NtClose(EventHandle);
    return;
}

VOID
Event1SwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    HANDLE WaitObjects[2];

    //
    // Create two event objects for the event1 context switch test.
    //

    Status = NtCreateEvent(&EventHandle1,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event1 object for context switch test.\n");
        goto EndOfTest;
    }

    Status = NtCreateEvent(&EventHandle2,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event1 object for context switch test.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           Event1Thread1,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create first thread event1 context switch test\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                           Event1Thread2,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create second thread event1 context switch test\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Event (synchronization) Context Switch Benchmark (Round Trips)",
                   EVENT1_SWITCHES,
                   &PerfInfo);

    //
    // Set event and wait for threads to terminate.
    //

    Status = NtSetEvent(EventHandle1, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to set event event1 context switch test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to wait event1 context switch test.\n");
        goto EndOfTest;
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of event1 context switch test.
    //

EndOfTest:
    NtClose(EventHandle1);
    NtClose(EventHandle2);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
Event1Thread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 1 and then set event 2.
    //

    for (Index = 0; Index < EVENT1_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(EventHandle1,
                                       FALSE,
                                       NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event1 test bad wait status, %x\n", Status);
            break;
        }

        Status = NtSetEvent(EventHandle2, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event1 test bad set status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
Event1Thread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 2 and then set event 1.
    //

    for (Index = 0; Index < EVENT1_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(EventHandle2,
                                       FALSE,
                                       NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 event1 test bad wait status, %x\n", Status);
            break;
        }

        Status = NtSetEvent(EventHandle1, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 event1 test bad set status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
Event2SwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    PVOID WaitObjects[2];

    //
    // Create two event objects for the event2 context switch test.
    //

    Status = NtCreateEvent(&EventHandle1,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event2 object for context switch test.\n");
        goto EndOfTest;
    }

    Status = NtCreateEvent(&EventHandle2,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event2 object for context switch test.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           Event2Thread1,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create first thread event2 context switch test\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                           Event2Thread2,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create second thread event2 context switch test\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Event (notification) Context Switch Benchmark (Round Trips)",
                   EVENT2_SWITCHES,
                   &PerfInfo);

    //
    // Set event and wait for threads to terminate.
    //

    Status = NtSetEvent(EventHandle1, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to set event2 object for context switch test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of event2 context switch test.
    //

EndOfTest:
    NtClose(EventHandle1);
    NtClose(EventHandle2);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
Event2Thread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 1, reset event 1, and then set event 2.
    //

    for (Index = 0; Index < EVENT2_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(EventHandle1, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event2 test bad wait status, %x\n", Status);
            break;
        }

        Status = NtResetEvent(EventHandle1, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event2 test bad reset status, %x\n", Status);
            break;
        }

        Status = NtSetEvent(EventHandle2, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event2 test bad set status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
Event2Thread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 2, reset event 2,  and then set event 1.
    //

    for (Index = 0; Index < EVENT2_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(EventHandle2, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 event2 test bad wait status, %x\n", Status);
            break;
        }

        Status = NtResetEvent(EventHandle2, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 event2 test bad reset status, %x\n", Status);
            break;
        }

        Status = NtSetEvent(EventHandle1, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 event2 test bad set status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
Event3SwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    PVOID WaitObjects[2];

    //
    // Create two event objects for the event1 context switch test.
    //

    Status = NtCreateEvent(&EventHandle1,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Failed to create event1 object for context switch test.\n");
        goto EndOfTest;
    }

    Status = NtCreateEvent(&EventHandle2,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Failed to create event2 object for context switch test.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           Event3Thread1,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Failed to create first thread event3 context switch test\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                           Event3Thread2,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Failed to create second thread event3 context switch test\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Event (signal/wait) Context Switch Benchmark (Round Trips)",
                   EVENT3_SWITCHES,
                   &PerfInfo);

    //
    // Set event and wait for threads to terminate.
    //

    Status = NtSetEvent(EventHandle1, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Failed to set event event1 context switch test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of event3 context switch test.
    //

EndOfTest:
    NtClose(EventHandle1);
    NtClose(EventHandle2);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
Event3Thread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 1 and then enter signal/wait loop.
    //

    Status = NtWaitForSingleObject(EventHandle1,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Thread1 initial wait failed, %x\n", Status);

    } else {
        for (Index = 0; Index < EVENT3_SWITCHES; Index += 1) {
            Status = NtSignalAndWaitForSingleObject(EventHandle2,
                                                    EventHandle1,
                                                    FALSE,
                                                    NULL);

            if (!NT_SUCCESS(Status)) {
                printf("EVENT3: Thread1 signal/wait failed, %x\n", Status);
                break;
            }
        }
    }

    Status = NtSetEvent(EventHandle2, NULL);
    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
Event3Thread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for event 1 and then enter signal/wait loop.
    //

    Status = NtWaitForSingleObject(EventHandle2,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {
        printf("EVENT3: Thread2 initial wait failed, %x\n", Status);

    } else {
        for (Index = 0; Index < EVENT3_SWITCHES; Index += 1) {
            Status = NtSignalAndWaitForSingleObject(EventHandle1,
                                                    EventHandle2,
                                                    FALSE,
                                                    NULL);

            if (!NT_SUCCESS(Status)) {
                printf("EVENT3: Thread2 signal/wait failed, %x\n", Status);
                break;
            }
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
Io1Test (
    VOID
    )

{

    ULONG Buffer[128];
    HANDLE DeviceHandle;
    ANSI_STRING AnsiName;
    HANDLE EventHandle;
    LARGE_INTEGER FileAddress;
    LONG Index;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PERFINFO PerfInfo;
    NTSTATUS Status;
    LARGE_INTEGER SystemTime;
    UNICODE_STRING UnicodeName;

    //
    // Create an event for synchronization of I/O operations.
    //

    Status = NtCreateEvent(&EventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           FALSE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for I/O test 1\n");
        goto EndOfTest;
    }

    //
    // Open device object for I/O operations.
    //

    RtlInitString(&AnsiName, "\\Device\\Null");
    Status = RtlAnsiStringToUnicodeString(&UnicodeName,
                                          &AnsiName,
                                          TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to convert device name to unicode for I/O test 1\n");
        goto EndOfTest;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                                 &UnicodeName,
                                 0,
                                 (HANDLE)0,
                                 NULL);

    Status = NtOpenFile(&DeviceHandle,
                        FILE_READ_DATA | FILE_WRITE_DATA,
                        &ObjectAttributes,
                        &IoStatus,
                        0,
                        0);

    RtlFreeUnicodeString(&UnicodeName);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to open device I/O test 1, status = %lx\n", Status);
        goto EndOfTest;
    }

    //
    // Initialize file address parameter.
    //

    FileAddress.LowPart = 0;
    FileAddress.HighPart = 0;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("I/O Benchmark for Synchronous Null Device",
                   IO_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly write data to null device.
    //

    for (Index = 0; Index < IO_ITERATIONS; Index += 1) {
        Status = NtWriteFile(DeviceHandle,
                             EventHandle,
                             NULL,
                             NULL,
                             &IoStatus,
                             Buffer,
                             512,
                             &FileAddress,
                             NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Failed to write device I/O test 1, status = %lx\n",
                     Status);
            goto EndOfTest;
        }

        Status = NtWaitForSingleObject(EventHandle, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       I/O test 1 bad wait status, %x\n", Status);
            goto EndOfTest;
        }

        if (NT_SUCCESS(IoStatus.Status) == FALSE) {
            printf("       I/O test 1 bad I/O status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of I/O test 1.
    //

EndOfTest:
    NtClose(DeviceHandle);
    NtClose(EventHandle);
    return;
}

VOID
MutantSwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    HANDLE WaitObjects[2];

    //
    // Create a mutant object for the mutant context switch test.
    //

    Status = NtCreateMutant(&MutantHandle, MUTANT_ALL_ACCESS, NULL, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to create mutant object for context switch test.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           MutantThread1,
                           LOW_REALTIME_PRIORITY + 11);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create first thread mutant context switch test\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                           MutantThread2,
                           LOW_REALTIME_PRIORITY + 11);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create second thread mutant context switch test\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Mutant Context Switch Benchmark (Round Trips)",
                   MUTANT_SWITCHES,
                   &PerfInfo);

    //
    // Release mutant and wait for threads to terminate.
    //

    Status = NtReleaseMutant(MutantHandle, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("Failed to release mutant object for context switch test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of mutant context switch test.
    //

EndOfTest:
    NtClose(MutantHandle);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
MutantThread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for mutant and then release mutant.
    //

    for (Index = 0; Index < MUTANT_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(MutantHandle, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 mutant test bad wait status, %x\n", Status);
            break;
        }
        Status = NtReleaseMutant(MutantHandle, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread1 mutant test bad release status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
MutantThread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for mutant and then release mutant.
    //

    for (Index = 0; Index < MUTANT_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(MutantHandle, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 mutant test bad wait status, %x\n", Status);
            break;
        }
        Status = NtReleaseMutant(MutantHandle, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Thread2 mutant test bad release status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
Semaphore1SwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    HANDLE WaitObjects[2];

    //
    // Create two semaphore objects for the semaphore1 context switch test.
    //

    Status = NtCreateSemaphore(&SemaphoreHandle1,
                               DESIRED_EVENT_ACCESS,
                               NULL,
                               0,
                               1);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to create semaphore1 object.\n");
        goto EndOfTest;
    }

    Status = NtCreateSemaphore(&SemaphoreHandle2,
                               DESIRED_EVENT_ACCESS,
                               NULL,
                               0,
                               1);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to create semaphore2 object.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           Semaphore1Thread1,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to create thread1 object.\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                           Semaphore1Thread2,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to create thread2 object.\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Semaphore (release/wait) Context Switch Benchmark (Round Trips)",
                   SEMAPHORE1_SWITCHES,
                   &PerfInfo);

    //
    // Release semaphore and wait for threads to terminate.
    //

    Status = NtReleaseSemaphore(SemaphoreHandle1, 1, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to release semaphore1 at start of test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE1: Failed to wait for threads.\n");
        goto EndOfTest;
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of semaphore1 context switch test.
    //

EndOfTest:
    NtClose(SemaphoreHandle1);
    NtClose(SemaphoreHandle2);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
Semaphore1Thread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for semaphore 1 and then release semaphore 2.
    //

    for (Index = 0; Index < SEMAPHORE1_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(SemaphoreHandle1,
                                       FALSE,
                                       NULL);

        if (!NT_SUCCESS(Status)) {
            printf("SEMAPHORE1: Thread1 bad wait status, %x\n", Status);
            break;
        }

        Status = NtReleaseSemaphore(SemaphoreHandle2, 1, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("SEMAPHORE1: Thread1 bad release status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
Semaphore1Thread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for semaphore 2 and then release semaphore 1.
    //

    for (Index = 0; Index < SEMAPHORE1_SWITCHES; Index += 1) {
        Status = NtWaitForSingleObject(SemaphoreHandle2,
                                       FALSE,
                                       NULL);

        if (!NT_SUCCESS(Status)) {
            printf("SEMAPHORE1: Thread2 bad wait status, %x\n", Status);
            break;
        }

        Status = NtReleaseSemaphore(SemaphoreHandle1, 1, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("SEMAPHORE1: Thread2 bad release status, %x\n", Status);
            break;
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
Semaphore2SwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    HANDLE WaitObjects[2];

    //
    // Create two semaphore objects for the semaphore1 context switch test.
    //

    Status = NtCreateSemaphore(&SemaphoreHandle1,
                               DESIRED_EVENT_ACCESS,
                               NULL,
                               0,
                               1);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to create semaphore1 object.\n");
        goto EndOfTest;
    }

    Status = NtCreateSemaphore(&SemaphoreHandle2,
                               DESIRED_EVENT_ACCESS,
                               NULL,
                               0,
                               1);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to create semaphore2 object.\n");
        goto EndOfTest;
    }

    //
    // Create the thread objects to execute the test.
    //

    Status = xCreateThread(&Thread1Handle,
                           Semaphore2Thread1,
                           LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to create thread1 object.\n");
        goto EndOfTest;
    }

    Status = xCreateThread(&Thread2Handle,
                          Semaphore2Thread2,
                          LOW_REALTIME_PRIORITY - 2);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to create thread2 object.\n");
        goto EndOfTest;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[0] = Thread1Handle;
    WaitObjects[1] = Thread2Handle;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Semaphore (signal/wait) Context Switch Benchmark (Round Trips)",
                   SEMAPHORE2_SWITCHES,
                   &PerfInfo);

    //
    // Release semaphore and wait for threads to terminate.
    //

    Status = NtReleaseSemaphore(SemaphoreHandle1, 1, NULL);
    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to release semaphore1 at start of test.\n");
        goto EndOfTest;
    }

    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAll,
                                      FALSE,
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Failed to wait for threads.\n");
        goto EndOfTest;
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of semaphore 2 context switch test.
    //

EndOfTest:
    NtClose(SemaphoreHandle1);
    NtClose(SemaphoreHandle2);
    NtClose(Thread1Handle);
    NtClose(Thread2Handle);
    return;
}

NTSTATUS
Semaphore2Thread1 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for semaphore 1 and then enter signal/wait loop.
    //

    Status = NtWaitForSingleObject(SemaphoreHandle1,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Thread1 initial wait failed, %x\n", Status);

    } else {
        for (Index = 0; Index < SEMAPHORE2_SWITCHES; Index += 1) {
            Status = NtSignalAndWaitForSingleObject(SemaphoreHandle2,
                                                    SemaphoreHandle1,
                                                    FALSE,
                                                    NULL);

            if (!NT_SUCCESS(Status)) {
                printf("SEMAPHORE2: Thread1 signal/wait failed, %x\n", Status);
                break;
            }
        }
    }

    Status = NtReleaseSemaphore(SemaphoreHandle2, 1, NULL);
    NtTerminateThread(Thread1Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS
Semaphore2Thread2 (
    IN PVOID Context
    )

{

    ULONG Index;
    NTSTATUS Status;

    //
    // Wait for semaphore 2 and then enter signal/wait loop.
    //

    Status = NtWaitForSingleObject(SemaphoreHandle2,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {
        printf("SEMAPHORE2: Thread2 initial wait failed, %x\n", Status);

    } else {
        for (Index = 0; Index < SEMAPHORE2_SWITCHES; Index += 1) {
            Status = NtSignalAndWaitForSingleObject(SemaphoreHandle1,
                                                    SemaphoreHandle2,
                                                    FALSE,
                                                    NULL);

            if (!NT_SUCCESS(Status)) {
                printf("SEMAPHORE2: Thread2 signal/wait failed, %x\n", Status);
                break;
            }
        }
    }

    NtTerminateThread(Thread2Handle, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
SlistTest (
    VOID
    )

{

    SLIST_ENTRY Entry;
    SLIST_HEADER SListHead;
    ULONG Index;
    PERFINFO PerfInfo;
    LARGE_INTEGER SystemTime;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("S-List Benchmark",
                   SLIST_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    InitializeSListHead(&SListHead);
    for (Index = 0; Index < SLIST_ITERATIONS; Index += 1) {
        InterlockedPushEntrySList(&SListHead, &Entry);
        if (InterlockedPopEntrySList(&SListHead) != (PVOID)&Entry) {
            printf("SLIST: Entry does match %lx\n", Entry);
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
SystemCallTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    LARGE_INTEGER SystemTime;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("System Call Benchmark (NtQuerySystemTime)",
                   SYSCALL_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    for (Index = 0; Index < SYSCALL_ITERATIONS; Index += 1) {
        NtQuerySystemTime(&SystemTime);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
TimerOperationTest (
    VOID
    )

{

    LARGE_INTEGER DueTime;
    HANDLE Handle;
    ULONG Index;
    PERFINFO PerfInfo;
    LARGE_INTEGER SystemTime;
    NTSTATUS Status;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Timer Operation Benchmark (NtSet/CancelTimer)",
                   TIMER_OPERATION_ITERATIONS,
                   &PerfInfo);

    //
    // Create a timer object for use in the test.
    //

    Status = NtCreateTimer(&Handle,
                           TIMER_ALL_ACCESS,
                           NULL,
                           NotificationTimer);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create timer during initialization\n");
        goto EndOfTest;
    }

    //
    // Repeatedly set and cancel a timer.
    //

    DueTime = RtlConvertLongToLargeInteger(- 100 * 1000 * 10);
    for (Index = 0; Index < TIMER_OPERATION_ITERATIONS; Index += 1) {
        NtSetTimer(Handle, &DueTime, NULL, NULL, FALSE, 0, NULL);
        NtCancelTimer(Handle, NULL);
    }

    //
    // Print out performance statistics.
    //

EndOfTest:
    FinishBenchMark(&PerfInfo);
    return;
}

VOID
UnalignedTest1 (
    VOID
    )

{

    PULONG Address;
    UCHAR Array[128];
    ULONG Count;
    ULONG Index;
    PERFINFO PerfInfo;
    ULONG Sum = 0;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    for (Index = 1; Index < 65; Index += 1) {
        Array[Index] = (UCHAR)Index;
    }

    StartBenchMark("Unaligned DWORD Access Test - Hardware",
                   UNALIGNED_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly sum array;
    //

    for (Count = 0; Count < UNALIGNED_ITERATIONS; Count += 1) {
        Address = (PULONG)&Array[1];
        for (Index = 1; Index < 65; Index += 4) {
            Sum += *Address;
            Address += 1;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    printf("final sum %d\n", Sum);
    return;
}

VOID
UnalignedTest2 (
    VOID
    )

{

    PULONG Address;
    UCHAR Array[128];
    ULONG Count;
    ULONG Index;
    PERFINFO PerfInfo;
    ULONG Sum = 0;
    ULONG Value;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    for (Index = 1; Index < 65; Index += 1) {
        Array[Index] = (UCHAR)Index;
    }

    StartBenchMark("Unaligned DWORD Access Test - Software",
                   UNALIGNED_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly sum array;
    //

    for (Count = 0; Count < UNALIGNED_ITERATIONS; Count += 1) {
        Address = (PULONG)&Array[1];
        for (Index = 1; Index < 65; Index += 4) {
            Value = *((PUCHAR)Address + 3);
            Value = (Value << 8) + *((PUCHAR)Address + 2);
            Value = (Value << 8) + *((PUCHAR)Address + 1);
            Value = (Value << 8) + *((PUCHAR)Address + 0);
            Address += 1;
            Sum += Value;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    printf("final sum %d\n", Sum);
    return;
}

VOID
WaitSingleTest (
    VOID
    )

{

    HANDLE EventHandle;
    LONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Create an event for synchronization of wait single operations.
    //

    Status = NtCreateEvent(&EventHandle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object for wait single test\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Wait Single Benchmark",
                   WAIT_SINGLE_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly wait for a single event.
    //

    for (Index = 0; Index < WAIT_SINGLE_ITERATIONS; Index += 1) {
        Status = NtWaitForSingleObject(EventHandle, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            printf("       Wait single bad wait status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of Wait Single Test.
    //

EndOfTest:
    NtClose(EventHandle);
    return;
}

VOID
WaitMultipleTest (
    VOID
    )

{

    HANDLE Event1Handle;
    HANDLE Event2Handle;
    HANDLE WaitObjects[2];
    LONG Index;
    PERFINFO PerfInfo;
    NTSTATUS Status;

    //
    // Create two events for synchronization of wait multiple operations.
    //

    Status = NtCreateEvent(&Event1Handle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object 1 for wait multiple test\n");
        goto EndOfTest;
    }

    Status = NtCreateEvent(&Event2Handle,
                           DESIRED_EVENT_ACCESS,
                           NULL,
                           NotificationEvent,
                           TRUE);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create event object 2 for wait multiple test\n");
        goto EndOfTest;
    }

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Wait Multiple Benchmark",
                   WAIT_MULTIPLE_ITERATIONS,
                   &PerfInfo);

    //
    // Repeatedly wait for a multiple events.
    //

    WaitObjects[0] = Event1Handle;
    WaitObjects[1] = Event2Handle;
    for (Index = 0; Index < WAIT_SINGLE_ITERATIONS; Index += 1) {
    Status = NtWaitForMultipleObjects(2,
                                      WaitObjects,
                                      WaitAny,
                                      FALSE,
                                      NULL);

        if (!NT_SUCCESS(Status)) {
            printf("       Wait multiple bad wait status, %x\n", Status);
            goto EndOfTest;
        }
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    //
    // End of Wait Multiple Test.
    //

EndOfTest:
    NtClose(Event1Handle);
    NtClose(Event2Handle);
    return;
}

NTSTATUS
TimerThread (
    IN PVOID Context
    )

{

    LARGE_INTEGER DueTime;
    NTSTATUS Status;
    HANDLE WaitObjects[2];

    //
    // Initialize variables and loop until the timer event is set.
    //

    DueTime.LowPart = -(5 * 1000 * 1000);
    DueTime.HighPart = -1;

    WaitObjects[0] = TimerEventHandle;
    WaitObjects[1] = TimerTimerHandle;

    do  {
        Status = NtSetTimer(TimerTimerHandle,
                            &DueTime,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        Status = NtWaitForMultipleObjects(2,
                                          WaitObjects,
                                          WaitAny,
                                          FALSE,
                                          NULL);

    } while (Status != STATUS_SUCCESS);

    NtTerminateThread(TimerThreadHandle, Status);
    return STATUS_SUCCESS;
}

NTSTATUS
xCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    IN KPRIORITY Priority
    )

{

    NTSTATUS Status;

    //
    // Create a thread in the suspended state, sets its priority, and then
    // resume the thread.
    //

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 TRUE,
                                 0,
                                 0,
                                 0,
                                 StartRoutine,
                                 NULL,
                                 Handle,
                                 NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = NtSetInformationThread(*Handle,
                                    ThreadPriority,
                                    &Priority,
                                    sizeof(KPRIORITY));

    if (!NT_SUCCESS(Status)) {
        NtClose(*Handle);
        return Status;
    }

    Status = NtResumeThread(*Handle,
                            NULL);

    if (!NT_SUCCESS(Status)) {
        NtClose(*Handle);
    }

    return Status;
}

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG InterruptCount;
    ULONG Length;
    ULONG Performance;
    ULONG Remainder;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;
    LARGE_INTEGER TotalCycles;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQueryInformationThread(NtCurrentThread(),
                                      ThreadPerformanceCount,
                                      &PerfInfo->StopCycles,
                                      sizeof(LARGE_INTEGER),
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query performance count, status = %lx\n", Status);
        return;
    }

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration.QuadPart = PerfInfo->StopTime.QuadPart - PerfInfo->StartTime.QuadPart;
    Length = Duration.LowPart / 10000;
    TotalCycles.QuadPart = PerfInfo->StopCycles.QuadPart - PerfInfo->StartCycles.QuadPart;
    TotalCycles = RtlExtendedLargeIntegerDivide(TotalCycles,
                                                PerfInfo->Iterations,
                                                &Remainder);

    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);
//    printf("        Cycles per iteration      %d\n", TotalCycles.LowPart);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQueryInformationThread(NtCurrentThread(),
                                      ThreadPerformanceCount,
                                      &PerfInfo->StartCycles,
                                      sizeof(LARGE_INTEGER),
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query performance count, status = %lx\n", Status);
        return;
    }

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}

LONG
SetProcessPrivilege (
    TCHAR *PrivilegeName
    )

{

    TOKEN_PRIVILEGES NewPrivileges;
    BOOL Status;
    HANDLE Token = NULL;
    LONG Value = - 1;

    //
    // Open process token.
    //

    Status = OpenProcessToken(GetCurrentProcess(),
                              TOKEN_ADJUST_PRIVILEGES,
                              &Token);

    if (Status == FALSE) {
        goto Done;
    }

    //
    // Look up privilege value.
    //

    Status = LookupPrivilegeValue(NULL,
                                  PrivilegeName,
                                  &NewPrivileges.Privileges[0].Luid);

    if (Status == FALSE) {
        goto Done;
    }

    //
    // Adjust token privileges.
    //

    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    NewPrivileges.PrivilegeCount = 1;
    Status = AdjustTokenPrivileges(Token,
                                   FALSE,
                                   &NewPrivileges,
                                   0,
                                   NULL,
                                   NULL);

    if (Status != FALSE) {
        Value = 0;
    }

    //
    // Close handle and return status.
    //

Done:

    if (Token != NULL) {
        CloseHandle(Token);
    }

    return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tee\tee.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tee.c

Abstract:

    Utility program to read stdin and write it to stdout and a file.

Author:

    Steve Wood (stevewo) 01-Feb-1992

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

void
Usage()
{
    printf("Usage: tee [-a] OutputFileName(s)...\n" );
    exit(1);
}

#define MAX_OUTPUT_FILES 8

__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i, c;
    char *s, *OpenFlags;
    int NumberOfOutputFiles;
    FILE *OutputFiles[ MAX_OUTPUT_FILES ];

    if (argc < 2) {
        Usage();
        }

    NumberOfOutputFiles = 0;
    OpenFlags = "wb";
    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            s++;
            switch( tolower( *s ) ) {
                case 'a':   OpenFlags = "ab"; break;
                default:    Usage();
                }
            }
        else
        if (NumberOfOutputFiles >= MAX_OUTPUT_FILES) {
            fprintf( stderr, "TEE: too many output files specified - %s\n", s );
            }
        else
        if (!(OutputFiles[NumberOfOutputFiles] = fopen( s, OpenFlags ))) {
            fprintf( stderr, "TEE: unable to open file - %s\n", s );
            }
        else {
            NumberOfOutputFiles++;
            }
        }

    if (NumberOfOutputFiles == 0) {
        fprintf( stderr, "TEE: no output files specified.\n" );
        }

    while ((c = getchar()) != EOF) {
        putchar( c );
        for (i=0; i<NumberOfOutputFiles; i++) {
            if (c == '\n') {
                putc('\r', OutputFiles[ i ] ); //CRT reads cr/lf as lf
                putc('\n', OutputFiles[ i ] ); //must write as cr/lf
                fflush( OutputFiles[ i ] );
                }
            else {
                putc( c, OutputFiles[ i ] );
                }
            }
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\timer\timer.c ===
/* execute a routine and determine the time spent...
 *
 *  26-Jan-1987 bw  Clean up, add 286DOS support
 *  30-Oct-1987 bw  Changed 'DOS5' to 'OS2'
 *  18-Oct-1990 w-barry Removed 'dead' code.
 *  28-Nov-1990 w-barry Replaced DosQuerySysInfo() with the C runtime
 *                      function 'clock' - timing is not as accurate; but,
 *                      until there is a win32 replacement, it will have to
 *                      do...
 */
#define INCL_DOSMISC


#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

__cdecl
main (
    int c,
    char *v[]
    )
{
    int i;
    long t, t1;
    char *newv[128];

    ConvertAppToOem( c, v );
    for (i = 1; i < c; i++)
        printf ("%s ", v[i]);
    printf ("\n");

//    newv[0] = getenv ("COMSPEC");
    newv[0] = getenvOem ("COMSPEC");
    newv[1] = "/C";
    for (i = 1; i < c; i++)
        newv[i+1] = v[i];
    newv[i+1] = NULL;

    t = clock();

    if ( (i = (int) _spawnvp (P_WAIT, newv[0], newv)) == -1) {
        printf("'%s' failed to run - %s\n", newv[0], error());
        exit(1);
        }

    t1 = clock();

    printf ("Results of execution:\n\n");
    printf ("    Exit code %x\n", i);
    t1 -= t;
    printf ("    Time of execution %ld.%03ld\n", t1 / CLK_TCK, t1 % CLK_TCK );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\timtp\i386\xsum.asm ===
include xsum.x86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\common.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


//
// global variables
//
PUCHAR  CommonLargeBuffer;
ULONG   CommonLargeBufferSize = 64*1024;

//
// prototypes
//
BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    );

BOOL CALLBACK
EnumWindowStationsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    );

BOOL CALLBACK
EnumDesktopsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    );


DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of process information for Win 32
    services that are running at the time of the API call.

Arguments:

    ppInfo  - address of a pointer to return the information.
              *ppInfo points to memory allocated with malloc.

Return Value:

    Number of ENUM_SERVICE_STATUS_PROCESS structures pointed at by *ppInfo.

--*/

{
    DWORD       dwNumServices = 0;
    SC_HANDLE   hScm;

    typedef
    BOOL
    (__stdcall * PFN_ENUMSERVICSESTATUSEXA) (
        SC_HANDLE    hSCManager,
        SC_ENUM_TYPE InfoLevel,
        DWORD        dwServiceType,
        DWORD        dwServiceState,
        LPBYTE       lpServices,
        DWORD        cbBufSize,
        LPDWORD      pcbBytesNeeded,
        LPDWORD      lpServicesReturned,
        LPDWORD      lpResumeHandle,
        LPCSTR       pszGroupName);

    PFN_ENUMSERVICSESTATUSEXA p_EnumServicesStatusEx;
    HINSTANCE   hAdv = LoadLibrary("advapi32.dll");

    // Initialize the output parmeter.
    *ppInfo = NULL;

    if (hAdv)
    {
        p_EnumServicesStatusEx = (PFN_ENUMSERVICSESTATUSEXA)
            GetProcAddress(hAdv, "EnumServicesStatusExA");

        if (!p_EnumServicesStatusEx)
        {
            return 0;
        }
    } else {
        return 0;
    }

    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESS   pInfo    = NULL;
        DWORD                           cbInfo   = 4 * 1024;
        DWORD                           cbExtraNeeded = 0;
        DWORD                           dwErr;
        DWORD                           dwResume;
        DWORD                           cLoop    = 0;
        const DWORD                     cLoopMax = 2;

        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {
            free (pInfo);
            cbInfo += cbExtraNeeded;
            pInfo = (LPENUM_SERVICE_STATUS_PROCESS)malloc(cbInfo);
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            dwErr = ERROR_SUCCESS;
            dwResume = 0;
            if (!p_EnumServicesStatusEx(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (LPBYTE)pInfo,
                    cbInfo,
                    &cbExtraNeeded,
                    &dwNumServices,
                    &dwResume,
                    NULL)) {
                dwErr = GetLastError();
            }
        }
        while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwNumServices) {
            *ppInfo = pInfo;
        } else {
            free (pInfo);
            dwNumServices = 0;
        }

        CloseServiceHandle(hScm);
    }

    return dwNumServices;
}

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESS*  pServiceInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:
    pTask           - Array of TASK_LIST structures to fill.
    dwNumTasks      - Maximum number of tasks that the pTask array can hold.
    fThreadInfo     - TRUE if thread information is desired.
    dwNumServices   - Maximum number of entries in pServiceInfo.
    pServiceInfo    - Array of service status structures to reference
                      for supporting services in processes.

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p;
    ULONG                        TotalOffset;
    ULONG                        totalTasks = 0;

retry:

    if (CommonLargeBuffer == NULL) {
        CommonLargeBuffer = VirtualAlloc (NULL,
                                          CommonLargeBufferSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
        if (CommonLargeBuffer == NULL) {
            return 0;
        }
    }
    status = NtQuerySystemInformation(
                SystemProcessInformation,
                CommonLargeBuffer,
                CommonLargeBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        CommonLargeBufferSize += 8192;
        VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
        CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) {
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            if (pname.Buffer) {
                p = strrchr(pname.Buffer,'\\');
                if ( p ) {
                    p++;
                }
                else {
                    p = pname.Buffer;
                }
            } else {
                p = "";
            }
        }
        else {
            p = "System Process";
        }

        strncpy( pTask->ProcessName, p, PROCESS_SIZE );
        pTask->ProcessName[PROCESS_SIZE-1] = '\0';
        pTask->flags = 0;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->dwInheritedFromProcessId = (DWORD)(DWORD_PTR)ProcessInfo->InheritedFromUniqueProcessId;
        pTask->CreateTime.QuadPart = (ULONGLONG)ProcessInfo->CreateTime.QuadPart;

        pTask->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
        pTask->VirtualSize = ProcessInfo->VirtualSize;
        pTask->PageFaultCount = ProcessInfo->PageFaultCount;
        pTask->PeakWorkingSetSize = ProcessInfo->PeakWorkingSetSize;
        pTask->WorkingSetSize = ProcessInfo->WorkingSetSize;
        pTask->NumberOfThreads = ProcessInfo->NumberOfThreads;

        if (fThreadInfo) {
            if (pTask->pThreadInfo = malloc(pTask->NumberOfThreads * sizeof(THREAD_INFO))) {

                UINT nThread = pTask->NumberOfThreads;
                PTHREAD_INFO pThreadInfo = pTask->pThreadInfo;
                PSYSTEM_THREAD_INFORMATION pSysThreadInfo =
                    (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

                while (nThread--) {
                    pThreadInfo->ThreadState = pSysThreadInfo->ThreadState;
                    pThreadInfo->UniqueThread = pSysThreadInfo->ClientId.UniqueThread;

                    pThreadInfo++;
                    pSysThreadInfo++;
                }
            }
        } else {
            pTask->pThreadInfo = NULL;
        }

        pTask->MtsPackageNames[0] = 0;
        pTask->SessionId = ProcessInfo->SessionId;
        pTask->CommandLine[0] = 0;
        
        // Initialize the ServiceNames if this task hosts any.
        //
        *pTask->ServiceNames = 0;
        if (dwNumServices)
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            BOOL    fFirstTime = TRUE;
            DWORD   iSvc;
            size_t  cchRemain = SERVICENAMES_SIZE - 1;
            size_t  cch;

            for (iSvc = 0; iSvc < dwNumServices; iSvc++) {
                if (pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId) {
                    cch = strlen(pServiceInfo[iSvc].lpServiceName);

                    if (fFirstTime) {
                        fFirstTime = FALSE;

                        strncpy(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);

                        // strncpy may not terminate the string if
                        // cchRemain <= cch so we do it regardless.
                        //
                        pTask->ServiceNames[cchRemain] = 0;
                    } else if (cchRemain > 1) { // ensure room for the comma
                        strncat(
                            pTask->ServiceNames,
                            ",",
                            cchRemain--);

                        strncat(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);
                    }

                    // Counts are unsigned so we have to check before
                    // subtracting.
                    //
                    if (cchRemain < cch) {
                        // No more room for any more.
                        break;
                    } else {
                        cchRemain -= cch;
                    }
                }
            }
        }

        pTask++;
        totalTasks++;
        if (totalTasks == dwNumTasks) {
            break;
        }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];
    }

    return totalTasks;
}

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    return GetTaskListEx(pTask, dwNumTasks, FALSE, 0, NULL);
}

void
AddMtsPackageNames(
    PTASK_LIST Tasks,
    DWORD NumTasks
    )
{
    HRESULT Hr;
    IMtsGrp* MtsGroup;
    long Packages;
    long i;

    if ((Hr = CoInitialize(NULL)) != S_OK) {
        return;
    }
    if ((Hr = CoCreateInstance(&CLSID_MtsGrp, NULL, CLSCTX_ALL,
                               &IID_IMtsGrp, (void **)&MtsGroup)) != S_OK) {
        goto Uninit;
    }
    
    if ((Hr = MtsGroup->lpVtbl->Refresh(MtsGroup)) != S_OK ||
        (Hr = MtsGroup->lpVtbl->get_Count(MtsGroup, &Packages)) != S_OK) {
        goto ReleaseGroup;
    }

    for (i = 0; i < Packages; i++) {
        IUnknown* Unk;
        IMtsEvents* Events;
        BSTR Name;
        DWORD Pid;
        DWORD TaskIdx;
        
        if ((Hr = MtsGroup->lpVtbl->Item(MtsGroup, i, &Unk)) != S_OK) {
            continue;
        }

        Hr = Unk->lpVtbl->QueryInterface(Unk, &IID_IMtsEvents,
                                         (void **)&Events);

        Unk->lpVtbl->Release(Unk);

        if (Hr != S_OK) {
            continue;
        }
        
        Hr = Events->lpVtbl->GetProcessID(Events, (PLONG)&Pid);
        if (Hr == S_OK) {
            Hr = Events->lpVtbl->get_PackageName(Events, &Name);
        }

        Events->lpVtbl->Release(Events);

        if (Hr != S_OK) {
            continue;
        }

        for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {
            if (Tasks[TaskIdx].dwProcessId == Pid) {
                break;
            }
        }

        if (TaskIdx < NumTasks) {
            PSTR Str;
            int Conv;

            Str = Tasks[TaskIdx].MtsPackageNames +
                strlen(Tasks[TaskIdx].MtsPackageNames);
            if (Str > Tasks[TaskIdx].MtsPackageNames) {
                *Str++ = ',';
            }

            Conv = WideCharToMultiByte(
                CP_ACP,
                0,
                Name,
                -1,
                Str,
                MTS_PACKAGE_NAMES_SIZE -
                (DWORD)(Str - Tasks[TaskIdx].MtsPackageNames) - 2,
                NULL,
                NULL
                );

            SysFreeString(Name);

            if (Conv == 0 && Str > Tasks[TaskIdx].MtsPackageNames &&
                *(Str - 1) == ',') {
                *(Str - 1) = 0;
            }
        }
    }

 ReleaseGroup:
    MtsGroup->lpVtbl->Release(MtsGroup);
 Uninit:
    CoUninitialize();
    return;
}
    
void
AddCommandLines(
    PTASK_LIST Tasks,
    DWORD NumTasks
    )
{
    NTSTATUS NtStatus;
    DWORD TaskIdx;
    PTASK_LIST Task;

    Task = Tasks;
    for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++, Task++) {
        
        HANDLE Process;
        int Conv;
        PROCESS_BASIC_INFORMATION Basic;
        PEB Peb;
        RTL_USER_PROCESS_PARAMETERS ProcParams;
        ULONG Done;
        SIZE_T DoneSize;
        PWSTR CmdLine;

        Process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                              FALSE, Task->dwProcessId);
        if (!Process) {
            continue;
        }
        
        NtStatus = NtQueryInformationProcess(Process, ProcessBasicInformation,
                                             &Basic, sizeof(Basic), &Done);
        if (!NT_SUCCESS(NtStatus) ||
            Done != sizeof(Basic) ||
            !Basic.PebBaseAddress ||
            !ReadProcessMemory(Process, Basic.PebBaseAddress,
                               &Peb, sizeof(Peb), &DoneSize) ||
            DoneSize != sizeof(Peb) ||
            !ReadProcessMemory(Process, Peb.ProcessParameters,
                               &ProcParams, sizeof(ProcParams), &DoneSize) ||
            DoneSize != sizeof(ProcParams) ||
            !ProcParams.CommandLine.Buffer ||
            !(CmdLine = (PWSTR)malloc(ProcParams.CommandLine.Length +
                                      sizeof(WCHAR)))) {
            goto EH_Process;
        }

        if (!ReadProcessMemory(Process, ProcParams.CommandLine.Buffer,
                               CmdLine, ProcParams.CommandLine.Length,
                               &DoneSize) ||
            DoneSize < ProcParams.CommandLine.Length) {
            goto EH_CmdLine;
        }

        CmdLine[DoneSize / sizeof(WCHAR)] = 0;
        
        if (!WideCharToMultiByte(CP_ACP, 0, CmdLine, -1,
                                 Task->CommandLine,
                                 sizeof(Task->CommandLine) - 1,
                                 NULL, NULL)) {
            Task->CommandLine[0] = 0;
        }
        
    EH_CmdLine:
        free(CmdLine);
    EH_Process:
        CloseHandle(Process);
    }
}
    
BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    DWORD i, j;
    BOOL Result = FALSE;

    for (i=0; i<dwNumTasks; i++) {
        if (pTask[i].dwInheritedFromProcessId != 0) {
            for (j=0; j<dwNumTasks; j++) {
                if (i != j && pTask[i].dwInheritedFromProcessId == pTask[j].dwProcessId) {
                    if (pTask[i].CreateTime.QuadPart <= pTask[j].CreateTime.QuadPart) {
                        pTask[i].dwInheritedFromProcessId = 0;
                        Result = TRUE;
                        }

                    break;
                    }
                }
            }
        }

    return Result;
}

BOOL
EnableDebugPriv(
    VOID
    )

/*++

Routine Description:

    Changes the tlist process's privilige so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
        printf("OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depending on the fEnable flag.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL,
            SE_DEBUG_NAME,
            &DebugValue)) {
        printf("LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        printf("AdjustTokenPrivileges failed with %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    )
{
    HANDLE            hProcess, hProcess1;
    HDESK             hdeskSave;
    HDESK             hdesk;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    if (fForce || !tlist->hwnd) {
        hProcess1 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );
        if (hProcess1) {
            hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );
            if (hProcess == NULL) {
                CloseHandle(hProcess1);
                return FALSE;
            }

            if (!TerminateProcess( hProcess, 1 )) {
                CloseHandle( hProcess );
                CloseHandle( hProcess1 );
                return FALSE;
            }

            CloseHandle( hProcess );
            CloseHandle( hProcess1 );
            return TRUE;
        }
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( tlist->lpWinsta, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    //
    // open the desktop
    //
    hdesk = OpenDesktop( tlist->lpDesk, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    //
    // kill the process
    //
    PostMessage( tlist->hwnd, WM_CLOSE, 0, 0 );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    return TRUE;
}


VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    )
{
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    EnumWindowStations( EnumWindowStationsFunc, (LPARAM)te );
}


BOOL CALLBACK
EnumWindowStationsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback function for windowstation enumeration.

Arguments:

    lpstr            - windowstation name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( lpstr, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    te->lpWinsta = _strdup( lpstr );

    //
    // enumerate all the desktops for this windowstation
    //
    EnumDesktops( hwinsta, EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //
    return TRUE;
}
BOOL CALLBACK
EnumMessageWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam
    )

/*++

Routine Description:

    Enumarates message windows (which are not enumarated by EnumWindows)

Arguments:

    lpEnumFunc       - Callback function
    lParam           - Caller data

Return Value:

    TRUE

--*/

{

    HWND hwnd = NULL;
    do {
        hwnd = FindWindowEx(HWND_MESSAGE, hwnd, NULL, NULL);
        if (hwnd != NULL) {
            if (!(*lpEnumFunc)(hwnd, lParam)) {
                break;
            }
        }
    } while (hwnd != NULL);
    return TRUE;
}

BOOL CALLBACK
EnumDesktopsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback function for desktop enumeration.

Arguments:

    lpstr            - desktop name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;


    //
    // open the desktop
    //
    hdesk = OpenDesktop( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    te->lpDesk = _strdup( lpstr );

    //
    // enumerate all windows in the new desktop
    //

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = TRUE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );
    EnumMessageWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = FALSE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );
    EnumMessageWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    return TRUE;
}


BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    )

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - pte

Return Value:

    TRUE  - continues the enumeration

--*/

{
    DWORD             pid = 0;
    DWORD             i;
    CHAR              buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // Use try/except block when enumerating windows,
    // as a window may be destroyed by another thread
    // when being enumerated.
    //
    try {
        //
        // get the processid for this window
        //
        if (!GetWindowThreadProcessId( hwnd, &pid )) {
            return TRUE;
        }

        if ((GetWindow( hwnd, GW_OWNER )) ||
            (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)) && te->bFirstLoop) {
            //
            // not a top level window
            //
            return TRUE;
        }

        //
        // look for the task in the task list for this window
        // If this is the second time let invisible windows through if we don't
        // have a window already
        //
        for (i=0; i<numTasks; i++) {
            if ((tlist[i].dwProcessId == pid) && (te->bFirstLoop || (tlist[i].hwnd == 0))) {
                tlist[i].hwnd = hwnd;
                tlist[i].lpWinsta = te->lpWinsta;
                tlist[i].lpDesk = te->lpDesk;
                //
                // we found the task no lets try to get the
                // window text
                //
                if (GetWindowText( tlist[i].hwnd, buf, sizeof(buf) )) {
                    //
                    // go it, so lets save it
                    //
                    strcpy( tlist[i].WindowTitle, buf );
                }
                break;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    //
    // continue the enumeration
    //
    return TRUE;
}

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    )
{
    INT   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = toupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (toupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    )
{
    HANDLE  hProcess;
    SIZE_T  dwMinimumWorkingSetSize;
    SIZE_T  dwMaximumWorkingSetSize;


    hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid );
    if (hProcess == NULL) {
        return FALSE;
    }

    if (!GetProcessWorkingSetSize(
            hProcess,
            &dwMinimumWorkingSetSize,
            &dwMaximumWorkingSetSize
            )) {
        CloseHandle( hProcess );
        return FALSE;
    }


    SetProcessWorkingSetSize( hProcess, 0xffffffff, 0xffffffff );
    CloseHandle( hProcess );

    return TRUE;
}

BOOL
EmptySystemWorkingSet(
    VOID
    )

{
    SYSTEM_FILECACHE_INFORMATION info;
    NTSTATUS status;

    info.MinimumWorkingSet = 0xffffffff;
    info.MaximumWorkingSet = 0xffffffff;
    if (!NT_SUCCESS (status = NtSetSystemInformation(
                                    SystemFileCacheInformation,
                                    &info,
                                    sizeof (info)))) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\common.h ===
#pragma once

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_TASKS              1024
#define TITLE_SIZE             128
#define PROCESS_SIZE           64
#define SERVICENAMES_SIZE      1024
#define MTS_PACKAGE_NAMES_SIZE 1024
#define TL_CMD_LINE_SIZE       512

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _FIND_MODULE_INFO {
    LPSTR  szModuleToFind;
    LPSTR  szMatchingModuleName;
    BOOL   fFound;
} FIND_MODULE_INFO, *PFIND_MODULE_INFO;


//
// task list structure
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];
    SIZE_T      PeakVirtualSize;
    SIZE_T      VirtualSize;
    ULONG       PageFaultCount;
    SIZE_T      PeakWorkingSetSize;
    SIZE_T      WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;
    CHAR        ServiceNames[SERVICENAMES_SIZE];
    CHAR        MtsPackageNames[MTS_PACKAGE_NAMES_SIZE];
    ULONG       SessionId;
    CHAR        CommandLine[TL_CMD_LINE_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppSvcInfo
    );

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESS*  pServiceInfo
    );

void
AddMtsPackageNames(
    PTASK_LIST Tasks,
    DWORD NumTasks
    );
    
void
AddCommandLines(
    PTASK_LIST Tasks,
    DWORD NumTasks
    );
    
void
PrintTasksUsingModule(
    LPTSTR szModuleName
    );


BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

BOOL
EnableDebugPriv(
    VOID
    );

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    );

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    );

BOOL
EmptySystemWorkingSet(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\empty.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a working set empty application.

Author:

    Lou Perazzoli (loup) 20-May-1994
    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


DWORD       pid;
CHAR        pname[MAX_PATH];
TASK_LIST   tlist[MAX_TASKS];

CHAR System[] = "System";

VOID GetCommandLineArgs(VOID);


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD          i;
    DWORD          numTasks;
    int            rval = 0;
    TASK_LIST_ENUM te;
    char           tname[PROCESS_SIZE];
    LPSTR          p;


    GetCommandLineArgs();

    if (pid == 0 && pname[0] == 0) {
        printf( "missing pid or task name\n" );
        return 1;
    }

    //
    // let's be god
    //

    EnableDebugPriv();

    if (pid) {
        if (!EmptyProcessWorkingSet( pid )) {
            printf( "could not empty working set for process #%d\n", pid );
            return 1;
        }
        return 0;
    }

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( tlist, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    for (i=0; i<numTasks; i++) {
        strcpy( tname, tlist[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }
        if (MatchPattern( tname, pname )) {
            tlist[i].flags = TRUE;
        } else if (MatchPattern( tlist[i].ProcessName, pname )) {
            tlist[i].flags = TRUE;
        } else if (MatchPattern( tlist[i].WindowTitle, pname )) {
            tlist[i].flags = TRUE;
        }
    }

    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            if (!EmptyProcessWorkingSet( tlist[i].dwProcessId )) {
                printf( "could not empty working set for process #%d [%s]\n", tlist[i].dwProcessId, tlist[i].ProcessName );
                rval = 1;
            }
        }
    }

    if (MatchPattern(System, pname )) {
        if (!EmptySystemWorkingSet()) {
            printf( "could not empty working set for process #%d [%s]\n",0,&System );
        }
    }

    return rval;
}

VOID
GetCommandLineArgs(
    VOID
    )
{
    char        *lpstrCmd;
    UCHAR       ch;
    char        *p = pname;


    pid = 0;
    *p = '\0';

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != ' ' && ch != '\t' && ch != '\0');

    //  skip over any following white space
    while (isspace(ch)) {
        ch = *lpstrCmd++;
    }

    if (isdigit(ch)) {
        while (isdigit(ch)) {
            pid = pid * 10 + ch - '0';
            ch = *lpstrCmd++;
        }
    }
    else {
      while (ch) {
            *p++ = ch;
            ch = *lpstrCmd++;
        }
        *p = '\0';
        _strupr( pname );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>
#include <comsvcs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\emptyq.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    emptyq.c

Abstract:

    This module implements a working set empty application.

Author:

    Lou Perazzoli (loup) 20-May-1994
    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/


#include "pch.h"
#pragma hdrstop


TASK_LIST   tlist[MAX_TASKS];
CHAR        buffer[64*1024];


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD                       i;
    DWORD                       numTasks;
    int                         rval = 0;
    TASK_LIST_ENUM              te;
    char                        tname[PROCESS_SIZE];
    LPSTR                       p;
    ULONG                       first = FALSE;
    NTSTATUS                    status;
    PSYSTEM_MEMORY_INFORMATION  MemInfo;
    PSYSTEM_MEMORY_INFO         Info;
    PSYSTEM_MEMORY_INFO         InfoEnd;
    PUCHAR                      String;
    ULONG                       TotalValid;
    ULONG                       TotalPageTable;
    SYSTEMTIME                  Time;


    //
    // let's be god
    //

    EnableDebugPriv();

    for (; ; ) {

        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        if (first) {
            status = NtQuerySystemInformation (SystemSummaryMemoryInformation,
                                             &buffer,
                                             64*1024,
                                             NULL);
            if (!NT_SUCCESS (status)) {
                printf("query system information failed %lx\n",status);
                return 1;
            }
            GetLocalTime (&Time);

            TotalValid = 0;
            TotalPageTable = 0;
            MemInfo = (PSYSTEM_MEMORY_INFORMATION)buffer;
            Info = &MemInfo->Memory[0];
            InfoEnd = (PSYSTEM_MEMORY_INFO)MemInfo->StringStart;
            printf("  time: %ld %2ld:%2ld.%03ld\n",
                                 Time.wHour,
                                 Time.wMinute,
                                 Time.wSecond,
                                Time.wMilliseconds);
            while (Info < InfoEnd) {
                if (Info->PageTableCount &&
                    ((Info->PageTableCount + 2) >= Info->ValidCount)) {
                    Info += 1;
                    continue;
                }
                if (Info->StringOffset != 0) {
                    if (*(PUCHAR)(Info->StringOffset + 1) != 0) {
                        printf("%4ld. %4ld. %s\n",Info->ValidCount*4,
                                            Info->PageTableCount*4,
                                            Info->StringOffset);
                    } else {
                        printf("%4ld. %4ld. %ws\n",Info->ValidCount*4,
                                        Info->PageTableCount*4,
                                        (wchar_t *)Info->StringOffset);
                    }
                } else {
                    printf("%4ld. %4ld. unable to get name\n",Info->ValidCount*4,
                                    Info->PageTableCount*4);
                }
                TotalValid += Info->ValidCount;
                TotalPageTable += Info->PageTableCount;
                Info += 1;
            }
            printf("\n%4ld. %4ld.  ** TOTAL **\n\n\n",
                    TotalValid*4,
                    TotalPageTable*4);

        }

        first = TRUE;

        //
        // get the task list for the system
        //

        numTasks = GetTaskList( tlist, MAX_TASKS );

        //
        // enumerate all windows and try to get the window
        // titles for each task
        //

        te.tlist = tlist;
        te.numtasks = numTasks;
        GetWindowTitles( &te );

        for (i=0; i<numTasks; i++) {
                if (!EmptyProcessWorkingSet( tlist[i].dwProcessId )) {
                    //printf( "could not empty working set for process #%d [%s]\n", tlist[i].dwProcessId, tlist[i].ProcessName );
                    rval = 1;
                }
        }

        if (!EmptySystemWorkingSet()) {
                //printf( "could not empty working set for process #%d [%s]\n",0,&System );
        }

        Sleep (1000);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\kill.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a task killer application.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


BOOL        ForceKill;

struct _arg {
    DWORD pid;
    CHAR *pname;
} Arguments[ 64 ];
DWORD NumberOfArguments;

TASK_LIST   tlist[MAX_TASKS];


VOID GetCommandLineArgs(VOID);
VOID Usage(VOID);



int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD          i, j;
    DWORD          numTasks;
    TASK_LIST_ENUM te;
    int            rval = 0;
    char           tname[PROCESS_SIZE];
    LPSTR          p;
    DWORD          ThisPid;


    GetCommandLineArgs();

    if (NumberOfArguments == 0) {
        printf( "missing pid or task name\n" );
        return 1;
    }

    //
    // lets be god
    //
    EnableDebugPriv();

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( tlist, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    ThisPid = GetCurrentProcessId();

    for (i=0; i<numTasks; i++) {
        //
        // this prevents the user from killing KILL.EXE and
        // it's parent cmd window too
        //
        if (ThisPid == tlist[i].dwProcessId) {
            continue;
        }
        if (MatchPattern( tlist[i].WindowTitle, "*KILL*" )) {
            continue;
        }

        tname[0] = 0;
        strcpy( tname, tlist[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }

        for (j=0; j<NumberOfArguments; j++) {
            if (Arguments[j].pname) {
                if (MatchPattern( tname, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                } else if (MatchPattern( tlist[i].ProcessName, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                } else if (MatchPattern( tlist[i].WindowTitle, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                }
            } else if (Arguments[j].pid) {
                    if (tlist[i].dwProcessId == Arguments[j].pid) {
                        tlist[i].flags = TRUE;
                    }
            }
        }
    }

    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            if (KillProcess( &tlist[i], ForceKill )) {
                printf( "process %s (%d) - '%s' killed\n",
                        tlist[i].ProcessName,
                        tlist[i].dwProcessId,
                        tlist[i].hwnd ? tlist[i].WindowTitle : ""
                      );
            } else {
                printf( "process %s (%d) - '%s' could not be killed\n",
                        tlist[i].ProcessName,
                        tlist[i].dwProcessId,
                        tlist[i].hwnd ? tlist[i].WindowTitle : ""
                      );
                rval = 1;
            }
        }
    }

    return rval;
}

VOID
GetCommandLineArgs(
    VOID
    )
{
    char        *lpstrCmd;
    UCHAR       ch;
    DWORD       pid;
    char        pname[MAX_PATH];
    char        *p;

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != ' ' && ch != '\t' && ch != '\0');

    NumberOfArguments = 0;
    while (ch != '\0') {
        //  skip over any following white space
        while (ch != '\0' && isspace(ch)) {
            ch = *lpstrCmd++;
        }
        if (ch == '\0') {
            break;
        }

        //  process each switch character '-' as encountered

        while (ch == '-' || ch == '/') {
            ch = (UCHAR)tolower(*lpstrCmd++);
            //  process multiple switch characters as needed
            do {
                switch (ch) {
                    case 'f':
                        ForceKill = TRUE;
                        ch = *lpstrCmd++;
                        break;

                    case '?':
                        Usage();
                        ch = *lpstrCmd++;
                        break;

                    default:
                        return;
                }
            } while (ch != ' ' && ch != '\t' && ch != '\0');

            while (ch == ' ' || ch == '\t') {
                ch = *lpstrCmd++;
            }
        }

        if (isdigit(ch)) {
            pid = 0;
            while (isdigit(ch)) {
                pid = pid * 10 + ch - '0';
                ch = *lpstrCmd++;
            }
            Arguments[NumberOfArguments].pid = pid;
            Arguments[NumberOfArguments].pname = NULL;
            NumberOfArguments += 1;
        }
        else
        if (ch != '\0') {
            p = pname;
            do {
                *p++ = ch;
                ch = *lpstrCmd++;
            } while (ch != ' ' && ch != '\t' && ch != '\0');
            *p = '\0';
            _strupr( pname );
            Arguments[NumberOfArguments].pid = 0;
            Arguments[NumberOfArguments].pname = malloc(strlen(pname)+1);
            strcpy(Arguments[NumberOfArguments].pname, pname);
            NumberOfArguments += 1;
        }
    }

    return;
}

VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr, "Microsoft (R) Windows NT (TM) Version 3.5 KILL\n" );
    fprintf( stderr, "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved\n\n" );
    fprintf( stderr, "usage: KILL [options] <<pid> | <pattern>>*\n\n" );
    fprintf( stderr, "           [options]:\n" );
    fprintf( stderr, "               -f     Force process kill\n\n" );
    fprintf( stderr, "           <pid>\n" );
    fprintf( stderr, "              This is the process id for the task\n" );
    fprintf( stderr, "               to be killed.  Use TLIST to get a\n" );
    fprintf( stderr, "               valid pid\n\n" );
    fprintf( stderr, "           <pattern>\n" );
    fprintf( stderr, "              The pattern can be a complete task\n" );
    fprintf( stderr, "              name or a regular expression pattern\n" );
    fprintf( stderr, "              to use as a match.  Kill matches the\n" );
    fprintf( stderr, "              supplied pattern against the task names\n" );
    fprintf( stderr, "              and the window titles.\n" );
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\touch\touch.c ===
/* touch.c - make last time on file be current time
 *
 *  touch [files] - requires arg expansion
 */

#include <io.h>
#include <sys\types.h>
#include <sys\utime.h>
#include <sys\stat.h>
#include <time.h>
#include <stdio.h>
#include <process.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

#define year  rgInt[0]
#define month rgInt[1]
#define day   rgInt[2]
#define hour  rgInt[3]
#define mins  rgInt[4]
#define sec   rgInt[5]
int rgInt[6];

void usage( char *Msg, int MsgArg )
{
    printf( "usage: TOUCH [/f] [/t year month day hour min sec] files"
            "\n"
            "where: /f - force file touch if read only\n"
            "       /t - specifies a specific time other than the current time.\n"
            "       /c - specifies to create the file if it does not exist.\n"
          );
    printf( "\nTOUCH: " );
    printf( Msg, MsgArg );
    printf( "\n" );
    exit( 1 );
}

int
__cdecl main (c, v)
int c;
char *v[];
{
    time_t ltime;
    struct utimbuf timenow;
    int i;
    int fh;
    char *p;
    int ReturnCode = 0;
    int force = 0;
    int create= 0;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    if ( c == 0 )
        usage( "invalid number of parameters", 0 );

    time (&ltime);
    while (fSwitChr (*(p = *v))) {
        while (*++p) {
            if (tolower(*p) == 'f')
                force = 1;
            else
            if (tolower(*p) == 'c')
                create = 1;
            else
            if (tolower(*p) == 't') {
                for (i = 0; i < 6; i++) {
                    SHIFT (c, v);
                    if (!c)
                        usage( "incorrect time", 0 );
                    rgInt[i] = atoi (*v);
                    }

                //
                //  do some basic date checking
                //
                if ( (year < 1980) || (month > 12) || (day>31) ||
                     (hour>23) || (mins>59) || (sec>59) ) {
                    usage( "incorrect time", 0 );
                }
                ltime = date2l(year, month, day, hour, mins, sec);
            } else
                usage( "bad switch '%c'", *p );
        }
        SHIFT (c, v);
    }

    timenow.actime = ltime;
    timenow.modtime = ltime;

    while (c) {
        //
        // Set the time
        //

        if (_utime (*v, (void *) &timenow) == -1) {
            //
            // Failed.  Does it exist?
            //
            if (_access(*v, 0) == -1) {
                //
                // Does not exist.  Create if requested and touch created file.
                //
                if (create) {
                    fh = _creat(*v, _S_IREAD|_S_IWRITE);
                    _close(fh);
                    if (_utime (*v, (void *) &timenow) == 0)  // touch it
                        goto shift_it;
                    }
                }
            else
            //
            // File exists, is it read-only and /f specified?
            //
            if (force && (_access(*v,2) == -1)) {
                //
                // Yes, make it read/write and change the time
                // then make it read-only again.
                //
                if (_chmod (*v, _S_IWRITE) == 0) {
                    if (_utime (*v, (void *) &timenow) == 0) {
                        if (_chmod (*v, _S_IREAD) != 0) {
                            printf ("ERROR - changed 'r' attrib on %s, could not change it back\n", *v);
                            ReturnCode = 1;
                            }
                        goto shift_it;
                        }
                    }
                }

            printf ("Can't touch %s - %s\n", *v, error ());
            ReturnCode = 1;
            }
shift_it:
        SHIFT(c,v);
        }
    return ReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\cppexamples\simpleexample\assemblyinfo.cpp ===
#include "stdafx.h"

#using <mscorlib.dll>

using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("")];
[assembly:AssemblyProductAttribute("")];
[assembly:AssemblyCopyrightAttribute("")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("1.0.*")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the project directory.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly:AssemblyDelaySignAttribute(false)];
[assembly:AssemblyKeyFileAttribute("")];
[assembly:AssemblyKeyNameAttribute("")];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tlist\tlist.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tlist.c

Abstract:

    This module implements a task list application.

Author:

    Wesley Witt (wesw) 20-May-1994
    Mike Sartain (mikesart) 28-Oct-1994  Added detailed task information
    Julian Jiggins (julianj) 19-Mar-1998 Added list processes using specific module feature
    Shaun Cox (shaunco) 9-Jul-1998 Display services running in processes

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop
#include <dbghelp.h>
#include "psapi.h"
#include <tchar.h>


#define BAD_PID     ((DWORD)-1)


DWORD       numTasks;
TASK_LIST   tlist[MAX_TASKS];
BOOL        fShowServices;
BOOL        fShowMtsPackages;
BOOL        fShowSessionIds;
BOOL        fShowCommandLines;

const char *Blanks = "                                                                               ";


VOID Usage(VOID);
VOID PrintThreadInfo(PTASK_LIST pTaskList);
BOOL FMatchTaskName(LPTSTR szPN, LPTSTR szWindowTitle, LPTSTR szProcessName);
VOID GetFirstPidWithName(LPTSTR szTask);

VOID
PrintTask(
    DWORD i
    )
{
    BOOL NameShown = FALSE;

    if (fShowSessionIds) {
        printf("%2d ", tlist[i].SessionId);
    }
    
    printf( "%4d %-15s ", tlist[i].dwProcessId, tlist[i].ProcessName );

    if (fShowServices && tlist[i].ServiceNames[0]) {
        printf( "Svcs:  %s", tlist[i].ServiceNames);
        NameShown = TRUE;
    }

    if (fShowMtsPackages && tlist[i].MtsPackageNames[0]) {
        printf( "%sMts:   %s", NameShown ? "  " : "",
                tlist[i].MtsPackageNames);
        NameShown = TRUE;
    }

    if (!NameShown && tlist[i].hwnd) {
        if (fShowServices || fShowMtsPackages) {
            printf( "Title: %s", tlist[i].WindowTitle );
        }
        else {
            printf( "  %s", tlist[i].WindowTitle );
        }
    }

    printf( "\n" );

    if (fShowCommandLines) {
        printf("     Command Line: %s\n", tlist[i].CommandLine);
    }
}

VOID
PrintTaskTree(
    DWORD level,
    DWORD id
    )
{
    DWORD i;

    DetectOrphans( tlist, numTasks );
    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            continue;
        }

        // NOTE: The format of the output below should stay fixed forever.  There are tools
        // at MS that depend on it.

        if (level == 0 || tlist[i].dwInheritedFromProcessId == id) {
            printf( "%.*s", level*2, Blanks );
            printf( "%s (%d)", tlist[i].ProcessName, tlist[i].dwProcessId );
            if (tlist[i].hwnd) {
                printf( " %s", tlist[i].WindowTitle );
            }
            printf( "\n" );
            tlist[i].flags = TRUE;
            if (tlist[i].dwProcessId != 0) {
                PrintTaskTree( level+1, tlist[i].dwProcessId );
            }
        }
    }
}

int __cdecl
main(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Main entrypoint for the TLIST application.  This app prints
    a task list to stdout.  The task list include the process id,
    task name, ant the window title.

Arguments:

    argc             - argument count
    argv             - array of pointers to arguments

Return Value:

    0                - success

--*/

{
    DWORD           i;
    TASK_LIST_ENUM  te;
    BOOL            fTree;
    BOOL            fFindTasksUsingModule;
    BOOL            fPidOnly = FALSE;
    DWORD           cchPN = 0;
    LPSTR           szPN  = NULL;
    DWORD           dwPID = BAD_PID;
    DWORD                           dwNumServices = 0;
    LPENUM_SERVICE_STATUS_PROCESS   pServiceInfo  = NULL;

    if (argc > 1 && (argv[1][0] == '-' || argv[1][0] == '/') && argv[1][1] == '?') {
        Usage();
    }

    fTree = FALSE;
    fFindTasksUsingModule = FALSE;
    if (argc > 1) {
        if ((argv[1][0] == '-' || argv[1][0] == '/') &&
            (argv[1][1] == 't' || argv[1][1] == 'T')) {
            fTree = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 's' || argv[1][1] == 'S')) {
            fShowServices = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'k' || argv[1][1] == 'K')) {
            fShowMtsPackages = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'e' || argv[1][1] == 'E')) {
            fShowSessionIds = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'c' || argv[1][1] == 'C')) {
            fShowCommandLines = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'v' || argv[1][1] == 'V')) {
            fShowServices = TRUE;
            fShowMtsPackages = TRUE;
            fShowSessionIds = TRUE;
            fShowCommandLines = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'p' || argv[1][1] == 'P') && argc == 3) {
            _strlwr(argv[2]);
            if (!strcmp(argv[2], "system process")) {
                printf("0\n");
                return 0;
            }
            fPidOnly = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'p' || argv[1][1] == 'P') && argc == 4) {
            _strlwr(argv[2]);
            if (!strcmp(argv[2], "system")) {
                _strlwr(argv[3]);
                if (!strcmp(argv[3], "process")) {
                    printf("0\n");
                    return 0;
                }
            }
            Usage();
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') &&
                   (argv[1][1] == 'm' || argv[1][1] == 'M') && argc == 3) {
            fFindTasksUsingModule = TRUE;
        } else {
            szPN = argv[1];
            if (!(dwPID = atol(szPN)) && szPN[0] != '0' && szPN[1] != 0) {
                dwPID = BAD_PID;
                cchPN = strlen(szPN);
                _strupr(szPN);
            }
        }
    }

    //
    // lets be god
    //
    EnableDebugPriv();

    //
    // Include 32bit modules in enumeration
    //
    {
        DWORD SymOpt = SymGetOptions();
        SymOpt |= SYMOPT_INCLUDE_32BIT_MODULES;
        SymSetOptions(SYMOPT_INCLUDE_32BIT_MODULES);
    }

    //
    // get the task list for the system
    //
    //
    // Get the process information for all active Win32 services.
    // This allows us to print the service names next to the processes
    // that host them.
    //
    dwNumServices = GetServiceProcessInfo( &pServiceInfo );

    numTasks = GetTaskListEx(
                    tlist,
                    MAX_TASKS,
                    cchPN || (dwPID != BAD_PID),
                    dwNumServices,
                    pServiceInfo);

    free( pServiceInfo );

    if (fShowMtsPackages) {
        AddMtsPackageNames(tlist, numTasks);
    }
            
    if (fShowCommandLines) {
        AddCommandLines(tlist, numTasks);
    }
            
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    //
    // print the task list
    //
    if (fTree) {
        PrintTaskTree( 0, 0 );
    } else if (fFindTasksUsingModule) {
        PrintTasksUsingModule(argv[2]);
    } else if (fPidOnly) {
        GetFirstPidWithName(argv[2]);
    } else {
        for (i=0; i<numTasks; i++) {
            if ((dwPID == BAD_PID) && (!cchPN)) {
                PrintTask( i );
            }
            else
            if ((dwPID == tlist[i].dwProcessId) ||
                (cchPN && FMatchTaskName(szPN, tlist[i].WindowTitle, tlist[i].ProcessName))) {
                    PrintTask( i );
                    PrintThreadInfo(tlist + i);
            }

            if (tlist[i].pThreadInfo) {
                free(tlist[i].pThreadInfo);
            }
        }
    }

    //
    // end of program
    //
    return 0;
}


VOID
GetFirstPidWithName(
    LPTSTR szTask
    )
/*++
Routine Description:

    Returns the PID of the first task with a Name matching the specified
    Name.  IF no task is found -1 is returned
Arguments:

    szTask    - module name to search for

--*/
{
    DWORD i;
    TCHAR szPName[PROCESS_SIZE + 1];
    TCHAR szNameWExe[PROCESS_SIZE + 1] = {0};

    _tcsncat(szNameWExe, szTask, (sizeof(szNameWExe)/sizeof(szNameWExe[0]))-1);
    _tcsncat(szNameWExe, ".exe", (sizeof(szNameWExe)/sizeof(szNameWExe[0]))-_tcslen(szNameWExe)-1);

    for (i=0; i<numTasks; i++) {
        ZeroMemory(szPName, sizeof(szPName));
        _tcsncat(szPName, tlist[i].ProcessName, (sizeof(szPName)/sizeof(szPName[0]))-1);
        _tcslwr(szPName);

        if ((!_tcscmp(szPName, szTask))||(!_tcscmp(szPName, szNameWExe))) {
            if (tlist[i].dwProcessId != 0) {
                printf("%d\n", tlist[i].dwProcessId);
                return;
            }
        }
    }
    printf("-1\n");
}


VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr,
            "Microsoft (R) Windows NT (TM) Version 5.1 TLIST\n"
            VER_LEGALCOPYRIGHT_STR
            "\n\n"
            "usage: TLIST"
            " <<-m <pattern>> | <-t> | <pid> | <pattern> | <-p <processname>>> | <-k> | <-s>\n"
            "           [options]:\n"
            "           -t\n"
            "              Print Task Tree\n\n"
            "           <pid>\n"
            "              List module information for this task.\n\n"
            "           <pattern>\n"
            "              The pattern can be a complete task\n"
            "              name or a regular expression pattern\n"
            "              to use as a match.  Tlist matches the\n"
            "              supplied pattern against the task names\n"
            "              and the window titles.\n\n"
            "           -c\n"
            "              Show command lines for each process\n\n"
            "           -e\n"
            "              Show session IDs for each process\n\n"
            "           -k\n"
            "              Show MTS packages active in each process.\n\n"
            "           -m <pattern>\n"
            "              Lists all tasks that have DLL modules loaded\n"
            "              in them that match the given pattern name\n\n"
            "           -s\n"
            "              Show services active in each process.\n\n"
            "           -p <processname>\n"
            "              Returns the PID of the process specified or -1\n"
            "              if the specified process doesn't exist.  If there\n"
            "              are multiple instances of the process running only\n"
            "              the instance with the first PID value is returned.\n\n"
            "           -v\n"
            "              Show all process information\n\n"
            );
    ExitProcess(0);
}


//
// Routines used to list all processes that have a specific module in use
//

BOOL
FindSpecificModuleCallback(
    LPSTR       Name,
    DWORD_PTR   Base,
    DWORD       Size,
    PVOID       Context
    )

/*++

Routine Description:

    Callback function for module enumeration to find a specific module

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
    PFIND_MODULE_INFO pFindModuleInfo;

    pFindModuleInfo = (PFIND_MODULE_INFO)Context;

    if (MatchPattern(Name, pFindModuleInfo->szModuleToFind))
    {
        pFindModuleInfo->fFound = TRUE;
        strcpy(pFindModuleInfo->szMatchingModuleName, Name);
        return FALSE; // Found Module so stop enumerating
    }

    return TRUE;
}

BOOL
IsTaskUsingModule(
    PTASK_LIST pTask,
    LPTSTR     szModuleName,
    LPTSTR     szMatchingModuleName
    )

/*++

Routine Description:

    Checks if the given task has the given module loaded

Arguments:

    pTaskList   - task to search for module
    szModule    - module name to search for

Return Value:

    TRUE             - if the module is loaded in the task
    FALSE            - if the module is not loaded in the task

--*/

{
    FIND_MODULE_INFO FindModuleInfo;

    FindModuleInfo.fFound = FALSE;
    FindModuleInfo.szModuleToFind = szModuleName;
    FindModuleInfo.szMatchingModuleName = szMatchingModuleName;

    EnumerateLoadedModules(
        (HANDLE) UlongToPtr(pTask->dwProcessId),
        FindSpecificModuleCallback,
        &FindModuleInfo
        );

    return FindModuleInfo.fFound;
}

void
PrintTasksUsingModule(
    LPTSTR szModuleName
    )

/*++

Routine Description:

    Enumerates through all the tasks in the system looking for those that
    have loaded modules of the given name.

Arguments:

    szModule    - module name to search for

Return Value:

    None

--*/

{
    BOOL fUsed = FALSE;
    DWORD i;
    CHAR szMatchingModuleName[64];

    _strupr(szModuleName); // Needed for wildcarding

    for (i=0; i<numTasks; i++) {
        if (IsTaskUsingModule(tlist + i, szModuleName, szMatchingModuleName)) {
            printf("%s - ", szMatchingModuleName);
            PrintTask( i );
            fUsed = TRUE;
        }
    }
    if (!fUsed) {
        printf( "No tasks found using %s\n", szModuleName );
    }
}


BOOL
GetVersionStuff(
    LPTSTR szFileName,
    VS_FIXEDFILEINFO *pvsRet
    )

/*++

Routine Description:

    Get fixedfileinfo for szFileName.

Arguments:

    szFileName       - name of file
    pvsRet           - fixedfileinfo return struct

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    DWORD               dwHandle;
    DWORD               dwLength;
    BOOL                fRet = FALSE;
    LPVOID              lpvData = NULL;

    if (!(dwLength = GetFileVersionInfoSize(szFileName, &dwHandle))) {
        goto err;
    }

    if (lpvData = malloc(dwLength)) {
        if (GetFileVersionInfo(szFileName, 0, dwLength, lpvData)) {

            UINT                uLen;
            VS_FIXEDFILEINFO    *pvs;
            DWORD               *pdwTranslation;
            DWORD               dwDefLang = 0x409;

            if (!VerQueryValue(lpvData, "\\VarFileInfo\\Translation",
                &pdwTranslation, &uLen)) {
                // if we can't get the langid, default to usa
                pdwTranslation = &dwDefLang;
                uLen = sizeof(DWORD);
            }

            if (VerQueryValue(lpvData, "\\", (LPVOID *)&pvs, &uLen)) {
                *pvsRet = *pvs;
                fRet = TRUE;
            }
        }
    }

err:
    if (lpvData)
        free(lpvData);
    return fRet;
}

BOOL
EnumLoadedModulesCallback(
    LPSTR       Name,
    DWORD_PTR   Base,
    DWORD       Size,
    PVOID       Context
    )

/*++

Routine Description:

    Callback function for module enumeration

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
    VS_FIXEDFILEINFO    vs;
    CHAR                szBuffer[100];

    szBuffer[0] = 0;
    if (GetVersionStuff( Name, &vs )) {
        sprintf( szBuffer, "%u.%u.%u.%u %s",
            HIWORD(vs.dwFileVersionMS),
            LOWORD(vs.dwFileVersionMS),
            HIWORD(vs.dwFileVersionLS),
            LOWORD(vs.dwFileVersionLS),
            vs.dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp"
            );
    }
    printf( " %18.18s  0x%p  %s\n", szBuffer, (void *)Base, Name );
    return TRUE;
}

BOOL
PrintModuleList(
    ULONG ProcessId
    )

/*++

Routine Description:

    Prints list of modules in ProcessId

Arguments:

    ProcessID       - process id

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    EnumerateLoadedModules(
        (HANDLE) UlongToPtr(ProcessId),
        EnumLoadedModulesCallback,
        NULL
        );
    return TRUE;
}

DWORD
GetWin32StartAddress(
    HANDLE hThread
    )

/*++

Routine Description:

    Get starting address for thread

Arguments:

    hThread

Return Value:

    Starting Thread address or 0

--*/

{
    NTSTATUS    Status;
    DWORD       ThreadInformation;

    // make sure we have a handle
    if (!hThread)
        return 0;

    // get the threadinfo
    Status = NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress,
        &ThreadInformation, sizeof(ThreadInformation), NULL);
    if (!NT_SUCCESS(Status))
        return 0;

    return ThreadInformation;
}

ULONG
GetLastThreadErr(
    HANDLE hThread
    )

/*++

Routine Description:

    Get Last Error for a Thread

Arguments:

    hThread

Return Value:

    LastError or 0

--*/

{
    TEB                         Teb;
    NTSTATUS                    Status;
    HANDLE                      hProcess;
    ULONG                       LastErrorValue;
    THREAD_BASIC_INFORMATION    ThreadInformation;

    // make sure we have a handle
    if (!hThread)
        return 0;

    // query for basic thread info
    Status = NtQueryInformationThread(hThread, ThreadBasicInformation,
        &ThreadInformation, sizeof(ThreadInformation), NULL);
    if (!NT_SUCCESS(Status))
        return 0;

    // get handle to process
    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
        (DWORD)(DWORD_PTR)ThreadInformation.ClientId.UniqueProcess))) {
        return 0;
    }

    __try {
        // read the TEB from the process and get the last error value
        if (ReadProcessMemory(hProcess,
            ThreadInformation.TebBaseAddress, &Teb, sizeof(TEB), NULL)) {
            LastErrorValue = Teb.LastErrorValue;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    // close the hProcess
    CloseHandle(hProcess);

    return LastErrorValue;
}

BOOL
FPrintPEBInfo(
    HANDLE hProcess
    )

/*++

Routine Description:

    Prints cmdline and cwd of hProcess

Arguments:

    hProcess.

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    PEB                         Peb;
    NTSTATUS                    Status;
    PROCESS_BASIC_INFORMATION   BasicInfo;
    BOOL                        fRet = FALSE;
    WCHAR                       szT[MAX_PATH * 2];
    RTL_USER_PROCESS_PARAMETERS ProcessParameters;

    Status = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
        &BasicInfo, sizeof(BasicInfo), NULL);
    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return fRet;
    }

    __try {
        // get the PEB
        if (ReadProcessMemory(hProcess, BasicInfo.PebBaseAddress, &Peb,
            sizeof(PEB), NULL)) {
            // get the processparameters
            if (ReadProcessMemory(hProcess, Peb.ProcessParameters,
                &ProcessParameters, sizeof(ProcessParameters), NULL)) {
                // get the CWD
                if (ReadProcessMemory(hProcess,
                    ProcessParameters.CurrentDirectory.DosPath.Buffer, szT,
                    sizeof(szT), NULL)) {
                        wprintf(L"   CWD:     %s\n", szT);
                }

                // get cmdline
                if (ReadProcessMemory(hProcess, ProcessParameters.CommandLine.Buffer,
                    szT, sizeof(szT), NULL)) {
                        wprintf(L"   CmdLine: %s\n", szT);
                }

                fRet = TRUE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return fRet;
}


// copied from the win32 API code since we need to run on NT 4 and this is a
// new API to NT 5

HANDLE
TlistOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )

/*++

Routine Description:

    A handle to a thread object may be created using OpenThread.

    Opening a thread creates a handle to the specified thread.
    Associated with the thread handle is a set of access rights that
    may be performed using the thread handle.  The caller specifies the
    desired access to the thread using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the thread object.
        For NT/Win32, this access is checked against any security
        descriptor on the target thread.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        THREAD_TERMINATE - This access is required to terminate the
            thread using TerminateThread.

        THREAD_SUSPEND_RESUME - This access is required to suspend and
            resume the thread using SuspendThread and ResumeThread.

        THREAD_GET_CONTEXT - This access is required to use the
            GetThreadContext API on a thread object.

        THREAD_SET_CONTEXT - This access is required to use the
            SetThreadContext API on a thread object.

        THREAD_SET_INFORMATION - This access is required to set certain
            information in the thread object.

        THREAD_SET_THREAD_TOKEN - This access is required to set the
            thread token using SetTokenInformation.

        THREAD_QUERY_INFORMATION - This access is required to read
            certain information from the thread object.

        SYNCHRONIZE - This access is required to wait on a thread object.

        THREAD_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a thread object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwThreadId - Supplies the thread id of the thread to open.

Return Value:

    NON-NULL - Returns an open handle to the specified thread.  The
        handle may be used by the calling process in any API that
        requires a handle to a thread.  If the open is successful, the
        handle is granted access to the thread object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        return NULL;
        }
}



VOID
PrintThreadInfo(
    PTASK_LIST pTaskList
    )

/*++

Routine Description:

    Prints all kinds of info about a task

Arguments:

    PTASK_LIST of task to print

Return Value:

    None.

--*/

{
    UINT    nThread;
    HANDLE  hProcess;

    // from \\kernel\razzle2\src\ntos\inc\ke.h
    #define MAX_THREADSTATE    (sizeof(szThreadState) / sizeof(TCHAR *))
    static const TCHAR  *szThreadState[] = {
        "Initialized",
        "Ready     ",
        "Running   ",
        "Standby   ",
        "Terminated",
        "Waiting   ",
        "Transition",
        "???       " };

    // get a handle to the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pTaskList->dwProcessId);
    if (!hProcess)
        return;

    // print the CWD and CmdLine
    FPrintPEBInfo(hProcess);

    printf( "   VirtualSize:   %6ld KB"
            "   PeakVirtualSize:   %6ld KB\n",
                pTaskList->VirtualSize / 1024,
                pTaskList->PeakVirtualSize / 1024);

    printf( "   WorkingSetSize:%6ld KB"
            "   PeakWorkingSetSize:%6ld KB\n",
            pTaskList->WorkingSetSize / 1024,
            pTaskList->PeakWorkingSetSize / 1024);

    printf( "   NumberOfThreads: %ld\n",
            pTaskList->NumberOfThreads);

    // if we got any threadinfo, spit it out
    if (pTaskList->pThreadInfo) {
        for (nThread = 0; nThread < pTaskList->NumberOfThreads; nThread++) {

            PTHREAD_INFO pThreadInfo = &pTaskList->pThreadInfo[nThread];
            HANDLE hThread = TlistOpenThread(THREAD_QUERY_INFORMATION, FALSE,
                (DWORD)(DWORD_PTR)pThreadInfo->UniqueThread);

            printf("   %4d Win32StartAddr:0x%08x LastErr:0x%08x State:%s\n",
                HandleToUlong(pThreadInfo->UniqueThread),
                GetWin32StartAddress(hThread),
                GetLastThreadErr(hThread),
                szThreadState[min(pThreadInfo->ThreadState, MAX_THREADSTATE - 1)]);

            if (hThread)
                NtClose(hThread);
        }
    }

    // print the modules
    PrintModuleList( pTaskList->dwProcessId );

    // close the hProcess
    CloseHandle(hProcess);
}

BOOL
FMatchTaskName(
    LPTSTR szPN,
    LPTSTR szWindowTitle,
    LPTSTR szProcessName
    )
{
    LPTSTR  szT;
    TCHAR    szTName[PROCESS_SIZE]= {0};

    _tcsncat( szTName, szProcessName, (sizeof(szTName)/sizeof(szTName[0]))-1 );
    if (szT = _tcschr( szTName, _T('.') ))
        szT[0] = _T('\0');

    if (MatchPattern( szTName, szPN ) ||
        MatchPattern( szProcessName, szPN ) ||
        MatchPattern( szWindowTitle, szPN )) {
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\cppexamples\simpleexample\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// SimpleExample.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\cppexamples\simpleexample\simpleexample.cpp ===
//A Sample program to demonstrate use of managed software tracing

#include "stdafx.h"

#using <mscorlib.dll>
#include <tchar.h>

#using <TraceEvent.dll>
using namespace System;
using namespace Microsoft::Win32::Diagnostics;

int _tmain(void)
{
    
    Guid g("{8C8AC55E-834E-49cb-B993-75B69FBF6D97}");    
    TraceProvider* MyProvider = new TraceProvider (S"SimpleExample App",g);								    
	MyProvider->TraceMessage(1,S"Composite formatting of a string: Hello |{0,30}|",S"World");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\cppexamples\simpleexample\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-buildenv\simpleexample\simpleexample.cs ===
//---------------------------------------------------------------------------
// File: SimpleExample
//
// An example program to demonstrate the use of WinTraceProvider class for
// software tracing in C#
//
// Author: Baskar Sridharan
// Date:   19 June 2002
//---------------------------------------------------------------------------

using System;
using Microsoft.Win32.Diagnostics;
	/// <summary>
	/// Summary description for TraceTest.
	/// </summary>
	/// 

class SimpleExample
    //SimpleExample
{
                 
    //
    // This method shows how to use WinTraceProvider.TraceMessage()
    //

    static void DebugTracingSample()
    {
		//Create an instance of WinTraceProvider and provide the GUID for the executable
		//of which this class will be a part.
        TraceProvider MyProvider = new TraceProvider ("SimpleExample App",new Guid("{8C8AC55E-834E-49cb-B993-75B69FBF6D97}"));								
		
		string frmtstr = "Hello {0}";
		string frmtstr2 = "Arg0 = {0} Arg1 = {1}";
		string frmtstr3 = "Arg0 ={0} Arg1 = {1} Arg2 = {2}";		
		bool bool_v=false;
		byte byte_v=(byte)99;
		sbyte sbyte_v = (sbyte)-114;
		short short_v = (short)-54;
		ushort ushort_v = (ushort)5000;
		int int_v = -654;
		uint uint_v = (uint)12345;
		long long_v = (long)-98765;
		ulong ulong_v = (ulong)1234567;
		string string_v = "MS World!!!!";
		char char_v='G';
		decimal decimal_v=(decimal)200.876543243213D;
		object decimal_obj = decimal_v;
		double double_v=(double)3.00;
		float float_v=2.00F;		
		long tel_no=4254944885;
		
		/** TraceMessages for all the types that are currently supported **/
		MyProvider.TraceMessage((uint)TraceFlags.Info,frmtstr,bool_v);
		MyProvider.TraceMessage((uint)TraceFlags.Info,frmtstr,byte_v);
		MyProvider.TraceMessage(1,frmtstr,sbyte_v);
		MyProvider.TraceMessage(1,frmtstr,short_v);
		MyProvider.TraceMessage(1,frmtstr,ushort_v);
		MyProvider.TraceMessage(1,frmtstr,int_v);
		MyProvider.TraceMessage(1,frmtstr,uint_v);
		MyProvider.TraceMessage(1,frmtstr,long_v);
		MyProvider.TraceMessage(1,frmtstr,ulong_v);
		MyProvider.TraceMessage(1,frmtstr,float_v);
		MyProvider.TraceMessage(1,frmtstr,double_v);
		MyProvider.TraceMessage(1,frmtstr,decimal_v);
		MyProvider.TraceMessage(1,frmtstr,char_v);
		MyProvider.TraceMessage(1,frmtstr,string_v);
		MyProvider.TraceMessage(1,frmtstr2,uint_v,byte_v);
		MyProvider.TraceMessage(1,frmtstr3,decimal_v,float_v,long_v);

		/** Composite  formatting **/
		MyProvider.TraceMessage(1,"Composite formatting of a long {0: (###)###-####}",tel_no);
		MyProvider.TraceMessage(1,"Composite formatting of a string: Hello |{0,30}|",string_v);
		MyProvider.TraceMessage(1,frmtstr3,decimal_v,null,string_v);					
    }
	static void Main(string[] args)
	{              
		
		DebugTracingSample();
		return;
	}
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\simpleexample\simpleexample.cs ===
//---------------------------------------------------------------------------
// File: SimpleExample
//
// An example program to demonstrate the use of WinTraceProvider class for
// software tracing in C#
//
// Author: Baskar Sridharan
// Date:   19 June 2002
//---------------------------------------------------------------------------

using System;
using Microsoft.Win32.Diagnostics;
	/// <summary>
	/// Summary description for TraceTest.
	/// </summary>
	/// 

class SimpleExample
    //SimpleExample
{
                 
    //
    // This method shows how to use WinTraceProvider.TraceMessage()
    //

    static void DebugTracingSample()
    {
		//Create an instance of WinTraceProvider and provide the GUID for the executable
		//of which this class will be a part.
        TraceProvider MyProvider = new TraceProvider ("SimpleExample App",new Guid("{8C8AC55E-834E-49cb-B993-75B69FBF6D97}"));								
		
		string frmtstr = "Hello {0}";
		string frmtstr2 = "Arg0 = {0} Arg1 = {1}";
		string frmtstr3 = "Arg0 ={0} Arg1 = {1} Arg2 = {2}";		
		bool bool_v=false;
		byte byte_v=(byte)99;
		sbyte sbyte_v = (sbyte)-114;
		short short_v = (short)-54;
		ushort ushort_v = (ushort)5000;
		int int_v = -654;
		uint uint_v = (uint)12345;
		long long_v = (long)-98765;
		ulong ulong_v = (ulong)1234567;
		string string_v = "MS World!!!!";
		char char_v='G';
		decimal decimal_v=(decimal)200.876543243213D;
		object decimal_obj = decimal_v;
		double double_v=(double)3.00;
		float float_v=2.00F;		
		long tel_no=4254944885;
		
		/** TraceMessages for all the types that are currently supported **/
		MyProvider.TraceMessage((uint)TraceFlags.Info,frmtstr,bool_v);
		MyProvider.TraceMessage((uint)TraceFlags.Info,frmtstr,byte_v);
		MyProvider.TraceMessage(1,frmtstr,sbyte_v);
		MyProvider.TraceMessage(1,frmtstr,short_v);
		MyProvider.TraceMessage(1,frmtstr,ushort_v);
		MyProvider.TraceMessage(1,frmtstr,int_v);
		MyProvider.TraceMessage(1,frmtstr,uint_v);
		MyProvider.TraceMessage(1,frmtstr,long_v);
		MyProvider.TraceMessage(1,frmtstr,ulong_v);
		MyProvider.TraceMessage(1,frmtstr,float_v);
		MyProvider.TraceMessage(1,frmtstr,double_v);
		MyProvider.TraceMessage(1,frmtstr,decimal_v);
		MyProvider.TraceMessage(1,frmtstr,char_v);
		MyProvider.TraceMessage(1,frmtstr,string_v);
		MyProvider.TraceMessage(1,frmtstr2,uint_v,byte_v);
		MyProvider.TraceMessage(1,frmtstr3,decimal_v,float_v,long_v);

		/** Composite  formatting **/
		MyProvider.TraceMessage(1,"Composite formatting of a long {0: (###)###-####}",tel_no);
		MyProvider.TraceMessage(1,"Composite formatting of a string: Hello |{0,30}|",string_v);
		MyProvider.TraceMessage(1,frmtstr3,decimal_v,null,string_v);					
    }
	static void Main(string[] args)
	{              
		
		DebugTracingSample();
		return;
	}
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\servicecontrollermanager.cs ===
namespace WindowsApplication1
{
	using System;
	using System.Windows.Forms;
	using System.Drawing;
	using System.ServiceProcess;

	/// <summary>
	///    Summary description for ServiceControllerManager.
	/// </summary>
	public class ServiceControllerManager
	{
		//The machine under control
		private string strMachineName;

		//selected service display name
		private string strDisplayName="";

		//The listBoxes used to show Services data
		private ListBox lstSrvRun, lstSrvStopped, lstSrvPaused,lstCurrent=null; 

		/// <summary>
		/// Default empty contructor
		/// </summary>
		public ServiceControllerManager()
		{
			//The default machine name
			strMachineName= System.Environment.MachineName;
		}

		
		// Explicit constructor
		// <param name="tmpSrvRun"> </param>
		//				pointer to the running services listbox
		// <param name="tmpSrvStopped"> </param>
		//				pointer to the stopped services listbox
		// <param name="tmpSrvPaused"> </param>
		//				pointer to the paused services listbox
		// <param name="tmpMachineName"> </param>
		//				the machine name
		public ServiceControllerManager(ListBox tmpSrvRun, ListBox tmpSrvStopped, ListBox tmpSrvPaused,string tmpMachineName)
		{
			strMachineName=tmpMachineName;
		
			//Add the right event handlers for the listboxes

			//Get the pointers to the ListBoxes from the MainForm UI.
			//Assign the correspondant EventHandlers
			lstSrvPaused=tmpSrvPaused;
			lstSrvPaused.SelectedIndexChanged += new System.EventHandler(this.lstSrv_SelectedIndexChanged);
			lstSrvPaused.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);
		
			lstSrvStopped=tmpSrvStopped;
			lstSrvStopped.SelectedIndexChanged += new System.EventHandler(this.lstSrv_SelectedIndexChanged);
			lstSrvStopped.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);
		
			lstSrvRun=tmpSrvRun;
			lstSrvRun.SelectedIndexChanged += new System.EventHandler(this.lstSrv_SelectedIndexChanged);
			lstSrvRun.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);
		
			LoadServices();
			
		
		}

		
		// Clear all the collections, arrays and eventhandlers
		public void Clear() 
		{

			strMachineName="";
			strDisplayName="";
		
			if(lstSrvRun!=null)
			{
				//Clear the items in the list 
				//Remove the event handlers
				lstSrvRun.Items.Clear();
				lstSrvRun.SelectedIndexChanged -= new System.EventHandler(this.lstSrv_SelectedIndexChanged);
				lstSrvRun.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);

			}
			if(lstSrvStopped!=null)
			{
				//Remove the event handlers
				lstSrvStopped.Items.Clear();
				lstSrvStopped.SelectedIndexChanged -= new System.EventHandler(this.lstSrv_SelectedIndexChanged);
				lstSrvStopped.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);
			}
			if(lstSrvPaused!=null)
			{
				lstSrvPaused.Items.Clear();
				lstSrvPaused.SelectedIndexChanged -= new System.EventHandler(this.lstSrv_SelectedIndexChanged);
				lstSrvPaused.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstSrv_MouseDown);
			}

		}
	
		
		// Trap the name of the service selected by the user,
		// as well as the listbox the selected listbox
		public void lstSrv_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			lstCurrent = (ListBox)sender;
		
			strDisplayName=lstCurrent.SelectedItem.ToString();
		}

		
		// PopUp the context menu
		public void lstSrv_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if(e.Button==System.Windows.Forms.MouseButtons.Right )
			{
			
				lstCurrent = (ListBox)sender;
				//Create a new contextMenu
				lstCurrent.ContextMenu=new System.Windows.Forms.ContextMenu();

				//And add the needed MenuItems
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("&Start Service", new EventHandler(this.MenuStart)));
			
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("S&top Service", new EventHandler(this.MenuStop)));

				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("&Pause Service", new EventHandler(this.MenuPause)));

				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("S&how Service Info", new EventHandler(this.ShowServiceInfo)));
			
				//check which menu should be active
				if(lstCurrent.Equals(lstSrvRun) )
				{
					lstCurrent.ContextMenu.MenuItems[0].Enabled=false;
				}
				else if(lstCurrent.Equals(lstSrvStopped ))
				{
					lstCurrent.ContextMenu.MenuItems[1].Enabled=false;
					lstCurrent.ContextMenu.MenuItems[2].Enabled=false;
				}
				else
				{
				
					lstCurrent.ContextMenu.MenuItems[2].Enabled=false;
				}
				

				lstCurrent.ContextMenu.Show(lstCurrent ,new Point(e.X,e.Y));
			}
		}


		private void MenuStart(object sender, EventArgs e)
		{
			System.ServiceProcess.ServiceController tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			try
			{
					
					
				//When a service is paused, it has to continue.
				//Start in this case is not possible.
						
				if(lstCurrent.Equals(lstSrvPaused))
					tmpSC.Continue();
				else
					tmpSC.Start();
					
				
				System.Threading.Thread.Sleep(500);
						
				//Loop while the service is pending the continue state
						

				while(tmpSC.Status== ServiceControllerStatus.ContinuePending )
				{
					Application.DoEvents() ;
				}
						
				//after starting the service, refresh the listBoxes
						
				if(tmpSC.Status==ServiceControllerStatus.Running )
				{
						
					lstSrvRun.Items.Add(lstCurrent.SelectedItem.ToString());
					lstCurrent.Items.Remove (lstCurrent.SelectedItem.ToString());//(lstCurrent.SelectedIndex);
					lstCurrent.Refresh();
					lstSrvRun.Refresh();

				}
							
					//Perhaps it could not start...
							
				else
				{
					MessageBox.Show(tmpSC.ServiceName + " Cannot be started");
				}
			}
			catch
						
				//Do you have enough permissions to start this service ?
						
			{
						
				MessageBox.Show("Service: " + strDisplayName + " Could not be started ! ");
			}
		}

		
		private void MenuStop(object sender, EventArgs e)
		{
			//Stop a service
			System.ServiceProcess.ServiceController tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;	
			try
			{
				if(tmpSC.CanStop)
				{
					try
					{
						tmpSC.Stop();
						System.Threading.Thread.Sleep(500);
						while(tmpSC.Status == ServiceControllerStatus.StopPending)
						{
							Application.DoEvents();
						}
						lstSrvStopped.Items.Add(lstCurrent.SelectedItem.ToString());
						lstCurrent.Items.Remove(lstCurrent.SelectedItem.ToString());
						lstCurrent.Refresh();
						lstSrvStopped.Refresh();
					}
					catch
					{
						MessageBox.Show("Service could not be stopped !");
					}
				}
				else
				{
					MessageBox.Show("The service: " + tmpSC.DisplayName + " is not allowed to be stopped !");
				}
			}
			catch
			{
				MessageBox.Show("Select a service and try again!");
			}
		}

		private void MenuPause(object sender, EventArgs e)
		{
			//Pause a service
			System.ServiceProcess.ServiceController tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;	
			try
			{
				//And refresh the listBoxes
				tmpSC.Pause();
				lstSrvPaused.Items.Add(lstCurrent.SelectedItem.ToString());
				lstCurrent.Items.Remove(lstCurrent.SelectedItem.ToString());
				lstCurrent.Refresh();
				lstSrvPaused.Refresh();
			}
			catch
			{
						
				//or may be not possible to stop the service...
						
				MessageBox.Show("Service: " + strDisplayName + " Could not be paused !");
			}
		}

		// Load all services on the machine
		public void LoadServices() 
		{
	
		
		
			if(!strMachineName.Equals(""))
			{
				ServiceController[]arrSrvCtrl;
		
				try
				{
					//That's enough to get all the services running on the machine
					arrSrvCtrl= ServiceController.GetServices(strMachineName);
			
					//Clear all the collections
					lstSrvRun.Items.Clear();
					lstSrvPaused.Items.Clear();
					lstSrvStopped.Items.Clear();

					//Fill up all the listBoxes
					foreach(ServiceController tmpSC in arrSrvCtrl)
					{
						if(tmpSC.Status==ServiceControllerStatus.Running )
							lstSrvRun.Items.Add (tmpSC.DisplayName );

						else if(tmpSC.Status== ServiceControllerStatus.Paused )
							lstSrvPaused.Items.Add(tmpSC.DisplayName);

						else
							lstSrvStopped.Items.Add(tmpSC.DisplayName);
				
					}
					//Sort them alphabeticaly
					lstSrvPaused.Sorted=lstSrvRun.Sorted=lstSrvStopped.Sorted =true;
			
			
				}
				catch
				{
					MessageBox.Show("Couldn't load the services !");
				}

		
			}
		
		}


		// Show the process info window
		public void ShowServiceInfo(object sender, EventArgs e)
		{
			System.ServiceProcess.ServiceController tmpSC;
			tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			ServiceInfo si = new ServiceInfo(tmpSC);
			si.Show();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\serviceinfo.cs ===
namespace WindowsApplication1
{
	//This Form is only used to show services or drivers properties
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;

    
    //    Summary description for ServiceInfo.
    //	  Show some service's properties
    public class ServiceInfo : System.Windows.Forms.Form
    {
		
		//    Required designer variable
		
		private System.ComponentModel.Container components;
		private System.Windows.Forms.Button btnClose;
		private System.Windows.Forms.ListBox lstInfo;
	
		//Explicit constructor
		public ServiceInfo(System.ServiceProcess.ServiceController tmpServCtrl)
		{
			
			InitializeComponent();
	
			ShowInfo(tmpServCtrl);

		}

		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		

		//    Required method for Designer support - do not modify
		//    the contents of this method with the code editor
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container ();
			this.btnClose = new System.Windows.Forms.Button ();
			this.lstInfo = new System.Windows.Forms.ListBox ();
			//@this.TrayHeight = 0;
			//@this.TrayLargeIcon = false;
			//@this.TrayAutoArrange = true;
			this.Text = "ServiceInfo";
			this.AutoScaleBaseSize = new System.Drawing.Size (5, 13);
			this.ClientSize = new System.Drawing.Size (672, 517);
			btnClose.Location = new System.Drawing.Point (280, 464);
			btnClose.Size = new System.Drawing.Size (112, 24);
			btnClose.TabIndex = 1;
			btnClose.Text = "Close";
			btnClose.Click += new System.EventHandler (this.btnClose_Click);
			lstInfo.Location = new System.Drawing.Point (8, 8);
			lstInfo.Size = new System.Drawing.Size (656, 429);
			lstInfo.Font = new System.Drawing.Font ("Microsoft Sans Serif", 16, System.Drawing.FontStyle.Bold);
			lstInfo.TabIndex = 0;
			this.Controls.Add (this.btnClose);
			this.Controls.Add (this.lstInfo);
		}

		protected void btnClose_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}
		//Get some Service Info
		private void ShowInfo(System.ServiceProcess.ServiceController tmpSrvCtrl)
		{
			try
			{
				lstInfo.Items.Add("ServiceName: " + tmpSrvCtrl.ServiceName);
				lstInfo.Items.Add("Service Status: "+ tmpSrvCtrl.Status.ToString());
				lstInfo.Items.Add("DisplayName: " + tmpSrvCtrl.DisplayName);
				lstInfo.Items.Add("MachineName: " + tmpSrvCtrl.MachineName);
				lstInfo.Items.Add("CanPauseAndContinue: " + tmpSrvCtrl.CanPauseAndContinue.ToString());
				lstInfo.Items.Add("CanShutdown: " + tmpSrvCtrl.CanShutdown.ToString());
				lstInfo.Items.Add("*************** Dependent Services ********************");
				//Check for the Dependent services (if any)
				foreach (System.ServiceProcess.ServiceController s in tmpSrvCtrl.DependentServices )
				{
					lstInfo.Items.Add(s.ServiceName + " is " + s.Status.ToString()  );
				}
			
				
			}
			catch
			{
				MessageBox.Show("Couldn't read Service Info!");
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\drivercontrollermanager.cs ===
namespace WindowsApplication1
{
	using System;
	using System.Windows.Forms;
	using System.Drawing;
	using System.ServiceProcess;

	
	//    Summary description for DriverControllerManager.
	//    This class is used to handle the device drivers 
	public class DriverControllerManager
	{

		//machine under test
		private string strMachineName;
		//The display name of the selected driver
		private string strDisplayName="";
		//the listBoxes used to show the drivers
		private ListBox lstDrvRun, lstDrvStopped, lstDrvPaused,lstCurrent=null; 
		/// <summary>
		/// default (empty) constructor
		/// </summary>
    
		public DriverControllerManager()
		{
		}
		
		// Explicit constructor for this class
		
		// <param name="tmpDrvRun"> </param>
		//			Pointer to the running drivers display
		// <param name="tmpDrvStopped"> </param>
		//			Pointer to stopped drivers display
		// <param name="tmpDrvPaused"> </param>
		//			Pointer to the paused drivers listBox
		// <param name="tmpMachineName"> </param>
		//			Selected machine name
		//			
		public DriverControllerManager(ListBox tmpDrvRun, ListBox tmpDrvStopped, ListBox tmpDrvPaused , string tmpMachineName)
		{
			strMachineName=tmpMachineName;
		
			//Get the pointers to the ListBoxes from the MainForm UI.
			//Assign the correspondant EventHandlers
			lstDrvPaused=tmpDrvPaused;
			lstDrvPaused.SelectedIndexChanged += new System.EventHandler(this.lstDrv_SelectedIndexChanged);
			lstDrvPaused.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);
		
			lstDrvStopped=tmpDrvStopped;
			lstDrvStopped.SelectedIndexChanged += new System.EventHandler(this.lstDrv_SelectedIndexChanged);
			lstDrvStopped.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);
		
			lstDrvRun=tmpDrvRun;
			lstDrvRun.SelectedIndexChanged += new System.EventHandler(this.lstDrv_SelectedIndexChanged);
			lstDrvRun.MouseDown += new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);

			LoadDrivers();
		}

	
		
		// Clear all the object collections
		
		public void Clear()
		{
			strMachineName="";
			strDisplayName="";
			if(lstDrvRun!=null)
			{
				lstDrvRun.Items.Clear();
				lstDrvRun.SelectedIndexChanged -= new System.EventHandler(this.lstDrv_SelectedIndexChanged);
				lstDrvRun.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);
			}
			if(lstDrvStopped!=null)
			{
				lstDrvStopped.Items.Clear();
				lstDrvStopped.SelectedIndexChanged -= new System.EventHandler(this.lstDrv_SelectedIndexChanged);
				lstDrvStopped.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);
			}
			if(lstDrvPaused!=null)
			{
				lstDrvPaused.Items.Clear();
				lstDrvPaused.SelectedIndexChanged -= new System.EventHandler(this.lstDrv_SelectedIndexChanged);
				lstDrvPaused.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.lstDrv_MouseDown);
			}
		}

		
		// event handler for all the ListBoxes
		// Used to catch the name of the selected Driver
		
		public void lstDrv_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			lstCurrent = (ListBox)sender;
			strDisplayName=lstCurrent.SelectedItem.ToString();
		}

		
		// event corresponding to the ListBox/mouseDown
		// Used to PopUp the ContextMenu with its options
		
		public void lstDrv_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if(e.Button==System.Windows.Forms.MouseButtons.Right )
			{
				lstCurrent = (ListBox)sender;
				//Create a new context menu
				lstCurrent.ContextMenu=new System.Windows.Forms.ContextMenu();
				//Insert the needed menuItems
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("&Start Service", new EventHandler(this.MenuStart)));
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("S&top Service", new EventHandler(this.MenuStop)));
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("&Pause Service", new EventHandler(this.MenuPause)));
				lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("S&how Driver Info", new EventHandler(this.ShowDriverInfo)));
				//Enable/Disable the right MenuItems depending on the selected display
				if(lstCurrent.Equals(lstDrvRun) )
				{
					lstCurrent.ContextMenu.MenuItems[0].Enabled=false;
				}
				else if(lstCurrent.Equals(lstDrvStopped ))
				{
					lstCurrent.ContextMenu.MenuItems[1].Enabled=false;
					lstCurrent.ContextMenu.MenuItems[2].Enabled=false;
				}
				else
				{				
					lstCurrent.ContextMenu.MenuItems[2].Enabled=false;
				}				
				lstCurrent.ContextMenu.Show(lstCurrent ,new Point(e.X,e.Y));
			}
		}

	
		//The event assigned to Start driver MenuItem
		private void MenuStart(object sender, EventArgs e)
		{
			
			System.ServiceProcess.ServiceController tmpSC;
			tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			try
			{
					

				if(lstCurrent.Equals(lstDrvPaused))
					tmpSC.Continue();
				else
					tmpSC.Start();
					
				//wait for the process to restart
				System.Threading.Thread.Sleep(500);
				while(tmpSC.Status== ServiceControllerStatus.ContinuePending )
				{
					Application.DoEvents() ;
				}
					
				if(tmpSC.Status==ServiceControllerStatus.Running )
				{
						
					lstDrvRun.Items.Add(lstCurrent.SelectedItem.ToString());
					lstCurrent.Items.Remove(lstCurrent.SelectedItem.ToString());
					lstCurrent.Refresh();
					lstDrvRun.Refresh();

				}
				else
				{
					MessageBox.Show(tmpSC.ServiceName + " Cannot be started");
				}
			}
			catch
				
			{
						
				MessageBox.Show("Service: " + strDisplayName + " Could not be started ! ");
			}
		
		
		
		}

		//Try to stop a service.
		private void MenuStop(object sender, EventArgs e)
		{
		
			System.ServiceProcess.ServiceController tmpSC;
			tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			try
			{
				if(tmpSC.CanStop)
				{
					try
					{
						tmpSC.Stop();
						System.Threading.Thread.Sleep(500);
						//wait for the service to stop
						while(tmpSC.Status == ServiceControllerStatus.StopPending)
						{
							Application.DoEvents();
						}
						lstDrvStopped.Items.Add(lstCurrent.SelectedItem.ToString());
						lstCurrent.Items.Remove(lstCurrent.SelectedItem.ToString());
						lstCurrent.Refresh();
						lstDrvStopped.Refresh();
					}
					catch
					{
						MessageBox.Show("Device driver could not be stopped !");
					}
				}
				else
				{
					MessageBox.Show("The service: " + tmpSC.DisplayName + " is not allowed to be stopped !");
				}
			}
			catch
			{
				MessageBox.Show("Select a device driver and try again!");
			}
		}

		private void MenuPause(object sender, EventArgs e)
		{
			System.ServiceProcess.ServiceController tmpSC;
			tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			
			try
			{

				tmpSC.Pause();
				System.Threading.Thread.Sleep(500);
				//wait for the service to pause
				while(tmpSC.Status == ServiceControllerStatus.PausePending)
				{
					Application.DoEvents();
				}
				lstDrvPaused.Items.Add(lstCurrent.SelectedItem.ToString());
				lstCurrent.Items.Remove(lstCurrent.SelectedIndex);
				lstCurrent.Refresh();
				lstDrvPaused.Refresh();
			}
			catch
			{
				MessageBox.Show("Service: " + strDisplayName + " Could not be paused !");
			}
		}

	//Load all the drivers on the given machine
		public void LoadDrivers() 
		{
	
		
		
			if(!strMachineName.Equals(""))
			{
				ServiceController[]arrDrvCtrl;
		
				try
				{
					//Get an array with all the devices on the machine
					arrDrvCtrl= ServiceController.GetDevices(strMachineName);
					string [] strTmp = new string[arrDrvCtrl.GetUpperBound(0)];
			
			

					for(int iIndex=0;iIndex<arrDrvCtrl.GetUpperBound(0);iIndex++ )
						strTmp[iIndex++]=arrDrvCtrl[iIndex].ServiceName;
			
					//Sort them by name
					System.Array.Sort(strTmp,arrDrvCtrl,0,arrDrvCtrl.GetUpperBound(0));
			
					lstDrvRun.Items.Clear();
					lstDrvPaused.Items.Clear();
					lstDrvStopped.Items.Clear();

					//Check the status for each service/device
					foreach(ServiceController tmpSC in arrDrvCtrl)
					{
						if(tmpSC.Status==ServiceControllerStatus.Running )
						{
					
					
							lstDrvRun.Items.Add (tmpSC.DisplayName );
					
						}
					

					
						else if(tmpSC.Status== ServiceControllerStatus.Paused )
							lstDrvPaused.Items.Add(tmpSC.DisplayName);
						else
							lstDrvStopped.Items.Add(tmpSC.DisplayName);
				
					}
					lstDrvPaused.Sorted=lstDrvRun.Sorted=lstDrvStopped.Sorted =true;
			
			
				}
				catch(Exception ex)
				{
					MessageBox.Show(ex.ToString());
				}

	

			}
		
		}
		//Used to show the device info
		public void ShowDriverInfo(object sender, EventArgs e)
		{
			System.ServiceProcess.ServiceController tmpSC;
			tmpSC=new System.ServiceProcess.ServiceController();
			tmpSC.MachineName=strMachineName;
			tmpSC.DisplayName=strDisplayName;
			ServiceInfo si = new ServiceInfo(tmpSC);
			si.Show();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\perftest\tracegen-dll\timertest1.cs ===
//---------------------------------------------------------------------------
// File: TimerTest.cool
//
// A basic class for inheriting Tests that want to get timing information.
//---------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;

public class TimerTest
{
    public long m_Start;
    public long m_End;
    public long m_Freq;
    long m_Min;
    long m_Max;
    public long m_Count;
    public long m_Sum;

	[DllImport("KERNEL32.DLL", EntryPoint="QueryPerformanceCounter",  SetLastError=true,
		  CharSet=CharSet.Unicode, ExactSpelling=true,
		  CallingConvention=CallingConvention.StdCall)]
    public static extern int QueryPerformanceCounter(ref long time);

	[DllImport("KERNEL32.DLL", EntryPoint="QueryPerformanceFrequency",  SetLastError=true,
		 CharSet=CharSet.Unicode, ExactSpelling=true,
		 CallingConvention=CallingConvention.StdCall)]
	public static extern int QueryPerformanceFrequency(ref long freq);

    public TimerTest()
    { 
        m_Start = m_End = 0; 
        QueryPerformanceFrequency(ref m_Freq);
        m_Min = m_Max = m_Count = m_Sum = 0;
    }

    public void Start()
    {
		long i = 0;
		QueryPerformanceCounter(ref i);
		m_Start = i;
//        m_Start = GetMilliseconds();
        m_End = m_Start;
    }

    public void Stop()
    {
		long i = 0;
		QueryPerformanceCounter(ref i);
		m_End = i;
		m_Sum += (m_End - m_Start);
		m_Count++;
        //m_End = GetMilliseconds();
    }

    public long GetDuration() // in milliseconds.
    {
        return (m_End - m_Start);
    }

    public long GetMilliseconds()
    {
        long i = 0;
        QueryPerformanceCounter(ref i);
        return ((i * (long)1000) / m_Freq);
    }

    // These methods allow you to count up multiple iterations and
    // then get the median, average and percent variation.
    public void Count(long ms)
    {   
        if (m_Min == 0) m_Min = ms;
        if (ms < m_Min) m_Min = ms;
        if (ms > m_Max) m_Max = ms;
        m_Sum += ms;
        m_Count++;
    }

    public long Min()
    {
        return m_Min;
    }

    public long Max()
    {
        return m_Max;
    }

    public double Median()
    {
        return TwoDecimals(m_Min + ((m_Max - m_Min)/2.0));
    }

    public double PercentError()
    {
        double spread = (m_Max - m_Min)/2.0;
        double percent = TwoDecimals((double)(spread*100.0)/(double)(m_Min));
        return percent;
    }

    public double TwoDecimals(double i)
    {
        return Math.Round(i * 100) / 100;
    }

    public long Average()
    {
        return m_Sum / m_Count;
    }

    public void Clear()
    {
        m_Start = m_End = m_Min = m_Max = m_Sum = m_Count = 0;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\processcontrollermanager.cs ===
namespace WindowsApplication1
{
	using System;
	using System.Windows.Forms;
	using System.Drawing;
	using System.ServiceProcess;
	using System.Diagnostics;
	using System.DirectoryServices;
    using Microsoft.Win32.Diagnostics; /* Instrumentation */
	
	//    Summary description for ProcessControllerManager.
	//	This class is used to handle all the processes on a machine
	public class ProcessControllerManager
	{
		private string strMachineName;
		private ListBox lstPcsRun, lstPcs,lstCurrent=null;
		private string strSelectedProcess="";
		private Process pcsSelectedProcess;
		private System.Collections.Hashtable colProcesses=new System.Collections.Hashtable();
		private System.Windows.Forms.Timer tmrWatchDog  = new System.Windows.Forms.Timer();
        private TraceProvider MyTraceProvider = new TraceProvider("ProcessController",new Guid("{C5EBCA17-E93F-4733-865B-DEC4039ADB6D}"));
		public ProcessControllerManager()
		{
			//Default constructor. Don't need any code
            
		}

		//Clear all the collections
		public void Clear()
		{
			strMachineName="";
			if(lstPcsRun!=null)
			{
				lstPcsRun.Items.Clear();
				lstPcsRun.SelectedIndexChanged -=new System.EventHandler(this.SelectedProcess);
				lstPcsRun.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.ListOptions);
			}
		
			if(lstPcs!=null)
			{
				lstPcs.Items.Clear();
				lstPcs.SelectedIndexChanged -= new System.EventHandler(this.SelectedProcess);
				lstPcs.MouseDown -= new System.Windows.Forms.MouseEventHandler(this.ListOptions);
			}

			colProcesses.Clear();

		}
		//Class explicit constructor
		public ProcessControllerManager(ListBox tmpPcsRun, ListBox tmpPcs, string tmpMachineName )
		{
			strMachineName=tmpMachineName;
		
			colProcesses.Clear();
			//Adding the events handlers to the controls
			lstPcs=tmpPcs;
			lstPcs.SelectedIndexChanged += new System.EventHandler(this.SelectedProcess);
			lstPcs.MouseDown += new System.Windows.Forms.MouseEventHandler(this.ListOptions);

			lstPcsRun=tmpPcsRun;
			lstPcsRun.SelectedIndexChanged += new System.EventHandler(this.SelectedProcess);
			lstPcsRun.MouseDown += new System.Windows.Forms.MouseEventHandler(this.ListOptions);


			LoadProcesses();
		

		}

		//Launch the selected process
		public void StartProcess(string strProcName)
		{
		
		
		
			
			Process tmpProcess = new Process();
			tmpProcess.Exited += new EventHandler(this.ProcessExited);
			tmpProcess.EnableRaisingEvents=true;
	
			tmpProcess.StartInfo.FileName=strProcName;
			
			try
			{
				tmpProcess.Start();
				while(! tmpProcess.Responding)System.Windows.Forms.Application.DoEvents();
				LoadProcesses();
			}
			catch
			{
				MessageBox.Show("The Process: " + strSelectedProcess + " cannot start !");
			}
		
		}

		//Add/remove options from the popup menu
		private void ListOptions( object sender, System.Windows.Forms.MouseEventArgs e)
		{
			lstCurrent=(ListBox)sender;
			if(e.Button==System.Windows.Forms.MouseButtons.Right && lstCurrent.Equals(lstPcsRun))
			{
			
				lstCurrent = (ListBox)sender;

				lstCurrent.ContextMenu=new System.Windows.Forms.ContextMenu();
			
				if(lstCurrent.Equals(lstPcs))
				{
				
					strSelectedProcess=lstCurrent.SelectedItem.ToString();
				}
				else
				{
					lstCurrent.ContextMenu.MenuItems.Add(new System.Windows.Forms.MenuItem("&Terminate Process", new EventHandler(this.KillProcess)));

				
				}
			

				lstCurrent.ContextMenu.Show(lstCurrent ,new Point(e.X,e.Y));
			}
		}
		//Try to stop a process
		private void KillProcess( object sender, EventArgs e)
		{
			try
			{
				string strProcName = lstCurrent.SelectedItem.ToString();
			
				if(pcsSelectedProcess!=null)
				{
					try
					{
						//Try to terminate the process
						pcsSelectedProcess.Kill();
						if(colProcesses.Contains(pcsSelectedProcess.Id.ToString()))
						{
							colProcesses.Remove(pcsSelectedProcess.Id.ToString());
							lstPcsRun.Items.Remove (pcsSelectedProcess.ProcessName + "  ID: " + pcsSelectedProcess.Id.ToString());
						}
					
					
					}
					catch
					{
						MessageBox.Show(pcsSelectedProcess.ProcessName + " can not be killed");
					}
				}
				lstPcs.Items.Clear();
			}
			catch
			{
				MessageBox.Show("Select a process first!") ;//no listItem was selected
			}
		}
		//Fills up the Process Info list
		private void ShowProcessInfo( object sender, EventArgs e)
		{
			string strItem = lstCurrent.SelectedItem.ToString();
			string strKey = strItem.Substring(strItem.IndexOf("ID:")+3).Trim();
		
			Process tmpProcess=null;
			if(strKey !="" )
			{
				try
				{
					tmpProcess= Process.GetProcessById(Int32.Parse (strKey),strMachineName);
				}
				catch
				{
				
					Process[] arrProcess=Process.GetProcesses(strMachineName);
					foreach(Process tmpP in arrProcess)
					{
						if(tmpP.Id==Int32.Parse(strKey))
						{
							tmpProcess=tmpP;
							break;
						}
					}
				}
			
				lstPcs.Items.Clear();
				//Adding the Process info to the list
				try
				{

				
					lstPcs.Items.Add("Process Name: " + tmpProcess.ProcessName );

					lstPcs.Items.Add("Arguments: " + tmpProcess.StartInfo.Arguments);

					lstPcs.Items.Add("Running on: " + tmpProcess.MachineName);
					try
					{
						lstPcs.Items.Add("Main Window title: " + tmpProcess.MainWindowTitle);
					}
					catch
					{
						lstPcs.Items.Add("Main Window title: Not Available");
					}

					lstPcs.Items.Add("Start Time: " + tmpProcess.StartTime.ToString());
				
					lstPcs.Items.Add("NonpagedSystemMemorySize: " + tmpProcess.NonpagedSystemMemorySize.ToString());
					lstPcs.Items.Add("PagedMemorySize: " + tmpProcess.PagedMemorySize.ToString());
					lstPcs.Items.Add("PrivateMemorySize: " + tmpProcess.PrivateMemorySize.ToString());
					lstPcs.Items.Add("PrivilegedProcessorTime: " + tmpProcess.PrivilegedProcessorTime.ToString());
					lstPcs.Items.Add("PeakPagedMemorySize: " + tmpProcess.PeakPagedMemorySize.ToString());
					lstPcs.Items.Add("PeakVirtualMemorySize: " + tmpProcess.PeakVirtualMemorySize.ToString());
					lstPcs.Items.Add("PeakPagedMemorySize: " + tmpProcess.PeakPagedMemorySize.ToString());
					lstPcs.Items.Add("PeakWorkingSet: " + tmpProcess.PeakWorkingSet.ToString());

					try
					{
						lstPcs.Items.Add("PriorityClass: " + tmpProcess.PriorityClass.ToString());
					}
					catch
					{
						lstPcs.Items.Add("PriorityClass: Not available" );
					}
					try
					{
						lstPcs.Items.Add("BasePriority: "+ tmpProcess.BasePriority.ToString());
					}
					catch
					{
						lstPcs.Items.Add("BasePriority: Not available" );
					}


					try
					{
						lstPcs.Items.Add("ProcessorAffinity: " + tmpProcess.ProcessorAffinity.ToString());
					}
					catch
					{
						lstPcs.Items.Add("ProcessorAffinity: Not available");
					}
					lstPcs.Items.Add("ID: " + tmpProcess.Id);

					lstPcs.Items.Add("WorkingDirectory: " + tmpProcess.StartInfo.WorkingDirectory);
					lstPcs.Items.Add("");
					lstPcs.Items.Add("********************* Modules in use by this process ***************** ");
					lstPcs.Items.Add("");
					foreach(System.Diagnostics.ProcessModule tmpPM in tmpProcess.Modules)
					{
						try
						{
							lstPcs.Items.Add("Module Name: " + tmpPM.FileName );
						}
						catch
						{
							lstPcs.Items.Add("Modules Reading Not Allowed");
						}
					}
				}
				catch
				{
					MessageBox.Show("Some process properties couldn't be loaded!");//Some did not work
				}
			}
		}
		//Remove the process from the processes list
		private void ProcessExited(object sender, EventArgs e)
		{	
			Process tmpProcess = (Process)sender;
			colProcesses.Remove(tmpProcess.Id.ToString());
			lstPcsRun.Items.Remove(tmpProcess.ProcessName + "  ID: " + tmpProcess.Id.ToString());
		}

		//Check the selected process
		private void SelectedProcess(object sender, EventArgs e)
		{
			lstCurrent=(ListBox)sender;
			strSelectedProcess=lstCurrent.SelectedItem.ToString();
			if(lstCurrent.Equals(lstPcsRun))
			{
				string pcsID = lstCurrent.SelectedItem.ToString();
				pcsID= pcsID.Substring(pcsID.IndexOf("ID: ")+4).Trim();
				pcsSelectedProcess=(Process)colProcesses[pcsID];
				ShowProcessInfo(sender,e);
			}

		}

		//Load all the processes on the given machine
		private void LoadProcesses()
		{

			tmrWatchDog.Enabled=false;
			lstPcsRun.Items.Clear();
			colProcesses.Clear();
			colProcesses=new System.Collections.Hashtable();
			try
			{
				//Use the Static: GetProcesses to have the array of currently running processes.
				Process[]arrProcess=Process.GetProcesses(strMachineName);
				foreach(Process tmpPcs in arrProcess)
				{
					//Assign ProcessExited event to each process in the list
					tmpPcs.Exited += new EventHandler(ProcessExited);
					if(!colProcesses.Contains(tmpPcs.Id.ToString()) )
					{
                        MyTraceProvider.TraceMessage((uint)TraceFlags.Info, "[{0}]Loading process {1} ID: {2}", strMachineName, tmpPcs.ProcessName, tmpPcs.Id.ToString()); /* Instrumentation */
						lstPcsRun.Items.Add(tmpPcs.ProcessName + "  ID: " + tmpPcs.Id.ToString());
						colProcesses.Add(tmpPcs.Id.ToString(),tmpPcs);
					}
				}
			}
			catch
			{
				MessageBox.Show("Cannot read processes on: " + strMachineName );
			}
			//Enable the RaisingEvents for each process
			foreach(Process tmpPcs in colProcesses.Values)
			{
				try
				{
					tmpPcs.EnableRaisingEvents=true;
				}
				catch
				{
					Console.WriteLine("Couldn't Set Option");
				}
			}
			tmrWatchDog.Enabled=true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\examples-nonbuildenv\processcontroller\mainform.cs ===
namespace WindowsApplication1
{
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Data;

    /// <summary>
    ///    Summary description for MainForm.
    /// </summary>
	public class MainForm : System.Windows.Forms.Form
	{
	
		/// <summary>
		///    Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components=null;
    
    
    
		//The "Start a Process" button
		private System.Windows.Forms.Button btnProcess;

		//used to select and start a process
		private System.Windows.Forms.OpenFileDialog openFile;
    
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.Label label8;

		//Processes info listBox
		private System.Windows.Forms.ListBox lstPcs;
		//Running processes listBox
		private System.Windows.Forms.ListBox lstPcsRun;

		//Paused drivers listBox
		private System.Windows.Forms.ListBox lstDrvPaused;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label5;

		//Stopped drivers list
		private System.Windows.Forms.ListBox lstDrvStopped;
		//Running drivers list
		private System.Windows.Forms.ListBox lstDrvRun;
		//Close app. button
		private System.Windows.Forms.Button cmdClose;
    
		//Load data button
		private System.Windows.Forms.Button cmdLoadData;
		private System.Windows.Forms.TextBox txtMachineName;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label3;

		//Stopped services button
		private System.Windows.Forms.ListBox lstSrvStopped;
		private System.Windows.Forms.Label label2;
		//Paused services List
		private System.Windows.Forms.ListBox lstSrvPaused;
		private System.Windows.Forms.Label label1;

		//Running services list
		private System.Windows.Forms.ListBox lstSrvRun;
		private System.Windows.Forms.TabPage tabProcess;
		private System.Windows.Forms.TabPage tabDrivers;
		private System.Windows.Forms.TabPage tabServices;
		private System.Windows.Forms.TabControl tabControl1;
    
		//User classes :

		// ServiceControllerManager is in charge of the System Services management using the ServiceController component
		private ServiceControllerManager objSrvCtrlMgr=new ServiceControllerManager();	
		//DriverControllerManager manage the System drivers via the ServiceController component
		private DriverControllerManager objDrvCtrlMgr = new DriverControllerManager();
		//ProcessControllerManager is destined to the control of the system Processes via the Process component
		private ProcessControllerManager objPcsCrtlMgr = new ProcessControllerManager();
	

        public MainForm()
        {
            InitializeComponent();
            
        }

        /// <summary>
        ///    Clean up any resources being used.
        /// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
        /// <summary>
        ///    Required method for Designer support - do not modify
        ///    the contents of this method with the code editor.
        /// </summary>
		private void InitializeComponent()
		{
			this.label8 = new System.Windows.Forms.Label();
			this.label9 = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.label5 = new System.Windows.Forms.Label();
			this.label6 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.tabDrivers = new System.Windows.Forms.TabPage();
			this.lstDrvPaused = new System.Windows.Forms.ListBox();
			this.lstDrvStopped = new System.Windows.Forms.ListBox();
			this.lstDrvRun = new System.Windows.Forms.ListBox();
			this.lstSrvStopped = new System.Windows.Forms.ListBox();
			this.lstSrvPaused = new System.Windows.Forms.ListBox();
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabServices = new System.Windows.Forms.TabPage();
			this.lstSrvRun = new System.Windows.Forms.ListBox();
			this.tabProcess = new System.Windows.Forms.TabPage();
			this.lstPcs = new System.Windows.Forms.ListBox();
			this.lstPcsRun = new System.Windows.Forms.ListBox();
			this.cmdLoadData = new System.Windows.Forms.Button();
			this.openFile = new System.Windows.Forms.OpenFileDialog();
			this.cmdClose = new System.Windows.Forms.Button();
			this.btnProcess = new System.Windows.Forms.Button();
			this.txtMachineName = new System.Windows.Forms.TextBox();
			this.tabDrivers.SuspendLayout();
			this.tabControl1.SuspendLayout();
			this.tabServices.SuspendLayout();
			this.tabProcess.SuspendLayout();
			this.SuspendLayout();
			// 
			// label8
			// 
			this.label8.Location = new System.Drawing.Point(24, 8);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(128, 16);
			this.label8.TabIndex = 2;
			this.label8.Text = "Running Process";
			// 
			// label9
			// 
			this.label9.Location = new System.Drawing.Point(264, 8);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(128, 16);
			this.label9.TabIndex = 3;
			this.label9.Text = "Process Properties";
			// 
			// label4
			// 
			this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label4.Location = new System.Drawing.Point(8, 416);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(136, 16);
			this.label4.TabIndex = 1;
			this.label4.Text = "Machine Name";
			// 
			// label5
			// 
			this.label5.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label5.Location = new System.Drawing.Point(16, 128);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(152, 16);
			this.label5.TabIndex = 2;
			this.label5.Text = "Stopped Drivers";
			// 
			// label6
			// 
			this.label6.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label6.Location = new System.Drawing.Point(16, 6);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(144, 16);
			this.label6.TabIndex = 3;
			this.label6.Text = "Running Drivers";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label7.Location = new System.Drawing.Point(16, 256);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(152, 16);
			this.label7.TabIndex = 4;
			this.label7.Text = "Paused Drivers";
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label1.Location = new System.Drawing.Point(24, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(224, 16);
			this.label1.TabIndex = 1;
			this.label1.Text = "Running Services";
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label2.Location = new System.Drawing.Point(20, 241);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(232, 16);
			this.label2.TabIndex = 3;
			this.label2.Text = "Paused Services";
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.label3.Location = new System.Drawing.Point(21, 128);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(177, 16);
			this.label3.TabIndex = 5;
			this.label3.Text = "Stopped Services";
			// 
			// tabDrivers
			// 
			this.tabDrivers.Controls.AddRange(new System.Windows.Forms.Control[] {
																					 this.lstDrvPaused,
																					 this.label7,
																					 this.label6,
																					 this.label5,
																					 this.lstDrvStopped,
																					 this.lstDrvRun});
			this.tabDrivers.Location = new System.Drawing.Point(4, 22);
			this.tabDrivers.Name = "tabDrivers";
			this.tabDrivers.Size = new System.Drawing.Size(453, 373);
			this.tabDrivers.TabIndex = 1;
			this.tabDrivers.Text = "Drivers";
			// 
			// lstDrvPaused
			// 
			this.lstDrvPaused.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.lstDrvPaused.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstDrvPaused.Location = new System.Drawing.Point(16, 280);
			this.lstDrvPaused.Name = "lstDrvPaused";
			this.lstDrvPaused.Size = new System.Drawing.Size(424, 82);
			this.lstDrvPaused.TabIndex = 5;
			// 
			// lstDrvStopped
			// 
			this.lstDrvStopped.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.lstDrvStopped.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstDrvStopped.Location = new System.Drawing.Point(16, 152);
			this.lstDrvStopped.Name = "lstDrvStopped";
			this.lstDrvStopped.Size = new System.Drawing.Size(424, 95);
			this.lstDrvStopped.TabIndex = 1;
			// 
			// lstDrvRun
			// 
			this.lstDrvRun.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.lstDrvRun.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstDrvRun.Location = new System.Drawing.Point(16, 26);
			this.lstDrvRun.Name = "lstDrvRun";
			this.lstDrvRun.Size = new System.Drawing.Size(424, 95);
			this.lstDrvRun.TabIndex = 0;
			// 
			// lstSrvStopped
			// 
			this.lstSrvStopped.Anchor = System.Windows.Forms.AnchorStyles.None;
			this.lstSrvStopped.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstSrvStopped.Location = new System.Drawing.Point(18, 152);
			this.lstSrvStopped.Name = "lstSrvStopped";
			this.lstSrvStopped.Size = new System.Drawing.Size(416, 82);
			this.lstSrvStopped.TabIndex = 4;
			// 
			// lstSrvPaused
			// 
			this.lstSrvPaused.Anchor = System.Windows.Forms.AnchorStyles.None;
			this.lstSrvPaused.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstSrvPaused.Location = new System.Drawing.Point(16, 272);
			this.lstSrvPaused.Name = "lstSrvPaused";
			this.lstSrvPaused.Size = new System.Drawing.Size(416, 95);
			this.lstSrvPaused.TabIndex = 2;
			// 
			// tabControl1
			// 
			this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabServices,
																					  this.tabDrivers,
																					  this.tabProcess});
			this.tabControl1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.tabControl1.Location = new System.Drawing.Point(0, 9);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(461, 399);
			this.tabControl1.TabIndex = 0;
			this.tabControl1.Text = "tabControl1";
			// 
			// tabServices
			// 
			this.tabServices.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.label3,
																					  this.lstSrvStopped,
																					  this.label2,
																					  this.lstSrvPaused,
																					  this.label1,
																					  this.lstSrvRun});
			this.tabServices.Location = new System.Drawing.Point(4, 22);
			this.tabServices.Name = "tabServices";
			this.tabServices.Size = new System.Drawing.Size(453, 373);
			this.tabServices.TabIndex = 0;
			this.tabServices.Text = "Services";
			// 
			// lstSrvRun
			// 
			this.lstSrvRun.Anchor = System.Windows.Forms.AnchorStyles.None;
			this.lstSrvRun.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstSrvRun.Location = new System.Drawing.Point(24, 40);
			this.lstSrvRun.Name = "lstSrvRun";
			this.lstSrvRun.Size = new System.Drawing.Size(416, 82);
			this.lstSrvRun.TabIndex = 0;
			// 
			// tabProcess
			// 
			this.tabProcess.Controls.AddRange(new System.Windows.Forms.Control[] {
																					 this.label9,
																					 this.label8,
																					 this.lstPcs,
																					 this.lstPcsRun});
			this.tabProcess.Location = new System.Drawing.Point(4, 22);
			this.tabProcess.Name = "tabProcess";
			this.tabProcess.Size = new System.Drawing.Size(453, 373);
			this.tabProcess.TabIndex = 2;
			this.tabProcess.Text = "Process";
			// 
			// lstPcs
			// 
			this.lstPcs.Anchor = System.Windows.Forms.AnchorStyles.None;
			this.lstPcs.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstPcs.Location = new System.Drawing.Point(224, 36);
			this.lstPcs.MultiColumn = true;
			this.lstPcs.Name = "lstPcs";
			this.lstPcs.ScrollAlwaysVisible = true;
			this.lstPcs.Size = new System.Drawing.Size(224, 329);
			this.lstPcs.TabIndex = 1;
			// 
			// lstPcsRun
			// 
			this.lstPcsRun.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.lstPcsRun.Location = new System.Drawing.Point(8, 36);
			this.lstPcsRun.Name = "lstPcsRun";
			this.lstPcsRun.Size = new System.Drawing.Size(200, 329);
			this.lstPcsRun.Sorted = true;
			this.lstPcsRun.TabIndex = 0;
			// 
			// cmdLoadData
			// 
			this.cmdLoadData.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.cmdLoadData.Location = new System.Drawing.Point(16, 448);
			this.cmdLoadData.Name = "cmdLoadData";
			this.cmdLoadData.Size = new System.Drawing.Size(120, 24);
			this.cmdLoadData.TabIndex = 3;
			this.cmdLoadData.Text = "&Load Data";
			this.cmdLoadData.Click += new System.EventHandler(this.cmdLoadData_Click);
			// 
			// openFile
			// 
			this.openFile.FileOk += new System.ComponentModel.CancelEventHandler(this.openFile_FileOk);
			// 
			// cmdClose
			// 
			this.cmdClose.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.cmdClose.Location = new System.Drawing.Point(296, 448);
			this.cmdClose.Name = "cmdClose";
			this.cmdClose.Size = new System.Drawing.Size(136, 24);
			this.cmdClose.TabIndex = 4;
			this.cmdClose.Text = "&Close Application";
			this.cmdClose.Click += new System.EventHandler(this.cmdClose_Click);
			// 
			// btnProcess
			// 
			this.btnProcess.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.btnProcess.Location = new System.Drawing.Point(152, 448);
			this.btnProcess.Name = "btnProcess";
			this.btnProcess.Size = new System.Drawing.Size(128, 24);
			this.btnProcess.TabIndex = 5;
			this.btnProcess.Text = "&Start a Process";
			this.btnProcess.Click += new System.EventHandler(this.btnProcess_Click);
			// 
			// txtMachineName
			// 
			this.txtMachineName.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
			this.txtMachineName.Location = new System.Drawing.Point(152, 416);
			this.txtMachineName.Name = "txtMachineName";
			this.txtMachineName.Size = new System.Drawing.Size(280, 20);
			this.txtMachineName.TabIndex = 2;
			this.txtMachineName.Text = "";
			// 
			// MainForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(464, 485);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.btnProcess,
																		  this.cmdClose,
																		  this.cmdLoadData,
																		  this.txtMachineName,
																		  this.label4,
																		  this.tabControl1});
			this.Name = "MainForm";
			this.Text = "Process Controller";
			this.tabDrivers.ResumeLayout(false);
			this.tabControl1.ResumeLayout(false);
			this.tabServices.ResumeLayout(false);
			this.tabProcess.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		// The event assigned to the openFile control.
		protected void openFile_FileOk(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(objPcsCrtlMgr!=null)
			{
				try
				{
					//try to start a new process using the Process component
					objPcsCrtlMgr.StartProcess(openFile.FileName);
				}
				catch
				{
					//Its possible since one might not have the permission to start a process on a certain machine
					MessageBox.Show("The process: " + openFile.FileName + " cannot be started !");
				}
			}
		}

		// launches the OpenFile dialog
		protected void btnProcess_Click(object sender, System.EventArgs e)
		{
			
			openFile.ShowDialog();
		}

		
		// Exit the App
		protected void cmdClose_Click(object sender, System.EventArgs e)
		{
			//Make the Window "Fade away"
			for(double d=1.0d; d> 0d; d-=0.2d)
			{
				System.Threading.Thread.Sleep(50);
				Application.DoEvents();
				this.Opacity=d;
				this.Refresh();
			}
			Environment.Exit(0);
		}
 
		// Call the method that fills up the services, drivers and processes
		protected void cmdLoadData_Click(object sender, System.EventArgs e)
		{
			btnProcess.Enabled=true;
			LoadData();
		}

		
		//  Loading all services, Drivers and Processes running on the selected machine
		public void LoadData()
		{
		
			string tmpMachineName= GetMachineName();
			
			
			//clear up the serviceManager 
			if(objSrvCtrlMgr!=null)
				objSrvCtrlMgr.Clear();
			objSrvCtrlMgr=null;
			objSrvCtrlMgr=new ServiceControllerManager(lstSrvRun,lstSrvStopped,lstSrvPaused,tmpMachineName);
			//Clear up the driver manager
			if(objDrvCtrlMgr!=null)
				objDrvCtrlMgr.Clear();
			objDrvCtrlMgr=null;
			objDrvCtrlMgr=new DriverControllerManager(lstDrvRun,lstDrvStopped,lstDrvPaused,tmpMachineName);
			//Clear the process manager
			if(objPcsCrtlMgr!=null)
				objPcsCrtlMgr.Clear();
			objPcsCrtlMgr=null;			
			objPcsCrtlMgr=new ProcessControllerManager(lstPcsRun,lstPcs,tmpMachineName);

		}
		// returns the name of the local machine
		public string GetLocalMachine()
		{
			return System.Environment.MachineName;			
		}

		// check wheter the selected machine exists in the Domain
		// you might want to change this to more complex code for machine name check
		public string GetMachineName()
		{
			if(txtMachineName.Text.Equals(""))
				
				//machineName field is empty, take the local machine	
			{
				txtMachineName.Text=GetLocalMachine();
				txtMachineName.Focus();
			
			}
			return txtMachineName.Text;
		}
		//Application main entry point
        [STAThread]
        public static void Main(string[] args) 
        {
            Application.Run(new MainForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\evntrprv.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
    
\*****************************************************************************/

#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR              1024
#define MAXIMUM_LOGGERS     64  // should be in sync with wmiumkm.h

#define PROVIDER_NAME_EVENTTRACE L"TraceLogger"

#define DECODE_MODE_WBEM_TO_TRACE    1
#define DECODE_MODE_TRACE_TO_WBEM    2

#define VALUETYPE_INDEX              1
#define VALUETYPE_FLAG               2

#define G_ALLOC( s )  HeapAlloc( GetProcessHeap(), 0, s )
#define G_FREE( s )   if( s != NULL ) { HeapFree( GetProcessHeap(), 0, s ); }

extern GUID gHeapGuid;
extern GUID gCritSecGuid;

ULONG EtsGetMaxEnableFlags();
HRESULT
EtsSetExtendedFlags(
    SAFEARRAY *saFlags,
    PEVENT_TRACE_PROPERTIES pLoggerInfo,
    ULONG offset
    );


class CEventTrace : public Provider 
{
public:
	CEventTrace(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
	virtual ~CEventTrace();

protected:
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

	virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

	virtual HRESULT ExecMethod( const CInstance& Instance,
				            const BSTR bstrMethodName,
				            CInstance *pInParams,
				            CInstance *pOutParams,
				            long lFlags = 0L 
                        );

    HRESULT LoadPropertyValues( 
                CInstance *pInstance, 
                PEVENT_TRACE_PROPERTIES pLoggerInfo,    
                PTRACE_GUID_PROPERTIES  *GuidPropertiesArray,
                ULONG nGuidCount
            );

    HRESULT LoadGuidArray( 
                PVOID* Storage, 
                PULONG pnGuidCount 
            );

private:
    HRESULT WmiFlushTrace( const CInstance &Instance );
    HRESULT WmiStopTrace( const CInstance &Instance );
    HRESULT WmiEnableTrace( const CInstance &Instance, bool bEnable, SAFEARRAY *saFlags, SAFEARRAY *saLevel, SAFEARRAY *saGuid, TRACEHANDLE LoggerHandle );

    HRESULT StartGlobalLogger( IN PEVENT_TRACE_PROPERTIES LoggerInfo );
    HRESULT DeleteGlobalLogger( IN PEVENT_TRACE_PROPERTIES LoggerInfo );
    
    HRESULT InitTraceProperties( PEVENT_TRACE_PROPERTIES* ppLoggerInfo );
    
    HRESULT DecodePropertyValue(
                CInstance*  pInstance, 
                LPCWSTR     szProperty,
                DWORD*      pdwValue,
                DWORD       dwFlags );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\glogger.cpp ===
/*****************************************************************************\

    Author: Insung Park (insungp)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <wmiguid.h>
#include <ntwmi.h>
#include <ntperf.h>
#include <fwcommon.h>

LPCWSTR cszGlobalLoggerKey = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\WMI\\GlobalLogger";
LPCWSTR cszStartValue = L"Start";
LPCWSTR cszBufferSizeValue = L"BufferSize";
LPCWSTR cszMaximumBufferValue = L"MaximumBuffers";
LPCWSTR cszMinimumBufferValue = L"MinimumBuffers";
LPCWSTR cszFlushTimerValue = L"FlushTimer";
LPCWSTR cszFileNameValue = L"FileName";
LPCWSTR cszEnableKernelValue = L"EnableKernelFlags";
LPCWSTR cszClockTypeValue = L"ClockType";

GUID gHeapGuid = HeapGuid;
GUID gCritSecGuid = CritSecGuid;

HRESULT
SetGlobalLoggerSettings(
    DWORD StartValue,
    PEVENT_TRACE_PROPERTIES LoggerInfo,
    DWORD ClockType
)
/*++

Since it is a standalone utility, there is no need for extensive comments. 

Routine Description:

    Depending on the value given in "StartValue", it sets or resets event
    trace registry. If the StartValue is 0 (Global logger off), it deletes
    all the keys (that the user may have set previsouly).
    
    Users are allowed to set or reset individual keys using this function,
    but only when "-start GlobalLogger" is used.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    StartValue - The "Start" value to be set in the registry.
                    0: Global logger off
                    1: Global logger on
    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are used to set registry keys.

    ClockType - The type of the clock to be set. Use pLoggerInfo->Wnode.ClientContext

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    DWORD  dwValue;
    NTSTATUS status;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey, UnicodeString;
    ULONG Disposition, TitleIndex;

    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );

    // instead of opening, create a new key because it may not exist.
    // if one exists already, that handle will be passed.
    // if none exists, it will create one.
    status = NtCreateKey(&KeyHandle,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &ObjectAttributes,
                         0L,    // not used within this call anyway.
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &Disposition);
    RtlFreeUnicodeString(&UnicodeLoggerKey);

    if(!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    TitleIndex = 0L;


    if (StartValue == 1) { // ACTION_START: set filename only when it is given by a user.
        // setting BufferSize
        if (LoggerInfo->BufferSize > 0) {
            dwValue = LoggerInfo->BufferSize;
            RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MaximumBuffers
        if (LoggerInfo->MaximumBuffers > 0) {
            dwValue = LoggerInfo->MaximumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MinimumBuffers 
        if (LoggerInfo->MinimumBuffers > 0) {
            dwValue = LoggerInfo->MinimumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting FlushTimer
        if (LoggerInfo->FlushTimer > 0) {
            dwValue = LoggerInfo->FlushTimer;
            RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting EnableFlags
        if (LoggerInfo->EnableFlags > 0) {
            dwValue = LoggerInfo->EnableFlags;
            RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }

        dwValue = 0;
        if (LoggerInfo->LogFileNameOffset > 0) {
            UNICODE_STRING UnicodeFileName;
            RtlInitUnicodeString((&UnicodeFileName), (PWCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo));
            RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_SZ,
                        UnicodeFileName.Buffer,
                        UnicodeFileName.Length + sizeof(UNICODE_NULL)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            RtlFreeUnicodeString(&UnicodeFileName);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
    }
    else { // if ACTION_STOP then delete the keys that users might have set previously.
        // delete buffer size
        RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete maximum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete minimum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete flush timer
        RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete enable falg
        RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete filename
        RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
    }

    // setting ClockType
    if (ClockType > 0) {
        dwValue = ClockType;
        RtlInitUnicodeString((&UnicodeString),(cszClockTypeValue));
        status = NtSetValueKey(
                    KeyHandle,
                    &UnicodeString,
                    TitleIndex,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue)
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status)) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        TitleIndex++;
    }

     // Setting StartValue
    dwValue = StartValue;
    RtlInitUnicodeString((&UnicodeString),(cszStartValue));
    status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                TitleIndex,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue)
                );
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(status)) {
        NtClose(KeyHandle);
        return RtlNtStatusToDosError(status);
    }
    TitleIndex++;

    NtClose(KeyHandle);
    return 0;
}

ULONG
EtsGetMaxEnableFlags ()
{
    return PERF_NUM_MASKS;
}


HRESULT
EtsSetExtendedFlags(
    SAFEARRAY *saFlags,
    PEVENT_TRACE_PROPERTIES pLoggerInfo,
    ULONG offset
    )

{
    LONG lBound, uBound;
    ULONG HUGEP *pFlagData;

    if( NULL != saFlags ){
        SafeArrayGetLBound( saFlags, 1, &lBound );
        SafeArrayGetUBound( saFlags, 1, &uBound );
        SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData );
        pLoggerInfo->EnableFlags = pFlagData[lBound];
        if (pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            USHORT i;
            PTRACE_ENABLE_FLAG_EXTENSION FlagExt;
            UCHAR nFlag = (UCHAR) (uBound - lBound);
            if ( nFlag <= PERF_NUM_MASKS ) {
                PULONG pFlags;

                pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                            &pLoggerInfo->EnableFlags;
                FlagExt->Offset = offset;
                FlagExt->Length = (UCHAR) nFlag;

                pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                for (i=1; i<=nFlag; i++) {
                    pFlags[i-1] = pFlagData[lBound + i];
                }
            }
        }
        SafeArrayUnaccessData( saFlags );
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\maindll.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <strsafe.h>

HMODULE ghModule;

WCHAR *EVENTTRACE_GUIDSTRING = L"{9a5dd473-d410-11d1-b829-00c04f94c7c3}";
WCHAR *SYSMONLOG_GUIDSTRING =  L"{f95e1664-7979-44f2-a040-496e7f500043}";

CLSID CLSID_CIM_EVENTTRACE;
CLSID CLSID_CIM_SYSMONLOG;

long g_cLock=0;

EXTERN_C BOOL LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

    CLSIDFromString(EVENTTRACE_GUIDSTRING, &CLSID_CIM_EVENTTRACE );
    CLSIDFromString(SYSMONLOG_GUIDSTRING, &CLSID_CIM_SYSMONLOG );

    if( CLSID_CIM_EVENTTRACE != rclsid && CLSID_CIM_SYSMONLOG != rclsid ){
        return E_FAIL;
    }

    pObj= new CWbemGlueFactory();

    if( NULL==pObj ){
        return E_OUTOFMEMORY;
    }

    hr=pObj->QueryInterface(riid, ppv);

    if( FAILED(hr) ){
        delete pObj;
    }

    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    if( (0L==g_cLock) && 
        CWbemProviderGlue::FrameworkLogoffDLL(L"EventTraceProv") && 
        CWbemProviderGlue::FrameworkLogoffDLL(L"SmonLogProv")){
        
        sc = S_OK;

    }else{
        sc = S_FALSE;
    }

    return sc;
}

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os)){
        return FALSE;
    }

    return os.dwMajorVersion >= 4;
}

STDAPI DllRegisterServer(void)
{   
    HRESULT hr;
    DWORD dwStatus = ERROR_SUCCESS;
    const size_t cchCLSID = 512;

    WCHAR szCLSID[cchCLSID];
    LPCWSTR szModule = L"%systemroot%\\system32\\wbem\\evntrprv.dll";
    LPWSTR pName;
    LPWSTR pModel = L"Both";
    HKEY hKey1 = NULL;
    HKEY hKey2 = NULL;
    
    // Event Trace Provider
    pName = L"Event Trace Logger Provider";
    hr = StringCchCopy( szCLSID, cchCLSID, L"SOFTWARE\\CLASSES\\CLSID\\" );
    if( FAILED(hr) ){ goto cleanup; }

    hr = StringCchCat( szCLSID, cchCLSID, EVENTTRACE_GUIDSTRING );
    if( FAILED(hr) ){ goto cleanup; }

    dwStatus = RegCreateKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }
    
    RegSetValueExW(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (wcslen(pName)+1)*sizeof(WCHAR));
    
    dwStatus = RegCreateKeyW(hKey1, L"InprocServer32", &hKey2 );
    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }

    RegSetValueExW(hKey2, NULL, 0, REG_EXPAND_SZ, (BYTE *)szModule, (wcslen(szModule)+1)*sizeof(WCHAR));
    RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (wcslen(pModel)+1)*sizeof(WCHAR));

    if( NULL != hKey1 ){
        RegCloseKey(hKey1);
        hKey1 = NULL;
    }
    if( NULL != hKey2 ){
        RegCloseKey(hKey2);
        hKey2 = NULL;
    }

    
    // Sysmon Log Provider
    pName = L"System Log Provider";
    hr = StringCchCopy( szCLSID, cchCLSID, L"SOFTWARE\\CLASSES\\CLSID\\" );
    if( FAILED(hr) ){ goto cleanup; }
    hr = StringCchCat( szCLSID, cchCLSID, SYSMONLOG_GUIDSTRING );
    if( FAILED(hr) ){ goto cleanup; }

    dwStatus = RegCreateKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }
    RegSetValueExW(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (wcslen(pName)+1)*sizeof(WCHAR));

    dwStatus = RegCreateKeyW(hKey1, L"InprocServer32", &hKey2 );
    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }

    RegSetValueExW(hKey2, NULL, 0, REG_EXPAND_SZ, (BYTE *)szModule, (wcslen(szModule)+1)*sizeof(WCHAR));
    RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (wcslen(pModel)+1)*sizeof(WCHAR));

cleanup:
    if( NULL != hKey1 ){
        RegCloseKey(hKey1);
    }
    if( NULL != hKey2 ){
        RegCloseKey(hKey2);
    }

    if( FAILED(hr) ){
        dwStatus = hr;
    }
    return dwStatus;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    const size_t cchSize = 128;

    WCHAR      wcID[cchSize];
    WCHAR      szCLSID[cchSize];
    HKEY hKey;

    // Event Trace Provider
    CLSIDFromString(EVENTTRACE_GUIDSTRING, &CLSID_CIM_EVENTTRACE);
    StringFromGUID2(CLSID_CIM_EVENTTRACE, wcID, cchSize);

    hr = StringCchCopy( szCLSID, cchSize, L"SOFTWARE\\CLASSES\\CLSID\\");
    if( FAILED(hr) ){  goto cleanup;  }

    hr = StringCchCat( szCLSID, cchSize, wcID);
    if( FAILED(hr) ){  goto cleanup;  }

    DWORD dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);

    if( dwRet == NO_ERROR ){
        RegDeleteKeyW(hKey, L"InProcServer32" );
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID\\", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyW(hKey,wcID);
        RegCloseKey(hKey);
    }

    // System Log Provider
    CLSIDFromString(SYSMONLOG_GUIDSTRING, &CLSID_CIM_SYSMONLOG);
    StringFromGUID2(CLSID_CIM_SYSMONLOG, wcID, cchSize);

    hr = StringCchCopy( szCLSID, cchSize, L"SOFTWARE\\CLASSES\\CLSID\\");
    if( FAILED(hr) ){  goto cleanup;  }

    hr = StringCchCat( szCLSID, cchSize, wcID);
    if( FAILED(hr) ){  goto cleanup;  }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);

    if( dwRet == NO_ERROR ){
        RegDeleteKeyW(hKey, L"InProcServer32" );
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID\\", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyW(hKey,wcID);
        RegCloseKey(hKey);
    }

cleanup:

    return NOERROR;
}

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL,
                        DWORD fdwReason,
                        LPVOID lpReserved   )
{
    BOOL bRet = TRUE;
    
    switch( fdwReason ){ 
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"EventTraceProv");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\evntrprv.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <fwcommon.h>   
#include <strsafe.h>

#include "evntrprv.h"

LPCWSTR cszGlobalLogger = L"GlobalLogger";
LPCWSTR cszKernelLogger = L"NT Kernel Logger";
LPCWSTR cszPrivateLogger = L"{dc945bc4-34e5-4bc4-ab8d-cc4e9de1c2bb}";

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

HRESULT
SetGlobalLoggerSettings(
    DWORD StartValue,
    PEVENT_TRACE_PROPERTIES LoggerInfo,
    DWORD ClockType
);

BOOL 
FindString( LPCWSTR strBuffer, LPCWSTR strMatch )
{
    BOOL bReturn = FALSE;

    LPWSTR buffer;
    LPWSTR match;

    if( NULL == strBuffer || NULL == strMatch ){
        return FALSE;
    }

    buffer = _wcsdup( strBuffer );
    match  = _wcsdup( strMatch );
    
    if( buffer != NULL && match != NULL ){
        _wcslwr( buffer );
        _wcslwr( match );

        if( wcsstr( buffer, match ) ){
            bReturn = TRUE;
        }
    }     

    if( NULL != match ){
        free( match );
    }
    if( NULL != buffer ){
        free( buffer );
    }

    return bReturn;
}

ULONG hextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }

    len = (long) wcslen(s);

    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

CEventTrace SystemEventTraceProv( PROVIDER_NAME_EVENTTRACE, L"root\\wmi" );

const static WCHAR* pEventTraceErrorClass = L"\\\\.\\root\\wmi:EventTraceError";

CEventTrace::CEventTrace (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

CEventTrace::~CEventTrace ()
{
}

HRESULT 
CEventTrace::EnumerateInstances( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ULONG i, nLoggers;
    DWORD dwSize;
    PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
    PEVENT_TRACE_PROPERTIES pStorage;
    PVOID Storage;
    PVOID GuidStorage = NULL;
    PTRACE_GUID_PROPERTIES* GuidPropertiesArray = NULL;
    ULONG nGuidCount = 0;

    dwSize = MAXIMUM_LOGGERS*(sizeof(EVENT_TRACE_PROPERTIES)+2*MAXSTR*sizeof(WCHAR));

    Storage =  G_ALLOC(dwSize);
    if( Storage == NULL ){
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(Storage, dwSize);

    pStorage = (PEVENT_TRACE_PROPERTIES)Storage;

    for (i=0; i<MAXIMUM_LOGGERS; i++) {

        pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)+2*MAXSTR*sizeof(WCHAR);
        pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)+MAXSTR*sizeof(WCHAR);
        pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

        pLoggerInfo[i] = pStorage;

        pStorage = (PEVENT_TRACE_PROPERTIES)( (char*)pStorage + pStorage->Wnode.BufferSize);
    }

    hr = QueryAllTraces(
                pLoggerInfo,
                MAXIMUM_LOGGERS,
                &nLoggers 
            );

    if( ERROR_SUCCESS == hr ){

        try{
            if( ERROR_SUCCESS == LoadGuidArray( &GuidStorage, &nGuidCount ) ){
                GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)GuidStorage;
            }

            for( i=0; i<nLoggers && i<MAXIMUM_LOGGERS; i++){

                CInstancePtr pInstance( CreateNewInstance(pMethodContext), false );

                assert( NULL != pLoggerInfo[i] );

                if( NULL != pInstance ){
                    if( SUCCEEDED( LoadPropertyValues(pInstance, pLoggerInfo[i], GuidPropertiesArray, nGuidCount ) )){
                        hr = pInstance->Commit();
                    }
                }
            }

        }catch(...){
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    G_FREE( GuidStorage );
    G_FREE( Storage );
    
    return hr;
}

HRESULT CEventTrace::GetObject ( CInstance* pInstance, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    CHString LoggerName;
    
    pInstance->GetCHString( L"Name", LoggerName );

    hr = InitTraceProperties( &pLoggerInfo );
    
    if( ERROR_SUCCESS != hr ){
        return hr;
    }
    
    if( wcsncmp( (LPCWSTR)LoggerName, cszPrivateLogger, wcslen( cszPrivateLogger ) ) == 0 ){
        GUID guid;
        LPWSTR szPrivateGuid;
        size_t cchSize;

        szPrivateGuid = (LPWSTR)(LPCWSTR)LoggerName;
        cchSize = wcslen( szPrivateGuid );

        if( cchSize + 1 > wcslen( cszPrivateLogger ) ){ 
            szPrivateGuid += wcslen( cszPrivateLogger ) + 1;
            CLSIDFromString( szPrivateGuid, &guid );
        
            pLoggerInfo->Wnode.Guid = guid;
            pLoggerInfo->LogFileMode = EVENT_TRACE_PRIVATE_LOGGER_MODE;

            hr = QueryTraceW( 0, NULL, pLoggerInfo);

        }else{
            hr = WBEM_E_INVALID_PARAMETER;
        }
 
    }else{

        hr = QueryTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo);
    }    

    if( ERROR_SUCCESS == hr ){

        if( hr == ERROR_SUCCESS ){
        
            PVOID GuidStorage = NULL;
            PTRACE_GUID_PROPERTIES* GuidPropertiesArray = NULL;
            ULONG nGuidCount = 0;

            try{
                if( ERROR_SUCCESS == LoadGuidArray( &GuidStorage, &nGuidCount ) ){
                    GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)GuidStorage;
                }

                hr = LoadPropertyValues( pInstance, pLoggerInfo, GuidPropertiesArray, nGuidCount );
            }catch(...){
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        
            G_FREE( GuidStorage );

        }

    }

    G_FREE( pLoggerInfo );

    return hr;
}

HRESULT CEventTrace::LoadGuidArray( PVOID* Storage, PULONG pnGuidCount )
{
    ULONG i;
    ULONG nGuidArray = 16;
    ULONG nGuidCount = 0;
    DWORD dwSize;
    PTRACE_GUID_PROPERTIES* GuidPropertiesArray;
    PTRACE_GUID_PROPERTIES pStorage;
    HRESULT hr;

    do{
        dwSize = nGuidArray * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
        *Storage = G_ALLOC(dwSize);
        if(*Storage == NULL){
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        RtlZeroMemory(*Storage, dwSize);
        GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)(*Storage);
        pStorage = (PTRACE_GUID_PROPERTIES)((char*)(*Storage) + nGuidArray * sizeof(PTRACE_GUID_PROPERTIES));
        for (i=0; i < nGuidArray; i++) {
            GuidPropertiesArray[i] = pStorage;
            pStorage = (PTRACE_GUID_PROPERTIES)((char*)pStorage + sizeof(TRACE_GUID_PROPERTIES));
        }

        hr = EnumerateTraceGuids(GuidPropertiesArray,nGuidArray,&nGuidCount);
        
        if(hr == ERROR_MORE_DATA){
            if( nGuidCount <= nGuidArray ){
                hr = WBEM_E_INVALID_PARAMETER;
                break;
            }
            nGuidArray = nGuidCount;
            G_FREE(*Storage);
            (*Storage) = NULL;
        }

    }while( hr == ERROR_MORE_DATA );
    
    if( ERROR_SUCCESS == hr ){
        *pnGuidCount = nGuidCount;
    }else{
        *pnGuidCount = 0;
    }
        
    return hr;
}

HRESULT 
CEventTrace::LoadPropertyValues( 
        CInstance *pInstanceParam, 
        PEVENT_TRACE_PROPERTIES pLoggerInfo,    
        PTRACE_GUID_PROPERTIES  *GuidPropertiesArray,
        ULONG nGuidCount
    )
{
    LPWSTR strName;
    ULONG i;
    CInstance* pInstance = pInstanceParam;

    if( NULL == pLoggerInfo || NULL == pInstance ){
        return WBEM_E_INVALID_PARAMETER;
    }


    if( NULL != GuidPropertiesArray ){
        SAFEARRAY *saGuids;
        SAFEARRAY *saFlags;
        SAFEARRAY *saLevel;
        BSTR HUGEP *pGuidData;
        DWORD HUGEP *pLevelData;
        DWORD HUGEP *pFlagData;

        ULONG nGuidIndex = 0;
        ULONG nProviderGuids = 0;
        
        if( pLoggerInfo->Wnode.Guid == SystemTraceControlGuid ){
            nProviderGuids = 1;
        }else{
            for (i=0; i < nGuidCount; i++) {
                if( pLoggerInfo->Wnode.HistoricalContext == GuidPropertiesArray[i]->LoggerId ){
                    nProviderGuids++;
                }
            }
        }
        
        if( nProviderGuids ){
            
            saGuids = SafeArrayCreateVector( VT_BSTR, 0, nProviderGuids );
            saFlags = SafeArrayCreateVector( VT_I4, 0, nProviderGuids );
            saLevel = SafeArrayCreateVector( VT_I4, 0, nProviderGuids );

            if( saGuids == NULL || saFlags == NULL || saLevel == NULL ){
                if( saGuids != NULL ){
                    SafeArrayDestroy( saGuids );
                }
                if( saFlags != NULL ){
                    SafeArrayDestroy( saFlags );
                }
                if( saLevel != NULL ){
                    SafeArrayDestroy( saLevel );
                }
            }else{

                SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData);
                SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData);
                SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData);

                if( pLoggerInfo->Wnode.Guid == SystemTraceControlGuid ){
                    WCHAR buffer[128];
                    BSTR strGUID;
                
                    StringFromGUID2( SystemTraceControlGuid, buffer, 128 );
                    strGUID = SysAllocString( buffer );

                    pGuidData[0] = strGUID;
                    pLevelData[0] = 0;
                    pFlagData[0] = pLoggerInfo->EnableFlags;

                }else{
                    for (i=0; i < nGuidCount; i++) {
                    
                        if( pLoggerInfo->Wnode.HistoricalContext == GuidPropertiesArray[i]->LoggerId ){
                        
                            WCHAR buffer[128];
                            BSTR strGUID;
                        
                            StringFromGUID2( GuidPropertiesArray[i]->Guid, buffer, 128 );
                            strGUID = SysAllocString( buffer );

                            pGuidData[nGuidIndex] = strGUID;
                            pLevelData[nGuidIndex] = GuidPropertiesArray[i]->EnableLevel;
                            pFlagData[nGuidIndex] = GuidPropertiesArray[i]->EnableFlags;
                        
                            nGuidIndex++;
                        }
                    }
                }

                SafeArrayUnaccessData( saGuids );    
                SafeArrayUnaccessData( saFlags );    
                SafeArrayUnaccessData( saLevel );    
                VARIANT vArray;
                vArray.vt = VT_ARRAY|VT_I4;
                
                pInstance->SetStringArray( L"Guid", *saGuids );

                vArray.parray = saFlags;
                pInstance->SetVariant( L"EnableFlags", vArray );

                vArray.parray = saLevel;
                pInstance->SetVariant( L"Level", vArray );

                SafeArrayDestroy( saGuids );
                SafeArrayDestroy( saFlags );
                SafeArrayDestroy( saLevel );
            }
        }
    }

    pInstance->SetDWORD( L"BufferSize",         pLoggerInfo->BufferSize );
    pInstance->SetDWORD( L"MinimumBuffers",     pLoggerInfo->MinimumBuffers );
    pInstance->SetDWORD( L"MaximumBuffers",     pLoggerInfo->MaximumBuffers );
    pInstance->SetDWORD( L"MaximumFileSize",    pLoggerInfo->MaximumFileSize );
    pInstance->SetDWORD( L"FlushTimer",         pLoggerInfo->FlushTimer );
    pInstance->SetDWORD( L"AgeLimit",           pLoggerInfo->AgeLimit );
    pInstance->SetDWORD( L"LoggerId",           pLoggerInfo->Wnode.HistoricalContext );
    pInstance->SetDWORD( L"NumberOfBuffers",    pLoggerInfo->NumberOfBuffers );
    pInstance->SetDWORD( L"FreeBuffers",        pLoggerInfo->FreeBuffers );
    pInstance->SetDWORD( L"EventsLost",         pLoggerInfo->EventsLost );
    pInstance->SetDWORD( L"BuffersWritten",     pLoggerInfo->BuffersWritten );
    pInstance->SetDWORD( L"LogBuffersLost",     pLoggerInfo->LogBuffersLost );
    pInstance->SetDWORD( L"RealTimeBuffersLost",pLoggerInfo->RealTimeBuffersLost );
    pInstance->SetDWORD( L"LoggerThreadId",     HandleToUlong( pLoggerInfo->LoggerThreadId ) );

    DecodePropertyValue( 
            pInstance, 
            L"LogFileMode", 
            &pLoggerInfo->LogFileMode, 
            DECODE_MODE_TRACE_TO_WBEM );

    DecodePropertyValue( 
            pInstance, 
            L"ClockType", 
            &pLoggerInfo->Wnode.ClientContext, 
            DECODE_MODE_TRACE_TO_WBEM );
    
    strName = (LPWSTR)((char*)pLoggerInfo+pLoggerInfo->LoggerNameOffset);
    pInstance->SetCHString( L"Name", strName );

    strName = (LPWSTR)((char*)pLoggerInfo+pLoggerInfo->LogFileNameOffset );
    pInstance->SetCHString( L"LogFileName", strName );
    
    return WBEM_S_NO_ERROR;
}

HRESULT 
CEventTrace::DecodePropertyValue(
                CInstance*  pInstance, 
                LPCWSTR     szProperty,
                DWORD*      pdwValue,
                DWORD       dwFlags )
{
    HRESULT hr = ERROR_SUCCESS;
    
    DWORD dwValue = 0;
    CHString Property;
    DWORD dwValueType = VALUETYPE_INDEX;

    if( NULL == pdwValue ){
        return WBEM_E_INVALID_PARAMETER;
    }

    if( dwFlags & DECODE_MODE_WBEM_TO_TRACE ){
        *pdwValue = 0;
        pInstance->GetCHString( szProperty, Property );
        
        if( ! Property.GetLength() ){
            return hr;
        }
    }else{
        dwValue = *pdwValue;
    }

    IWbemClassObject* pClass = pInstance->GetClassObjectInterface();

    if( pClass != NULL ){
        const ULONG cchBuffer = 1024;
        WCHAR buffer[cchBuffer] = L"";
        LONG nFlavor;
        VARIANT var;
        SAFEARRAY* saValues = NULL;
        SAFEARRAY* saValueMap = NULL;

        IWbemQualifierSet   *pQualSet = NULL;
        pClass->GetPropertyQualifierSet( szProperty, &pQualSet );
        if( pQualSet != NULL ){
            hr = pQualSet->Get( L"ValueMap", 0, &var, &nFlavor );
            if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
                saValueMap = var.parray;
            }

            hr = pQualSet->Get( L"Values", 0, &var, &nFlavor );
            if( SUCCEEDED(hr) && (var.vt & VT_ARRAY) ){
                saValues = var.parray;
            }

            hr = pQualSet->Get( L"ValueType", 0, &var, &nFlavor );
            if( SUCCEEDED(hr) ){
                if( _wcsicmp( var.bstrVal, L"index" ) == 0 ){
                    dwValueType = VALUETYPE_INDEX;
                }
                if( _wcsicmp( var.bstrVal, L"flag") == 0 ){
                    dwValueType = VALUETYPE_FLAG;
                }
            }
    
            if( saValues != NULL && saValueMap != NULL ){
                BSTR HUGEP *pMapData;
                BSTR HUGEP *pValuesData;
                LONG uMapBound, lMapBound;
                LONG uValuesBound, lValuesBound;

                hr = SafeArrayGetUBound( saValueMap, 1, &uMapBound );
                if( SUCCEEDED(hr) ){
                    hr = SafeArrayGetLBound( saValueMap, 1, &lMapBound );
                }
                if( SUCCEEDED(hr) ){
                    hr = SafeArrayAccessData( saValueMap, (void HUGEP **)&pMapData );
                }
        
                if( SUCCEEDED(hr) ){
                    hr = SafeArrayGetUBound( saValues, 1, &uValuesBound );
                }
                if( SUCCEEDED(hr) ){
                    hr = SafeArrayGetLBound( saValues, 1, &lValuesBound );
                }
                if( SUCCEEDED(hr) ){
                    hr = SafeArrayAccessData( saValues, (void HUGEP **)&pValuesData );
                }

                for ( LONG i=lMapBound; i<=uMapBound && SUCCEEDED(hr); i++) {
                    LONG dwFlag;
            
                    if( i<lValuesBound || i>uValuesBound ){
                        break;
                    }
                    dwFlag = hextoi( pMapData[i] );
                    if( dwFlags & DECODE_MODE_WBEM_TO_TRACE ){
                                               
                        if( FindString( pValuesData[i], (LPCWSTR)Property )  ){
                            switch( dwValueType ){
                            case VALUETYPE_INDEX:
                                dwValue = dwFlag;
                                break;
                            case VALUETYPE_FLAG:
                                dwValue |= dwFlag;
                                break;
                            }
                        }

                    }else{
                        BOOL bValue = FALSE;

                        switch( dwValueType ){
                        case VALUETYPE_INDEX:
                            bValue = (dwFlag == dwValue);
                            break;
                        case VALUETYPE_FLAG:
                            bValue = ((dwFlag & dwValue) == dwFlag );
                            break;
                        }

                        if( bValue ){
                            
                            if( wcslen(buffer) ){
                                hr = StringCchCat( buffer, cchBuffer, L"|" );
                            }
                            if( SUCCEEDED( hr ) ){
                                hr = StringCchCat( buffer, cchBuffer, pValuesData[i] );
                            }
                        }
                    }
                }

                SafeArrayUnaccessData( saValueMap );
                SafeArrayUnaccessData( saValues );
        
                SafeArrayDestroy( saValueMap );
                SafeArrayDestroy( saValues );

                if( dwFlags & DECODE_MODE_TRACE_TO_WBEM ){
                    if( wcslen( buffer ) ){
                        pInstance->SetCHString( szProperty, buffer );
                    }else{
                        hr = pQualSet->Get( L"DefaultValue", 0, &var, &nFlavor );
                        if( ERROR_SUCCESS == hr && VT_BSTR == var.vt ){
                            pInstance->SetCHString( szProperty, var.bstrVal );
                            VariantClear( &var );
                        }
                    }
                }else if( dwFlags & DECODE_MODE_WBEM_TO_TRACE ){
                    *pdwValue = dwValue;
                }

            }

            pQualSet->Release();
        }
    }

    return hr;
}

HRESULT CEventTrace::PutInstance ( const CInstance &Instance, long lFlags )
{
    HRESULT hr = WBEM_E_UNSUPPORTED_PARAMETER;

    CHString LoggerName;
    CHString LogFileName;
    SAFEARRAY *saGuids = NULL;
    SAFEARRAY *saLevel = NULL;
    SAFEARRAY *saFlags = NULL;
    GUID guid = {0};
    
    DWORD dwValue;

    LPWSTR strName;
    LPWSTR strFile;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    BSTR HUGEP *pGuidData;
    VARIANT vArray;
    LONG lBound;
    
    if ( !(lFlags & WBEM_FLAG_CREATE_ONLY|WBEM_FLAG_UPDATE_ONLY ) ){ 
        return hr;
    }
   
    hr = InitTraceProperties( &pLoggerInfo );   
    if( hr != ERROR_SUCCESS ){
        return hr;
    }

    Instance.GetCHString( L"Name", LoggerName );
    strName = (LPWSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset );
    hr = StringCchCopy( strName, MAXSTR, (LPCWSTR)LoggerName );
    if( FAILED(hr) ){
        return hr;
    }
    
    Instance.GetCHString( L"LogFileName", LogFileName );
    strFile = (LPWSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset );
    hr = StringCchCopy( strFile, MAXSTR, (LPCWSTR)LogFileName );
    if( FAILED(hr) ){
        return hr;
    }

    Instance.GetDWORD( L"BufferSize",         pLoggerInfo->BufferSize );
    Instance.GetDWORD( L"MinimumBuffers",     pLoggerInfo->MinimumBuffers );
    Instance.GetDWORD( L"MaximumBuffers",     pLoggerInfo->MaximumBuffers );
    Instance.GetDWORD( L"MaximumFileSize",    pLoggerInfo->MaximumFileSize );
    Instance.GetDWORD( L"FlushTimer",         pLoggerInfo->FlushTimer );

    hr = DecodePropertyValue( 
                (CInstance*)&Instance, 
                L"LogFileMode",  
                &dwValue, 
                DECODE_MODE_WBEM_TO_TRACE );

    if( SUCCEEDED(hr) ){
        pLoggerInfo->LogFileMode = dwValue;
    }

    hr = DecodePropertyValue( 
                (CInstance*)&Instance, 
                L"ClockType",
                &dwValue,
                DECODE_MODE_WBEM_TO_TRACE );

    if( SUCCEEDED(hr) ){
        pLoggerInfo->Wnode.ClientContext = dwValue;
    }

    hr = WBEM_S_NO_ERROR;

    if(! Instance.GetStringArray( L"Guid", saGuids ) ){
        saGuids = NULL;
    }

    Instance.GetVariant( L"EnableFlags", vArray );
    if( VT_NULL != vArray.vt ){
        saFlags = vArray.parray;
    }
   
    Instance.GetVariant( L"Level", vArray );
    if( VT_NULL != vArray.vt ){
        saLevel = vArray.parray;
    }
    
    if( saGuids != NULL ){

        //
        // Need to check the guids now in case it 
        // is the kernel logger.  The kernel logger
        // is handled differently for both Create and Update
        //

        hr = SafeArrayGetLBound( saGuids, 1, &lBound );
        if( SUCCEEDED(hr) ){
            hr = SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData );
        }
        if( SUCCEEDED(hr) ){
            CLSIDFromString( pGuidData[lBound], &guid );
            SafeArrayUnaccessData( saGuids );
        }
    }

    BOOL bSystemLogger = IsEqualGUID( gCritSecGuid, guid ) || IsEqualGUID( gHeapGuid, guid );

    if (lFlags & WBEM_FLAG_CREATE_ONLY){

        if( IsEqualGUID( guid, SystemTraceControlGuid ) || bSystemLogger ){
            
            ULONG offset = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);
            
            pLoggerInfo->Wnode.Guid = guid;
    
            if( bSystemLogger ){
                pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
                pLoggerInfo->Wnode.HistoricalContext = 0x1000001;
            }

            hr = EtsSetExtendedFlags(
                            saFlags,
                            pLoggerInfo,
                            offset
                            );

            hr = StartTrace( &LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

            if( ERROR_SUCCESS == hr && bSystemLogger ){
                hr = WmiEnableTrace( Instance, TRUE, saFlags, saLevel, saGuids, LoggerHandle );
            }

        }else if( LoggerName.CompareNoCase( cszGlobalLogger) == 0 ){
            hr = StartGlobalLogger( pLoggerInfo );
        }else{
            if( pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE ){
                pLoggerInfo->Wnode.Guid = guid;
            }

            hr = StartTrace( &LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );
            
            if( ERROR_SUCCESS == hr ){
                hr = WmiEnableTrace( Instance, TRUE, saFlags, saLevel, saGuids, LoggerHandle );
            }
        }
        
    }else if( lFlags & WBEM_FLAG_UPDATE_ONLY ){

        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );
        
        if( IsEqualGUID( guid, SystemTraceControlGuid ) || bSystemLogger ){

            // 
            // The kernel logger does not use EnableTrace.
            // Set the flags and call Update Only
            //
            
            ULONG offset = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);

            hr = EtsSetExtendedFlags(
                            saFlags,
                            pLoggerInfo,
                            offset
                            );

            if( bSystemLogger ){
                pLoggerInfo->Wnode.Guid = guid;
            }

            hr = UpdateTrace( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

        }else{
    
            hr = UpdateTrace( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );
            if( ERROR_SUCCESS == hr ){
                hr = WmiEnableTrace( Instance, TRUE, saFlags, saLevel, saGuids, LoggerHandle );
            }
        }
    }

    if( NULL != saGuids ){
        SafeArrayDestroy( saGuids );
    }
    if( NULL != saFlags ){
        SafeArrayDestroy( saFlags );
    }
    if( NULL != saLevel ){
        SafeArrayDestroy( saLevel );
    }

    G_FREE( pLoggerInfo );

    return hr; 
}

HRESULT CEventTrace::InitTraceProperties( PEVENT_TRACE_PROPERTIES* ppLoggerInfo )
{
    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;

    DWORD dwSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(WCHAR)*MAXSTR*2 + EtsGetMaxEnableFlags() * sizeof(ULONG);

    pLoggerInfo = (PEVENT_TRACE_PROPERTIES)G_ALLOC( dwSize );
    
    if( NULL == pLoggerInfo  ){
        return ERROR_OUTOFMEMORY;
    }

    ZeroMemory( pLoggerInfo, dwSize );
    pLoggerInfo->Wnode.BufferSize = dwSize;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset+MAXSTR*sizeof(WCHAR);

    *ppLoggerInfo = pLoggerInfo;

    return ERROR_SUCCESS;

}

HRESULT 
CEventTrace::WmiEnableTrace( 
        const CInstance &Instance, 
        bool bEnable,
        SAFEARRAY *saFlags, 
        SAFEARRAY *saLevel, 
        SAFEARRAY *saGuid,
        TRACEHANDLE LoggerHandle
    )
{
    HRESULT hr = ERROR_SUCCESS;

    BSTR HUGEP  *pGuidData = NULL;
    DWORD HUGEP  *pFlagData = NULL;
    DWORD HUGEP  *pLevelData = NULL;
    LONG lGuidBound,uGuidBound;
    LONG lFlagBound,uFlagBound;
    LONG lLevelBound,uLevelBound;
    
    if( NULL == saGuid ){
        return ERROR_SUCCESS;
    }

    hr = SafeArrayGetUBound( saGuid, 1, &uGuidBound );
    if( FAILED(hr) ){ return hr; }
    
    hr = SafeArrayGetLBound( saGuid, 1, &lGuidBound );
    if( FAILED(hr) ){ return hr; }
    
    hr = SafeArrayAccessData( saGuid, (void HUGEP **)&pGuidData );
    if( FAILED(hr) ){ return hr; }

    if( saFlags != NULL ){
        hr = SafeArrayGetUBound( saFlags, 1, &uFlagBound );
        if( SUCCEEDED(hr) ){
            hr = SafeArrayGetLBound( saFlags, 1, &lFlagBound );
        }
        if( SUCCEEDED(hr) ){
            hr = SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData );
        }
    }
    if( NULL == saFlags || FAILED(hr) ){
        uFlagBound = 0;
        lFlagBound = 0;
    }

    if( saLevel != NULL ){
        hr = SafeArrayGetUBound( saLevel, 1, &uLevelBound );
        if(SUCCEEDED(hr) ){
            hr = SafeArrayGetLBound( saLevel, 1, &lLevelBound );
        }
        if(SUCCEEDED(hr) ){
            hr = SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData );
        }
    }
    if( NULL == saLevel || FAILED(hr) ){
        uLevelBound = 0;
        lLevelBound = 0;
    }

    for ( LONG i=lGuidBound; i<=uGuidBound; i++) {
        
        GUID  guid;
        DWORD dwLevel = 0;
        DWORD dwFlags = 0;
        
        if( pGuidData[i] == NULL ){
            continue;
        }

        if( SUCCEEDED( CLSIDFromString( pGuidData[i], &guid ) ) ){

            if( i>=lLevelBound && i<=uLevelBound && saLevel != NULL ){
                if( NULL != pLevelData ){
                    dwLevel = pLevelData[i];
                }
            }
            if( i>=lFlagBound && i<=uFlagBound && saFlags != NULL ){
                if( NULL != pFlagData ){
                    dwFlags = pFlagData[i];
                }
            }

            hr = EnableTrace( bEnable, dwFlags, dwLevel, &guid, LoggerHandle );

            if(IsEqualGUID( gCritSecGuid, guid ) || IsEqualGUID( gHeapGuid, guid )){
                break;
            }

        }
    }

    SafeArrayUnaccessData( saGuid );

    if( saFlags != NULL ){
        SafeArrayUnaccessData( saFlags );
    }
    if( saLevel != NULL ){
        SafeArrayUnaccessData( saLevel );
    }

    return hr;
}

HRESULT CEventTrace::WmiFlushTrace( const CInstance &Instance )
{
    HRESULT hr;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;

    CHString LoggerName;

    hr = InitTraceProperties( &pLoggerInfo );   
    
    if( hr == ERROR_SUCCESS ){

        Instance.GetCHString( L"Name", LoggerName );
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );
 
        hr = ::FlushTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

        G_FREE( pLoggerInfo );
    }

    return hr;
}

HRESULT CEventTrace::WmiStopTrace( const CInstance &Instance )
{
    HRESULT hr;

    CHString LoggerName;
    SAFEARRAY *saGuids = NULL;
    LONG nGuidCount,i;
    GUID guid;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    BSTR HUGEP *pData;
  
    Instance.GetCHString( L"Name", LoggerName );
    hr = InitTraceProperties( &pLoggerInfo );   

    if( ERROR_SUCCESS != hr ){
        return hr;
    }

    if( wcsncmp( (LPCWSTR)LoggerName, cszPrivateLogger, wcslen( cszPrivateLogger ) ) == 0 ){
        
        LPWSTR szPrivateGuid;
        size_t cchSize;
        szPrivateGuid = (LPWSTR)(LPCWSTR)LoggerName;
        cchSize = wcslen( szPrivateGuid );
        if( cchSize + 1 > wcslen( cszPrivateLogger ) ){ 
            szPrivateGuid += wcslen( cszPrivateLogger ) + 1;
            CLSIDFromString( szPrivateGuid, &guid );
        
            pLoggerInfo->Wnode.Guid = guid;
            pLoggerInfo->LogFileMode = EVENT_TRACE_PRIVATE_LOGGER_MODE;

            hr = ::StopTrace( 0, (LPCWSTR)LoggerName, pLoggerInfo );
        }else{
            hr = WBEM_E_INVALID_PARAMETER;
        }

    }else{
    
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );
        Instance.GetStringArray( L"Guid", saGuids );

        if( NULL != saGuids ){

            hr = SafeArrayGetUBound( saGuids, 0, &nGuidCount );
            if( SUCCEEDED(hr) ){
                hr = SafeArrayAccessData( saGuids, (void HUGEP **)&pData );
            }

            if( SUCCEEDED(hr) ){
                for (i=0; i<nGuidCount; i++) {
                    CLSIDFromString( pData[i], &guid );
                    hr = EnableTrace( FALSE, 0, 0, &guid, LoggerHandle );
                }

                SafeArrayUnaccessData( saGuids );    
            }

            SafeArrayDestroy( saGuids );
        }

        hr = ::StopTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

        if( LoggerName.CompareNoCase( cszGlobalLogger ) == 0 ){
            hr = DeleteGlobalLogger( pLoggerInfo );
        }

        G_FREE( pLoggerInfo );

    }

    return hr;
}

HRESULT 
CEventTrace::StartGlobalLogger(
    IN PEVENT_TRACE_PROPERTIES pLoggerInfo
)
{
	return (SetGlobalLoggerSettings( 1L, pLoggerInfo, 0 ));
}

HRESULT 
CEventTrace::DeleteGlobalLogger(
    IN PEVENT_TRACE_PROPERTIES pLoggerInfo
)
{
	return (SetGlobalLoggerSettings( 0L, pLoggerInfo, 0 ) );
}

HRESULT 
CEventTrace::ExecMethod( 
        const CInstance& Instance,
        const BSTR bstrMethodName,
        CInstance *pInParams,
        CInstance *pOutParams,
        long lFlags
    )
{
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    HRESULT hResult = ERROR_SUCCESS;

    if( _wcsicmp( bstrMethodName, L"FlushTrace") == 0 ){
        hResult = WmiFlushTrace( Instance );
        hr = WBEM_S_NO_ERROR;
    }

    if( _wcsicmp( bstrMethodName, L"StopTrace") == 0 ){
        hResult = WmiStopTrace( Instance );
        hr = WBEM_S_NO_ERROR;
    }

    if( _wcsicmp( bstrMethodName, L"EnableTrace") == 0 ){

        bool bEnable;
        SAFEARRAY *saGuids = NULL;
        SAFEARRAY *saLevel = NULL;
        SAFEARRAY *saFlags = NULL;
        VARIANT vArray;
        TRACEHANDLE LoggerHandle;

        pInParams->Getbool( L"Enable", bEnable );

        pInParams->GetStringArray( L"Guid", saGuids );
        pInParams->GetVariant( L"Flags", vArray );
        saFlags = vArray.parray;
        pInParams->GetVariant( L"Level", vArray );
        saLevel = vArray.parray;
    
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );

        hResult = WmiEnableTrace( Instance, bEnable, saFlags, saLevel, saGuids, LoggerHandle );

        if( NULL != saGuids ){
            SafeArrayDestroy( saGuids );
        }
        if( NULL != saFlags ){
            SafeArrayDestroy( saFlags );    
        }
        if( NULL != saLevel ){
            SafeArrayDestroy( saLevel );
        }

        hr = WBEM_S_NO_ERROR;
    }

    pOutParams->SetDWORD( L"ReturnValue", hResult );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\smlogprv.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <fwcommon.h>
#include <pdhp.h>

#define SECURITY_WIN32
#include <security.h>

#include "smlogprv.h"

CSmonLog SysmonLogProv1( PROVIDER_NAME_SMONLOG, L"root\\wmi" );
CSmonLog SysmonLogProv2( PROVIDER_NAME_SMONLOG, L"root\\perfmon" );


CSmonLog::CSmonLog (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

CSmonLog::~CSmonLog ()
{
}

HRESULT 
CSmonLog::EnumerateInstances( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwSize = 0;

    LPTSTR mszCollections = NULL;

    hr = PdhPlaEnumCollections( NULL, &dwSize, mszCollections );

    mszCollections = (LPTSTR)malloc( dwSize * sizeof(TCHAR) );
    if( mszCollections ){
        LPTSTR strCollection;
        
        hr = PdhPlaEnumCollections( NULL, &dwSize, mszCollections );
        
        if( hr == ERROR_SUCCESS ){
            
            strCollection = mszCollections;

            while( strCollection != NULL && *strCollection != '\0' ){

                CInstance *pInstance = CreateNewInstance(pMethodContext);
                if( SUCCEEDED( LoadPropertyValues(pInstance, strCollection ) )){
                    hr = pInstance->Commit();
                }

                pInstance->Release();

                strCollection += ( _tcslen( strCollection ) + 1 );
            }
        }
    }
                
    return hr;
}

HRESULT CSmonLog::GetObject ( CInstance* pInstance, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString Name;
    PDH_PLA_INFO_W info;
    DWORD dwSize = sizeof(PDH_PLA_INFO_W);
    ZeroMemory( &info, dwSize );

    pInstance->GetCHString( L"Name", Name );
    hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)Name, NULL, &dwSize, &info );

    return hr;
}


HRESULT 
CSmonLog::LoadPropertyValues( 
        CInstance *pInstance,
        LPWSTR strName
    )
{
    pInstance->SetCHString( L"Name", strName );

    return WBEM_S_NO_ERROR;
}

HRESULT CSmonLog::PutInstance( const CInstance &Instance, long lFlags )
{
    HRESULT hr = WBEM_E_UNSUPPORTED_PARAMETER;

    return hr; 
}

HRESULT
CSmonLog::SetRunAs( const CInstance &Instance, CInstance *pInParams )
{
    HRESULT hr;

    CHString Name;
    CHString User;
    CHString Password;

    Instance.GetCHString( L"Name", Name );
    pInParams->GetCHString( L"User", User );
    pInParams->GetCHString( L"Password", Password );

    RevertToSelf();
    
    hr = PdhiPlaSetRunAs( (LPWSTR)(LPCWSTR)Name, NULL, (LPWSTR)(LPCWSTR)User, (LPWSTR)(LPCWSTR)Password );
    
    return hr;
}

HRESULT 
CSmonLog::ExecMethod( 
        const CInstance& Instance,
        const BSTR bstrMethodName,
        CInstance *pInParams,
        CInstance *pOutParams,
        long lFlags
    )
{
    HRESULT hr = WBEM_E_METHOD_NOT_IMPLEMENTED;
    HRESULT hResult = ERROR_SUCCESS;

    if( _wcsicmp( bstrMethodName, L"SetRunAs") == 0 ){
        hResult = SetRunAs( Instance, pInParams );
        hr = WBEM_S_NO_ERROR;
    }

    pOutParams->SetDWORD( L"ReturnValue", hResult );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\evntrprv\smlogprv.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <wmistr.h>
#include <evntrace.h>

#define MAXSTR              1024
#define MAXIMUM_LOGGERS     32

#define PROVIDER_NAME_SMONLOG L"SysmonLog"

class CSmonLog : public Provider 
{
public:
	CSmonLog(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
	virtual ~CSmonLog();

protected:
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

	virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

	virtual HRESULT ExecMethod( const CInstance& Instance,
				            const BSTR bstrMethodName,
				            CInstance *pInParams,
				            CInstance *pOutParams,
				            long lFlags = 0L 
                        );

    HRESULT LoadPropertyValues( 
                CInstance *pInstance, 
                LPWSTR strName
            );
private:
    HRESULT SetRunAs( const CInstance &Instance, CInstance *pInParams );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\csharptracepack\perftest\tracegen-dll\tracetest.cs ===
//---------------------------------------------------------------------------
// File: TraceTest
//
// A Test Program for using the ETW Trace Listener
//
// Author: Melur Raghuraman 
// Date:   01 Oct 2001
//---------------------------------------------------------------------------

using System;
using System.Threading;
using System.Diagnostics;
using System.IO;
using System.Data; 
using System.Configuration;
using Microsoft.Win32.Diagnostics;
using System.Reflection;
	/// <summary>
	/// Summary description for TraceTest.
	/// </summary>
	/// 

class TraceTest
    //TraceTest
{
                 
    //
    // This routine is a sample of what a performance and capacity planning trace
    // provider will do to generate ETW traces. 
    //

    static void PerfTracingSample(int eventCount, int argCount, bool bString)
    {
        uint i;
        uint Status;
        Int64 AvgTime;
        int arg1 = 3276;
        int arg2 = 56797;        
        Guid TransactionGuid = new Guid("{b4955bf0-3af1-4740-b475-99055d3fe9aa}");
        Console.WriteLine("Perf Tracing Sample running");
        TimerTest MyTimer = new TimerTest(); 

        WinTraceProvider MyProvider = new WinTraceProvider (new Guid("{98bea4af-ef37-424a-b457-9ea1cfd77dd9}") );

        MyTimer.Start();

        for (i=0; i < eventCount; i++) 
        {
            if (MyProvider.enabled) 
            {
                if (!bString) 
                {
                    switch (argCount) 
                    {
                        case 0: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start); break;
                        case 1: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1); break;
                        case 2: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2); break;
                        case 3: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1); break;
                        case 4: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1, arg2); break;
                        case 5: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1, arg2, arg1); break;
                        case 6: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1, arg2, arg1, arg2); break;
                        case 7: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1, arg2, arg1, arg2, arg1); break;
                        case 8: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, arg1, arg2, arg1, arg2, arg1, arg2, arg1, arg1); break;
                    }
                }
                else 
                {
                    switch (argCount) 
                    {
                        case 0: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start); break;
                        case 1: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012"); break;
                        case 2: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 3: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 4: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 5: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 6: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 7: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012"); break;
                        case 8: Status = MyProvider.TraceEvent(TransactionGuid, EventType.Start, "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012", "12345678901234567890123456789012","12345678901234567890123456789012"); break;
                    }

                }
         


            }
        }
        
        MyTimer.Stop();
		AvgTime = MyTimer.Average() / eventCount;
        Console.WriteLine("Start {0} End {1} Count {2} Delta {3} Freq {4}", MyTimer.m_Start, MyTimer.m_End, MyTimer.m_Count, MyTimer.m_Sum, MyTimer.m_Freq);


        AvgTime = MyTimer.m_Sum / MyTimer.m_Freq;   // This is in seconds

        Console.WriteLine("Elapsed Time {0} milli seconds ", AvgTime*1000);
        // Assumes you are running on a 1700 MHz box. 
        AvgTime = MyTimer.m_Sum * (1700 * 1000000 / eventCount);
        AvgTime = AvgTime / MyTimer.m_Freq;
        Console.WriteLine("Done! Average Time for {0} calls = {1} Cycles", eventCount, AvgTime);        
    }

    //
    // Here's what a debug trace provider will have to do to generate debug traces
    //

    static void DebugTracingSample(int eventCount, int argCount, bool bString)
    {
        uint i;
        int EventCount = eventCount; 
        uint Status;
        long AvgTime;
        
		
		unsafe
		{
			/* Test to determine how characters are encoded in the String class */
			sbyte[] b ={ 0x64, 0x65, 0x66, 0x67 };
			fixed(sbyte* sbyteArray = b)
			{
				String s = new String(sbyteArray,0,4);
				Console.WriteLine("Test String = " + s + " Length = " + s.Length);
				int len = s.Length*2;
				fixed(char* cArray = s.ToCharArray())
				{
					byte* bArray = (byte*)cArray;
					for(int h = 0; h < len; h++)
						Console.WriteLine("[{0}]:{1}",h,bArray[h]);
				}
				
			}
		}


        Console.WriteLine("DebugTracing Sample Running");
		unsafe {Console.WriteLine("sizeof char = " + sizeof(char));}
        TimerTest MyTimer = new TimerTest();
        WinTraceProvider MyProvider = new WinTraceProvider (new Guid("{98bea4af-ef37-424a-b457-9ea1cfd77dd9}") );

		/*** scratch work - start  ***/
		Assembly assembly;
		assembly  = Assembly.GetAssembly(MyTimer.GetType());
		Console.WriteLine("Code base : " + assembly.CodeBase);
		/*** scratch work - end	   ***/
						
		string frmtstr = "Hello {0}";
		string frmtstr2 = "Arg0 = {0} Arg1 = {1}";
		string frmtstr3 = "Arg0 ={0} Arg1 = {1} Arg2 = {2}";		
		bool bool_v=false;
		byte byte_v=(byte)99;
		sbyte sbyte_v = (sbyte)-114;
		short short_v = (short)-54;
		ushort ushort_v = (ushort)5000;
		int int_v = -654;
		uint uint_v = (uint)12345;
		long long_v = (long)-98765;
		ulong ulong_v = (ulong)1234567;
		string string_v = "Does it work [2]?";
		char char_v='G';
		decimal decimal_v=(decimal)200.876543243213D;
		object decimal_obj = decimal_v;
		double double_v=(double)3.00;
		float float_v=2.00F;

		//This is a string of length 128 bytes
		string testStr = "We began in earnest on Microsoft Windows 2000 in August 1996!!!!";
		//string testStr = "12345678"; //16 bytes in length
		//Yes, it is only a performance test and hence we do not need the actual formatting. Yet....
		string testFmtStr1="Test Message = {0}", testFmtStr2 = testFmtStr1+",{1}", testFmtStr3 = testFmtStr2+",{2}";
		string testFmtStr4=testFmtStr3+",{3}", testFmtStr5=testFmtStr4+",{4}",testFmtStr6=testFmtStr5+",{5}";
		string testFmtStr7=testFmtStr6+",{6}", testFmtStr8=testFmtStr7+",{7}";
		Console.WriteLine("Length = " + testStr.Length);		
		string emptyString = "";
		Console.WriteLine("Length of empty string = "+emptyString.Length);
		//Console.WriteLine(String.Format("Dummy Format {0} {1}","Hello"));
		unsafe{Console.WriteLine("size of decimal = " + sizeof(decimal));}
		Console.WriteLine("Length of decimal string = " + decimal_obj.ToString().Length);
		if (bString)
		{
			
			//Gather performance results for logging a message containing 1 128-byte argument.
			Console.WriteLine("Helooooo {0} {1} {2}",decimal_v,(object)null,decimal_v);
			//MyProvider.DoTraceMessage(1,"Helloooo {0} {1} {2}",decimal_v,(object)null,decimal_v);
			MyTimer.Start();
			for(i=0; i < eventCount; i++)
			{
				if (MyProvider.enabled)
				{
					
					switch(argCount)
					{
						case 1:MyProvider.DoTraceMessage(1,testFmtStr1,testStr);break;
						case 2:MyProvider.DoTraceMessage(1,testFmtStr2,testStr,testStr);break;
						case 3:MyProvider.DoTraceMessage(1,testFmtStr3,testStr,testStr,testStr);break;
						case 4:MyProvider.DoTraceMessage(1,testFmtStr4,testStr,testStr,testStr,testStr);break;
						case 5:MyProvider.DoTraceMessage(1,testFmtStr5,testStr,testStr,testStr,testStr, testStr);break;
						case 6:MyProvider.DoTraceMessage(1,testFmtStr6,testStr,testStr,testStr,testStr, testStr, testStr);break;
						case 7:MyProvider.DoTraceMessage(1,testFmtStr7,testStr,testStr,testStr,testStr, testStr, testStr, testStr);break;
						case 8:MyProvider.DoTraceMessage(1,testFmtStr8,testStr,testStr,testStr,testStr, testStr, testStr, testStr, testStr);break;
					}
				}
			}
			MyTimer.Stop();
			

		}

		else
		{
			MyTimer.Start();
			MyProvider.DoTraceMessage(1,frmtstr,bool_v);
			MyProvider.DoTraceMessage(1,frmtstr,byte_v);
			MyProvider.DoTraceMessage(1,frmtstr,sbyte_v);
			MyProvider.DoTraceMessage(1,frmtstr,short_v);
			MyProvider.DoTraceMessage(1,frmtstr,ushort_v);
			MyProvider.DoTraceMessage(1,frmtstr,int_v);
			MyProvider.DoTraceMessage(1,frmtstr,uint_v);
			MyProvider.DoTraceMessage(1,frmtstr,long_v);
			MyProvider.DoTraceMessage(1,frmtstr,ulong_v);
			MyProvider.DoTraceMessage(1,frmtstr,float_v);
			MyProvider.DoTraceMessage(1,frmtstr,double_v);
			MyProvider.DoTraceMessage(1,frmtstr,decimal_v);
			MyProvider.DoTraceMessage(1,frmtstr,char_v);
			MyProvider.DoTraceMessage(1,frmtstr,string_v);
			MyProvider.DoTraceMessage(1,frmtstr2,uint_v,byte_v);
			Status = MyProvider.DoTraceMessage(1,frmtstr3,decimal_v,float_v,long_v);
			/*
			for (i=0; i < eventCount; i++) 
			{
				if (MyProvider.enabled) 
				{				
					for(i=0; i < eventCount; i++)
					{
						if (MyProvider.enabled)
						{
							switch(argCount)
							{
								case 1:MyProvider.DoTraceMessage(1,testFmtStr1,decimal_v);break;
								case 2:MyProvider.DoTraceMessage(1,testFmtStr2,decimal_v,decimal_v);break;
								case 3:MyProvider.DoTraceMessage(1,testFmtStr3,decimal_v,decimal_v,decimal_v);break;
								case 4:MyProvider.DoTraceMessage(1,testFmtStr4,decimal_v,decimal_v,decimal_v,decimal_v);break;
								case 5:MyProvider.DoTraceMessage(1,testFmtStr5,decimal_v,decimal_v,decimal_v,decimal_v, decimal_v);break;
								case 6:MyProvider.DoTraceMessage(1,testFmtStr6,decimal_v,decimal_v,decimal_v,decimal_v, decimal_v, decimal_v);break;
								case 7:MyProvider.DoTraceMessage(1,testFmtStr7,decimal_v,decimal_v,decimal_v,decimal_v, decimal_v, decimal_v, decimal_v);break;
								case 8:MyProvider.DoTraceMessage(1,testFmtStr8,decimal_v,decimal_v,decimal_v,decimal_v, decimal_v, decimal_v, decimal_v, decimal_v);break;
							}
						}
					}
				
					
					
				}
			}
		*/
			MyTimer.Stop();
			


			/*

			AvgTime = MyTimer.m_Sum * (1700 * 1000000 / eventCount);
			AvgTime = AvgTime / MyTimer.m_Freq;
			Console.WriteLine("Encoding Scheme [{2} args] : Average Time for {0} calls = {1} Cycles", eventCount, AvgTime, argCount); 
			
			MyTimer.Clear();
			MyTimer.Start();
			for (i=0; i < eventCount; i++) 
			{
				if (MyProvider.enabled) 
				{				
					for(i=0; i < eventCount; i++)
					{
						if (MyProvider.enabled)
						{
							switch(argCount)
							{
								case 1:MyProvider.DoTraceMessage(1,testFmtStr1,((object)decimal_v).ToString());break;
								case 2:MyProvider.DoTraceMessage(1,testFmtStr2,((object)decimal_v).ToString(),((object)decimal_v).ToString());break;
								case 3:MyProvider.DoTraceMessage(1,testFmtStr3,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString());break;
								case 4:MyProvider.DoTraceMessage(1,testFmtStr4,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString());break;
								case 5:MyProvider.DoTraceMessage(1,testFmtStr5,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(), ((object)decimal_v).ToString());break;
								case 6:MyProvider.DoTraceMessage(1,testFmtStr6,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString());break;
								case 7:MyProvider.DoTraceMessage(1,testFmtStr7,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString());break;
								case 8:MyProvider.DoTraceMessage(1,testFmtStr8,((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(),((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString(), ((object)decimal_v).ToString());break;
							}
						}
					}
					
				}
			}
		
			MyTimer.Stop();
			


			
			AvgTime = MyTimer.m_Sum * (1700 * 1000000 / eventCount);
			AvgTime = AvgTime / MyTimer.m_Freq;
			Console.WriteLine("ToString() Scheme [{2} args] : Average Time for {0} calls = {1} Cycles", eventCount, AvgTime, argCount); 
			*/
		}
		Console.WriteLine("Debug Test Complete. Timing Results:");


		AvgTime = MyTimer.Average() / eventCount;
		Console.WriteLine("StartTime {0} EndTime {1} Count {2} Sum {3} Freq {4}", MyTimer.m_Start, MyTimer.m_End, eventCount, MyTimer.m_Sum, MyTimer.m_Freq);

		AvgTime = MyTimer.m_Sum / MyTimer.m_Freq;   // This is in seconds

		AvgTime = MyTimer.m_Sum * (1700 * 1000000 / eventCount);
		AvgTime = AvgTime / MyTimer.m_Freq;
		Console.WriteLine("Done! Average Time for {0} calls = {1} Cycles", eventCount, AvgTime); 

    }

    static void Main(string[] args)
    {
        uint i;
        int eventCount = 10000; 
        int argCount = 0;
        bool testDebug=false;
        bool bString=false;

        try 
        {
            i = 0;
            while (i < args.Length)
            {
                if (args[i] == "-Debug") 
                {
                    testDebug = true;
                }
                else if (args[i] == "-nArg")
                {
                    i++;
                    if (i >= args.Length) return;
                    argCount = System.Convert.ToInt32(args[i]);
                }
                else  if (args[i] == "-bString")
                {
                    bString = true;
                }
                else 
                {
					eventCount = 10000; //default
                    eventCount = System.Convert.ToInt32(args[i]);
                }
                i++;
            }
        }
        catch (Exception e)
        {
            Console.WriteLine("{0} Exception caught.", e);

            Console.WriteLine("Usage: trace [EventCount] [-nArg argCount] [-bString] [-Debug]");
            return;
        }

        if (testDebug)
        {
            DebugTracingSample(eventCount, argCount, bString);
        }
        else 
        {
            Console.WriteLine("PerfTracing with eventCount{0}, argCount {1}, bString {2}", eventCount, argCount, bString);
            PerfTracingSample(eventCount, argCount, bString);
        }

        
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\inc\varg.c ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <conio.h>
#include <tchar.h>
#include <mbctype.h>
#include <strsafe.h>

#include "varg.h"

#define VARG_ARG_PREFIX_LEN     16
#define VARG_TOKEN_LEN          2
#define VARG_VERB_PREFIX_LEN    4

LPTSTR g_strProg;
HANDLE g_hConsole;
WORD g_original;
WORD g_debug;
WORD g_light;
WORD g_dark;
WORD g_normal;
TCHAR g_strVerbPrefix[VARG_VERB_PREFIX_LEN]    = _T("");
TCHAR g_strPrefix[VARG_ARG_PREFIX_LEN]         = _T("-/");
TCHAR g_strArgToken[VARG_TOKEN_LEN]            = _T("`");
SHORT g_X;
SHORT g_Y;
LONG  g_nDebug = -1;

#define COLORIZE( c )   (WORD)((Commands[c].fFlag & (VARG_FLAG_DARKEN|VARG_FLAG_HIDDEN)) ? g_dark : g_normal)
#define HELP_INDENT     32

#define COPY_RESOURCE( dest, src, c )                               \
if( IsEmpty( src ) || _tcscmp( src, c )==0 ){                       \
    ASSIGN_STRING( dest, NULL );                                    \
}else{                                                              \
    ASSIGN_STRING( dest, src );                                     \
}                                                                   \

#define OOM( p ) if(NULL == p){ PrintError( E_OUTOFMEMORY ); FreeCmd(); exit(ERROR_OUTOFMEMORY); }

BOOL varg_strlen( LPTSTR str, ULONG* pVisualSize, ULONG* pAcutalSize );
void PrintParam( int idPrompt, int cmd, BOOL bEOL );
BOOL FindString( LPTSTR strBuffer, LPTSTR strMatch );

int varg_vprintf( WORD color, LPCTSTR mask, va_list args )
{
    DWORD dwPrint;
    HANDLE hOut;
    BOOL bResult;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if( INVALID_HANDLE_VALUE == hOut ){
        return 0;
    }

    bResult = SetConsoleTextAttribute( g_hConsole, color );
    ASSERT( bResult );

    __try {
        LPTSTR buffer = NULL;
        dwPrint = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING, 
                        mask, 
                        0, 
                        0, 
                        (LPTSTR)&buffer, 
                        4096, 
                        &args 
                    );

        if( NULL != buffer ){
            ULONG len, temp;
            if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
                bResult = WriteConsole( hOut, buffer, dwPrint, &dwPrint, NULL );
                ASSERT( bResult );
            }else{
                LPSTR  szAnsiBuffer = NULL;

                szAnsiBuffer = (LPSTR)VARG_ALLOC( (dwPrint+1) * sizeof(WCHAR) );
                if( NULL != szAnsiBuffer ){
                    if( CharToOem( buffer, szAnsiBuffer ) ){
                        bResult = WriteFile( hOut, szAnsiBuffer, strlen( szAnsiBuffer ), &temp, NULL );
                        ASSERT( bResult );
                    }
                }                
                VARG_FREE( szAnsiBuffer );
            }

            if( varg_strlen( buffer, &len, NULL ) ){
                dwPrint = len;
            }


            LocalFree( buffer );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
       FreeCmd();
       exit(E_UNEXPECTED);
    }
    
    bResult = SetConsoleTextAttribute( g_hConsole, g_original );
    ASSERT( bResult );
    
    return (int)dwPrint;
}

int varg_printf( WORD color, LPCTSTR mask, ... )
{
    int nPrint;

    va_list args;
    va_start( args, mask );

    nPrint = varg_vprintf( color, mask, args );

    va_end( args );

    return nPrint;
}

_inline 
BOOL IsArg( LPTSTR str )
{
    int i;
    if( str == NULL ){
        return FALSE;
    }
    for( i=0;i<g_strPrefix[i] != _T('\0');i++){
        if( str[0] == g_strPrefix[i] ){
            return TRUE;
        }
    }

    return FALSE;
}

_inline
BOOL IsCmd( PVARG_RECORD arg, LPTSTR str, BOOL bIni )
{
    BOOL bNegated = FALSE;

    if( !bIni ){
        if( IsArg(str) ){
            str++;
        }else{
            if( arg->fFlag & VARG_FLAG_NOFLAG ){
                if( arg->bDefined ){
                    return FALSE;
                }else{
                    return TRUE;
                }
            }
            if( !( (arg->fFlag & VARG_FLAG_VERB) || (arg->fFlag & VARG_FLAG_ADVERB)) ){
                return FALSE;
            }
        }
    }
    
    if( str[0] == _T('-') ){
        bNegated = TRUE;
        str++;
    }

    if( ( arg->strArg1 != NULL && !_tcsicmp( str, arg->strArg1 ) ) ||
        ( arg->strArg2 != NULL && !_tcsicmp( str, arg->strArg2 ) ) ){

        if( arg->fFlag & VARG_FLAG_NEGATE ){
            arg->bNegated = bNegated;
        }
        
        return TRUE;
    }
    
    return FALSE;
}

_inline
BOOL ArgExpected( PVARG_RECORD arg )
{
    switch(arg->fType){
    case VARG_TYPE_BOOL:
    case VARG_TYPE_HELP:
        return FALSE;
    }

    return TRUE;
}

_inline
BOOL
IsEmpty( LPTSTR str )
{
    if( str == NULL ){
        return TRUE;
    }
    if( *str == _T('\0') ){
        return TRUE;
    }
    return FALSE;
}

_inline BOOL 
IsCharWhitespace( TCHAR ch )
{
    switch( ch ){
    case _T(' '):
    case _T('\r'):
    case _T('\n'):
    case _T('\t'):
        return TRUE;
    default:
        return FALSE;
    }
}

_inline
BOOL
IsDBCSCodePage()
{
    switch (GetConsoleOutputCP()) {
    case 932:
    case 936:
    case 949:
    case 950:
        return TRUE;
    default:
        return FALSE;
    }
}

LPTSTR varg_strdup( LPTSTR src )
{
    HRESULT hr = S_OK;

    LPTSTR dest = NULL;

    if( !IsEmpty(src) ){
        DWORD dwSize = (_tcslen(src)+2)*sizeof(TCHAR);
        dest = (LPTSTR)VARG_ALLOC( dwSize );
        if( NULL != dest ){
            ZeroMemory( dest, dwSize );
            hr = StringCbCopy( dest, dwSize, src );
        }
    }else{
        DWORD dwSize = 2*sizeof(TCHAR);
        dest = (LPTSTR)VARG_ALLOC( dwSize );
        if( NULL != dest ){
            hr = StringCbCopy( dest, dwSize, _T("") );
        }
    }
    
    if( FAILED(hr) ){
        VARG_FREE(dest);
        dest = NULL;
    }

    return dest;
}

BOOL
varg_cmdIsString( int id )
{
    BOOL bResult = FALSE;

    __try{
        if( Commands[id].fType == VARG_TYPE_STR || 
            Commands[id].fType == VARG_TYPE_MSZ || 
            Commands[id].fType == VARG_TYPE_INI ){

            bResult = TRUE;
        }
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        bResult = FALSE;
    }

    return bResult;
}

DWORD 
varg_cmdStringAssign( int id, LPTSTR src )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    __try{
    
        if( varg_cmdIsString( id ) ){
            if( Commands[id].fFlag & VARG_FLAG_ALLOCSTR ){
                varg_cmdStringFree( id );
            }

            Commands[id].strValue = varg_strdup( src );
        
            if( NULL == Commands[id].strValue ){
                dwStatus = ERROR_OUTOFMEMORY;
            }else{
                Commands[id].fFlag |= VARG_FLAG_ALLOCSTR;
                Commands[id].fFlag &= ~VARG_FLAG_DODEFAULT;
                Commands[id].fFlag &= ~VARG_FLAG_RCDEFAULT;
            }
        }else{
            dwStatus = ERROR_INVALID_PARAMETER;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    
    return dwStatus;
}

DWORD
varg_cmdStringFree( int id )
{
    if( varg_cmdIsString( id ) ){
        if( Commands[id].fFlag & VARG_FLAG_ALLOCSTR  ){
            VARG_FREE( Commands[id].strValue );
        }
        Commands[id].fFlag &= ~VARG_FLAG_ALLOCSTR;
        Commands[id].strValue = NULL;
    }

    return ERROR_SUCCESS;
}

DWORD 
varg_cmdStringAddMsz( int id, LPTSTR src )
{
    if( varg_cmdIsString( id ) ){
        if( !(Commands[id].fFlag & VARG_FLAG_ALLOCSTR) ){
            Commands[id].strValue = varg_strdup( Commands[id].strValue );
        }
        AddStringToMsz( &Commands[id].strValue, src );
        Commands[id].fFlag |= VARG_FLAG_ALLOCSTR;
    }

    return ERROR_SUCCESS;
}

LPWSTR
PaddedString(
    LPWSTR sz,
    LPWSTR buffer,
    ULONG  cchBufferSize,
    ULONG  cchPadSize
    )
{
    HRESULT hr = S_OK;
    ULONG visual, actual;

    if( _tcslen( sz ) < cchPadSize ){
        
        hr = StringCchCopy( buffer, cchBufferSize, sz );

        varg_strlen( sz, &visual, &actual );

        while( visual < cchPadSize ){
            hr = StringCchCat( buffer, cchBufferSize, _T(" ") );
            visual++;
        }

        return buffer;
    }else{
        return sz;
    }
}

void Chomp(LPTSTR pszLine)
{
    size_t lLen;
    LPTSTR pszLineEnd;
    
    if( pszLine == NULL ){
        return;
    }

    lLen = _tcslen(pszLine);

    pszLineEnd = pszLine + lLen - 1;

    while( pszLineEnd >= pszLine && 
          (*pszLineEnd == _T(' ') || 
          *pszLineEnd == _T('\r') || 
          *pszLineEnd == _T('\n') || 
          *pszLineEnd == _T('\t')) ){
    
        pszLineEnd--; 
    }

    pszLineEnd++;

    if (*pszLineEnd == _T(' ') || *pszLineEnd == _T('\n') || *pszLineEnd == _T('\t') ){
       *pszLineEnd = _T('\0');
    }
}

DWORD
ReadLong( LPTSTR strNumber, ULONG* pulNumber, ULONG nMax )
{
    HRESULT hr = S_OK;
    LPTSTR strBuffer = NULL;
    ULONG nValue;
    DWORD dwStatus = ERROR_INVALID_PARAMETER;

    if( NULL == strNumber ){
        *pulNumber = 0;
        dwStatus = ERROR_SUCCESS;
    }else{

        strBuffer = varg_strdup( strNumber );
        
        if( NULL == strBuffer ){
            dwStatus = ERROR_OUTOFMEMORY;
        }else{
            LPTSTR strEnd;
            LPTSTR strBegin;
            size_t count = _tcslen( strBuffer )+1;

            nValue = (ULONG)_tcstod( strNumber, &strEnd );
            hr = StringCchPrintf( strBuffer, count, _T("%lu"), nValue );

            if( SUCCEEDED(hr) ){
                strBegin = strNumber;
                while( *strBegin == _T('0') && (strEnd - strBegin) > 1 ){ strBegin++; }
                count = (size_t)(strEnd - strBegin);
           
                if( (_tcsnicmp( strBuffer, strBegin, count ) == 0) ){
                    if( nValue <= nMax ){
                        *pulNumber = nValue;
                        dwStatus = ERROR_SUCCESS;
                    }
                }
            }
        }
    }

    VARG_FREE( strBuffer );

    return dwStatus;
}

void SetUpColors()
{
    CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
    HKEY hkey = NULL;
    HRESULT hr;
    DWORD dwColorize = 0;
    g_hConsole = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleScreenBufferInfo( g_hConsole, &ConsoleInfo );
    
    g_original = ConsoleInfo.wAttributes;
    g_X = (SHORT)(ConsoleInfo.srWindow.Right - ConsoleInfo.srWindow.Left);
    g_Y = (SHORT)(ConsoleInfo.srWindow.Bottom - ConsoleInfo.srWindow.Top);

    hr = RegOpenKeyExW (
                HKEY_CURRENT_USER,
                L"Console",
                0,
                KEY_QUERY_VALUE,
                &hkey 
           );
    if( ERROR_SUCCESS == hr ){
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        hr = RegQueryValueExW (
                    hkey,
                    L"Colorize",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwColorize,
                    &dwSize
                );
    }

    if( ERROR_SUCCESS == hr ){
        if( dwColorize == 0xff ){
            g_normal = ConsoleInfo.wAttributes;
            g_light = (USHORT)(ConsoleInfo.wAttributes | FOREGROUND_INTENSITY);
            g_debug = (USHORT)((ConsoleInfo.wAttributes & 0xF0) | FOREGROUND_INTENSITY | FOREGROUND_RED);
            g_dark = (USHORT)((ConsoleInfo.wAttributes & 0xF0) | FOREGROUND_INTENSITY);
        }else{
            g_normal = (USHORT)(dwColorize & 0x000000FF);
            g_debug = (USHORT)((dwColorize & 0x0000FF00) >> 8);
            g_light = (USHORT)((dwColorize & 0x00FF0000) >> 16);
            g_dark =  (USHORT)((dwColorize & 0xFF000000) >> 24);
        }
    }else{
        g_normal = ConsoleInfo.wAttributes;
        g_debug = g_normal;
        g_light = g_normal;
        g_dark =  g_normal;
    }

    if((g_dark & 0xF) == ((g_dark >> 4) & 0xF)) {
        g_dark = g_normal;
    }

    if((g_light & 0xF) == ((g_light >> 4) & 0xF)) {
        g_light = g_normal;
    }

    if((g_debug & 0xF) == ((g_debug >> 4) & 0xF)) {
        g_debug = g_normal;
    }

    if( NULL != hkey ){
        RegCloseKey ( hkey );
    }
}

void FreeCmd()
{
    int i;
    
    DWORD dwStatus = ERROR_SUCCESS;
    
        
        for(i=0;Commands[i].fType != VARG_TYPE_LAST;i++){
            Commands[i].bDefined = FALSE;
            __try{

                if( varg_cmdIsString( i ) ){
                    varg_cmdStringFree( i );
                }

                if( Commands[i].strArg1 != NULL ){
                    VARG_FREE( Commands[i].strArg1  );
                }
                
                if( Commands[i].strArg2 != NULL ){
                    VARG_FREE( Commands[i].strArg2  );
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                dwStatus = ERROR_INVALID_PARAMETER;
            }
        }


    SetConsoleTextAttribute( g_hConsole, g_original );
}

void LoadCmd()
{
    HRESULT hr;
    int i;
    TCHAR buffer[MAXSTR];
    TCHAR param[MAXSTR];

    i = LoadString( NULL, IDS_ARG_TOKEN, buffer, VARG_TOKEN_LEN );
    if( i>0 && i <= VARG_TOKEN_LEN ){
        _tcsncpy( g_strArgToken, buffer, i );
    }

    i =  LoadString( NULL, IDS_ARG_PREFIX, buffer, VARG_ARG_PREFIX_LEN );
    if( i>0 && i <= VARG_ARG_PREFIX_LEN ){
        _tcsncpy( g_strPrefix, buffer, i );
    }
    
    i = LoadString( NULL, IDS_VERB_PREFIX, buffer, VARG_VERB_PREFIX_LEN );
    if( i>0 && i <= VARG_VERB_PREFIX_LEN){
        _tcsncpy( g_strVerbPrefix, buffer, i );
    }

    for( i=0; Commands[i].fType!=VARG_TYPE_LAST; i++ ){

        LPTSTR strArg1;
        LPTSTR strArg2;
        LPTSTR strParam;
        LPTSTR strHelp;

        LoadString( NULL, Commands[i].idParam, param, MAXSTR );

        strArg1 = _tcstok( param, g_strArgToken );
        strArg2 = _tcstok( NULL, g_strArgToken );
        strParam = _tcstok( NULL, g_strArgToken );
        strHelp = _tcstok( NULL, g_strArgToken );

        COPY_RESOURCE( Commands[i].strArg1, strArg1, _T("*") );
        COPY_RESOURCE( Commands[i].strArg2, strArg2, _T("*") );
        
        if( Commands[i].fFlag & VARG_FLAG_ARG_DATE ){
            TCHAR strDate[80];
            TCHAR strTime[80];
            TCHAR strAM[4];
            TCHAR strPM[4];

            GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, strDate, 80 );
            GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIMEFORMAT, strTime, 80 );
            if( !GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S1159, strAM, 4 ) ){
                strAM[0] = _T('\0');
            }
            if( !GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S2359, strPM, 4 ) ){
                strPM[0] = _T('\0');
            }
            _tcstok( strTime, _T(" ") );
            if( _tcslen( strAM ) && _tcslen(strPM) ){
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    hr = StringCchPrintf( buffer, MAXSTR, _T("[%s %s[%s|%s]]"), strDate, strTime, strAM, strPM );
                }else{
                    hr = StringCchPrintf( buffer, MAXSTR, _T("<%s %s[%s|%s]>"), strDate, strTime, strAM, strPM );
                }
            }else{
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    hr = StringCchPrintf( buffer, MAXSTR, _T("[%s %s]"), strDate, strTime );
                }else{
                    hr = StringCchPrintf( buffer, MAXSTR, _T("<%s %s>"), strDate, strTime );
                }
            }
            COPY_RESOURCE( Commands[i].strParam, buffer, _T("*") );

        }else{
            if( Commands[i].fFlag & VARG_FLAG_ARG_DEFAULT ){
                LoadString( NULL, IDS_ARG_DEFAULT, param, MAXSTR );
                strParam = param;
            }else if( Commands[i].fFlag & VARG_FLAG_ARG_FILENAME ){
                LoadString( NULL, IDS_ARG_FILENAME, param, MAXSTR );
                strParam = param;
            }else if( Commands[i].fFlag & VARG_FLAG_ARG_TIME ){
                LoadString( NULL, IDS_ARG_TIME, param, MAXSTR );
                strParam = param;
            }
            if( strParam != NULL && _tcslen( strParam ) && _tcscmp( strParam, _T("*") ) ){
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    if( Commands[i].fType == VARG_TYPE_MSZ && !(Commands[i].fFlag & VARG_FLAG_FLATHELP) ){
                        hr = StringCchPrintf( buffer, MAXSTR, _T("[%s [%s ...]]"), strParam, strParam );
                    }else{
                        hr = StringCchPrintf( buffer, MAXSTR, _T("[%s]"), strParam );
                    }
                }else{
                    if( Commands[i].fType == VARG_TYPE_MSZ && !(Commands[i].fFlag & VARG_FLAG_FLATHELP)){
                        hr = StringCchPrintf( buffer, MAXSTR, _T("<%s [%s ...]>"), strParam, strParam );
                    }else{
                        hr = StringCchPrintf( buffer, MAXSTR, _T("<%s>"), strParam );
                    }
                }
                COPY_RESOURCE( Commands[i].strParam, buffer, _T("*") );
            }else{
                strParam = NULL;
                COPY_RESOURCE( Commands[i].strParam, strParam, _T("*") );
            }
        }
    }
}

ULONG MszStrLen( LPTSTR mszBuffer )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPTSTR strScan = mszBuffer;
    ULONG  nTermSize = sizeof(TCHAR) * 2;

    while( strScan != NULL && *strScan != _T('\0') ){
        nLength = (_tcslen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
    
    return (nTotalLength*sizeof(TCHAR) + nTermSize);
}

HRESULT
AddStringToMsz( LPTSTR* mszBuffer, LPTSTR strValue )
{
    size_t  cbNewDataSize = 0;
    size_t  cbOldDataSize = 0;
    size_t  cbTotalDataSize = 0;
    LPTSTR strScan = *mszBuffer;
    LPTSTR mszNewBuffer;
    ULONG nLength;

    if( IsEmpty( strValue ) ){
        return ERROR_SUCCESS;
    }

    if( strScan != NULL ){
        while( *strScan != _T('\0') ){
            nLength = (_tcslen( strScan )+1);
            strScan += nLength;
            cbOldDataSize += nLength * sizeof(TCHAR);
        }
    }

    cbNewDataSize = ( _tcslen( strValue )+1 ) * sizeof(TCHAR);
    
    cbTotalDataSize = cbOldDataSize + cbNewDataSize + (sizeof(TCHAR)*2);

    mszNewBuffer = (LPTSTR)VARG_ALLOC( cbTotalDataSize );

    if( NULL == mszNewBuffer ){
        return ERROR_OUTOFMEMORY;
    }

    ZeroMemory( mszNewBuffer, cbTotalDataSize );

    if( cbOldDataSize ){
        memcpy( mszNewBuffer, *mszBuffer, cbOldDataSize );
        memcpy( (((PUCHAR)mszNewBuffer) + cbOldDataSize), strValue, cbNewDataSize );

        //
        // Zero the old memory block in case it 
        // contained sensitive information
        //

        ZeroMemory( *mszBuffer, cbOldDataSize );

    }else{
        memcpy( mszNewBuffer, strValue, cbNewDataSize );
    }

    VARG_FREE( *mszBuffer );
    
    *mszBuffer = mszNewBuffer;
    
    return ERROR_SUCCESS;
}

void ParseIni( LPTSTR strFile )
{
    HRESULT hr;
    TCHAR buffer[MAXSTR];
    FILE* f;
    LPTSTR str;
    TCHAR strCmd[MAXSTR];
    LPTSTR strValue;
    BOOL bFound;
    int i;
    
    ZeroMemory( strCmd, MAXSTR*sizeof(TCHAR) );

    if( strFile == NULL || _tcslen( strFile ) == 0 ){
        return;
    }
    
    f = _tfopen( strFile, _T("r") );
    if( NULL == f ){
        return;
    }
    while( _fgetts( buffer, MAXSTR, f ) ){  
        
        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){

            continue;
        }
        
        Chomp( buffer );

        if( IsEmpty( buffer ) ){
            continue;
        }

        if( buffer[0] == _T('[') || _tcsstr( buffer, _T("=") ) ){
            str = _tcstok( buffer, _T("[]\n\t=") );
            if( str != NULL ){
                hr = StringCchCopy( strCmd, MAXSTR, str );
                strValue = _tcstok( NULL, _T("]=\n ") );
            }else{
                strCmd[0] = _T('\0');
                strValue = NULL;
            }
        }else{
            strValue = _tcstok( buffer, _T("\n") );
        }
        
        bFound = FALSE;

        //
        // Check to see if it is a parameter that does not take a value
        //
        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++ ){
            if( IsCmd( &Commands[i], strCmd, TRUE ) ){
                switch( Commands[i].fType ){
                case VARG_TYPE_HELP:
                    bFound = TRUE;
                    break;
                case VARG_TYPE_BOOL:
                    bFound = TRUE;
                    Commands[i].bValue = Commands[i].bValue ? FALSE : TRUE;
                    break;
                }
                if( bFound ){
                    Commands[i].bDefined = TRUE;

                    if( Commands[i].bDefined && Commands[i].fntValidation != NULL ){
                        Commands[i].fntValidation(i);
                    }
                }
            }
        }

        if( bFound || strValue == NULL || _tcslen( strCmd ) == 0 ){
            continue;
        }

        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++ ){
            if( IsCmd( &Commands[i], strCmd, TRUE ) ){

                bFound = TRUE;
                if( Commands[i].bDefined && Commands[i].fType != VARG_TYPE_MSZ ){
                    continue;
                }

                switch( Commands[i].fType ){
                case VARG_TYPE_DEBUG:
                case VARG_TYPE_INT:
                    {
                        ULONG nValue;
                        if( ERROR_SUCCESS == ReadLong( strValue, &nValue, MAXLONG ) ){
                            Commands[i].nValue = nValue;
                            if( Commands[i].fType == VARG_TYPE_DEBUG ){
                                g_nDebug = nValue;
                            }
                        }
                    }
                    break;
                case VARG_TYPE_MSZ:
                    if( !Commands[i].bDefined ){
                        Commands[i].strValue = NULL;
                    }
                    if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                        Chomp( strValue );
                    }
                    varg_cmdStringAddMsz( i, strValue );
                    break;
                case VARG_TYPE_STR:
                    if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                        Chomp( strValue );
                    }
                    varg_cmdStringAssign( i, strValue );
                    break;
                case VARG_TYPE_TIME:
                case VARG_TYPE_DATE:
                    ParseTime( strValue, &Commands[i].stValue, (Commands[i].fType == VARG_TYPE_DATE) );
                    break;
                }

                Commands[i].bDefined = TRUE;

                if( Commands[i].bDefined && Commands[i].fntValidation != NULL ){
                    Commands[i].fntValidation(i);
                }

            }
        }
    }

    fclose(f);
}

void ParseCmd(int argc, LPTSTR argv[] )
{
    int i;
    BOOL bFound;
    BOOL bHelp = FALSE;
    BOOL bBadSyntax = FALSE;

    int nIniIndex = (-1);
    
    VSetThreadUILanguage(0);

    VArgDeclareFormat();
    LoadCmd();
    SetUpColors();

    g_strProg = argv[0];
    argv++;argc--;

    while( argc > 0 ){
        
        bFound = FALSE;

        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++){
            
            if( IsCmd( &Commands[i], argv[0], FALSE ) ){

                if(Commands[i].bDefined){
                    PrintMessage( g_debug, IDS_MESSAGE_ARG_DUP, Commands[i].strArg1, argv[0] );
                    bBadSyntax = TRUE;
                }

                if( IsArg( argv[0] ) || Commands[i].fFlag & VARG_FLAG_VERB || Commands[i].fFlag & VARG_FLAG_ADVERB ){
                    argv++;argc--;
                }

                bFound = TRUE;

                Commands[i].bDefined = TRUE;

                switch( Commands[i].fType ){
                case VARG_TYPE_HELP:
                    Commands[i].bValue = TRUE;
                    bHelp = TRUE;
                    break;
                case VARG_TYPE_DEBUG:
                    Commands[i].fFlag |= VARG_FLAG_DEFAULTABLE;
                    g_nDebug = Commands[i].nValue;
                case VARG_TYPE_INT:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        ULONG nValue;
                        HRESULT hr = ReadLong( argv[0], &nValue, MAXLONG );
                        if( ERROR_SUCCESS == hr ){
                            Commands[i].nValue = nValue;   
                        }else{
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                        if( Commands[i].fType == VARG_TYPE_DEBUG ){
                            g_nDebug = Commands[i].nValue;
                        }
                        argv++;argc--;
                    }else if( !(Commands[i].fFlag & VARG_FLAG_DEFAULTABLE) ){
                        if( !Commands[i].bNegated ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                    }
                    break;
                case VARG_TYPE_BOOL:
                    Commands[i].bValue = Commands[i].bValue ? FALSE : TRUE;
                    break;
                case VARG_TYPE_MSZ:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        Commands[i].fFlag &= ~VARG_FLAG_RCDEFAULT;
                        varg_cmdStringAssign( i, argv[0] );
                        OOM( Commands[i].strValue );
                        argv++;argc--;
                        while( argc > 0 && ! IsArg( argv[0] ) ){
                            if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                                Chomp( argv[0] );
                            }
                            varg_cmdStringAddMsz( i, argv[0] );
                            argv++;argc--;
                        }
                    }else if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE || Commands[i].bNegated ){
                        Commands[i].fFlag |= VARG_FLAG_DODEFAULT;
                    }else{
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                    }
                    break;
                case VARG_TYPE_INI:
                    nIniIndex = i;
                case VARG_TYPE_STR:
                    if( argc > 0 && ! IsArg( argv[0] ) ){
                        if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                            Chomp( argv[0] );
                        }
                        Commands[i].fFlag &= ~VARG_FLAG_RCDEFAULT;
                        varg_cmdStringAssign( i, argv[0] );
                        argv++;argc--;
                    }else if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE || Commands[i].bNegated ){
                        Commands[i].fFlag |= VARG_FLAG_DODEFAULT;
                    }else{
                        if( !(Commands[i].fFlag & VARG_FLAG_NEGATE) ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                    }
                    break;
                case VARG_TYPE_TIME:
                case VARG_TYPE_DATE:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        HRESULT hr;
                        LPTSTR strDate = NULL;
                        LPTSTR strTime = argv[0];
                        argv++;argc--;
                        if( Commands[i].fType == VARG_TYPE_DATE ){
                            if( argc > 0 && !IsArg( argv[0] ) ){
                                size_t cbSize = (_tcslen(strTime)+_tcslen(argv[0])+2)*sizeof(TCHAR);

                                strDate = (LPTSTR)VARG_ALLOC( cbSize );
                                if( NULL != strDate ){
                                    hr = StringCbPrintf( strDate, cbSize, _T("%s %s"), strTime, argv[0] );
                                    strTime = strDate;
                                }
                                argv++;argc--;
                            }
                        }

                        hr = ParseTime( strTime, &Commands[i].stValue, (Commands[i].fType == VARG_TYPE_DATE) );
                        if( ERROR_SUCCESS != hr ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                        VARG_FREE( strDate );
                    }else if( !(Commands[i].fFlag & VARG_FLAG_DEFAULTABLE) && !(Commands[i].bNegated) ){
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                    }
                }
            }
        }

        if (!bFound){
            PrintMessage( g_debug, IDS_MESSAGE_UNKNOWNPARAM, (*(argv)));
            argv++;argc--;
            bBadSyntax = TRUE;
        }

    }

    if( nIniIndex >= 0 ){
        if( Commands[nIniIndex].fType == VARG_TYPE_INI && Commands[nIniIndex].bDefined ){
            ParseIni( Commands[nIniIndex].strValue );
        }
    }

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){

        if( !bHelp && (Commands[i].bDefined && Commands[i].fntValidation != NULL ) ){
            Commands[i].fntValidation(i);
        }
        
        if( Commands[i].fFlag & VARG_FLAG_RCDEFAULT ||
            (( Commands[i].fType == VARG_TYPE_STR || 
            Commands[i].fType == VARG_TYPE_MSZ || 
            Commands[i].fType == VARG_TYPE_INI ) && 
            (!Commands[i].bDefined || Commands[i].fFlag & VARG_FLAG_DODEFAULT )) ){
        
            TCHAR buffer[MAXSTR];
            
            Commands[i].fFlag &= ~VARG_FLAG_DODEFAULT;
            if( Commands[i].fFlag & VARG_FLAG_RCDEFAULT ){
                LoadString( NULL, Commands[i].nValue, buffer, MAXSTR );
                varg_cmdStringAssign( i, buffer );
                OOM( Commands[i].strValue );
            }
        }

        if( Commands[i].bDefined && Commands[i].fFlag & VARG_FLAG_EXPANDFILES ){
            Commands[i].fFlag |= VARG_FLAG_ALLOCSTR;
            ExpandFiles( &Commands[i].strValue, (Commands[i].fType == VARG_TYPE_MSZ) );
        }

    }

    if( bHelp ){
        DisplayCommandLineHelp();
    }

    if( g_nDebug >= 0 ){
        DisplayDebugInfo();
    }

    if( ERROR_SUCCESS != ValidateCommands() || bBadSyntax ){
        PrintMessage( g_debug, IDS_MESSAGE_INCORRECT );
        FreeCmd();
        exit(ERROR_BAD_FORMAT);
    }
}

void
DisplayIniInfo()
{
    int i;
    int nOut;
    BOOL bOpt;
    PrintMessage( g_normal, IDS_MESSAGE_INISYNT );
    for( i=0;i<35;i++){ varg_printf( g_normal, _T("-") ); }
    varg_printf( g_normal,  _T("\n") );
    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){

        if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
            continue;
        }

        bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );

        switch( Commands[i].fType ){
        case VARG_TYPE_DEBUG:
        case VARG_TYPE_BOOL:
        case VARG_TYPE_MSZ:
        case VARG_TYPE_STR:
        case VARG_TYPE_INT:
        case VARG_TYPE_TIME:
        case VARG_TYPE_DATE:
            nOut = varg_printf( g_normal,  
                            _T("  %1!-20s! %2!-20s!\n"), 
                            Commands[i].strArg1, bOpt ? 
                            Commands[i].strArg2 : _T("") 
                        );
            break;
        }
    }
    varg_printf( g_normal,  _T("\n") );
}

void
DisplayDebugInfo()
{
    int i;
    int nOut;
    TCHAR strDefault[MAXSTR] = _T("");

    LoadString( NULL, IDS_MESSAGE_DEFAULT, strDefault, MAXSTR );

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( !(Commands[i].bDefined) && g_nDebug < 1 ){
            continue;
        }
        if( Commands[i].fType == VARG_TYPE_HELP ){
            continue;
        }
        if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
            continue;
        }
        nOut = varg_printf( g_debug,  _T("%1!-16s! = "), Commands[i].strArg1 );
        switch( Commands[i].fType ){
        case VARG_TYPE_DEBUG:
        case VARG_TYPE_INT:
            varg_printf( g_debug,  _T("%1!-20lu!"), Commands[i].nValue );
            break;
        case VARG_TYPE_BOOL:
            varg_printf( g_debug,  _T("%1!-20s!"),
                Commands[i].bValue ? _T("TRUE") : _T("FALSE")
                );
            break;
        case VARG_TYPE_MSZ:
            if( !IsEmpty( Commands[i].strValue ) ){
                LPTSTR strValue = Commands[i].strValue;
                while( *strValue != _T('\0') ){
                    if( strValue == Commands[i].strValue ){
                        varg_printf( g_debug,  _T("%1!-20s!"), strValue );
                    }else{
                        varg_printf( g_debug,  _T("\n%1!19s!%2!-20s!"), _T(" "), strValue );
                    }
                    strValue += (_tcslen( strValue )+1);
                }
            }else{
                varg_printf( g_debug,  _T("%1!-20s!"), _T("-") );
            }
            break;
        case VARG_TYPE_TIME:
        case VARG_TYPE_DATE:
            {
                nOut = PrintDateEx( g_debug, &Commands[i].stValue );
                while( nOut++ < 20 ) { varg_printf( g_debug, _T(" ") ); }
            }
            break;
        case VARG_TYPE_INI:
        case VARG_TYPE_STR:
            varg_printf( g_debug,  _T("%1!-20s!"),
                (Commands[i].strValue == NULL || !(_tcslen(Commands[i].strValue)) ) ? 
                _T("-") : Commands[i].strValue
                );
            break;
        }
        if( !Commands[i].bDefined ){
            varg_printf( g_debug, _T(" (%1!s!)"), strDefault );
        }
        varg_printf( g_debug,  _T("\n") );
       
    }
    varg_printf( g_debug,  _T("\n") );
}

int PrintMessage( WORD color, LONG id, ... )
{
    int nLoad;
    TCHAR buffer[MAXSTR];
    va_list args;

    va_start( args, id );
    
    nLoad = LoadString( NULL, id, buffer, MAXSTR );
    
    if( nLoad > 0 ){
        nLoad = varg_vprintf( color, buffer, args );
    }else{
        nLoad = FormatMessage( 
                        FORMAT_MESSAGE_FROM_HMODULE, 
                        GetModuleHandle(NULL), 
                        id, 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                        buffer, 
                        MAXSTR, 
                        &args 
                    );
        varg_printf( color, buffer );
    }
    
    return nLoad;
}

/***************************************************************************\

  IsFullWidth

  Determine if the given Unicode char is fullwidth or not.

  
  04-08-1992 ShunK    Created.
  
  07-11-1995 FloydR   Modified to be Japanese aware, when enabled for
                      other DBCS languages.  Note that we could build
                      KOREA/TAIWAN/PRC w/o this code, but we like single
                      binary solutions.
  
  10-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and 
                      WideCharToMultiByte because 950 only defined 
                      13500 chars, and unicode defined almost 18000 chars.
                      So there are almost 4000 chars can not be mapped to 
                      big5 code.
  
  07-27-2001 CoreyM   Stolen from base\cmd for string wrapping

\***************************************************************************/

BOOL IsFullWidth(TCHAR wch)
{
    if (0x20 <= wch && wch <= 0x7e)
        /* ASCII */
        return FALSE;
    else if (0x3000 <= wch && wch <= 0x3036)
        /* CJK Symbols and Punctuation */
        return TRUE;
    else if (0x3041 <= wch && wch <= 0x3094)
        /* Hiragana */
        return TRUE;
    else if (0x30a1 <= wch && wch <= 0x30fe)
        /* Katakana */
        return TRUE;
    else if (0x3105 <= wch && wch <= 0x312c)
        /* Bopomofo */
        return TRUE;
    else if (0x3131 <= wch && wch <= 0x318e)
        /* Hangul Elements */
        return TRUE;
    else if (0x3200 <= wch && wch <= 0x32ff)
        /* Enclosed CJK Letters and Ideographics */
        return TRUE;
    else if (0x3300 <= wch && wch <= 0x33fe)
        /* CJK Squared Words and Abbreviations */
        return TRUE;
    else if (0xac00 <= wch && wch <= 0xd7a3)
        /* Korean Hangul Syllables */
        return TRUE;
    else if (0xe000 <= wch && wch <= 0xf8ff)
        /* EUDC */
        return TRUE;
    else if (0xff01 <= wch && wch <= 0xff5e)
        /* Fullwidth ASCII variants */
        return TRUE;
    else if (0xff61 <= wch && wch <= 0xff9f)
        /* Halfwidth Katakana variants */
        return FALSE;
    else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)   )
        /* Halfwidth Hangule variants */
        return FALSE;
    else if (0xffe0 <= wch && wch <= 0xffe6)
        /* Fullwidth symbol variants */
        return TRUE;
    else if (0x4e00 <= wch && wch <= 0x9fa5)
        /* CJK Ideographic */
        return TRUE;
    else if (0xf900 <= wch && wch <= 0xfa2d)
        /* CJK Compatibility Ideographs */
        return TRUE;
    else if (0xfe30 <= wch && wch <= 0xfe4f) {
        /* CJK Compatibility Forms */
        return TRUE;
    }

    else
        /* Unknown character */
        return FALSE;
}

BOOL
varg_strlen( LPTSTR str, ULONG* pVisualLength, ULONG* pActualLength )
{
    ULONG nVisual = 0;
    ULONG nActual = 0;

    if( NULL != str ){
        nActual = _tcslen(str);

        if( NULL != pVisualLength && IsDBCSCodePage() ){
            while (*str) {
                if (IsFullWidth(*str)){
                    nVisual += 2;
                }else{
                    nVisual++;
                }
                str++;
            }
        }else{
            nVisual = nActual;
        }

        if( NULL != pVisualLength ){
            *pVisualLength = nVisual;
        }

        if( NULL != pActualLength ){
            *pActualLength = nActual;
        }

        return TRUE;
    }

    return FALSE;
}

BOOL WrapString( LPTSTR str, ULONG nCol, ULONG* pBreak )
{
    ULONG nVisual = 0;
    ULONG nActual = 0;
    ULONG nBreak = 0;

    *pBreak = 0;

    while( *str ){
        nActual++;
        if( IsFullWidth( *str ) ){
            nVisual += 2;
            if( nVisual < nCol ){
                nBreak = nActual;
            }
        }else{
            nVisual++;
            if( nVisual < nCol ){
                if( IsCharWhitespace( *str ) ){
                    nBreak = nActual-1;
                    if( *str == _T('\n') ){
                        *pBreak = nBreak;
                        return TRUE;
                    }
                }
            }
        }
        if( nVisual > nCol ){
            if( nBreak ){
                *pBreak = nBreak;
                return TRUE;
            }else{
                return FALSE;
            }
        }
        str++;
    }

    return FALSE;
}

void SetColumn( LONG nStart, LONG nCol )
{
    while( nStart++ < nCol ){
        varg_printf( g_normal, _T(" ") );
    }
}

HRESULT PrintHelpString( LONG id, LONG nStart, LONG nCol, LONG nMax, BOOL bSwitch )
{
    int nLoad;
    TCHAR buffer[MAXSTR];
    LPTSTR strHelp;
    ULONG nWrap;
    
    nMax -= (nMax%2);

    if( nMax <= nCol ){
        nMax = 79;
    }

    nLoad = LoadString( NULL, id, buffer, MAXSTR );
    strHelp = _tcstok( buffer, g_strArgToken );
    
    if( bSwitch ){
        _tcstok( NULL, g_strArgToken );
        _tcstok( NULL, g_strArgToken );
        strHelp = _tcstok( NULL, g_strArgToken );
    }

    if( nStart < nCol ){
        SetColumn( nStart, nCol );
        nWrap = nMax - nCol;
    }else{
        nWrap = nMax - nStart;
    }
    
    if( nLoad > 0 && strHelp != NULL && _tcslen( strHelp ) ){
        
        LPTSTR str;
        ULONG nBreak;
        TCHAR cWrap;
        str = strHelp;
        
        while( *str != _T('\0') ){
            if( WrapString( str, nWrap, &nBreak ) ){
                cWrap = str[nBreak];
                str[nBreak] = _T('\0');
                varg_printf( g_normal, str );
                str[nBreak] = cWrap;
                str += nBreak;
                if( IsCharWhitespace( *str ) ){
                    str++;
                }
                varg_printf( g_normal, _T("\n") );
                SetColumn( 0, nCol );
                nWrap = nMax - nCol;
            }else{
                varg_printf( g_normal, str );
                varg_printf( g_normal, _T("\n") );
                break;
            }
        }  
        
        return ERROR_SUCCESS;
    }
    
    return ERROR_FILE_NOT_FOUND;
}

void DisplayVersionInfo()
{
    HRESULT hr;
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    TCHAR strMicrosoft[512];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR );
    LoadString( NULL, IDS_MESSAGE_MSR, strMicrosoft, 512 );

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)VARG_ALLOC(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        hr = StringCchPrintf( buffer, 512, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        hr = StringCchPrintf( buffer, 512, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        hr = StringCchPrintf( buffer, 512, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        varg_printf( g_normal,  _T("\n%1!s! %2!s! (%3!s!)\n%4!s!\n\n"), strMicrosoft, pProduct, pVersion, pCopyRight );
                    }
                }
                VARG_FREE( pVersionInfo );
            }
        }
    }
}

void
DisplayHelpEx( LONG id )
{
    TCHAR buffer[8];
    DWORD dwSize = 8;

    dwSize = LoadString( NULL, id, buffer, dwSize );
    if( dwSize > 0 ){
        PrintMessage( g_normal, id );
    }
}

void
DisplayCommandLineHelp()
{
    int i,j;
    int nOut;
    BOOL bOpt;
    BOOL bVerbs = FALSE;
    int  nVerbs = 0;
    int  nCommands = 0;
    BOOL bRequired = FALSE;
    int  nConditional = 0;
    int  nDefinedConditional = 0;
    BOOL bFirst = TRUE;
    BOOL bDisplayAll = FALSE;
    DWORD dwVerbMask = 0;
    UCHAR excl1 = 0;
    LPTSTR strNegateHelp = NULL;

    for( i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( (Commands[i].dwSet & VARG_CONDITION) && 
            !(Commands[i].fFlag & VARG_FLAG_VERB) ){
            nConditional++;
            if( Commands[i].bDefined ){
                nDefinedConditional++;
            }
        }
        if( Commands[i].fFlag & VARG_FLAG_VERB ){
            bVerbs = TRUE;
        }

        if( Commands[i].bDefined ){
            if( Commands[i].fFlag & VARG_FLAG_VERB || Commands[i].fFlag & VARG_FLAG_ADVERB){
                nVerbs++;
                dwVerbMask |= (Commands[i].dwVerb & 0x0000FFFF);
                if( Commands[i].dwSet != 0 ){
                    excl1 = (UCHAR)(((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0x0F);
                }
            }else{
                if( Commands[i].fType != VARG_TYPE_HELP && 
                    Commands[i].fType != VARG_TYPE_DEBUG ){
                    nCommands++;
                }
            }
        }
    }
    if( nCommands == 0 && nVerbs == 0 ){
        bDisplayAll = TRUE;
    }
    DisplayVersionInfo();
    
    if( bDisplayAll ){
        if( ERROR_SUCCESS == PrintHelpString( IDS_PROGRAM_DESCRIPTION, 0, 0, g_X, FALSE ) ){
            varg_printf( g_normal,  _T("\n") );
        }
    }
    
    // Usage
    PrintMessage( g_normal, IDS_MESSAGE_USAGE );
    nOut = varg_printf( g_normal,  _T("%1!s! "), g_strProg );
    if( bVerbs ){
        LONG nDispVerbs = 0;
        if( !bDisplayAll ){
            for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
                if( Commands[i].fFlag & VARG_FLAG_VERB && Commands[i].bDefined ){
                    nOut += varg_printf( g_normal,  _T("%1!s! "), Commands[i].strArg1 );
                    nDispVerbs++;
                }
            }
        }
        if( bDisplayAll || !nDispVerbs ){
            nOut += PrintMessage( g_normal,  IDS_MESSAGE_VERB );
        }
    }
    if( nConditional > 1 && nDefinedConditional == 0 ){
        nOut += varg_printf( g_normal,  _T("{ ") );
    }
    for( j=0;j<2;j++){
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( j==0 ){
                // show conditional switches
                if( Commands[i].fFlag & VARG_FLAG_HIDDEN || 
                    Commands[i].fFlag & VARG_FLAG_VERB ||
                    !(Commands[i].dwSet & VARG_CONDITION) ){
                    continue;
                }
                if( nDefinedConditional > 0 && !Commands[i].bDefined ){
                    continue;
                }
            }else{
                // show required switches
                if( Commands[i].fFlag & VARG_FLAG_HIDDEN || 
                    Commands[i].fFlag & VARG_FLAG_VERB ||
                    Commands[i].dwSet & VARG_CONDITION ||
                    Commands[i].fFlag & VARG_FLAG_OPTIONAL ){
                    continue;
                }
            }
            if( (!bFirst) && nConditional && nDefinedConditional == 0 ){
                nOut += varg_printf( g_normal,  _T("| ") );
            }
            bFirst = FALSE;
            if( Commands[i].fFlag & VARG_FLAG_NOFLAG ){
                nOut += varg_printf( g_normal,  _T("%1!s! "), Commands[i].strParam );
            }else{
                nOut += varg_printf( g_normal,  _T("%1!c!%2!s!%3!s!%4!s!%5!s! "), 
                        Commands[i].fFlag&VARG_FLAG_VERB ? g_strVerbPrefix[0] : g_strPrefix[0], 
                        Commands[i].fFlag&VARG_FLAG_NEGATE ? _T("[-]"):_T(""),
                        Commands[i].strArg2, 
                        ArgExpected( &Commands[i] ) ? _T(" "): _T(""), 
                        Commands[i].strParam 
                    );
            }
            if( nOut > (g_X - 15) ){
                nOut = 0;
                varg_printf( g_normal, _T("\n") );
                while( nOut++ < HELP_INDENT){ varg_printf( g_normal, _T(" ") ); }
            }
        }
        if( j == 0 && (nConditional>1) && nDefinedConditional == 0 ){
            varg_printf( g_normal,  _T("} ") );
        }
    }
    PrintMessage( g_normal, IDS_MESSAGE_LINEOPT );

    // Verbs
    if( bVerbs ){
        bFirst = TRUE;
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
                continue;
            }
            if( !(Commands[i].fFlag & VARG_FLAG_VERB ) ){
                continue;
            }
            if( !bDisplayAll && !Commands[i].bDefined ){
                continue;
            }
            if( bFirst ){
                PrintMessage( g_normal, IDS_MESSAGE_VERBS );
                bFirst = FALSE;
            }
            bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );
            nOut = varg_printf( COLORIZE(i),  _T("  %1!s!%2!s! %3!s! "),
                        g_strVerbPrefix,
                        (LPTSTR)(bOpt ? Commands[i].strArg2 : Commands[i].strArg1),
                        Commands[i].strParam
                    );
            if( nOut > HELP_INDENT ){
                nOut += varg_printf( g_normal, _T(" ") );
            }
           
            PrintHelpString( Commands[i].idParam, nOut, HELP_INDENT, g_X, TRUE );
        }
        if( !bFirst ){
            varg_printf( g_normal,  _T("\n") );
        }
    }
    
    // Options
    for(j=0;j<2;j++){
        bFirst = TRUE;
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( j==0 ){
                if( !(Commands[i].fFlag & VARG_FLAG_NOFLAG) ||
                    Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ){
                    continue;
                }
            }else{
                if( Commands[i].fFlag & VARG_FLAG_NOFLAG || 
                    Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ){
                    continue;
                }
            }
            if( ! bDisplayAll && (Commands[i].fType == VARG_TYPE_HELP) ){
                continue;
            }
            if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
                continue;
            }
            if( bDisplayAll || 
                Commands[i].bDefined || 
                (((Commands[i].dwVerb & 0x0000FFFF)& dwVerbMask) && nCommands < 1 )  ){
                UCHAR excl2 = (UCHAR)((((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0xF0) >> 4 );
                if( excl2 & excl1 ){
                    continue;
                }
                if( bFirst ){
                    switch( j ){
                    case 0:
                        PrintMessage( g_normal, IDS_MESSAGE_PARAMETERS );
                        bRequired = TRUE;
                        break;
                    case 1:
                        PrintMessage( g_normal, IDS_MESSAGE_OPTIONS, bRequired ? _T("\n") : _T("") );
                        break;
                    }
                    bFirst = FALSE;
                }
                bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );
                if( Commands[i].fFlag & VARG_FLAG_NOFLAG ){
                    nOut = varg_printf( COLORIZE(i),  _T("  %1!s! "),
                            Commands[i].strParam
                        );
                }else{
                    nOut = varg_printf( COLORIZE(i),  _T("  %1!c!%2!s!%3!s! %4!s! "),
                            g_strPrefix[0],
                            Commands[i].fFlag & VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                            bOpt ? Commands[i].strArg2 : Commands[i].strArg1,
                            Commands[i].strParam
                        );
                }
                if( nOut > HELP_INDENT ){
                    nOut += varg_printf( g_normal, _T("  ") );
                }
                if( Commands[i].fFlag & VARG_FLAG_NEGATE && NULL == strNegateHelp ){
                    strNegateHelp = bOpt ? Commands[i].strArg2 : Commands[i].strArg1;
                }
                PrintHelpString( Commands[i].idParam, nOut, HELP_INDENT, g_X, TRUE );
                if( !bDisplayAll ){
                    if( Commands[i].fType == VARG_TYPE_INI ){
                        DisplayIniInfo();
                    }
                }
            }
        }
    }

    if( NULL != strNegateHelp ){
        PrintMessage( g_normal, IDS_MESSAGE_NEGATE, strNegateHelp, strNegateHelp );
    }

    // Notes
    if( bDisplayAll ){
        PrintMessage( g_normal, IDS_MESSAGE_HELPTEXT );
    }

    // Examples
    bFirst = TRUE;
    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( bDisplayAll || Commands[i].bDefined ){
            if( (bDisplayAll && bVerbs ) && 
                !(Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ) ){
                continue;
            }
            if( Commands[i].fFlag & VARG_FLAG_EXHELP ){
                if( bFirst ){
                    PrintMessage( g_normal, IDS_MESSAGE_EXAMPLES );
                    bFirst = FALSE;
                }
                PrintHelpString( Commands[i].idExHelp, 0, 2, 80, FALSE );
            }
        }
    }

    FreeCmd();
    exit(0);
}

void PrintParam( int idPrompt, int cmd, BOOL bEOL )
{
    BOOL bUseArg1;
    TCHAR buffer[MAXSTR];
    bUseArg1 = (Commands[cmd].fFlag & VARG_FLAG_VERB) || 
               (Commands[cmd].fFlag & VARG_FLAG_ADVERB) ||
               ( IsEmpty( Commands[cmd].strArg2 ) );

    if( 0 != idPrompt ){
        LoadString( NULL, idPrompt, buffer, MAXSTR );
        varg_printf( g_debug, buffer );
    }
    
    if( Commands[cmd].fFlag & VARG_FLAG_NOFLAG ){
        varg_printf( g_debug,  _T("%1!s! "),  Commands[cmd].strParam );
    }else{
        if( !(Commands[cmd].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB)) ){
            varg_printf( g_debug, _T("%1!c!"), g_strPrefix[0] );
        }else if( !IsEmpty( g_strVerbPrefix ) ){
            varg_printf( g_debug, _T("%1!c!"), g_strVerbPrefix[0] );
        }
        if( ArgExpected( &Commands[cmd] ) ){
            varg_printf( g_debug,  _T("%1!s!%2!s! %3!s! "),
                    Commands[cmd].fFlag&VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                    bUseArg1 ? Commands[cmd].strArg1 : Commands[cmd].strArg2,
                    Commands[cmd].strParam
                );
        }else{
            varg_printf( g_debug,  _T("%1!s!%2!s! "),
                    Commands[cmd].fFlag&VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                    bUseArg1 ? Commands[cmd].strArg1 : Commands[cmd].strArg2
                );
        }
    }

    if( bEOL ){
        varg_printf( g_debug,  _T("\n") );
    }
    
}

HRESULT
ValidateCommands()
{
    int i,j;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bVerbs = FALSE;
    BOOL nDefinedVerbs = 0;

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        UCHAR cond1 = (UCHAR)((Commands[i].dwSet & VARG_CONDITION) >> 16);
        if( cond1 ){
            BOOL bFound = FALSE;
            for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                UCHAR cond2 = (UCHAR)((Commands[j].dwSet & VARG_CONDITION) >> 16);
                if( (cond1 & cond2) && Commands[j].bDefined ){
                    bFound = TRUE;
                    break;
                }
            }
            if( ! bFound ){
                for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                    UCHAR cond2 = (UCHAR)((Commands[j].dwSet & VARG_CONDITION) >> 16);
                    if( (cond1 & cond2) && !(Commands[j].fFlag & VARG_FLAG_VERB)){
                        Commands[j].fFlag |= VARG_FLAG_REQUIRED;
                    }
                }
            }
        }
        if( Commands[i].bDefined && (Commands[i].fFlag & VARG_FLAG_REQ_ADV) ){
            BOOL bFound = FALSE;
            WORD wVerb1 = (WORD)( Commands[i].dwVerb & 0x0000FFFF );
            for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                WORD wVerb2 = (WORD)(Commands[j].dwVerb & 0x0000FFFF);
                if( Commands[j].bDefined && (wVerb1 == wVerb2) && (Commands[j].fFlag & VARG_FLAG_ADVERB) ){
                    bFound = TRUE;
                    break;
                }
            }
            if( ! bFound ){
                for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                    WORD wVerb2 = (WORD)(Commands[j].dwVerb & 0x0000FFFF);
                    if( wVerb1 == wVerb2 && Commands[j].fFlag & VARG_FLAG_ADVERB ){
                        Commands[j].fFlag |= VARG_FLAG_REQUIRED;
                    }
                }
            }
        }
        if( Commands[i].bDefined && Commands[i].dwSet ){
            UCHAR excl1 = (UCHAR)((Commands[i].dwSet & VARG_EXCLUSIVE));
            UCHAR incl1 = (UCHAR)((Commands[i].dwSet & VARG_INCLUSIVE) >> 8);
            UCHAR grp_ex1 = (UCHAR)(((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0x0F);
            for(j=i+1; Commands[j].fType != VARG_TYPE_LAST;j++){
                if( Commands[j].dwSet ){
                    UCHAR excl2 = (UCHAR)((Commands[j].dwSet & VARG_EXCLUSIVE));
                    UCHAR incl2 = (UCHAR)((Commands[j].dwSet & VARG_INCLUSIVE) >> 8);
                    UCHAR grp_in2 = (UCHAR)((((Commands[j].dwSet & VARG_GROUPEXCL) >> 24) & 0xF0) >> 4 );
                    if( excl1 && (excl1 & excl2) && Commands[j].bDefined ){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_AND, j, FALSE );
                        PrintMessage( g_debug, IDS_MESSAGE_EXCLUSIVE );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( incl1 && (incl1 & incl2) && !Commands[j].bDefined){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_REQUIRES, j, FALSE );
                        varg_printf( g_debug, _T("\n") );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( grp_ex1 && (grp_in2 & grp_ex1) && Commands[j].bDefined ){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_AND, j, FALSE );
                        PrintMessage( g_debug, IDS_MESSAGE_EXCLUSIVE );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                }
            }
        }

        if( Commands[i].bDefined && (Commands[i].fFlag & VARG_FLAG_LITERAL) ){
            LPTSTR strValues;
            LPTSTR strCheck;
            LPTSTR strArg;
            BOOL bFound = FALSE;
            switch( Commands[i].fType ){
            case VARG_TYPE_MSZ:
            case VARG_TYPE_STR:
                
                strArg = Commands[i].strValue;
                while( strArg != NULL && !(Commands[i].fFlag & VARG_FLAG_BADSYNTAX) ){
                    strValues = varg_strdup( Commands[i].strParam );
                    if( NULL != strValues ){
                        strCheck = _tcstok( strValues, _T("<>[]|") );
                        while( !bFound && strCheck != NULL ){
                            if( _tcsicmp( strCheck, strArg ) == 0 ){
                                bFound = TRUE;
                                break;
                            }
                            strCheck = _tcstok( NULL, _T("<>[]|") );
                        }
                    }
                    VARG_FREE( strValues );
                    if( !bFound ){
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( Commands[i].fType == VARG_TYPE_MSZ ){
                        strArg += _tcslen( strArg ) + 1;
                        bFound = FALSE;
                        if( *strArg == _T('\0') ){
                            strArg = NULL;
                        }
                    }else{
                        strArg = NULL;
                    }
                }
                break;
            default:
                hr = ERROR_INVALID_PARAMETER;
            }
        }
    }

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( Commands[i].fFlag & VARG_FLAG_VERB ){
            if( Commands[i].bDefined ){
                nDefinedVerbs++;
            }
            bVerbs = TRUE;
        }
        if( (Commands[i].fFlag & VARG_FLAG_REQUIRED) && !Commands[i].bDefined){
            PrintParam( IDS_MESSAGE_MISSING, i, TRUE );
            hr = ERROR_BAD_ARGUMENTS;
        }
        if( Commands[i].fFlag & VARG_FLAG_BADSYNTAX ){
            PrintParam( IDS_MESSAGE_BADSYNTAX, i, TRUE );
            hr = ERROR_BAD_ARGUMENTS;
        }
    }
        
    if( bVerbs && nDefinedVerbs == 0 ){
        PrintMessage( g_debug, IDS_MESSAGE_NOVERB );
        hr = ERROR_BAD_ARGUMENTS;
    }

    return hr;
}

/*****************************************************************************\
    Utility Functions        
\*****************************************************************************/

HRESULT GetUserInput( LPTSTR strBuffer, ULONG lSize, BOOL bEcho )
{
    TCHAR c = _T('\0');
    UCHAR a;
    ULONG i = 0;
    BOOL bDone = FALSE;
    HANDLE hInput = NULL;
    DWORD dwSize;
    DWORD dwMode;
    
    hInput = GetStdHandle( STD_INPUT_HANDLE );

    GetConsoleMode( hInput, &dwMode);
    SetConsoleMode( hInput, (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & dwMode);

    while( !bDone ){
        if( (GetFileType(hInput) & ~FILE_TYPE_REMOTE) != FILE_TYPE_CHAR ){
            BOOL bRead = ReadFile( hInput, &a, 1, &dwSize, NULL );
            if( 0 == dwSize || !bRead ){
                c = _T('\n');
            }else{
                MultiByteToChar( a, c );
                if( _T('\r') == c ){
                    bRead = ReadFile( hInput, &a, 1, &dwSize, NULL );
                }
            }
        }else{
            ReadConsole( hInput, &c, 1, &dwSize, NULL );
        }
        switch( c ){
        case 8:
            if( i > 0 ){
                strBuffer[i--] = _T('\0');
                if(bEcho){
                    _tprintf( _T("%c %c"), c, c );
                }
            }
            break;
        case 3:
            FreeCmd();
            SetConsoleMode(hInput, dwMode);
            exit(0);
        case _T('\r'):
        case _T('\n'):
            bDone = TRUE;
            varg_printf( g_normal, _T("\n") );
            break;
        default:
            if( i < (lSize-1) ){
                strBuffer[i++] = (TCHAR)c;
                if( bEcho ){
                    varg_printf( g_normal, _T("%1!c!"), c );
                }
            }
        }
    }

    SetConsoleMode(hInput, dwMode);

    if( i > lSize ){
        return ERROR_INSUFFICIENT_BUFFER;
    }else{
        strBuffer[i] = _T('\0');
    }

    return ERROR_SUCCESS;
}

DWORD
CheckFile( LPTSTR strFile, DWORD dwFlags )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE hFile;

    hFile = CreateFile(
                strFile,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if( hFile == INVALID_HANDLE_VALUE){
        dwStatus = GetLastError();
    }
    CloseHandle(hFile);
    
    if( dwFlags & VARG_CF_OVERWRITE ){
        if( ERROR_FILE_NOT_FOUND == dwStatus ){
            dwStatus = ERROR_SUCCESS;
        }else if( ERROR_PATH_NOT_FOUND == dwStatus){
            return dwStatus;
        }else if( dwFlags & VARG_CF_PROMPT ){
            
            TCHAR buffer[MAXSTR] = _T("");
            TCHAR yes[16];

            PrintMessage( g_normal, IDS_CF_OVERWRITE, strFile );
            GetUserInput( buffer, MAXSTR, TRUE );
            LoadString( NULL, IDS_ARG_YES, yes, 16 );

            if( FindString( buffer, yes ) ){
                dwStatus = ERROR_SUCCESS;
            }else{
                dwStatus = ERROR_ALREADY_EXISTS;
            }
        }
    }
    
    return dwStatus;
}

HRESULT
ExpandFiles( LPTSTR* mszFiles, BOOL bMultiple )
{
    LPTSTR strFiles = NULL;
    LPTSTR strExpand;

    TCHAR buffer[_MAX_PATH];
    TCHAR drive[_MAX_DRIVE];
    TCHAR dir[_MAX_DIR];
    TCHAR fname[_MAX_FNAME];
    TCHAR ext[_MAX_EXT];
    HANDLE hFile = NULL;
    WIN32_FIND_DATA file;

    strExpand = *mszFiles;
    while( strExpand != NULL && *strExpand != _T('\0')){
        _tsplitpath( strExpand, drive, dir, fname, ext );
        hFile = FindFirstFile( strExpand, &file );
        
        if( hFile != INVALID_HANDLE_VALUE){
            do{
                if( !( !_tcscmp(file.cFileName, _T(".") ) || !_tcscmp(file.cFileName, _T("..")) ) ){
                    _tmakepath( buffer, drive, dir, file.cFileName, _T("") );
                    AddStringToMsz( &strFiles, buffer );
                }
            }while( FindNextFile( hFile, &file ) == TRUE );
            
            FindClose( hFile );

        }else{
            return GetLastError();
        }
        if( bMultiple ){
            strExpand += _tcslen( strExpand )+1;
        }else{
            break;
        }

    }
    
    if( NULL != strFiles ){
        VARG_FREE( *mszFiles );
        *mszFiles = strFiles;
    }

    return ERROR_SUCCESS;
}

BOOL FindString( LPTSTR strBuffer, LPTSTR strMatch )
{
    BOOL bReturn = FALSE;

    LPTSTR buffer;
    LPTSTR match;

    buffer = varg_strdup( strBuffer );
    match = varg_strdup( strMatch );
    
    if( buffer != NULL && match != NULL ){
        _tcslwr( buffer );
        _tcslwr( match );

        if( _tcsstr( buffer, match ) ){
            bReturn = TRUE;
        }
    }

    VARG_FREE( match );
    VARG_FREE( buffer );

    return bReturn;
}

HRESULT 
ParseTime( LPTSTR strTime, SYSTEMTIME* pstTime, BOOL bDate )
{
    TCHAR buffer[MAXSTR];
    TCHAR PM[9] = _T("pm");
    TCHAR AM[9] = _T("am");
    TCHAR strDateSep[8] = _T("/");
    TCHAR strTimeSep[8] = _T(":");
    ULONG l;
    LPTSTR str, str2;
    int nDateFormat = 0;
    BOOL bValid = TRUE;
    FILETIME ft;
    HRESULT hr = ERROR_SUCCESS;

    ZeroMemory( pstTime, sizeof( SYSTEMTIME ) );
    
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IDATE, buffer, MAXSTR ) > 1 ){
        nDateFormat = _ttoi( buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S1159, buffer, 9 ) > 1 ){
        hr = StringCchCopy( AM, 9, buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S2359, buffer, 9 ) > 1 ){
        hr = StringCchCopy( PM, 9, buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, buffer, 8 ) > 1 ){
        hr = StringCchCopy( strTimeSep, 8, buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SDATE, buffer, 8 ) > 1 ){
        hr = StringCchCopy( strDateSep, 8, buffer );
    }

    hr = StringCchCopy( buffer, MAXSTR, strTime );

    str = _tcstok( buffer, _T(" \n\t") );
    str2 = _tcstok( NULL, _T(" \n\t") );
    while( str ){
        if( _tcsstr( str, strDateSep ) ){

            LPTSTR strMonth = NULL;
            LPTSTR strDay = NULL;
            LPTSTR strYear = NULL;

            switch( nDateFormat ){
            case 0:
                strMonth = _tcstok( str,  strDateSep );
                strDay =   _tcstok( NULL, strDateSep );
                strYear =  _tcstok( NULL, strDateSep );
                break;
            case 1:
                strDay =   _tcstok( str,  strDateSep );
                strMonth = _tcstok( NULL, strDateSep );
                strYear =  _tcstok( NULL, strDateSep );
                break;
            case 2:
                strYear =  _tcstok( str,  strDateSep );
                strMonth = _tcstok( NULL, strDateSep );
                strDay =   _tcstok( NULL, strDateSep );
                break;
            }

            if( NULL != strMonth ){
                hr = ReadLong( strMonth, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wMonth = (WORD)l;
                }
            }
            if( NULL != strDay ){
                hr = ReadLong( strDay, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wDay = (WORD)l;
                }
            }
            if( NULL != strYear ){
                hr = ReadLong( strYear, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    if( l < 100 ){
                        l += 2000;
                    }
                    pstTime->wYear = (WORD)l;
                }
            }
        }else{
            LPTSTR tok1 = NULL;
            LPTSTR tok2 = NULL;
            LPTSTR tok3 = NULL;
            UINT nTok = 0;
            BOOL bPM = FALSE;
            BOOL bAM = FALSE;
            LPTSTR szZero = _T("0");

            bPM = FindString( str, PM );
            bAM = FindString( str, AM );

            tok1 = _tcstok( str, strTimeSep );
            if( NULL != tok1 ){
                nTok++;
                tok2 = _tcstok( NULL, strTimeSep );
            }else{
                tok1 = szZero;
            }
            if( NULL != tok2 ){
                nTok++;
                tok3 = _tcstok( NULL, strTimeSep );
            }else{
                tok2 = szZero;
            }
            if( NULL != tok3 ){
                nTok++;
            }else{
                tok3 = szZero;
            }
            if( bDate ){
                nTok = 3;
            }
            switch( nTok ){
            case 1:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wSecond = (WORD)l;
                }
                break;
            case 2:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wMinute = (WORD)l;
                    hr = ReadLong( tok2, &l, MAXWORD );
                    if( ERROR_SUCCESS == hr ){
                        pstTime->wSecond = (WORD)l;
                    }
                }
                break;
            case 3:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wHour = (WORD)l;
                    hr = ReadLong( tok2, &l, MAXWORD );
                    if( ERROR_SUCCESS == hr ){
                        pstTime->wMinute = (WORD)l;
                        hr = ReadLong( tok3, &l, MAXWORD );
                        if( ERROR_SUCCESS == hr ){
                            pstTime->wSecond = (WORD)l;
                        }
                    }
                }
                break;
            }
            if( ERROR_SUCCESS == hr ){
                if( bPM ){
                    if( pstTime->wHour < 12 ){
                        pstTime->wHour += 12;
                    }else if( pstTime->wHour > 12 ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADTIME, PM );
                    }
                }
                if( bAM ){
                    if( pstTime->wHour > 12 ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADTIME, AM );
                    }
                }
            }
        }
        str = str2;
        str2 = NULL;
    }
    
    if( bDate && ERROR_SUCCESS == hr ){
        bValid = SystemTimeToFileTime( pstTime, &ft );
        if( !bValid ){
            hr = GetLastError();
        }
    }

    return hr;
}

void PrintError( HRESULT hr )
{
    PrintErrorEx( hr, NULL );
}

void PrintErrorEx( HRESULT hr, LPTSTR strModule, ... )
{
    LPVOID lpMsgBuf = NULL;
    HINSTANCE hModule = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;

    va_list args;
    va_start( args, strModule );

    if(hr == 0){
        hr = GetLastError();
    }

    if( strModule != NULL ){
        hModule = LoadLibrary( strModule );
    }

    if ( NULL != hModule ) {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }else{
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }

    __try{
     
        FormatMessage(
                dwFlags,
                hModule,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&lpMsgBuf,
                MAXSTR,
                &args
            );

        if( g_nDebug >= 0 ){
            PrintMessage( g_debug, IDS_MESSAGE_ERROR_DBG, hr );
        }else{
            PrintMessage( g_debug, IDS_MESSAGE_ERROR );
        }
        if( NULL == lpMsgBuf ){
            PrintMessage( g_debug, IDS_MESSAGE_UNKNOWN );
        }else{
            varg_printf( g_debug, _T("%1!s!\n"), (LPTSTR)lpMsgBuf );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        PrintMessage( g_debug, IDS_MESSAGE_UNKNOWN );
    }

    if ( NULL != hModule ) {
        FreeLibrary( hModule );
    }

    LocalFree( lpMsgBuf );
}

int 
PrintDateEx( SHORT color, SYSTEMTIME* st )
{
    HRESULT hr;
    TCHAR buffer[MAXSTR];
    TCHAR strDateSep[8] = _T("/");
    TCHAR strTimeSep[8] = _T(":");
    int nDateFormat = 0;
    int nOut = 0;

    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IDATE, buffer, MAXSTR ) > 0 ){
        nDateFormat = _ttoi( buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, buffer, 8 ) > 0 ){
        hr = StringCchCopy( strTimeSep, 8, buffer );
    }
    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SDATE, buffer, 8 ) > 0 ){
        hr = StringCchCopy( strDateSep, 8, buffer );
    }

    if( st->wMonth ){
        switch( nDateFormat ){
        case 0:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wMonth, 
                    strDateSep, 
                    st->wDay, 
                    strDateSep, 
                    st->wYear
                );
            break;
        case 1:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wDay, 
                    strDateSep, 
                    st->wMonth, 
                    strDateSep, 
                    st->wYear
                );
            break;
        case 2:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wYear, 
                    strDateSep, 
                    st->wMonth, 
                    strDateSep, 
                    st->wDay
                );
            break;
        }
    }

    nOut += varg_printf( color, _T("%1!d!%2!s!%3!02d!%4!s!%5!02d!"),
                    st->wHour, 
                    strTimeSep, 
                    st->wMinute, 
                    strTimeSep, 
                    st->wSecond
              );

    return nOut;
}

void PrintDate( SYSTEMTIME* st )
{
    PrintDateEx( g_normal, st );
}

/*****************************************************************************\

    VSetThreadUILanguage

    This routine sets the thread UI language based on the console codepage.

    9-29-00    WeiWu    Created.
    6-19-01    coreym   Adapted from Base\Win32\Winnls so that it works in W2K

\*****************************************************************************/

LANGID WINAPI 
VSetThreadUILanguage(WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    static LCID s_lidSystem = 0;
    static UINT s_uiSysCp = 0;
    static UINT s_uiSysOEMCp = 0;

    ULONG uiUserUICp = 0;
    ULONG uiUserUIOEMCp = 0;
    TCHAR szData[16];

    LANGID lidUserUI = GetUserDefaultUILanguage();
    LCID lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    UNREFERENCED_PARAMETER(wReserved);

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp) {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem) {
            //
            // Get ANSI CP
            //
            GetLocaleInfo(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
            uiUserUICp = _ttol(szData);

            //
            // Get OEM CP
            //
            GetLocaleInfo(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
            s_uiSysOEMCp = _ttol(szData);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }

    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI) {
        GetLocaleInfo(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
        uiUserUICp = _ttol(szData);

        GetLocaleInfo(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
        uiUserUIOEMCp = _ttol(szData);
    }

    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp && 
        s_lidSystem != LANG_ARABIC && 
        s_lidSystem != LANG_HEBREW &&
        s_lidSystem != LANG_VIETNAMESE && 
        s_lidSystem != LANG_THAI) {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
            (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp)) {

            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }

    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread))) {
        lcidThread = lcidThreadOld;
    }

    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\inc\varg.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#ifndef _VARG_H_012599_
#define _VARG_H_012599_

#define MAXSTR                   1024

#define VARG_HELP_ALL            (-1)

#define VARG_TYPE_INT            0
#define VARG_TYPE_BOOL           1
#define VARG_TYPE_STR            2
#define VARG_TYPE_HELP           3
#define VARG_TYPE_DEBUG          4
#define VARG_TYPE_MSZ            5
#define VARG_TYPE_LAST           6
#define VARG_TYPE_INI            7
#define VARG_TYPE_TIME           8
#define VARG_TYPE_DATE           9

#define VARG_FLAG_OPTIONAL       0x00000001
#define VARG_FLAG_REQUIRED       0x00000002
#define VARG_FLAG_DEFAULTABLE    0x00000004
#define VARG_FLAG_NOFLAG         0x00000008
#define VARG_FLAG_HIDDEN         0x00000010
#define VARG_FLAG_VERB           0x00000020
#define VARG_FLAG_EXPANDFILES    0x00000040
#define VARG_FLAG_EXHELP         0x00000080
#define VARG_FLAG_DARKEN         0x00000100
#define VARG_FLAG_FLATHELP       0x00000200
#define VARG_FLAG_CHOMP          0x00000400
#define VARG_FLAG_LITERAL        0x00000800
#define VARG_FLAG_ARG_DEFAULT    0x00001000
#define VARG_FLAG_ARG_FILENAME   0x00002000
#define VARG_FLAG_ARG_DATE       0x00004000
#define VARG_FLAG_ARG_TIME       0x00008000
#define VARG_FLAG_NEGATE         0x00010000
#define VARG_FLAG_RCDEFAULT      0x00020000
#define VARG_FLAG_ADVERB         0x00100000
#define VARG_FLAG_OPT_ADV        0x00200000
#define VARG_FLAG_REQ_ADV        0x00400000

#define VARG_FLAG_DODEFAULT      0x01000000
#define VARG_FLAG_BADSYNTAX      0x02000000
#define VARG_FLAG_ALLOCSTR       0x80000000

#define VARG_CF_OVERWRITE        0x00000001
#define VARG_CF_EXISTS           0x00000002
#define VARG_CF_PROMPT           0x00000004

#define IDS_PROGRAM_DESCRIPTION  500

#define IDS_PARAM_DEBUG          501
#define IDS_PARAM_HELP           502
#define IDS_PARAM_SETTINGS       511

#define IDS_ARG_DEFAULT          503
#define IDS_ARG_FILENAME         504
#define IDS_ARG_TIME             505
#define IDS_ARG_DATE             506
#define IDS_ARG_TOKEN            507
#define IDS_ARG_PREFIX           508
#define IDS_ARG_YES              512
#define IDS_VERB_PREFIX          509

#define IDS_MESSAGE_ARG_DUP      550
#define IDS_MESSAGE_BADSYNTAX    551
#define IDS_MESSAGE_UNKNOWNPARAM 552
#define IDS_MESSAGE_AND          553
#define IDS_MESSAGE_REQUIRES     554
#define IDS_MESSAGE_MISSING      555
#define IDS_MESSAGE_NOVERB       556
#define IDS_MESSAGE_UNKNOWN      557
#define IDS_MESSAGE_ERROR        558
#define IDS_MESSAGE_EXCLUSIVE    559
#define IDS_MESSAGE_VERB         560
#define IDS_MESSAGE_VERBS        561
#define IDS_MESSAGE_LINEOPT      562
#define IDS_MESSAGE_PARAMETERS   563
#define IDS_MESSAGE_OPTIONS      564
#define IDS_MESSAGE_INISYNT      565
#define IDS_MESSAGE_USAGE        566
#define IDS_MESSAGE_BADTIME      567
#define IDS_MESSAGE_INCORRECT    568
#define IDS_CF_OVERWRITE         569
#define IDS_MESSAGE_MSR          570
#define IDS_MESSAGE_SUCCESS      571
#define IDS_MESSAGE_DEFAULT      572
#define IDS_MESSAGE_NEGATE       573
#define IDS_MESSAGE_HELPTEXT     574
#define IDS_MESSAGE_ERROR_DBG    575
#define IDS_MESSAGE_WARNING_DBG  576
#define IDS_MESSAGE_WARNING      577
#define IDS_MESSAGE_EXAMPLES     578

#define VARG_BOOL( id, flags, value )   id,0,0,                 NULL,NULL,NULL, VARG_TYPE_BOOL,     flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_STR( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_STR,      flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_MSZ( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_MSZ,      flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_TIME( id, flags )          id,0,0,                 NULL,NULL,NULL, VARG_TYPE_TIME,     flags,  (CMD_TYPE)0,        0,0,0,NULL, 
#define VARG_DATE( id, flags )          id,0,0,                 NULL,NULL,NULL, VARG_TYPE_DATE,     flags,  (CMD_TYPE)0,        0,0,0,NULL, 
#define VARG_INT( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_INT,      flags,  (CMD_TYPE)value,    0,0,0,NULL, 
#define VARG_INI( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_INI,      flags|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP,   (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_DEBUG( flags )             IDS_PARAM_DEBUG,0,0,    NULL,NULL,NULL, VARG_TYPE_DEBUG,    flags,  (CMD_TYPE)0,        0,0,0,NULL,
#define VARG_HELP( flags )              IDS_PARAM_HELP,0,0,     NULL,NULL,NULL, VARG_TYPE_HELP,     flags,  (CMD_TYPE)FALSE,    0,0,0,NULL,
#define VARG_TERMINATOR                 0,0,0,                  NULL,NULL,NULL, VARG_TYPE_LAST,     0,      (CMD_TYPE)0,        0,0,0,NULL

#define VARG_ADJECTIVE    0xFFFF0000
#define VARG_EXCLUSIVE    0x000000FF
#define VARG_INCLUSIVE    0x0000FF00
#define VARG_CONDITION    0x00FF0000
#define VARG_GROUPEXCL    0xFF000000

#define VARG_EXCL( x )    ((DWORD)(x))
#define VARG_INCL( x )    ((DWORD)((x) << 8 ))
#define VARG_COND( x )    ((DWORD)((x) << 16))
#define VARG_GRPX( i, x ) ((DWORD)(((i<<4)|x) << 24))

#define VARG_DECLARE_COMMANDS  VARG_RECORD Commands[] = {
#define VARG_DECLARE_NAMES     VARG_TERMINATOR }; typedef enum _Commands {
#define VARG_DECLARE_FORMAT    };void VArgDeclareFormat() {
#define VARG_DECLARE_END       }
#define VARG_VERB( e, v )      Commands[e].dwVerb = (v & 0x0000FFFF);
#define VARG_GROUP( e, g )     Commands[e].dwSet |= g;
#define VARG_ADVERB( e, v, a ) Commands[e].dwVerb = ( v & 0x0000FFFF) | (a<<16);
#define VARG_EXHELP( e, rc )   Commands[e].fFlag |= VARG_FLAG_EXHELP; Commands[e].idExHelp = rc;

#define ASSIGN_STRING( dest, src ) dest = varg_strdup( src )

#ifdef UNICODE
#define MultiByteToChar( a, c )       if(! MultiByteToWideChar( _getmbcp(), 0, (LPCSTR)&a, 1, &c, 1 ) ){ c = _T('\0'); }
#else
#define MultiByteToChar( a, c )       a = c
#endif

#define VARG_ALLOC( s )  HeapAlloc( GetProcessHeap(), 0, s )
#define VARG_FREE( s )   if( s != NULL ) { HeapFree( GetProcessHeap(), 0, s ); }
#define VARG_REALLOC( p, s )   HeapReAlloc( GetProcessHeap(), 0, p, s )

#ifdef __cplusplus
extern "C" 
{
#endif

#define CMD_TYPE    void*

#pragma warning ( disable : 4201 )

typedef struct _VARG_RECORD
{
    LONG    idParam;
    LONG    idExHelp;
    DWORD   dwSet;
    LPTSTR  strArg1;
    LPTSTR  strArg2;
    LPTSTR  strParam;
    int     fType;
	DWORD   fFlag;
    union{
        void*       vValue;
        LPTSTR      strValue;
        ULONG       nValue;
        BOOL        bValue;
        SYSTEMTIME  stValue;
    };
    BOOL	bDefined;
    BOOL	bNegated;
    DWORD   dwVerb;
    void	(*fntValidation)(int);
} VARG_RECORD, *PVARG_RECORD;

#pragma warning ( default : 4201 )

LPTSTR varg_strdup( LPTSTR src );

DWORD varg_cmdStringAddMsz( int id, LPTSTR src );
DWORD varg_cmdStringAssign( int id, LPTSTR src );
DWORD varg_cmdStringFree( int id );

int varg_printf( WORD color, LPCTSTR mask, ... );

void ParseCmd(int argc, LPTSTR argv[] );
void VArgDeclareFormat();
void DisplayCommandLineHelp();
void DisplayDebugInfo();

ULONG MszStrLen( LPTSTR mszBuffer );

LPWSTR
PaddedString(
    LPWSTR sz,
    LPWSTR buffer,
    ULONG  cchBufferSize,
    ULONG  cchPadSize
);

HRESULT AddStringToMsz( LPTSTR* mszBuffer, LPTSTR strValue );
HRESULT ValidateCommands();

void PrintError( HRESULT hr );
void PrintErrorEx( HRESULT hr, LPTSTR strModule, ... );
void PrintDate( SYSTEMTIME* st );
int  PrintDateEx( SHORT color, SYSTEMTIME* st );

LANGID WINAPI 
VSetThreadUILanguage(
    WORD wReserved
);

int PrintMessage( WORD color, LONG id, ... );
void Chomp(LPTSTR pszLine);

HRESULT GetUserInput( 
    LPTSTR strBuffer, 
    ULONG lSize, 
    BOOL bEcho 
);

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime,
    BOOL bDate
);

HRESULT
ExpandFiles( 
    LPTSTR* mszFiles,  
    BOOL bMultiple 
);

DWORD
CheckFile( 
    LPTSTR strFile, 
    DWORD dwFlags 
);

void FreeCmd();

extern VARG_RECORD Commands[];

extern WORD g_debug;
extern WORD g_light;
extern WORD g_dark;
extern WORD g_normal;

#ifdef DBG 

#define ASSERT( x ) \
if( !(x) ){ \
    WCHAR buffer[MAXSTR]; \
    StringCchPrintfW( buffer, MAXSTR, L"VARG Assert: File: %S Line: %d\n", __FILE__, __LINE__ ); \
    OutputDebugStringW( buffer ); \
}

#else

#define ASSERT( x )

#endif

#ifdef __cplusplus
}
#endif

#endif //_VARG_H_012599_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define    IDS_PARAM_APPEND          110
#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_QUERY           125
#define    IDS_PARAM_COUNTERS        128
#define    IDS_PARAM_BEGIN           131
#define    IDS_PARAM_END             134
#define    IDS_PARAM_COUNTERFILE     140
#define    IDS_PARAM_YES             141
#define    IDS_PARAM_FA              142

#define    IDS_DEFAULT_OUTPUT        600

#define    IDS_MESSAGE_INPUT         700
#define    IDS_MESSAGE_OUTPUT        701
#define    IDS_MESSAGE_FILE          702
#define    IDS_MESSAGE_FILES         703
#define    IDS_MESSAGE_BEGIN         704
#define    IDS_MESSAGE_END           705
#define    IDS_MESSAGE_SAMPLES       706
#define    IDS_MESSAGE_LOG_OLD_BIN   707
#define    IDS_MESSAGE_LOG_CSV       708
#define    IDS_MESSAGE_LOG_TSV       709
#define    IDS_MESSAGE_LOG_BINARY    710
#define    IDS_MESSAGE_LOG_PERFMON   711
#define    IDS_MESSAGE_LOG_UNKNOWN   712    
#define    IDS_MESSAGE_BADFILES      713
#define    IDS_MESSAGE_BADFORMAT     714
#define    IDS_MESSAGE_BADRANGE      715
#define    IDS_MESSAGE_SQLERROR      716

#define    IDS_EXAMPLE_FORMAT        800
#define    IDS_EXAMPLE_QUERY         801
#define    IDS_EXAMPLE_COUNTERFILE   802
#define    IDS_EXAMPLE_COUNTERS      803
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\relogger.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <objbase.h>
#include <pdh.h>
#include <pdhmsg.h>
#include <pdhp.h>

#include "resource.h"

#include "varg.c"


DWORD GetLogFormat( LPTSTR str, LPDWORD pdwFormat );
PDH_STATUS GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery );
PDH_STATUS QueryLog( HLOG hLog, HQUERY hQuery, FILE* f );
PDH_STATUS AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery );
_inline BOOL IsTextFormat( DWORD dwFormat );
DWORD GetTempName( LPTSTR strFile, size_t cchSize );
void ReportStatus( int Status, double Progress );

#define PDH_LOG_TYPE_RETIRED_BIN_ 3
#define CHECK_STATUS( hr )       if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define RELOG_ERROR_BADFILES    0xF0000001
#define RELOG_ERROR_BADFORMAT   0xF0000002
#define RELOG_ERROR_TIMERANGE   0xF0000003
#define RELOG_ERROR_BADAPPEND   0xF0000004

VARG_DECLARE_COMMANDS
    VARG_DEBUG( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP ( VARG_FLAG_OPTIONAL )
    VARG_BOOL ( IDS_PARAM_APPEND,       VARG_FLAG_OPTIONAL, FALSE )    
    VARG_MSZ  ( IDS_PARAM_COUNTERS,     VARG_FLAG_OPTIONAL, _T("") )
    VARG_STR  ( IDS_PARAM_COUNTERFILE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME, _T("") )
    VARG_STR  ( IDS_PARAM_FORMAT,       VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("BIN") )
    VARG_MSZ  ( IDS_PARAM_INPUT,        VARG_FLAG_REQUIRED|VARG_FLAG_NOFLAG|VARG_FLAG_EXPANDFILES|VARG_FLAG_ARG_FILENAME, _T("") ) 
    VARG_INT  ( IDS_PARAM_INTERVAL,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT, 0 )
    VARG_STR  ( IDS_PARAM_OUTPUT,       VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_OUTPUT )
    VARG_DATE ( IDS_PARAM_BEGIN,        VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_DATE ( IDS_PARAM_END,          VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_INI  ( IDS_PARAM_SETTINGS,     VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL ( IDS_PARAM_QUERY,        VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL ( IDS_PARAM_YES,          VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL ( IDS_PARAM_FA,           VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eAppend,
    eCounters,
    eCounterFile,
    eFormat,
    eInput,
    eInterval,
    eOutput,
    eBegin,
    eEnd,
    eSettings,
    eQuery,
    eYes,
    eForceAppend,
VARG_DECLARE_FORMAT
    VARG_EXHELP( eFormat,       IDS_EXAMPLE_FORMAT )
    VARG_EXHELP( eQuery,        IDS_EXAMPLE_QUERY )
    VARG_EXHELP( eCounterFile,  IDS_EXAMPLE_COUNTERFILE )
    VARG_EXHELP( eCounters,     IDS_EXAMPLE_COUNTERS )
VARG_DECLARE_END

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PDH_RELOG_INFO RelogInfo;
    DWORD dwOutputFormat;
    DWORD dwInputFormat;
    PDH_TIME_INFO InputTimeRange;
    LPTSTR strFile = NULL;
    TCHAR strTempFile[MAXSTR] = _T("");

    ParseCmd( argc, argv );
    
    HLOG hLogIn = NULL;
    HQUERY hQuery = NULL;
    
    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO) );

    DWORD dwNumEntries = 1;
    DWORD dwBufferSize = sizeof(PDH_TIME_INFO);
    int nBinary = 0;
    int nFiles = 0;
    BOOL bFakeAppend = FALSE;

    if( Commands[eInput].strValue == NULL ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
 
    if( Commands[eAppend].bValue && !(Commands[eForceAppend].bValue ) ){
        // We are going to do a merge instead
        bFakeAppend = TRUE;
        
        dwStatus = varg_cmdStringAddMsz( eInput, Commands[eOutput].strValue );
        CHECK_STATUS( dwStatus );

        dwStatus = GetTempName( strTempFile, MAXSTR );   
        CHECK_STATUS( dwStatus );
    }

    dwStatus = GetLogFormat( Commands[eFormat].strValue, &dwOutputFormat );
    CHECK_STATUS(dwStatus);
    
    strFile = Commands[eInput].strValue;
    PrintMessage( g_normal, IDS_MESSAGE_INPUT );
    PrintMessage( g_normal, IDS_MESSAGE_FILES );

    while( strFile != NULL && *strFile != _T('\0') ){
        pdhStatus = PdhGetLogFileType( strFile, &dwInputFormat );
        nFiles++;
        if( pdhStatus != ERROR_SUCCESS ){
            dwInputFormat = 0;
        }
        switch( dwInputFormat ){
        case PDH_LOG_TYPE_RETIRED_BIN_:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_OLD_BIN, strFile );
            break;
        case PDH_LOG_TYPE_CSV:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_CSV, strFile );
            break;
        case PDH_LOG_TYPE_TSV:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_TSV, strFile );
            break;
        case PDH_LOG_TYPE_BINARY:
            nBinary++;
            PrintMessage( g_normal, IDS_MESSAGE_LOG_BINARY, strFile );
            break;
        case PDH_LOG_TYPE_PERFMON:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_PERFMON, strFile );
            break;
        default:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_UNKNOWN, strFile );
        }
        strFile += _tcslen(strFile)+1;
    }
    varg_printf( g_normal, _T("\n") );

    if( nFiles > 1 && nFiles > nBinary ){
        dwStatus = RELOG_ERROR_BADFILES;
        goto cleanup;
    }
    
    pdhStatus = PdhBindInputDataSource( &hLogIn, Commands[eInput].strValue );
    CHECK_STATUS( pdhStatus );
    
    pdhStatus = PdhOpenQueryH( hLogIn, NULL, &hQuery );
    CHECK_STATUS( pdhStatus );

    pdhStatus = PdhGetDataSourceTimeRangeH (
                hLogIn,
                &dwNumEntries,
                &InputTimeRange,
                &dwBufferSize
            );
    CHECK_STATUS( pdhStatus );
    
    SYSTEMTIME st;
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.StartTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
    PrintDate( &st );
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.EndTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_END );
    PrintDate( &st );
    PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, InputTimeRange.SampleCount );

    if( Commands[eQuery].bDefined ){
        FILE* f = NULL;
        if( Commands[eOutput].bDefined ){
            dwStatus = CheckFile( Commands[eOutput].strValue, 
                            Commands[eYes].bValue ? 
                            VARG_CF_OVERWRITE : 
                            (VARG_CF_PROMPT|VARG_CF_OVERWRITE) 
                        );
            CHECK_STATUS( dwStatus );

            f = _tfopen( Commands[eOutput].strValue, _T("w") );
            if( NULL == f ){
                dwStatus = GetLastError();
            }
        }
        pdhStatus = QueryLog( hLogIn, hQuery, f );
        if( NULL != f ){
            fclose(f);
        }

    }else if( (!Commands[eCounters].bDefined && !Commands[eCounterFile].bDefined) ){
        
        pdhStatus = QueryLog( hLogIn, hQuery, NULL );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eCounters].bDefined ){
        pdhStatus = AddCounters( IsTextFormat( dwOutputFormat ), hLogIn, hQuery );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eCounterFile].bDefined ){
        pdhStatus = GetCountersFromFile( 
                        (IsTextFormat( dwInputFormat ) || IsTextFormat(dwOutputFormat)), 
                        hLogIn, 
                        hQuery 
                    );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eBegin].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eBegin].stValue, &ft );
        RelogInfo.TimeInfo.StartTime = *(LONGLONG *)&ft;
        if( RelogInfo.TimeInfo.StartTime >= InputTimeRange.EndTime ){
            dwStatus = RELOG_ERROR_TIMERANGE;
        }
        CHECK_STATUS(dwStatus);
    }

    if( Commands[eEnd].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eEnd].stValue, &ft );
        RelogInfo.TimeInfo.EndTime = *(LONGLONG *)&ft;
        if( RelogInfo.TimeInfo.EndTime <= InputTimeRange.StartTime ){
            dwStatus = RELOG_ERROR_TIMERANGE;
        }
        CHECK_STATUS(dwStatus);
    }

    if( Commands[eOutput].bDefined && !Commands[eQuery].bDefined ){
        TCHAR strFileBuffer[MAX_PATH];
        TCHAR drive[_MAX_DRIVE];
        TCHAR path[_MAX_DIR];
        TCHAR file[_MAX_FNAME];
        TCHAR ext[_MAX_EXT];
        RelogInfo.dwFileFormat = dwOutputFormat;
        _tsplitpath( Commands[eOutput].strValue, drive, path, file, ext );
        if( 0 == _tcslen( ext ) ){
            switch( RelogInfo.dwFileFormat ){
            case PDH_LOG_TYPE_TSV: StringCchCopy( ext, _MAX_EXT, _T("tsv") ); break;
            case PDH_LOG_TYPE_CSV: StringCchCopy( ext, _MAX_EXT, _T("csv") ); break;
            case PDH_LOG_TYPE_SQL: break;
            case PDH_LOG_TYPE_BINARY: 
                StringCchCopy( ext, _MAX_EXT, _T("blg") ); break;
            }
        }
        _tmakepath( strFileBuffer, drive, path, file, ext );
        
        if( PDH_LOG_TYPE_SQL != dwOutputFormat ){
            if( Commands[eAppend].bDefined ){
                dwStatus = CheckFile( strFileBuffer, 0 );
            }else{
                dwStatus = CheckFile( strFileBuffer, Commands[eYes].bValue ? VARG_CF_OVERWRITE : (VARG_CF_PROMPT|VARG_CF_OVERWRITE) );
            }
            CHECK_STATUS(dwStatus);
        }

        RelogInfo.dwFlags = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;

        if( Commands[eAppend].bValue && Commands[eForceAppend].bValue ){
            if( IsTextFormat( dwOutputFormat) ){
                if( PDH_LOG_TYPE_SQL != dwOutputFormat ){
                    dwStatus = RELOG_ERROR_BADAPPEND;
                    goto cleanup;
                }
            }else{
                pdhStatus = PdhGetLogFileType( Commands[eOutput].strValue, &dwOutputFormat );
                if( ERROR_SUCCESS == pdhStatus && PDH_LOG_TYPE_BINARY == dwOutputFormat ){
                    RelogInfo.dwFlags |= PDH_LOG_OPT_APPEND;
                }else{
                    if( ERROR_SUCCESS == pdhStatus ){
                        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    }
                    goto cleanup;
                }
            }
        }

        if( bFakeAppend ){
            RelogInfo.strLog = strTempFile;
        }else{
            RelogInfo.strLog = strFileBuffer;
        }
    
        RelogInfo.StatusFunction = ReportStatus;
        RelogInfo.TimeInfo.SampleCount = Commands[eInterval].nValue;
        
        ReportStatus( 0, 0.0 );

        pdhStatus = PdhRelog( hLogIn, &RelogInfo );
        CHECK_STATUS( pdhStatus );

        ReportStatus( 0, 1.0 );
        varg_printf( g_normal, _T("\n\n") );

        if( bFakeAppend ){
            BOOL bResult;
            bResult = CopyFile( strTempFile, Commands[eOutput].strValue, FALSE );
            DeleteFile( strTempFile );
            if( !bResult ){
                dwStatus = GetLastError();
            }
            CHECK_STATUS( dwStatus );
            RelogInfo.strLog = strFileBuffer;
        }

        PrintMessage( g_normal, IDS_MESSAGE_OUTPUT );
        PrintMessage( g_normal, IDS_MESSAGE_FILE, RelogInfo.strLog );

        FileTimeToSystemTime( (FILETIME *)&RelogInfo.TimeInfo.StartTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
        PrintDate( &st );
        FileTimeToSystemTime( (FILETIME *)&RelogInfo.TimeInfo.EndTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_END );
        PrintDate( &st );
        PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, RelogInfo.TimeInfo.SampleCount );

    }
    
cleanup:
    if( hLogIn != NULL ){
        PdhCloseLog( hLogIn, PDH_FLAGS_CLOSE_QUERY );
    }

    switch( dwStatus ){
    case RELOG_ERROR_TIMERANGE:
        PrintMessage( g_debug, IDS_MESSAGE_BADRANGE );
        break;
    case RELOG_ERROR_BADFORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADAPPEND:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADFILES:
        PrintMessage( g_debug, IDS_MESSAGE_BADFILES );
        break;
    case ERROR_SUCCESS:
        if( ERROR_SUCCESS == pdhStatus ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        }else{
            switch( pdhStatus ){
            case PDH_SQL_ALLOC_FAILED:
            case PDH_SQL_ALLOCCON_FAILED:
            case PDH_SQL_EXEC_DIRECT_FAILED:
            case PDH_SQL_FETCH_FAILED:
            case PDH_SQL_ROWCOUNT_FAILED:
            case PDH_SQL_MORE_RESULTS_FAILED:
            case PDH_SQL_CONNECT_FAILED:
            case PDH_SQL_BIND_FAILED:
                PrintMessage( g_debug, IDS_MESSAGE_SQLERROR );
                break;
            default:
                PrintErrorEx( pdhStatus, _T("PDH.DLL") );
            }

            dwStatus = pdhStatus;
        }
        break;
    default:
        PrintError( dwStatus );
    }

    FreeCmd();

    return dwStatus;
}

void ReportStatus( int Status, double Progress )
{
    HRESULT hr;
    TCHAR buffer[16];

    hr = StringCchPrintf( buffer, 16, _T("%1.2f%%"), Progress*100 );
    
    _tprintf( _T("\r") );
    varg_printf( g_normal, _T("%1!s!"), buffer );    
}

DWORD
GetTempName( LPTSTR strFile, size_t cchSize )
{
    DWORD dwStatus;
    GUID guid;
    const size_t cchGuidSize = 128;
    TCHAR strGUID[cchGuidSize];
    DWORD nChar = 0;

    dwStatus = UuidCreate( &guid );
    if( dwStatus == RPC_S_OK || dwStatus == RPC_S_UUID_LOCAL_ONLY ){
        nChar = StringFromGUID2( guid, strGUID, cchGuidSize );
        dwStatus = ERROR_SUCCESS;
    }

    if( 0 == nChar ){
        StringCchCopy( strGUID, cchGuidSize, _T("{d41c99ea-c303-4d06-b779-f9e8e20acb8f}") );        
    }

    nChar = GetTempPath( cchSize, strFile );
    if( 0 == nChar ){
        dwStatus = GetLastError();
    }

    if( ERROR_SUCCESS == dwStatus ){
        StringCchCat( strFile, cchSize, strGUID );
    }

    return dwStatus;
}

_inline BOOL IsTextFormat( DWORD dwFormat )
{
    switch( dwFormat ){
    case PDH_LOG_TYPE_CSV:
    case PDH_LOG_TYPE_TSV:
    case PDH_LOG_TYPE_SQL:
        return TRUE;
    default:
        return FALSE;
    }
}

DWORD
GetLogFormat( LPTSTR str, LPDWORD pdwFormat )
{
    DWORD dwFormat = PDH_LOG_TYPE_UNDEFINED;

    if( str != NULL ){
        if( !_tcsicmp( str, _T("TSV")) ){
            dwFormat = PDH_LOG_TYPE_TSV;
        }else if( !_tcsicmp( str, _T("CSV")) ){
            dwFormat = PDH_LOG_TYPE_CSV;
        }else if( !_tcsicmp( str, _T("SQL")) ){
            dwFormat = PDH_LOG_TYPE_SQL;
        }else if( !_tcsicmp( str, _T("BIN")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }else if( !_tcsicmp( str, _T("ETL")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }else if( !_tcsicmp( str, _T("BLG")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }
    }

    if( dwFormat == PDH_LOG_TYPE_UNDEFINED ){
        return RELOG_ERROR_BADFORMAT;
    }

    *pdwFormat = dwFormat;

    return ERROR_SUCCESS;
}

PDH_STATUS 
RelogGetMachines( HLOG hLog, LPTSTR* mszMachines )
{
    PDH_STATUS pdhStatus;
    DWORD dwSize = 0;

    pdhStatus = PdhEnumMachinesH( hLog, NULL, &dwSize );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        *mszMachines = (LPTSTR)VARG_ALLOC( sizeof(TCHAR)*dwSize );
        if( *mszMachines != NULL ){
            pdhStatus = PdhEnumMachinesH( hLog, *mszMachines, &dwSize );
        }else{
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    return pdhStatus;

}

PDH_STATUS 
RelogAddCounter( BOOL bExpand, HLOG hLog, HQUERY hQuery, LPTSTR strCounter, LPTSTR mszMachines )
{
    PDH_STATUS pdhStatus;
    HCOUNTER pCounter;
    
    LPTSTR szMachineList;

    PPDH_COUNTER_PATH_ELEMENTS pPathElements = NULL;
    DWORD dwPathElementsBufferSize = 0;

    LPTSTR szPathBuffer = NULL;
    DWORD  dwPathBufferSize = 0;

    LPTSTR szExpandedPathBuffer = NULL;
    DWORD  dwExpandedPathBufferSize = 0;
    
    BOOL bMachineDeclared = FALSE;

    if( hQuery == NULL || strCounter == NULL ){
        return ERROR_SUCCESS;
    }
   
    // 
    // Parse original path
    //

    if( _tcslen( strCounter ) > 3 ){
        if( strCounter[1] == _T('\\') ){
            bMachineDeclared = TRUE;
        }
    }

    do{
        pdhStatus = PdhParseCounterPath( strCounter, pPathElements, &dwPathElementsBufferSize, 0 );
    
        if( PDH_MORE_DATA == pdhStatus ){
            VARG_FREE( pPathElements );
            pPathElements = (PPDH_COUNTER_PATH_ELEMENTS)VARG_ALLOC( ++dwPathElementsBufferSize );
            if( NULL == pPathElements ){
                break;
            }
        }
    
    }while( PDH_MORE_DATA == pdhStatus );

    if( NULL == pPathElements ){
        return ERROR_OUTOFMEMORY;
    }

    //
    // If the original path contains a machine name
    // only add that machine.  Otherwise counter for
    // all machines in the mszMachines list
    //

    if( bMachineDeclared ){
        szMachineList = pPathElements->szMachineName;
    }else{
        szMachineList = mszMachines;
    }

    while( NULL != szMachineList ){

        pPathElements->szMachineName = szMachineList;

        do{
            pdhStatus = PdhMakeCounterPath( pPathElements, szPathBuffer, &dwPathBufferSize, 0 );

            if( PDH_MORE_DATA == pdhStatus ){
                VARG_FREE( szPathBuffer );
                szPathBuffer = (LPTSTR)VARG_ALLOC( ++dwPathBufferSize * sizeof(TCHAR) );
                if( NULL == szPathBuffer ){
                    break;
                }
            }
    
        }while( PDH_MORE_DATA == pdhStatus );


        //  
        // If writing to a text file wild cards must be expanded
        //

        if( bExpand ){
            
            do{
                pdhStatus = PdhExpandWildCardPathH(
                            hLog,
                            szPathBuffer,
                            szExpandedPathBuffer,
                            &dwExpandedPathBufferSize,
                            0
                        );

                if( PDH_MORE_DATA == pdhStatus ){
                    VARG_FREE( szExpandedPathBuffer );
                    szExpandedPathBuffer = (LPTSTR)VARG_ALLOC( ++dwExpandedPathBufferSize * sizeof(TCHAR) );
                    if( szExpandedPathBuffer == NULL ){
                        break;
                    }
                }
            }while(PDH_MORE_DATA == pdhStatus);

            if( ERROR_SUCCESS == pdhStatus && szExpandedPathBuffer != NULL ){
            
                LPTSTR szCounter = szExpandedPathBuffer;
                while( *szCounter != _T('\0') ){
                    pdhStatus = PdhAddCounter(
                            hQuery,
                            szCounter,
                            0,
                            &pCounter
                        );
                    szCounter += (_tcslen( szCounter) +1 );
                }
            }
            
        }else{
            pdhStatus = PdhAddCounter(
                    hQuery,
                    szPathBuffer,
                    0,
                    &pCounter
                );
        }

        if( bMachineDeclared ){
            szMachineList = NULL;
        }else{
            szMachineList += (_tcslen( szMachineList ) + 1);
            if( _T('\0') == *szMachineList ){
                szMachineList = NULL;
            }
        }
    }
  
    VARG_FREE( szPathBuffer );
    VARG_FREE( pPathElements );
    VARG_FREE( szExpandedPathBuffer );
    
    return ERROR_SUCCESS;
}

PDH_STATUS
AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    PDH_STATUS pdhStatus;
    LPTSTR strPath = Commands[eCounters].strValue;
    LPTSTR mszMachines = NULL;
    RelogGetMachines( hLog, &mszMachines );
    if( strPath != NULL ){
        while( *strPath != _T('\0') ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, strPath, mszMachines );    
            strPath += _tcslen( strPath )+1;
        }
    }

    VARG_FREE( mszMachines );
    return ERROR_SUCCESS;
}

PDH_STATUS 
GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    TCHAR buffer[MAXSTR];
    PDH_STATUS pdhStatus;
    LPTSTR strCounter = NULL;
    LPTSTR mszMachines = NULL;

    FILE* f = _tfopen( Commands[eCounterFile].strValue, _T("r") );

    if( !f ){
        DWORD dwStatus = GetLastError();
        return PDH_FILE_NOT_FOUND;
    }

    RelogGetMachines( hLog, &mszMachines );

    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }

        Chomp(buffer);

        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter != NULL ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, buffer, mszMachines );
        }
    }

    fclose( f );
    VARG_FREE( mszMachines );

    return ERROR_SUCCESS;
}

_inline BOOL IsSameInstance( LPTSTR strLastInstance, LPTSTR strInstance )
{
    if( strLastInstance == NULL || strInstance == NULL ){
        return FALSE;
    }

    return ( _tcscmp( strLastInstance, strInstance ) == 0 );
}

PDH_STATUS 
QueryLog( HLOG hLog, HQUERY hQuery, FILE* f )
{
    PDH_STATUS pdhStatus;

    LPTSTR mszMachines = NULL;
    LPTSTR strMachine = NULL;
    LPTSTR strFullCounterPath = NULL;
    DWORD  dwFullCounterPathSize = 0;
    DWORD  dwMachines = 0;
    HCOUNTER pCounter;

    pdhStatus = PdhEnumMachinesH( hLog, mszMachines, &dwMachines );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        mszMachines = (LPTSTR)VARG_ALLOC( dwMachines * sizeof(TCHAR) );
        if( mszMachines == NULL ){

            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
        pdhStatus = PdhEnumMachinesH( hLog, mszMachines, &dwMachines );

        if( ERROR_SUCCESS == pdhStatus ){
            strMachine = mszMachines;
            while( NULL != strMachine && strMachine[0] != _T('\0') ){
               
                LPTSTR mszObjects = NULL;
                LPTSTR strObject = NULL;
                DWORD  dwObjects = 0;

                pdhStatus = PdhEnumObjectsH( 
                            hLog, 
                            strMachine, 
                            mszObjects, 
                            &dwObjects, 
                            PERF_DETAIL_WIZARD, 
                            FALSE 
                        );

                if( ERROR_SUCCESS == pdhStatus || 
                    PDH_MORE_DATA == pdhStatus || 
                    PDH_INSUFFICIENT_BUFFER == pdhStatus ){

                    mszObjects = (LPTSTR)VARG_ALLOC( dwObjects * sizeof(TCHAR));
                    if( mszObjects == NULL ){
                        VARG_FREE( mszMachines );
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto cleanup;
                    }
                    pdhStatus = PdhEnumObjectsH( 
                                hLog, 
                                strMachine, 
                                mszObjects, 
                                &dwObjects, 
                                PERF_DETAIL_WIZARD, 
                                FALSE 
                            );

                    strObject = mszObjects;
                    while( NULL != strObject && strObject[0] != _T('\0') ){

                        LPTSTR mszCounters = NULL;
                        LPTSTR strCounter = NULL;
                        LPTSTR mszInstances = NULL;
                        LPTSTR strInstance = NULL;
                        DWORD  dwCounters = 0;
                        DWORD  dwInstances = 0;

                        pdhStatus = PdhEnumObjectItemsH( 
                                    hLog, 
                                    strMachine, 
                                    strObject, 
                                    mszCounters, 
                                    &dwCounters, 
                                    mszInstances, 
                                    &dwInstances, 
                                    PERF_DETAIL_WIZARD, 
                                    0 
                                );

                        if( ERROR_SUCCESS == pdhStatus || 
                            PDH_MORE_DATA == pdhStatus || 
                            PDH_INSUFFICIENT_BUFFER == pdhStatus ){
                            
                            if( dwCounters > 0 ){
                                mszCounters = (LPTSTR)VARG_ALLOC( dwCounters * sizeof(TCHAR) );
                            }
                            if( dwInstances > 0 ){
                                mszInstances = (LPTSTR)VARG_ALLOC( dwInstances * sizeof(TCHAR) );
                            }
                            
                            if( (mszCounters == NULL && dwCounters > 0 ) || 
                                (mszInstances == NULL && dwInstances > 0) ){
                                
                                VARG_FREE( mszMachines );
                                VARG_FREE( mszObjects );
                                VARG_FREE( mszCounters );
                                VARG_FREE( mszInstances );
                                
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                goto cleanup;
                            }
                            
                            pdhStatus = PdhEnumObjectItemsH( 
                                        hLog, 
                                        strMachine, 
                                        strObject, 
                                        mszCounters, 
                                        &dwCounters, 
                                        mszInstances,
                                        &dwInstances, 
                                        PERF_DETAIL_WIZARD, 
                                        0 
                                    );

                            if( ERROR_SUCCESS == pdhStatus ){
                                strCounter = mszCounters;
                                while( NULL != strCounter && strCounter[0] != _T('\0') ){
                                    PDH_COUNTER_PATH_ELEMENTS_W pdhElements;
                                    ZeroMemory( &pdhElements, sizeof( PDH_COUNTER_PATH_ELEMENTS ) );

                                    pdhElements.szMachineName = strMachine;
                                    pdhElements.szObjectName = strObject;
                                    pdhElements.szCounterName = strCounter;
                                    strInstance = mszInstances;
                                    
                                    if( NULL != strInstance && strInstance[0] != _T('\0') ){
                                        LPTSTR strLastInstance = NULL;
                                        ULONG nInstance = 0;
                                        while( strInstance[0] != _T('\0') ){

                                            DWORD dwSize = dwFullCounterPathSize;
                                            pdhElements.szInstanceName = strInstance;
                                            
                                            if( ! IsSameInstance( strLastInstance, strInstance ) ){
                                                pdhElements.dwInstanceIndex = -1;
                                                nInstance = 0;
                                            }else{
                                                pdhElements.dwInstanceIndex = ++nInstance;
                                            }

                                            pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ){
                                                VARG_FREE( strFullCounterPath );
                                                strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                                if( NULL != strFullCounterPath ){
                                                    dwFullCounterPathSize = dwSize;
                                                    pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                                }
                                            }

                                            strLastInstance = strInstance;
                                            strInstance += _tcslen( strInstance ) + 1;
                                            if( Commands[eQuery].bValue ){
                                                if( NULL != f ){
                                                    _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                                }else{
                                                    varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                                }
                                            }

                                            if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                                pdhStatus = PdhAddCounter(
                                                        hQuery,
                                                        strFullCounterPath,
                                                        0,
                                                        &pCounter
                                                    );
                                            }
                                        }
                                    }else{
                                        DWORD dwSize = dwFullCounterPathSize;
                                        pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                        if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ){
                                            VARG_FREE( strFullCounterPath );
                                            strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                            if( NULL != strFullCounterPath ){
                                                dwFullCounterPathSize = dwSize;
                                                pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            }
                                        }
                                        
                                        if( Commands[eQuery].bValue ){
                                            if( NULL != f ){
                                                _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                            }else{
                                                varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                            }
                                        }

                                        if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                            pdhStatus = PdhAddCounter(
                                                    hQuery,
                                                    strFullCounterPath,
                                                    0,
                                                    &pCounter
                                                );
                                        }
                                    }

                                    
                                    strCounter += _tcslen( strCounter ) + 1;
                                }
                            }

                            VARG_FREE( mszCounters );
                            VARG_FREE( mszInstances );

                        }


                        strObject += _tcslen( strObject ) + 1;
                    }
                    VARG_FREE( mszObjects );
                }
                
                
                strMachine += _tcslen( strMachine ) + 1;
            }
        }

        VARG_FREE( mszMachines );
    }

cleanup:
    
    VARG_FREE( strFullCounterPath );

    if( NULL == f ){
        if( ERROR_SUCCESS == pdhStatus && Commands[eQuery].bValue){
            varg_printf( g_normal, _T("\n") );
        }
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\win2000\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define    IDS_PARAM_APPEND          110
#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_QUERY           125
#define    IDS_PARAM_COUNTERS        128
#define    IDS_PARAM_BEGIN           131
#define    IDS_PARAM_END             134
#define    IDS_PARAM_COUNTERFILE     140
#define    IDS_PARAM_YES             141
#define    IDS_PARAM_FORCERUN        142

#define    IDS_DEFAULT_OUTPUT        600

#define    IDS_MESSAGE_INPUT         700
#define    IDS_MESSAGE_OUTPUT        701
#define    IDS_MESSAGE_FILE          702
#define    IDS_MESSAGE_FILES         703
#define    IDS_MESSAGE_BEGIN         704
#define    IDS_MESSAGE_END           705
#define    IDS_MESSAGE_SAMPLES       706
#define    IDS_MESSAGE_LOG_OLD_BIN   707
#define    IDS_MESSAGE_LOG_CSV       708
#define    IDS_MESSAGE_LOG_TSV       709
#define    IDS_MESSAGE_LOG_BINARY    710
#define    IDS_MESSAGE_LOG_PERFMON   711
#define    IDS_MESSAGE_LOG_UNKNOWN   712    
#define    IDS_MESSAGE_BADFILES      713
#define    IDS_MESSAGE_BADFORMAT     714
#define    IDS_MESSAGE_BADRANGE      715
#define    IDS_MESSAGE_APPENDTIME    716
#define    IDS_MESSAGE_BADHEADERS    717
#define    IDS_MESSAGE_TYPEMISMATCH  718
#define    IDS_MESSAGE_BADOS         719


#define    IDS_EXAMPLE_FORMAT        800
#define    IDS_EXAMPLE_QUERY         801
#define    IDS_EXAMPLE_COUNTERFILE   802
#define    IDS_EXAMPLE_COUNTERS      803
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\win2000\relogger.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>

#include <pdh.h>
#include <pdhmsg.h>
#include <pdhp.h>

#include "rpdh.h"
#include "resource.h"

#include "varg.c"

DWORD GetLogFormat( LPTSTR str, LPDWORD pdwFormat );
PDH_STATUS GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery );
PDH_STATUS QueryLog( HLOG hLog, HQUERY hQuery, FILE* f );
PDH_STATUS AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery );
_inline BOOL IsTextFormat( DWORD dwFormat );
DWORD ValidateBuild();

#define CHECK_STATUS( hr )       if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define RELOG_ERROR_BADFILES    0xF0000001
#define RELOG_ERROR_BADFORMAT   0xF0000002
#define RELOG_ERROR_TIMERANGE   0xF0000003
#define RELOG_ERROR_BADAPPEND   0xF0000004
#define RELOG_ERROR_BADOS       0xF0000005

#define WINDOWS_2000            (2195)
#define REQUIRED_SERVICE_PACK   (3)

VARG_DECLARE_COMMANDS
    VARG_DEBUG( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP ( VARG_FLAG_OPTIONAL )
    VARG_BOOL ( IDS_PARAM_APPEND,       VARG_FLAG_OPTIONAL, FALSE )    
    VARG_MSZ  ( IDS_PARAM_COUNTERS,     VARG_FLAG_OPTIONAL, _T("") )
    VARG_STR  ( IDS_PARAM_COUNTERFILE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME, _T("") )
    VARG_STR  ( IDS_PARAM_FORMAT,       VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("BIN") )
    VARG_STR  ( IDS_PARAM_INPUT,        VARG_FLAG_REQUIRED|VARG_FLAG_NOFLAG|VARG_FLAG_ARG_FILENAME, _T("") ) 
    VARG_INT  ( IDS_PARAM_INTERVAL,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT, 0 )
    VARG_STR  ( IDS_PARAM_OUTPUT,       VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_OUTPUT )
    VARG_DATE ( IDS_PARAM_BEGIN,        VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_DATE ( IDS_PARAM_END,          VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_INI  ( IDS_PARAM_SETTINGS,     VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL ( IDS_PARAM_QUERY,        VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL ( IDS_PARAM_YES,          VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL ( IDS_PARAM_FORCERUN,     VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eAppend,
    eCounters,
    eCounterFile,
    eFormat,
    eInput,
    eInterval,
    eOutput,
    eBegin,
    eEnd,
    eSettings,
    eQuery,
    eYes,
    eForceRun
VARG_DECLARE_FORMAT
    VARG_EXHELP( eFormat,       IDS_EXAMPLE_FORMAT )
    VARG_EXHELP( eQuery,        IDS_EXAMPLE_QUERY )
    VARG_EXHELP( eCounterFile,  IDS_EXAMPLE_COUNTERFILE )
    VARG_EXHELP( eCounters,     IDS_EXAMPLE_COUNTERS )
VARG_DECLARE_END

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PDH_RELOG_INFO RelogInfo;
    DWORD dwOutputFormat;
    DWORD dwInputFormat;
    PDH_TIME_INFO InputTimeRange;
    LPTSTR strFile = NULL;
    TCHAR strOutputFile[MAXSTR] = _T("\0");
    DWORD dwNumEntries = 1;
    DWORD dwBufferSize = sizeof(PDH_TIME_INFO);
    int nBinary = 0;
    int nFiles = 0;

    ParseCmd( argc, argv );
    
    HLOG hLogIn = NULL;
    HQUERY hQuery = NULL;
    
    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO) );

    if( ! Commands[eForceRun].bValue ){
        dwStatus = ValidateBuild();
        CHECK_STATUS( dwStatus );
    }


    if( Commands[eInput].strValue == NULL ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
 
    dwStatus = GetLogFormat( Commands[eFormat].strValue, &dwOutputFormat );
    CHECK_STATUS(dwStatus);
    
    strFile = Commands[eInput].strValue;
    PrintMessage( g_normal, IDS_MESSAGE_INPUT );
    PrintMessage( g_normal, IDS_MESSAGE_FILES );

    pdhStatus = R_PdhGetLogFileType( strFile, &dwInputFormat );
    if( pdhStatus != ERROR_SUCCESS ){
        dwInputFormat = 0;
    }
    switch( dwInputFormat ){
    case PDH_LOG_TYPE_RETIRED_BIN_:
        PrintMessage( g_normal, IDS_MESSAGE_LOG_OLD_BIN, strFile );
        break;
    case PDH_LOG_TYPE_CSV:
        PrintMessage( g_normal, IDS_MESSAGE_LOG_CSV, strFile );
        break;
    case PDH_LOG_TYPE_TSV:
        PrintMessage( g_normal, IDS_MESSAGE_LOG_TSV, strFile );
        break;
    case PDH_LOG_TYPE_BINARY:
        nBinary++;
        PrintMessage( g_normal, IDS_MESSAGE_LOG_BINARY, strFile );
        break;
    case PDH_LOG_TYPE_PERFMON:
        PrintMessage( g_normal, IDS_MESSAGE_LOG_PERFMON, strFile );
        break;
    default:
        PrintMessage( g_normal, IDS_MESSAGE_LOG_UNKNOWN, strFile );
    }
    varg_printf( g_normal, _T("\n") );

    if( nFiles > 1 && nFiles > nBinary ){
        dwStatus = RELOG_ERROR_BADFILES;
        goto cleanup;
    }

    pdhStatus = PdhOpenLogW( 
                    Commands[eInput].strValue, 
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    &dwInputFormat,
                    NULL,
                    0,
                    NULL,
                    & hLogIn 
                );
    CHECK_STATUS( pdhStatus );
    
    pdhStatus = PdhGetDataSourceTimeRange (
                Commands[eInput].strValue,
                &dwNumEntries,
                &InputTimeRange,
                &dwBufferSize
            );
    CHECK_STATUS( pdhStatus );
    
    SYSTEMTIME st;
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.StartTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
    PrintDate( &st );
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.EndTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_END );
    PrintDate( &st );
    PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, InputTimeRange.SampleCount );

    if( Commands[eAppend].bValue ){
    
        StringCchCopy( strOutputFile, MAXSTR, Commands[eOutput].strValue );

        pdhStatus = R_PdhAppendLog( Commands[eOutput].strValue, Commands[eInput].strValue );
        CHECK_STATUS( pdhStatus );
    
    }else{

        pdhStatus = PdhOpenQuery( Commands[eInput].strValue, NULL, &hQuery );
        CHECK_STATUS( pdhStatus );

        if( Commands[eQuery].bDefined ){
            FILE* f = NULL;
            if( Commands[eOutput].bDefined ){
                dwStatus = CheckFile( Commands[eOutput].strValue, 
                                Commands[eYes].bValue ? 
                                VARG_CF_OVERWRITE : 
                                (VARG_CF_PROMPT|VARG_CF_OVERWRITE) 
                            );
                CHECK_STATUS( dwStatus );

                f = _tfopen( Commands[eOutput].strValue, _T("w") );
                if( NULL == f ){
                    dwStatus = GetLastError();
                }
            }
            pdhStatus = QueryLog( hLogIn, hQuery, f );
            if( NULL != f ){
                fclose(f);
            }

        }else if( (!Commands[eCounters].bDefined && !Commands[eCounterFile].bDefined) ){
        
            pdhStatus = QueryLog( hLogIn, hQuery, NULL );
            CHECK_STATUS( pdhStatus );
        }

        if( Commands[eCounters].bDefined ){
            pdhStatus = AddCounters( dwInputFormat, hLogIn, hQuery );
            CHECK_STATUS( pdhStatus );
        }

        if( Commands[eCounterFile].bDefined ){
            pdhStatus = GetCountersFromFile( 
                            (IsTextFormat( dwInputFormat ) || IsTextFormat(dwOutputFormat)), 
                            hLogIn, 
                            hQuery 
                        );
            CHECK_STATUS( pdhStatus );
        }

        if( Commands[eBegin].bDefined ){
            FILETIME   ft;
            SystemTimeToFileTime( &Commands[eBegin].stValue, &ft );
            RelogInfo.TimeInfo.StartTime = *(LONGLONG *)&ft;
            if( RelogInfo.TimeInfo.StartTime >= InputTimeRange.EndTime ){
                dwStatus = RELOG_ERROR_TIMERANGE;
            }
            CHECK_STATUS(dwStatus);
        }

        if( Commands[eEnd].bDefined ){
            FILETIME   ft;
            SystemTimeToFileTime( &Commands[eEnd].stValue, &ft );
            RelogInfo.TimeInfo.EndTime = *(LONGLONG *)&ft;
            if( RelogInfo.TimeInfo.EndTime <= InputTimeRange.StartTime ){
                dwStatus = RELOG_ERROR_TIMERANGE;
            }
            CHECK_STATUS(dwStatus);
        }
        if( Commands[eOutput].bDefined && !Commands[eQuery].bDefined ){
            TCHAR drive[_MAX_DRIVE];
            TCHAR path[_MAX_DIR];
            TCHAR file[_MAX_FNAME];
            TCHAR ext[_MAX_EXT];
            
            RelogInfo.dwFileFormat = dwOutputFormat;
            _tsplitpath( Commands[eOutput].strValue, drive, path, file, ext );
            
            if( 0 == _tcslen( ext ) ){
                switch( RelogInfo.dwFileFormat ){
                case PDH_LOG_TYPE_TSV: StringCchCopy( ext, _MAX_EXT, _T("tsv") ); break;
                case PDH_LOG_TYPE_CSV: StringCchCopy( ext, _MAX_EXT, _T("csv") ); break;
                case PDH_LOG_TYPE_SQL: break;
                case PDH_LOG_TYPE_BINARY: 
                case PDH_LOG_TYPE_RETIRED_BIN_:
                    StringCchCopy( ext, _MAX_EXT, _T("blg") ); break;
                }
            }
            _tmakepath( strOutputFile, drive, path, file, ext );
        
            RelogInfo.dwFlags = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;

            RelogInfo.strLog = strOutputFile;
            RelogInfo.TimeInfo.SampleCount = Commands[eInterval].nValue;
 
            dwStatus = CheckFile( strOutputFile, Commands[eYes].bValue ? VARG_CF_OVERWRITE : (VARG_CF_PROMPT|VARG_CF_OVERWRITE) );
            CHECK_STATUS(dwStatus);

            pdhStatus = R_PdhRelog( Commands[eInput].strValue, hQuery, &RelogInfo );
            CHECK_STATUS( pdhStatus );
        }
    }


    if( Commands[eOutput].bDefined && !Commands[eQuery].bDefined && pdhStatus == ERROR_SUCCESS ){

        pdhStatus = PdhGetDataSourceTimeRange (
            strOutputFile,
            &dwNumEntries,
            &InputTimeRange,
            &dwBufferSize
        );
        CHECK_STATUS( pdhStatus );

        PrintMessage( g_normal, IDS_MESSAGE_OUTPUT );
        PrintMessage( g_normal, IDS_MESSAGE_FILE, strOutputFile );

        SYSTEMTIME st;
        FileTimeToSystemTime( (FILETIME *)&InputTimeRange.StartTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
        PrintDate( &st );
        FileTimeToSystemTime( (FILETIME *)&InputTimeRange.EndTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_END );
        PrintDate( &st );
        PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, InputTimeRange.SampleCount );
    }
    
cleanup:
    if( hLogIn != NULL ){
        PdhCloseLog( hLogIn, PDH_FLAGS_CLOSE_QUERY );
    }

    switch( dwStatus ){
    case RELOG_ERROR_BADOS:
        varg_printf( g_normal, _T("\n") );
        PrintMessage( g_debug, IDS_MESSAGE_BADOS );
        break;
    case RELOG_ERROR_TIMERANGE:
        PrintMessage( g_debug, IDS_MESSAGE_BADRANGE );
        break;
    case RELOG_ERROR_BADFORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADAPPEND:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADFILES:
        PrintMessage( g_debug, IDS_MESSAGE_BADFILES );
        break;
    case ERROR_SUCCESS:
        if( ERROR_SUCCESS == pdhStatus ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        }else{
            switch( pdhStatus ){
            case PDH_TIME_MISMATCH:
                PrintMessage( g_debug, IDS_MESSAGE_APPENDTIME );
                break;
            case PDH_HEADER_MISMATCH:
                PrintMessage( g_debug, IDS_MESSAGE_BADHEADERS );
                break;
            case PDH_TYPE_MISMATCH:
                PrintMessage( g_debug, IDS_MESSAGE_TYPEMISMATCH );
                break;
            default:
                PrintErrorEx( pdhStatus, _T("PDH.DLL") );
            }
            dwStatus = pdhStatus;
        }
        break;
    default:
        PrintError( dwStatus );
    }

    FreeCmd();

    return dwStatus;
}

_inline BOOL IsTextFormat( DWORD dwFormat )
{
    switch( dwFormat ){
    case PDH_LOG_TYPE_CSV:
    case PDH_LOG_TYPE_TSV:
    case PDH_LOG_TYPE_SQL:
        return TRUE;
    default:
        return FALSE;
    }
}

DWORD
GetLogFormat( LPTSTR str, LPDWORD pdwFormat )
{
    DWORD dwFormat = PDH_LOG_TYPE_UNDEFINED;

    if( str != NULL ){
        if( !_tcsicmp( str, _T("TSV")) ){
            dwFormat = PDH_LOG_TYPE_TSV;
        }else if( !_tcsicmp( str, _T("CSV")) ){
            dwFormat = PDH_LOG_TYPE_CSV;
        }else if( !_tcsicmp( str, _T("BIN")) ){
            dwFormat = PDH_LOG_TYPE_RETIRED_BIN_;
        }else if( !_tcsicmp( str, _T("BLG")) ){
            dwFormat = PDH_LOG_TYPE_RETIRED_BIN_;
        }
    }

    if( dwFormat == PDH_LOG_TYPE_UNDEFINED ){
        return RELOG_ERROR_BADFORMAT;
    }

    *pdwFormat = dwFormat;

    return ERROR_SUCCESS;
}

PDH_STATUS 
RelogGetMachines( HLOG hLog, LPTSTR* mszMachines )
{
    PDH_STATUS pdhStatus;
    DWORD dwSize = 0;

    pdhStatus = PdhEnumMachines( Commands[eInput].strValue, NULL, &dwSize );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        *mszMachines = (LPTSTR)VARG_ALLOC( sizeof(TCHAR)*dwSize );
        if( *mszMachines != NULL ){
            pdhStatus = PdhEnumMachines( Commands[eInput].strValue, *mszMachines, &dwSize );
        }else{
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    return pdhStatus;

}

PDH_STATUS 
RelogAddCounter( BOOL bExpand, HLOG hLog, HQUERY hQuery, LPTSTR strCounter, LPTSTR mszMachines )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HCOUNTER pCounter;

    if( hQuery == NULL || strCounter == NULL ){
        return ERROR_SUCCESS;
    }
    
    if( _tcslen( strCounter ) > 3 ){
        if( strCounter[1] == _T('\\') ){
            pdhStatus = PdhAddCounter(
                    hQuery,
                    strCounter,
                    0,
                    &pCounter
                );
        }else{
            TCHAR buffer[MAXSTR];
            LPTSTR strMachine = mszMachines;
            if( strMachine != NULL ){
                while( *strMachine != _T('\0') ){

                    StringCchPrintf( buffer, MAXSTR, _T("%s%s%s"), 
                        strMachine,
                        (*strCounter == _T('\\')) ? _T("") : _T("\\"),
                        strCounter );

                    if( bExpand ){

                        LPTSTR pBuffer = NULL;
                        DWORD dwBufferSize = 0;
                        do{
                            pdhStatus = PdhExpandWildCardPath(
                                        Commands[eInput].strValue,
                                        buffer,
                                        pBuffer,
                                        &dwBufferSize,
                                        0
                                    );

                            if( PDH_MORE_DATA == pdhStatus ){
                                VARG_FREE( pBuffer );
                                pBuffer = (LPTSTR)VARG_ALLOC( ++dwBufferSize * sizeof(TCHAR) );
                                if( pBuffer == NULL ){
                                    break;
                                }
                            }
                        }while(PDH_MORE_DATA == pdhStatus);

                        if( ERROR_SUCCESS == pdhStatus && pBuffer != NULL ){
                        
                            LPTSTR szCounter = pBuffer;
                            while( *szCounter != _T('\0') ){
                                pdhStatus = PdhAddCounter(
                                        hQuery,
                                        szCounter,
                                        0,
                                        &pCounter
                                    );
                                szCounter += (_tcslen( szCounter) +1 );
                            }
                        }
                        
                        VARG_FREE( pBuffer );

                    }else{

                        pdhStatus = PdhAddCounter(
                                hQuery,
                                buffer,
                                0,
                                &pCounter
                            );
                    }
                    strMachine += (_tcslen( strMachine ) + 1);
                    
                }
            }

        }
    }

    return ERROR_SUCCESS;
}

PDH_STATUS
AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    PDH_STATUS pdhStatus;
    LPTSTR strPath = Commands[eCounters].strValue;
    LPTSTR mszMachines = NULL;
    RelogGetMachines( hLog, &mszMachines );
    if( strPath != NULL ){
        while( *strPath != _T('\0') ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, strPath, mszMachines );    
            strPath += _tcslen( strPath )+1;
        }
    }

    VARG_FREE( mszMachines );
    return ERROR_SUCCESS;
}

PDH_STATUS 
GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    TCHAR buffer[MAXSTR];
    PDH_STATUS pdhStatus;
    LPTSTR strCounter = NULL;
    LPTSTR mszMachines = NULL;

    FILE* f = _tfopen( Commands[eCounterFile].strValue, _T("r") );

    if( !f ){
        DWORD dwStatus = GetLastError();
        return PDH_LOG_FILE_OPEN_ERROR;
    }

    RelogGetMachines( hLog, &mszMachines );

    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }

        Chomp(buffer);

        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter != NULL ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, buffer, mszMachines );
        }
    }

    fclose( f );
    VARG_FREE( mszMachines );

    return ERROR_SUCCESS;
}

_inline BOOL IsSameInstance( LPTSTR strLastInstance, LPTSTR strInstance )
{
    if( strLastInstance == NULL || strInstance == NULL ){
        return FALSE;
    }

    return ( _tcscmp( strLastInstance, strInstance ) == 0 );
}

PDH_STATUS 
QueryLog( HLOG hLog, HQUERY hQuery, FILE* f )
{
    PDH_STATUS pdhStatus;

    LPTSTR mszMachines = NULL;
    LPTSTR strMachine = NULL;
    LPTSTR strFullCounterPath = NULL;
    DWORD  dwFullCounterPathSize = 0;
    DWORD  dwMachines = 0;
    HCOUNTER pCounter;

    pdhStatus = PdhEnumMachines( Commands[eInput].strValue, mszMachines, &dwMachines );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        mszMachines = (LPTSTR)VARG_ALLOC( dwMachines * sizeof(TCHAR) );
        if( mszMachines == NULL ){

            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
        pdhStatus = PdhEnumMachines( Commands[eInput].strValue, mszMachines, &dwMachines );

        if( ERROR_SUCCESS == pdhStatus ){
            strMachine = mszMachines;
            while( NULL != strMachine && strMachine[0] != _T('\0') ){
               
                LPTSTR mszObjects = NULL;
                LPTSTR strObject = NULL;
                DWORD  dwObjects = 0;

                pdhStatus = PdhEnumObjects( 
                            Commands[eInput].strValue, 
                            strMachine, 
                            mszObjects, 
                            &dwObjects, 
                            PERF_DETAIL_WIZARD, 
                            FALSE 
                        );

                if( ERROR_SUCCESS == pdhStatus || 
                    PDH_MORE_DATA == pdhStatus || 
                    PDH_INSUFFICIENT_BUFFER == pdhStatus ){

                    mszObjects = (LPTSTR)VARG_ALLOC( dwObjects * sizeof(TCHAR));
                    if( mszObjects == NULL ){
                        VARG_FREE( mszMachines );
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto cleanup;
                    }
                    pdhStatus = PdhEnumObjects( 
                                Commands[eInput].strValue,
                                strMachine, 
                                mszObjects, 
                                &dwObjects, 
                                PERF_DETAIL_WIZARD, 
                                FALSE 
                            );

                    strObject = mszObjects;
                    while( NULL != strObject && strObject[0] != _T('\0') ){

                        LPTSTR mszCounters = NULL;
                        LPTSTR strCounter = NULL;
                        LPTSTR mszInstances = NULL;
                        LPTSTR strInstance = NULL;
                        DWORD  dwCounters = 0;
                        DWORD  dwInstances = 0;

                        pdhStatus = PdhEnumObjectItems( 
                                    Commands[eInput].strValue,
                                    strMachine, 
                                    strObject, 
                                    mszCounters, 
                                    &dwCounters, 
                                    mszInstances, 
                                    &dwInstances, 
                                    PERF_DETAIL_WIZARD, 
                                    0 
                                );

                        if( ERROR_SUCCESS == pdhStatus || 
                            PDH_MORE_DATA == pdhStatus || 
                            PDH_INSUFFICIENT_BUFFER == pdhStatus ){
                            
                            if( dwCounters > 0 ){
                                mszCounters = (LPTSTR)VARG_ALLOC( dwCounters * sizeof(TCHAR) );
                            }
                            if( dwInstances > 0 ){
                                mszInstances = (LPTSTR)VARG_ALLOC( dwInstances * sizeof(TCHAR) );
                            }
                            
                            if( (mszCounters == NULL && dwCounters > 0 ) || 
                                (mszInstances == NULL && dwInstances > 0) ){
                                
                                VARG_FREE( mszMachines );
                                VARG_FREE( mszObjects );
                                VARG_FREE( mszCounters );
                                VARG_FREE( mszInstances );
                                
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                goto cleanup;
                            }
                            
                            pdhStatus = PdhEnumObjectItems( 
                                        Commands[eInput].strValue,
                                        strMachine, 
                                        strObject, 
                                        mszCounters, 
                                        &dwCounters, 
                                        mszInstances,
                                        &dwInstances, 
                                        PERF_DETAIL_WIZARD, 
                                        0 
                                    );

                            if( ERROR_SUCCESS == pdhStatus ){
                                strCounter = mszCounters;
                                while( NULL != strCounter && strCounter[0] != _T('\0') ){
                                    PDH_COUNTER_PATH_ELEMENTS_W pdhElements;
                                    ZeroMemory( &pdhElements, sizeof( PDH_COUNTER_PATH_ELEMENTS ) );

                                    pdhElements.szMachineName = strMachine;
                                    pdhElements.szObjectName = strObject;
                                    pdhElements.szCounterName = strCounter;
                                    strInstance = mszInstances;
                                    
                                    if( NULL != strInstance && strInstance[0] != _T('\0') ){
                                        LPTSTR strLastInstance = NULL;
                                        ULONG nInstance = 0;
                                        while( strInstance[0] != _T('\0') ){

                                            DWORD dwSize = dwFullCounterPathSize;
                                            pdhElements.szInstanceName = strInstance;
                                            
                                            if( ! IsSameInstance( strLastInstance, strInstance ) ){
                                                pdhElements.dwInstanceIndex = -1;
                                                nInstance = 0;
                                            }else{
                                                pdhElements.dwInstanceIndex = ++nInstance;
                                            }

                                            pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus || ERROR_SUCCESS == pdhStatus ){
                                                VARG_FREE( strFullCounterPath );
                                                strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                                if( NULL != strFullCounterPath ){
                                                    dwFullCounterPathSize = dwSize;
                                                    pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                                }
                                            }

                                            strLastInstance = strInstance;
                                            strInstance += _tcslen( strInstance ) + 1;
                                            if( Commands[eQuery].bValue ){
                                                if( NULL != f ){
                                                    _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                                }else{
                                                    varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                                }
                                            }

                                            if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                                pdhStatus = PdhAddCounter(
                                                        hQuery,
                                                        strFullCounterPath,
                                                        0,
                                                        &pCounter
                                                    );
                                            }
                                        }
                                    }else{
                                        DWORD dwSize = dwFullCounterPathSize;
                                        pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                        if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus || ERROR_SUCCESS == pdhStatus){
                                            VARG_FREE( strFullCounterPath );
                                            strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                            if( NULL != strFullCounterPath ){
                                                dwFullCounterPathSize = dwSize;
                                                pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            }
                                        }
                                        
                                        if( Commands[eQuery].bValue ){
                                            if( NULL != f ){
                                                _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                            }else{
                                                varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                            }
                                        }

                                        if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                            pdhStatus = PdhAddCounter(
                                                    hQuery,
                                                    strFullCounterPath,
                                                    0,
                                                    &pCounter
                                                );
                                        }
                                    }

                                    strCounter += _tcslen( strCounter ) + 1;
                                }
                            }

                            VARG_FREE( mszCounters );
                            VARG_FREE( mszInstances );
                        }

                        strObject += _tcslen( strObject ) + 1;
                    }
                    VARG_FREE( mszObjects );
                }
                
                strMachine += _tcslen( strMachine ) + 1;
            }
        }

        VARG_FREE( mszMachines );
    }

cleanup:
    
    VARG_FREE( strFullCounterPath );

    if( NULL == f ){
        if( ERROR_SUCCESS == pdhStatus && Commands[eQuery].bValue){
            varg_printf( g_normal, _T("\n") );
        }
    }

    return pdhStatus;
}

DWORD ValidateBuild()
{
    OSVERSIONINFO VersionInfo;
    BOOL bResult;

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionEx( &VersionInfo );

    return ERROR_SUCCESS;

    if( ! bResult ){
        ZeroMemory( &VersionInfo, sizeof( OSVERSIONINFO ) );
    }

    if( VersionInfo.dwBuildNumber == WINDOWS_2000 ){
        TCHAR  buffer[128];
        LPTSTR szServicePack;
        _tcsncpy( buffer, VersionInfo.szCSDVersion, 128 );

        szServicePack = _tcstok( buffer, _T(" \n") );
        szServicePack = _tcstok( NULL, _T(" \n") );
        szServicePack = _tcstok( NULL, _T(" \n") );

        if( szServicePack != NULL ){
            int nPack;
            nPack = _ttoi( szServicePack );
            if( nPack >= REQUIRED_SERVICE_PACK ){
                return ERROR_SUCCESS;
            }
        }
    }

    return RELOG_ERROR_BADOS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\logman\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2001 Microsoft Corporation

\*****************************************************************************/

#define    IDS_PARAM_COMPUTER       104
#define    IDS_PARAM_CREATE         108
#define    IDS_PARAM_START          109
#define    IDS_PARAM_STOP           112
#define    IDS_PARAM_DELETE         115
#define    IDS_PARAM_QUERY          118
#define    IDS_PARAM_BEGIN          124
#define    IDS_PARAM_END            127
#define    IDS_PARAM_REPEAT         130
#define    IDS_PARAM_NAME           133
#define    IDS_PARAM_OUTPUT         137
#define    IDS_PARAM_FORMAT         140
#define    IDS_PARAM_APPEND         144
#define    IDS_PARAM_VERSION        147
#define    IDS_PARAM_RUNCMD         151
#define    IDS_PARAM_MAX            154
#define    IDS_PARAM_NEWFILE        157
#define    IDS_PARAM_COUNTERS       160
#define    IDS_PARAM_COUNTERFILE    164
#define    IDS_PARAM_SAMPLERATE     167
#define    IDS_PARAM_LOGGERNAME     170
#define    IDS_PARAM_REALTIME       173
#define    IDS_PARAM_PROVIDER       176
#define    IDS_PARAM_PROVIDERFILE   179
#define    IDS_PARAM_USERMODE       182
#define    IDS_PARAM_BUFFERSIZE     185
#define    IDS_PARAM_FLUSHTIMER     188
#define    IDS_PARAM_BUFFERS        191
#define    IDS_PARAM_FLUSHBUFFERS   195
#define    IDS_PARAM_UPDATE         198
#define    IDS_PARAM_USER           202
#define    IDS_PARAM_RUNFOR         206
#define    IDS_PARAM_YES            209
#define    IDS_PARAM_MANUAL         217
#define    IDS_PARAM_ETS            218
#define    IDS_PARAM_AGE            219
#define    IDS_PARAM_MODE           220
#define    IDS_PARAM_COUNTER        221
#define    IDS_PARAM_TRACE          222
#define    IDS_PARAM_QUERYPROV      223
#define    IDS_PARAM_CLOCKTYPE      224

#define    IDS_MESSAGE_QUERY        600
#define    IDS_MESSAGE_QUERYF       601
#define    IDS_MESSAGE_PERF         605
#define    IDS_MESSAGE_EVENTTRACE   606
#define    IDS_MESSAGE_ALERT        607
#define    IDS_MESSAGE_STOPPED      608
#define    IDS_MESSAGE_RUNNING      609
#define    IDS_MESSAGE_PENDING      610
#define    IDS_MESSAGE_STATUS       611
#define    IDS_MESSAGE_NAME         612
#define    IDS_MESSAGE_TYPE         613
#define    IDS_MESSAGE_FILE         614
#define    IDS_MESSAGE_RUNAS        615
#define    IDS_MESSAGE_EUSER        616
#define    IDS_MESSAGE_EPASSWORD    617
#define    IDS_MESSAGE_THISCON      618
#define    IDS_MESSAGE_ETSQUERY     619
#define    IDS_MESSAGE_ETSQUERYF    620
#define    IDS_MESSAGE_ETSQUERYSF   621
#define    IDS_MESSAGE_COUNTERS     622
#define    IDS_MESSAGE_LOGGERNAME   623
#define    IDS_MESSAGE_BUFFERSIZE   624
#define    IDS_MESSAGE_BADPARAM     625
#define    IDS_MESSAGE_START        626
#define    IDS_MESSAGE_STOP         627
#define    IDS_MESSAGE_MANUAL       628
#define    IDS_MESSAGE_AFTER        629
#define    IDS_MESSAGE_REPEATING    630
#define    IDS_MESSAGE_BYSIZE       631
#define    IDS_MESSAGE_NEWFILE      632
#define    IDS_MESSAGE_PRVGUID      633
#define    IDS_MESSAGE_PROVIDERS    634
#define    IDS_MESSAGE_SYSTEM       635
#define    IDS_MESSAGE_QUERYP       636
#define    IDS_MESSAGE_ETSNAME      637
#define    IDS_MESSAGE_LOGMAN       638
#define    IDS_MESSAGE_WIN2000      639
#define    IDS_MESSAGE_ETSQUERYP    640
#define    IDS_MESSAGE_QUERYFL      641

#define    IDS_DEFAULT_OUTPUT       700
#define    IDS_DEFAULT_NNNNN        701
#define    IDS_DEFAULT_ETSENABLE    702

#define    IDS_EXAMPLE_ETS          800
#define    IDS_EXAMPLE_START        801
#define    IDS_EXAMPLE_CREATE       802
#define    IDS_EXAMPLE_UPDATE       803
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\logman\logman.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <wbemidl.h>
#include <conio.h>
#include <pdhp.h>
#include <pdhmsg.h>
#include <lmuse.h>
#include "resource.h"
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <shlwapi.h>

#include "logmmsg.h"
#include "varg.c"

// Exclusive
#define GROUP_START     0x01
#define GROUP_END       0x02

// Group Exclusive
#define GROUP_COUNTER   0x01
#define GROUP_TRACE     0x02
#define GROUP_CREATE    0x04

// Conditional
#define GROUP_ARG       0x01

#define VERB_CREATE     0x0001
#define VERB_COUNTER    0x0002
#define VERB_TRACE      0x0004
#define VERB_START      0x0008
#define VERB_STOP       0x0010
#define VERB_UPDATE     0x0020
#define VERB_QUERY      0x0040
#define VERB_DELETE     0x0080
#define VERB_PROV       0x0100

VARG_DECLARE_COMMANDS
    VARG_DEBUG ( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )    
    VARG_HELP  ( VARG_FLAG_OPTIONAL )
    VARG_BOOL  ( IDS_PARAM_CREATE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB|VARG_FLAG_REQ_ADV, FALSE )
    VARG_BOOL  ( IDS_PARAM_COUNTER,     VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_TRACE,       VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_START,       VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_STOP,        VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_DELETE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_QUERY,       VARG_FLAG_DEFAULTABLE|VARG_FLAG_VERB|VARG_FLAG_OPT_ADV,  FALSE )
    VARG_BOOL  ( IDS_PARAM_QUERYPROV,   VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_UPDATE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_STR   ( IDS_PARAM_NAME,        VARG_FLAG_NOFLAG|VARG_FLAG_CHOMP, NULL )
    VARG_STR   ( IDS_PARAM_COMPUTER,    VARG_FLAG_OPTIONAL, NULL )
    VARG_INI   ( IDS_PARAM_SETTINGS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_DATE  ( IDS_PARAM_BEGIN,       VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_DATE  ( IDS_PARAM_END,         VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_MSZ   ( IDS_PARAM_MANUAL,      VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP|VARG_FLAG_LITERAL, NULL )
    VARG_BOOL  ( IDS_PARAM_REPEAT,      VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_STR   ( IDS_PARAM_OUTPUT,      VARG_FLAG_OPTIONAL|VARG_FLAG_RCDEFAULT|VARG_FLAG_CHOMP, IDS_DEFAULT_OUTPUT )
    VARG_STR   ( IDS_PARAM_FORMAT,      VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("bin") )
    VARG_BOOL  ( IDS_PARAM_APPEND,      VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_STR   ( IDS_PARAM_VERSION,     VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_NEGATE|VARG_FLAG_RCDEFAULT|VARG_FLAG_LITERAL, IDS_DEFAULT_NNNNN )
    VARG_STR   ( IDS_PARAM_RUNCMD,      VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_NEGATE|VARG_FLAG_CHOMP, NULL )
    VARG_INT   ( IDS_PARAM_MAX,         VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT|VARG_FLAG_NEGATE, 0 )
    VARG_TIME  ( IDS_PARAM_NEWFILE,     VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_ARG_TIME|VARG_FLAG_NEGATE )
    VARG_MSZ   ( IDS_PARAM_COUNTERS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_STR   ( IDS_PARAM_COUNTERFILE, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP, NULL )
    VARG_TIME  ( IDS_PARAM_SAMPLERATE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_STR   ( IDS_PARAM_LOGGERNAME,  VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL  ( IDS_PARAM_REALTIME,    VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_MSZ   ( IDS_PARAM_PROVIDER,    VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP, NULL )
    VARG_STR   ( IDS_PARAM_PROVIDERFILE,VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP, NULL )
    VARG_BOOL  ( IDS_PARAM_USERMODE,    VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_INT   ( IDS_PARAM_BUFFERSIZE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT, 64 )
    VARG_TIME  ( IDS_PARAM_FLUSHTIMER,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_MSZ   ( IDS_PARAM_BUFFERS,     VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP, NULL )
    VARG_BOOL  ( IDS_PARAM_FLUSHBUFFERS,VARG_FLAG_OPTIONAL, FALSE )
    VARG_MSZ   ( IDS_PARAM_USER,        VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP|VARG_FLAG_NEGATE|VARG_FLAG_DEFAULTABLE, _T("") )
    VARG_TIME  ( IDS_PARAM_RUNFOR,      VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_BOOL  ( IDS_PARAM_YES,         VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL  ( IDS_PARAM_ETS,         VARG_FLAG_OPTIONAL, FALSE )
    VARG_INT   ( IDS_PARAM_AGE,         VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
    VARG_MSZ   ( IDS_PARAM_MODE,        VARG_FLAG_OPTIONAL, NULL )
    VARG_STR   ( IDS_PARAM_CLOCKTYPE,   VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("system") )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eCreate,
    eCounter,
    eTrace,
    eStart,
    eStop,
    eDelete,
    eQuery,
    eQueryProv,
    eUpdate,
    eName,
    eComputer,
    eConfig,
    eBegin,
    eEnd,
    eManual,
    eRepeat,
    eOutput,
    eFormat,
    eAppend,
    eVersion,
    eRunCmd,
    eMax,
    eNewFile,
    eCounters,
    eCounterFile,
    eSampleInterval,
    eLoggerName,
    eRealTime,
    eProviders,
    eProviderFile,
    eUserMode,
    eBufferSize,
    eFlushTimer,
    eBuffers,
    eFlushBuffers,
    eUser,
    eRunFor,
    eYes,
    eEts,
    eAgeLimit,
    eMode,
    eClockType,
VARG_DECLARE_FORMAT
    VARG_VERB  ( eCreate,        VERB_CREATE )
    VARG_ADVERB( eCounter,       VERB_CREATE, VERB_COUNTER )
    VARG_ADVERB( eTrace,         VERB_CREATE, VERB_TRACE )
    VARG_VERB  ( eStart,         VERB_START )
    VARG_VERB  ( eStop,          VERB_STOP )
    VARG_VERB  ( eDelete,        VERB_DELETE )
    VARG_VERB  ( eQuery,         VERB_QUERY )
    VARG_ADVERB( eQueryProv,     VERB_QUERY, VERB_PROV )
    VARG_VERB  ( eUpdate,        VERB_UPDATE )
    VARG_VERB  ( eName,          VERB_CREATE|VERB_UPDATE|VERB_START|VERB_STOP|VERB_QUERY|VERB_DELETE )
    VARG_VERB  ( eBegin,         VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eEnd,           VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eManual,        VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eRepeat,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eOutput,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eFormat,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eAppend,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eVersion,       VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eRunCmd,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eMax,           VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eNewFile,       VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eCounters,      VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eCounterFile,   VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eSampleInterval,VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eLoggerName,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eRealTime,      VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eProviders,     VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eProviderFile,  VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eUserMode,      VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eBufferSize,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eFlushTimer,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eBuffers,       VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eFlushBuffers,  VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eUser,          VERB_UPDATE|VERB_CREATE|VERB_TRACE|VERB_COUNTER|VERB_QUERY )
    VARG_VERB  ( eComputer,      VERB_UPDATE|VERB_CREATE|VERB_TRACE|VERB_COUNTER|VERB_QUERY|VERB_START|VERB_STOP|VERB_DELETE )
    VARG_VERB  ( eRunFor,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eEts,           VERB_UPDATE|VERB_TRACE|VERB_START|VERB_STOP|VERB_QUERY )
    VARG_VERB  ( eMode,          VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eClockType,     VERB_CREATE|VERB_TRACE )
    VARG_GROUP ( eCounter,       VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eTrace,         VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eStart,         VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eStop,          VARG_EXCL(GROUP_END) )
    VARG_GROUP ( eQuery,         VARG_COND(GROUP_ARG) )
    VARG_GROUP ( eName,          VARG_COND(GROUP_ARG) )
    VARG_GROUP ( eBegin,         VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eEnd,           VARG_EXCL(GROUP_END) )
    VARG_GROUP ( eManual,        VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eCounters,      VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eCounterFile,   VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eSampleInterval,VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eLoggerName,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eRealTime,      VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eProviders,     VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eProviderFile,  VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eUserMode,      VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eBufferSize,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eFlushTimer,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eBuffers,       VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eFlushBuffers,  VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eEts,           VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eMode,          VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eClockType,     VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_EXHELP( eEts,           IDS_EXAMPLE_ETS )
    VARG_EXHELP( eCreate,        IDS_EXAMPLE_CREATE )
    VARG_EXHELP( eStart,         IDS_EXAMPLE_START )
    VARG_EXHELP( eUpdate,        IDS_EXAMPLE_UPDATE )
VARG_DECLARE_END

#define PROVIDER_NAME       0x0001
#define PROVIDER_GUID       0x0002
#define PROVIDER_FLAG       0x0004
#define PROVIDER_LEVEL      0x0008
#define PROVIDER_FLAGSTR    0x0010
#define PROVIDER_LEVELSTR   0x0020
#define PROVIDER_ALLSET     0x003F

typedef struct _PROVIDER_REC {
    _PROVIDER_REC* flink;
    _PROVIDER_REC* blink;
    DWORD  dwMask;
    LPTSTR strProviderName;
    LPTSTR strProviderGuid;
    LPTSTR strFlags;
    DWORD  dwFlags;
    LPTSTR strLevel;
    DWORD  dwLevel;
} PROVIDER_REC, *PPROVIDER_REC;

ULONG hextoi( LPWSTR s );
DWORD SetCredentials();
DWORD GetCountersFromFile( LPTSTR strFile, PPDH_PLA_ITEM pItem );
DWORD GetFileFormat( LPTSTR str, LPDWORD pdwFormat );
DWORD SetPlaInfo( PPDH_PLA_INFO pInfo );
HRESULT WbemConnect( IWbemServices** pWbemServices );
HRESULT GetProviders( PPDH_PLA_ITEM pItem );
HRESULT GetTraceNameToGuidMap( PPROVIDER_REC* pProviders, BOOL bQuery );
HRESULT EventTraceSessionControl();
HRESULT WbemError( HRESULT hr );
PDH_STATUS QueryCollection( LPTSTR strCollection, BOOL bHeader );
PDH_STATUS QuerySingleCollection( LPTSTR strCollection );
HRESULT QueryProviders( );

PDH_STATUS ScheduleLog();
void ShowValidationError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo );
void LogmanError( DWORD dwStatus );
void PdhError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo );
DWORD AdjustPrivilegeForKernel();
void DeleteProviderList( PPROVIDER_REC pProviderHead );

#define CHECK_STATUS( hr ) if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define SEVERITY( s )    ((ULONG)s >> 30)

#define VALUETYPE_INDEX              1
#define VALUETYPE_FLAG               2

#define PDH_MODULE          _T("PDH.DLL")
LPCWSTR PRIVATE_GUID = L"{dc945bc4-34e5-4bc4-ab8d-cc4e9de1c2bb}";

TCHAR NT_KERNEL_GUID[48];

TCHAR g_strUser[MAXSTR];
TCHAR g_strPassword[MAXSTR];
TCHAR g_strIPC[MAXSTR];

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    HRESULT hr = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_PLA_INFO_W info;

    StringFromGUID2( SystemTraceControlGuid, NT_KERNEL_GUID, 48 );

    ZeroMemory( &info, sizeof( PDH_PLA_INFO ) );

    ParseCmd( argc, argv );
    
    if( ! IsEmpty( Commands[eName].strValue) ){
        if( !_tcsicmp( Commands[eName].strValue, KERNEL_LOGGER_NAME ) ){
            //
            // Logger Name is case sensitive, delete the user input and 
            // replace it with the correct case name
            //

            varg_cmdStringAssign( eName, KERNEL_LOGGER_NAME );

            if(NULL == Commands[eName].strValue){ 
                PrintError( E_OUTOFMEMORY ); 
                FreeCmd(); 
                exit(ERROR_OUTOFMEMORY); 
            }

            if( Commands[eEts].bDefined && ! Commands[eComputer].bDefined ){
                dwStatus = AdjustPrivilegeForKernel();
                CHECK_STATUS( dwStatus );
            }
        }
    }

    if( Commands[eUser].bDefined && !(Commands[eUser].bNegated) ){
        dwStatus = SetCredentials();
    }else{
        g_strIPC[0] = _T('\0');
    }

    if( dwStatus != ERROR_SUCCESS ){
        dwStatus = LOGMAN_ERROR_LOGON;
        goto cleanup;
    }

    if( Commands[eEts].bValue ){

        DWORD dwFormat;
        dwStatus = GetFileFormat( Commands[eFormat].strValue, &dwFormat );
        CHECK_STATUS( dwStatus );

        switch( dwFormat ){
            case PLA_BIN_FILE: 
            case PLA_BIN_CIRC_FILE:
            case PLA_CIRC_TRACE_FILE:
            case PLA_SEQ_TRACE_FILE:
                break;
            default:
                dwStatus = LOGMAN_ERROR_FILEFORMAT;

        }

        CHECK_STATUS( dwStatus );
        hr = EventTraceSessionControl();
        goto cleanup;
    }

    PLA_VERSION plaVersion;
    pdhStatus = PdhiPlaGetVersion( Commands[eComputer].strValue, &plaVersion );
    if( ERROR_SUCCESS == pdhStatus ){
        if( plaVersion.dwBuild < 2195 ){
            pdhStatus = PDH_OS_EARLIER_VERSION;
        }
    }
    CHECK_STATUS(pdhStatus);

    if( Commands[eStart].bValue ){

        pdhStatus = PdhPlaStart( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eStop].bValue ){

        pdhStatus = PdhPlaStop( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eDelete].bValue ){

        pdhStatus = PdhPlaDelete( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eCreate].bDefined ){

        DWORD dwType = 0;
        PDH_STATUS pdhWarning;

        if( Commands[eCounter].bDefined ){
            dwType = PLA_COUNTER_LOG;
        }else if( Commands[eTrace].bDefined ){
            dwType = PLA_TRACE_LOG;
        }
       
        info.dwMask |= PLA_INFO_FLAG_TYPE;
        info.dwType = dwType;

        dwStatus = SetPlaInfo( &info );
        CHECK_STATUS( dwStatus );

        if( Commands[eYes].bValue ){
            PdhPlaDeleteW( Commands[eName].strValue, Commands[eComputer].strValue );
        }

        pdhStatus = PdhPlaCreate( Commands[eName].strValue, Commands[eComputer].strValue, &info );
        if( SEVERITY(pdhStatus) == STATUS_SEVERITY_ERROR ){
            goto cleanup;
        }else{
            pdhWarning = pdhStatus;
        }
 
        if( Commands[eRunFor].bDefined ||
            Commands[eManual].bDefined ){
        
            pdhStatus = ScheduleLog();
            if( FAILED( pdhStatus ) ){
                PdhPlaDeleteW( Commands[eName].strValue, Commands[eComputer].strValue );
                goto cleanup;
            }
        }

        pdhStatus = pdhWarning;

    }else if( Commands[eQuery].bDefined ){

        if( Commands[eQueryProv].bDefined ){
            hr = QueryProviders();
            goto cleanup;

        }else if( Commands[eName].strValue != NULL ){

            pdhStatus = QuerySingleCollection( Commands[eName].strValue );

        }else{

            DWORD dwSize = 0;
            LPTSTR mszCollections = NULL;

            pdhStatus = PdhPlaEnumCollections( Commands[eComputer].strValue, &dwSize, mszCollections );
            if( ERROR_SUCCESS == pdhStatus || PDH_INSUFFICIENT_BUFFER == pdhStatus ){
                mszCollections = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                if( mszCollections ){
                    LPTSTR strCollection;
                    pdhStatus = PdhPlaEnumCollections( Commands[eComputer].strValue, &dwSize, mszCollections );
                    if( ERROR_SUCCESS == pdhStatus ){
                        strCollection = mszCollections;
                        while( strCollection != NULL && *strCollection != _T('\0') ){
                            QueryCollection( strCollection, (strCollection == mszCollections) );
                            strCollection += ( _tcslen( strCollection ) + 1 );
                        }
                        varg_printf( g_normal, _T("\n") );
                    }
                    VARG_FREE( mszCollections );
                }else{ 
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

    }else if( Commands[eUpdate].bDefined ){

        dwStatus = SetPlaInfo( &info );
        CHECK_STATUS( dwStatus );

        if( info.dwMask != 0 ){

            // Try update without credentials
            pdhStatus = PdhPlaSetInfoW( Commands[eName].strValue, Commands[eComputer].strValue, &info );

            if( PDH_ACCESS_DENIED == pdhStatus ){
                // Try again with credintials
                dwStatus = SetCredentials();
                CHECK_STATUS( dwStatus );

                if( ERROR_SUCCESS == dwStatus ){
                    info.dwMask |= PLA_INFO_FLAG_USER;
                    info.strUser = g_strUser;
                    info.strPassword = g_strPassword;
    
                    pdhStatus = PdhPlaSetInfoW( Commands[eName].strValue, Commands[eComputer].strValue, &info );
                }
            }
            CHECK_STATUS( pdhStatus );
        }

        if( Commands[eRunFor].bDefined ||
            Commands[eManual].bDefined ){
        
            pdhStatus = ScheduleLog();
            CHECK_STATUS( pdhStatus );
        }

    }
            
cleanup:

    ZeroMemory( g_strPassword, sizeof(TCHAR)*MAXSTR );
    
    if( Commands[eUser].bDefined ){
        //
        // AddStringToMsz will zero out the old memory to remove the password
        //
        varg_cmdStringAddMsz( eUser, _T("-") );
    }

    if( ERROR_SUCCESS == dwStatus  && 
        ERROR_SUCCESS == hr  &&
        ERROR_SUCCESS == pdhStatus ){

        PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );

    }else{

        if( ERROR_SUCCESS != dwStatus ){
            LogmanError( dwStatus );
        }
        if( ERROR_SUCCESS != hr ){
            WbemError( hr );
            dwStatus = hr;
        }
        if( ERROR_SUCCESS != pdhStatus ){
            PdhError( pdhStatus, &info );
            dwStatus = pdhStatus;
        }

        if( SEVERITY( dwStatus ) == STATUS_SEVERITY_WARNING && 
            ERROR_SUCCESS == hr ){

            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
            dwStatus = ERROR_SUCCESS;
        }
    }

    if( info.dwMask & PLA_INFO_FLAG_COUNTERS && Commands[eCounterFile].bDefined ){
        VARG_FREE( info.Perf.piCounterList.strCounters );
    }
    if( info.dwMask & PLA_INFO_FLAG_PROVIDERS ){
        VARG_FREE( info.Trace.piProviderList.strProviders );
        VARG_FREE( info.Trace.piProviderList.strFlags );
        VARG_FREE( info.Trace.piProviderList.strLevels );
    }

    if( _tcslen( g_strIPC ) ){
        dwStatus = NetUseDel( NULL, g_strIPC, USE_LOTS_OF_FORCE /*luke*/ );
    }
    
    FreeCmd();
    CoUninitialize();

    return dwStatus;
}

DWORD 
SetPlaInfo( PPDH_PLA_INFO pInfo )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HRESULT hr;

    if( Commands[eCounters].bDefined && Commands[eCounters].strValue != NULL ){
        pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;

        pInfo->Perf.piCounterList.dwType = PLA_COUNTER_LOG;
        pInfo->Perf.piCounterList.strCounters =  Commands[eCounters].strValue;

    }else if( Commands[eCounterFile].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;

        dwStatus = GetCountersFromFile( Commands[eCounterFile].strValue, &(pInfo->Perf.piCounterList) );
        CHECK_STATUS( dwStatus );
    }

    if( Commands[eProviders].bDefined || Commands[eProviderFile].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_PROVIDERS;
        dwStatus = GetProviders( &(pInfo->Trace.piProviderList) );
        CHECK_STATUS( dwStatus );

        pInfo->Trace.piProviderList.dwType = PLA_TRACE_LOG;
    }

    if( Commands[eFormat].bDefined ){
        DWORD dwFormat;
        dwStatus = GetFileFormat( Commands[eFormat].strValue, &dwFormat );
        CHECK_STATUS( dwStatus );

        pInfo->dwMask |= PLA_INFO_FLAG_FORMAT;
        pInfo->dwFileFormat = dwFormat;
    }
    
    if( Commands[eAppend].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_DATASTORE;
        if( Commands[eAppend].bNegated ){
            pInfo->dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;
        }else{
            pInfo->dwDatastoreAttributes |= PLA_DATASTORE_APPEND;
        }
    }
    
    if( Commands[eSampleInterval].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_INTERVAL;

        pInfo->Perf.ptSampleInterval.wDataType = PLA_TT_DTYPE_UNITS;
        pInfo->Perf.ptSampleInterval.dwUnitType = PLA_TT_UTYPE_SECONDS;
        pInfo->Perf.ptSampleInterval.wTimeType = PLA_TT_TTYPE_SAMPLE;
        pInfo->Perf.ptSampleInterval.dwAutoMode = PLA_AUTO_MODE_AFTER;

        pInfo->Perf.ptSampleInterval.dwValue = Commands[eSampleInterval].stValue.wSecond;
        pInfo->Perf.ptSampleInterval.dwValue += Commands[eSampleInterval].stValue.wMinute * 60;
        pInfo->Perf.ptSampleInterval.dwValue += Commands[eSampleInterval].stValue.wHour * 3600;
    }

    if( Commands[eBufferSize].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_BUFFERSIZE;
        pInfo->Trace.dwBufferSize = Commands[eBufferSize].nValue;
    }
    
    if( Commands[eBuffers].bDefined ){
        LPTSTR strMin;
        LPTSTR strMax;
        strMin = Commands[eBuffers].strValue;
        if( NULL != strMin ){
            pInfo->dwMask |= PLA_INFO_FLAG_MINBUFFERS;
            pInfo->Trace.dwMinimumBuffers = _ttoi( strMin );
    
            strMax = strMin + (_tcslen( strMin )+1);
            if( *strMax != _T('\0') ){
                pInfo->dwMask |= PLA_INFO_FLAG_MAXBUFFERS;
                pInfo->Trace.dwMaximumBuffers = _ttoi( strMax );
            }
        }
    }
    
    if( Commands[eFlushTimer].bDefined ){
        DWORD dwSeconds;
        dwSeconds = Commands[eFlushTimer].stValue.wSecond;
        dwSeconds += Commands[eFlushTimer].stValue.wMinute * 60;
        dwSeconds += Commands[eFlushTimer].stValue.wHour * 3600;

        pInfo->dwMask |= PLA_INFO_FLAG_FLUSHTIMER;
        pInfo->Trace.dwFlushTimer = dwSeconds;
    }
    
    if( Commands[eMax].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MAXLOGSIZE;
        if( Commands[eMax].bNegated ){
            pInfo->dwMaxLogSize = PLA_DISK_MAX_SIZE;
        }else{
            pInfo->dwMaxLogSize = Commands[eMax].nValue;
        }
    }
    
    if( Commands[eRunCmd].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_RUNCOMMAND;
        if( Commands[eRunCmd].bNegated ){
            pInfo->strCommandFileName = _T("");            
        }else{
            pInfo->strCommandFileName = Commands[eRunCmd].strValue;
        }
    }
    
    if( Commands[eOutput].bDefined && NULL != Commands[eOutput].strValue ){

        if( ((pInfo->dwMask & PLA_INFO_FLAG_FORMAT) && 
            pInfo->dwFileFormat == PLA_SQL_LOG ) ||
            !StrCmpNI( Commands[eOutput].strValue, _T("SQL:"), 4 ) ){

            pInfo->dwMask |= PLA_INFO_FLAG_SQLNAME;
            pInfo->strSqlName = Commands[eOutput].strValue;

        }else{
            if( IsEmpty( Commands[eOutput].strValue ) ){
                pInfo->dwMask |= (PLA_INFO_FLAG_DEFAULTDIR|PLA_INFO_FLAG_FILENAME);
                pInfo->strDefaultDir = _T("");
                pInfo->strBaseFileName = _T("");
            }else{
                
                LPTSTR str = NULL;
                TCHAR full[MAXSTR];
                TCHAR buffer[MAX_PATH];
                TCHAR drive[_MAX_DRIVE];
                TCHAR dir[_MAX_DIR];
                TCHAR fname[_MAX_FNAME];
                TCHAR ext[_MAX_EXT];
                DWORD dwFormat;
                
                if( Commands[eComputer].bDefined ){
                    hr = StringCchCopy( full, MAXSTR, Commands[eOutput].strValue );
                }else{
                    _tfullpath( full, Commands[eOutput].strValue, MAXSTR );
                }

                _tsplitpath( full, drive, dir, fname, ext );
                
                varg_cmdStringFree( eOutput );
                if( _tcslen( drive ) ){
                    hr = StringCchPrintf( buffer, MAX_PATH, _T("%s%s"), drive, dir );
                }else{
                    hr = StringCchCopy( buffer, MAX_PATH, dir );
                }
                if( _tcslen( buffer ) ){
                    pInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;         
                    varg_cmdStringAddMsz( eOutput, buffer );
                }
                dwStatus = GetFileFormat( ext, &dwFormat );
                if( ERROR_SUCCESS == dwStatus ){
                    hr = StringCchCopy( buffer, MAX_PATH, fname );
                }else{
                    StringCchPrintf( buffer, MAX_PATH, _T("%s%s"), fname, ext );
                    dwStatus = ERROR_SUCCESS;
                }
                if( _tcslen( buffer ) ){
                    pInfo->dwMask |= PLA_INFO_FLAG_FILENAME;         
                    varg_cmdStringAddMsz(eOutput, buffer );
                }
                str = Commands[eOutput].strValue;
                if( str != NULL  ){
                    if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                        pInfo->strDefaultDir = str;
                        str += ( _tcslen( str ) + 1 );
                    }
                    if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                        pInfo->strBaseFileName = str;
                    }
                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
            }
        }
    }
    
    if( Commands[eVersion].bDefined ){
        
        DWORD dwFormat = 0;
        pInfo->dwMask |= PLA_INFO_FLAG_AUTOFORMAT;

        if( Commands[eVersion].bNegated ){
            dwFormat = PLA_SLF_NAME_NONE;
        }else if( !_tcsicmp( Commands[eVersion].strValue, _T("nnnnnn") ) ){
            dwFormat = PLA_SLF_NAME_NNNNNN;
        }else if( !_tcsicmp( Commands[eVersion].strValue, _T("mmddhhmm") ) ){
            dwFormat = PLA_SLF_NAME_MMDDHHMM;
        }else{
            dwFormat = PLA_SLF_NAME_NNNNNN;
        }

        pInfo->dwAutoNameFormat = dwFormat;
    }
    
    if( Commands[eRealTime].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MODE;
        if( Commands[eRealTime].bNegated ){
            pInfo->Trace.dwMode &= ~EVENT_TRACE_REAL_TIME_MODE;
        }else{
            pInfo->Trace.dwMode |= EVENT_TRACE_REAL_TIME_MODE;
        }
    }
    
    if( Commands[eUserMode].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MODE;
        if( Commands[eUserMode].bNegated ){
            pInfo->Trace.dwMode &= ~EVENT_TRACE_PRIVATE_LOGGER_MODE;
        }else{
            pInfo->Trace.dwMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;   
        }
    }
    
    if( Commands[eLoggerName].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_LOGGERNAME;
        pInfo->Trace.strLoggerName = Commands[eLoggerName].strValue;
    }
    
    if( Commands[eRepeat].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_REPEAT;
        if( Commands[eRepeat].bNegated ){
            pInfo->ptRepeat.dwAutoMode = PLA_AUTO_MODE_NONE;
        }else{
            pInfo->ptRepeat.wDataType = PLA_TT_DTYPE_UNITS;
            pInfo->ptRepeat.wTimeType = PLA_TT_TTYPE_REPEAT_SCHEDULE;
            pInfo->ptRepeat.dwUnitType = PLA_TT_UTYPE_DAYSOFWEEK;
            pInfo->ptRepeat.dwAutoMode = PLA_AUTO_MODE_CALENDAR;

            pInfo->ptRepeat.dwValue = 0x0000007F;
        }
    }
    
    if( Commands[eNewFile].bDefined ){
        
        pInfo->dwMask |= PLA_INFO_FLAG_CRTNEWFILE;
        
        pInfo->ptCreateNewFile.wTimeType = PLA_TT_TTYPE_CREATENEWFILE;
        pInfo->ptCreateNewFile.wDataType = PLA_TT_DTYPE_UNITS;

        if( Commands[eNewFile].bNegated ){
            pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_NONE;
        }else{
            DWORD dwSeconds = Commands[eNewFile].stValue.wSecond;
            dwSeconds += Commands[eNewFile].stValue.wMinute * 60;
            dwSeconds += Commands[eNewFile].stValue.wHour * 3600;

            if( dwSeconds == 0 ){
                pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_SIZE;
            }else{
                pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_AFTER;
                pInfo->ptCreateNewFile.dwUnitType = PLA_TT_UTYPE_SECONDS;
                pInfo->ptCreateNewFile.dwValue = dwSeconds;
            }
        }
    }

    if( Commands[eUser].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_USER;
        if( Commands[eUser].bNegated ){
            pInfo->strUser = _T("");
            pInfo->strPassword = _T("");
        }else{
            pInfo->strUser = g_strUser;
            pInfo->strPassword = g_strPassword;
        }
    }
               
    if(Commands[eBegin].bDefined){
        FILETIME ft;
        if( SystemTimeToFileTime( &Commands[eBegin].stValue, &ft ) ){
            pInfo->dwMask |= PLA_INFO_FLAG_BEGIN;

            pInfo->ptLogBeginTime.wTimeType = PLA_TT_TTYPE_START;
            pInfo->ptLogBeginTime.wDataType = PLA_TT_DTYPE_DATETIME;
            pInfo->ptLogBeginTime.dwAutoMode = PLA_AUTO_MODE_AT;
            pInfo->ptLogBeginTime.llDateTime = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
        }
    }

    if(Commands[eEnd].bDefined){
        FILETIME ft;
        if( SystemTimeToFileTime( &Commands[eEnd].stValue, &ft ) ){
            pInfo->dwMask |= PLA_INFO_FLAG_END;
        
            pInfo->ptLogEndTime.wTimeType = PLA_TT_TTYPE_STOP;
            pInfo->ptLogEndTime.wDataType = PLA_TT_DTYPE_DATETIME;
            pInfo->ptLogEndTime.dwAutoMode = PLA_AUTO_MODE_AT;
            pInfo->ptLogEndTime.llDateTime = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
        }
    }

cleanup:
    return dwStatus;
}

DWORD
GetFileFormat( LPTSTR str, LPDWORD pdwFormat )
{
    *pdwFormat = PLA_BIN_FILE;
    LPTSTR strCmp = str;

    if( strCmp != NULL ){
        if( *strCmp == _T('.') ){
            strCmp++;
        }
        if( !_tcsicmp( strCmp, _T("TSV")) ){
            *pdwFormat = PLA_TSV_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("CSV")) ){
            *pdwFormat = PLA_CSV_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BLG")) ){
            *pdwFormat = PLA_BIN_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BIN")) ){
            *pdwFormat = PLA_BIN_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BINCIRC")) ){
            *pdwFormat = PLA_BIN_CIRC_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("SQL")) ){
            *pdwFormat = PLA_SQL_LOG;
            return ERROR_SUCCESS;
        }
    }

    return LOGMAN_ERROR_FILEFORMAT;
}

PDH_STATUS 
QueryCollection( LPTSTR strCollection, BOOL bHeader )
{
    PDH_STATUS pdhStatus;
    PDH_PLA_INFO  info;
    DWORD dwInfoSize = sizeof( PDH_PLA_INFO );

    TCHAR strType[256] = _T("");
    TCHAR strStatus[256];
    TCHAR buffer[MAXSTR];

    if( bHeader ){
        PrintMessage( g_normal, IDS_MESSAGE_QUERY );
        for(int i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
        varg_printf( g_normal, _T("\n") );
    }

    info.dwMask = PLA_INFO_FLAG_TYPE|PLA_INFO_FLAG_STATUS;
    pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, &info );
    
    if( ERROR_SUCCESS == pdhStatus ){
        switch( info.dwType ){
        case PLA_COUNTER_LOG:
            LoadString( NULL, IDS_MESSAGE_PERF, strType, 256 );
            break;
        case PLA_TRACE_LOG:
            LoadString( NULL, IDS_MESSAGE_EVENTTRACE, strType, 256 );
            break;
        case PLA_ALERT:
            LoadString( NULL, IDS_MESSAGE_ALERT, strType, 256 );
            break;
        default:
            LoadString( NULL, IDS_MESSAGE_UNKNOWN, strType, 256 );
        }
        switch( info.dwStatus ){
        case PLA_QUERY_STOPPED: 
            LoadString( NULL, IDS_MESSAGE_STOPPED, strStatus, 256 );
            break;
        case PLA_QUERY_RUNNING:
            LoadString( NULL, IDS_MESSAGE_RUNNING, strStatus, 256 );
            break;
        case PLA_QUERY_START_PENDING:
        default:
            LoadString( NULL, IDS_MESSAGE_PENDING, strStatus, 256 );
            break;
        }
        PrintMessage( g_normal, IDS_MESSAGE_QUERYF, PaddedString( strCollection, buffer, MAXSTR, 39 ), strType, strStatus );
    }
    
    return pdhStatus;
}

PDH_STATUS 
QuerySingleCollection( LPTSTR strCollection )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwInfoSize = 0;
    TCHAR buffer[MAXSTR];

    pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, pInfo );
    if( ERROR_SUCCESS == pdhStatus ){
        pInfo = (PPDH_PLA_INFO)VARG_ALLOC(dwInfoSize);
        if( NULL != pInfo ){
            pInfo->dwMask = PLA_INFO_FLAG_ALL;
            pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, pInfo );

            if( pdhStatus == ERROR_SUCCESS ){
                varg_printf( g_normal, _T("\n") );
                PrintMessage( g_normal, IDS_MESSAGE_NAME, strCollection );
                switch( pInfo->dwType ){
                case PLA_COUNTER_LOG: 
                    LoadString( NULL, IDS_MESSAGE_PERF, buffer, MAXSTR );
                    break;
                case PLA_TRACE_LOG:
                    LoadString( NULL, IDS_MESSAGE_EVENTTRACE, buffer, MAXSTR );
                    break;
                case PLA_ALERT:
                    LoadString( NULL, IDS_MESSAGE_ALERT, buffer, MAXSTR );
                    break;
                default:
                    buffer[0] = _T('\0');
                }
                PrintMessage( g_normal, IDS_MESSAGE_TYPE, buffer );

                switch( pInfo->dwStatus ){
                case PLA_QUERY_STOPPED: 
                    LoadString( NULL, IDS_MESSAGE_STOPPED, buffer, MAXSTR );
                    break;
                case PLA_QUERY_RUNNING:
                    LoadString( NULL, IDS_MESSAGE_RUNNING, buffer, MAXSTR );
                    break;
                case PLA_QUERY_START_PENDING:
                default:
                    LoadString( NULL, IDS_MESSAGE_PENDING, buffer, MAXSTR );
                    break;
                }
                PrintMessage( g_normal, IDS_MESSAGE_STATUS, buffer );
                
                DWORD dwStart;
                DWORD dwStop;
                PDH_TIME_INFO TimeInfo;
                pdhStatus = PdhPlaGetScheduleW( strCollection, Commands[eComputer].strValue, &dwStart, &dwStop, &TimeInfo );

                if( ERROR_SUCCESS == pdhStatus ){
                    LoadString( NULL, IDS_MESSAGE_MANUAL, buffer, MAXSTR );
                    PrintMessage( g_normal, IDS_MESSAGE_START );
                    switch( dwStart ){
                    
                    case PLA_AUTO_MODE_NONE:
                        varg_printf( g_normal, buffer );
                        break;
                    case PLA_AUTO_MODE_CALENDAR:
                    case PLA_AUTO_MODE_AT:
                        {
                            SYSTEMTIME st;
                            FILETIME ft;
                            ft.dwLowDateTime  = (DWORD) (TimeInfo.StartTime & 0xFFFFFFFF );
                            ft.dwHighDateTime = (DWORD) (TimeInfo.StartTime >> 32 );
                            FileTimeToSystemTime( &ft, &st );
                            PrintDate( &st );
                            if( dwStart == PLA_AUTO_MODE_CALENDAR ){
                                PrintMessage( g_normal, IDS_MESSAGE_REPEATING );
                            }
                        }
                    }
                    varg_printf( g_normal, _T("\n") );
                
                    PrintMessage( g_normal, IDS_MESSAGE_STOP );
                    switch( dwStop ){
                    case PLA_AUTO_MODE_NONE:
                        varg_printf( g_normal, buffer );
                        break;
                    case PLA_AUTO_MODE_AT:
                        {
                            SYSTEMTIME st;
                            FILETIME ft;
                            ft.dwLowDateTime  = (DWORD) (TimeInfo.EndTime & 0xFFFFFFFF );
                            ft.dwHighDateTime = (DWORD) (TimeInfo.EndTime >> 32 );

                            FileTimeToSystemTime( &ft, &st );
                            PrintDate( &st );
                        }
                        break;
                    case PLA_AUTO_MODE_AFTER:
                        {
                            SYSTEMTIME st;
                            LONGLONG llMS;
                            ZeroMemory( &st, sizeof(SYSTEMTIME) );
                            PlaTimeInfoToMilliSeconds( &pInfo->ptLogEndTime, &llMS );
                            llMS /= 1000;
                        
                            st.wHour = (USHORT)(llMS / 3600);
                            st.wMinute = (USHORT)((llMS%3600) / 60);
                            st.wSecond = (USHORT)((llMS % 60) % 3600);

                            PrintMessage( g_normal, IDS_MESSAGE_AFTER );
                            PrintDate( &st );
                        }
                    }
                    varg_printf( g_normal, _T("\n") );
                }
                if( pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
                    if( pInfo->ptCreateNewFile.dwAutoMode == PLA_AUTO_MODE_SIZE ){
                        PrintMessage( g_normal, IDS_MESSAGE_NEWFILE );
                        PrintMessage( g_normal, IDS_MESSAGE_BYSIZE );
                    }else if( pInfo->ptCreateNewFile.dwAutoMode == PLA_AUTO_MODE_AFTER ){
                        SYSTEMTIME st;
                        LONGLONG llMS;
                        ZeroMemory( &st, sizeof(SYSTEMTIME) );
                        PlaTimeInfoToMilliSeconds( &pInfo->ptCreateNewFile, &llMS );
                        llMS /= 1000;
                    
                        st.wHour = (USHORT)(llMS / 3600);
                        st.wMinute = (USHORT)((llMS%3600) / 60);
                        st.wSecond = (USHORT)((llMS % 60) % 3600);

                        PrintMessage( g_normal, IDS_MESSAGE_NEWFILE );
                        PrintMessage( g_normal, IDS_MESSAGE_AFTER );
                        PrintDate( &st );
                        varg_printf( g_normal, _T("\n") );
                    }
                }
                dwInfoSize = MAXSTR;
                pdhStatus = PdhPlaGetLogFileNameW( strCollection, Commands[eComputer].strValue, pInfo, 0, &dwInfoSize, buffer );
                if( pdhStatus != ERROR_SUCCESS ){
                    LoadString( NULL, IDS_MESSAGE_BADPARAM, buffer, MAXSTR );
                    pdhStatus = ERROR_SUCCESS;
                }
                PrintMessage( g_normal, IDS_MESSAGE_FILE, buffer );
                PrintMessage( g_normal, IDS_MESSAGE_RUNAS, pInfo->strUser ? pInfo->strUser : _T("")  );
                
                switch( pInfo->dwType ){
                case PLA_COUNTER_LOG: 
                    {
                        LPTSTR strCounter;
                        PrintMessage( g_normal, IDS_MESSAGE_COUNTERS );
                        strCounter = pInfo->Perf.piCounterList.strCounters;
                        if( NULL != strCounter ){
                            if( PRIMARYLANGID( GetUserDefaultUILanguage()) == LANG_ENGLISH ){
                                while( *strCounter != _T('\0') ){
                                    varg_printf( g_normal, _T("   %1!s!\n"), strCounter );
                                    strCounter += (_tcslen(strCounter)+1);
                                }
                            }else{
                                LPTSTR strLocale = NULL;
                                DWORD dwSize = MAX_PATH;
                                strLocale = (LPTSTR)VARG_ALLOC(dwSize*sizeof(TCHAR));
                                if( NULL != strLocale ){
                                    while( *strCounter != _T('\0') ){
                                        pdhStatus = PdhTranslateLocaleCounter( strCounter, strLocale, &dwSize );
                                        if( PDH_MORE_DATA == pdhStatus ){
                                            LPTSTR strMem = (LPTSTR)VARG_REALLOC( strLocale, (dwSize*sizeof(TCHAR)) );
                                            if( NULL != strMem ){
                                                strLocale = strMem;
                                            }else{
                                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                                VARG_FREE(strLocale);
                                                break;
                                            }
                                        }else if( ERROR_SUCCESS == pdhStatus ){
                                            varg_printf( g_normal, _T("   %1!s!\n"), strLocale );
                                            strCounter += (_tcslen(strCounter)+1);
                                        }else{
                                            pdhStatus = ERROR_SUCCESS;
                                            varg_printf( g_normal, _T("   %1!s!\n"), strCounter );
                                            strCounter += (_tcslen(strCounter)+1);
                                        }
                                    }
                                }else{
                                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                            }
                        }
                    }
                    break;
                case PLA_TRACE_LOG:
                    {
                        LPTSTR strProvider;
                        PrintMessage( g_normal, IDS_MESSAGE_LOGGERNAME, pInfo->Trace.strLoggerName );
                        PrintMessage( g_normal, IDS_MESSAGE_BUFFERSIZE, pInfo->Trace.dwBufferSize );

                        PrintMessage( g_normal, IDS_MESSAGE_PROVIDERS );
                        
                        strProvider = pInfo->Trace.piProviderList.strProviders;
                        if( NULL != strProvider ){
                            while( *strProvider != _T('\0') ){
                                PrintMessage( g_normal, IDS_MESSAGE_PRVGUID, strProvider );
                                strProvider += (_tcslen(strProvider)+1);
                            }
                        }else{
                            StringFromGUID2( SystemTraceControlGuid, buffer, 128 );
                            PrintMessage( g_normal, IDS_MESSAGE_PRVGUID, buffer );
                        }
                    }
                    break;
                case PLA_ALERT:
                    break;
                }
                

            }

            VARG_FREE( pInfo );
        }
    }
    
    varg_printf( g_normal, _T("\n") );

    return pdhStatus;
}

DWORD
SetCredentials( )
{
    DWORD dwStatus = ERROR_SUCCESS;

    LPTSTR strUser = NULL;
    LPTSTR strPassword = NULL;
    TCHAR  buffer[MAXSTR];
    TCHAR  strConnection[MAXSTR];
    
    LoadString( NULL, IDS_MESSAGE_THISCON, strConnection, MAXSTR );

    ZeroMemory( g_strUser, MAXSTR*sizeof(TCHAR) );
    ZeroMemory( g_strPassword, MAXSTR*sizeof(TCHAR) );

    if( Commands[eUser].strValue == NULL || !_tcslen( Commands[eUser].strValue ) ){
        LoadString( NULL, IDS_MESSAGE_EUSER, buffer, MAXSTR );
        varg_printf( g_normal,  
                buffer, 
                Commands[eName].bDefined ? 
                    Commands[eName].strValue : 
                Commands[eComputer].bDefined ? 
                    Commands[eComputer].strValue : 
                strConnection 
            );
        
         GetUserInput( g_strUser, MAXSTR, TRUE );

        strUser = g_strUser;
        strPassword = _T("*");
    }else{
        strUser = Commands[eUser].strValue;
        strPassword = strUser + (_tcslen( strUser ) + 1);
    }

    if( NULL == strPassword ){
        strPassword = _T("");
    }else if( !_tcscmp( _T("*"), strPassword  ) ){
        LoadString( NULL, IDS_MESSAGE_EPASSWORD, buffer, MAXSTR );
        varg_printf( g_normal, buffer,
                Commands[eName].bDefined ? 
                    Commands[eName].strValue : 
                Commands[eComputer].bDefined ? 
                    Commands[eComputer].strValue : 
                strConnection
            );

        GetUserInput( buffer, MAXSTR, FALSE );

        strPassword = buffer;
    }

    StringCchCopy( g_strPassword, MAXSTR, strPassword );
    ZeroMemory( buffer, MAXSTR * sizeof(TCHAR) );

    if( strUser != NULL ){
        StringCchCopy( g_strUser, MAXSTR, strUser );
        strUser = g_strUser;
    }

    TCHAR strUserBuffer[MAXSTR];
    StringCchCopy( strUserBuffer, MAXSTR, strUser );
    
    LPTSTR strDomain = _tcstok( strUserBuffer, _T("\\") );
    strUser = _tcstok( NULL, _T("") );
    if( strUser == NULL ){
        strUser = strDomain;
        strDomain = NULL;
    }

    if( Commands[eComputer].bDefined ){
        if( _tcslen(Commands[eComputer].strValue) > 2 && Commands[eComputer].strValue[1] == _T('\\') ){
            StringCchPrintf( g_strIPC, MAXSTR, _T("%s\\ipc$"), Commands[eComputer].strValue );
        }else{
            StringCchPrintf( g_strIPC, MAXSTR, _T("\\\\%s\\ipc$"), Commands[eComputer].strValue );
        }
     
        LPTSTR pNetInfo;

        dwStatus = NetUseGetInfo( NULL, g_strIPC, 0, (LPBYTE*)&pNetInfo );
        if( dwStatus != ERROR_SUCCESS ){
        
            USE_INFO_2 info;
            DWORD dwError;

            ZeroMemory( &info, sizeof(USE_INFO_2) );
            info.ui2_local = NULL;
            info.ui2_remote = g_strIPC;
            info.ui2_password = g_strPassword;
            info.ui2_username = strUser;
            info.ui2_domainname = strDomain;
            info.ui2_asg_type = USE_IPC;

            dwStatus = NetUseAdd (
                    NULL,
                    2,
                    (unsigned char *)&info,
                    &dwError
                );
        }else{
            ZeroMemory( g_strIPC, sizeof(TCHAR) * MAXSTR );
        }
    }

    return dwStatus;
}

DWORD GetCountersFromFile( LPTSTR strFile, PPDH_PLA_ITEM pItem )
{
    TCHAR buffer[MAXSTR];
    LPTSTR strList = NULL;
    LPTSTR strItem = NULL;

    FILE* f = _tfopen( strFile, _T("r") );

    if( !f ){
        return GetLastError();
    }

    pItem->dwType = PLA_COUNTER_LOG;
    pItem->strCounters = NULL;
    
    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }

        Chomp(buffer);

        strItem = _tcstok( buffer, _T("\"\n") );
        if( strItem != NULL ){
            AddStringToMsz( &strList, strItem );
        }
    }

    fclose( f );

    pItem->strCounters = strList;

    return ERROR_SUCCESS;
}

BOOL IsStrGuid( LPTSTR str ){

    if( _tcslen( str ) < 38 ){
        return FALSE;
    }

    if( str[0] == _T('{') &&
        str[9] == _T('-') &&
        str[14] == _T('-') &&
        str[19] == _T('-') &&
        str[24] == _T('-') &&
        str[37] == _T('}')
        ){

        return TRUE;
    }

    return FALSE;
}

HRESULT GetProviders( PPDH_PLA_ITEM pItem )
{
    HRESULT hr = ERROR_SUCCESS;

    TCHAR buffer[MAXSTR];
    LPTSTR strLine = NULL;
    LPTSTR strItem = NULL;
    LPTSTR strLevel;
    LPTSTR strFlags;
    
    PPROVIDER_REC pProviderHead = NULL;
    PPROVIDER_REC pProvider;
    
    FILE* f = NULL;

    if( Commands[eProviderFile].bDefined ){

        f = _tfopen( Commands[eProviderFile].strValue, _T("r") );

        if( !f ){
            return GetLastError();
        }

        strLine = _fgetts( buffer, MAXSTR, f );

        Chomp(buffer);

    }else if( Commands[eProviders].bDefined ){
        strLine = Commands[eProviders].strValue;
    }
    
    while( NULL != strLine ){

        strItem = NULL;
        strFlags = NULL;
        strLevel = NULL;

        if( Commands[eProviderFile].bDefined ){
            switch( strLine[0] ){
            case _T(';'):
            case _T('#'):
            case _T('*'):
                strLine = _fgetts( buffer, MAXSTR, f );
                Chomp(buffer);
                continue;
            }
        }
        
        if( Commands[eProviderFile].bDefined ){

            LPTSTR strBegin = _tcsstr( strLine, _T("\"") );
            LPTSTR strEnd;

            if( NULL != strBegin ){
                strBegin++;
                strEnd = strBegin;
                strEnd = _tcsstr( strEnd, _T("\"") );
                strItem = strBegin;
                if( NULL != strEnd ){
                    *strEnd = _T('\0');
                    strEnd++;
                    strFlags = _tcstok( strEnd, _T("\n\t ") );
                    strLevel = _tcstok( NULL, _T("\n\t ") );
                }
            }else{
                strItem = _tcstok( buffer, _T("\n\t ") );
                strFlags = _tcstok( NULL, _T("\n\t ") );
                strLevel = _tcstok( NULL, _T("\n\t ") );
            }

        }else if( Commands[eProviders].bDefined ){
            strItem = strLine;
            if( *strItem != _T('\0') ){
                strFlags = strItem + (_tcslen(strItem)+1);
                if( *strFlags != _T('\0') ){
                    strLevel = strFlags + (_tcslen(strFlags)+1);
                    if( IsEmpty( strLevel ) ){
                        strLevel = NULL;
                    }
                }else{
                    strFlags = NULL;
                }
            }else{
                strItem = NULL;
            }
        }
        
        if( strItem != NULL ){
            pProvider = (PPROVIDER_REC)VARG_ALLOC( sizeof(PROVIDER_REC) );
            if( NULL != pProvider ){

                ZeroMemory( pProvider, sizeof(PROVIDER_REC) );
                if( pProviderHead == NULL ){
                    pProviderHead = pProvider;
                }else{
                    pProviderHead->blink = pProvider;
                    pProvider->flink = pProviderHead;
                    pProviderHead = pProvider;
                }
                
                if( IsStrGuid( strItem ) ){
                    ASSIGN_STRING( pProvider->strProviderGuid, strItem );
                    pProvider->dwMask |= PROVIDER_GUID;
                }else{
                    ASSIGN_STRING( pProvider->strProviderName, strItem );
                    pProvider->dwMask |= PROVIDER_NAME;
                }

                if( strFlags != NULL ){
                    ASSIGN_STRING( pProvider->strFlags, strFlags );
                    pProvider->dwMask |= PROVIDER_FLAGSTR;
                }else{
                    pProvider->dwFlags = 0; 
                    pProvider->dwMask |= PROVIDER_FLAG;
                }

                if( strLevel != NULL ){
                    ASSIGN_STRING( pProvider->strLevel, strLevel );
                    pProvider->dwMask |= PROVIDER_LEVELSTR;
                }else{
                    pProvider->dwLevel = 0;
                    pProvider->dwMask |= PROVIDER_LEVEL;
                }
            }
        }
        if( Commands[eProviderFile].bDefined ){

            strLine = _fgetts( buffer, MAXSTR, f );
            Chomp(buffer);

        }else if( Commands[eProviders].bDefined ){
            break;
        }

    }

    if( NULL != f ){
        fclose( f );
    }

    hr = GetTraceNameToGuidMap( &pProviderHead, FALSE );

    pItem->dwType = PLA_TRACE_LOG;
    pProvider = pProviderHead;
    while( pProvider ){ 
        if( NULL == pProvider->strProviderGuid ){
            PrintMessage( g_debug, IDS_MESSAGE_WARNING );
            PrintMessage( g_debug, LOGMAN_WARNING_BAD_CODE, pProvider->strProviderName );
        }else{
        
            hr = AddStringToMsz( &(pItem->strProviders), pProvider->strProviderGuid );
            CHECK_STATUS(hr);

            if( pProvider->dwMask & PROVIDER_LEVEL ){
                StringCchPrintf( buffer, MAXSTR, _T("0x%x"), pProvider->dwLevel );
                hr = AddStringToMsz( &(pItem->strLevels), buffer );
                CHECK_STATUS(hr);
            }else if( pProvider->dwMask & PROVIDER_LEVELSTR ){
                hr = AddStringToMsz( &(pItem->strLevels), pProvider->strLevel );
                CHECK_STATUS(hr);
            }else{
                hr = AddStringToMsz( &(pItem->strLevels), _T("0") );
                CHECK_STATUS(hr);
            }

            if( pProvider->dwMask & PROVIDER_FLAG ){
                StringCchPrintf( buffer, MAXSTR, _T("0x%x"), pProvider->dwFlags );
                hr = AddStringToMsz( &(pItem->strFlags), buffer );
                CHECK_STATUS(hr);
            }else if( pProvider->dwMask & PROVIDER_FLAGSTR ){
                hr = AddStringToMsz( &(pItem->strFlags), pProvider->strFlags );
                CHECK_STATUS(hr);
            }else{
                hr = AddStringToMsz( &(pItem->strFlags), _T("0") );
                CHECK_STATUS(hr);
            }
        }

        pProvider = pProvider->flink;
    }

cleanup:
    DeleteProviderList( pProviderHead );
    
    return hr;
}

void
DeleteProviderList( PPROVIDER_REC pProviderHead )
{
    PPROVIDER_REC pDelete;
    PPROVIDER_REC pProvider = pProviderHead;

    while( pProvider ){
        pDelete = pProvider;
        pProvider = pProvider->flink;
        VARG_FREE( pDelete->strProviderGuid );
        VARG_FREE( pDelete->strProviderName );
        VARG_FREE( pDelete->strFlags );
        VARG_FREE( pDelete->strLevel );
        VARG_FREE( pDelete );
    }
}

BOOL 
AllProvidersMapped( PPROVIDER_REC pProviders )
{
    if( NULL == pProviders ){
        return FALSE;
    }

    PPROVIDER_REC pProvider = pProviders;
    
    while( pProvider ){
        if( pProvider->dwMask < (PROVIDER_ALLSET) ){
            return FALSE;
        }
        pProvider = pProvider->flink;
    }
    
    return TRUE;
}

HRESULT 
DecodeFlags( IWbemClassObject *pClass, LPTSTR strKey, LPTSTR* pstrValue, LPDWORD pdwValue )
{
    HRESULT hr = ERROR_SUCCESS;
    IWbemQualifierSet   *pQualSet = NULL;
    TCHAR buffer[MAXSTR];
    SAFEARRAY* saValues = NULL;
    SAFEARRAY* saValueMap = NULL;
    LONG nFlavor;
    VARIANT var;
    BOOL bMakeString = FALSE;
    BOOL bQuery = FALSE;
    ULONG nDecoded = 0;
    DWORD dwValueType = VALUETYPE_FLAG;

    if( NULL == pstrValue && NULL == pdwValue ){
        bQuery = TRUE;
    }else if( NULL != pstrValue && NULL == *pstrValue  ){
        bMakeString = TRUE;
        StringCchCopy( buffer, MAXSTR, _T("(") );
    }else if( NULL != pstrValue ){
        if( _tcslen( *pstrValue) < MAXSTR ){
            StringCchCopy( buffer, MAXSTR, *pstrValue );
        }else{
            return E_OUTOFMEMORY;
        }
    }else{
        return E_OUTOFMEMORY;
    }

    hr = pClass->GetPropertyQualifierSet( strKey, &pQualSet );

    if( pQualSet != NULL ){
        hr = pQualSet->Get( L"ValueMap", 0, &var, &nFlavor );
        if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
            saValueMap = var.parray;
        }

        hr = pQualSet->Get( L"Values", 0, &var, &nFlavor );
        if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
            saValues = var.parray;
        }else{
            dwValueType = VALUETYPE_INDEX;
        }

        hr = pQualSet->Get( L"ValueType", 0, &var, &nFlavor );
        if( SUCCEEDED(hr) ){
            if( _wcsicmp( var.bstrVal, L"index" ) == 0 ){
                dwValueType = VALUETYPE_INDEX;
            }
            if( _wcsicmp( var.bstrVal, L"flag") == 0 ){
                dwValueType = VALUETYPE_FLAG;
            }
        }
        
        if( saValues != NULL ){

            BSTR HUGEP *pMapData;
            BSTR HUGEP *pValuesData;
            LONG uMapBound, lMapBound;
            LONG uValuesBound, lValuesBound;

            if( NULL != saValueMap ){
                SafeArrayGetUBound( saValueMap, 1, &uMapBound );
                SafeArrayGetLBound( saValueMap, 1, &lMapBound );
                SafeArrayAccessData( saValueMap, (void HUGEP **)&pMapData );
            }

            SafeArrayGetUBound( saValues, 1, &uValuesBound );
            SafeArrayGetLBound( saValues, 1, &lValuesBound );
            SafeArrayAccessData( saValues, (void HUGEP **)&pValuesData );
            
            if( bMakeString ){

                //
                // DWORD => LPTSTR
                //

                for ( LONG i=lValuesBound; i<=uValuesBound; i++) {
                    
                    ULONG dwFlag;

                    if( NULL == saValueMap ){
                        dwFlag = i;
                    }else{
                        if( i<lMapBound || i>uMapBound ){
                            break;
                        }
                        dwFlag = hextoi( pMapData[i] );
                    }

                    if( dwValueType == VALUETYPE_FLAG ){
                        if( (*pdwValue & dwFlag) == dwFlag ){
                        
                            if( nDecoded > 0 ){
                                StringCchCat( buffer, MAXSTR, _T(",") );
                            }

                            StringCchCat( buffer, MAXSTR, pValuesData[i] );
                            nDecoded++;

                        }
                    }else{
                        if( *pdwValue == dwFlag ){
                            if( _tcslen(pValuesData[i]) + sizeof(TCHAR)*2 < MAXSTR ){
                                StringCchCopy( buffer, MAXSTR, pValuesData[i] );
                                nDecoded++;
                                break;
                            }
                        }
                    }
                }            
            }else if(bQuery){

                //
                // Display for query providers X
                //

                SAFEARRAY* saDescription = NULL;
                LONG uDescBound, lDescBound;
                BSTR HUGEP *pDescData;
                LONG i;

                hr = pQualSet->Get( L"ValueDescriptions", 0, &var, NULL );

                if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
                    saDescription = var.parray;
                    if( NULL != saDescription ){
                        SafeArrayGetUBound( saDescription, 1, &uDescBound );
                        SafeArrayGetLBound( saDescription, 1, &lDescBound );
                        SafeArrayAccessData( saDescription, (void HUGEP **)&pDescData );
                    }
                }

                PrintMessage( g_normal, IDS_MESSAGE_QUERYFL, strKey );
                for( i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
                varg_printf( g_normal, _T("\n") );

                for ( i=lValuesBound; i<=uValuesBound; i++) {
                    
                    LPTSTR strMap = _T("");
                    LPTSTR strDesc = _T("");
                    if( NULL != saValueMap ){
                        if( i>=lMapBound && i<=uMapBound ){
                            strMap = pMapData[i];
                        }
                    }

                    if( NULL != saDescription ){
                        if( i>=lDescBound && i<=uDescBound ){
                            strDesc = pDescData[i];
                        }
                    }
                    
                    varg_printf( g_normal, _T("%1!-20s! %2!-18s!  %3!s!\n"), pValuesData[i], strMap, strDesc );

                }

                varg_printf( g_normal, _T("\n") );

                if( NULL != saDescription ){
                    SafeArrayUnaccessData( saDescription );
                    SafeArrayDestroy( saDescription );
                }
                
            }else{

                //
                // LPTSTR => DWORD
                //
                
                if( _tcsstr( buffer, _T("(") ) ){
                    LPWSTR strFlag = _tcstok( buffer, _T("(,)") );

                    while( NULL != strFlag ){
                    
                        BOOL bDecoded = FALSE;

                        for ( LONG i=lValuesBound; i<=uValuesBound; i++) {
                            LONG dwFlag = 0;

                            if( NULL == saValueMap ){
                                dwFlag = i;
                            }else{
                                if( i>=lMapBound && i<=uMapBound ){
                                    dwFlag = hextoi( pMapData[i] );
                                }
                            }

                            if( 0 == _wcsicmp( strFlag, pValuesData[i] ) ){
                                if( VALUETYPE_FLAG == dwValueType ){
                                    *pdwValue |= dwFlag;
                                }else{
                                    *pdwValue = dwFlag;
                                }
                                nDecoded++;
                                bDecoded = TRUE;
                            }
                        }            

                        if( ! bDecoded ){
                            PrintMessage( g_debug, IDS_MESSAGE_WARNING );
                            PrintMessage( g_debug, LOGMAN_WARNING_BAD_CODE, strFlag );
                        }

                        strFlag = _tcstok( NULL, _T("(,)") );
                    }
                }else{
                    *pdwValue = hextoi( buffer );
                }
            
            }
            
            if( NULL != saValueMap ){
                SafeArrayUnaccessData( saValueMap );
                SafeArrayDestroy( saValueMap );
            }

            SafeArrayUnaccessData( saValues );
            SafeArrayDestroy( saValues );

        }

        pQualSet->Release();
    }

    if( bMakeString ){
        if( 0 == nDecoded ){
            StringCchPrintf( buffer, MAXSTR, _T("0x%x"), *pdwValue );
        }else{
            StringCchCat( buffer, MAXSTR,  _T(")") );
        }

        *pstrValue = varg_strdup(buffer);
    }else if( !bQuery ){
        if( 0 == nDecoded ){
            if( NULL != pdwValue ){
                *pdwValue = hextoi( buffer );
            }
        }
    }

    if( (DWORD)hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }

    return hr;
}

HRESULT
SetProviderGuid( PPROVIDER_REC pProvider, IWbemClassObject *pClass, LPTSTR strProvider, LPTSTR strGuid )
{
    if( NULL != pProvider ){

        if( !(pProvider->dwMask & PROVIDER_NAME ) ){
            pProvider->strProviderName = varg_strdup( strProvider );
            pProvider->dwMask |= PROVIDER_NAME;
        }
        if( !(pProvider->dwMask & PROVIDER_GUID ) ){
            pProvider->strProviderGuid = varg_strdup( strGuid );
            pProvider->dwMask |= PROVIDER_GUID;
        }
        if( !(pProvider->dwMask & PROVIDER_FLAG) ){
            DecodeFlags( pClass, L"Flags", &pProvider->strFlags, &pProvider->dwFlags );
            pProvider->dwMask |= PROVIDER_FLAG;
        }
        if( !(pProvider->dwMask & PROVIDER_FLAGSTR ) ){
            DecodeFlags( pClass, L"Flags", &pProvider->strFlags, &pProvider->dwFlags );
            pProvider->dwMask |= PROVIDER_FLAGSTR;
        }
        if( !(pProvider->dwMask & PROVIDER_LEVEL) ){
            DecodeFlags( pClass, L"Level", &pProvider->strLevel, &pProvider->dwLevel );
            pProvider->dwMask |= PROVIDER_LEVEL;
        }
        if( !(pProvider->dwMask & PROVIDER_LEVELSTR) ){
            DecodeFlags( pClass, L"Level", &pProvider->strLevel, &pProvider->dwLevel );
            pProvider->dwMask |= PROVIDER_LEVELSTR;
        }

        return ERROR_SUCCESS;
    }

    return ERROR_PATH_NOT_FOUND;
}

HRESULT
QuerySingleProvider(IWbemClassObject *pClass, LPTSTR strProvider, LPTSTR strGuid )
{
    HRESULT hr;

    PrintMessage( g_normal, IDS_MESSAGE_QUERYP );
    for( int i=0;i<79;i++){ varg_printf( g_normal, _T("-") );}
    varg_printf( g_normal, _T("\n") );
    varg_printf( g_normal, _T("%1!-40s! %2!-38s!\n\n"), strProvider, strGuid );

    hr = DecodeFlags( pClass, L"Flags", NULL, NULL );
    hr = DecodeFlags( pClass, L"Level", NULL, NULL );

    return ERROR_SUCCESS;
}

HRESULT
QueryProviders()
{
    HRESULT hr;

    PPROVIDER_REC pProviderList = NULL;
    PPROVIDER_REC pProvider;
    

    if( Commands[eName].bDefined ){

        pProvider = (PPROVIDER_REC)VARG_ALLOC( sizeof(PROVIDER_REC) );
        if( NULL != pProvider ){
            ZeroMemory( pProvider, sizeof(PROVIDER_REC) );

            if( IsStrGuid( Commands[eName].strValue ) ){
                pProvider->strProviderGuid = varg_strdup( Commands[eName].strValue );
                pProvider->dwMask |= PROVIDER_GUID;
            }else{
                pProvider->strProviderName = varg_strdup( Commands[eName].strValue );
                pProvider->dwMask |= PROVIDER_NAME;
            }

        }else{
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pProviderList = pProvider;

        hr = GetTraceNameToGuidMap( &pProviderList, TRUE );
        CHECK_STATUS(hr);

        if( (pProviderList->dwMask & (PROVIDER_GUID|PROVIDER_NAME)) != (PROVIDER_GUID|PROVIDER_NAME) ){
            hr = ERROR_WMI_INSTANCE_NOT_FOUND;
        }

    }else{
        TCHAR buffer[MAXSTR];

        hr = GetTraceNameToGuidMap( &pProviderList, FALSE );
        CHECK_STATUS(hr);

        PrintMessage( g_normal, IDS_MESSAGE_QUERYP );
        for( int i=0;i<79;i++){ varg_printf( g_normal, _T("-") );}
        varg_printf( g_normal, _T("\n") );

        pProvider = pProviderList;

        while( NULL != pProvider  ){
            varg_printf( g_normal, _T("%1!s! %2!-38s!\n"), 
                        PaddedString( pProvider->strProviderName, buffer, MAXSTR, 40 ), 
                        pProvider->strProviderGuid );

            pProvider = pProvider->flink;
        }
 
        varg_printf( g_normal, _T("\n") );
    }

cleanup:
    DeleteProviderList( pProviderList );
    return hr;

}

PPROVIDER_REC
FindProvider( PPROVIDER_REC pProviders, LPTSTR strProvider, LPTSTR strGuid )
{
    PPROVIDER_REC pProvider = pProviders;
    while( pProvider ){

        if( !IsEmpty(pProvider->strProviderGuid) && !IsEmpty(strGuid) ){
            if( !_tcsicmp(pProvider->strProviderGuid, strGuid ) ){
                return pProvider;
            }
        }else if( !IsEmpty(pProvider->strProviderName) && !IsEmpty(strProvider) ){
            if( !_tcsicmp(pProvider->strProviderName, strProvider ) ){
                return pProvider;
            }
        }

        pProvider = pProvider->flink;
    }

    return NULL;
}

HRESULT
GetTraceNameToGuidMap( PPROVIDER_REC* pProviders, BOOL bQuery )
{
    HRESULT hr;
    IWbemServices*  pIWbemServices = NULL;
    IEnumWbemClassObject *pEnumProviders = NULL;
    BOOL bRetrieve = FALSE;
    PPROVIDER_REC pProvider;

    if( pProviders == NULL ){
        return E_FAIL;
    }

    if( NULL == *pProviders ){
        bRetrieve = TRUE;
    }

    if( !bRetrieve && AllProvidersMapped( *pProviders ) ){
        return ERROR_SUCCESS;
    }

    BSTR bszTraceClass = SysAllocString( L"EventTrace" );
    BSTR bszDescription = SysAllocString( L"Description" );
    BSTR bszGuid = SysAllocString( L"Guid" );

    IWbemQualifierSet   *pQualSet = NULL;
    IWbemClassObject    *pClass = NULL;
    VARIANT vDescription;
    VARIANT vGuid;
    ULONG nReturned;

    hr = WbemConnect( &pIWbemServices );
    CHECK_STATUS( hr );

    hr = pIWbemServices->CreateClassEnum (
            bszTraceClass,
            WBEM_FLAG_SHALLOW|WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            NULL,
            &pEnumProviders 
        );
    CHECK_STATUS( hr );

    while( ERROR_SUCCESS == hr ){

        if( !bRetrieve && AllProvidersMapped( *pProviders ) ){
            break;
        }
        
        hr = pEnumProviders->Next( (-1), 1, &pClass, &nReturned );
        
        if( ERROR_SUCCESS == hr ){
            pClass->GetQualifierSet ( &pQualSet );
            if ( pQualSet != NULL ) {
                
                hr = pQualSet->Get ( bszDescription, 0, &vDescription, 0 );
                if( ERROR_SUCCESS == hr ){
                    hr = pQualSet->Get ( bszGuid, 0, &vGuid, 0 );
                    if( ERROR_SUCCESS == hr ){
                        if( bRetrieve ){
                            pProvider = (PPROVIDER_REC)VARG_ALLOC( sizeof(PROVIDER_REC) );
                            if( NULL != pProvider ){
                                ZeroMemory( pProvider, sizeof(PROVIDER_REC) );
                                if( *pProviders == NULL ){
                                    *pProviders = pProvider;
                                }else{
                                    (*pProviders)->blink = pProvider;
                                    pProvider->flink = (*pProviders);
                                    (*pProviders) = pProvider;
                                }
                            }
                        }else{
                            pProvider = FindProvider( *pProviders, vDescription.bstrVal, vGuid.bstrVal );
                        }

                        if( NULL != pProvider ){

                            SetProviderGuid( pProvider, pClass, vDescription.bstrVal, vGuid.bstrVal );
                            
                            if( bQuery ){

                                hr = QuerySingleProvider( pClass, vDescription.bstrVal, vGuid.bstrVal );
                                CHECK_STATUS( hr );

                                hr = (HRESULT)WBEM_S_FALSE;
                            }
                        }
                    }
                }
            }
        }
    }
    
    if( (DWORD)hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }

cleanup:
    SysFreeString( bszTraceClass );
    SysFreeString( bszDescription );
    SysFreeString( bszGuid );

    if (pIWbemServices){ 
        pIWbemServices->Release(); 
    }

    return hr;
}

PDH_STATUS
ScheduleLog()
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PDH_TIME_INFO info;

    if( Commands[eRunFor].bDefined){
        
        DWORD dwSeconds = Commands[eRunFor].stValue.wSecond;
    
        ZeroMemory( &info, sizeof(PDH_TIME_INFO) );
        
        dwSeconds += Commands[eRunFor].stValue.wMinute * 60;
        dwSeconds += Commands[eRunFor].stValue.wHour * 3600;
        info.EndTime = dwSeconds;
        info.SampleCount = PLA_TT_UTYPE_SECONDS;

        pdhStatus = PdhPlaSchedule( 
                Commands[eName].strValue, 
                Commands[eComputer].strValue, 
                PLA_AUTO_MODE_AFTER, 
                &info 
            );

    }
    
    if( ERROR_SUCCESS == pdhStatus && Commands[eManual].bDefined ){

        LPTSTR strManual = Commands[eManual].strValue;
    
        ZeroMemory( &info, sizeof(PDH_TIME_INFO) );

        while( strManual != NULL && *strManual != _T('\0') ){
            if( !_tcsicmp( strManual, _T("start")) ){
                info.StartTime = 1;
            }
            if( !_tcsicmp( strManual,_T("stop")) ){
                info.EndTime = 1;
            }
            strManual += (_tcslen( strManual )+1);
        }

        pdhStatus = PdhPlaSchedule( 
                Commands[eName].strValue, 
                Commands[eComputer].strValue, 
                PLA_AUTO_MODE_NONE, 
                &info 
            );

    }
    
    return pdhStatus;
}

HRESULT
WbemConnect( IWbemServices** pWbemServices )
{
    WCHAR buffer[MAXSTR];
    IWbemLocator     *pLocator = NULL;
    
    BSTR bszNamespace = NULL;

    if( Commands[eComputer].bDefined ){
        StringCchPrintf( buffer, MAXSTR, _T("\\\\%s\\%s"), Commands[eComputer].strValue, L"root\\wmi" );
        bszNamespace = SysAllocString( buffer );
    }else{
        bszNamespace = SysAllocString( L"root\\wmi" );
    }

    HRESULT hr = CoInitialize(0);
    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    CHECK_STATUS( hr );

    if( Commands[eUser].bDefined ){
        BSTR bszUser = SysAllocString( g_strUser );
        BSTR bszPassword = NULL;
        
        if( IsEmpty( g_strPassword ) ){
            bszPassword = SysAllocString( L"" );
        }else{
            bszPassword = SysAllocString( g_strPassword );
        }

        if( NULL != bszUser && NULL != bszPassword ){

            hr = pLocator->ConnectServer(
                    bszNamespace,
                    bszUser, 
                    bszPassword, 
                    NULL, 
                    0L,
                    NULL,
                    NULL,
                    pWbemServices
                );
            
            ZeroMemory( bszPassword, sizeof(WCHAR) * wcslen( bszPassword ) );

        }else{
            hr = E_OUTOFMEMORY;
        }

        SysFreeString( bszUser );
        SysFreeString( bszPassword );

    }else{
        hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    }
    CHECK_STATUS( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,               
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     

   
cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release();    
    }
    
    return hr;
}

HRESULT
EtsQuerySession( IWbemServices *pWbemService, LPTSTR strSession )
{
    HRESULT hr = ERROR_SUCCESS;
    IEnumWbemClassObject* pEnumClass = NULL;
    IWbemClassObject* pClass = NULL;
    IWbemQualifierSet   *pQualSet = NULL;
    TCHAR buffer[MAXSTR];
    BOOL bFound;
    BSTR bszClass = SysAllocString( L"TraceLogger" );

    varg_printf( g_normal, _T("\n") );
    if( NULL == strSession ){
        PrintMessage( g_normal, IDS_MESSAGE_ETSQUERY );
        for(int i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
        varg_printf( g_normal, _T("\n") );
    }

    hr = pWbemService->CreateInstanceEnum( bszClass, WBEM_FLAG_SHALLOW, NULL, &pEnumClass );
    CHECK_STATUS( hr );

    bFound = (NULL==strSession);

    while ( hr == ERROR_SUCCESS ){
        ULONG nObjects;

        hr = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &nObjects );
        if( hr == ERROR_SUCCESS ){
            
            VARIANT vValue;
            CIMTYPE vtType;
            LONG nFlavor;

            pClass->Get( L"Name", 0, &vValue, &vtType, &nFlavor );

            if( NULL == strSession ){
                VARIANT vLogger;
                VARIANT vFile;
                              
                pClass->Get( L"LoggerId", 0, &vLogger, &vtType, &nFlavor );
                pClass->Get( L"LogFileName", 0, &vFile, &vtType, &nFlavor );
                
                hr = VariantChangeType( &vLogger, &vLogger, 0, VT_BSTR );
                if( ERROR_SUCCESS == hr ){
                    PrintMessage( g_normal, 
                            IDS_MESSAGE_ETSQUERYF, 
                            PaddedString( vValue.bstrVal, buffer, MAXSTR, 26 ), 
                            vLogger.bstrVal, 
                            vFile.bstrVal ); 
                }

            }else{
                BSTR HUGEP  *pData;

                SAFEARRAY* saProperties;
                LONG uBound, lBound;

                if( _tcsicmp( strSession, vValue.bstrVal ) == 0 ){
                    LoadString( NULL, IDS_MESSAGE_ETSNAME, buffer, MAXSTR );
                    PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYSF, buffer, vValue.bstrVal );
                }else{
                    continue;
                }
                
                bFound = TRUE;

                vValue.boolVal = TRUE;
                vValue.vt = VT_BOOL;
                
                hr = pClass->GetNames( L"DisplayName", WBEM_FLAG_ONLY_IF_TRUE, 0, &saProperties );
                if( hr == ERROR_SUCCESS && saProperties != NULL ){
                    SafeArrayGetUBound( saProperties, 1, &uBound );
                    SafeArrayGetLBound( saProperties, 1, &lBound );
                    SafeArrayAccessData( saProperties, (void HUGEP **)&pData );
                    for( LONG i=lBound;i<=uBound;i++){
                        VARIANT vLabel;
                        pClass->GetPropertyQualifierSet( pData[i], &pQualSet );
                        pQualSet->Get( L"DisplayName", 0, &vLabel, &nFlavor );
                        StringCchPrintf( buffer, MAXSTR, _T("%s:"), vLabel.bstrVal );
                        pClass->Get( pData[i], 0, &vValue, &vtType, &nFlavor );
                        hr = VariantChangeType( &vValue, &vValue, 0, VT_BSTR );
                        if( SUCCEEDED(hr) ){
                            PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYSF, buffer, vValue.bstrVal );   
                        }
                        VariantClear( &vValue );
                        VariantClear( &vLabel );
                    }
                    SafeArrayUnaccessData( saProperties );
                    SafeArrayDestroy( saProperties );
                }

                hr = pClass->Get( L"Guid", 0, &vValue, &vtType, &nFlavor );
                if( ERROR_SUCCESS == hr && VT_NULL != vValue.vt ){
                    LONG HUGEP  *pFlagData;
                    SAFEARRAY* saFlags = NULL;
                    LONG uFlagBound, lFlagBound;

                    LONG HUGEP  *pLevelData;
                    SAFEARRAY* saLevels = NULL;
                    LONG uLevelBound, lLevelBound;

                    saProperties = vValue.parray;
                    SafeArrayGetUBound( saProperties, 1, &uBound );
                    SafeArrayGetLBound( saProperties, 1, &lBound );
                    SafeArrayAccessData( saProperties, (void HUGEP **)&pData );
                    
                    hr = pClass->Get( L"EnableFlags", 0, &vValue, NULL, NULL );
                    if( ERROR_SUCCESS == hr && VT_NULL != vValue.vt ){
                        saFlags = vValue.parray;
                        SafeArrayGetUBound( saFlags, 1, &uFlagBound );
                        SafeArrayGetLBound( saFlags, 1, &lFlagBound );
                        SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData );
                    }

                    hr = pClass->Get( L"Level", 0, &vValue, NULL, NULL );
                    if( ERROR_SUCCESS == hr && VT_NULL != vValue.vt ){
                        saLevels = vValue.parray;
                        SafeArrayGetUBound( saLevels, 1, &uLevelBound );
                        SafeArrayGetLBound( saLevels, 1, &lLevelBound );
                        SafeArrayAccessData( saLevels, (void HUGEP **)&pLevelData );
                    }
                    
                    PPROVIDER_REC pProviderList = NULL;
                    PPROVIDER_REC pProvider;

                    for( LONG i=lBound;i<=uBound;i++){
                        pProvider = (PPROVIDER_REC)VARG_ALLOC(sizeof(PROVIDER_REC) );
                        if( NULL != pProvider ){
                            ZeroMemory( pProvider, sizeof(PROVIDER_REC) );
                            pProvider->strProviderGuid = varg_strdup( pData[i] );
                            pProvider->dwMask |= PROVIDER_GUID;
                            
                            if( i >= lFlagBound && i <= uFlagBound ){
                                pProvider->dwFlags = pFlagData[i];
                                pProvider->dwMask |= PROVIDER_FLAG;
                            }

                            if( i >= lLevelBound && i <= uLevelBound ){
                                pProvider->dwLevel = pLevelData[i];
                                pProvider->dwMask |= PROVIDER_LEVEL;
                            }

                            if( NULL == pProviderList ){
                                pProviderList = pProvider;
                            }else{
                                pProvider->flink = pProviderList;
                                pProviderList->blink = pProvider;
                                pProviderList = pProvider;
                            }
                        }
                    }

                    hr = GetTraceNameToGuidMap( &pProviderList, FALSE );

                    if( NULL != pProviderList ){

                        varg_printf( g_normal, _T("\n") );

                        PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYP );
                        for(int i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
                        varg_printf( g_normal, _T("\n") );
                        
                        pProvider = pProviderList;
                        
                        while( pProvider ){
                            if( (pProvider->dwMask & PROVIDER_NAME) && !IsEmpty(pProvider->strProviderName ) ){
                                if( _tcslen( pProvider->strProviderName ) + 3*sizeof(TCHAR) < MAXSTR ){
                                    LPTSTR strValue;

                                    StringCchPrintf( buffer, MAXSTR, _T("\"%s\""), pProvider->strProviderName );
                                    varg_printf( g_normal, _T("* %1!-38s!  "), buffer );
                                
                                    strValue = NULL;

                                    if( (pProvider->dwMask & PROVIDER_FLAGSTR) &&
                                        !IsEmpty(pProvider->strFlags ) ){

                                        if( _tcsstr( pProvider->strFlags, _T("(") ) ){
                                            strValue = pProvider->strFlags;
                                        }

                                    }
                                    if( NULL == strValue ){
                                        StringCchPrintf( buffer, MAXSTR, _T("0x%08x"), pProvider->dwFlags );
                                        strValue = buffer;
                                    }
                                    varg_printf( g_normal, _T("%1!-24s!  "), strValue );
                                
                                    strValue = NULL;
                                    if( (pProvider->dwMask & PROVIDER_LEVELSTR) &&
                                        !IsEmpty( pProvider->strLevel ) ){

                                        if( _tcsstr( pProvider->strLevel, _T("(") ) ){
                                            strValue = pProvider->strLevel;
                                        }
                                    }
                                    if( NULL == strValue ){
                                        StringCchPrintf( buffer, MAXSTR, _T("0x%02x"), pProvider->dwLevel );
                                        strValue = buffer;
                                    }
                                    varg_printf( g_normal, _T("%1!s!\n"), strValue );
                                }
                            }

                            if( (pProvider->dwMask & PROVIDER_GUID) && !IsEmpty(pProvider->strProviderGuid ) ){
                                varg_printf( g_normal, _T("  %1!-38s!  0x%2!08x!                0x%3!02x!\n\n"),
                                    pProvider->strProviderGuid,
                                    pProvider->dwFlags,
                                    pProvider->dwLevel );
                            }

                            pProvider = pProvider->flink;
                        }

                        DeleteProviderList( pProviderList );
                    }
                }
            }
        }
    }

    if( (DWORD)hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }
    if( SUCCEEDED(hr) && !bFound ){
        hr = ERROR_WMI_INSTANCE_NOT_FOUND;
    }
    
    if( SUCCEEDED(hr) ){
        varg_printf( g_normal, _T("\n") );
    }

cleanup:

    SysFreeString( bszClass );

    return hr;
}

#define  FIRST_MODE( b ) if( !b ){ StringCchCat( buffer, MAXSTR, L"|" );}else{b=FALSE;}

HRESULT
EtsSetSession( IWbemServices* pWbemService, IWbemClassObject* pTrace )
{
    HRESULT hr = ERROR_SUCCESS;
    VARIANT var;
    WCHAR buffer[MAXSTR];
    BOOL bFirst;
    
    VariantInit( &var );

    if( Commands[eOutput].bDefined ){
        
        TCHAR full[MAXSTR];
        _tfullpath( full, Commands[eOutput].strValue, MAXSTR );

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( full );
        hr = pTrace->Put( L"LogFileName", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }else if( !Commands[eRealTime].bDefined && !Commands[eUpdate].bDefined ){
        TCHAR full[MAXSTR];
        size_t cbPathSize = (_tcslen( Commands[eName].strValue )+6) * sizeof(TCHAR);
        LPTSTR strPath = (LPTSTR)VARG_ALLOC( cbPathSize );
        if( NULL != strPath ){
            StringCbCopy( strPath, cbPathSize, Commands[eName].strValue );
            StringCbCat( strPath, cbPathSize, _T(".etl") );

            _tfullpath( full, strPath, MAXSTR );

            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString( full );
            hr = pTrace->Put( L"LogFileName", 0, &var, 0);
            VariantClear(&var);
            VARG_FREE( strPath );
            CHECK_STATUS( hr );
        }else{
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }else if( Commands[eUpdate].bDefined ){
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( L"" );

        hr = pTrace->Put( L"LogFileName", 0, &var, 0);
        VariantClear( &var );
    }
    
    if( Commands[eClockType].bDefined ){
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( Commands[eClockType].strValue );

        hr = pTrace->Put( L"ClockType", 0, &var, 0);
        VariantClear( &var );
    }

    if( Commands[eBufferSize].bDefined ){
        var.vt = VT_I4;
        var.lVal = Commands[eBufferSize].nValue;
        hr = pTrace->Put( L"BufferSize", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( Commands[eBuffers].bDefined ){
        LPTSTR strMin;
        LPTSTR strMax;
        var.vt = VT_I4;

        strMin = Commands[eBuffers].strValue;
        
        if( NULL != strMin ){
            var.lVal = _ttoi( strMin );
            hr = pTrace->Put( L"MinimumBuffers", 0, &var, 0);
            CHECK_STATUS( hr );
    
            strMax = strMin + (_tcslen( strMin )+1);
            if( *strMax != _T('\0') ){
                var.lVal = _ttoi( strMax );
                hr = pTrace->Put( L"MaximumBuffers", 0, &var, 0);
                CHECK_STATUS( hr );
            }
        }
    }

    if( Commands[eMax].bDefined ){
        var.vt = VT_I4;
        var.lVal = Commands[eMax].nValue;
        hr = pTrace->Put( L"MaximumFileSize", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    buffer[0] = L'\0';
    var.vt = VT_BSTR;
    bFirst = TRUE;

    if( Commands[eFormat].bDefined || Commands[eAppend].bDefined ){
        DWORD dwFormat = 0;
        hr = GetFileFormat( Commands[eFormat].strValue, &dwFormat );
        switch(dwFormat){
        case PLA_BIN_CIRC_FILE:
            FIRST_MODE( bFirst );
            StringCchCopy( buffer, MAXSTR, L"Circular" );
            break;
        case PLA_BIN_FILE:
        default:
            FIRST_MODE( bFirst );
            StringCchCopy( buffer, MAXSTR, L"Sequential" );
        }
    }
    if( Commands[eAppend].bDefined ){
        FIRST_MODE( bFirst );
        StringCchCat( buffer, MAXSTR, L"Append" );
    }
    if( Commands[eRealTime].bDefined ){
        FIRST_MODE( bFirst );
        StringCchCat( buffer, MAXSTR, L"RealTime" );
    }
    if( Commands[eUserMode].bDefined ){
        FIRST_MODE( bFirst );
        StringCchCat( buffer, MAXSTR, L"Private" );
    }
    if( Commands[eMode].bDefined && Commands[eMode].strValue != NULL ){
        LPTSTR strMode = Commands[eMode].strValue;
        while( *strMode != _T('\0') ){
            if( (wcslen( buffer ) + wcslen( strMode ) + 2) > MAXSTR ){
                break;
            }
            FIRST_MODE( bFirst );
            StringCchCat( buffer, MAXSTR, strMode );
            strMode += (wcslen(strMode)+1);
        }
    }
    var.bstrVal = SysAllocString( buffer );
    hr = pTrace->Put( L"LogFileMode", 0, &var, 0);
    VariantClear( &var );
    CHECK_STATUS( hr );

    if( Commands[eFlushTimer].bDefined ){
        
        DWORD dwSeconds;
        dwSeconds = Commands[eFlushTimer].stValue.wSecond;
        dwSeconds += Commands[eFlushTimer].stValue.wMinute * 60;
        dwSeconds += Commands[eFlushTimer].stValue.wHour * 3600;

        var.vt = VT_I4;
        var.lVal = dwSeconds;

        hr = pTrace->Put( L"FlushTimer", 0, &var, 0);
        
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( Commands[eAgeLimit].bDefined ){
        
        var.vt = VT_I4;
        var.lVal = Commands[eAgeLimit].nValue;

        hr = pTrace->Put( L"AgeLimit", 0, &var, 0);
        
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( !Commands[eProviders].bDefined && !Commands[eProviderFile].bDefined ){

        if( _tcsicmp( Commands[eName].strValue, KERNEL_LOGGER_NAME ) == 0 ){
        
            LoadString( NULL, IDS_DEFAULT_ETSENABLE, buffer, MAXSTR );
            Commands[eProviders].bDefined = TRUE;
            varg_cmdStringAssign( eProviders, NT_KERNEL_GUID );
            varg_cmdStringAddMsz( eProviders, buffer );
        }
    }

    if( Commands[eProviders].bDefined || Commands[eProviderFile].bDefined ){
        PDH_PLA_ITEM providers;
        
        LPTSTR strGuid;
        LPTSTR strLevel;
        LPTSTR strFlags;
        long dwCount = 0;

        ZeroMemory( &providers, sizeof(PDH_PLA_ITEM) );

        hr = GetProviders( &providers );
        CHECK_STATUS( hr );
        
        strGuid = providers.strProviders;
        strLevel = providers.strLevels;
        strFlags = providers.strFlags;

        if( strGuid != NULL ){
            SAFEARRAY* saGuids;
            SAFEARRAY* saLevel;
            SAFEARRAY* saFlags;

            while( *strGuid != _T('\0') ){
                strGuid += _tcslen( strGuid )+1;
                
                dwCount++;
            }
            
            strGuid = providers.strProviders;
            saGuids = SafeArrayCreateVector( VT_BSTR, 0, dwCount );
            saFlags = SafeArrayCreateVector( VT_I4, 0, dwCount );
            saLevel = SafeArrayCreateVector( VT_I4, 0, dwCount );

            if( saGuids == NULL || saFlags == NULL || saLevel == NULL ){
                if( saGuids != NULL ){
                    SafeArrayDestroy( saGuids );
                }
                if( saFlags != NULL ){
                    SafeArrayDestroy( saFlags );
                }
                if( saLevel != NULL ){
                    SafeArrayDestroy( saLevel );
                }
            }else{
                BSTR HUGEP *pGuidData;
                DWORD HUGEP *pLevelData;
                DWORD HUGEP *pFlagData;

                SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData);
                SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData);
                SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData);

                for (long i=dwCount-1; i >=0; i--) {
                    if( strGuid != NULL ){                       
                        BSTR bszGuid = SysAllocString( strGuid );
                        pGuidData[i] = bszGuid;
                        strGuid += _tcslen( strGuid )+1;
                    }
                    if( strLevel != NULL ){
                        pLevelData[i] = hextoi( strLevel );
                        strLevel += _tcslen( strLevel )+1;
                    }
                    if( strFlags != NULL ){
                        pFlagData[i] = hextoi( strFlags );
                        strFlags += _tcslen( strFlags )+1;
                    }
                }

                SafeArrayUnaccessData( saGuids );    
                SafeArrayUnaccessData( saFlags );    
                SafeArrayUnaccessData( saLevel );    
                VARIANT vArray;

                vArray.vt = VT_ARRAY|VT_BSTR;
                vArray.parray = saGuids;
                pTrace->Put( L"Guid", 0, &vArray, 0 );

                vArray.vt = VT_ARRAY|VT_I4;
                vArray.parray = saFlags;
                pTrace->Put( L"EnableFlags", 0, &vArray, 0 );

                vArray.vt = VT_ARRAY|VT_I4;
                vArray.parray = saLevel;
                pTrace->Put( L"Level", 0, &vArray, 0 );

                SafeArrayDestroy( saGuids );
                SafeArrayDestroy( saFlags );
                SafeArrayDestroy( saLevel );
            }
        }
    }

cleanup:
    return hr;
}

HRESULT
EtsCallSession( IWbemServices *pWbemService, LPWSTR strFunction )
{
    HRESULT hr;

    WCHAR buffer[MAXSTR];
    IWbemClassObject *pOutInst = NULL;

    BSTR bszFunction = SysAllocString( strFunction );
    BSTR bszNamespace = NULL;
    BSTR bszInstance = NULL;

    
    if( Commands[eUserMode].bDefined ){
        PDH_PLA_ITEM providers;
        ZeroMemory( &providers, sizeof(PDH_PLA_ITEM) );
        
        hr = GetProviders( &providers );
        if( ERROR_SUCCESS == hr ){
            hr = StringCchPrintfW( buffer, MAXSTR, L"TraceLogger.Name=\"%s:%s\"", PRIVATE_GUID, providers.strProviders );    
        }
    }else{
        hr = StringCchPrintfW( buffer, MAXSTR, L"TraceLogger.Name=\"%s\"", Commands[eName].strValue );
    }

    bszInstance = SysAllocString( buffer );

    hr = pWbemService->ExecMethod( bszInstance, bszFunction, 0, NULL, NULL, &pOutInst, NULL );
    CHECK_STATUS( hr );

    if( pOutInst ){
        VARIANT var;
        VariantInit( &var );
        pOutInst->Get( L"ReturnValue", 0, &var, NULL, NULL );
        hr = var.lVal;
    }
    
cleanup:
    SysFreeString( bszInstance );
    SysFreeString( bszFunction );

    if( pOutInst ){
        pOutInst->Release();
    }
    
    return hr;
}

HRESULT
EtsStartSession(IWbemServices *pWbemService)
{
    HRESULT hr = ERROR_SUCCESS;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject* pNewTrace = NULL;
    IWbemCallResult  *pCallResult = NULL;

    VARIANT var;

    BSTR bszClass = SysAllocString( L"TraceLogger" );
    
    hr = pWbemService->GetObject( bszClass, 0, NULL, &pClass, NULL);
    CHECK_STATUS( hr );

    hr = pClass->SpawnInstance( 0, &pNewTrace );
    CHECK_STATUS( hr );
    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( Commands[eName].strValue );
    hr = pNewTrace->Put( L"Name", 0, &var, 0);
    VariantClear(&var);

    hr = EtsSetSession( pWbemService, pNewTrace );
    CHECK_STATUS( hr );
    
    hr = pWbemService->PutInstance( pNewTrace, WBEM_FLAG_CREATE_ONLY, NULL, &pCallResult );
    CHECK_STATUS( hr );
    
    if( pCallResult ){
        LONG lResult;
        pCallResult->GetCallStatus( WBEM_INFINITE, &lResult );
        hr = lResult;
    }
    CHECK_STATUS( hr );

cleanup:
    
    SysFreeString( bszClass );

    if( pCallResult ){
        pCallResult->Release();
    }

    return hr;
}

HRESULT
EtsEnableSession(IWbemServices *pWbemService)
{
    HRESULT hr;

    WCHAR buffer[MAXSTR];
    IWbemClassObject *pOutInst = NULL;
    IWbemCallResult  *pCallResult = NULL;
    IWbemClassObject *pTrace = NULL;

    BSTR bszNamespace = NULL;
    BSTR bszInstance = NULL;

    StringCchPrintfW( buffer, MAXSTR, L"TraceLogger.Name=\"%s\"", Commands[eName].strValue );
    bszInstance = SysAllocString( buffer );

    hr = pWbemService->GetObject( bszInstance, 0, NULL, &pTrace, NULL);
    CHECK_STATUS( hr );

    hr = EtsSetSession( pWbemService, pTrace );
    CHECK_STATUS( hr );

    hr = pWbemService->PutInstance( pTrace, WBEM_FLAG_UPDATE_ONLY, NULL, &pCallResult );
    CHECK_STATUS( hr );

    if( pCallResult ){
        LONG lResult;

        pCallResult->GetCallStatus( WBEM_INFINITE, &lResult );
        hr = lResult;
    }
    CHECK_STATUS( hr );
    
cleanup:
    SysFreeString( bszInstance );

    if( pCallResult ){
        pCallResult->Release();
    }
    if( pOutInst ){
        pOutInst->Release();
    }
    
    return hr;
}

HRESULT EventTraceSessionControl()
{
    HRESULT hr = ERROR_SUCCESS;
    IWbemServices *pWbemService = NULL;

    hr = WbemConnect( &pWbemService );
    CHECK_STATUS( hr );

    if( Commands[eFlushBuffers].bValue ){
        hr = EtsCallSession( pWbemService, L"FlushTrace" );
    }else if( Commands[eQuery].bDefined ){
        hr = EtsQuerySession( pWbemService, Commands[eName].strValue );
    }else if( Commands[eStart].bDefined || Commands[eCreate].bDefined ){
        hr = EtsStartSession( pWbemService );
        if( SUCCEEDED(hr) ){
            EtsQuerySession( pWbemService, Commands[eName].strValue );
        }
    }else if( Commands[eStop].bDefined || Commands[eDelete].bDefined ){
        hr = EtsCallSession( pWbemService, L"StopTrace" );
    }else if( Commands[eUpdate].bDefined ){
        hr = EtsEnableSession( pWbemService );
    }

cleanup:
    if( pWbemService ){
        pWbemService->Release();
    }

    return hr;
}

HRESULT WbemError( HRESULT hr )
{
    WCHAR szError[MAXSTR] = { NULL };
    WCHAR szFacility[MAXSTR] = { NULL };
    IWbemStatusCodeText * pStatus = NULL;
    
    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if(sc == S_OK){
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
        if(sc == S_OK){
            wcsncpy(szError, bstr, MAXSTR-1);
            SysFreeString(bstr);
            bstr = 0;
        }

        sc = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
        if(sc == S_OK){
            wcsncpy(szFacility, bstr, MAXSTR-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        
        pStatus->Release();
    }
 
    if( Commands[eDebug].bDefined ){
        if( _tcscmp( szFacility, L"<Null>" ) == 0 ){
            LoadString( NULL, IDS_MESSAGE_SYSTEM, szFacility, MAXSTR );
        }

        PrintMessage( g_debug, LOGMAN_ERROR_WBEM, hr, szFacility, szError );
    }else{
        PrintMessage( g_debug, IDS_MESSAGE_ERROR );
        varg_printf( g_debug, _T("%1!s!"), szError );
    }

    return ERROR_SUCCESS;
}

void 
ShowValidationError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo )
{
    DWORD dwFlag;
    DWORD dwMask; 
    
    if( SEVERITY( pdhStatus ) == STATUS_SEVERITY_WARNING ){
        dwMask = pInfo->dwReserved2;
    }else{
        dwMask = pInfo->dwMask;
    }

    if( 0 == dwMask ){
        return;
    }

    for( ULONG i=1;i<0x80000000; i*=2 ){
        
        dwFlag = (i & dwMask);
        
        if( 0 == dwFlag ){
            continue;
        }

        switch( SEVERITY( pdhStatus ) ){
        case STATUS_SEVERITY_ERROR:
            PrintMessage( g_debug, IDS_MESSAGE_ERROR );
            break;
        case STATUS_SEVERITY_WARNING:
            PrintMessage( g_debug, IDS_MESSAGE_WARNING );
            break;
        }
    
        switch( dwFlag ){
        case PLA_INFO_FLAG_FORMAT:
            PrintMessage( g_debug, LOGMAN_ERROR_FILEFORMAT, pInfo->dwFileFormat );
            break;
        case PLA_INFO_FLAG_INTERVAL:
            PrintMessage( g_debug, LOGMAN_ERROR_INTERVAL );
            break;
        case PLA_INFO_FLAG_BUFFERSIZE:
            PrintMessage( g_debug, LOGMAN_ERROR_BUFFERSIZE, pInfo->Trace.dwBufferSize );
            break;
        case PLA_INFO_FLAG_MINBUFFERS:
            PrintMessage( g_debug, LOGMAN_ERROR_MINBUFFER, pInfo->Trace.dwMinimumBuffers );
            break;
        case PLA_INFO_FLAG_MAXBUFFERS:
            PrintMessage( g_debug, LOGMAN_ERROR_MAXBUFFER, pInfo->Trace.dwMinimumBuffers );
            break;
        case PLA_INFO_FLAG_FLUSHTIMER:
            PrintMessage( g_debug, LOGMAN_ERROR_FLUSHTIMER, pInfo->Trace.dwFlushTimer );
            break;
        case PLA_INFO_FLAG_MAXLOGSIZE:
            PrintMessage( g_debug, LOGMAN_ERROR_MAXLOGSIZE, pInfo->dwMaxLogSize );
            break;
        case PLA_INFO_FLAG_RUNCOMMAND:
            PrintMessage( g_debug, LOGMAN_ERROR_CMDFILE, pInfo->strCommandFileName );
            break;
        case PLA_INFO_FLAG_FILENAME:
            if( Commands[eOutput].bDefined ){
                PrintMessage( g_debug, LOGMAN_ERROR_FILENAME );
            }else{
                PrintMessage( g_debug, LOGMAN_ERROR_FILENAME_DEFAULT );
            }
            break;
        case PLA_INFO_FLAG_AUTOFORMAT:
            PrintMessage( g_debug, LOGMAN_ERROR_AUTOFORMAT );
            break;
        case PLA_INFO_FLAG_USER:
            PrintMessage( g_debug, LOGMAN_ERROR_USER, pInfo->strUser );
            break;
        case PLA_INFO_FLAG_DATASTORE:
            switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ){
            case PLA_DATASTORE_APPEND:
                PrintMessage( g_debug, LOGMAN_ERROR_DATASTOREA );
                break;
            case PLA_DATASTORE_OVERWRITE:
                PrintMessage( g_debug, LOGMAN_ERROR_DATASTOREO );
                break;
            }
            break;
        case PLA_INFO_FLAG_MODE:
            PrintMessage( g_debug, LOGMAN_ERROR_TRACEMODE, pInfo->Trace.dwMode );
            break;
        case PLA_INFO_FLAG_LOGGERNAME:
            PrintMessage( g_debug, LOGMAN_ERROR_LOGGERNAME, pInfo->Trace.strLoggerName );
            break;
        case PLA_INFO_FLAG_REPEAT:
            PrintMessage( g_debug, LOGMAN_ERROR_REPEATMODE );
            break;
        case PLA_INFO_FLAG_TYPE:
            PrintMessage( g_debug, LOGMAN_ERROR_COLLTYPE, pInfo->dwType );
            break;
        case PLA_INFO_FLAG_DEFAULTDIR:
        case PLA_INFO_FLAG_PROVIDERS:
            PrintMessage( g_debug, LOGMAN_ERROR_PROVIDER );
            break;
        case PLA_INFO_FLAG_COUNTERS:
            {
                LPTSTR strCounter = pInfo->Perf.piCounterList.strCounters;
                if( strCounter != NULL ){
                    DWORD dwCount = 0;
                    while(*strCounter != _T('\0') ){
                        if( dwCount++ == pInfo->dwReserved1 ){
                            break;
                        }
                        strCounter += (_tcslen( strCounter )+1 );
                    }
                }

                PrintMessage( g_debug, LOGMAN_ERROR_COUNTERPATH, strCounter ? strCounter : _T("") );
            }
            break;
        default:
            PrintMessage( g_debug, LOGMAN_ERROR_UNKNOWN );
        }
    }

    varg_printf( g_debug, _T("\n") );
}

void
PdhError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo )
{
    switch( pdhStatus ){
    case PDH_PLA_VALIDATION_ERROR:
    case PDH_PLA_VALIDATION_WARNING:
        ShowValidationError( pdhStatus, pInfo );
        break;
    case PDH_PLA_COLLECTION_ALREADY_RUNNING:
    case PDH_PLA_COLLECTION_NOT_FOUND:
    case PDH_PLA_ERROR_NOSTART:
    case PDH_PLA_ERROR_ALREADY_EXISTS:
        PrintErrorEx( pdhStatus, PDH_MODULE, Commands[eName].strValue );
        break;
    case PDH_OS_EARLIER_VERSION:
        {
            const size_t cchSize = 128;
            TCHAR szLogman[cchSize];
            TCHAR szWin2000[cchSize];
            TCHAR szComputer[cchSize];
        
            if( Commands[eComputer].strValue == NULL ){
                DWORD dwSize = cchSize;
                GetComputerName( szComputer, &dwSize );
            }else{
                StringCchCopy( szComputer, cchSize, Commands[eComputer].strValue );
            }

            LoadString( NULL, IDS_MESSAGE_LOGMAN, szLogman, cchSize );
            LoadString( NULL, IDS_MESSAGE_WIN2000, szWin2000, cchSize );

            PrintErrorEx( pdhStatus, PDH_MODULE, szLogman, szWin2000, szComputer );
            break;
        }
    default:
        PrintErrorEx( pdhStatus, PDH_MODULE );
    }
}

void
LogmanError( DWORD dwStatus )
{
    switch( dwStatus ){
    case LOGMAN_ERROR_FILEFORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_ERROR );
        PrintMessage( g_debug, LOGMAN_ERROR_FILEFORMAT );
        break;
    case LOGMAN_ERROR_LOGON:
        PrintMessage( g_debug, LOGMAN_ERROR_LOGON );
        break;
    default:
        PrintError( dwStatus );
    }
}

ULONG hextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }

    if( wcsstr( s, L"x") || wcsstr( s, L"X" ) ){

        len = (long) wcslen(s);

        if (len == 0) {
            return 0;
        }

        hex  = 0;
        base = 1;
        num  = 0;

        while (-- len >= 0) {
            if (s[len] >= L'0' && s[len] <= L'9'){
                num = s[len] - L'0';
            }else if (s[len] >= L'a' && s[len] <= L'f'){
                num = (s[len] - L'a') + 10;
            }else if (s[len] >= L'A' && s[len] <= L'F'){
                num = (s[len] - L'A') + 10;
            }else if( s[len] == L'x' || s[len] == L'X'){
                break;
            }else{
                continue;
            }

            hex += num * base;
            base = base * 16;
        }
    }else{
        hex = _ttoi( s );
    }

    return hex;
}

#define SE_DEBUG_PRIVILEGE                (20L)
#define SE_SYSTEM_PROFILE_PRIVILEGE       (11L)

DWORD 
AdjustPrivilegeForKernel()
{
    BOOL bResult = TRUE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES*   tkp = NULL;

    tkp = (TOKEN_PRIVILEGES*)VARG_ALLOC(
            sizeof(TOKEN_PRIVILEGES) + 
            sizeof(LUID_AND_ATTRIBUTES) 
        );

    if( NULL == tkp ){
        goto cleanup;
    }

    bResult = OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES,
            &hToken
        );

    if( !bResult ){
        goto cleanup;
    }

    tkp->PrivilegeCount = 2;
    tkp->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    tkp->Privileges[0].Luid.LowPart = SE_DEBUG_PRIVILEGE;
    tkp->Privileges[0].Luid.HighPart = 0;
    
    tkp->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
    tkp->Privileges[1].Luid.LowPart = SE_SYSTEM_PROFILE_PRIVILEGE;
    tkp->Privileges[1].Luid.HighPart = 0;

    bResult = AdjustTokenPrivileges(
            hToken,
            FALSE,
            tkp,
            0,
            (PTOKEN_PRIVILEGES)NULL,
            NULL
        );

    if( INVALID_HANDLE_VALUE != hToken ){
        CloseHandle( hToken );
    }

cleanup:

    VARG_FREE(tkp);
    
    if( !bResult ){
        return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\win2000\rpdh.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <pdh.h>
#include <pdhp.h>
#include <pdhmsg.h>
#include <winperf.h>
#include <tchar.h>
#include <varg.h>

#include "rpdh.h"

const DWORD   dwFileHeaderLength =    13;
const DWORD   dwTypeLoc =             2;
const DWORD   dwFieldLength =         7;
const DWORD   dwPerfmonTypeLength =   5;

LPCSTR  szTsvType          =    "PDH-TSV";
LPCSTR  szCsvType          =    "PDH-CSV";
LPCSTR  szBinaryType       =    "PDH-BIN";
LPCWSTR    cszPerfmonLogSig        = (LPCWSTR)L"Loges";

#define MemoryAllocate(x) \
    ((LPVOID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
#define MemoryFree(x) \
    if( x ){ ((VOID) HeapFree(GetProcessHeap(), 0, x)); x = NULL; }
#define MemoryResize(x,y) \
    ((LPVOID) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y));

#define MAKEULONGLONG(low, high) \
        ((ULONGLONG) (((DWORD) (low)) | ((ULONGLONG) ((DWORD) (high))) << 32))

#define PDH_BLG_HEADER_SIZE 24
#define PDH_MAX_BUFFER      0x01000000
#define PDH_HEADER_BUFFER   65536

typedef struct _PDHI_BINARY_LOG_RECORD_HEADER {
    DWORD       dwType;
    DWORD       dwLength;
} PDHI_BINARY_LOG_RECORD_HEADER, *PPDHI_BINARY_LOG_RECORD_HEADER;

PDH_STATUS
R_PdhRelog( LPTSTR szSource, HQUERY hQuery, PPDH_RELOG_INFO_W pRelogInfo )
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    HLOG            hLogOut;
    ULONG           nSampleCount = 0;
    ULONG           nSamplesWritten = 0;

    ULONG nRecordSkip;

    pdhStatus = PdhOpenLogW(
            pRelogInfo->strLog, 
            pRelogInfo->dwFlags,
            &pRelogInfo->dwFileFormat, 
            hQuery,
            0,
            NULL,
            &hLogOut
        );

    if( pdhStatus == ERROR_SUCCESS ){
        
        DWORD dwNumEntries = 1;
        DWORD dwBufferSize = sizeof(PDH_TIME_INFO);
        PDH_TIME_INFO TimeInfo;

        ZeroMemory( &TimeInfo, sizeof( PDH_TIME_INFO ) );
 
        pdhStatus = PdhGetDataSourceTimeRange(
                            szSource,
                            &dwNumEntries,
                            &TimeInfo,
                            &dwBufferSize
                        );

        if( pRelogInfo->TimeInfo.StartTime > TimeInfo.StartTime && 
            pRelogInfo->TimeInfo.StartTime < TimeInfo.EndTime ){

            TimeInfo.StartTime = pRelogInfo->TimeInfo.StartTime;
        }

        if( pRelogInfo->TimeInfo.EndTime < TimeInfo.EndTime &&
            pRelogInfo->TimeInfo.EndTime > TimeInfo.StartTime ){

            TimeInfo.EndTime = pRelogInfo->TimeInfo.EndTime;
        }
        
        if( TimeInfo.EndTime > TimeInfo.StartTime ){
            pdhStatus = PdhSetQueryTimeRange( hQuery, &TimeInfo );
        }

        nRecordSkip = pRelogInfo->TimeInfo.SampleCount >= 1 ? pRelogInfo->TimeInfo.SampleCount : 1;
    
        while( ERROR_SUCCESS == pdhStatus ){

            if( nSampleCount++ % nRecordSkip ){
                pdhStatus = PdhCollectQueryData( hQuery );
                continue;
            }

            if( ERROR_SUCCESS == pdhStatus ){
                pdhStatus = PdhUpdateLog( hLogOut, NULL );
                nSamplesWritten++;
            }
        }

        if( PDH_NO_MORE_DATA == pdhStatus || 
            (PDH_ENTRY_NOT_IN_LOG_FILE == pdhStatus && pRelogInfo->dwFileFormat == PDH_LOG_TYPE_BINARY) ){
   
            pdhStatus = PdhCloseLog( hLogOut, 0 );
            if( ERROR_SUCCESS == pdhStatus ){
                PdhGetDataSourceTimeRange( pRelogInfo->strLog, &dwNumEntries, &pRelogInfo->TimeInfo, &dwBufferSize );
            }
        }
    }
    
    
    pRelogInfo->TimeInfo.SampleCount = nSamplesWritten;

    return pdhStatus;
}

DWORD
GetLogFileType (
    IN  HANDLE  hLogFile
)
{
    CHAR    cBuffer[MAX_PATH];
    CHAR    cType[MAX_PATH];
    WCHAR   wcType[MAX_PATH];
    BOOL    bStatus;
    DWORD   dwResult;
    DWORD   dwBytesRead;

    memset (&cBuffer[0], 0, sizeof(cBuffer));
    memset (&cType[0], 0, sizeof(cType));
    memset (&wcType[0], 0, sizeof(wcType));

    // read first log file record
    SetFilePointer (hLogFile, 0, NULL, FILE_BEGIN);

    bStatus = ReadFile (hLogFile,
        (LPVOID)cBuffer,
        dwFileHeaderLength,
        &dwBytesRead,
        NULL);

    if (bStatus) {
        // read header record to get type
        lstrcpynA (cType, (LPSTR)(cBuffer+dwTypeLoc), dwFieldLength+1);
        if (lstrcmpA(cType, szTsvType) == 0) {
            dwResult = PDH_LOG_TYPE_TSV;
        } else if (lstrcmpA(cType, szCsvType) == 0) {
            dwResult = PDH_LOG_TYPE_CSV;
        } else if (lstrcmpA(cType, szBinaryType) == 0) {
            dwResult = PDH_LOG_TYPE_RETIRED_BIN_;
        } else {
            // perfmon log file type string is in a different
            // location than sysmon logs and used wide chars.
            lstrcpynW (wcType, (LPWSTR)cBuffer, dwPerfmonTypeLength+1);
            if (lstrcmpW(wcType, cszPerfmonLogSig) == 0) {
                dwResult = PDH_LOG_TYPE_PERFMON;
            } else {
                dwResult = PDH_LOG_TYPE_UNDEFINED;
            }
        } 
    } else {
        // unable to read file
        dwResult = PDH_LOG_TYPE_UNDEFINED;
    }
    return dwResult;

}

PDH_STATUS
R_PdhBlgLogFileHeader(LPCWSTR szFile1, LPCWSTR szFile2)
{
    BOOL       bReturn   = FALSE;
    PDH_STATUS Status    = ERROR_SUCCESS;
    LPWSTR     szHeaderList1 = NULL;
    LPWSTR     szHeaderList2 = NULL;
    DWORD      dwHeader1 = 0;
    DWORD      dwHeader2 = 0;
    LPWSTR     szName1;
    LPWSTR     szName2;

    Status = PdhListLogFileHeaderW(szFile1, szHeaderList1, &dwHeader1);
    if (Status != ERROR_SUCCESS && Status != PDH_MORE_DATA && Status != PDH_INSUFFICIENT_BUFFER){
        goto Cleanup;
    }
    szHeaderList1 = (LPWSTR)MemoryAllocate( (dwHeader1+1)*sizeof(WCHAR) );
    Status = PdhListLogFileHeaderW(szFile1, szHeaderList1, &dwHeader1);
    if (Status != ERROR_SUCCESS ){
        goto Cleanup;
    }

    Status = PdhListLogFileHeaderW(szFile2, szHeaderList2, &dwHeader2);
    if (Status != ERROR_SUCCESS && Status != PDH_MORE_DATA && Status != PDH_INSUFFICIENT_BUFFER){
        goto Cleanup;
    }
    szHeaderList2 = (LPWSTR)MemoryAllocate( (dwHeader2+1)*sizeof(WCHAR) );
    Status = PdhListLogFileHeaderW(szFile2, szHeaderList2, &dwHeader2);
    if (Status != ERROR_SUCCESS ){
        goto Cleanup;
    }

    for (szName1 = szHeaderList1, szName2 = szHeaderList2;
         szName1[0] != L'\0' && szName2[0] != L'\0';
         szName1 += (lstrlenW(szName1) + 1),
         szName2 += (lstrlenW(szName2) + 1)) {

        if (lstrcmpiW(szName1, szName2) != 0) {
            varg_printf( g_debug, _T("(%s) != (%s)\n"), szName1, szName2);
            break;
        }
    }

    if (szName1[0] != L'\0' || szName2[0] != L'\0'){
        Status = PDH_HEADER_MISMATCH;
    }

Cleanup:
    MemoryFree( szHeaderList1 );
    MemoryFree( szHeaderList2 );
    
    return Status;
}

PDH_STATUS
R_PdhGetLogFileType(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HANDLE     hFile;
    DWORD      dwLogFormat;

    if (LogFileName == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLogFormat   = * LogFileType;
            * LogFileType = dwLogFormat;
            if (* LogFileName == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        hFile = CreateFileW(LogFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        dwLogFormat = GetLogFileType(hFile);
        CloseHandle(hFile);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        * LogFileType = dwLogFormat;
    }

    return pdhStatus;
}

PDH_STATUS
R_PdhRelogCopyFile(
        HANDLE    hOutFile,
        HANDLE    hInFile,
        BOOL      bCopyHeader
)
{
    BOOL       bResult    = TRUE;
    PDH_STATUS pdhStatus  = ERROR_SUCCESS;
    DWORD      dwSizeLow  = 0;
    DWORD      dwSizeHigh = 0;
    DWORD      dwBuffer   = PDH_MAX_BUFFER;
    ULONGLONG  lFileSize  = 0;
    ULONGLONG  lCurrent   = 0;
    LPBYTE     pBuffer    = NULL;
    LPBYTE     pCurrent   = NULL;

    PPDHI_BINARY_LOG_RECORD_HEADER pPdhBlgHeader = NULL;

    dwSizeLow = GetFileSize(hInFile, & dwSizeHigh);
    lFileSize = MAKEULONGLONG(dwSizeLow, dwSizeHigh);
    lCurrent  = PDH_BLG_HEADER_SIZE + sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
    if (lCurrent > lFileSize) {
        pdhStatus  = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    pBuffer = (LPBYTE)MemoryAllocate(dwBuffer);
    if (pBuffer == NULL) {
        pdhStatus  = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwSizeLow  = (DWORD) lCurrent;
    dwSizeHigh = 0;
    bResult    = ReadFile(hInFile, pBuffer, dwSizeLow, & dwSizeHigh, NULL);

    if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
        pdhStatus = PDH_INVALID_DATA;
        goto Cleanup;
    }

    pPdhBlgHeader = (PPDHI_BINARY_LOG_RECORD_HEADER)
                    (pBuffer + PDH_BLG_HEADER_SIZE);
    if (pPdhBlgHeader->dwType != 0x01024C42) {
        pdhStatus  = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (pPdhBlgHeader->dwLength + PDH_BLG_HEADER_SIZE > dwBuffer) {
        LPBYTE pTemp = pBuffer;
        pBuffer = (LPBYTE)MemoryResize(pBuffer, pPdhBlgHeader->dwLength);
        if (pBuffer == NULL) {
            MemoryFree(pTemp);
            pdhStatus  = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
    }
    if ((lCurrent + dwSizeLow) > lFileSize) {
        pdhStatus  = PDH_INVALID_HANDLE;
        goto Cleanup;
    }
    pCurrent   = (LPBYTE) (pBuffer + dwSizeLow);
    dwSizeLow  = pPdhBlgHeader->dwLength
               - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
    dwSizeHigh = 0;
    bResult    = ReadFile(hInFile, pCurrent, dwSizeLow, & dwSizeHigh, NULL);
    if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
        pdhStatus = PDH_INVALID_DATA;
        goto Cleanup;
    }

    lCurrent += dwSizeLow;
    if (bCopyHeader) {
        dwSizeLow = dwSizeHigh = (DWORD) lCurrent;
        bResult = WriteFile(hOutFile, pBuffer, dwSizeLow, & dwSizeHigh, NULL);
        if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
            pdhStatus = PDH_INVALID_DATA;
            goto Cleanup;
        }
    }

    while (lCurrent + sizeof(PDHI_BINARY_LOG_RECORD_HEADER) < lFileSize) {
        ZeroMemory(pBuffer, dwBuffer);
        dwSizeLow  = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        dwSizeHigh = 0;
        bResult    = ReadFile(hInFile, pBuffer, dwSizeLow, & dwSizeHigh, NULL);
        if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
            pdhStatus = PDH_INVALID_DATA;
            goto Cleanup;
        }

        pPdhBlgHeader = (PPDHI_BINARY_LOG_RECORD_HEADER) pBuffer;
        if ((pPdhBlgHeader->dwType & 0x0000FFFF) != 0x00004C42) {
            pdhStatus  = PDH_INVALID_ARGUMENT;
            goto Cleanup;
        }

        if (pPdhBlgHeader->dwLength > dwBuffer) {
            LPBYTE pTemp = pBuffer;
            pBuffer = (LPBYTE)MemoryResize(pBuffer, pPdhBlgHeader->dwLength);
            if (pBuffer == NULL) {
                MemoryFree(pTemp);
                pdhStatus  = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }
        }
        if ((lCurrent + pPdhBlgHeader->dwLength) > lFileSize) {
            pdhStatus  = PDH_INVALID_HANDLE;
            bResult = FALSE;
            goto Cleanup;
        }
        pCurrent   = (LPBYTE) (pBuffer + dwSizeLow);
        dwSizeLow  = pPdhBlgHeader->dwLength
                   - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        dwSizeHigh = 0;
        bResult    = ReadFile(hInFile, pCurrent, dwSizeLow, & dwSizeHigh, NULL);
        if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
            pdhStatus = PDH_INVALID_DATA;
            goto Cleanup;
        }

        if ((pPdhBlgHeader->dwType & 0x00FF0000) == 0x00030000) {
            dwSizeLow = dwSizeHigh = pPdhBlgHeader->dwLength;
            bResult = WriteFile(
                            hOutFile, pBuffer, dwSizeLow, & dwSizeHigh, NULL);
            if ((bResult == FALSE) || (dwSizeLow != dwSizeHigh)) {
                pdhStatus = PDH_INVALID_DATA;
                goto Cleanup;
            }
        }

        lCurrent += pPdhBlgHeader->dwLength;
    }

Cleanup:
    if (pBuffer != NULL){
        MemoryFree(pBuffer);
    }

    return pdhStatus;
}

PDH_STATUS
R_PdhAppendLog( LPTSTR szSource, LPTSTR szAppend )
{
    HANDLE hSource   = INVALID_HANDLE_VALUE;
    HANDLE hAppend   = INVALID_HANDLE_VALUE;
    BOOL   bResult   = TRUE;
    PDH_STATUS pdhStatus;

    DWORD dwFormat;
    PDH_TIME_INFO  TimeSource;
    PDH_TIME_INFO  TimeAppend;
    LPTSTR mszSourceHeader = NULL;
    LPTSTR mszAppendHeader = NULL;
    DWORD dwSourceSize = 0;
    DWORD dwAppendSize = 0;

    DWORD dwNumEntries = 1;
    DWORD dwBufferSize = sizeof(PDH_TIME_INFO);

    //
    // Compare the log types, both must be Windows 2000 binary
    //

    pdhStatus = R_PdhGetLogFileType( szSource, &dwFormat );
    if( ERROR_SUCCESS != pdhStatus || PDH_LOG_TYPE_RETIRED_BIN_ != dwFormat ){
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PDH_TYPE_MISMATCH;
        }
        goto cleanup;
    }

    pdhStatus = R_PdhGetLogFileType( szAppend, &dwFormat );
    if( ERROR_SUCCESS != pdhStatus || PDH_LOG_TYPE_RETIRED_BIN_ != dwFormat ){
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PDH_TYPE_MISMATCH;
        }
        goto cleanup;
    }

    //
    // Compare the time ranges, source file must start after append end 
    //

    ZeroMemory( &TimeSource, sizeof( PDH_TIME_INFO ) );
    ZeroMemory( &TimeAppend, sizeof( PDH_TIME_INFO ) );
 
    pdhStatus = PdhGetDataSourceTimeRange(
                        szSource,
                        &dwNumEntries,
                        &TimeSource,
                        &dwBufferSize
                    );
    if( ERROR_SUCCESS != pdhStatus ){
        goto cleanup;
    }

    pdhStatus = PdhGetDataSourceTimeRange(
                        szAppend,
                        &dwNumEntries,
                        &TimeAppend,
                        &dwBufferSize
                    );
    if( ERROR_SUCCESS != pdhStatus ){
        goto cleanup;
    }

    if( TimeSource.EndTime > TimeAppend.StartTime ){
        pdhStatus = PDH_TIME_MISMATCH;
        goto cleanup;
    }

    //
    // Compare the headers, must be exact match
    //

    pdhStatus = R_PdhBlgLogFileHeader( szSource, szAppend );
    if( ERROR_SUCCESS != pdhStatus ){
        goto cleanup;
    }

    //
    // All good, now do the actual append
    // 

    hSource = CreateFileW(
                    szSource,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                 );

    hAppend = CreateFileW(  
                    szAppend,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );

    if ( INVALID_HANDLE_VALUE == hSource || INVALID_HANDLE_VALUE == hAppend ){
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto cleanup;
    }
 
    SetFilePointer( hSource, NULL, NULL, FILE_END );
    pdhStatus = R_PdhRelogCopyFile( hSource, hAppend, FALSE);

cleanup:
    MemoryFree( mszSourceHeader );
    MemoryFree( mszAppendHeader );

    if ( INVALID_HANDLE_VALUE != hAppend ) {
        CloseHandle(hAppend);
    }
    if ( INVALID_HANDLE_VALUE != hSource ) {
        CloseHandle(hSource);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\samples\tracekmp\makefile.inc ===
MOF: tracekmp.bmf

tracekmp.bmf: tracekmp.mof
    mofcomp -B:tracekmp.bmf tracekmp.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\relog\win2000\rpdh.h ===
#ifndef __RPDH_H_06262001__
#define __RPDH_H_06262001__

#define PDH_LOG_TYPE_RETIRED_BIN_   3
#define PDH_TIME_MISMATCH           0xF000C001
#define PDH_HEADER_MISMATCH         0xF000C002
#define PDH_TYPE_MISMATCH           0xF000C003

PDH_STATUS
R_PdhAppendLog( 
    LPTSTR szSource, 
    LPTSTR szAppend 
);

PDH_STATUS
R_PdhGetLogFileType(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType
);

PDH_STATUS
R_PdhRelog( 
    LPTSTR szSource, 
    HQUERY hQuery, 
    PPDH_RELOG_INFO_W pRelogInfo 
);

#endif __RPDH_H_06262001__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\samples\tracedp\tracedp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracedp.c

Abstract:

    Sample trace provider program.

// end_sdk
Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Insung Park (insungp) 18-Jan-2001

      Modified tracedp so that when tracedp generates User Mof Events
    with some sample strings, integers, floats, and arrays.


// begin_sdk
--*/

#include <stdio.h> 
#include <stdlib.h>

#include <windows.h>
#include <shellapi.h>

#include <tchar.h>
#include <wmistr.h>

#include <guiddef.h>
#include <evntrace.h>

#define MAXEVENTS                       5000
#define MAXSTR                          1024
#define MAXTHREADS                      128

// sample string data
#define WIDE_DATA_STRING           L"Sample Wide String"
#define COUNTED_DATA_STRING        L"Sample Counted String"

TRACEHANDLE LoggerHandle;
#define ResourceName _T("MofResource")
TCHAR ImagePath[MAXSTR];

GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};
GUID   ControlGuid[2]  =
{
    {0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc},
    {0x7c6a708a, 0xba1e, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

typedef enum {
    TYPE_USER_EVENT,
    TYPE_INSTANCE_EVENT,
    TYPE_MOF_EVENT,
    TYPEPTR_GUID
} TypeEventType;

typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    ULONG                 EventInfo;
} USER_EVENT, *PUSER_EVENT;

typedef struct _USER_INSTANCE_EVENT {
    EVENT_INSTANCE_HEADER    Header;
    ULONG                    mofData;
} USER_INSTANCE_EVENT, *PUSER_INSTANCE_EVENT;

// customized event to use sample data that follow
typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;

// sample data structure
typedef struct _INTEGER_SAMPLE_EVENT {
    CHAR                  sc;
    UCHAR                 uc;
    SHORT                 sh;
    ULONG                 ul;
} INTEGER_SAMPLE_EVENT, *PINTEGER_SAMPLE_EVENT;

typedef struct _FLOAT_SAMPLE_EVENT {
    float                 fl;
    double                db;
} FLOAT_SAMPLE_EVENT, *PFLOAT_SAMPLE_EVENT;

typedef struct _ARRAY_SAMPLE_EVENT {
    CHAR                  ca[9];
} ARRAY_SAMPLE_EVENT, *PARRAY_SAMPLE_EVENT;

TypeEventType EventType = TYPE_USER_EVENT;
TRACEHANDLE RegistrationHandle[2];
BOOLEAN TraceOnFlag;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;
BOOLEAN bPersistData = FALSE;
ULONG nSleepTime = 0;
ULONG EventCount = 0;

BOOLEAN  bInstanceTrace=0, bUseGuidPtr=0, bUseMofPtr=0;
BOOLEAN  bIncorrect  = FALSE;
BOOLEAN  bUseNullPtr = FALSE;
BOOLEAN  bFirstTime = TRUE;

ULONG InitializeTrace(
    void
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

LPTSTR
DecodeStatus(
    IN ULONG Status,
    TCHAR *ErrorMsg,
    IN ULONG StringSize
    );


void
LogProc();

ULONG 
ahextoi(
    IN TCHAR *s
    );
    
void 
StringToGuid(
    TCHAR *str, 
    LPGUID guid
);

ULONG  MaxEvents = MAXEVENTS;
ULONG  gnMultiReg = 1;

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void StringToGuid(
    TCHAR *str, 
    LPGUID guid
)
/*++

Routine Description:

    Converts a String into a GUID.

Arguments:

    str - String representing a GUID.
    guid - Pointer to a GUID for ourput

Return Value:

    None.

--*/
{
    TCHAR temp[10];
    int i, n;

    _tcsncpy(temp, str, 8);
    temp[8] = 0;
    guid->Data1 = ahextoi(temp);
    _tcsncpy(temp, &str[9], 4);
    temp[4] = 0;
    guid->Data2 = (USHORT) ahextoi(temp);
    _tcsncpy(temp, &str[14], 4);
    temp[4] = 0;
    guid->Data3 = (USHORT) ahextoi(temp);

    for (i=0; i<2; i++) {
        _tcsncpy(temp, &str[19 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
    for (i=2; i<8; i++) {
        _tcsncpy(temp, &str[20 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
}

__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    main() routine.

Arguments:

    Usage: TraceDp [options] [number of events]
                -UseEventTraceHeader        this is default.
                -UseEventInstanceHeader
                -UseMofPtrFlag
                -Thread [n]                 Sets the number of event-generating threads.
                -GuidPtr                    Use GUID pointer instead of GUID itself.
                -MofPtr                     Use MOF pointer for additional data.
                -GuidPtrMofPtr              User GUID pointer and MOF pointer.
                -InCorrectMofPtr            Use incorrect MOF pointer (Creates an error case).
                -NullMofPtr                 Use NULL MOF pointer (Creates an error case).
                -MultiReg                   Register multiple event GUIDS.
                -Sleep [n]                  Sets the sleep time before unregistering.
                [number of events] default is 5000

Return Value:

        Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    ULONG Status;
    LPGUID  Guid = NULL;
    DWORD ThreadId;
    HANDLE hThreadVector[MAXTHREADS];
    ULONG i;
    ULONG nThreads = 1;
    LPTSTR *targv, *utargv = NULL;

    MaxEvents = MAXEVENTS;
    TraceOnFlag = FALSE;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL)
    {
        return(GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    // process command line arguments to override defaults
    //
    while (--argc > 0)
    {
        targv ++;
        if (**targv == '-' || **targv == '/')
        {
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0],_T("-UseEventTraceHeader")))
            {
                EventType = TYPE_USER_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseEventInstanceHeader")))
            {
                EventType = TYPE_INSTANCE_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseMofPtrFlag")))
            {
                EventType = TYPE_MOF_EVENT;
            }
// end_sdk
            else if (!_tcsicmp(targv[0],_T("-Persist")))
            {
                bPersistData = TRUE;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0],_T("-Thread")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nThreads = _ttoi(targv[0]);
                    if (nThreads > MAXTHREADS) 
                        nThreads = MAXTHREADS;
                }
            }
             else if (!_tcsicmp(targv[0],_T("-GuidPtr")))
            {
                bUseGuidPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-MofPtr")))
            {
                bUseMofPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-GuidPtrMofPtr")))
            {
                bUseGuidPtr = TRUE;
                bUseMofPtr  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-InCorrectMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bIncorrect  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-NullMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bUseNullPtr = TRUE;
                bIncorrect  = TRUE;;
            }
            else if (!_tcsicmp(targv[0],_T("-MultiReg")))
            {
                gnMultiReg = 2;
            }
            else if (!_tcsicmp(targv[0], _T("-Guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], &ControlGuid[0]);
                        ++targv; --argc;
                    }
                }
            }
            else if (!_tcsicmp(targv[0],_T("-Sleep")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nSleepTime = _ttoi(targv[0]);
                }
            }
            else
            {
                printf("Usage: TraceDp [options] [number of events]\n");
                printf("\t-UseEventTraceHeader      this is default.\n");
                printf("\t-UseEventInstanceHeader\n");
                printf("\t-UseMofPtrFlag\n");
                printf("\t-Thread [n]\n");
                printf("\t-GuidPtr\n");
                printf("\t-MofPtr\n");
                printf("\t-GuidPtrMofPtr\n");
                printf("\t-InCorrectMofPtr\n");
                printf("\t-NullMofPtr\n");
                printf("\t-MultiReg\n");
                printf("\t-Guid #[guid]             alternative control GUID\n");
                printf("\t-Sleep [n]\n");
                printf("\t[number of events]        default is 5000\n");

                return 0;
            }
        }
        else if (** targv >= '0' && ** targv <= '9')
        {
            MaxEvents = _ttoi(targv[0]);
        }
    }

    if (utargv != NULL) {
        GlobalFree(utargv);
    }

    Status = InitializeTrace();
    if (Status != ERROR_SUCCESS) {
       return Status;
    }

    _tprintf(_T("Testing Logger with %d events (%d,%d)\n"),
            MaxEvents, EventType, bPersistData);

    while (! TraceOnFlag)
        _sleep(1000);

    for (i=0; i < nThreads; i++) {
        hThreadVector[i] = CreateThread(NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) LogProc,
                    NULL,
                    0,
                    (LPDWORD)&ThreadId);
    }

    WaitForMultipleObjects(nThreads, hThreadVector, TRUE, INFINITE);

    if (nSleepTime > 0) {
        _sleep(nSleepTime * 1000);
    }

    for (i=0; i<gnMultiReg; i++)  {
        UnregisterTraceGuids(RegistrationHandle[i]);
    }

    return ERROR_SUCCESS;
}

LPTSTR
DecodeStatus(
    IN ULONG Status,
    IN OUT TCHAR *ErrorMsg,
    IN ULONG StringSize
)
/*++

Routine Description:

    Decodes error status.

Arguments:

    Status - Return status of function calls to be decoded.

Return Value:

    Pointer to a decoded error message.

--*/
{
    RtlZeroMemory(ErrorMsg, (StringSize * sizeof(TCHAR)));
    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            Status,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) ErrorMsg,
            StringSize,
            NULL );
    return ErrorMsg;
}

ULONG InitializeTrace(
    void
)
/*++

Routine Description:

    Register traces.

Arguments:

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG i, j;

    if (!GetModuleFileName(NULL, ImagePath, MAXSTR)) {
        return (ERROR_FILE_NOT_FOUND);
    }

    for (i=0; i<gnMultiReg; i++) {

        Status = RegisterTraceGuids(
                    (WMIDPREQUEST)ControlCallback,   //use same callback function
                    (PVOID)(INT_PTR)(0x12345678+i),  // RequestContext
                    (LPCGUID)&ControlGuid[i],
                    1,
                    &TraceGuidReg[i],
                    (LPCTSTR)&ImagePath[0],
                    (LPCTSTR)ResourceName,
                    &RegistrationHandle[i]
                 );

        if (Status != ERROR_SUCCESS) {
            TCHAR ErrorMsg[MAXSTR];

            _tprintf(_T("Trace registration failed\n"));
            if( i > 0) {
                for (j=0; j<i; j++) {
                    UnregisterTraceGuids(RegistrationHandle[j]);
                }
            }
            _tprintf(_T("InitializeTrace failed. i=%d, status=%d, %s\n"), i, Status, DecodeStatus(Status, ErrorMsg, MAXSTR));
            return(Status);
        }
        else {
            _tprintf(_T("Trace registered successfully\n"));
        }
    }

    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
)
/*++

Routine Description:

    Callback function when enabled.

Arguments:

    RequestCode - Flag for either enable or disable.
    Context - User-defined context.
    InOutBufferSize - not used.
    Buffer - WNODE_HEADER for the logger session.

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d)\n"),
                    LoggerHandle, RequestCode, EnableLevel, EnableFlags);
            TraceOnFlag = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = FALSE;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}

void
LogProc()
/*++

Routine Description:

    Generates events. It is spawned as separate threads.
    Based on the options given by users, it generates different events.

Arguments:

Return Value:

    None.

--*/
{
    USER_EVENT          UserEvent;
    USER_INSTANCE_EVENT UserInstanceEvent;
    USER_MOF_EVENT      UserMofEvent;
    EVENT_INSTANCE_INFO InstInfo;
    PMOF_FIELD          mofField;
    ULONG i;
    PWNODE_HEADER Wnode;
    ULONG status;
    ULONG  InstanceId;
    LPGUID Guid = NULL;
    ULONG nTemp;
    USHORT nSize, nStrEventSize;
    WCHAR wstrTemp[MAXSTR];

    INTEGER_SAMPLE_EVENT ise;
    FLOAT_SAMPLE_EVENT fse;
    ARRAY_SAMPLE_EVENT ase;
    CHAR *sse, *ptr;

    // some arbitrary data for MOF structs
    ise.sc = 'x';
    ise.uc = 'y';
    ise.sh = (SHORT)rand();
    ise.ul = (ULONG)rand();

    nTemp = 0;
    while (nTemp == 0) {
        nTemp = rand();
    }

    fse.fl = ((float)rand() / (float)nTemp);
    fse.db = ((double)rand() / (double)nTemp);

    ase.ca[0] = 'M';
    ase.ca[1] = 'i';
    ase.ca[2] = 'c';
    ase.ca[3] = 'r';
    ase.ca[4] = 'o';
    ase.ca[5] = 's';
    ase.ca[6] = 'o';
    ase.ca[7] = 'f';
    ase.ca[8] = 't';

    nStrEventSize = ((wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR)) + sizeof(SHORT) + (wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    sse = (PCHAR) malloc(nStrEventSize);

    if (NULL != sse) {
        ptr = sse;
        wcscpy(wstrTemp, WIDE_DATA_STRING);
        wstrTemp[wcslen(WIDE_DATA_STRING)] = L'\0';
        memcpy(ptr, wstrTemp, (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR));
        ptr += (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR);
        nSize = (USHORT)(wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
        memcpy(ptr, &nSize, sizeof(USHORT));
        ptr += sizeof(USHORT);
        wcscpy(wstrTemp, COUNTED_DATA_STRING);
        memcpy(ptr, wstrTemp, wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    }

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    Wnode = (PWNODE_HEADER) &UserEvent;
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserEvent.Header.Guid  =  TransactionGuid;
    if (bPersistData)
        UserEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;

    RtlZeroMemory(&UserInstanceEvent, sizeof(UserInstanceEvent));
    UserInstanceEvent.Header.Size  = sizeof(UserInstanceEvent);
    UserInstanceEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    if (bPersistData)
        UserInstanceEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));
    Wnode = (PWNODE_HEADER) &UserMofEvent;
    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
// end_sdk
    if (bPersistData)
        UserMofEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;
// begin_sdk
    if (bUseGuidPtr) {
        UserEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
        UserMofEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserMofEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
    }

    i = 0;
    while (TraceOnFlag) {
        if ((i % 4) == 0) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 3;
        }
        else if ((i % 4) == 1) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 4;
        }
        else if ((i % 4) == 2) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 5;
        }
        else {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 6;
        }

        switch (EventType)
        {
        case TYPE_INSTANCE_EVENT:
            if (UserInstanceEvent.Header.Class.Type == EVENT_TRACE_TYPE_START) {
                status = CreateTraceInstanceId(
                                (PVOID) TraceGuidReg[0].RegHandle,
                                & InstInfo);

                if (status != ERROR_SUCCESS) {
                    TCHAR ErrorMsg[MAXSTR];
                    fprintf(stderr, 
                             "CreatTraceInstanceId() status=%d, %ws\n",
                              status, DecodeStatus(status, ErrorMsg, MAXSTR)
                             );
                    return; 
                }
            }
            status = TraceEventInstance(
                        LoggerHandle, 
                        (PEVENT_INSTANCE_HEADER) & UserInstanceEvent,
                        & InstInfo,
                        NULL);
            break;

        case TYPE_USER_EVENT:
            UserEvent.EventInfo = InterlockedIncrement(&EventCount);
            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserEvent);
            break;

        case TYPE_MOF_EVENT:
            UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
            mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
            if (UserMofEvent.Header.Class.Type == 4) {
                mofField->DataPtr = (ULONGLONG) (&ise);
                mofField->Length  = sizeof(INTEGER_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 5) {
                mofField->DataPtr = (ULONGLONG) (&fse);
                mofField->Length  = sizeof(FLOAT_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 6) {
                mofField->DataPtr = (ULONGLONG) (&ase);
                mofField->Length  = sizeof(ARRAY_SAMPLE_EVENT);
            }
            else {
                mofField->DataPtr = (ULONGLONG) (sse);
                mofField->Length  = nStrEventSize;
            }
            if (bUseNullPtr)
                mofField->DataPtr = (ULONGLONG) (NULL);
            if (bIncorrect)
                mofField->Length  += 1000;

            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserMofEvent);
            if (status != ERROR_SUCCESS) {
                fprintf(stderr, "Error(%d) while writing event.\n", status);
            }
            break;

        default:
            status = ERROR_SUCCESS;
            break;
        }

        // logger buffers out of memory should not prevent provider from
        // generating events. This will only cause events lost.
        //
        if (status == ERROR_NOT_ENOUGH_MEMORY) {
            status = ERROR_SUCCESS;
        }

        if (status != ERROR_SUCCESS) {
            TCHAR ErrorMsg[MAXSTR];
            _ftprintf(stderr, _T("\nError %s while writing event\n"),
                      DecodeStatus(status, ErrorMsg, MAXSTR));
            _ftprintf( stderr, _T("Logging terminated due to error\n"));
            free(sse);
            return;
        }

        i++;
        if (i >= MaxEvents)
            break;

        if (!(i % 100))
            _tprintf(_T("."));
        _sleep(1);
    }

    free(sse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\samples\tracekmp\tracekmp.c ===
#include <stdio.h>
#include <stdlib.h>
#include <ntddk.h>
#include <wmistr.h>
#include <evntrace.h>
#include <wmikm.h>

#define TRACEKMP_NT_DEVICE_NAME     L"\\Device\\TraceKmp"
#define TRACEKMP_MOF_FILE   L"MofResourceName"

PDEVICE_OBJECT pTracekmpDeviceObject;
UNICODE_STRING KmpRegistryPath;


typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT DeviceObject;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// ETW Globals 
// 

// 1. A control guid to identify this driver to ETW. The enable/disable state
//    of this Guid controls enable/disable state of tracing for this driver. 
GUID ControlGuid = \
{0xce5b1120, 0x8ea9, 0x11d1, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};

// 2. EventGuids to fire events with. Can have more than one EventGuid. 
GUID TracekmpGuid  = \
{0xbc8700cb, 0x120b, 0x4aad, 0xbf, 0xbf, 0x99, 0x6e, 0x57, 0x60, 0xcb, 0x85};

// 3. EtwLoggerHandle to use with IoWMIWriteEvent. 
TRACEHANDLE EtwLoggerHandle = 0;

// 4. EtwTraceEnable to indicate whether or not tracing is currently on. 
ULONG EtwTraceEnable = 0;

// 5. EtwTraceLevel  to indicate the current Level of logging
ULONG EtwTraceLevel = 0;

// Note: EtwLoggerHandle, EtwTraceEnable and EtwTraceLevel are set through 
//       ENABLE_EVENTS irp.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
EtwDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    );

NTSTATUS
EtwRegisterGuids(
    IN  PWMIREGINFO WmiRegInfo,
    IN  ULONG wmiRegInfoSize,
    IN  PULONG pReturnSize
    );

VOID
TracekmpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, EtwDispatch )
#pragma alloc_text( PAGE, EtwRegisterGuids )
#pragma alloc_text( PAGE, TracekmpDriverUnload )
#endif // ALLOC_PRAGMA



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    WMI Driver Object.  In this function, we need to remember the
    DriverObject.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
               to driver-specific key in the registry

Return Value:

   STATUS_SUCCESS if successful
   STATUS_UNSUCCESSFUL  otherwise

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING deviceName;

    KmpRegistryPath.Length = 0;
    KmpRegistryPath.MaximumLength = RegistryPath->Length;
    KmpRegistryPath.Buffer = ExAllocatePool(PagedPool,
                                                RegistryPath->Length+2);
    RtlCopyUnicodeString(&KmpRegistryPath, RegistryPath);


    DriverObject->DriverUnload = TracekmpDriverUnload;

    //
    // STEP 1. Wire a function to start fielding WMI IRPS
    //

    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = EtwDispatch;

    RtlInitUnicodeString( &deviceName, TRACEKMP_NT_DEVICE_NAME );

    status = IoCreateDevice(
                DriverObject,
                sizeof( DEVICE_EXTENSION ),
                &deviceName,
                FILE_DEVICE_UNKNOWN,
                0,
                FALSE,
                &pTracekmpDeviceObject);

    if( !NT_SUCCESS( status )) {
        return status;
    }
    pTracekmpDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // STEP 2. Register with ETW here
    //

    status = IoWMIRegistrationControl(pTracekmpDeviceObject, 
                                      WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status))
    {
        KdPrint((
            "TRACEKMP: IoWMIRegistrationControl failed with %x\n",
             status
            ));
    }


    return STATUS_SUCCESS;
}

VOID
TracekmpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unregister from ETW logging  and Unload this driver

Arguments:

    DriverObject - Supplies a pointer to the driver object

Return Value:

--*/
{
    PDEVICE_OBJECT pDevObj;
    NTSTATUS status;

    ExFreePool(KmpRegistryPath.Buffer);

    pDevObj = DriverObject->DeviceObject;
    
    //
    // STEP 3: Unregister with ETW.
    //
    if (pDevObj != NULL) {
        status = IoWMIRegistrationControl(pDevObj, WMIREG_ACTION_DEREGISTER);
        if (!NT_SUCCESS(status))
        {
            KdPrint((
                "TracekmpDriverUnload: Failed to unregister for ETW support\n"
                ));
        }
    }
    
    IoDeleteDevice( pDevObj );

}

//
// STEP 4: Wire the ETW Dispatch function. 
//

NTSTATUS
EtwDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for MJ_SYSTEM_CONTROL irps.


Arguments:

    pDO - Pointer to the target device object.
    Irp - Pointer to IRP

Return Value:

    NTSTATUS - Completion status.
--*/
{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID Buffer = irpSp->Parameters.WMI.Buffer;
    ULONG ReturnSize = 0;
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDO);


    switch (irpSp->MinorFunction) {

        case IRP_MN_REGINFO:
        {
            status = EtwRegisterGuids( (PWMIREGINFO) Buffer,
                                     BufferSize,
                                     &ReturnSize);
            Irp->IoStatus.Information = ReturnSize;
            Irp->IoStatus.Status = status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_ENABLE_EVENTS:
        {
            if ( (BufferSize < sizeof(WNODE_HEADER)) || (Buffer == NULL) ) {
                status = STATUS_INVALID_PARAMETER;
            }
            else {
                //
                // The Buffer that came is a WNODE_HEADER. Now Validate the
                // Wnode before using it. 
                //

                PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
                if ( (Wnode->BufferSize < sizeof(WNODE_HEADER)) ||
                     !IsEqualGUID(&Wnode->Guid, &ControlGuid) )
                {
                    status = STATUS_INVALID_PARAMETER;
                } 
                     
                //
                //  and the LoggerHandle
                // is in its HistoricalContext field. 
                // We can pick up the Enable Level and Flags by using 
                // the WmiGetLoggerEnableLevel and WmiGetLoggerEnableFlags calls
                //

                EtwLoggerHandle = Wnode->HistoricalContext;
                EtwTraceLevel = (ULONG) WmiGetLoggerEnableLevel( 
                                                                EtwLoggerHandle 
                                                               );

                //
                // After picking up the LoggerHandle and EnableLevel we can 
                // set the flag EtwTraceEnable to true. 
                // 

                EtwTraceEnable = TRUE;

                //
                // Now this driver is enabled and ready to send traces to the 
                // EventTrace session specified by the EtwLoggerHandle. 
                //
                // The commented code fragment below shows a typical example of 
                // sending an event to an Event Trace session. Insert this code
                // fragment (and remove the comments) wherever you want to 
                // send traces to ETW from this driver. 
                //

//              if (EtwTraceEnable) {
//                  EVENT_TRACE_HEADER Header;
//                  PEVENT_TRACE_HEADER Wnode;
//                  NTSTATUS status;
//                  Wnode = &Header;
//                  RtlZeroMemory(Wnode, sizeof(EVENT_TRACE_HEADER));
//                  Wnode->Size = sizeof(EVENT_TRACE_HEADER);
//                  Wnode->Flags |= WNODE_FLAG_TRACED_GUID;
//                  Wnode->Guid = TracekmpGuid;
//                  ((PWNODE_HEADER)Wnode)->HistoricalContext = EtwLoggerHandle;
//                  status = IoWMIWriteEvent((PVOID)Wnode);
//              }

                // STEP 6: Add IoWMIWriteEvent calls from various locations
                // of the driver code to trace its operation. 
                //
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_DISABLE_EVENTS:
        {
            EtwTraceEnable  = FALSE;
            EtwTraceLevel   = 0;
            EtwLoggerHandle = 0;

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;
        }
    }
    return status;
}


//
// STEP 5: RegisterGuids function
//


NTSTATUS
EtwRegisterGuids(
    IN PWMIREGINFO  EtwRegInfo,
    IN ULONG        etwRegInfoSize,
    IN PULONG       pReturnSize
    )
/*++

Routine Description:

    This function handles ETW GUID registration.


Arguments:

    EtwRegInfo
    etwRegInfoSize,
    pReturnSize


Return Value:

    NTSTATUS - Completion status.
--*/
{
    //
    // Register a Control Guid as a Trace Guid.
    //

    ULONG           SizeNeeded;
    PWMIREGGUIDW    EtwRegGuidPtr;
    ULONG           RegistryPathSize;
    ULONG           MofResourceSize;
    PUCHAR          ptmp;

    //
    // We either have a valid buffer to fill up or have at least
    // enough room to return the SizeNeeded. 
    //

    if ( (pReturnSize == NULL) || 
         (EtwRegInfo == NULL)  ||
         (etwRegInfoSize < sizeof(ULONG)) ) {
        return STATUS_INVALID_PARAMETER;
    }


    *pReturnSize = 0;

    //
    // Allocate WMIREGINFO for controlGuid 
    //
    RegistryPathSize = KmpRegistryPath.Length +
                       sizeof(USHORT);
    MofResourceSize =  sizeof(TRACEKMP_MOF_FILE) - 
                       sizeof(WCHAR) + 
                       sizeof(USHORT);

    SizeNeeded = sizeof(WMIREGINFOW) + sizeof(WMIREGGUIDW) +
                 RegistryPathSize +
                 MofResourceSize;

    //
    // If there is not sufficient space, return the size required as
    // a ULONG and WMI will send another request with the right size buffer.
    //

    if (SizeNeeded  > etwRegInfoSize) {
        *((PULONG)EtwRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlZeroMemory(EtwRegInfo, SizeNeeded);
    EtwRegInfo->BufferSize = SizeNeeded;
    EtwRegInfo->GuidCount = 1;
    EtwRegInfo->RegistryPath = sizeof(WMIREGINFOW) + sizeof(WMIREGGUIDW);
    EtwRegInfo->MofResourceName = EtwRegInfo->RegistryPath + RegistryPathSize;

    EtwRegGuidPtr = &EtwRegInfo->WmiRegGuid[0];
    EtwRegGuidPtr->Guid = ControlGuid;
    EtwRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    EtwRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    EtwRegGuidPtr->InstanceCount = 0;
    EtwRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&EtwRegInfo->WmiRegGuid[1];
    *((PUSHORT)ptmp) = KmpRegistryPath.Length;
    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp,
                  KmpRegistryPath.Buffer,
                  KmpRegistryPath.Length);

    ptmp = (PUCHAR)EtwRegInfo + EtwRegInfo->MofResourceName;
    *((PUSHORT)ptmp) = sizeof(TRACEKMP_MOF_FILE) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp,
                  TRACEKMP_MOF_FILE,
                  sizeof(TRACEKMP_MOF_FILE) - sizeof(WCHAR)
                 );

    *pReturnSize =  SizeNeeded;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\sdksamples\tracedmp\tracewmi.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracewmi.cpp

Abstract:

    Sample trace consumer helper routines. The functions in this file will fetch 
    event layout data given the GUID, version, and level.

    Functions in this file deals with WMI to retrieve the event layout information.
    GetMofInfoHead() and RemoveMofInfo() are the only two exported APIs from 
    this file. GetMofInfoHead() returns MOF_INFO structure to the caller.

    For each GUID, search takes place once. Once found, the information will be 
    placed as MOF_INFO in a global list (EventListHead). This list is searched 
    first before WMI is attempted to avoid repetitive WMI access.

--*/
#include "tracedmp.h"

extern
void
GuidToString(
    PTCHAR s,
    LPGUID piid
);

// cached Wbem pointer
IWbemServices *pWbemServices = NULL;

// Global head for event layout linked list 
extern PLIST_ENTRY EventListHead;

PMOF_INFO
GetMofInfoHead(
    GUID Guid,
    SHORT  nType,
    SHORT nVersion,
    CHAR  nLevel
);

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
);

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
);

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
);

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);
 
PMOF_INFO
GetGuids( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);

PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
);

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
);

PMOF_INFO
GetMofInfoHead(
    GUID    Guid,
    SHORT   nType,
    SHORT   nVersion,
    CHAR    nLevel
    )
/*++

Routine Description:

    Find a matching event layout in the global linked list. If it
    is not found in the list, it calls GetGuids() to examine the WBEM
    namespace.
    If the global list is empty, it first creates a header.

Arguments:

    Guid - GUID for the event under consideration.
    nType - Event Type
    nVersion - Event Version
    nLevel - Event Level (not supported in this program)

Return Value:

    Pointer to MOF_INFO for the current event. If the layout
    information is not found anywhere, GetMofInfoHead() creates
    a dummy and returns it.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PMOF_INFO pBestMatch = NULL;
    SHORT nMatchLevel = 0;
    SHORT nMatchCheck;

    // Search the eventList for this Guid and find the head

    if (EventListHead == NULL) {
        // Initialize the MOF List and add the global header guid to it
        EventListHead = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
        if (EventListHead == NULL)
            return NULL;
        InitializeListHead(EventListHead);

        pMofInfo = GetNewMofInfo( EventTraceGuid, EVENT_TYPE_DEFAULT, 0, 0 );
        if( pMofInfo != NULL ){
            InsertTailList( EventListHead, &pMofInfo->Entry );
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_EVENTTRACE)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_EVENTTRACE );
            }
            pMofInfo->strType = (LPTSTR)malloc((_tcslen(GUID_TYPE_HEADER)+1)*sizeof(TCHAR));
            if( pMofInfo->strType != NULL ){
                _tcscpy( pMofInfo->strType, GUID_TYPE_HEADER );
            }
        }
    }

    // Traverse the list and look for the Mof info head for this Guid. 

    Head = EventListHead;
    Next = Head->Flink;

    while (Head != Next) {

        nMatchCheck = 0;

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        if( IsEqualGUID(&pMofInfo->Guid, &Guid) ){

            if( pMofInfo->TypeIndex == nType ){
                nMatchCheck++;
            }
            if( pMofInfo->Version == nVersion ){
                nMatchCheck++;
            }
            if( nMatchCheck == 2 ){ // Exact Match
                return  pMofInfo;
            }

            if( nMatchCheck > nMatchLevel ){ // Close Match
                nMatchLevel = nMatchCheck;
                pBestMatch = pMofInfo;
            }

            if( pMofInfo->TypeIndex == EVENT_TYPE_DEFAULT && // Total Guess
                pBestMatch == NULL ){
                pBestMatch = pMofInfo;
            }
        }

    } 

    if(pBestMatch != NULL){
        return pBestMatch;
    }

    // If one does not exist in the list, look it up in the file. 
    pMofInfo = GetGuids( Guid, nVersion, nLevel, nType );
    
    // If still not found, create a unknown place holder
    if( NULL == pMofInfo ){
        pMofInfo = GetNewMofInfo( Guid, nType, nVersion, nLevel );
        if( pMofInfo != NULL ){
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_UNKNOWN)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_UNKNOWN );
            }
            InsertTailList( EventListHead, &pMofInfo->Entry );
        }
    }

    return pMofInfo;
}

void
AddMofInfo(
        PLIST_ENTRY List,
        LPTSTR  strType,
        ITEM_TYPE  nType,
        UINT   ArraySize
)
/*++

Routine Description:

    Creates a data item information struct (ITEM_DESC) and appends
    it to all MOF_INFOs in the given list.
    GetPropertiesFromWBEM() creates a list of MOF_INFOs for multiple
    types, stores them in a temporary list and calls this function for
    each data item information it encounters.

Arguments:

    List - List of MOF_INFOs.
    strType - Item description in string.
    nType - ITEM_TYPE defined at the beginning of this file.
    ArraySize - Size of array of this type of items, if applicable.

Return Value:

    None.

--*/
{
    PITEM_DESC pItem;
    PMOF_INFO pMofInfo;

    PLIST_ENTRY Head = List;
    PLIST_ENTRY Next = Head->Flink;
    while (Head != Next) {
        
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;

        if( NULL != pMofInfo ){

            pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
            if( NULL == pItem ){
                return;
            }
            ZeroMemory( pItem, sizeof(ITEM_DESC) );            
            pItem->ItemType = nType;
            pItem->ArraySize = ArraySize;

            pItem->strDescription = (LPTSTR) malloc( (_tcslen(strType)+1)*sizeof(TCHAR));
            
            if( NULL == pItem->strDescription ){
                free( pItem );
                return;
            }
            _tcscpy(pItem->strDescription, strType);

            InsertTailList( (pMofInfo->ItemHeader), &pItem->Entry);
        }

    }
}


PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
)
/*++

Routine Description:

    Creates a new MOF_INFO with given data.

Arguments:

    guid - Event GUID.
    nType - Event type.
    nVersion - Event version.
    nLevel - Event level (not supported in this program).

Return Value:

    Pointer to the created MOF_INFO. NULL if malloc failed.

--*/
{
    PMOF_INFO pMofInfo;

    pMofInfo = (PMOF_INFO)malloc(sizeof(MOF_INFO));

    if( NULL == pMofInfo ){
        return NULL;
    }

    RtlZeroMemory(pMofInfo, sizeof(MOF_INFO));

    RtlCopyMemory(&pMofInfo->Guid, &guid, sizeof(GUID) );
    
    pMofInfo->ItemHeader = (PLIST_ENTRY)malloc(sizeof(LIST_ENTRY));
    
    if( NULL == pMofInfo->ItemHeader ){
        free( pMofInfo );
        return NULL;
    }

    InitializeListHead(pMofInfo->ItemHeader);
    
    pMofInfo->TypeIndex = nType;
    pMofInfo->Level = nLevel;
    pMofInfo->Version = nVersion;

    return pMofInfo;
}

void
FlushMofList( 
    PLIST_ENTRY ListHead
)
/*++

Routine Description:

    Flushes MOF_INFOs in a temporary list into the global list.

Arguments:

    ListHead - Pointer to the head of a temporary list.

Return Value:

    None.

--*/
{
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head = ListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        RemoveEntryList(&pMofInfo->Entry);
        InsertTailList( EventListHead, &pMofInfo->Entry);
    }
}

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
)
/*++

Routine Description:

    Connects to WBEM and returns a pointer to WbemServices.

Arguments:

    pWbemServices - Pointer to the connected WbemServices.

Return Value:

    ERROR_SUCCESS if successful. Error flag otherwise.

--*/
{
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = SysAllocString( L"root\\wmi" );

    HRESULT hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = CoSetProxyBlanket(
            *pWbemServices,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );

cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release(); 
        pLocator = NULL;
    }
    
    return hr;
}

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set and returns the array size.

    NOTE: WBEM stores the size of an array in "MAX" qualifier.

Arguments:

    pQualSet - Pointer to a qualifier set.

Return Value:

    The size of the array. The default is 1.

--*/
{
    ULONG ArraySize = 1;
    VARIANT pVal;
    BSTR bszMaxLen;
    HRESULT hRes;

    if (pQualSet == NULL){
        return ArraySize;
    }

    bszMaxLen = SysAllocString(L"MAX");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszMaxLen,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszMaxLen);
    if (ERROR_SUCCESS == hRes && pVal.vt == VT_I4 ){
        ArraySize = pVal.lVal;
    }
    VariantClear(&pVal);
    return ArraySize;
}

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set for a property and returns the type.

Arguments:

    CimType - WBEM type (different from ITEM_TYPE) of a property.
    pQualSet - Pointer to a qualifier set for a property under consideration.

Return Value:

    The type (in ITEM_TYPE) of a property.

--*/
{
    ITEM_TYPE Type;
    VARIANT pVal;
    HRESULT hRes;
    BSTR bszQualName;
    WCHAR strFormat[10];
    WCHAR strTermination[30];
    WCHAR strTemp[30];
    BOOLEAN IsPointer = FALSE;

    strFormat[0] = '\0';
    strTermination[0] = '\0';
    strTemp[0] = '\0';

    if (pQualSet == NULL)
        return ItemUnknown;

    bszQualName = SysAllocString(L"format");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strFormat, pVal.bstrVal);

    bszQualName = SysAllocString(L"StringTermination");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTermination, pVal.bstrVal);

    bszQualName = SysAllocString(L"pointer");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    // Major fix required to get rid of temp
    bszQualName = SysAllocString(L"extension");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTemp, pVal.bstrVal);

    VariantClear(&pVal);

    CimType = (CIMTYPE_ENUMERATION)(CimType & (~CIM_FLAG_ARRAY));

    switch (CimType) {
        case CIM_EMPTY:
            Type = ItemUnknown;
            break;        
        case CIM_SINT8:
            Type = ItemCharShort;
            if (!_wcsicmp(strFormat, L"c")){
                Type = ItemChar;
            }
            break;
        case CIM_UINT8:
            Type = ItemUChar;
            break;
        case CIM_SINT16:
            Type = ItemShort;
            break;
        case CIM_UINT16:
            Type = ItemUShort;
            break;
        case CIM_SINT32:
            Type = ItemLong;
            break;
        case CIM_UINT32:
            Type = ItemULong;
            if (!_wcsicmp(strFormat, L"x")){
                Type = ItemULongX;
            }
            break;
        case CIM_SINT64: 
            Type = ItemLongLong;
            break;
        case CIM_UINT64:
            Type = ItemULongLong;
            break;
        case CIM_REAL32:
            Type = ItemFloat;
            break;
        case CIM_REAL64:
            Type = ItemDouble;
            break;
        case CIM_BOOLEAN:
            // ItemBool
            Type = ItemBool;
            break;
        case CIM_STRING:
            
            if (!_wcsicmp(strTermination, L"NullTerminated")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemWString;
                else
                    Type = ItemString;
            }
            else if (!_wcsicmp(strTermination, L"Counted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemPWString;
                else
                    Type = ItemPString;
            }
            else if (!_wcsicmp(strTermination, L"ReverseCounted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemDSWString;
                else
                    Type = ItemDSString;
            }
            else if (!_wcsicmp(strTermination, L"NotCounted")) {
                Type = ItemNWString;
            }else{
                Type = ItemString;
            }
            break;
        case CIM_CHAR16:
            // ItemWChar
            Type = ItemWChar;
            break;

        case CIM_OBJECT :
            if (!_wcsicmp(strTemp, L"Port"))
                Type = ItemPort;
            else if (!_wcsicmp(strTemp, L"IPAddr"))
                Type = ItemIPAddr;
            else if (!_wcsicmp(strTemp, L"Sid"))
                Type = ItemSid;
            else if (!_wcsicmp(strTemp, L"Guid"))
                Type = ItemGuid;
            break;

        case CIM_DATETIME:
        case CIM_REFERENCE:
        case CIM_ILLEGAL:
        default:
            Type = ItemUnknown;
            break;
    }

    if (IsPointer)
        Type = ItemPtr;
    return Type;
}

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
)
/*++

Routine Description:

    Constructs a linked list with the information read from the WBEM
    namespace, given the WBEM pointer to the version subtree. It enumerates
    through all type classes in WBEM, and constructs MOF_INFOs for all of
    them (for caching purpose). Meanwhile, it looks for the event layout
    that mathces the passed event, and returns the pointer to the matching 
    MOF_INFO at the end. 

Arguments:

    pTraceSubClasses - WBEM pointer to the version subtree.
    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    Pointer to MOF_INFO corresponding to the passed event.
    If the right type is not found, it returns the pointer to
    the generic MOF_INFO for the event version.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubSubClasses = NULL; 
    IWbemQualifierSet       *pQualSet = NULL;

    PMOF_INFO pMofInfo = NULL, pMofLookup = NULL, pMofTemplate = NULL;

    BSTR bszClassName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszWmiDataId = NULL;
    BSTR bszEventType = NULL; 
    BSTR bszEventTypeName = NULL; 
    BSTR bszFriendlyName = NULL;
    BSTR bszPropName = NULL;

    TCHAR strClassName[MAXSTR];
    TCHAR strType[MAXSTR];
#ifndef UNICODE
    CHAR TempString[MAXSTR];
#endif
    LONG pVarType;
    SHORT nEventType = EVENT_TYPE_DEFAULT; 

    LIST_ENTRY ListHead;
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pTypeVal;
    VARIANT pTypeNameVal;
    VARIANT pClassName;
    ULONG lEventTypeWbem;
    ULONG HUGEP *pTypeData;
    BSTR HUGEP *pTypeNameData;

    SAFEARRAY *PropArray = NULL;
    SAFEARRAY *TypeArray = NULL;
    SAFEARRAY *TypeNameArray = NULL;

    long lLower, lUpper, lCount, IdIndex;
    long lTypeLower, lTypeUpper;
    long lTypeNameLower, lTypeNameUpper;

    ULONG ArraySize;

    ITEM_TYPE ItemType;

    InitializeListHead(&ListHead);

    VariantInit(&pVal);
    VariantInit(&pTypeVal);
    VariantInit(&pTypeNameVal);
    VariantInit(&pClassName);

    bszClassName = SysAllocString(L"__CLASS");
    bszWmiDataId = SysAllocString(L"WmiDataId");
    bszEventType = SysAllocString(L"EventType");
    bszEventTypeName = SysAllocString(L"EventTypeName");
    bszFriendlyName = SysAllocString(L"DisplayName");

    hRes = pTraceSubClasses->Get(bszClassName,          // property name 
                                        0L, 
                                        &pVal,          // output to this variant 
                                        NULL, 
                                        NULL);

    if (ERROR_SUCCESS == hRes){
        if (pQualSet) {
            pQualSet->Release();
            pQualSet = NULL;
        }
        // Get Qualifier Set to obtain the friendly name.
        pTraceSubClasses->GetQualifierSet(&pQualSet);
        hRes = pQualSet->Get(bszFriendlyName, 
                                0, 
                                &pClassName, 
                                0);
        if (ERROR_SUCCESS == hRes && pClassName.bstrVal != NULL) {
#ifdef UNICODE
            wcscpy(strClassName, pClassName.bstrVal);
#else
            WideCharToMultiByte(CP_ACP,
                                0,
                                pClassName.bstrVal,
                                wcslen(pClassName.bstrVal),
                                TempString,
                                (MAXSTR * sizeof(CHAR)),
                                NULL,
                                NULL
                                );
            strcpy(strClassName, TempString);
            strClassName[wcslen(pClassName.bstrVal)] = '\0';
#endif
        }
        else {
#ifdef UNICODE
            strClassName[0] = L'\0';
#else
            strClassName[0] = '\0';
#endif
        }
        // Put Event Header
        pMofInfo = GetNewMofInfo(Guid,
                                    EVENT_TYPE_DEFAULT,
                                    EVENT_VERSION_DEFAULT,
                                    EVENT_LEVEL_DEFAULT
                                    );
        if (pMofInfo != NULL) {
            pMofTemplate = pMofInfo;
            pMofLookup = pMofInfo;
            InsertTailList(&ListHead, &pMofInfo->Entry);
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(strClassName) + 1) * sizeof(TCHAR));
            if (NULL != pMofInfo->strDescription) {
                _tcscpy(pMofInfo->strDescription, strClassName);
            }
        }
        else{
            goto cleanup;
        }

        // Create an enumerator to find derived classes.
        bszSubClassName = SysAllocString(pVal.bstrVal);
        hRes = pWbemServices->CreateClassEnum ( 
                                    bszSubClassName,                                                // class name
                                    WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,           // shallow search
                                    NULL,
                                    &pEnumTraceSubSubClasses
                                    );
        SysFreeString ( bszSubClassName );
        if (ERROR_SUCCESS == hRes) {
            ULONG uReturnedSub = 1;

            while(uReturnedSub == 1){
                // For each event in the subclass
                pTraceSubSubClasses = NULL;
                hRes = pEnumTraceSubSubClasses->Next(5000,                  // timeout in five seconds
                                                    1,                      // return just one instance
                                                    &pTraceSubSubClasses,   // pointer to a Sub class
                                                    &uReturnedSub);         // number obtained: one 
                if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                    if (pQualSet) {
                        pQualSet->Release();
                        pQualSet = NULL;
                    }
                    // Get Qualifier Set.
                    pTraceSubSubClasses->GetQualifierSet(&pQualSet);
                    // Get Type number among Qualifiers
                    VariantClear(&pTypeVal);
                    hRes = pQualSet->Get(bszEventType, 
                                            0, 
                                            &pTypeVal, 
                                            0);

                    if (ERROR_SUCCESS == hRes) {
                        TypeArray = NULL;
                        TypeNameArray = NULL;
                        if (pTypeVal.vt & VT_ARRAY) {   // EventType is an array
                            TypeArray = pTypeVal.parray;
                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if ((ERROR_SUCCESS == hRes) && (pTypeNameVal.vt & VT_ARRAY)) {
                                TypeNameArray = pTypeNameVal.parray;
                            }
                            if (TypeArray != NULL) {
                                hRes = SafeArrayGetLBound(TypeArray, 1, &lTypeLower);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = SafeArrayGetUBound(TypeArray, 1, &lTypeUpper);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                if (lTypeUpper < 0) {
                                    break;
                                }
                                SafeArrayAccessData(TypeArray, (void HUGEP **)&pTypeData );

                                if (TypeNameArray != NULL) {
                                    hRes = SafeArrayGetLBound(TypeNameArray, 1, &lTypeNameLower);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    hRes = SafeArrayGetUBound(TypeNameArray, 1, &lTypeNameUpper);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    if (lTypeNameUpper < 0) 
                                        break;
                                    SafeArrayAccessData(TypeNameArray, (void HUGEP **)&pTypeNameData );
                                }

                                for (lCount = lTypeLower; lCount <= lTypeUpper; lCount++) { 
                                    lEventTypeWbem = pTypeData[lCount];
                                    nEventType = (SHORT)lEventTypeWbem;
                                    pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                                    if (pMofInfo != NULL) {
                                        InsertTailList(&ListHead, &pMofInfo->Entry);
                                        if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                            if (pMofInfo->strDescription != NULL) {
                                                _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                            }
                                        }
                                        if (nType == nEventType) {
                                            // Type matched
                                            pMofLookup = pMofInfo;
                                        }
                                        if (TypeNameArray != NULL) {
                                            if ((lCount >= lTypeNameLower) && (lCount <= lTypeNameUpper)) {
                                                pMofInfo->strType = (LPTSTR)malloc((wcslen((LPWSTR)pTypeNameData[lCount]) + 1) * sizeof(TCHAR));
                                                if (pMofInfo->strType != NULL){
#ifdef UNICODE
                                                    wcscpy(pMofInfo->strType, (LPWSTR)(pTypeNameData[lCount]));
#else
                                                    WideCharToMultiByte(CP_ACP,
                                                                        0,
                                                                        (LPWSTR)(pTypeNameData[lCount]),
                                                                        wcslen((LPWSTR)(pTypeNameData[lCount])),
                                                                        TempString,
                                                                        (MAXSTR * sizeof(CHAR)),
                                                                        NULL,
                                                                        NULL
                                                                        );
                                                    TempString[wcslen((LPWSTR)(pTypeNameData[lCount]))] = '\0';
                                                    strcpy(pMofInfo->strType, TempString);
#endif
                                                }
                                            }
                                        }
                                    }
                                }
                                SafeArrayUnaccessData(TypeArray);  
                                SafeArrayDestroy(TypeArray);
                                VariantInit(&pTypeVal);
                                if (TypeNameArray != NULL) {
                                    SafeArrayUnaccessData(TypeNameArray);
                                    SafeArrayDestroy(TypeNameArray);
                                    VariantInit(&pTypeNameVal);
                                }
                            }
                            else {
                                // If the Types are not found, then bail
                                break;
                            }
                        }
                        else {                          // EventType is scalar
                            hRes = VariantChangeType(&pTypeVal, &pTypeVal, 0, VT_I2);
                            if (ERROR_SUCCESS == hRes)
                                nEventType = (SHORT)V_I2(&pTypeVal);
                            else
                                nEventType = (SHORT)V_I4(&pTypeVal);

                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if (ERROR_SUCCESS == hRes) {
#ifdef UNICODE
                                wcscpy(strType, pTypeNameVal.bstrVal);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    pTypeNameVal.bstrVal,
                                                    wcslen(pTypeNameVal.bstrVal),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                strcpy(strType, TempString);
                                strType[wcslen(pTypeNameVal.bstrVal)] = '\0';
#endif
                            }
                            else{
#ifdef UNICODE
                                strType[0] = L'\0';
#else
                                strType[0] = '\0';
#endif
                            }

                            pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                            if (pMofInfo != NULL) {
                                InsertTailList(&ListHead, &pMofInfo->Entry);
                                if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                    pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                    if (pMofInfo->strDescription != NULL) {
                                        _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                    }
                                }
                                if (nType == nEventType) {
                                    // Type matched
                                    pMofLookup = pMofInfo;
                                }
                                pMofInfo->strType = (LPTSTR)malloc((_tcslen(strType) + 1) * sizeof(TCHAR));
                                if (pMofInfo->strType != NULL){
                                    _tcscpy(pMofInfo->strType, strType);
                                }
                            }
                        }

                        // Get event layout
                        VariantClear(&pVal);
                        IdIndex = 1;
                        V_VT(&pVal) = VT_I4;
                        V_I4(&pVal) = IdIndex; 
                        // For each property
                        PropArray = NULL;
                        while (pTraceSubSubClasses->GetNames(bszWmiDataId,                  // only properties with WmiDataId qualifier
                                                            WBEM_FLAG_ONLY_IF_IDENTICAL,
                                                            &pVal,                          // WmiDataId number starting from 1
                                                            &PropArray) == WBEM_NO_ERROR) {

                            hRes = SafeArrayGetLBound(PropArray, 1, &lLower);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            hRes = SafeArrayGetUBound(PropArray, 1, &lUpper);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            if (lUpper < 0) 
                                break;
                            // This loop will iterate just once.
                            for (lCount = lLower; lCount <= lUpper; lCount++) { 
                                hRes = SafeArrayGetElement(PropArray, &lCount, &bszPropName);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = pTraceSubSubClasses->Get(bszPropName,    // Property name
                                                                0L,
                                                                NULL,
                                                                &pVarType,      // CIMTYPE of the property
                                                                NULL);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }

                                // Get the Qualifier set for the property
                                if (pQualSet) {
                                    pQualSet->Release();
                                    pQualSet = NULL;
                                }
                                hRes = pTraceSubSubClasses->GetPropertyQualifierSet(bszPropName,
                                                                        &pQualSet);

                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                
                                ItemType = GetItemType((CIMTYPE_ENUMERATION)pVarType, pQualSet);
                                
                                if( pVarType & CIM_FLAG_ARRAY ){
                                    ArraySize = GetArraySize(pQualSet);
                                }else{
                                    ArraySize = 1;
                                }
#ifdef UNICODE
                                AddMofInfo(&ListHead, 
                                            bszPropName, 
                                            ItemType, 
                                            ArraySize);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    bszPropName,
                                                    wcslen(bszPropName),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                TempString[wcslen(bszPropName)] = '\0';
                                AddMofInfo(&ListHead,
                                            TempString,
                                            ItemType, 
                                            ArraySize);
#endif
                            }
                            SafeArrayDestroy(PropArray);
                            PropArray = NULL;
                            V_I4(&pVal) = ++IdIndex;
                        }   // end enumerating through WmiDataId
                        FlushMofList(&ListHead);
                    }   // if getting event type was successful
                }   // if enumeration returned a subclass successfully
            }   // end enumerating subclasses
        }   // if enumeration was created successfully
    }   // if getting class name was successful
cleanup:
    VariantClear(&pVal);
    VariantClear(&pTypeVal);
    VariantClear(&pClassName);

    SysFreeString(bszClassName);
    SysFreeString(bszWmiDataId);
    SysFreeString(bszEventType);
    SysFreeString(bszEventTypeName);
    SysFreeString(bszFriendlyName);
    // Should not free bszPropName becuase it is already freed by SafeArrayDestroy

    FlushMofList(&ListHead);

    return pMofLookup;
}

PMOF_INFO
GetGuids (GUID Guid, 
        SHORT nVersion, 
        CHAR nLevel, 
        SHORT nType 
        )
/*++

Routine Description:

    Aceesses the MOF data information from WBEM, creates a linked list, 
    and returns a pointer that matches the passed event.
    This function finds the right subtree within the WBEM namespace,
    and calls GetPropertiesFromWBEM() to create the list.

Arguments:

    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    PMOF_INFO to MOF_INFO structure that matches the passed event.
    NULL if no match is found.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubClasses = NULL, *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubClasses = NULL, *pTraceSubSubClasses = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    BSTR bszInstance = NULL;
    BSTR bszPropertyName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszGuid = NULL;
    BSTR bszVersion = NULL;

    WCHAR strGuid[MAXSTR], strTargetGuid[MAXSTR];
    
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pGuidVal;
    VARIANT pVersionVal;

    UINT nCounter=0;
    BOOLEAN MatchFound;
    SHORT nEventVersion = EVENT_VERSION_DEFAULT;

    PMOF_INFO pMofLookup = NULL;

    VariantInit(&pVal);
    VariantInit(&pGuidVal);
    VariantInit(&pVersionVal);
    
    if (NULL == pWbemServices) {
        hRes = WbemConnect( &pWbemServices );
        if ( ERROR_SUCCESS != hRes ) {
            goto cleanup;
        }
    }

    // Convert traget GUID to string for later comparison
#ifdef UNICODE
    GuidToString(strTargetGuid, &Guid);
#else
    CHAR TempString[MAXSTR];
    GuidToString(TempString, &Guid);
    MultiByteToWideChar(CP_ACP, 0, TempString, -1, strTargetGuid, MAXSTR);
#endif

    bszInstance = SysAllocString(L"EventTrace");
    bszPropertyName = SysAllocString(L"__CLASS");
    bszGuid = SysAllocString(L"Guid");
    bszVersion = SysAllocString(L"EventVersion");
    pEnumTraceSubClasses = NULL;

    // Get an enumerator for all classes under "EventTace".
    hRes = pWbemServices->CreateClassEnum ( 
                bszInstance,
                WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumTraceSubClasses );
    SysFreeString (bszInstance);

    if (ERROR_SUCCESS == hRes) {
        ULONG uReturned = 1;
        MatchFound = FALSE;
        while (uReturned == 1) {
            pTraceSubClasses = NULL;
            // Get the next ClassObject.
            hRes = pEnumTraceSubClasses->Next(5000,             // timeout in five seconds
                                            1,                  // return just one instance
                                            &pTraceSubClasses,  // pointer to Event Trace Sub Class
                                            &uReturned);        // number obtained: one or zero
            if (ERROR_SUCCESS == hRes && (uReturned == 1)) {
                // Get the class name
                hRes = pTraceSubClasses->Get(bszPropertyName,   // property name 
                                                0L, 
                                                &pVal,          // output to this variant 
                                                NULL, 
                                                NULL);
                if (ERROR_SUCCESS == hRes){
                    bszSubClassName = SysAllocString(pVal.bstrVal);
                    // Create an enumerator to find derived classes.
                    hRes = pWbemServices->CreateClassEnum ( 
                                            bszSubClassName,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                            NULL,
                                            &pEnumTraceSubSubClasses 
                                            );
                    SysFreeString ( bszSubClassName );
                    bszSubClassName = NULL;
                    VariantClear(&pVal);

                    if (ERROR_SUCCESS == hRes) {
                                    
                        ULONG uReturnedSub = 1;
                        while(uReturnedSub == 1){

                            pTraceSubSubClasses = NULL;
                            // enumerate through the resultset.
                            hRes = pEnumTraceSubSubClasses->Next(5000,              // timeout in five seconds
                                                            1,                      // return just one instance
                                                            &pTraceSubSubClasses,   // pointer to a Sub class
                                                            &uReturnedSub);         // number obtained: one or zero
                            if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                                // Get the subclass name            
                                hRes = pTraceSubSubClasses->Get(bszPropertyName,    // Class name 
                                                                0L, 
                                                                &pVal,              // output to this variant 
                                                                NULL, 
                                                                NULL);
                                VariantClear(&pVal);

                                if (ERROR_SUCCESS == hRes){
                                    // Get Qualifier Set.
                                    if (pQualSet) {
                                        pQualSet->Release();
                                        pQualSet = NULL;
                                    }
                                    pTraceSubSubClasses->GetQualifierSet (&pQualSet );

                                    // Get GUID among Qualifiers
                                    hRes = pQualSet->Get(bszGuid, 
                                                            0, 
                                                            &pGuidVal, 
                                                            0);
                                    if (ERROR_SUCCESS == hRes) {
                                        wcscpy(strGuid, (LPWSTR)V_BSTR(&pGuidVal));
                                        VariantClear ( &pGuidVal  );

                                        if (!wcsstr(strGuid, L"{"))
                                            swprintf(strGuid , L"{%s}", strGuid);

                                        if (!_wcsicmp(strTargetGuid, strGuid)) {
                                            hRes = pQualSet->Get(bszVersion, 
                                                                    0, 
                                                                    &pVersionVal, 
                                                                    0);
                                            if (ERROR_SUCCESS == hRes) {
                                                hRes = VariantChangeType(&pVersionVal, &pVersionVal, 0, VT_I2);
                                                if (ERROR_SUCCESS == hRes)
                                                    nEventVersion = (SHORT)V_I2(&pVersionVal);
                                                else
                                                    nEventVersion = (SHORT)V_I4(&pVersionVal);
                                                VariantClear(&pVersionVal);

                                                if (nVersion == nEventVersion) {
                                                    // Match is found. 
                                                    // Now put all events in this subtree into the list 
                                                    MatchFound = TRUE;
                                                    pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                        Guid,
                                                                                        nVersion,
                                                                                        nLevel,
                                                                                        nType
                                                                                        );
                                                    break;
                                                }
                                            }
                                            else {
                                                // if there is no version number for this event,
                                                // the current one is the only one
                                                // Now put all events in this subtree into the list 
                                                MatchFound = TRUE;
                                                pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                    Guid,
                                                                                    EVENT_VERSION_DEFAULT,
                                                                                    nLevel,
                                                                                    nType
                                                                                    );
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } // end while enumerating sub classes
                        if (MatchFound) {
                            break;
                        }
                        if (pEnumTraceSubSubClasses) {
                            pEnumTraceSubSubClasses->Release();
                            pEnumTraceSubSubClasses = NULL;
                        }
                    }   // if creating enumeration was successful
                    else {
                        pEnumTraceSubSubClasses = NULL;
                    }
                }   // if getting class name was successful
            }
            nCounter++;
            // if match is found, break out of the top level search
            if (MatchFound)
                break;
        }   // end while enumerating top classes
        if( pEnumTraceSubClasses ){
            pEnumTraceSubClasses->Release();
            pEnumTraceSubClasses = NULL;
        }
    }   // if creating enumeration for top level is successful

cleanup:

    VariantClear(&pGuidVal);
    VariantClear(&pVersionVal);

    SysFreeString(bszGuid);
    SysFreeString(bszPropertyName);
    SysFreeString(bszVersion);

    if( pEnumTraceSubClasses ){
        pEnumTraceSubClasses->Release();
        pEnumTraceSubClasses = NULL;
    }
    if (pEnumTraceSubSubClasses){
        pEnumTraceSubSubClasses->Release();
        pEnumTraceSubSubClasses = NULL;
    }
    if (pQualSet) {
        pQualSet->Release();
        pQualSet = NULL;
    }

    return pMofLookup;
}

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
)
/*++

Routine Description:

    Removes and frees data item structs from a given list.

Arguments:

    pMofInfo - Pointer to the MOF_INFO to be purged of data item structs.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PITEM_DESC pItem;

    Head = pMofInfo;
    Next = Head->Flink;
    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList(&pItem->Entry);
        free(pItem);
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\sdksamples\tracedmp\tracedmp.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracedmp.cpp

Abstract:

    Sample trace consumer program. Converts binary Event Trace Log (ETL) to CSV format.

    Aside from various printing routines for dumping event data and writing summary, 
    three functions need mentioning. main() parses command line and calls OpenTrace(), 
    ProcessTrace(), and CloseTrace(). BufferCallback() is for BufferCallback and 
    simply counts the number of buffers processed. Finally, DumpEvent() is the 
    EventCallback function in this sample that writes event data into a dumpfile.

    Important Notes:

    Event Tracing API for trace consumption (OpenTrace, ProcessTrace, CloseTrace,...)
    are straightforward and easy to use. Hence, getting an event back is simple. 
    However, another important aspect of trace consumption is event decoding, which 
    requires event layout information. This information may be known in advance and 
    hard coded in an event consumer, but we rely on WMI name space for storing event 
    layout information. This requires extensive WMI interface just to get the layout.
    
    We placed all the routines needed for getting layout information in a separate 
    file (tracewmi.cpp). The only two functions exported from this file are 
    GetMofInfoHead() and RemoveMofInfo(). GetMofInfoHead() is the one that returns 
    MOF_INFO with the proper layout information. RemoveMofInfo() is used only for 
    cleaning up cached event list.

    We hope this helps readers understand two separate issues in this samples: 
    event tracing APIs and WMI interface. 

--*/
#include "tracedmp.h"

extern 
PMOF_INFO
GetMofInfoHead(
    GUID Guid,
    SHORT  nType,
    SHORT nVersion,
    CHAR  nLevel
);

extern
void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
);

// Simple check on a trace file. 
ULONG
CheckFile(
    LPTSTR fileName
);

// BufferCallback function.
ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

// EventCallback function in this sample.
void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
);

// Print functions
void 
PrintSummary();

void 
PrintDumpHeader();

void 
PrintEvent(
    PEVENT_TRACE pEvent,
    PMOF_INFO pMofInfo
    );

// Other helper functions.
void
GuidToString(
    PTCHAR s,
    LPGUID piid
);

void
PrintHelpMessage();

void
CleanupEventList(
    VOID
);

// output files
FILE* DumpFile = NULL;
FILE* SummaryFile = NULL;

static ULONG TotalBuffersRead = 0;
static ULONG TotalEventsLost = 0;
static ULONG TotalEventCount = 0;
static ULONG TimerResolution = 10;

static ULONGLONG StartTime   = 0;
static ULONGLONG EndTime     = 0;
static BOOL   fNoEndTime  = FALSE;
static __int64 ElapseTime;

// Option flags.
BOOLEAN fSummaryOnly  = FALSE;

// Sizeof of a pointer in a file may be different.
ULONG PointerSize = sizeof(PVOID) * 8;

// log files
PEVENT_TRACE_LOGFILE EvmFile[MAXLOGFILES];
ULONG LogFileCount = 0;

// IF the events are from a private logger, we need to make some adjustment.
BOOL bUserMode = FALSE;

// Global head for event layout linked list 
PLIST_ENTRY EventListHead = NULL;

int __cdecl main (int argc, LPTSTR* argv)
/*++

Routine Description:

    It is the main function.

Arguments:
Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]
        -o <file>          Output CSV file
        -rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]
        -summary           Summary.txt only
        -h
        -help
        -?                 Display usage information

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    TCHAR DumpFileName[MAXSTR];
    TCHAR SummaryFileName[MAXSTR];

    LPTSTR *targv;

#ifdef UNICODE
    LPTSTR *cmdargv;
#endif

    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG Status = ERROR_SUCCESS;
    ULONG i, j;
    TRACEHANDLE HandleArray[MAXLOGFILES];

#ifdef UNICODE
    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),  // pointer to a command-line string
                        &argc               // receives the argument count
                        )) == NULL)
    {
        return(GetLastError());
    };
    targv = cmdargv ;
#else
    targv = argv;
#endif

    _tcscpy(DumpFileName, DUMP_FILE_NAME);
    _tcscpy(SummaryFileName, SUMMARY_FILE_NAME);

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }

            if ( !_tcsicmp(targv[0], _T("-summary")) ) {
                fSummaryOnly = TRUE;
            }
            else if (targv[0][1] == 'h' || targv[0][1] == 'H'
                                       || targv[0][1] == '?')
            {
                PrintHelpMessage();
                return ERROR_SUCCESS;
            }
            else if ( !_tcsicmp(targv[0], _T("-rt")) ) {
                TCHAR LoggerName[MAXSTR];
                _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
                if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       _tcscpy(LoggerName, targv[0]);
                   }
                }
               
                pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
                if (pLogFile == NULL){
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
                EvmFile[LogFileCount] = pLogFile;
               
                EvmFile[LogFileCount]->LogFileName = NULL;
                EvmFile[LogFileCount]->LoggerName =
                    (LPTSTR) malloc(MAXSTR * sizeof(TCHAR));
               
                if (EvmFile[LogFileCount]->LoggerName == NULL) {
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                _tcscpy(EvmFile[LogFileCount]->LoggerName, LoggerName);
               
                _tprintf(_T("Setting RealTime mode for  %s\n"),
                        EvmFile[LogFileCount]->LoggerName);
               
                EvmFile[LogFileCount]->Context = NULL;
                EvmFile[LogFileCount]->BufferCallback = BufferCallback;
                EvmFile[LogFileCount]->BuffersRead = 0;
                EvmFile[LogFileCount]->CurrentTime = 0;
                EvmFile[LogFileCount]->EventCallback = &DumpEvent;
                EvmFile[LogFileCount]->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
                LogFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(DumpFileName, targv[0], MAXSTR);
                        _tsplitpath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("csv"));
                        _tmakepath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("txt"));  
                        _tmakepath( SummaryFileName, drive, path, file, ext );
                    }
                }
            }
        }
        else {
            pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            EvmFile[LogFileCount] = pLogFile;

            EvmFile[LogFileCount]->LoggerName = NULL;
            EvmFile[LogFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (EvmFile[LogFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            
            _tfullpath(EvmFile[LogFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     EvmFile[LogFileCount]->LogFileName);
            // If one of the log files is not readable, exit.
            if (!CheckFile(EvmFile[LogFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                Status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            EvmFile[LogFileCount]->Context = NULL;
            EvmFile[LogFileCount]->BufferCallback = BufferCallback;
            EvmFile[LogFileCount]->BuffersRead = 0;
            EvmFile[LogFileCount]->CurrentTime = 0;
            EvmFile[LogFileCount]->EventCallback = &DumpEvent;
            LogFileCount++;
        }
    }

    if (LogFileCount <= 0) {
        PrintHelpMessage();
        return Status;
    }

    // OpenTrace calls
    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;

        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            Status = GetLastError();
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, Status);

            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }

    // Open files.
    if (!fSummaryOnly)
    {
        DumpFile = _tfopen(DumpFileName, _T("w"));
        if (DumpFile == NULL) {
            Status = ERROR_INVALID_PARAMETER;
            _tprintf(_T("DumpFile is NULL\n"));
            goto cleanup;
        }
    }
    SummaryFile = _tfopen(SummaryFileName, _T("w"));
    if (SummaryFile == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        _tprintf(_T("SummaryFile is NULL\n"));
        goto cleanup;
    }

    if (!fSummaryOnly)
    {
        PrintDumpHeader();
    }

    // At this point, users can set a different trace callback function for 
    // a specific GUID using SetTraceCallback(). Also RemoveTraceCallback() allows
    // users to remove a callback function for a specific GUID. In this way, users
    // can customize callbacks based on GUIDs.

    // Actual processing takes place here. EventCallback function will be invoked
    // for each event.
    // We do not use start and end time parameters in this sample.
    Status = ProcessTrace(
            HandleArray,
            LogFileCount,
            NULL,
            NULL
            );

    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing with status=%dL (GetLastError=0x%x)\n"),
                Status, GetLastError());
    }

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, Status);
        }
    }

    // Write summary.
    PrintSummary();

cleanup:
    if (!fSummaryOnly && DumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), DumpFileName);
        fclose(DumpFile);
    }

    if(SummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), SummaryFileName);
        fclose(SummaryFile);
    }

    for (i = 0; i < LogFileCount; i ++)
    {
        if (EvmFile[i]->LoggerName != NULL)
        {
            free(EvmFile[i]->LoggerName);
            EvmFile[i]->LoggerName = NULL;
        }
        if (EvmFile[i]->LogFileName != NULL)
        {
            free(EvmFile[i]->LogFileName);
            EvmFile[i]->LogFileName = NULL;
        }
        free(EvmFile[i]);
    }
#ifdef UNICODE
    GlobalFree(cmdargv);
#endif

    SetLastError(Status);
    if(Status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), Status);
    }

    return Status;
}

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
/*++

Routine Description:

    Callback method for processing a buffer. Does not do anything but
    updating global counters.

Arguments:

    pLog - Pointer to a log file.

Return Value:

    Always TRUE.

--*/
{
    TotalBuffersRead++;
    return (TRUE);
}

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
)
/*++

Routine Description:

    Callback method for processing an event. It obtains the layout
    information by calling GetMofInfoHead(), which returns the pointer
    to the PMOF_INFO corresponding to the event type. Then it writes
    to the output file.

    NOTE: Only character arrays are supported in this program.

Arguments:

    pEvent - Pointer to an event.

Return Value:

    None.

--*/
{
    PEVENT_TRACE_HEADER pHeader;
    PMOF_INFO pMofInfo;

    TotalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("Warning: Null Event\n"));
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    // Extrace log file information if the event is a log file header.
    if( IsEqualGUID(&(pEvent->Header.Guid), &EventTraceGuid) && 
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if( NULL != head ){
            if(head->TimerResolution > 0){
                TimerResolution = head->TimerResolution / 10000;
            }
        
            StartTime  = head->StartTime.QuadPart;
            EndTime    = head->EndTime.QuadPart;
            // If ProcessTrace() call was made on areal time logger or an trace file being 
            // logged, EndTime amy be 0.
            fNoEndTime = (EndTime == 0);

            TotalEventsLost += head->EventsLost;

            // We use global flags for private logger and pointer size.
            // This may cause an error when trace files are from different environments.
            bUserMode = (head->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);

            // Set pointer size
            PointerSize =  head->PointerSize * 8;
            if (PointerSize != 64){   
                PointerSize = 32; 
            }
        }
    }

    // if EndTime is missing from one of the files, keep updating to get the largest value.
    if (fNoEndTime && EndTime < (ULONGLONG) pHeader->TimeStamp.QuadPart) {
        EndTime = pHeader->TimeStamp.QuadPart;
    }

    // Find the MOF information for this event. This will retrieve the layout
    // information from WMI fi we don't already have it in our list. 
    pMofInfo = GetMofInfoHead ( 
            pEvent->Header.Guid, 
            pEvent->Header.Class.Type, 
            pEvent->Header.Class.Version, 
            pEvent->Header.Class.Level 
        );
    
    if( NULL == pMofInfo ){
        // Could not locate event layout information.
        return;
    }

    pMofInfo->EventCount++;

    if( fSummaryOnly == TRUE ){
        return;
    }
    // At this point, pEvent and pMofInfo are not NULL. No need to check in PrintEvent(). 
    PrintEvent(pEvent, pMofInfo);

}

/***************************************************************************************
    Various printing and helper function after this point.
***************************************************************************************/

void PrintDumpHeader() 
/*++

Routine Description:

    Prints out column headers to a dump file.

Arguments:

    None

Return Value:

    None

--*/
{
    _ftprintf(DumpFile,
        _T("%12s, %10s,%7s,%21s,%11s,%11s, User Data\n"),
        _T("Event Name"), _T("Type"), _T("TID"), _T("Clock-Time"),
        _T("Kernel(ms)"), _T("User(ms)")
        );
}

void PrintSummary()
/*++

Routine Description:

    Prints out a event summary into a dump file while cleaning the event list.

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG i;

    _ftprintf(SummaryFile,_T("Files Processed:\n"));
    for (i = 0; i < LogFileCount; i++) {
        _ftprintf(SummaryFile, _T("\t%s\n"),EvmFile[i]->LogFileName);
    }

    ElapseTime = EndTime - StartTime;
    _ftprintf(SummaryFile,
              _T("Total Buffers Processed %d\n")
              _T("Total Events  Processed %d\n")
              _T("Total Events  Lost      %d\n")
              _T("Start Time              0x%016I64X\n")
              _T("End Time                0x%016I64X\n")
              _T("Elapsed Time            %I64d sec\n"), 
              TotalBuffersRead,
              TotalEventCount,
              TotalEventsLost,
              StartTime,
              EndTime,
              (ElapseTime / 10000000) );

    _ftprintf(SummaryFile,
       _T("+-------------------------------------------------------------------------------------+\n")
       _T("|%10s    %-20s %-10s  %-36s  |\n")
       _T("+-------------------------------------------------------------------------------------+\n"),
       _T("EventCount"),
       _T("EventName"),
       _T("EventType"),
       _T("Guid")
        );

    // Print event GUIDs while cleaning up.
    CleanupEventList();

    _ftprintf(SummaryFile,
        _T("+-------------------------------------------------------------------------------------+\n")
         );
}

void 
PrintEvent(
    PEVENT_TRACE pEvent,
    PMOF_INFO pMofInfo
    )
/*++

Routine Description:

    Dumps event data into a dump file.

Arguments:

    None

Return Value:

    None

--*/
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;
    ULONG   i;
    PITEM_DESC pItem;
    CHAR str[MOFSTR];
    WCHAR wstr[MOFWSTR];
    PCHAR ptr;
    ULONG ulongword;
    LONG  longword;
    USHORT ushortword;
    SHORT  shortword;
    CHAR iChar;
    WCHAR iwChar;
    ULONG MofDataUsed;
    PLIST_ENTRY Head, Next;

    // Print a general information on the event.
    if ( pMofInfo->strDescription != NULL ){
        _ftprintf( DumpFile, _T("%12s, "), pMofInfo->strDescription );
    }
    else {
        TCHAR strGuid[MAXSTR];
        GuidToString( strGuid, &pMofInfo->Guid );
        _ftprintf( DumpFile, _T("%12s, "), strGuid );
    }

    if (pMofInfo->strType != NULL && _tcslen(pMofInfo->strType) ){
        _ftprintf( DumpFile, _T("%10s, "), pMofInfo->strType );
    }
    else {
        _ftprintf( DumpFile, _T("%10d, "), pEvent->Header.Class.Type );
    }

    // Thread ID
    _ftprintf( DumpFile, _T("0x%04X, "), pHeader->ThreadId );
    
    // System Time
    _ftprintf( DumpFile, _T("%20I64u, "), pHeader->TimeStamp.QuadPart);

    if ( bUserMode == FALSE ){
        // Kernel Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->KernelTime * TimerResolution);

        // User Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->UserTime * TimerResolution);
    }
    else {
        // processor Time
        _ftprintf(DumpFile, _T("%I64u, "), pHeader->ProcessorTime);
    }

    if (NULL == pEvent->MofData && pEvent->MofLength != 0) {
        _tprintf(_T("Incorrect MOF size\n"));
        return;
    }

    Head = pMofInfo->ItemHeader;
    Next = Head->Flink;
    ptr = (PCHAR)(pEvent->MofData);

    // If we cannot locate layout information, just print the size.
    if ((Head == Next) && (pEvent->MofLength > 0)) {
         _ftprintf(DumpFile, _T("DataSize=%d, "), pEvent->MofLength);
    }

    // Print event-specific data.
    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;

        MofDataUsed = (ULONG) (ptr - (PCHAR)(pEvent->MofData));
        
        if (MofDataUsed >= pEvent->MofLength){
            break;
        }

        switch (pItem->ItemType)
        {
        case ItemChar:      // char 
        case ItemUChar:     // unsigned char
            for( i = 0; i < pItem->ArraySize; i++){
                iChar = *((PCHAR) ptr);
                _ftprintf(DumpFile,   _T("%c"), iChar);
                ptr += sizeof(CHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemWChar:     // wide char
            for(i = 0;i < pItem->ArraySize; i++){
                iwChar = *((PWCHAR) ptr);
                _ftprintf(DumpFile, _T(",%wc"), iwChar);
                ptr += sizeof(WCHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemCharShort: // char as a number
            iChar = *((PCHAR) ptr);
            _ftprintf(DumpFile, _T("%d, "), iChar);
            ptr += sizeof(CHAR);
            break;

        case ItemShort:     // short
            shortword = * ((PSHORT) ptr);
            _ftprintf(DumpFile, _T("%6d, "), shortword);
            ptr += sizeof (SHORT);
            break;

        case ItemUShort:    // unsigned short
            ushortword = *((PUSHORT) ptr);
            _ftprintf(DumpFile, _T("%6u, "), ushortword);
            ptr += sizeof (USHORT);
            break;

        case ItemLong:      // long
            longword = *((PLONG) ptr);
            _ftprintf(DumpFile, _T("%8d, "), longword);
            ptr += sizeof (LONG);
            break;

        case ItemULong:     // unsigned long
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("%8lu, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemULongX:    // unsinged long as hex
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemLongLong:
        {
            LONGLONG n64;   // longlong
            n64 = *((LONGLONG*) ptr);
            ptr += sizeof(LONGLONG);
            _ftprintf(DumpFile, _T("%16I64d, "), n64);
            break;
        }

        case ItemULongLong: // unsigned longlong
        {
            ULONGLONG n64;
            n64 = *((ULONGLONG*) ptr);
            ptr += sizeof(ULONGLONG);
            _ftprintf(DumpFile, _T("%16I64u, "), n64);
            break;
        }

        case ItemFloat:     // float
        {
            float f32;
            f32 = *((float*) ptr);
            ptr += sizeof(float);
            _ftprintf(DumpFile, _T("%f, "), f32);
            break;
        }

        case ItemDouble:    // double
        {
            double f64;
            f64 = *((double*) ptr);
            ptr += sizeof(double);
            _ftprintf(DumpFile, _T("%f, "), f64);
            break;
        }

        case ItemPtr :      // pointer
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                pointer = *((unsigned __int64 *) ptr);
                _ftprintf(DumpFile, _T("0x%X, "), pointer);
                ptr += 8;
            }
            else {      // assumes 32 bit otherwise
                ulongword = *((PULONG) ptr);
                _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
                ptr += 4;
            }
            break;
        }

        case ItemIPAddr:    // IP address
        {
            ulongword = *((PULONG) ptr);

            // Convert it to readable form
            _ftprintf(DumpFile, _T("%03d.%03d.%03d.%03d, "),
                    (ulongword >>  0) & 0xff,
                    (ulongword >>  8) & 0xff,
                    (ulongword >> 16) & 0xff,
                    (ulongword >> 24) & 0xff);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemPort:      // Port
        {
            _ftprintf(DumpFile, _T("%u, "), NTOHS(*((PUSHORT)ptr)));
            ptr += sizeof (USHORT);
            break;
        }

        case ItemString:    // NULL-terminated char string
        {
            USHORT pLen = (USHORT)strlen((CHAR*) ptr);

            if (pLen > 0)
            {
                strcpy(str, ptr);
                for (i = pLen-1; i > 0; i--) {
                    if (str[i] == 0xFF)
                        str[i] = 0;
                    else break;
                }
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemWString:   // NULL-terminated wide char string
        {
            size_t  pLen = 0;
            size_t     i;

            if (*(PWCHAR)ptr)
            {
                pLen = ((wcslen((PWCHAR)ptr) + 1) * sizeof(WCHAR));
                RtlCopyMemory(wstr, ptr, pLen);
                // Unused space in a buffer is filled with 0xFFFF. 
                // Replace them with 0, just in case.
                for (i = (pLen / 2) - 1; i > 0; i--)
                {
                    if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
                    {
                        wstr[i] = (USHORT) 0;
                    }
                    else break;
                }

                wstr[pLen / 2] = wstr[(pLen / 2) + 1]= '\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;

            break;
        }

        case ItemDSString:   // Counted String
        {
            USHORT pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed - 1)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed - 1);
            }
            if (pLen > 0)
            {
                strncpy(str, ptr, pLen);
                str[pLen] = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                fprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemPString:   // Counted String
        {
            USHORT pLen = * ((USHORT *) ptr);
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFSTR * sizeof(CHAR)) {
                pLen = MOFSTR * sizeof(CHAR);
            }
            if (pLen > 0) {
                RtlCopyMemory(str, ptr, pLen);
                str[pLen] = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += pLen;
            break;
        }

        case ItemDSWString:  // DS Counted Wide Strings
        case ItemPWString:   // Counted Wide Strings
        {
            USHORT pLen = (USHORT)(( pItem->ItemType == ItemDSWString)
                        ? (256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)))
                        : (* ((USHORT *) ptr)));

            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFWSTR * sizeof(WCHAR)) {
                pLen = MOFWSTR * sizeof(WCHAR);
            }
            if (pLen > 0) {
                RtlCopyMemory(wstr, ptr, pLen);
                wstr[pLen / sizeof(WCHAR)] = L'\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemNWString:   // Non Null Terminated String
        {
           USHORT Size;

           Size = (USHORT)(pEvent->MofLength - (ULONG)(ptr - (PCHAR)(pEvent->MofData)));
           if( Size > MOFSTR )
           {
               Size = MOFSTR;
           }
           if (Size > 0)
           {
               RtlCopyMemory(wstr, ptr, Size);
               wstr[Size / 2] = '\0';
               _ftprintf(DumpFile, _T("\"%ws\","), wstr);
           }
           ptr += Size;
           break;
        }

        case ItemMLString:  // Multi Line String
        {
            USHORT   pLen;
            char   * src, * dest;
            BOOL     inQ       = FALSE;
            BOOL     skip      = FALSE;
            UINT     lineCount = 0;

            ptr += sizeof(UCHAR) * 2;
            pLen = (USHORT)strlen(ptr);
            if (pLen > 0)
            {
                src = ptr;
                dest = str;
                while (* src != '\0'){
                    if (* src == '\n'){
                        if (!lineCount){
                            * dest++ = ' ';
                        }
                        lineCount++;
                    }else if (* src == '\"'){ 
                        if (inQ){
                            char   strCount[32];
                            char * cpy;

                            sprintf(strCount, "{%dx}", lineCount);
                            cpy = & strCount[0];
                            while (* cpy != '\0'){
                                * dest ++ = * cpy ++;
                            }
                        }
                        inQ = !inQ;
                    }else if (!skip){
                        *dest++ = *src;
                    }
                    skip = (lineCount > 1 && inQ);
                    src++;
                }
                *dest = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen);
            break;
        }

        case ItemSid:       // SID 
        {
            WCHAR        UserName[64];
            WCHAR        Domain[64];
            WCHAR        FullName[256];
            ULONG        asize = 0;
            ULONG        bsize = 0;
            ULONG        SidMarker;
            SID_NAME_USE Se;
            ULONG        nSidLength;

            RtlCopyMemory(&SidMarker, ptr, sizeof(ULONG));
            if (SidMarker == 0){
                ptr += 4;
                fwprintf(DumpFile,   L"0, ");
            }
            else
            {
                if (PointerSize == 64) {
                    ptr += 16;           // skip the TOKEN_USER structure
                }
                else {
                    ptr += 8;            // skip the TOKEN_USER structure
                }
                nSidLength = 8 + (4*ptr[1]);

                asize = 64;
                bsize = 64;
                if (LookupAccountSidW(
                                NULL,
                               (PSID) ptr,
                               (LPWSTR) & UserName[0],
                               & asize,
                               (LPWSTR) & Domain[0],
                               & bsize,
                               & Se))
                {
                    LPWSTR pFullName = &FullName[0];
                    swprintf(pFullName, L"\\\\%s\\%s", Domain, UserName);
                    asize = (ULONG)  lstrlenW(pFullName);
                    if (asize > 0){
                         fwprintf(DumpFile,   L"\"%s\", ", pFullName);
                    }
                }
                else
                {
                     fwprintf(DumpFile,   L"\"System\", " );
                }
                SetLastError( ERROR_SUCCESS );
                ptr += nSidLength;
            }
            break;
        }

        case ItemGuid:      // GUID
        {
            TCHAR s[64];
            GuidToString(s, (LPGUID)ptr);
            _ftprintf(DumpFile,   _T("%s, "), s);
            ptr += sizeof(GUID);
            break;
        }
        case ItemBool:      // boolean
        {
            BOOL Flag = (BOOL)*ptr;
            _ftprintf(DumpFile, _T("%5s, "), (Flag) ? _T("TRUE") : _T("FALSE"));
            ptr += sizeof(BOOL);
            break;
        }

        default:
            ptr += sizeof (int);
        }
    }

    //Instance ID
    _ftprintf(DumpFile, _T("%d,"), pEvent->InstanceId);

    //Parent Instance ID
    _ftprintf(DumpFile, _T("%d\n"), pEvent->ParentInstanceId);

}

ULONG
CheckFile(
    LPTSTR fileName
)
/*++

Routine Description:

    Checks whether a file exists and is readable.

Arguments:

    fileName - File name.

Return Value:

    Non-zero if the file exists and is readable. Zero otherwise.

--*/
{
    HANDLE hFile;
    ULONG Status;

    hFile = CreateFile(
                fileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    Status = (hFile != INVALID_HANDLE_VALUE);
    CloseHandle(hFile);
    return Status;
}

void
GuidToString(
    PTCHAR s,
    LPGUID piid
)
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - String that will have the converted GUID.
    piid - GUID

Return Value:

    None.

--*/
{
    _stprintf(s, _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return;
}

void 
PrintHelpMessage()
/*++

Routine Description:

    Prints out help messages.

Arguments:

    None

Return Value:

    None

--*/
{
    _tprintf(
        _T("Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]\n")
        _T("\t-o <file>          Output CSV file\n")
        _T("\t-rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]\n")
        _T("\t-summary           Summary.txt only\n")
        _T("\t-h\n")
        _T("\t-help\n")
        _T("\t-?                 Display usage information\n")
        _T("\n")
        _T("\tDefault output file is dumpfile.csv\n")
    );
}

void
CleanupEventList(
    VOID
)
/*++

Routine Description:

    Cleans up a global event list.

Arguments:

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    TCHAR s[256];
    TCHAR wstr[256];
    PTCHAR str;

    if (EventListHead == NULL) {
        return;
    }

    Head = EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        RtlZeroMemory(&wstr, 256);

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);

        if (pMofInfo->EventCount > 0) {
            GuidToString(&s[0], &pMofInfo->Guid);
            str = s;
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( wstr, pMofInfo->strDescription );
            }
            
            _ftprintf(SummaryFile,_T("|%10d    %-20s %-10s  %36s|\n"),
                      pMofInfo->EventCount, 
                      wstr, 
                      pMofInfo->strType ? pMofInfo->strType : GUID_TYPE_DEFAULT, 
                      str);
        }

        RemoveEntryList(&pMofInfo->Entry);
        RemoveMofInfo(pMofInfo->ItemHeader);
        free(pMofInfo->ItemHeader);

        if (pMofInfo->strDescription != NULL)
            free(pMofInfo->strDescription);
        if (pMofInfo->strType != NULL)
            free(pMofInfo->strType);

        Next = Next->Flink;
        free(pMofInfo);
    }

    free(EventListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\sdksamples\tracedp\tracedp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracedp.c

Abstract:

    Sample trace provider program.

--*/

#include <stdio.h> 
#include <stdlib.h>

#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>

#include <guiddef.h>
#include <evntrace.h>

#define DEFAULT_EVENTS                  5000
#define MAXSTR                          1024

TRACEHANDLE LoggerHandle;

// Control GUID for this provider.
GUID   ControlGuid  =
    {0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc};


// Only one transaction GUID will be registered for this provider.
GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};
// Array for transaction GUID registration.
TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

// User event layout: one ULONG.
typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    ULONG                 EventInfo;
} USER_EVENT, *PUSER_EVENT;

// Registration handle.
TRACEHANDLE RegistrationHandle;
// Trace on/off switch, level, and flag.
BOOLEAN TraceOnFlag;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;

// Number of events to be logged. The actual number can be less if disabled early. 
ULONG MaxEvents = DEFAULT_EVENTS;
// To keep track of events logged.
ULONG EventCount = 0;

// ControlCallback function for enable/disable.
ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

// Main work to be traced is done here.
void
DoWork();

__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    main() routine.

Arguments:

    Usage: TraceDp [number of events]
                [number of events] default is 5000

Return Value:

        Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    ULONG Status, i;
    LPTSTR *targv, *utargv = NULL;

    TraceOnFlag = FALSE;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL)
    {
        return (GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    // process command line arguments to override defaults
    if (argc == 2) {
        targv ++;
        if (**targv >= _T('0') && **targv <= _T('9')) {
            MaxEvents = _ttoi(targv[0]);
        }
        else if (!_tcsicmp(targv[0], _T("/?")) || !_tcsicmp(targv[0], _T("-?"))) {
            printf("Usage: TraceDp [number of events]\n");
            printf("\t[number of events]        default is 5000\n");

            return ERROR_SUCCESS;
        }
    }

    // Free temporary argument buffer.
    if (utargv != NULL) {
        GlobalFree(utargv);
    }

    // Event provider registration.
    Status = RegisterTraceGuids(
                (WMIDPREQUEST)ControlCallback,   // callback function
                0,
                &ControlGuid,
                1,
                TraceGuidReg,
                NULL,
                NULL,
                &RegistrationHandle
             );

    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Trace registration failed. Status=%d\n"), Status);
        return(Status);
    }
    else {
        _tprintf(_T("Trace registered successfully\n"));
    }

    _tprintf(_T("Testing Logger with %d events\n"),
            MaxEvents);

    // Sleep until enabled by a trace controller. In this sample, we wait to be
    // enabled for tracing. However, normal applications should continue and log
    // events when enabled later on.
    while (!TraceOnFlag) {
        _sleep(1000);
    }

    // Do the work while logging events. We trace two events (START and END) for
    // each call to DoWork.
    for (i = 0; i < MaxEvents / 2; i++) {
        DoWork();
    }

    // Unregister.
    UnregisterTraceGuids(RegistrationHandle);

    return ERROR_SUCCESS;
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
)
/*++

Routine Description:

    Callback function when enabled.

Arguments:

    RequestCode - Flag for either enable or disable.
    Context - User-defined context.
    InOutBufferSize - not used.
    Buffer - WNODE_HEADER for the logger session.

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d)\n"),
                    LoggerHandle, RequestCode, EnableLevel, EnableFlags);
            TraceOnFlag = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = FALSE;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}

void
DoWork()
/*++

Routine Description:

    Logs events. 

Arguments:

Return Value:

    None.

--*/
{
    USER_EVENT UserEvent;
    ULONG Status;

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserEvent.Header.Guid  = TransactionGuid;

    // Log START event to indicate a start of a routine or activity.
    // We log EventCount as data. 
    if (TraceOnFlag) {
        UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
        UserEvent.EventInfo = ++EventCount;
        Status = TraceEvent(
                        LoggerHandle,
                        (PEVENT_TRACE_HEADER) & UserEvent);
        if (Status != ERROR_SUCCESS) {
            // TraceEvent() failed. This could happen when the logger 
            // cannot keep up with too many events logged rapidly. 
            // In such cases, the return valid is 
            // ERROR_NOT_ENOUGH_MEMORY.
            _tprintf(_T("TraceEvent failed. Status=%d\n"), Status);
        }
    }

    //
    // Main body of the work in this routine comes here.
    // 
    _sleep(1);

    // Log END event to indicate an end of a routine or activity.
    // We log EventCount as data. 
    if (TraceOnFlag) {
        UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
        UserEvent.EventInfo = ++EventCount;
        Status = TraceEvent(
                        LoggerHandle,
                        (PEVENT_TRACE_HEADER) & UserEvent);
        if (Status != ERROR_SUCCESS) {
            // TraceEvent() failed. This could happen when the logger 
            // cannot keep up with too many events logged rapidly. 
            // In such cases, the return valid is 
            // ERROR_NOT_ENOUGH_MEMORY.
            _tprintf(_T("TraceEvent failed. Status=%d\n"), Status);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\sdksamples\tracedmp\tracedmp.h ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <wbemidl.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <objidl.h>

#define MAXLOGFILES         16
#define MAXSTR              1024
#define MOFWSTR             1024
#define MOFSTR              2048
#define MAXTYPE             256
#define UC(x)               ( (UINT)((x) & 0xFF) )
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )
// Maximum number of properties per WBEM class object: may need to be changed
#define MAXPROPS            256

#define DUMP_FILE_NAME          _T("DumpFile.csv")
#define SUMMARY_FILE_NAME       _T("Summary.txt")

#define DEFAULT_NAMESPACE       _T("root\\wmi")

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

// List mamangement macros
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

// Default strings and values.
#define GUID_TYPE_EVENTTRACE            _T("EventTrace")
#define GUID_TYPE_HEADER                _T("Header")
#define GUID_TYPE_UNKNOWN               _T("Unknown")
#define GUID_TYPE_DEFAULT               _T("Default")

#define EVENT_TYPE_DEFAULT              (-1)
#define EVENT_LEVEL_DEFAULT             (-1)
#define EVENT_VERSION_DEFAULT           (-1)

// Strings and enumeration for Data item types that we want to decode.
// Refer to DumpEvent() for more detail on each item.
#define STR_ItemChar                    _T("ItemChar")
#define STR_ItemWChar                   _T("ItemWChar")
#define STR_ItemUChar                   _T("ItemUChar")
#define STR_ItemCharShort               _T("ItemCharShort")
#define STR_ItemShort                   _T("ItemShort")
#define STR_ItemUShort                  _T("ItemUShort")
#define STR_ItemLong                    _T("ItemLong")
#define STR_ItemULong                   _T("ItemULong")
#define STR_ItemULongX                  _T("ItemULongX")
#define STR_ItemLongLong                _T("ItemLongLong")
#define STR_ItemULongLong               _T("ItemULongLong")
#define STR_ItemFloat                   _T("ItemFloat");
#define STR_ItemDouble                  _T("ItemDouble");
#define STR_ItemString                  _T("ItemString")
#define STR_ItemWString                 _T("ItemWString")
#define STR_ItemPString                 _T("ItemPString")
#define STR_ItemPWString                _T("ItemPWString")
#define STR_ItemDSString                _T("ItemDSString")
#define STR_ItemDSWString               _T("ItemDSWString")
#define STR_ItemMLString                _T("ItemMLString")
#define STR_ItemSid                     _T("ItemSid")
#define STR_ItemIPAddr                  _T("ItemIPAddr")
#define STR_ItemPort                    _T("ItemPort")
#define STR_ItemNWString                _T("ItemNWString")
#define STR_ItemPtr                     _T("ItemPtr")
#define STR_ItemGuid                    _T("ItemGuid")
#define STR_ItemBool                    _T("ItemBool")

typedef enum _ITEM_TYPE {
    ItemChar,
    ItemWChar,
    ItemUChar,
    ItemCharShort,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemFloat,
    ItemDouble,
    ItemString,
    ItemWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemIPAddr,
    ItemPort,
    ItemMLString,
    ItemNWString, 
    ItemPtr,
    ItemGuid,
    ItemBool,
    ItemUnknown
} ITEM_TYPE;

// Construct that represents an event layout.
typedef struct _MOF_INFO {
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;        // Class Name
    ULONG        EventCount;
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;
    LPTSTR       strType;               // Type Name
    SHORT        TypeIndex;
    SHORT        Version;
    CHAR         Level;
}  MOF_INFO, *PMOF_INFO;

// Construct that represents one data item.
typedef struct _ITEM_DESC {
    LIST_ENTRY  Entry;
    LPTSTR      strDescription;
    ULONG       DataSize;
    ITEM_TYPE   ItemType;
    UINT        ArraySize;
} ITEM_DESC, *PITEM_DESC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\sdksamples\tracelog\tracelog.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, update, query, stop 
    event tracing, etc.


--*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR                          1024
// Default trace file name.
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Etl")
// On Windows 2000, we support up to 32 loggers at once.
// On Windows XP and .NET server, we support up to 64 loggers. 
#define MAXIMUM_LOGGERS                  32

// In this sample, we support the following actions. 
// Additional actions that we do not use in this sample include 
// Flush and Enumerate Guids functionalities. They are supported
// only on XP or higher version.
#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST                     4
#define ACTION_ENABLE                   5
#define ACTION_HELP                     6

#define ACTION_UNDEFINED               10

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    );

ULONG 
ahextoi(
    IN TCHAR *s
    );

void 
StringToGuid(
    IN TCHAR *str,
    OUT LPGUID guid
    );

void 
PrintHelpMessage();


//
//  main function
//
__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    It is the main function.

Arguments:
  
Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).


--*/{
    ULONG i, j;
    ULONG Status = ERROR_SUCCESS;
    LPTSTR *targv, *utargv = NULL;
    // Action to be taken
    USHORT Action = ACTION_UNDEFINED;

    LPTSTR LoggerName;
    LPTSTR LogFileName;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    // Target GUID, level and flags for enable/disable
    GUID TargetGuid;
    ULONG bEnable = TRUE;

    ULONG SizeNeeded = 0;

    // We will enable Process, Thread, Disk, and Network events 
    // if the Kernel Logger is requested.
    BOOL bKernelLogger = FALSE;

    // Allocate and initialize EVENT_TRACE_PROPERTIES structure first
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        return (ERROR_OUTOFMEMORY);
    }
    
    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    // If the logger name is not given, we will assume the kernel logger.
    _tcscpy(LoggerName, KERNEL_LOGGER_NAME);

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL) {
        free(pLoggerInfo);
        return (GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    //
    // Parse the command line options to determine actions and parameters.
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if (targv[0][0] == '/' ) {
                targv[0][0] = '-';
            }

            // Deterine actions.
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-query"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-list"))) {
                Action  = ACTION_LIST;
            }
 
            // Get other parameters.
            // Users can customize logger settings further by adding/changing 
            // values to pLoggerInfo. Refer to EVENT_TRACE_PROPERTIES documentation
            // for available options.
            // In this sample, we allow changing maximum number of buffers and 
            // specifying user mode (private) logger.
            // We also take trace file name and guid for enable/disable.
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    _tfullpath(LogFileName, targv[1], MAXSTR);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    // -guid #00000000-0000-0000-0000-000000000000
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], &TargetGuid);
                        ++targv; --argc;
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){
                Action = ACTION_HELP;
                PrintHelpMessage();
                if (utargv != NULL) {
                    GlobalFree(utargv);
                }
                free(pLoggerInfo);

                return (ERROR_SUCCESS);
            }
            else Action = ACTION_UNDEFINED;
        }
        else { 
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            Status = ERROR_INVALID_PARAMETER;
            SetLastError(Status);
            if (utargv != NULL) {
                GlobalFree(utargv);
            }
            free(pLoggerInfo);

            return (Status);
        }
    }

    // Set the kernel logger parameters.
    if (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME)) {
        // Set enable flags. Users can add options to add additional kernel events 
        // or remove some of these events.
        pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_PROCESS;
        pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_THREAD;
        pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_DISK_IO;
        pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;

        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid; 
        bKernelLogger = TRUE;
    }
    else if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        // We must provide a control GUID for a private logger. 
        pLoggerInfo->Wnode.Guid = TargetGuid;
    }

    // Process the request.
    switch (Action) {
        case  ACTION_START:
        {
            // Use default file name if not given
            if (_tcslen(LogFileName) == 0) {
                _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); 
            }

            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n"),
                         LoggerName,
                         Status);

                break;
            }
            _tprintf(_T("Logger Started...\n"));
        }
        case ACTION_ENABLE:
        {
            // We can allow enabling a GUID during START operation (Note no break in case ACTION_START). 
            // In that case, we do not need to get LoggerHandle separately.
            if (Action == ACTION_ENABLE ){
                
                // Get Logger Handle though Query.
                Status = ControlTrace((TRACEHANDLE) 0, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                if( Status != ERROR_SUCCESS ){
                    _tprintf( _T("ERROR: Logger not started\n")
                              _T("Operation Status:    %uL\n"),
                              Status);
                    break;
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            // We do not allow EnableTrace on the Kernel Logger in this sample,
            // users can use EnableFlags to enable/disable certain kernel events.
            if (!bKernelLogger) {
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                // In this sample, we use EnableFlag = EnableLebel = 0
                Status = EnableTrace (
                                bEnable,
                                0,
                                0,
                                &TargetGuid, 
                                LoggerHandle);

                if (Status != ERROR_SUCCESS) {
                    _tprintf(_T("ERROR: Failed to enable Guid...\n"));
                    _tprintf(_T("Operation Status:       %uL\n"), Status);
                    break;
                }
            }
            break;
        }
        case ACTION_STOP :
        {
            LoggerHandle = (TRACEHANDLE) 0;
            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_STOP);
            break;
        }
        case ACTION_LIST :
        {
            ULONG returnCount;
            PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
            PEVENT_TRACE_PROPERTIES pStorage, pTempStorage;
            ULONG SizeForOneProperty = sizeof(EVENT_TRACE_PROPERTIES) +
                                       2 * MAXSTR * sizeof(TCHAR);

            // We need to prepare space to receieve the inforamtion on loggers.
            SizeNeeded = MAXIMUM_LOGGERS * SizeForOneProperty;

            pStorage =  (PEVENT_TRACE_PROPERTIES)malloc(SizeNeeded);
            if (pStorage == NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(pStorage, SizeNeeded);
            // Save the pointer for free() later.
            pTempStorage = pStorage;

            for (i = 0; i < MAXIMUM_LOGGERS; i++) {
                pStorage->Wnode.BufferSize = SizeForOneProperty;
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                        + MAXSTR * sizeof(TCHAR);
                pLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                 (PUCHAR)pStorage + 
                                  pStorage->Wnode.BufferSize);
            }
        
            Status = QueryAllTraces(pLoggerInfo,
                                MAXIMUM_LOGGERS,
                                &returnCount);
    
            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    PrintLoggerStatus(pLoggerInfo[j], 
                                        Status);
                    _tprintf(_T("\n"));
                }
            }

            free(pTempStorage);
            break;
        }

        case ACTION_UPDATE :
        {
            // In this sample, users can only update MaximumBuffers and log file name. 
            // User can add more options for other parameters as needed.
            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_UPDATE);
            break;
        }
        case ACTION_QUERY  :
        {
            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
            break;
        }
        case ACTION_HELP:
        {
            PrintHelpMessage();
            break;
        }
        default :
        {
            _tprintf(_T("Error: no action specified\n"));
            PrintHelpMessage();
            break;
        }
    }
    
    if ((Action != ACTION_HELP) && 
        (Action != ACTION_UNDEFINED) && 
        (Action != ACTION_LIST)) {
        PrintLoggerStatus(pLoggerInfo,
                            Status);
    }

    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
    }
    if (utargv != NULL) {
        GlobalFree(utargv);
    }
    free(pLoggerInfo);

    return (Status);
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    )
/*++

Routine Description:

    Prints out the status of the specified logger.

Arguments:

    LoggerInfo - The pointer to the resident EVENT_TRACE_PROPERTIES that has
        the information about the current logger.
    Status - The operation status of the current logger.

Return Value:

    None

--*/
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((PUCHAR)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((PUCHAR)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;

    _tprintf(_T("Operation Status:       %uL\n"), Status);
    
    _tprintf(_T("Logger Name:            %s\n"),
            (LoggerName == NULL) ?
            _T(" ") : LoggerName);
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %d\n"), LoggerInfo->LoggerThreadId);

    if (Status != 0)
        return;

    _tprintf(_T("Buffer Size:            %d Kb"), LoggerInfo->BufferSize);
    if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
        _tprintf(_T(" using paged memory\n"));
    }
    else {
        _tprintf(_T("\n"));
    }
    _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
    _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
    _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
    _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

    if (LogFileName == NULL) {
        _tprintf(_T("Buffering Mode:         "));
    }
    else {
        _tprintf(_T("Log File Mode:          "));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
        _tprintf(_T("Append  "));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _tprintf(_T("Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _tprintf(_T("Sequential\n"));
    }
    else {
        _tprintf(_T("Sequential\n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _tprintf(_T("Real Time mode enabled"));
        _tprintf(_T("\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

    if (LoggerInfo->EnableFlags != 0) {
        _tprintf(_T("Enabled tracing:        "));

        if ((LoggerName != NULL) && (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME))) {

            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                _tprintf(_T("Process "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                _tprintf(_T("Thread "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                _tprintf(_T("Disk "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                _tprintf(_T("File "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                _tprintf(_T("PageFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                _tprintf(_T("HardFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                _tprintf(_T("ImageLoad "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                _tprintf(_T("TcpIp "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                _tprintf(_T("Registry "));
        }else{
            _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
        }
        _tprintf(_T("\n"));
    }
    if (LogFileName != NULL) {
        _tprintf(_T("Log Filename:           %s\n"), LogFileName);
    }

}

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void 
StringToGuid(
    IN TCHAR *str, 
    IN OUT LPGUID guid
)
/*++

Routine Description:

    Converts a string into a GUID.

Arguments:

    str - A string in TCHAR.
    guid - The pointer to a GUID that will have the converted GUID.

Return Value:

    None.


--*/
{
    TCHAR temp[10];
    int i;

    _tcsncpy(temp, str, 8);
    temp[8] = 0;
    guid->Data1 = ahextoi(temp);
    _tcsncpy(temp, &str[9], 4);
    temp[4] = 0;
    guid->Data2 = (USHORT) ahextoi(temp);
    _tcsncpy(temp, &str[14], 4);
    temp[4] = 0;
    guid->Data3 = (USHORT) ahextoi(temp);

    for (i=0; i<2; i++) {
        _tcsncpy(temp, &str[19 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
    for (i=2; i<8; i++) {
        _tcsncpy(temp, &str[20 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
}

void PrintHelpMessage()
/*++

Routine Description:

    prints out a help message.

Arguments:

    None.

Return Value:

    None.


--*/
{
    _tprintf(_T("Usage: tracelog [actions] [options] | [-h | -help | -?]\n"));
    _tprintf(_T("\n    actions:\n"));
    _tprintf(_T("\t-start   [LoggerName] Starts up the [LoggerName] trace session\n"));
    _tprintf(_T("\t-stop    [LoggerName] Stops the [LoggerName] trace session\n"));
    _tprintf(_T("\t-update  [LoggerName] Updates the [LoggerName] trace session\n"));
    _tprintf(_T("\t-enable  [LoggerName] Enables providers for the [LoggerName] session\n"));
    _tprintf(_T("\t-disable [LoggerName] Disables providers for the [LoggerName] session\n"));
    _tprintf(_T("\t-query   [LoggerName] Query status of [LoggerName] trace session\n"));
    _tprintf(_T("\t-list                 List all trace sessions\n"));

    _tprintf(_T("\n    options:\n"));
    _tprintf(_T("\t-um                   Use Process Private tracing\n"));
    _tprintf(_T("\t-max <n>              Sets maximum buffers\n"));
    _tprintf(_T("\t-f <name>             Log to file <name>\n"));
    _tprintf(_T("\t-guid #<guid>         Provider GUID to enable/disable\n"));
    _tprintf(_T("\n"));
    _tprintf(_T("\t-h\n"));
    _tprintf(_T("\t-help\n"));
    _tprintf(_T("\t-?                    Display usage information\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\list.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOL
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\item.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    item.h

Abstract:

    Item header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

//
// Temporary structure used. Should be using MOF types
//

#define GUID_TYPE_HEADER                  L"Header" 
#define GUID_TYPE_UNKNOWN                 L"Unknown" 
#define GUID_TYPE_DEFAULT                 L"Default" 

#define EVENT_TYPE_DEFAULT              ((CHAR)(-1))
#define EVENT_LEVEL_DEFAULT             ((CHAR)(-1))
#define EVENT_VERSION_DEFAULT           ((SHORT)(-1))

#define STR_ItemChar                      L"ItemChar" 
#define STR_ItemCharHidden                L"ItemCharHidden"
#define STR_ItemWChar                     L"ItemWChar" 
#define STR_ItemUChar                     L"ItemUChar" 
#define STR_ItemCharShort                 L"ItemCharShort" 
#define STR_ItemCharSign                  L"ItemCharSign" 
#define STR_ItemShort                     L"ItemShort" 
#define STR_ItemUShort                    L"ItemUShort" 
#define STR_ItemLong                      L"ItemLong" 
#define STR_ItemULong                     L"ItemULong" 
#define STR_ItemULongX                    L"ItemULongX" 
#define STR_ItemLongLong                  L"ItemLongLong" 
#define STR_ItemULongLong                 L"ItemULongLong" 
#define STR_ItemString                    L"ItemString" 
#define STR_ItemWString                   L"ItemWString" 
#define STR_ItemRString                   L"ItemRString" 
#define STR_ItemRWString                  L"ItemRWString" 
#define STR_ItemPString                   L"ItemPString" 
#define STR_ItemPWString                  L"ItemPWString" 
#define STR_ItemDSString                  L"ItemDSString" 
#define STR_ItemDSWString                 L"ItemDSWString" 
#define STR_ItemMLString                  L"ItemMLString" 
#define STR_ItemSid                       L"ItemSid" 
#define STR_ItemChar4                     L"ItemChar4" 
#define STR_ItemIPAddr                    L"ItemIPAddr"
#define STR_ItemTDIAddr                   L"ItemTDIAddr" 
#define STR_ItemPort                      L"ItemPort" 
#define STR_ItemNWString                  L"ItemNWString" 
#define STR_ItemPtr                       L"ItemPtr" 
#define STR_ItemGuid                      L"ItemGuid" 
#define STR_ItemVariant                   L"ItemVariant" 
#define STR_ItemBool                      L"ItemBool" 
#define STR_ItemOptArgs                   L"ItemOptArgs"
#define STR_ItemCPUTime                   L"ItemCPUTime"
#define STR_ItemSizeT                     L"ItemSizeT"

//
// The following are the data types  supported by 
// WMI event trace parsing tools. New data types must be
// added to this file and the parsing code for that type
// must be added in the DumpEvent routine. 
//
typedef enum _ITEM_TYPE {
    ItemChar,
    ItemCharHidden,
    ItemWChar,
    ItemUChar,
    ItemCharShort,
    ItemCharSign,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemString,
    ItemWString,
    ItemRString,
    ItemRWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemChar4,
    ItemIPAddr,
    ItemTDIAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemGuid,
    ItemVariant,
    ItemBool,
    ItemOptArgs,
    ItemCPUTime,
    ItemSizeT,
    ItemUnknown
} ITEM_TYPE;

#define VALUETYPE_INDEX              1
#define VALUETYPE_FLAG               2

typedef struct _VALUEMAP
{
    LIST_ENTRY Entry;
    DWORD   dwValueType;
    SAFEARRAY* saValueMap;
    SAFEARRAY* saValues;

} VALUEMAP, *PVALUEMAP;

typedef struct _ITEM_DESC {
    LIST_ENTRY  Entry;
    ULONG       DataSize;
    ULONG       ArraySize;
    ITEM_TYPE   ItemType;
    PVALUEMAP   pValueMap;
    PWCHAR      strDescription;
} ITEM_DESC, *PITEM_DESC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\tracectr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __TRACECTR__01042001_
#define __TRACECTR__01042001_

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Trace Section
\*****************************************************************************/

#define CPDAPI  __stdcall

#define TRACE_LOGGER_START_IF  0x00000001
#define TRACE_LOGGER_EXISTING  0x00000002

#define TRACE_ZERO_ON_QUERY    0x00000004
#define TRACE_REDUCE           0x00000008
#define TRACE_LOG_REPLAY       0x00000010
#define TRACE_DS_ONLY          0x00000020
#define TRACE_DUMP             0x00000080
#define TRACE_USE_WBEM         0x00000100
#define TRACE_EXTENDED_FMT     0x00000200
#define TRACE_SUMMARY          0x00000400
#define TRACE_MERGE_ETL        0x00000800
#define TRACE_INTERPRET        0x00001000

#define TRACE_MEMORY_REPORT    0x00002000
#define TRACE_HARDFAULT_REPORT 0x00004000
#define TRACE_BASIC_REPORT     0x00008000
#define TRACE_TOTALS_REPORT    0x00010000
#define TRACE_FILE_REPORT      0x00020000
#define TRACE_TRANSFORM_XML    0x00040000

#define DEFAULT_FILE_REPORT_SIZE   50

#define TRACE_STATUS_PROCESSING   0x00000001
#define TRACE_STATUS_REPORTING    0x00000002

typedef enum _MM_REPORT_TYPE
{
    REPORT_SUMMARY_PROCESS,
    REPORT_SUMMARY_MODULE,
    REPORT_LIST_PROCESS,
    REPORT_LIST_MODULE
} MM_REPORT_TYPE;

typedef enum _MM_REPORT_SORT_KEY
{
    REPORT_SORT_ALL,
    REPORT_SORT_HPF,
    REPORT_SORT_TF,
    REPORT_SORT_DZF,
    REPORT_SORT_COW
} MM_REPORT_SORT_KEY;

typedef struct _USER_CONTEXT_MM
{
    MM_REPORT_TYPE     reportNow;
    MM_REPORT_SORT_KEY sortNow;
    PWCHAR             strImgName;
} CPD_USER_CONTEXT_MM, * PCPD_USER_CONTEXT_MM;

typedef struct _TRACE_MODULE_INFO
{
    ULONG       PID;
    ULONG       lBaseAddress;
    ULONG       lModuleSize;
    ULONG       lDataFaultHF;
    ULONG       lDataFaultTF;
    ULONG       lDataFaultDZF;
    ULONG       lDataFaultCOW;
    ULONG       lCodeFaultHF;
    ULONG       lCodeFaultTF;
    ULONG       lCodeFaultDZF;
    ULONG       lCodeFaultCOW;
    ULONG       NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR      strModuleName;
    LPWSTR      strImageName;
} TRACE_MODULE_INFO, * PTRACE_MODULE_INFO;

typedef struct _TRACE_PROCESS_FAULT_INFO {
    ULONG    PID;
    ULONG    lDataFaultHF;
    ULONG    lDataFaultTF;
    ULONG    lDataFaultDZF;
    ULONG    lDataFaultCOW;
    ULONG    lCodeFaultHF;
    ULONG    lCodeFaultTF;
    ULONG    lCodeFaultDZF;
    ULONG    lCodeFaultCOW;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
} TRACE_PROCESS_FAULT_INFO, *PTRACE_PROCESS_FAULT_INFO;

typedef struct _TRACE_TRANSACTION_INFO {
    ULONG   TransactionCount;
    ULONG   AverageResponseTime;    // in milliseconds
    ULONG   MaxResponseTime;
    ULONG   MinResponseTime;
    ULONG   NextEntryOffset;
    LPWSTR  Name;
} TRACE_TRANSACTION_INFO, *PTRACE_TRANSACTION_INFO;

typedef struct _TRACE_FILE_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR  FileName;  // The string immediatealy follows this structure. 
    ULONG   DiskNumber;
} TRACE_FILE_INFOW, *PTRACE_FILE_INFOW;

typedef struct _TRACE_PROCESS_INFOW {
    ULONG    ReadCount;
    ULONG    WriteCount;
    ULONG    ReadSize;
    ULONG    WriteSize;
    ULONG    SendCount;
    ULONG    RecvCount;
    ULONG    SendSize;
    ULONG    RecvSize;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
    ULONG    PID;
    ULONG    DeadFlag; 
    ULONG    HPF;
    ULONG    SPF;
    ULONG    PrivateWSet;
    ULONG    GlobalWSet;
    ULONG   UserCPU;
    ULONG   KernelCPU;
    ULONG   TransCount;
    ULONGLONG   LifeTime;
    ULONGLONG   ResponseTime;
    ULONGLONG   TxnStartTime;
    ULONGLONG   TxnEndTime; 
    LPWSTR      UserName;
} TRACE_PROCESS_INFOW, *PTRACE_PROCESS_INFOW;

typedef struct _TRACE_THREAD_INFO {
    ULONG     ThreadId;
} TRACE_THREAD_INFO, *PTRACE_THREAD_INFO;

typedef struct _TRACE_DISK_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;
    LPWSTR  DiskName;
    ULONG   DiskNumber;
} TRACE_DISK_INFOW, *PTRACE_DISK_INFOW;

//
// tracelib will not start up a logger anymore. It is external to the dll
// You can provide either Logfiles or LoggerNames (RealTime) as data feed
//
typedef struct _TRACE_BASIC_INFOW {
    ULONG     FlushTimer;
    HANDLE    hEvent;
    ULONG     LogFileCount;
    ULONG     LoggerCount;
    LPCWSTR    *LogFileName;
    LPCWSTR    *LoggerName;
    LPCWSTR     MergeFileName;
    LPCWSTR     ProcFileName;
    LPCWSTR     SummaryFileName;
    LPCWSTR     DumpFileName;
    LPCWSTR     MofFileName;
    LPCWSTR     DefMofFileName;
    LPCWSTR     CompFileName;
    LPCWSTR     XSLDocName;
    ULONGLONG StartTime;
    ULONGLONG EndTime;
    ULONGLONG DSStartTime;
    ULONGLONG DSEndTime;
    ULONG Flags;
    void    (*StatusFunction)(int, double);
    PVOID     pUserContext;
} TRACE_BASIC_INFOW, *PTRACE_BASIC_INFOW;

#define TRACE_FILE_INFO TRACE_FILE_INFOW
#define PTRACE_FILE_INFO PTRACE_FILE_INFOW
#define TRACE_PROCESS_INFO  TRACE_PROCESS_INFOW
#define PTRACE_PROCESS_INFO PTRACE_PROCESS_INFOW
#define TRACE_DISK_INFO TRACE_DISK_INFOW
#define PTRACE_DISK_INFO PTRACE_DISK_INFOW
#define TRACE_BASIC_INFO   TRACE_BASIC_INFOW
#define PTRACE_BASIC_INFO  PTRACE_BASIC_INFOW

#ifdef DBG

extern BOOLEAN TracectrDbgEnabled;
#define TrctrDbgPrint(_x_) { if (TracectrDbgEnabled) DbgPrint _x_ ; }

#endif

//
// APIs 
//

ULONG 
CPDAPI
GetTempName( LPTSTR strFile, size_t cchSize );

BOOLEAN
CPDAPI
TraceCtrDllInitialize (
    HINSTANCE hinstDll,
    DWORD fdwReason,
    LPVOID fImpLoad
    );


ULONG 
CPDAPI
InitTraceContextW(
    IN OUT PTRACE_BASIC_INFOW pTraceBasic,
    PULONG pMergedEventsLost
    );

ULONG
CPDAPI
DeinitTraceContext(
    IN OUT PTRACE_BASIC_INFO pTraceBasic
    );

ULONG
CPDAPI
GetMaxLoggers();

void DecodeIpAddressA(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PCHAR pszA
    );

void DecodeIpAddressW(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PWCHAR pszW
    );

HRESULT TransformXML( LPWSTR szXML, LPWSTR szXSL, LPWSTR szResult );

#define InitTraceContext    InitTraceContextW

#ifdef __cplusplus
}
#endif

#endif // __TRACECTR__01042001_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\callbacks.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    callbacks.c

Abstract:

    Setting up and handling the callbacks for the events from the
    trace file.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:

    Insung Park (insungp) 05-Jan-2001

    Updated DumpEvent() so that by default, it searches WBEM namespace 
    for the event data layout information. 
    Functions added/modified: GetArraySize, GetItemType,
        GetPropertiesFromWBEM, GetGuidsWbem, GetGuidsFile, and GetGuids.

    Insung Park (insungp) 16-Jan-2001

    Changes enabling tracerpt to handle an invalid type name array in the WBEM namespace.
    Bug fixes for memory corruption (GetPropertiesFromWBEM and GetGuidsWBEM).


--*/
#ifdef __cplusplus
extern "C"{
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "cpdata.h"
#include <wbemidl.h>
#include "tracectr.h"
#include "item.h"
#include "guids.h"

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

#define MOFWSTR             16360
#define MOFSTR              32720
#define MAXTYPE             256
#define MAXGUIDSTR          128
#define UC(x)               ( (UINT)((x) & 0xFF) )
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )

//
// IRP Flags from ntos\inc\io.h for Io event processing.
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

int   IdleEndCount   = 0;
ULONG PageFaultCount = 0;
ULONG EventCount     = 0;

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern ULONG TotalBuffersRead;
extern BOOLEAN XPorHigher;

ULONG HPFReadCount  = 0;
ULONG HPFWriteCount = 0;

ULONG TotalEventsLost = 0;
ULONG TotalEventCount = 0;
ULONG TimerResolution = 10;
__int64 ElapseTime;

PCHAR  MofData    = NULL;
size_t MofLength  = 0;
BOOLEAN fIgnorePerfClock = FALSE;
BOOLEAN fRealTimeCircular = FALSE;
ULONG PointerSize = 0;

BOOL g_bUserMode = FALSE;

static ULONG NumProc = 0;
ULONGLONG BogusThreads[64];
ULONG BogusCount=0;
ULONG IdleThreadCount=0;
BOOLEAN bCaptureBogusThreads=TRUE;

BOOLEAN bIISEvents = FALSE;
ULONG IISRequestsDiscarded = 0;
ULONG IISEventsDiscarded = 0;

IWbemServices *pWbemServices = NULL;
LIST_ENTRY g_ValueMapTable;

void AnsiToUnicode(PCHAR str, PWCHAR wstr);

ULONG ahextoi( WCHAR *s);

ULONG StringToNumber( LPWSTR sz );

PMOF_VERSION
GetGuids( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent );

HRESULT
WbemConnect( IWbemServices** pWbemServices );

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
    );

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
    );

PMOF_VERSION
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType,
    BOOL bKernelEvent
    );

PMOF_VERSION
GetGuidsWBEM ( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType, 
    BOOL bKernelEvent 
    );

PMOF_VERSION
GetGuidsMofFiles(
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType, 
    BOOL bKernelEvent 
    );

PMOF_VERSION
GetGuidsFile(
    FILE *f,
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType, 
    BOOL bKernelEvent 
    );

VOID
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );

VOID
AddMofInfo(
    PLIST_ENTRY List,
    LPWSTR      strType,
    SHORT       nType,
    UINT        ArraySize,
    PVALUEMAP   pValueMap
);


VOID
UpdateThreadPrintData(
    PPRINT_JOB_RECORD pJob,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    );

VOID
PrintJobCallback(
    PEVENT_TRACE pEvent
    );

VOID
UpdateThreadIisData(
    PHTTP_REQUEST_RECORD pReq,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    );

VOID
SumUpCPUTime(
    PHTTP_REQUEST_RECORD pReq
    );

VOID
IISEventCallback(
    PEVENT_TRACE pEvent
    );

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
    );

void
DumpMofVersionItem(
    PMOF_VERSION pMofVersion
    );

void
DumpMofList();

extern PWCHAR CpdiGuidToString(PWCHAR s, ULONG len, LPGUID piid);


ULONG Interpolate(ULONGLONG timeStart, ULONG deltaStart,
                  ULONGLONG timeEnd,   ULONG deltaEnd,
                  ULONGLONG timeMiddle)
{
    return deltaStart
          + (deltaEnd - deltaStart) * ((ULONG) (timeMiddle - timeStart))
                                    / ((ULONG) (timeEnd - timeStart));
}

BOOLEAN
InTimeWindow(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    BOOLEAN fResult = (pThread) ? (TRUE) : (FALSE);

    if (fResult && fDSOnly)
    {
        if (   ((ULONGLONG) pHeader->TimeStamp.QuadPart < DSStartTime)
            || ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime))
        {
            fResult = FALSE;
        }
    }
    return fResult;
}

VOID
AdjustThreadTime(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;

    if (IsEqualGUID(&pHeader->Guid, &EventTraceGuid))
    {
        return;
    }
    else if (!pThread || pThread->DeadFlag)
    {
        return;
    }
    else if (fDSOnly)
    {
        if (   ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
            && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime))
        {
            if (pThread->TimeStart < DSStartTime)
            {
                pThread->TimeStart = DSStartTime;
                pThread->KCPUStart = Interpolate(
                        pThread->TimeEnd, pThread->KCPUStart,
                        pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                        DSStartTime);
                pThread->UCPUStart = Interpolate(
                        pThread->TimeEnd, pThread->UCPUStart,
                        pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                        DSStartTime);
            }

            pThread->KCPUEnd = pHeader->KernelTime;
            pThread->UCPUEnd = pHeader->UserTime;
            pThread->TimeEnd = (ULONGLONG)pHeader->TimeStamp.QuadPart;
        }
        else if ((ULONGLONG) pHeader->TimeStamp.QuadPart < DSStartTime)
        {
            pThread->TimeStart = pThread->TimeEnd
                               = (ULONGLONG) pHeader->TimeStamp.QuadPart;
            pThread->KCPUStart = pThread->KCPUEnd = pHeader->KernelTime;
            pThread->UCPUStart = pThread->UCPUEnd = pHeader->UserTime;
        }
        else if ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime)
        {
            if (pThread->TimeEnd < DSEndTime)
            {
                if (pThread->TimeEnd < DSStartTime)
                {
                    pThread->KCPUStart = Interpolate(
                            pThread->TimeEnd, pThread->KCPUStart,
                            pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                            DSStartTime);
                    pThread->UCPUStart = Interpolate(
                            pThread->TimeEnd, pThread->UCPUStart,
                            pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                            DSStartTime);
                    pThread->TimeStart = DSStartTime;
                }
                pThread->KCPUEnd = Interpolate(
                        pThread->TimeEnd, pThread->KCPUEnd,
                        pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                        DSEndTime);
                pThread->UCPUEnd = Interpolate(
                        pThread->TimeEnd, pThread->UCPUEnd,
                        pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                        DSEndTime);
                pThread->TimeEnd = DSEndTime;
            }
        }
    }
    else
    {
        pThread->TimeEnd  = pHeader->TimeStamp.QuadPart;
        if (pThread->KCPUEnd <= pHeader->KernelTime)
            pThread->KCPUEnd  = pHeader->KernelTime;
        if (pThread->UCPUEnd <= pHeader->UserTime)
            pThread->UCPUEnd  = pHeader->UserTime;
    }
}

//
// This routine allocates a new MOF_VERSION entry for
// the given type, version and Level.
//

PMOF_VERSION
GetNewMofVersion( SHORT nType, SHORT nVersion, CHAR nLevel )
{
    PMOF_VERSION pMofVersion = NULL;

    pMofVersion = (PMOF_VERSION)malloc(sizeof(MOF_VERSION));

    if( NULL == pMofVersion ){
        return NULL;
    }

    RtlZeroMemory(pMofVersion, sizeof(MOF_VERSION));

    InitializeListHead(&pMofVersion->ItemHeader);
    
    pMofVersion->TypeIndex = nType;
    pMofVersion->Level = nLevel;
    pMofVersion->Version = nVersion;

    return pMofVersion;
}

static void reduceA(char *Src)
{
    char *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if ('\t' == *Src)
            *Src = ' ';
        else if (',' == *Src)
            *Src = ' ';
        else if ('\n' == *Src)
            *Src = ',';
        else if ('\r' == *Src)
            *Src = ' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((' ' == *Src) || (',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

static void reduceW(WCHAR *Src)
{
    WCHAR *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if (L'\t' == *Src)
            *Src = L' ';
        else if (L',' == *Src)
            *Src = L' ';
        else if (L'\n' == *Src)
            *Src = L',';
        else if (L'\r' == *Src)
            *Src = L' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((L' ' == *Src) || (L',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

static void replaceNLW(WCHAR *Src)
{
    WCHAR *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if (L'\n' == *Src)
            *Src = L' ';
        else if (L'\r' == *Src)
            *Src = L' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && (L' ' == *Src))
    {
        *Src = 0x00;
        --Src;
    }
}

//
// Given a GUID, return a MOF_INFO
//

PMOF_INFO
GetMofInfoHead(
    LPCGUID pGuid
    )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY  EventListHead;

    if (pGuid == NULL) 
        return NULL;

    // Search the eventList for this Guid and find the head
    //

    //
    // Traverse the list and look for the Mof info head for this Guid.

    EventListHead = &CurrentSystem.EventListHead;
    Head = EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (IsEqualGUID(&pMofInfo->Guid, pGuid)) {
            return  pMofInfo;
        }
        Next = Next->Flink;
    }

    //
    // If not found, add a new entry for this GUID
    //

    pMofInfo = (PMOF_INFO)malloc(sizeof(MOF_INFO));
    if (pMofInfo == NULL) {
        return NULL;
    }
    RtlZeroMemory (pMofInfo, sizeof(MOF_INFO));
    pMofInfo->Guid = *pGuid;
    InitializeListHead(&pMofInfo->VersionHeader);
    InitializeListHead(&pMofInfo->DataListHead);

    InsertTailList(EventListHead, &pMofInfo->Entry);
    return pMofInfo;
}


//
// Locate the mof version information for the given guid
//
PMOF_VERSION
GetMofVersion(
    PMOF_INFO pMofInfo,
    SHORT  nType,
    SHORT  nVersion,
    CHAR   nLevel

    )
{
    PLIST_ENTRY Head, Next;
    SHORT   nMatchLevel = 0;
    SHORT nMatchCheck = 0;
    PMOF_VERSION pMofVersion = NULL;
    PMOF_VERSION pBestMatch = NULL;
    

    if (pMofInfo == NULL)
        return NULL;
    //
    // Traverse the list and look for the Mof info head for this Guid.

    Head = &pMofInfo->VersionHeader;
    Next = Head->Flink;

    while (Head != Next) {

        nMatchCheck = 0;
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        if( pMofVersion->TypeIndex == nType ){
            nMatchCheck++;
        }
        if( pMofVersion->Level == nLevel ){
            nMatchCheck++;
        }
        if( pMofVersion->Version == nVersion ){
            nMatchCheck++;
        }

        if( nMatchCheck == 3 ){ // Exact Match
            return  pMofVersion;
        }

        if( nMatchCheck > nMatchLevel ){ // Close Match

            nMatchLevel = nMatchCheck;
            pBestMatch = pMofVersion;
        }

        if( pMofVersion->TypeIndex == EVENT_TYPE_DEFAULT && // Total Guess
            pBestMatch == NULL ){

            pBestMatch = pMofVersion;
        }

    }

    if (pBestMatch != NULL) {
        return pBestMatch;
    }
    //
    // If One does not exist, look it up.
    //
    pMofVersion = GetGuids( pMofInfo->Guid, nVersion, nLevel, nType, 0 );

    // If still not found, create a unknown place holder
    if( NULL == pMofVersion ){
        pMofVersion = GetNewMofVersion( nType, nVersion, nLevel );
        if( pMofVersion != NULL ){
            InsertTailList( &pMofInfo->VersionHeader, &pMofVersion->Entry );
            
            if (nType == EVENT_TRACE_TYPE_INFO) {
                LPWSTR szHeader = L"Header";
                pMofVersion->strType = (PWCHAR)malloc((lstrlenW(szHeader)+1)*sizeof(WCHAR));
                if( pMofVersion->strType != NULL ){
                    StringCchCopyW( pMofVersion->strType, lstrlenW(szHeader)+1, szHeader);
                }
            }
        }
    }

    return pMofVersion;
}

//
// This routine adds a ITEM_DESC entry to all the MOF_VERSION 
// structures in the List
//


VOID
AddMofInfo(
    PLIST_ENTRY List,
    LPWSTR      strType,
    SHORT       nType,
    UINT        ArraySize,
    PVALUEMAP   pValueMap
    )
{
    PITEM_DESC pItem;
    PMOF_VERSION pMofVersion;

    PLIST_ENTRY Head = List;
    PLIST_ENTRY Next = Head->Flink;


    //
    // Traverse through the list of MOF_VERSIONS
    //

    while (Head != Next) {
        
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        if( NULL != pMofVersion ){

            //
            // ALLOCATE a new ITEM_DESC for the given type
            //

            pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
            if( NULL == pItem ){
                return;
            }
            ZeroMemory( pItem, sizeof(ITEM_DESC) );
            pItem->ItemType = (ITEM_TYPE)nType;
            pItem->ArraySize = ArraySize;


            // All standard datatypes with fixed sizes will be filled here. 

            switch (nType) {
                case ItemChar       :
                case ItemUChar      : pItem->DataSize = sizeof (char); break;
                case ItemCharHidden : pItem->DataSize = sizeof (char); break;
                case ItemBool       : pItem->DataSize = sizeof (BOOL); break;
                case ItemWChar      : pItem->DataSize = sizeof (WCHAR); break;
                case ItemShort      :
                case ItemPort       : 
                case ItemUShort     : pItem->DataSize = sizeof (short); break;
                case ItemSizeT      :
                case ItemPtr        : pItem->DataSize = PointerSize / 8; break; // BUG when two files (Win64 & Win32) are used.
                case ItemLong       :
                case ItemIPAddr     :
                case ItemCPUTime    :
                case ItemULong      :
                case ItemULongX     : pItem->DataSize = sizeof (ULONG); break;
                case ItemGuid       : pItem->DataSize = sizeof(GUID); break;
                case ItemLongLong   :
                case ItemULongLong  : pItem->DataSize = sizeof (__int64); break;
                case ItemChar4      : pItem->DataSize = sizeof(char) * 4; break;
                // This is the maximum size for TDI address.
                case ItemTDIAddr    : pItem->DataSize = sizeof(USHORT) + sizeof(TDI_ADDRESS_IP6); break; 
                case ItemOptArgs    :
                default             : pItem->DataSize = 0;
            }


            pItem->strDescription = (PWCHAR) malloc((lstrlenW(strType)+1)*sizeof(WCHAR));
            
            if( NULL == pItem->strDescription ){
                free( pItem );
                return;
            }
            StringCchCopyW(pItem->strDescription, lstrlenW(strType)+1, strType);

            if( NULL != pValueMap ){
                
                pItem->pValueMap = pValueMap;
                
                /*
                if( NULL == pItem->pValueMap ){
                    free( pItem->strDescription );
                    free( pItem );
                    return;
                }

                pItem->pValueMap->dwValueType = pValueMap->dwValueType;
                SafeArrayCopy( pValueMap->saValueMap, &pItem->pValueMap->saValueMap );
                SafeArrayCopy( pValueMap->saValues, &pItem->pValueMap->saValues );
                */
            }

            //
            // Insert the new entry into the ItemHeader list for 
            // this Version, Type, Level combination
            //
         
            InsertTailList( &(pMofVersion->ItemHeader), &pItem->Entry);
        }
    }
}

VOID
DeclareKernelEvents()
{
    PMOF_VERSION pMofVersion;

    pMofVersion = GetGuids(FileIoGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(DiskIoGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(PageFaultGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ProcessGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ImageLoadGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ThreadGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(TcpIpGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(UdpIpGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(EventTraceConfigGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(RegistryGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(EventTraceGuid, 0, 0, EVENT_TRACE_TYPE_INFO, TRUE);

}

VOID
LogHeaderCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER   pHeader;
    ULONG BuildNumber;
    PPROCESS_FILE_RECORD pFileRec;
    PTRACE_LOGFILE_HEADER pEvmInfo;
    ULONGLONG HeaderStartTime = 0;

    if (pEvent == NULL) {
        return;
    }
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    if ( (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP) ||
         (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_EXTENSION) ) {
        return;
    }

    pEvmInfo = (PTRACE_LOGFILE_HEADER) pEvent->MofData;
    BuildNumber = pEvmInfo->ProviderVersion;
    BuildNumber &= (0xFAFFFFFF);
    CurrentSystem.BuildNumber = BuildNumber;

    CurrentSystem.TimerResolution = pEvmInfo->TimerResolution /  10000;
    CurrentSystem.NumberOfProcessors = pEvmInfo->NumberOfProcessors;
    CurrentSystem.CpuSpeed = pEvmInfo->CpuSpeedInMHz;

    g_bUserMode = (pEvmInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
    if(pEvmInfo->TimerResolution > 0){
        TimerResolution = pEvmInfo->TimerResolution / 10000;
    }
    TotalEventsLost += pEvmInfo->EventsLost;

    //
    // If Multiple files are given, use the values from the first file. 
    // 

    if (NumProc == 0) {
        NumProc = pEvmInfo->NumberOfProcessors;
        RtlZeroMemory(&BogusThreads, 64*sizeof(ULONG));
    }

    if (PointerSize < pEvmInfo->PointerSize * 8) {
    // We have multiple files with different pointer size. We cannot 
    // resolve this because event callback has no pointersize or origin 
    // file information. 
        
    // For now, we will assume that a larger pointer size. This needs to
    // be fixed in longhorn.

        PointerSize = pEvmInfo->PointerSize * 8;
    }
    if (PointerSize < 16){       // minimum is 16 bits
        PointerSize = 32;       // defaults = 32 bits
    }

    // When we pick up names and start time from individual files here, we don't use
    // global pointersize for the reason mentioned above.
    if (pEvmInfo->PointerSize == 4 && sizeof(PVOID) == 8) {
        RtlCopyMemory(&HeaderStartTime, ((PUCHAR)(&(pEvmInfo->StartTime)) - 8), sizeof(ULONGLONG));
    }
    else if (pEvmInfo->PointerSize == 8 && sizeof(PVOID) == 4) {
        RtlCopyMemory(&HeaderStartTime, ((PUCHAR)(&(pEvmInfo->StartTime)) + 8), sizeof(ULONGLONG));
    }
    else {
        HeaderStartTime = (ULONGLONG)(pEvmInfo->StartTime.QuadPart);
    }
    //
    // With Multiple LogFiles always take the largest time window
    //
    if ((CurrentSystem.StartTime == (ULONGLONG)0) ||
        (CurrentSystem.StartTime > HeaderStartTime)) {
        CurrentSystem.StartTime = HeaderStartTime;
    }

    if (DSStartTime == 0) {
        DSStartTime = CurrentSystem.StartTime;
    }
    if (fDSOnly && CurrentSystem.StartTime < DSStartTime) {
        CurrentSystem.StartTime = DSStartTime;
    }

    if ((CurrentSystem.EndTime == (ULONGLONG)0) ||
        (CurrentSystem.EndTime < (ULONGLONG)pEvmInfo->EndTime.QuadPart)) {
        CurrentSystem.EndTime = pEvmInfo->EndTime.QuadPart;
    }
    if (!(CurrentSystem.fNoEndTime)) {
        CurrentSystem.fNoEndTime = ((ULONGLONG)pEvmInfo->EndTime.QuadPart == 0);
    }

    if (DSEndTime == 0) {
        DSEndTime = CurrentSystem.EndTime;
    }
    if (fDSOnly && CurrentSystem.EndTime > DSEndTime) {
        CurrentSystem.EndTime = DSEndTime;
    }

    if (TraceContext->Flags & TRACE_REDUCE) {
        pFileRec = (PPROCESS_FILE_RECORD)malloc(sizeof(PROCESS_FILE_RECORD));
        if( pFileRec != NULL ){
            // Temporary... WMI Should dereference ->LogFileName
            LPWSTR pName = (LPWSTR)pEvmInfo;
            if (pEvmInfo->PointerSize == 4 && sizeof(PVOID) == 8) {
                pName = (LPWSTR)((PCHAR)pName + sizeof( TRACE_LOGFILE_HEADER ) - 8);
            }
            else if (pEvmInfo->PointerSize == 8 && sizeof(PVOID) == 4) {
                pName = (LPWSTR)((PCHAR)pName + sizeof( TRACE_LOGFILE_HEADER ) + 8);
            }
            else {
                pName = (LPWSTR)((PCHAR)pName + sizeof( TRACE_LOGFILE_HEADER ));
            }
            pFileRec->TraceName = (LPWSTR)malloc( ( lstrlenW(pName)+1 )*sizeof(WCHAR) );
            if( pFileRec->TraceName != NULL ){
                StringCchCopyW( pFileRec->TraceName, lstrlenW(pName)+1, pName );
            }

            pName += lstrlenW( pName ) + 1;
            pFileRec->FileName = (LPWSTR)malloc( ( lstrlenW(pName)+1 )*sizeof(WCHAR) );
            if( pFileRec->FileName != NULL ){
                StringCchCopyW( pFileRec->FileName, lstrlenW(pName)+1, pName );
            }
            pFileRec->StartTime = HeaderStartTime;
            pFileRec->EndTime = pEvmInfo->EndTime.QuadPart;
            InsertTailList( &CurrentSystem.ProcessFileListHead, &pFileRec->Entry );
        }
    }
}

VOID
IoWriteCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;
    ULONG DiskNumber= 0;
    ULONG BytesWrite=0;
    PTDISK_RECORD Disk;
    PPROCESS_RECORD pProcess, pDiskProcess;
    PPROTO_PROCESS_RECORD pProto;
    PFILE_OBJECT fileObj;
    PFILE_RECORD pProcFile;
    PVOID fDO = NULL;
    ULONG IrpFlags = 0;
    LONGLONG ByteOffset = 0;
    ULONG pFlag = FALSE;
    BOOLEAN fValidWrite = (BOOLEAN) (!fDSOnly ||
                    (  ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
                    && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime)));


    GetMofData(pEvent, L"DiskNumber", &DiskNumber, sizeof(ULONG));
    GetMofData(pEvent, L"IrpFlags", &IrpFlags, sizeof(ULONG));
    GetMofData(pEvent, L"TransferSize", &BytesWrite, sizeof(ULONG));
    GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
    GetMofData(pEvent, L"ByteOffset", &ByteOffset, sizeof(LONGLONG));

    if (((IrpFlags & IRP_PAGING_IO) != 0) ||
         ((IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) != 0)) {
            pFlag = TRUE;
    }

    if ((Disk = FindGlobalDiskById(DiskNumber)) == NULL) {
        if ( !AddDisk(DiskNumber, &Disk) ) {
            return;
        }
    }
    BytesWrite /= 1024;   // Convert to Kbytes.

    if (fValidWrite)
    {
        Disk->WriteCount++;
        Disk->WriteSize += BytesWrite;
    }

    if (pThread == NULL) {

    //
    // Logger Thread Creation is MISSED by the collector.
    // So we must handle it here.
    //
        if (AddThread( pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge IO Write event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;
        //
        // Note: All ThreadStart record at the start of  data collection
        // have the same TID in the header and in the  Aux Fields.
        // Real ThreadStart events will have the Parent threadId in the
        // header and the new ThreadId in the Aux Field.
        //
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for IO Write Event.\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): IO Write Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): IO Write Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (fValidWrite)
    {
        if (pThread->pMofData != NULL) {
            ((PMOF_DATA)pThread->pMofData)->WriteCount++;
        }
        pThread->WriteIO++;
        pThread->WriteIOSize += BytesWrite;
    }

    // 2. Disk->Process
    //

    pDiskProcess = FindDiskProcessById(Disk, pThread->pProcess->PID);
    if (fValidWrite && pDiskProcess != NULL) {
       if (pFlag) {
           pDiskProcess->HPF++;
           pDiskProcess->HPFSize += BytesWrite;
       }
       else {
           pDiskProcess->WriteIO++;
           pDiskProcess->WriteIOSize += BytesWrite;
       }
    }

    // Add the I/O to the process that owns the causing thread.
    //
    pProcess = pThread->pProcess;
    if (fValidWrite && (pProcess != NULL ) ) {
        pProcess->WriteIO++;
        pProcess->WriteIOSize += BytesWrite;
        Disk = FindProcessDiskById(pProcess, DiskNumber);
        if (Disk != NULL) {

            Disk->WriteCount++;
            Disk->WriteSize += BytesWrite;
        }
    }

    //
    // Thread Local Disk.
    //
    Disk = FindLocalDiskById(&pThread->DiskListHead, DiskNumber);
    if (fValidWrite && Disk != NULL) {
        Disk->WriteCount++;
        Disk->WriteSize += BytesWrite;
    }

    //
    // Now add this I/O the file it came from
    //

    if (fValidWrite)
    {
        fileObj  = FindFileInTable(fDO);
        if (fileObj == NULL) {
            return;
        }
        fileObj->ThreadId = pEvent->Header.ThreadId;
        fileObj->LastByteOffset = ByteOffset;
        fileObj->DiskNumber = DiskNumber;
        if (fileObj->fileRec != NULL) {
            fileObj->fileRec->WriteCount++;
            fileObj->fileRec->WriteSize += BytesWrite;

            pProcFile = FindFileInProcess(pProcess, fileObj->fileRec->FileName);
            if (pProcFile != NULL) {
                pProcFile->WriteCount++;
                pProcFile->WriteSize += BytesWrite;
            }
            pProto = FindProtoProcessRecord(fileObj->fileRec, pProcess);
            if (pProto != NULL) {
                pProto->WriteCount++;
                pProto->WriteSize += BytesWrite;
            }
        }
        else {
            // APC has not happened yet. So Make a copy of the pEvent.
            // and Insert it in EventListHead;

            AddEvent(fileObj, DiskNumber,  BytesWrite, FALSE);
        }
    }

    if (pFlag || (IrpFlags & IRP_ASSOCIATED_IRP) != 0)
    {
        PHPF_FILE_RECORD pHPFFileRecord = NULL;

        HPFWriteCount ++;
        if (   fValidWrite
            && AddHPFFileRecord(& pHPFFileRecord, HPFWriteCount, IrpFlags,
                        DiskNumber, ByteOffset, BytesWrite, fDO))
        {
            EnterTracelibCritSection();
            InsertHeadList(& pThread->HPFWriteListHead,
                           & pHPFFileRecord->Entry);
            LeaveTracelibCritSection();
        }
    }
}

VOID
PsStartCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ProcessId=0;
    ULONG ReadId = 0;
    PPROCESS_RECORD pProcess;
    PCHAR ImageName;
    ULONG returnLength, requiredLength;
    CHAR  UserName[64];
    CHAR  Domain[64];
    CHAR FullName[256];
    ULONG RetLength;
    DWORD asize = 0;
    DWORD bsize = 0;
    ULONG Sid[64];
    PULONG pSid = &Sid[0];
    SID_NAME_USE Se;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;
    pProcess = FindProcessById(ProcessId, FALSE);
    // if real thread events get fired first before process start, 
    // we may already have Process structure created.
    if ( pProcess == NULL ) {
        AddProcess(ProcessId, &pProcess);
    }
    else {
        if ( pProcess->ImageName != NULL ) {
            free(pProcess->ImageName);
            pProcess->ImageName = NULL;
        }
        if ( pProcess->UserName != NULL ) {
            free(pProcess->UserName);
            pProcess->UserName = NULL;
        }
    }
    if ( pProcess != NULL ) {
        //
        // If the Data Collection Start Time and the Process Start Time
        // match, then the PsStart was created by the ProcessRunDown
        // Code. So Keep the CPU Times to compute the difference at the
        // end. Otherwise, zero the starting CPU Times.
        //
        pProcess->PID       = ProcessId;
        // try with 16 bytes for image name first.
        ImageName = (PCHAR)malloc(16 * sizeof(CHAR));
        if (ImageName == NULL) {
            return;
        }
        RtlZeroMemory(ImageName, 16 * sizeof(CHAR));
        returnLength = 16 * sizeof(CHAR);
        requiredLength = GetMofData(pEvent, L"ImageFileName", ImageName, returnLength);
        if (requiredLength > returnLength) {
            free(ImageName);
            ImageName = (PCHAR)malloc(requiredLength);
            if (ImageName == NULL) {
                return;
            }
            RtlZeroMemory(ImageName, requiredLength);
            GetMofData(pEvent, L"ImageFileName", ImageName, requiredLength);
        }

        asize = lstrlenA(ImageName);
        if (asize > 0) {
            pProcess->ImageName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
            if (pProcess->ImageName == NULL) {
                free(ImageName);
                return;
            }
            //
            // Process hook has the image name as ASCII. So we need to
            // convert it to unicode here.
            //
            AnsiToUnicode(ImageName, pProcess->ImageName);
        }
        else {
            pProcess->ImageName = (LPWSTR)malloc(MAXSTR * sizeof(WCHAR));
            if (pProcess->ImageName == NULL) {
                free(ImageName);
                return;
            }
            if (ProcessId == 0)
            {
                StringCchCopyW(pProcess->ImageName, MAXSTR, L"Idle");
            }
            else
            {
                StringCchPrintfW(pProcess->ImageName,
                                MAXSTR,
                                L"Unknown(0x%08X)",
                                ProcessId);
            }
        }
        free(ImageName);

        GetMofData(pEvent, L"UserSID", pSid, 64);

        asize = 64; bsize = 64;
        if  (LookupAccountSidA(NULL,
                               pSid,
                               &UserName[0],
                               &asize,
                               &Domain[0],
                               &bsize,
                               &Se)) {
            char* pFullName = &FullName[0];
            StringCchCopyA(pFullName, 256, "\\\\");
            StringCchCatA(pFullName, 256, Domain);
            StringCchCatA(pFullName, 256, "\\");
            StringCchCatA(pFullName, 256, UserName);
            asize = lstrlenA(pFullName);
            if (asize > 0) {
                pProcess->UserName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
                if (pProcess->UserName != NULL) {
                    AnsiToUnicode(pFullName, pProcess->UserName);
                }
            }
        }
        else
        {
            pProcess->UserName = (LPWSTR)malloc(7 * sizeof(WCHAR));
            if (pProcess->UserName != NULL) {
                StringCchCopyW(pProcess->UserName, 7, L"system");
            }
        }
    }
}

VOID
PsEndCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG    ProcessId;
    ULONG    ReadId = 0;
    PPROCESS_RECORD pProcess;
    PCHAR ImageName;
    ULONG returnLength, requiredLength;
    CHAR UserName[64];
    CHAR Domain[64];
    CHAR FullName[256];
    DWORD asize = 0;
    DWORD bsize = 0;
    ULONG RetLength;

    ULONG Sid[64];
    PULONG pSid = &Sid[0];
    SID_NAME_USE Se;

    if (pEvent == NULL)
        return;

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;

    if ( (pProcess = FindProcessById(ProcessId, TRUE)) != NULL )
    {
        if (pProcess->DeadFlag)
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): End Process %x Dead Already!\n",
                   EventCount, ProcessId);
#endif
*/
            return;
        }

        pProcess->DeadFlag = TRUE;
        // try with 16 bytes for image name first.
        ImageName = (PCHAR)malloc(16 * sizeof(CHAR));
        if (ImageName == NULL) {
            return;
        }
        RtlZeroMemory(ImageName, 16 * sizeof(CHAR));
        returnLength = 16 * sizeof(CHAR);
        requiredLength = GetMofData(pEvent, L"ImageFileName", ImageName, returnLength);
        if (requiredLength > returnLength) {
            free(ImageName);
            ImageName = (PCHAR)malloc(requiredLength);
            if (ImageName == NULL) {
                return;
            }
            RtlZeroMemory(ImageName, requiredLength);
            GetMofData(pEvent, L"ImageFileName", ImageName, requiredLength);
        }

        asize = lstrlenA(ImageName);
        if (asize > 0)
        {
            if (pProcess->ImageName != NULL) {
                free(pProcess->ImageName);
            }
            pProcess->ImageName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
            if (pProcess->ImageName != NULL) {
                AnsiToUnicode(ImageName, pProcess->ImageName);
            }
        }
        free(ImageName);

        GetMofData(pEvent, L"UserSID", pSid, 64);

        asize = 64; bsize = 64;
        if (LookupAccountSidA(NULL,
                               pSid,
                               &UserName[0],
                               &asize,
                               &Domain[0],
                               &bsize,
                               &Se)) {
            char* pFullName = &FullName[0];
            StringCchCopyA(pFullName, 256, "\\\\");
            StringCchCatA(pFullName, 256, Domain);
            StringCchCatA(pFullName, 256, "\\");
            StringCchCatA(pFullName, 256, UserName);
            asize = lstrlenA(pFullName);
            if (asize > 0)
            {
                if (pProcess->UserName != NULL)
                {
                    free(pProcess->UserName);
                }
                pProcess->UserName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
                if (pProcess->UserName != NULL) {
                    AnsiToUnicode(pFullName, pProcess->UserName);
                }
            }
        }
        else
        {
            if (pProcess->UserName != NULL)
            {
                free(pProcess->UserName);
            }
            pProcess->UserName = (LPWSTR)malloc(7 * sizeof(WCHAR));
            if (pProcess->UserName != NULL) {
                StringCchCopyW(pProcess->UserName, 7, L"system");
            }
        }
    }
/*
#if DBG
    else {
        DbgPrint("WARNING(%d): PsEnd for Unknown process %x Ignored!\n",
               EventCount, ProcessId);
    }
#endif
*/
}

VOID
ThStartCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ProcessorId;
    ULONG ProcessId, ThreadId;
    PPROCESS_RECORD pProcess;
    PTHREAD_RECORD Thread;

    ULONG ReadId = 0;
    ULONG RetLength;

    if (pEvent == NULL)
    {
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;
    RetLength = GetMofData(pEvent, L"TThreadId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//       return;
//   }
    ProcessorId = pEvent->ClientContext & 0x000000FF;
    ThreadId = ReadId;
    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;
    pProcess = FindProcessById(ProcessId, TRUE);
    if (pProcess == NULL)
    {
        // This should not Happen. The PS hooks are supposed to guarantee
        // that the process create happens before the thread creates
        // for that process.
        //
        if (!AddProcess(ProcessId, &pProcess))
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Can not find Process Start Record Th %x PID %x\n",
                   EventCount, ThreadId, ProcessId);
#endif
*/
            return;
        }
    }

    if (ThreadId == 0 && ProcessorId == 0)
    {
        pEvent->ClientContext += CurrentSystem.CurrentThread0 ++;
        //ASSERT(   CurrentSystem.CurrentThread0 <= CurrentSystem.NumberOfProcessors );
    }

    Thread = FindGlobalThreadById(ThreadId, pEvent);
    if (ThreadId != 0 && Thread != NULL && !Thread->DeadFlag)
    {
        if (Thread->fOrphan)
        {
            Thread->fOrphan = FALSE;
/*
#if DBG
            DbgPrint("INFO(%d): Attach orphan thread %x to process %x.\n",
                    EventCount, ThreadId, ProcessId);
#endif
*/
        }
        else
        {
            EVENT_TRACE event;

/*
#if DBG
            DbgPrint("WARNING(%d): Two active thread have the same TID %x.\n",
                    EventCount, ThreadId);
#endif
*/
            event.Header.TimeStamp.QuadPart = pHeader->TimeStamp.QuadPart;
            event.Header.Class.Type = EVENT_TRACE_TYPE_END;
            event.Header.ThreadId   = ThreadId;
            event.Header.UserTime   = Thread->UCPUEnd;
            event.Header.KernelTime = Thread->KCPUEnd;

            //
            // If a DCStart event with non-zero KCPU and UCPU is paired up with 
            // an end Event for the same ThreadId with less CPU Times, the delta
            // can come out negative. We correct it here. 
            //

            if (Thread->KCPUEnd < Thread->KCPUStart) 
                Thread->KCPUEnd = Thread->KCPUStart;
            if (Thread->UCPUEnd < Thread->UCPUStart)
                Thread->UCPUEnd = Thread->UCPUStart;

            ThEndCallback(&event);

            if (!AddThread(ThreadId, pEvent, &Thread))
            {

/*
#if DBG
                DbgPrint("FATBUG(%d): Cannot add global active thread TID %x.\n",
                        EventCount, ThreadId);
#endif
*/
                return;
            }
        }
    }
    else if (!AddThread(ThreadId, pEvent, &Thread))    {

/*
#if DBG
        DbgPrint("FATBUG(%d): Cannot add global active thread TID %x.\n",
                EventCount, ThreadId);
#endif
*/
        return;
    }

    Thread->pProcess = pProcess;
    Thread->TimeStart = pHeader->TimeStamp.QuadPart;

    // Note: All ThreadStart record at the start of  data collection
    // have the same TID in the header and in the  Aux Fields.
    // Real ThreadStart events will have the Parent threadId in the
    // header and the new ThreadId in the Aux Field.
    //

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)
    {
        Thread->KCPUStart = pHeader->KernelTime;
        Thread->UCPUStart = pHeader->UserTime;
    }
    else
    {
        Thread->KCPUStart = 0;
        Thread->UCPUStart = 0;
    }


    //
    // For DCStart type, the TID in the pEvent and the new thread
    // match. So we can adjust its ThreadTimes. 
    // 

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START) {
        AdjustThreadTime(pEvent, Thread);
    }
    else {
        AdjustThreadTime(pEvent, NULL);
    }

    {
        Thread->KCPU_Trans     = 0;
        Thread->KCPU_NoTrans   = 0;
        Thread->UCPU_Trans     = 0;
        Thread->UCPU_NoTrans   = 0;
        Thread->TransLevel     = 0;
        Thread->KCPU_PrevTrans = Thread->KCPUStart;
        Thread->UCPU_PrevTrans = Thread->UCPUStart;
    }

    if (Thread->TID == 0 && CurrentSystem.BuildNumber <= 1877)
    {
        CurrentSystem.NumberOfProcessors++;
    }
}

VOID
ShutdownThreads()
{
    int i;
    EVENT_TRACE event;
    PLIST_ENTRY Head,Next;
    PTHREAD_RECORD Thread;

    RtlZeroMemory(&event, sizeof(EVENT_TRACE));
    if (CurrentSystem.EndTime > CurrentSystem.LastEventTime) {
        event.Header.TimeStamp.QuadPart = CurrentSystem.EndTime;
    }
    else {
        event.Header.TimeStamp.QuadPart = CurrentSystem.LastEventTime;
    }

    //
    // Move the Thread list from the HashTable to GlobalList
    //

    for (i=0; i < THREAD_HASH_TABLESIZE; i++) {
        Head = &CurrentSystem.ThreadHashList[i];
        Next = Head->Flink;
        while (Next != Head) {
            Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
            Next = Next->Flink;

            if (!Thread->DeadFlag){
                event.Header.Class.Type = EVENT_TRACE_TYPE_DC_END;
                event.Header.ThreadId   = Thread->TID;
                event.Header.UserTime   = Thread->UCPUEnd;
                event.Header.KernelTime = Thread->KCPUEnd;
                ThEndCallback( &event );
            }
        }
    }
}

VOID
ShutdownProcesses()
{
    PLIST_ENTRY pHead = &CurrentSystem.ProcessListHead;
    PLIST_ENTRY pNext = pHead->Flink;
    PPROCESS_RECORD pProcess;

    while (pNext != pHead){
        pProcess = CONTAINING_RECORD(pNext, PROCESS_RECORD, Entry);
        pNext    = pNext->Flink;

        if (!pProcess->DeadFlag){
            pProcess->DeadFlag = TRUE;
        }
    }
}

BOOL
StopThreadTrans(
    PLIST_ENTRY Head,
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PTRANS_RECORD pTrans;
    PLIST_ENTRY Next = Head->Flink;
    while( Head != Next ){
        pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
        Next = Next->Flink;
        if( !StopThreadTrans( &pTrans->SubTransListHead, pEvent, pThread ) ){
            return FALSE;
        }
        if( !pTrans->bStarted ){
            continue;
        }
        RtlCopyMemory( &pEvent->Header.Guid, pTrans->pGuid, sizeof(GUID));
        pEvent->Header.Class.Type = EVENT_TRACE_TYPE_END;
        EventCallback( pEvent, pThread );
        return FALSE; // stopping one will credit all running events
    }
    return TRUE;
}

VOID
ThEndCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ThreadId;
    PTHREAD_RECORD Thread;

    if (pEvent == NULL)
    {
        return;
    }

    pHeader  = (PEVENT_TRACE_HEADER)&pEvent->Header;
    ThreadId = pHeader->ThreadId;

    if (ThreadId == 0)
    {
        ULONG ProcessorId = pEvent->ClientContext & 0x000000FF;
        if (ProcessorId == 0) {
            pEvent->ClientContext += (CurrentSystem.NumberOfProcessors
                                   - (CurrentSystem.CurrentThread0 --));
        }
    }
    Thread = FindGlobalThreadById(ThreadId, pEvent);

    if (Thread != NULL)
    {
        if (Thread->DeadFlag)
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Thread %x Dead Already\n",
                   EventCount, ThreadId);
#endif
*/
            return;
        }

        if (Thread->fOrphan)
        {
            ULONG           ReadId    = 0;
            ULONG           ProcessId = 0;
            PPROCESS_RECORD pProcess  = NULL;

            GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
            ProcessId = ReadId;

            pProcess = FindProcessById(ProcessId, TRUE);
            if (pProcess != NULL)
            {
                Thread->fOrphan  = FALSE;
                Thread->pProcess = pProcess;
            }

/*
#if DBG
            DbgPrint("INFO(%d): ThEndCallback() attach orphan thread %X to process %X\n",
                    EventCount, ThreadId, ProcessId);
#endif
*/
        }
        //
        // Charge any unstopped transactions
        //
        if (   Thread != NULL
            && pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)
        {
            StopThreadTrans(&Thread->TransListHead, pEvent, Thread );
        }

        Thread->DeadFlag = TRUE;
        if (fDSOnly)
        {
            if ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime)
            {
                Thread->TimeEnd = DSEndTime;
            }
            else
            {
                Thread->KCPUEnd = pHeader->KernelTime;
                Thread->UCPUEnd = pHeader->UserTime;
                Thread->TimeEnd = (ULONGLONG) pHeader->TimeStamp.QuadPart;
            }
        }
        else
        {
            if (Thread->UCPUEnd < pHeader->UserTime)
                Thread->UCPUEnd = pHeader->UserTime;
            if (Thread->KCPUEnd < pHeader->KernelTime)
                Thread->KCPUEnd = pHeader->KernelTime;
            Thread->TimeEnd = pHeader->TimeStamp.QuadPart;
        }

        if (Thread->TransLevel <= 0)
        {
            Thread->KCPU_NoTrans += Thread->KCPUEnd - Thread->KCPU_PrevTrans;
            Thread->UCPU_NoTrans += Thread->UCPUEnd - Thread->UCPU_PrevTrans;
        }
        else
        {
            Thread->KCPU_Trans += Thread->KCPUEnd - Thread->KCPU_PrevTrans;
            Thread->UCPU_Trans += Thread->UCPUEnd - Thread->UCPU_PrevTrans;
/*
#if DBG
            DbgPrint("WARNING(%d): Active Transactions in Dead Thread %x\n",
                    EventCount, ThreadId);
#endif
*/
        }
    }
    else
    {
/*
#if DBG
        DbgPrint("WARNING(%d): No Thread Start for ThreadId %x\n",
               EventCount, ThreadId);
#endif
*/
        if (AddThread(ThreadId, pEvent, &Thread))
        {
            Thread->pProcess  = FindProcessById(0, FALSE);
            Thread->DeadFlag  = TRUE;
            Thread->fOrphan   = TRUE;
            Thread->TimeStart = Thread->TimeEnd = pHeader->TimeStamp.QuadPart;
            Thread->KCPUStart = Thread->KCPUEnd = pHeader->KernelTime;
            Thread->UCPUStart = Thread->UCPUEnd = pHeader->UserTime;
            AdjustThreadTime(pEvent, Thread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for ThreadEnd Event.\n",
                   EventCount, ThreadId);
#endif
*/
        }
    }
}

VOID
IoReadCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (EVENT_TRACE_HEADER*)&pEvent->Header;
    ULONG DiskNumber=0;
    ULONG BytesRead=0;
    ULONG IrpFlags=0;
    PTDISK_RECORD Disk;
    PPROCESS_RECORD pProcess;
    PPROTO_PROCESS_RECORD pProto;
    PFILE_OBJECT fileObj;
    PFILE_RECORD pProcFile;
    PVOID fDO;
    BOOLEAN pFlag = FALSE;
    PPROCESS_RECORD pDiskProcess;
    LONGLONG ByteOffset;
    BOOLEAN fValidRead = (BOOLEAN) (!fDSOnly ||
                    (  ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
                    && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime)));

    GetMofData(pEvent, L"DiskNumber", &DiskNumber, sizeof(ULONG));
    GetMofData(pEvent, L"IrpFlags", &IrpFlags, sizeof(ULONG));
    GetMofData(pEvent, L"TransferSize", &BytesRead, sizeof(ULONG));
    GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
    GetMofData(pEvent, L"ByteOffset", &ByteOffset, sizeof(ULONGLONG));

    BytesRead /= 1024;  // Convert to Kbytes

    if (((IrpFlags & IRP_PAGING_IO) != 0) ||
         ((IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) != 0)) {
            pFlag = TRUE;
    }
//
// TODO: From DiskNumber and Offset get the Logical Disk
//       ie., DiskNumber = MapDisk(DiskIndex, Offset);
//

    //
    // Add the I/O to the DISK
    //

    if ((Disk = FindGlobalDiskById(DiskNumber)) == NULL) {
        if (!AddDisk(DiskNumber, &Disk) ) {
            return;
        }
    }

    if (fValidRead)
    {
        if (pFlag) {
            Disk->HPF++;
            Disk->HPFSize += BytesRead;
        }
        else {
            Disk->ReadCount++;
            Disk->ReadSize += BytesRead;
        }
    }

    //
    // Add the I/O to the THREAD
    //

    if ( pThread == NULL) {

    //
    // NOTE: Logger Thread Creation is MISSED by the collector.
    // So we must handle it here.
    //
        if (AddThread(pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge IO Read event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;
        //
        // Note: All ThreadStart record at the start of  data collection
        // have the same TID in the header and in the  Aux Fields.
        // Real ThreadStart events will have the Parent threadId in the
        // header and the new ThreadId in the Aux Field.
        //
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for IO Read Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): IO Read Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): IO Read Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    ASSERT(pThread != NULL);

    if (fValidRead && pThread->pMofData != NULL) {
        ((PMOF_DATA)pThread->pMofData)->ReadCount++;
    }

    if (fValidRead)
    {
        if (pFlag) {
            pThread->HPF++;
            pThread->HPFSize += BytesRead;
        }
        else {
            pThread->ReadIO++;
            pThread->ReadIOSize += BytesRead;
        }
    }

    //
    // 2. Disk->Process
    //

    pDiskProcess = FindDiskProcessById(Disk, pThread->pProcess->PID);
    if (fValidRead && pDiskProcess != NULL) {
        if (pFlag) {
            pDiskProcess->HPF++;
            pDiskProcess->HPFSize += BytesRead;
        }
        else {
            pDiskProcess->ReadIO++;
            pDiskProcess->ReadIOSize += BytesRead;
        }
    }

    //
    // Add the I/O to the PROCESS
    //
    pProcess = pThread->pProcess;
    if (fValidRead && (pProcess != NULL )) {
        pProcess->ReadIO++;
        pProcess->ReadIOSize += BytesRead;

        Disk = FindProcessDiskById(pProcess, DiskNumber);
        if (Disk != NULL) {
            if (pFlag) {
                Disk->HPF++;
                Disk->HPFSize += BytesRead;
            }
            else {
                Disk->ReadCount++;
                Disk->ReadSize += BytesRead;
            }
        }
    }

    //
    // Add the I/O to the FILE
    //
    if (fValidRead)
    {
        fileObj  = FindFileInTable(fDO);
        if (fileObj == NULL) {
            return;
        }
        fileObj->ThreadId = pEvent->Header.ThreadId;
        fileObj->LastByteOffset = ByteOffset;
        fileObj->DiskNumber = DiskNumber;
        if (fileObj->fileRec) {
            fileObj->fileRec->ReadCount++;
            fileObj->fileRec->ReadSize += BytesRead;
            pProcFile = FindFileInProcess(pProcess, fileObj->fileRec->FileName);
            if (pProcFile != NULL) {
#if 0
                if (pFlag) {
                    pProcFile->HPF++;
                    pProcFile->HPFSize += BytesRead;
                }
                else {
#endif
                    pProcFile->ReadCount++;
                    pProcFile->ReadSize += BytesRead;
#if 0
                }
#endif
            }
            pProto = FindProtoProcessRecord(fileObj->fileRec, pProcess);
            if (pProto != NULL) {
#if 0
                if (pFlag) {
                    pProto->HPF++;
                    pProto->HPFSize += BytesRead;
                }
                else {
#endif
                    pProto->ReadCount++;
                    pProto->ReadSize += BytesRead;
#if 0
                }
#endif
            }
        }
        else {
            // APC has not happened yet. So Make a copy of the pEvent.
            // and Insert it in EventListHead;
            AddEvent(fileObj, DiskNumber,  BytesRead, TRUE);
        }
    }

    //
    // Do the Drill Down Calls Now. To Save on memory we need to be
    // selective about which ones to create.
    //


    // 2. Thread->Disk

    Disk = FindLocalDiskById(&pThread->DiskListHead, DiskNumber);
    if (fValidRead && Disk != NULL) {
        if (pFlag) {
            Disk->HPF++;
            Disk->HPFSize += BytesRead;
        }
        else {
            Disk->ReadCount++;
            Disk->ReadSize += BytesRead;
        }
    }

    if (pFlag || (IrpFlags & IRP_ASSOCIATED_IRP) != 0)
    {
        PHPF_FILE_RECORD pHPFFileRecord = NULL;

        HPFReadCount ++;
        if (   fValidRead
            && AddHPFFileRecord(& pHPFFileRecord, HPFReadCount, IrpFlags,
                        DiskNumber, ByteOffset, BytesRead, fDO))
        {
            EnterTracelibCritSection();
            InsertHeadList(& pThread->HPFReadListHead,
                           & pHPFFileRecord->Entry);
            LeaveTracelibCritSection();
        }
    }
}

VOID 
LogDriveCallback(
    PEVENT_TRACE pEvent
    )
{
    ULONGLONG   StartOffset = 0;
    ULONGLONG   PartitionSize = 0;
    ULONG       DiskNumber = 0;
    ULONG       Size = 0;
    ULONG       DriveType = 0;
    WCHAR       DriveLetter[MAXSTR];
    ULONG       RetLength;

    if (pEvent == NULL) {
        return;
    }
    DriveLetter[0] = UNICODE_NULL;

    GetMofData(pEvent, L"StartOffset", &StartOffset, sizeof(ULONGLONG));
    GetMofData(pEvent, L"PartitionSize", &PartitionSize, sizeof(ULONGLONG));
    GetMofData(pEvent, L"DiskNumber", &DiskNumber, sizeof(ULONG));
    GetMofData(pEvent, L"Size", &Size, sizeof(ULONG));
    GetMofData(pEvent, L"DriveType", &DriveType, sizeof(SHORT));
    RetLength = GetMofData(pEvent, L"DriveLetterString", &DriveLetter[0], MAXSTR*sizeof(WCHAR));
    if (RetLength != 0 && RetLength > MAXSTR*sizeof(WCHAR)) {
        return;
    }

    AddLogicalDrive(
                StartOffset,
                PartitionSize,
                DiskNumber,
                Size,
                DriveType,
                DriveLetter
                );

}

VOID 
CpuCallback(
    PEVENT_TRACE pEvent
    )
{
    ULONG MemSize = 0;
    WCHAR ComputerName[256];
    ULONG ComputerNameSize = 0;
    ULONG RetLength;

    ComputerName[0] = UNICODE_NULL;

    GetMofData(pEvent, L"MemSize", &MemSize, sizeof(ULONG));
    CurrentSystem.MemorySize = MemSize;
    RetLength = GetMofData(pEvent, L"ComputerName", &ComputerName[0], 256*sizeof(WCHAR));
    if (RetLength != 0 && RetLength > MAXSTR*sizeof(WCHAR)) {
        return;
    }
    ComputerNameSize = wcslen(ComputerName);
    if (ComputerNameSize > 0) {
        CurrentSystem.ComputerName = (LPWSTR)malloc((ComputerNameSize + 1) * sizeof(WCHAR));
        if (CurrentSystem.ComputerName != NULL) {
            StringCchCopyW(CurrentSystem.ComputerName, ComputerNameSize + 1, ComputerName);
        }
    }
}

VOID
HotFileCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    WCHAR FileName[MAXSTR];  // Not Sure if this is sufficient...
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec, pProcFile = NULL;
    PLOGICAL_DRIVE_RECORD pLogDrive = NULL;
    PPROTO_FILE_RECORD protoFileRec;
    PFILE_OBJECT fileObj;
    PVOID fDO = NULL;
    PTHREAD_RECORD  pThread = NULL;
    PPROCESS_RECORD pProcess = NULL;
    PPROTO_PROCESS_RECORD pProto = NULL;
    ULONG RetLength;

    if (pEvent == NULL) {
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RtlZeroMemory(&FileName[0], MAXSTR * sizeof(WCHAR));

    GetMofData(pEvent, L"FileObject", &fDO, sizeof(PVOID));
    RetLength = GetMofData(pEvent, L"FileName", &FileName[0], MAXSTR*sizeof(WCHAR));
    if (RetLength != 0 && RetLength > MAXSTR*sizeof(WCHAR)) {
        return;
    }

    //
    // Get the FileObject from the fileTable  and update the information.
    //

    fileObj = FindFileInTable(fDO);
    if (fileObj == NULL) {
        return;
    }

    pLogDrive = FindLogicalDrive(fileObj->LastByteOffset, fileObj->DiskNumber);
    // pLogDrive can be null, and it should be OK.
    if ((fileRec = FindFileRecordByName(FileName, pLogDrive)) == NULL) {
        AddFile(FileName, &fileRec, pLogDrive);
    }


    if (fileObj->fileRec != NULL) {
/*
#if DBG
        DbgPrint("BUG: APC for known file %ws\n", FileName);
#endif
*/
    }

    if ((pThread = FindGlobalThreadById(fileObj->ThreadId, pEvent)) != NULL) {
        pProcess = pThread->pProcess;
        if (pProcess != NULL) {
            pProcFile = FindFileInProcess(pProcess, FileName);
            pProto = FindProtoProcessRecord(fileRec, pProcess);
        }
    }
    else {
        return;
    }

    fileObj->fileRec = fileRec;

    //
    // Walk through the EventList and add it to this file record
    //
    Head = &fileObj->ProtoFileRecordListHead;
    Next = Head->Flink;
    while (Next != Head) {
        protoFileRec = CONTAINING_RECORD( Next, PROTO_FILE_RECORD, Entry );
        fileRec->DiskNumber = protoFileRec->DiskNumber;
        if (protoFileRec->ReadFlag) {
            fileRec->ReadCount++;
            fileRec->ReadSize += protoFileRec->IoSize;
            if (pProcFile != NULL) {
                pProcFile->ReadCount++;
                pProcFile->ReadSize += protoFileRec->IoSize;
            }
            if (pProto != NULL) {
                pProto->ReadCount++;
                pProto->ReadSize += protoFileRec->IoSize;
            }
        }
        else {
            fileRec->WriteCount++;
            fileRec->WriteSize += protoFileRec->IoSize;
            if (pProcFile != NULL) {
                pProcFile->WriteCount++;
                pProcFile->WriteSize += protoFileRec->IoSize;
            }
            if (pProto != NULL) {
                pProto->WriteCount++;
                pProto->WriteSize += protoFileRec->IoSize;
            }
        }
        Next = Next->Flink;
        RemoveEntryList( &protoFileRec->Entry);
    }

    //
    // If DrillDown Records are appended, we need to handle those too
    //
}

VOID
ModuleLoadCallback(PEVENT_TRACE pEvent)
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    ULONG lBaseAddress = 0;
    ULONG lModuleSize = 0;
    WCHAR strModulePath[256];
    WCHAR * strModuleName;
    ULONG rtnLength = sizeof(WCHAR) * 256;

    PLIST_ENTRY     pHead    = &CurrentSystem.GlobalModuleListHead;
    PLIST_ENTRY     pNext    = pHead->Flink;
    PMODULE_RECORD  pMatched = NULL;
    PMODULE_RECORD  pCurrent = NULL;
    PTHREAD_RECORD  pThread  = NULL;
    PPROCESS_RECORD pProcess = NULL;

    RtlZeroMemory(strModulePath, 256 * sizeof(WCHAR) );
    GetMofData(pEvent, L"ImageBase",    & lBaseAddress,  sizeof(ULONG));
    GetMofData(pEvent, L"ImageSize",     & lModuleSize,   sizeof(ULONG));
    GetMofData(pEvent, L"FileName",  &strModulePath[0], rtnLength);

    strModuleName = wcsrchr(strModulePath, L'\\');
    if (!strModuleName){
        strModuleName = strModulePath;
    }else{
        strModuleName ++;
    }

    // Check if loaded image is already in SYSTEM_RECORD::GlobalModuleListHead.
    // Otherwise, insert new MODULE_RECORD.
    //
    while (!pMatched && pNext != pHead){
        pMatched = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
        if (_wcsicmp(strModuleName, pMatched->strModuleName)){
            pMatched = NULL;
            pNext    = pNext->Flink;
        }
    }

    if (!pMatched){
        if (AddModuleRecord(& pMatched, lBaseAddress, lModuleSize, strModuleName)){
            EnterTracelibCritSection();
            InsertHeadList(
                    & CurrentSystem.GlobalModuleListHead,
                    & pMatched->Entry);
            LeaveTracelibCritSection();
            pMatched->pProcess   = NULL;
            pMatched->pGlobalPtr = NULL;
        }else{
            return;
        }
    }

    ASSERT(pMatched);

    // Insert loaded image in PROCESS_RECORD::ModuleListHead
    //
    if (AddModuleRecord(& pCurrent, lBaseAddress, lModuleSize, strModuleName)){
        pCurrent->pGlobalPtr = pMatched;

        pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent);
        ASSERT(pThread);
        if (!pThread){
            free( pCurrent );
            return;
        }

        pProcess = pThread->pProcess;
        ASSERT(pProcess);
        if (!pProcess){
            free( pCurrent );
            return;
        }

        EnterTracelibCritSection();
        pCurrent->pProcess = pProcess;
        InsertHeadList( & pProcess->ModuleListHead, & pCurrent->Entry);
        LeaveTracelibCritSection();
    }else{
        return;
    }
}

VOID
ProcessCallback(
   PEVENT_TRACE pEvent
    )
{
    if (pEvent == NULL){     
        return;
    }

    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)) {
        PsStartCallback(pEvent);
    }
    else if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_END) ||
             (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)) {
        PsEndCallback(pEvent);
    }
}

VOID
ThreadCallback(
    PEVENT_TRACE pEvent
    )
{
    if (pEvent == NULL){
        return;
    }

    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)) {
        ThStartCallback(pEvent);
    } 
    else if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_END) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)) {
        ThEndCallback(pEvent);
    }
}

PMODULE_RECORD
SearchModuleByAddr(
    PLIST_ENTRY pModuleListHead,
    ULONG       lAddress
    )
{
    PLIST_ENTRY    pNext   = pModuleListHead->Flink;
    PMODULE_RECORD pModule = NULL;
    PMODULE_RECORD pCurrent;

    while (pNext != pModuleListHead)
    {
        pCurrent = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
        pNext    = pNext->Flink;
        if (   (lAddress >= pCurrent->lBaseAddress)
            && (lAddress <  pCurrent->lBaseAddress + pCurrent->lModuleSize))
        {
            pModule = pCurrent;
            break;
        }
    }
    return pModule;
}

void
UpdatePageFaultCount(
    PPROCESS_RECORD pProcess,
    PMODULE_RECORD  pModule,
    ULONG           lFaultAddr,
    UCHAR           FaultType)
{
    BOOLEAN fFaultInImage = (BOOLEAN) ((lFaultAddr >= pModule->lBaseAddress)
                         && (lFaultAddr <  pModule->lBaseAddress
                                         + pModule->lModuleSize));
    switch(FaultType)
    {
    case EVENT_TRACE_TYPE_MM_HPF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultHF ++;
            pModule->lCodeFaultHF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultHF ++;
            }
        }
        else
        {
            pProcess->lDataFaultHF ++;
            pModule->lDataFaultHF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultHF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_TF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultTF ++;
            pModule->lCodeFaultTF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultTF ++;
            }
        }
        else
        {
            pProcess->lDataFaultTF ++;
            pModule->lDataFaultTF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultTF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_DZF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultDZF ++;
            pModule->lCodeFaultDZF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultDZF ++;
            }
        }
        else
        {
            pProcess->lDataFaultDZF ++;
            pModule->lDataFaultDZF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultDZF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_COW :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultCOW ++;
            pModule->lCodeFaultCOW ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultCOW ++;
            }
        }
        else
        {
            pProcess->lDataFaultCOW ++;
            pModule->lDataFaultCOW ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultCOW ++;
            }
        }
        break;

    default :
        break;
    }
}

PMODULE_RECORD
SearchSysModule(
    PPROCESS_RECORD pProcess,
    ULONG    lPC,
    BOOLEAN  fActive
    )
{
    PMODULE_RECORD  pModule     = NULL;
    PPROCESS_RECORD pSysProcess = FindProcessById(0, fActive);
    PMODULE_RECORD  pCurrent    =
                        SearchModuleByAddr(& pSysProcess->ModuleListHead, lPC);
    if (pCurrent)
    {
        if (AddModuleRecord(& pModule,
                            pCurrent->lBaseAddress,
                            pCurrent->lModuleSize,
                            pCurrent->strModuleName))
        {
            EnterTracelibCritSection();
            InsertHeadList(
                    & pProcess->ModuleListHead,
                    & pModule->Entry);
            LeaveTracelibCritSection();

            pModule->pProcess   = pProcess;
            pModule->pGlobalPtr = pCurrent->pGlobalPtr;
        }
    }

    return pModule;
}

VOID
PageFaultCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD     pProcess;
    PMOF_DATA           pMofData;
    ULONG               lFaultAddr = 0;
    ULONG               lPC = 0;
    PVOID               fDO = NULL;
    LONG                lByteCount = 0;
    LONGLONG            lByteOffset = 0;
    WCHAR               strHotFileName[1024];
    ULONG               rtnLength = sizeof(WCHAR) * 1024;
    BOOLEAN             fSpecialHPF = FALSE;
    BOOLEAN             fFound;

    if (pEvent == NULL)
        return;

    if (!InTimeWindow(pEvent, pThread))
        return;

    GetMofData(pEvent, L"VirtualAddress", &lFaultAddr, sizeof(ULONG));
    GetMofData(pEvent, L"ProgramCounter", &lPC, sizeof(ULONG));

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    if (   pHeader->Class.Type == EVENT_TRACE_TYPE_MM_HPF
        && pEvent->MofLength > 2 * sizeof(ULONG))
    {
        fSpecialHPF = TRUE;
        GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
        GetMofData(pEvent, L"ByteCount",  &lByteCount, sizeof(LONG));
        GetMofData(pEvent, L"ByteOffset", &lByteOffset, sizeof(LONGLONG));
        GetMofData(pEvent, L"FileName", &strHotFileName[0], rtnLength);
    }


    if (pThread == NULL)
    {
        if (AddThread(pHeader->ThreadId, pEvent, &pThread ))
        {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge PageFault event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE);
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;

            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for PageFault Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): PageFault Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): PageFault Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    pMofData = (PMOF_DATA)pThread->pMofData;

    if (pMofData && !fSpecialHPF)
    {
        switch(pHeader->Class.Type)
        {
        case EVENT_TRACE_TYPE_MM_TF  : pMofData->MmTf++;  break;
        case EVENT_TRACE_TYPE_MM_DZF : pMofData->MmDzf++; break;
        case EVENT_TRACE_TYPE_MM_COW : pMofData->MmCow++; break;
        case EVENT_TRACE_TYPE_MM_GPF : pMofData->MmGpf++; break;
        }
    }

    // Update loaded image MODULE_RECORD::lFaultCount
    //
    pProcess = pThread->pProcess;

    if (pProcess != NULL)
    {
        PMODULE_RECORD pModule = SearchModuleByAddr(
                                         & pProcess->ModuleListHead,
                                         lPC);

        fFound = FALSE;
        if (fSpecialHPF)
        {
            PHPF_RECORD pHPFRecord = NULL;

            PageFaultCount ++;
            if (AddHPFRecord(& pHPFRecord, lFaultAddr,
                            fDO, lByteCount, lByteOffset))
            {
                PLIST_ENTRY pHead = & pThread->HPFReadListHead;
                PLIST_ENTRY pNext = pHead->Flink;
                PHPF_FILE_RECORD pHPFFileRecord;
                PHPF_FILE_RECORD pHPFThreadRead;
                LONG             lTotalByte = 0;
                BOOLEAN          fAssociatedIrp = TRUE;

                EnterTracelibCritSection();
                pHPFRecord->RecordID = PageFaultCount;
                InsertHeadList(& pProcess->HPFListHead, & pHPFRecord->Entry);
                while (fAssociatedIrp && pNext != pHead)
                {
                    pHPFThreadRead = CONTAINING_RECORD(pNext,
                                                       HPF_FILE_RECORD,
                                                       Entry);
                    pNext = pNext->Flink;
                    fAssociatedIrp = (BOOLEAN) ((pHPFThreadRead->IrpFlags
                                      & IRP_ASSOCIATED_IRP) != 0);

                    if (!fAssociatedIrp && fDO != pHPFThreadRead->fDO)
                    {
                        fAssociatedIrp = TRUE;
                        continue;
                    }

                     if (AddHPFFileRecord(& pHPFFileRecord,
                                            pHPFThreadRead->RecordID,
                                            pHPFThreadRead->IrpFlags,
                                            pHPFThreadRead->DiskNumber,
                                            pHPFThreadRead->ByteOffset,
                                            pHPFThreadRead->BytesCount,
                                            pHPFThreadRead->fDO))
                     {
                         lTotalByte += pHPFThreadRead->BytesCount;
                         InsertHeadList(& pHPFRecord->HPFReadListHead,
                                        & pHPFFileRecord->Entry);
                     }
                     RemoveEntryList(& pHPFThreadRead->Entry);
                     free(pHPFThreadRead);
                }
                LeaveTracelibCritSection();
            }

            goto Cleanup;
        }
        else if (pHeader->Class.Type == EVENT_TRACE_TYPE_MM_HPF)
        {
            PLIST_ENTRY pHead = & pProcess->HPFListHead;
            PLIST_ENTRY pNext = pHead->Flink;
            PHPF_RECORD pHPFRecord;

            while (pNext != pHead)
            {
                pHPFRecord = CONTAINING_RECORD(pNext, HPF_RECORD, Entry);
                pNext      = pNext->Flink;
                if (pHPFRecord->lFaultAddress == lFaultAddr)
                {
                    pHPFRecord->lProgramCounter = lPC;
                    break;
                }
            }
        }

        if (pModule)
        {
            UpdatePageFaultCount(
                    pProcess, pModule, lFaultAddr, pHeader->Class.Type);
            fFound = TRUE;
        }

        if (!fFound && pProcess->PID != 0)
        {
            PMODULE_RECORD pSysModule = SearchSysModule(pProcess, lPC, TRUE);
            if (pSysModule)
            {
                UpdatePageFaultCount(
                        pProcess, pSysModule, lFaultAddr, pHeader->Class.Type);
                fFound = TRUE;
            }
        }

        if (!fFound)
        {
            PLIST_ENTRY    pModuleHead = & pProcess->ModuleListHead;
            PLIST_ENTRY    pModuleNext = pModuleHead->Flink;
            PMODULE_RECORD pTmpModule;

            while (pModuleNext != pModuleHead)
            {
                pTmpModule = CONTAINING_RECORD(pModuleNext,
                                            MODULE_RECORD,
                                            Entry);
                pModuleNext = pModuleNext->Flink;
                if (!_wcsicmp(pTmpModule->strModuleName, L"other"))
                {
                    if (   pTmpModule->lBaseAddress == 0
                        && pTmpModule->lModuleSize  == 0)
                    {
                        pTmpModule->lBaseAddress = lPC;
                        pTmpModule->lModuleSize  = 1;
                    }
                    else if (pTmpModule->lBaseAddress > lPC)
                    {
                        pTmpModule->lModuleSize += pTmpModule->lBaseAddress - lPC;
                        pTmpModule->lBaseAddress = lPC;
                    }
                    else if (  pTmpModule->lModuleSize
                             < lPC - pTmpModule->lBaseAddress + 1)
                    {
                        pTmpModule->lModuleSize =
                                lPC - pTmpModule->lBaseAddress + 1;
                    }
                    UpdatePageFaultCount(
                            pProcess,
                            pTmpModule,
                            lFaultAddr,
                            pHeader->Class.Type);
                    break;
                }
            }
        }
    }
/*
    else
    {

#if DBG
        DbgPrint("ERROR - PageFaultCallback(0x%08I64x,0x%08I64x,0x%08x,0x%08x) cannot find process\n",
                pHeader->ThreadId,
                pThread->pProcess->PID,
                lPC,
                lFaultAddr);
#endif

    }
*/
Cleanup:
    return;
}

VOID
DiskIoCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    if (pEvent == NULL)
        return;

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IO_READ) {
        IoReadCallback(pEvent, pThread);
    }
    else {
        IoWriteCallback(pEvent, pThread);
    }
}

VOID
TcpIpCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD     pProcess;
    ULONG size = 0;

    if (pEvent == NULL)
        return;
    pHeader = (EVENT_TRACE_HEADER*)&pEvent->Header;

    if (!InTimeWindow(pEvent, pThread))
        return;

    if (pThread == NULL)
    {
        if (AddThread(pHeader->ThreadId, pEvent, &pThread ))
        {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge TCP/IP event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE);
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;

            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for TCP/IP Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): TCP/IP Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): TCP/IP Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (GetMofData(pEvent, L"size", &size, sizeof(ULONG)) > 0) {

        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SEND ) {

            pThread->SendCount++;
            pThread->SendSize += size;

            if (pThread->pMofData != NULL) {
                ((PMOF_DATA)pThread->pMofData)->SendCount++;
            }

            if ( (pProcess = pThread->pProcess) != NULL ) {
                pProcess->SendCount++;
                pProcess->SendSize += size;
            }

        } else if( pEvent->Header.Class.Type == EVENT_TRACE_TYPE_RECEIVE ) {

            pThread->RecvCount++;
            pThread->RecvSize += size;

            if (pThread->pMofData != NULL) {
                ((PMOF_DATA)pThread->pMofData)->RecvCount++;
            }

            if ( (pProcess = pThread->pProcess) != NULL ) {
                pProcess->RecvCount++;
                pProcess->RecvSize += size;
            }
        }
    }
}

PFILE_OBJECT
FindFileInTable (
    IN PVOID fDO
    )
{
    PFILE_OBJECT thisFile, lastFile = NULL;
    PFILE_OBJECT *fileTable;
    UINT i;
    fileTable = CurrentSystem.FileTable;
    for (i = 0; i < MAX_FILE_TABLE_SIZE; i++) {
        thisFile = fileTable[i];
        fileTable[i] = lastFile;
        lastFile = thisFile;
        if ((thisFile != NULL) && (thisFile->fDO == fDO)) {
            fileTable[0] = thisFile;
            return thisFile;
        }
    }
    if (lastFile == NULL) {
        lastFile = (PFILE_OBJECT) malloc( sizeof(FILE_OBJECT));
        if (lastFile == NULL) {
            return NULL;
        }
    }
    fileTable[0] = lastFile;
    lastFile->fDO = fDO;
    lastFile->fileRec = NULL;
    InitializeListHead( &lastFile->ProtoFileRecordListHead );
    return lastFile;

}


//
// TODO: Redo the EventList as FILE_RECORDS with Unknown Filenames
//       The current implementation will create a proto record for
//       evenry I/O and if the  APC never arrives, it can choke the
//       system!
//

VOID
AddEvent(
    IN PFILE_OBJECT fileObject,
    IN ULONG DiskNumber,
    IN ULONG IoSize,
    IN BOOLEAN ReadFlag
    )
{
    PPROTO_FILE_RECORD protoFileRec;

    if (fileObject->fileRec != NULL) {
/*
#if DBG
        DbgPrint("BUG: FileObject  is NONNULL in AddEvent\n");
#endif
*/
    }

    protoFileRec = (PPROTO_FILE_RECORD) malloc(sizeof(PROTO_FILE_RECORD));
    if (protoFileRec == NULL) {
        return;
    }
    protoFileRec->ReadFlag = ReadFlag;
    protoFileRec->IoSize = IoSize;
    protoFileRec->DiskNumber = DiskNumber;

    InsertHeadList( &fileObject->ProtoFileRecordListHead, &protoFileRec->Entry);

    // Currently NOT Keeping track of the DrillDown data for the File
    // if APC has not happened yet. Some Events may be lost.
}


ULONG
GetMofData(
    PEVENT_TRACE pEvent,
    WCHAR *strName,
    PVOID ReturnValue,
    ULONG ReturnLength
    )
{
    PITEM_DESC pAuxInfo;
    PUCHAR pData;
    ULONG RequiredLength = 0;
    BOOLEAN  AddNull = FALSE;
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PMOF_VERSION pMofVersion;

    if (pEvent == NULL)
        return 0;

    pData = (PUCHAR) pEvent->MofData;

    if (strName == NULL)
        return 0;
    if (lstrlenW(strName) <= 0)
        return 0;

    pMofInfo = GetMofInfoHead(&pEvent->Header.Guid);
    if (pMofInfo == NULL)
        return 0;

    pMofVersion = GetMofVersion(pMofInfo,
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                            );

    if (pMofVersion == NULL)
        return 0;

    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;
    while (Head != Next) {
        pAuxInfo = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        if ( (ULONG) (pData-(PUCHAR)pEvent->MofData) >= pEvent->MofLength)
            return 0;

        switch (pAuxInfo->ItemType) {
        case ItemChar:
        case ItemUChar:
            {
                if (pAuxInfo->ArraySize > 0) {
                    RequiredLength = pAuxInfo->ArraySize;
                }
                else {
                    RequiredLength = sizeof(UCHAR);
                }
            }
            break;
        case ItemWChar:
            {
                if (pAuxInfo->ArraySize > 0) {
                    RequiredLength = pAuxInfo->ArraySize * sizeof(WCHAR);
                }
                else {
                    RequiredLength = sizeof(WCHAR);
                }
            }
            break;
        case ItemShort:
        case ItemUShort:
            {
                RequiredLength = 2;
            }
            break;
        case ItemULong:
        case ItemULongX:
            {
                RequiredLength = 4;
            }
            break;
        case ItemLongLong:
        case ItemULongLong:
            {
                RequiredLength = 8;
            }
            break;
        case ItemPString :
            pData += sizeof(USHORT);
        case ItemString :
            RequiredLength = lstrlenA((PCHAR)pData) + 1;
            break;
        case ItemWString :

            //
            // FileNames etc are not NULL Terminated and only the buffer
            // is copied. To find its length, we can't use wcslen.
            // The Length is computed from the assumption that this string
            // is the last item for this event and the size of the event
            // should help determine the size of this string.

            RequiredLength =  pEvent->MofLength -
                              (ULONG) (pData - (PUCHAR) pEvent->MofData);

            AddNull = TRUE;

            break;

        case ItemSid :
                {
                    ULONG SidMarker;
                    RtlCopyMemory(&SidMarker, pData, sizeof(ULONG));
                    if (SidMarker == 0) {
                        RequiredLength = 4;
                    }
                    else {
                        if (PointerSize == 64) {
                            pData += 16;         // skip the TOKEN_USER structure
                        }
                        else {
                            pData += 8;         // skip the TOKEN_USER structure
                        }
                        RequiredLength = 8 + (4*pData[1]);
                    }
                }
            break;
        case ItemSizeT:
        case ItemPtr :
        {
            RequiredLength = PointerSize / 8;
            if ( (RequiredLength != 4) && (RequiredLength != 8)  ) {
                RequiredLength = 4;
            }
            break;
        }
        case ItemTDIAddr :
        {
            // We assume the rest of the event is all TDIAddr
            RequiredLength =  pEvent->MofLength -
                              (ULONG) (pData - (PUCHAR) pEvent->MofData);
            break;
        }
        default : RequiredLength = pAuxInfo->DataSize;
        }
        if (!wcscmp(pAuxInfo->strDescription, strName)) {
            if (RequiredLength == 0) return 0;
            //
            // Make Sure there is enough room to copy 
            //
            if (RequiredLength > ReturnLength) {
/*
#if DBG
                DbgPrint("RequiredLength %d Space Available %d\n", RequiredLength, ReturnLength);
#endif
*/
                return RequiredLength;
            }

            RtlCopyMemory(ReturnValue, pData, RequiredLength);

            if (AddNull) {
                WCHAR* ws;
                ws = (WCHAR*) ReturnValue;
                ws[(RequiredLength/2)] = 0;
            }

            return 0;
        }
        pData += RequiredLength;
        Next = Next->Flink;
    }
    return RequiredLength;
}


ULONG
GetDeltaWithTimeWindow(BOOLEAN fKCPU, PTHREAD_RECORD pThread,
                       ULONGLONG timeStart, ULONGLONG timeEnd,
                       ULONG DeltaStart, ULONG DeltaEnd)
{
    ULONG lResult = 0;
    ULONG lDeltaStart, lDeltaEnd;

    UNREFERENCED_PARAMETER(pThread);

    if (!fDSOnly)
    {
        lResult = (DeltaEnd > DeltaStart) ? (DeltaEnd - DeltaStart) : (0);
    }
    else if ((timeStart >= DSEndTime) || (timeEnd <= DSStartTime))
    {
        lResult = 0;
    }
    else if (fKCPU)
    {
        lDeltaStart = (timeStart < DSStartTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSStartTime)
                    : DeltaStart;
        lDeltaEnd   = (timeEnd > DSEndTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSEndTime)
                    : DeltaEnd;
        lResult = (lDeltaEnd > lDeltaStart) ? (lDeltaEnd - lDeltaStart) : (0);
    }
    else
    {
        lDeltaStart = (timeStart < DSStartTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSStartTime)
                    : DeltaStart;
        lDeltaEnd   = (timeEnd > DSEndTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSEndTime)
                    : DeltaEnd;
        lResult = (lDeltaEnd > lDeltaStart) ? (lDeltaEnd - lDeltaStart) : (0);
    }
    return lResult;
}

// Generic Event Callback. Get the Transaction Response Time.
//
VOID
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD pProcess;
    PTRANS_RECORD pThreadTrans = NULL;
    ULONGLONG delta;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    //
    // Ignore Process/Thread Start/End transactions. Only go after
    // User Defined  Transactions.
    //
    pMofInfo = GetMofInfoHead(&pHeader->Guid);
    if (pMofInfo == NULL){
         return;
    }

    if ( pMofInfo->bKernelEvent ){
        return;
    }

    if (IsEqualGUID( &pMofInfo->Guid, &EventTraceGuid ) ||
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP) {
        return;
    }

    if (pThread == NULL) {
        if (AddThread( pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart = pHeader->UserTime;
            pThread->fOrphan   = TRUE;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): Generic Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): Generic Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (pMofInfo->strSortField == NULL){
        pMofData = FindMofData(pMofInfo, NULL);
    }
    else if (   (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START)
             || (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)){
        WCHAR           strSortKey[MAXSTR];

        RtlZeroMemory(strSortKey, MAXSTR * sizeof(WCHAR) );

        GetMofData(pEvent, pMofInfo->strSortField, &strSortKey[0], MAXSTR);
        pMofData = FindMofData(pMofInfo, strSortKey );
        // pThread->strSortKey is static array
        StringCchCopyW(pThread->strSortKey, MAXSTR, strSortKey );

    }else{
        pMofData = FindMofData( pMofInfo, pThread->strSortKey );
    }

    pProcess     = pThread->pProcess;
    if (   (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START)
        || (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)){
        pThreadTrans = FindTransByList(& pThread->TransListHead,
                                       & pMofInfo->Guid, 
                                       pThread->TransLevel);
    }
    else
    {
        LONG i = pThread->TransLevel - 1;

        while (i >= 0)
        {
            if (IsEqualGUID(& pHeader->Guid,
                            pThread->TransStack[i]->pGuid))
            {
                pThreadTrans = pThread->TransStack[i];
                break;
            }
            i --;
        }
        if (i < 0)
        {
            pThreadTrans = FindTransByList(& pThread->TransListHead, 
                                           &pMofInfo->Guid, 
                    (pThread->TransLevel >= 0) ? (pThread->TransLevel) : (0));
            if (pThread->TransLevel < 0)
            {
                pThread->TransLevel = 0;
                pThread->TransStack[pThread->TransLevel] = pThreadTrans;
                pThread->TransLevel ++;
            }

        }
    }

    if (pMofData == NULL) {
        return;
    }

    if (pMofData->PrevClockTime == 0)
    {
        pMofData->PrevClockTime = pHeader->TimeStamp.QuadPart;
    }

    delta = (pHeader->TimeStamp.QuadPart - pMofData->PrevClockTime);

    pMofData->TotalResponseTime += (delta * pMofData->InProgressCount) / 10000;

    // Update the Clock
    pMofData->PrevClockTime = pHeader->TimeStamp.QuadPart;

    if (   (pHeader->Class.Type == EVENT_TRACE_TYPE_START)
        || (pHeader->Class.Type == EVENT_TRACE_TYPE_DC_START))
    {
        if (pThread->TransLevel < 0)
        {
            pThread->TransLevel = 0;
        }

        if (pThread->TransLevel == 0)
        {
            LONG lDelta;

            lDelta = pHeader->KernelTime - pThread->KCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->KCPU_NoTrans  += lDelta;
                pThread->KCPU_PrevTrans = pHeader->KernelTime;
            }
            lDelta = pHeader->UserTime - pThread->UCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->UCPU_NoTrans  += lDelta;
                pThread->UCPU_PrevTrans = pHeader->UserTime;
            }
        }
        else
        {
            PTRANS_RECORD pTransPrev   =
                              pThread->TransStack[pThread->TransLevel - 1];
            PMOF_INFO     pMofInfoPrev = GetMofInfoHead(pTransPrev->pGuid);
            PMOF_DATA     pMofDataPrev = NULL;
            ULONG         DeltaCPU;

            if (pMofInfoPrev != NULL)
            {
                pMofDataPrev = FindMofData(pMofInfoPrev, NULL);
            }

            if (pMofDataPrev)
            {
                DeltaCPU = GetDeltaWithTimeWindow(
                        TRUE,
                        pThread,
                        pThread->Time_PrevEvent,
                        (ULONGLONG) pHeader->TimeStamp.QuadPart,
                        pThread->KCPU_PrevEvent,
                        pHeader->KernelTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pTransPrev->KCpu        += DeltaCPU;
                pMofDataPrev->KernelCPU += DeltaCPU;
                if (pMofDataPrev->MaxKCpu < 0)
                {
                    pMofDataPrev->MaxKCpu = DeltaCPU;
                    pMofDataPrev->MinKCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofDataPrev->MaxKCpu)
                {
                    pMofDataPrev->MaxKCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofDataPrev->MinKCpu)
                {
                    pMofDataPrev->MinKCpu = DeltaCPU;
                }

                DeltaCPU = GetDeltaWithTimeWindow(
                        FALSE,
                        pThread,
                        pThread->Time_PrevEvent,
                        (ULONGLONG) pHeader->TimeStamp.QuadPart,
                        pThread->UCPU_PrevEvent,
                        pHeader->UserTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pTransPrev->UCpu        += DeltaCPU;
                pMofDataPrev->UserCPU += DeltaCPU;
                if (pMofDataPrev->MaxUCpu < 0)
                {
                    pMofDataPrev->MaxUCpu = DeltaCPU;
                    pMofDataPrev->MinUCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofDataPrev->MaxUCpu)
                {
                    pMofDataPrev->MaxUCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofDataPrev->MinUCpu)
                {
                    pMofDataPrev->MinUCpu = DeltaCPU;
                }
            }
        }

        if( pThreadTrans != NULL ){
            if( ! pThreadTrans->bStarted ){
                pThreadTrans->bStarted = TRUE;

                pMofData->InProgressCount ++;

                if (pHeader->Class.Type == EVENT_TRACE_TYPE_START) {
                    pThread->RefCount ++;
                    pThreadTrans->RefCount ++;
                }
                else {
                    pThreadTrans->RefCount1 ++;
                }

                pThread->pMofData = pMofData;

                pThread->TransStack[pThread->TransLevel] = pThreadTrans;
                pThread->TransLevel ++;
            }
        }
        pThread->Time_PrevEvent = (ULONGLONG) pHeader->TimeStamp.QuadPart;
        pThread->KCPU_PrevEvent = pHeader->KernelTime;
        pThread->UCPU_PrevEvent = pHeader->UserTime;

        pThread->DeltaReadIO  = pThread->ReadIO;
        pThread->DeltaWriteIO = pThread->WriteIO;

        pThread->DeltaSend    = pThread->SendCount;
        pThread->DeltaRecv    = pThread->RecvCount;
    }
    else if (   (pHeader->Class.Type == EVENT_TRACE_TYPE_END)
             || (pHeader->Class.Type == EVENT_TRACE_TYPE_DC_END))
    {
        ULONG DeltaCPU;
        BOOLEAN fSwitch = TRUE;
        if( pThreadTrans != NULL ){

            if (pThreadTrans->bStarted){

                PTRANS_RECORD pTransCurrent;
                PMOF_INFO     pMofInfoCurrent;
                PMOF_DATA     pMofDataCurrent;
                BOOLEAN       fCharged = FALSE;

                if (pThread->TransLevel <= 0)
                {
                    pThread->TransLevel = 0;
                }
                else {
                    do
                    {
                        pThread->TransLevel --;
                        pTransCurrent = pThread->TransStack[pThread->TransLevel];
                        if (pTransCurrent->bStarted)
                        {
                            pTransCurrent->bStarted = FALSE;
                        }

                        pMofInfoCurrent = GetMofInfoHead( pTransCurrent->pGuid );
                        pMofDataCurrent = NULL;

                        if (pMofInfoCurrent != NULL)
                        {
                            pMofDataCurrent = FindMofData(pMofInfoCurrent, NULL);
                        }

                        if (!pMofDataCurrent)
                            continue;

                        pMofDataCurrent->InProgressCount--;

                        if (pMofDataCurrent->InProgressCount < 0){
                            pMofDataCurrent->InProgressCount = 0;
                        }
                        pMofDataCurrent->CompleteCount++;

                        pMofDataCurrent->AverageResponseTime
                                = (pMofDataCurrent->CompleteCount > 0)
                                ? (  (LONG) pMofDataCurrent->TotalResponseTime
                                   / pMofDataCurrent->CompleteCount)
                                : 0;

                        if (fCharged)
                            continue;

                        DeltaCPU = GetDeltaWithTimeWindow(
                                    TRUE,
                                    pThread,
                                    pThread->Time_PrevEvent,
                                    (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                    pThread->KCPU_PrevEvent,
                                    pHeader->KernelTime);
                        DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                        pTransCurrent->KCpu += DeltaCPU;
                        pMofDataCurrent->KernelCPU += DeltaCPU;
                        if (pMofDataCurrent->MaxKCpu < 0)
                        {
                            pMofDataCurrent->MaxKCpu = DeltaCPU;
                            pMofDataCurrent->MinKCpu = DeltaCPU;
                        }
                        if (DeltaCPU > (ULONG) pMofDataCurrent->MaxKCpu)
                        {
                            pMofDataCurrent->MaxKCpu = DeltaCPU;
                        }
                        if (DeltaCPU < (ULONG) pMofDataCurrent->MinKCpu)
                        {
                            pMofDataCurrent->MinKCpu = DeltaCPU;
                        }

                        DeltaCPU = GetDeltaWithTimeWindow(
                                    FALSE,
                                    pThread,
                                    pThread->Time_PrevEvent,
                                    (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                    pThread->UCPU_PrevEvent,
                                    pHeader->UserTime);
                        DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                        pTransCurrent->UCpu += DeltaCPU;
                        pMofDataCurrent->UserCPU += DeltaCPU;
                        if(pMofDataCurrent->MaxUCpu < 0)
                        {
                            pMofDataCurrent->MaxUCpu = DeltaCPU;
                            pMofDataCurrent->MinUCpu = DeltaCPU;
                        }
                        if (DeltaCPU > (ULONG) pMofDataCurrent->MaxUCpu)
                        {
                            pMofDataCurrent->MaxUCpu = DeltaCPU;
                        }
                        fCharged = TRUE;
                    }while ( pThread->TransLevel > 0 && 
                            !IsEqualGUID(& pHeader->Guid, pTransCurrent->pGuid));
                }

                pThread->Time_PrevEvent = (ULONGLONG) pHeader->TimeStamp.QuadPart;
                pThread->KCPU_PrevEvent = pHeader->KernelTime;
                pThread->UCPU_PrevEvent = pHeader->UserTime;
            }
            else
            {
                DeltaCPU = GetDeltaWithTimeWindow(
                                TRUE,
                                pThread,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                pHeader->KernelTime,
                                pHeader->KernelTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pThreadTrans->KCpu += DeltaCPU;
                pMofData->KernelCPU += DeltaCPU;
                if (pMofData->MaxKCpu < 0)
                {
                    pMofData->MaxKCpu = DeltaCPU;
                    pMofData->MinKCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofData->MaxKCpu)
                {
                    pMofData->MaxKCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofData->MinKCpu)
                {
                    pMofData->MinKCpu = DeltaCPU;
                }

                DeltaCPU = GetDeltaWithTimeWindow(
                                FALSE,
                                pThread,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                pHeader->UserTime,
                                pHeader->UserTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pThreadTrans->UCpu += DeltaCPU;
                pMofData->UserCPU += DeltaCPU;
                if(pMofData->MaxUCpu < 0)
                {
                    pMofData->MaxUCpu = DeltaCPU;
                    pMofData->MinUCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofData->MaxUCpu)
                {
                    pMofData->MaxUCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofData->MinUCpu)
                {
                    pMofData->MinUCpu = DeltaCPU;
                }

                fSwitch = FALSE;
            }
        }

        pMofData->ReadCount  += (pThread->ReadIO    - pThread->DeltaReadIO);
        pMofData->WriteCount += (pThread->WriteIO   - pThread->DeltaWriteIO);
        pMofData->SendCount  += (pThread->SendCount - pThread->DeltaSend);
        pMofData->RecvCount  += (pThread->RecvCount - pThread->DeltaRecv);
        pThread->pMofData     = NULL;

        if (fSwitch && pThread->TransLevel <= 0)
        {
            LONG lDelta;

            if (pThread->TransLevel < 0)
            {
                pThread->TransLevel = 0;
            }
            lDelta = pHeader->KernelTime - pThread->KCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->KCPU_Trans    += lDelta;
                pThread->KCPU_PrevTrans = pHeader->KernelTime;
            }
            lDelta = pHeader->UserTime - pThread->UCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->UCPU_Trans    += lDelta;
                pThread->UCPU_PrevTrans = pHeader->UserTime;
            }
        }
    }
}

//
// This routine moves the temporary MOF_VERSION list 
// into the VersionHeader list for this GUID (MofInfo)
//

void
FlushMofVersionList( PMOF_INFO pMofInfo, PLIST_ENTRY ListHead )
{
    PMOF_VERSION pMofVersion;
    PLIST_ENTRY Head = ListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        RemoveEntryList(&pMofVersion->Entry);
        if (pMofInfo != NULL) {
            InsertTailList( &pMofInfo->VersionHeader, &pMofVersion->Entry);
        }
        else  {
            free(pMofVersion);
        //
        // Really should not hit this case
        //
/*
#if DBG
            DbgPrint("TRACECTR: FlushMofVersionList. MofInfo ptr is NULL\n");
            ASSERT (pMofInfo != NULL);
#endif
*/
        }
    }
}


void
DumpMofVersionItem(
    PMOF_VERSION pMofVersion
    )
{
    PLIST_ENTRY Head = &pMofVersion->ItemHeader;
    PLIST_ENTRY Next = Head->Flink;
    PITEM_DESC pItem;

    DbgPrint("MOF_VERSION: Version %d Level %d Type %d strType %ws\n", 
                pMofVersion->Version,
                pMofVersion->Level,
                pMofVersion->TypeIndex,
                pMofVersion->strType);


    while( Head != Next ){
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;


        DbgPrint("Name %ws Size %d ItemType %d\n", pItem->strDescription, pItem->DataSize, pItem->ItemType);

    }
    
}

void
DumpMofList()
{
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head = &CurrentSystem.EventListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;


        //
        // Count the MOF Fields for this Guid and Type
        //




        DbgPrint("Name %ws KernelEvent %d\n", pMofInfo->strDescription,
                    pMofInfo->bKernelEvent);

    }
}

PMOF_VERSION
GetGuids( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    if ( TraceContext->Flags & TRACE_USE_WBEM ){
        return GetGuidsWBEM( Guid, nVersion, nLevel, nType, bKernelEvent );
    }else{
        return GetGuidsMofFiles( Guid, nVersion, nLevel, nType, bKernelEvent );
    }
}

HRESULT
WbemConnect( IWbemServices** pWbemServices )
{
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = SysAllocString( L"root\\wmi" );

    HRESULT hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    CHECK_HR( hr );

    hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    CHECK_HR( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,               
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     

   
cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release(); 
        pLocator = NULL;
    }
    
    return hr;
}

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
    )
{
    ULONG ArraySize = 1;
    VARIANT pVal;
    BSTR bszMaxLen;
    HRESULT hRes;

    if (pQualSet == NULL){
        return ArraySize;
    }

    bszMaxLen = SysAllocString(L"MAX");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszMaxLen,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszMaxLen);
    if (ERROR_SUCCESS == hRes && pVal.vt == VT_I4 ){
        ArraySize = pVal.lVal;
    }
    VariantClear(&pVal);
    return ArraySize;
}

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
    )
{
    ITEM_TYPE Type = ItemUnknown;;
    VARIANT pVal;
    HRESULT hRes;
    BSTR bszQualName;
    WCHAR strFormat[10];
    WCHAR strTermination[30];
    WCHAR strTemp[30];
    BOOLEAN IsPointer = FALSE;

    strFormat[0] = '\0';
    strTermination[0] = '\0';
    strTemp[0] = '\0';

    if (pQualSet == NULL)
        return ItemUnknown;

    bszQualName = SysAllocString(L"format");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        StringCchCopyW(strFormat, 10, pVal.bstrVal);

    bszQualName = SysAllocString(L"StringTermination");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        StringCchCopyW(strTermination, 30, pVal.bstrVal);

    bszQualName = SysAllocString(L"pointer");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    bszQualName = SysAllocString(L"PointerType");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    // Major fix required to get rid of temp
    bszQualName = SysAllocString(L"extension");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        StringCchCopyW(strTemp, 30, pVal.bstrVal);

    VariantClear(&pVal);
    
    CimType = (CIMTYPE_ENUMERATION)(CimType & (~CIM_FLAG_ARRAY));

    switch (CimType) {
        case CIM_EMPTY:
            Type = ItemUnknown;
            break;        
        case CIM_SINT8:
            Type = ItemCharShort;
            if (!_wcsicmp(strFormat, L"c")){
                Type = ItemChar;
            }
            break;
        case CIM_UINT8:
            Type = ItemUChar;
            if (!_wcsicmp(strTemp, L"NoPrint")) {
                Type = ItemCharHidden;
            }
            break;
        case CIM_SINT16:
            Type = ItemShort;
            break;
        case CIM_UINT16:
            Type = ItemUShort;
            if (!_wcsicmp(strTemp, L"TDIAddrType")) {
                Type = ItemTDIAddr;
            }
            break;
        case CIM_SINT32:
            Type = ItemLong;
            break;
        case CIM_UINT32:
            Type = ItemULong;
            if (!_wcsicmp(strFormat, L"x")){
                Type = ItemULongX;
            }
            break;
        case CIM_SINT64: 
            Type = ItemLongLong;
            break;
        case CIM_UINT64:
            Type = ItemULongLong;
            break;
        case CIM_BOOLEAN:
            // ItemBool
            Type = ItemBool;
            break;
        case CIM_STRING:
            
            if (!_wcsicmp(strTermination, L"NullTerminated")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemWString;
                else
                    Type = ItemString;
            }
            else if (!_wcsicmp(strTermination, L"Counted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemPWString;
                else
                    Type = ItemPString;
            }
            else if (!_wcsicmp(strTermination, L"ReverseCounted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemDSWString;
                else
                    Type = ItemDSString;
            }
            else if (!_wcsicmp(strTermination, L"NotCounted")) {
                Type = ItemNWString;
            }else{
                Type = ItemString;
            }
            break;
        case CIM_CHAR16:
            // ItemWChar
            Type = ItemWChar;
            break;
        // Major fix required for executing methods from WBEM
        case CIM_OBJECT :
            if (!_wcsicmp(strTemp, L"Port"))
                Type = ItemPort;
            else if (!_wcsicmp(strTemp, L"SizeT"))
                Type = ItemSizeT;
            else if (!_wcsicmp(strTemp, L"RString"))
                Type = ItemRString;
            else if (!_wcsicmp(strTemp, L"RWString"))
                Type = ItemRWString;
            else if (!_wcsicmp(strTemp, L"IPAddr"))
                Type = ItemIPAddr;
            else if (!_wcsicmp(strTemp, L"Sid"))
                Type = ItemSid;
            else if (!_wcsicmp(strTemp, L"Guid"))
                Type = ItemGuid;
            else if (!_wcsicmp(strTemp, L"Variant"))
                Type = ItemVariant;
            else 
                Type = ItemUnknown;
            break;

        case CIM_REAL32:
        case CIM_REAL64:
        case CIM_DATETIME:
        case CIM_REFERENCE:
        case CIM_ILLEGAL:
        default:
            Type = ItemUnknown;
            break;
    }

    if (IsPointer)
        Type = ItemPtr;
    return Type;
}

PVALUEMAP
GetValueMap( IWbemQualifierSet* pQualSet )
{
    VARIANT var;
    SAFEARRAY* saValues = NULL;
    SAFEARRAY* saValueMap = NULL;
    SAFEARRAY* saValueNumber = NULL;
    PVALUEMAP pValueMap = NULL;

    HRESULT hr;
    DWORD dwValueType = VALUETYPE_INDEX;

    if( pQualSet != NULL ){
        hr = pQualSet->Get( L"ValueMap", 0, &var, NULL );
        if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
            saValueMap = var.parray;
        }

        hr = pQualSet->Get( L"Values", 0, &var, NULL );
        if( SUCCEEDED(hr) && (var.vt & VT_ARRAY) ){
            saValues = var.parray;
        }

        hr = pQualSet->Get( L"ValueType", 0, &var, NULL );
        if( SUCCEEDED(hr) ){
            if( _wcsicmp( var.bstrVal, L"index" ) == 0 ){
                dwValueType = VALUETYPE_INDEX;
            }
            if( _wcsicmp( var.bstrVal, L"flag") == 0 ){
                dwValueType = VALUETYPE_FLAG;
            }
        }

        if( saValues != NULL && saValueMap != NULL ){
            
            BSTR HUGEP *pValueMapData;
            BSTR HUGEP *pValuesData;
            LONG HUGEP *pValueNumberData;

            LONG uMapBound, lMapBound;
            LONG uValuesBound, lValuesBound;
            
            SafeArrayGetUBound( saValueMap, 1, &uMapBound );
            SafeArrayGetLBound( saValueMap, 1, &lMapBound );
            SafeArrayAccessData( saValueMap, (void HUGEP **)&pValueMapData );
    
            SafeArrayGetUBound( saValues, 1, &uValuesBound );
            SafeArrayGetLBound( saValues, 1, &lValuesBound );
            SafeArrayAccessData( saValues, (void HUGEP **)&pValuesData );

            saValueNumber = SafeArrayCreateVector( VT_I4, 0, (uMapBound-lMapBound)+1 );

            SafeArrayAccessData( saValueNumber, (void HUGEP **)&pValueNumberData );

            for ( LONG i=lMapBound; i<=uMapBound; i++) {

                if( i<lValuesBound || i>uValuesBound ){
                    pValueNumberData[i] = 0;
                }else{
                    pValueNumberData[i] = StringToNumber( pValueMapData[i] );
                }
            }

            SafeArrayUnaccessData( saValueMap );
            SafeArrayUnaccessData( saValues );
            SafeArrayUnaccessData( saValueNumber );
    
            pValueMap = (PVALUEMAP)malloc( sizeof(VALUEMAP) );
            if( NULL == pValueMap ){
                SafeArrayDestroy( saValueMap );
                SafeArrayDestroy( saValues );
                SafeArrayDestroy( saValueNumber );
                return NULL;
            }

            InsertTailList( &g_ValueMapTable, &pValueMap->Entry);

            pValueMap->dwValueType = dwValueType;
            pValueMap->saValueMap = saValueNumber;
            pValueMap->saValues = saValues;

            SafeArrayDestroy( saValueMap );
           
            return pValueMap;

        }else if( saValues != NULL ){
            
            pValueMap = (PVALUEMAP)malloc( sizeof(VALUEMAP) );
            
            if( NULL == pValueMap ){
                return NULL;
            }

            InsertTailList( &g_ValueMapTable, &pValueMap->Entry);

            pValueMap->dwValueType = VALUETYPE_INDEX;
            pValueMap->saValueMap = NULL;
            pValueMap->saValues = saValues;

            return pValueMap;
        }

    }

    return NULL;
}

PMOF_VERSION
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType,
    BOOL bKernelEvent
)
{
    IEnumWbemClassObject    *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubSubClasses = NULL; 
    IWbemQualifierSet       *pQualSet = NULL;

    PMOF_INFO pMofInfo = NULL;
    PMOF_VERSION pMofLookup = NULL, pMofVersion = NULL;

    BSTR bszClassName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszWmiDataId = NULL;
    BSTR bszEventType = NULL; 
    BSTR bszEventTypeName = NULL; 
    BSTR bszFriendlyName = NULL;
    BSTR bszPropName = NULL;

    WCHAR strClassName[MAXSTR];
    WCHAR strType[MAXSTR];
    LONG pVarType;
    SHORT nEventType = EVENT_TYPE_DEFAULT; 

    LIST_ENTRY ListHead;
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pTypeVal;
    VARIANT pTypeNameVal;
    VARIANT pClassName;
    ULONG lEventTypeWbem;           // when types are in an array.
    ULONG HUGEP *pTypeData;
    BSTR HUGEP *pTypeNameData;

    SAFEARRAY *PropArray = NULL;
    SAFEARRAY *TypeArray = NULL;
    SAFEARRAY *TypeNameArray = NULL;

    long lLower, lUpper, lCount, IdIndex;
    long lTypeLower, lTypeUpper;
    long lTypeNameLower, lTypeNameUpper;

    ULONG ArraySize;

    ITEM_TYPE ItemType;

    InitializeListHead(&ListHead);

    VariantInit(&pVal);
    VariantInit(&pTypeVal);
    VariantInit(&pTypeNameVal);
    VariantInit(&pClassName);

    pMofInfo = GetMofInfoHead( &Guid );
    if( NULL == pMofInfo ){
        return NULL;
    }
    pMofInfo->bKernelEvent = bKernelEvent;

    bszClassName = SysAllocString(L"__CLASS");
    bszWmiDataId = SysAllocString(L"WmiDataId");
    bszEventType = SysAllocString(L"EventType");
    bszEventTypeName = SysAllocString(L"EventTypeName");
    bszFriendlyName = SysAllocString(L"DisplayName");

    hRes = pTraceSubClasses->Get(bszClassName,          // property name 
                                        0L, 
                                        &pVal,          // output to this variant 
                                        NULL, 
                                        NULL);
    if (ERROR_SUCCESS == hRes){
        if (pQualSet) {
            pQualSet->Release();
            pQualSet = NULL;
        }
        // Get Qualifier Set to obtain the friendly name.
        pTraceSubClasses->GetQualifierSet(&pQualSet);
        hRes = pQualSet->Get(bszFriendlyName, 
                                0, 
                                &pClassName, 
                                0);
        if (ERROR_SUCCESS == hRes && pClassName.bstrVal != NULL) {
            StringCchCopyW(strClassName, MAXSTR, pClassName.bstrVal);
            pMofInfo->strDescription = (LPWSTR)malloc((wcslen(strClassName) + 1) * sizeof(WCHAR));
            if (NULL != pMofInfo->strDescription) {
                StringCchCopyW(pMofInfo->strDescription, wcslen(strClassName) + 1, strClassName);
            }
        }else{
            strClassName[0] = L'\0';
        }
    
        // Put Event Header
        pMofVersion = GetNewMofVersion(
                                    EVENT_TYPE_DEFAULT,
                                    EVENT_VERSION_DEFAULT,
                                    EVENT_LEVEL_DEFAULT
                                    );
        if (pMofVersion != NULL) {
            pMofLookup = pMofVersion;
            InsertTailList(&ListHead, &pMofVersion->Entry);
        }
        else{
            goto cleanup;
        }

        // Create an enumerator to find derived classes.
        bszSubClassName = SysAllocString(pVal.bstrVal);
        hRes = pWbemServices->CreateClassEnum ( 
                                    bszSubClassName,                                                // class name
                                    WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,           // shallow search
                                    NULL,
                                    &pEnumTraceSubSubClasses
                                    );
        SysFreeString ( bszSubClassName );
        if (ERROR_SUCCESS == hRes) {
            ULONG uReturnedSub = 1;

            while(uReturnedSub == 1){
                // For each event in the subclass
                pTraceSubSubClasses = NULL;
                hRes = pEnumTraceSubSubClasses->Next((-1),                  // timeout in infinite seconds
                                                    1,                      // return just one instance
                                                    &pTraceSubSubClasses,   // pointer to a Sub class
                                                    &uReturnedSub);         // number obtained: one or zero
                if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                    if (pQualSet) {
                        pQualSet->Release();
                        pQualSet = NULL;
                    }
                    // Get Qualifier Set.
                    pTraceSubSubClasses->GetQualifierSet(&pQualSet);
                    // Get Type number among Qualifiers
                    VariantClear(&pTypeVal);
                    hRes = pQualSet->Get(bszEventType, 
                                            0, 
                                            &pTypeVal, 
                                            0);
                    if (ERROR_SUCCESS == hRes) {
                        TypeArray = NULL;
                        TypeNameArray = NULL;
                        if (pTypeVal.vt & VT_ARRAY) {   // EventType is an array
                            TypeArray = pTypeVal.parray;
                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if ((ERROR_SUCCESS == hRes) && (pTypeNameVal.vt & VT_ARRAY)) {
                                TypeNameArray = pTypeNameVal.parray;
                            }
                            if (TypeArray != NULL) {
                                hRes = SafeArrayGetLBound(TypeArray, 1, &lTypeLower);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = SafeArrayGetUBound(TypeArray, 1, &lTypeUpper);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                if (lTypeUpper < 0) {
                                    break;
                                }
                                SafeArrayAccessData(TypeArray, (void HUGEP **)&pTypeData );

                                if (TypeNameArray != NULL) {
                                    hRes = SafeArrayGetLBound(TypeNameArray, 1, &lTypeNameLower);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    hRes = SafeArrayGetUBound(TypeNameArray, 1, &lTypeNameUpper);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    if (lTypeNameUpper < 0) 
                                        break;
                                    SafeArrayAccessData(TypeNameArray, (void HUGEP **)&pTypeNameData );
                                }

                                for (lCount = lTypeLower; lCount <= lTypeUpper; lCount++) { 
                                    lEventTypeWbem = pTypeData[lCount];
                                    nEventType = (SHORT)lEventTypeWbem;
                                    pMofVersion = GetNewMofVersion(nEventType, nVersion, nLevel);
                                    if (pMofVersion != NULL) {
                                        InsertTailList(&ListHead, &pMofVersion->Entry);
                                        if (nType == nEventType) {
                                            // Type matched
                                            pMofLookup = pMofVersion;
                                        }
                                        if (TypeNameArray != NULL) {
                                            if ((lCount >= lTypeNameLower) && (lCount <= lTypeNameUpper)) {
                                                pMofVersion->strType = (LPWSTR)malloc((wcslen(pTypeNameData[lCount]) + 1) * sizeof(WCHAR));
                                                if (pMofVersion->strType != NULL){
                                                    StringCchCopyW(pMofVersion->strType, wcslen(pTypeNameData[lCount]) + 1, (LPWSTR)(pTypeNameData[lCount]));
                                                }
                                            }
                                        }
                                    }
                                }
                                SafeArrayUnaccessData(TypeArray);  
                                SafeArrayDestroy(TypeArray);
                                VariantInit(&pTypeVal);
                                if (TypeNameArray != NULL) {
                                    SafeArrayUnaccessData(TypeNameArray);
                                    SafeArrayDestroy(TypeNameArray);
                                    VariantInit(&pTypeNameVal);
                                }
                            }
                            else {
                                // 
                                // If the Types or TypeName is not found, then bail
                                //
                                break;
                            }
                        }                       
                        else {                          // EventType is scalar
                            hRes = VariantChangeType(&pTypeVal, &pTypeVal, 0, VT_I2);
                            if (ERROR_SUCCESS == hRes)
                                nEventType = (SHORT)V_I2(&pTypeVal);
                            else
                                nEventType = (SHORT)V_I4(&pTypeVal);

                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if (ERROR_SUCCESS == hRes) {
                                StringCchCopyW(strType, MAXSTR, pTypeNameVal.bstrVal);
                            }
                            else{
                                strType[0] = '\0';
                            }

                            pMofVersion = GetNewMofVersion(nEventType, nVersion, nLevel);
                            if (pMofVersion != NULL) {
                                InsertTailList(&ListHead, &pMofVersion->Entry);
                                if (nType == nEventType) {
                                    // Type matched
                                    pMofLookup = pMofVersion;
                                }
                                pMofVersion->strType = (LPWSTR)malloc((wcslen(strType) + 1) * sizeof(WCHAR));
                                if (pMofVersion->strType != NULL){
                                    StringCchCopyW(pMofVersion->strType, wcslen(strType) + 1, strType);
                                }
                            }
                        }

                        // Get event layout
                        VariantClear(&pVal);
                        IdIndex = 1;
                        V_VT(&pVal) = VT_I4;
                        V_I4(&pVal) = IdIndex; 
                        // For each property
                        PropArray = NULL;
                        while (pTraceSubSubClasses->GetNames(bszWmiDataId,                  // only properties with WmiDataId qualifier
                                                            WBEM_FLAG_ONLY_IF_IDENTICAL,
                                                            &pVal,                          // WmiDataId number starting from 1
                                                            &PropArray) == WBEM_NO_ERROR) {

                            hRes = SafeArrayGetLBound(PropArray, 1, &lLower);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            hRes = SafeArrayGetUBound(PropArray, 1, &lUpper);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            if (lUpper < 0) 
                                break;
                            // This loop will iterate just once.
                            for (lCount = lLower; lCount <= lUpper; lCount++) { 
                                hRes = SafeArrayGetElement(PropArray, &lCount, &bszPropName);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = pTraceSubSubClasses->Get(bszPropName,    // Property name
                                                                0L,
                                                                NULL,
                                                                &pVarType,      // CIMTYPE of the property
                                                                NULL);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }

                                // Get the Qualifier set for the property
                                if (pQualSet) {
                                    pQualSet->Release();
                                    pQualSet = NULL;
                                }
                                hRes = pTraceSubSubClasses->GetPropertyQualifierSet(bszPropName,
                                                                        &pQualSet);

                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                
                                ItemType = GetItemType((CIMTYPE_ENUMERATION)pVarType, pQualSet);
                                
                                if( pVarType & CIM_FLAG_ARRAY ){
                                    ArraySize = GetArraySize(pQualSet);
                                }else{
                                    ArraySize = 1;
                                }
                                
                                PVALUEMAP pValueMap = NULL;

                                pValueMap = GetValueMap( pQualSet );

                                AddMofInfo(&ListHead, 
                                            bszPropName, 
                                            ItemType, 
                                            ArraySize,
                                            pValueMap );
                            }

                            SafeArrayDestroy(PropArray);
                            PropArray = NULL;
                            V_I4(&pVal) = ++IdIndex;                        
                        }   // end enumerating through WmiDataId

                        FlushMofVersionList(pMofInfo, &ListHead);
                    }   // if getting event type was successful
                }   // if enumeration returned a subclass successfully
            }   // end enumerating subclasses
        }   // if enumeration was created successfully
    }   // if getting class name was successful
  
cleanup:
    VariantClear(&pVal);
    VariantClear(&pTypeVal);
    VariantClear(&pClassName);

    SysFreeString(bszClassName);
    SysFreeString(bszWmiDataId);
    SysFreeString(bszEventType);
    SysFreeString(bszEventTypeName);
    SysFreeString(bszFriendlyName);
    // Should not free bszPropName becuase it is already freed by SafeArrayDestroy

    FlushMofVersionList(pMofInfo, &ListHead);

    return pMofLookup;
}

PMOF_VERSION
GetGuidsWBEM ( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    IEnumWbemClassObject    *pEnumTraceSubClasses = NULL, *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubClasses = NULL, *pTraceSubSubClasses = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    BSTR bszInstance = NULL;
    BSTR bszPropertyName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszGuid = NULL;
    BSTR bszVersion = NULL;

    WCHAR strGuid[MAXGUIDSTR], strTargetGuid[MAXGUIDSTR];
    
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pGuidVal;
    VARIANT pVersionVal;

    UINT nCounter=0;
    BOOLEAN MatchFound;
    SHORT nEventVersion = EVENT_VERSION_DEFAULT;

    PMOF_VERSION pMofLookup = NULL;

    VariantInit(&pVal);
    VariantInit(&pGuidVal);
    VariantInit(&pVersionVal);
    
    if (NULL == pWbemServices) {
        hRes = WbemConnect( &pWbemServices );
        CHECK_HR( hRes );
    }

    // Convert traget GUID to string for later comparison
    CpdiGuidToString(strTargetGuid, MAXGUIDSTR, &Guid);
    
    bszInstance = SysAllocString(L"EventTrace");
    bszPropertyName = SysAllocString(L"__CLASS");
    bszGuid = SysAllocString(L"Guid");
    bszVersion = SysAllocString(L"EventVersion");
    pEnumTraceSubClasses = NULL;

    // Get an enumerator for all classes under "EventTace".
    hRes = pWbemServices->CreateClassEnum ( 
                bszInstance,
                WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumTraceSubClasses );
    SysFreeString (bszInstance);

    if (ERROR_SUCCESS == hRes) {
        ULONG uReturned = 1;
        MatchFound = FALSE;
        while (uReturned == 1) {
            pTraceSubClasses = NULL;
            // Get the next ClassObject.
            hRes = pEnumTraceSubClasses->Next((-1),             // timeout in infinite seconds
                                            1,                  // return just one instance
                                            &pTraceSubClasses,  // pointer to Event Trace Sub Class
                                            &uReturned);        // number obtained: one or zero
            if (ERROR_SUCCESS == hRes && (uReturned == 1)) {
                // Get the class name
                hRes = pTraceSubClasses->Get(bszPropertyName,   // property name 
                                                0L, 
                                                &pVal,          // output to this variant 
                                                NULL, 
                                                NULL);

                if (ERROR_SUCCESS == hRes){

                    bszSubClassName = SysAllocString(pVal.bstrVal);
                    // Create an enumerator to find derived classes.
                    hRes = pWbemServices->CreateClassEnum ( 
                                            bszSubClassName,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                            NULL,
                                            &pEnumTraceSubSubClasses 
                                            );
                    SysFreeString ( bszSubClassName );
                    VariantClear(&pVal);

                    if (ERROR_SUCCESS == hRes) {
                                    
                        ULONG uReturnedSub = 1;
                        MatchFound = FALSE;
                    
                        while(uReturnedSub == 1){

                            pTraceSubSubClasses = NULL;
                            // enumerate through the resultset.
                            hRes = pEnumTraceSubSubClasses->Next((-1),              // timeout in infinite seconds
                                                            1,                      // return just one instance
                                                            &pTraceSubSubClasses,   // pointer to a Sub class
                                                            &uReturnedSub);         // number obtained: one or zero
                            if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                                // Get the subclass name            
                                hRes = pTraceSubSubClasses->Get(bszPropertyName,    // Class name 
                                                                0L, 
                                                                &pVal,              // output to this variant 
                                                                NULL, 
                                                                NULL);
                                VariantClear(&pVal);

                                if (ERROR_SUCCESS == hRes){

                                    // Get Qualifier Set.
                                    if (pQualSet) {
                                        pQualSet->Release();
                                        pQualSet = NULL;
                                    }
                                    pTraceSubSubClasses->GetQualifierSet (&pQualSet );

                                    // Get GUID among Qualifiers
                                    hRes = pQualSet->Get(bszGuid, 
                                                            0, 
                                                            &pGuidVal, 
                                                            0);

                                    if (ERROR_SUCCESS == hRes) {
                                        StringCchCopyW(strGuid, MAXGUIDSTR, (LPWSTR)V_BSTR(&pGuidVal));
                                        VariantClear ( &pGuidVal  );
                                                    
                                        if (!wcsstr(strGuid, L"{")) {
                                            WCHAR strTempGuid[MAXGUIDSTR];
                                            StringCchCopyW(strTempGuid, MAXGUIDSTR, strGuid);
                                            StringCchPrintfW(strGuid, MAXGUIDSTR, L"{%ws}", strTempGuid);
                                        }

                                        if (!_wcsicmp(strTargetGuid, strGuid)) {
                                            hRes = pQualSet->Get(bszVersion, 
                                                                    0, 
                                                                    &pVersionVal, 
                                                                    0);
                                            if (ERROR_SUCCESS == hRes) {
                                                hRes = VariantChangeType(&pVersionVal, &pVersionVal, 0, VT_I2);
                                                if (ERROR_SUCCESS == hRes)
                                                    nEventVersion = (SHORT)V_I2(&pVersionVal);
                                                else
                                                    nEventVersion = (SHORT)V_I4(&pVersionVal);
                                                VariantClear(&pVersionVal);

                                                if (nVersion == nEventVersion) {
                                                    // Match is found. 
                                                    // Now put all events in this subtree into the list 
                                                    MatchFound = TRUE;
                                                    pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                        Guid,
                                                                                        nVersion,
                                                                                        nLevel,
                                                                                        nType,
                                                                                        bKernelEvent
                                                                                        );
                                                    break;
                                                }
                                            }
                                            else {

                                                // if there is no version number for this event
                                                MatchFound = TRUE;
                                                //_tprintf(_T("Close Match Found: \t%s\t, version %d\n"), strGuid, nEventVersion);
                                                pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                    Guid,
                                                                                    EVENT_VERSION_DEFAULT,
                                                                                    nLevel,
                                                                                    nType,
                                                                                    bKernelEvent
                                                                                    );
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } // end while enumerating sub classes
                        if (MatchFound) {
                            break;
                        }
                        if (pEnumTraceSubSubClasses) {
                            pEnumTraceSubSubClasses->Release();
                            pEnumTraceSubSubClasses = NULL;
                        }
                    }   // if creating enumeration was successful
                }   // if getting class name was successful
            }
            nCounter++;
            // if match is found, break out of the top level search
            if (MatchFound)
                break;
        }   // end while enumerating top classes
        if( pEnumTraceSubClasses ){
            pEnumTraceSubClasses->Release();
            pEnumTraceSubClasses = NULL;
        }
    }   // if creating enumeration for top level is successful

cleanup:

    VariantClear(&pGuidVal);
    VariantClear(&pVersionVal);

    SysFreeString(bszGuid);
    SysFreeString(bszPropertyName);  
    SysFreeString(bszVersion);  
 
    if (pEnumTraceSubClasses){  
        pEnumTraceSubClasses->Release();
        pEnumTraceSubClasses = NULL;
    }
    if (pEnumTraceSubSubClasses){
        pEnumTraceSubSubClasses->Release();
        pEnumTraceSubSubClasses = NULL;
    }
    if (pQualSet) {
        pQualSet->Release();
        pQualSet = NULL;
    }

    return pMofLookup;
}

PMOF_VERSION
GetGuidsMofFiles ( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    FILE *f = NULL;
    PMOF_VERSION pMofLookup = NULL;
    //
    // If MofFileName is given, use it. Otherwise, look for 
    // the default file mofdata.guid 
    //
    
    if (TraceContext->MofFileName != NULL) {
        f = _wfopen( TraceContext->MofFileName, L"r" );
        if( f != NULL ){
            pMofLookup = GetGuidsFile(f, Guid, nVersion, nLevel, nType, bKernelEvent);
            fclose(f);
        }
    }

    if ((pMofLookup == NULL) && (TraceContext->DefMofFileName != NULL)) {
        f = _wfopen( TraceContext->DefMofFileName, L"r" );
        if( f != NULL ){
            pMofLookup = GetGuidsFile(f, Guid, nVersion, nLevel, nType, bKernelEvent);
            fclose(f);
        }
    }

    return pMofLookup;
}



PMOF_VERSION
GetGuidsFile( FILE *f, GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    WCHAR line[MAXSTR];
    WCHAR buffer[MAXSTR];
    
    PMOF_INFO pMofInfo = NULL;
    PMOF_VERSION pMofLookup = NULL;
    PMOF_VERSION pMofVersion = NULL;
    
    UINT i;
    LPWSTR s;
    UINT typeCount = 0;
    BOOL bInInfo = FALSE;
    BOOL    bInGuid = FALSE;

    SHORT   nTypeIndex;
    CHAR    nLevelIndex = -1;
    SHORT   nVersionIndex = -1;
    SHORT   nMatchLevel = 0;

    GUID    guid;

    LIST_ENTRY ListHead;

    InitializeListHead( &ListHead );

    //
    // If MofFileName is given, use it. Otherwise, look for 
    // the default file mofdata.guid 
    //
    
    while ( fgetws(line, MAXSTR, f) != NULL ) {
        UINT Index;
        if(line[0] == '/'){
            continue;
        }
        if(line[0] == '{' && bInGuid ){
            bInInfo = TRUE;
        } 
        else if ( line[0] == '}' && bInGuid ){
            bInInfo = FALSE;
            FlushMofVersionList( pMofInfo, &ListHead );
        }
        else if( bInInfo && bInGuid ){
            ITEM_TYPE type;
            LPWSTR strValue;

            Index = 1;
            strValue =  wcstok(line,  L"\n\t\r,");

            s =  wcstok( NULL,   L" \n\t\r,[");
            if(s != NULL && strValue != NULL ){
                PWCHAR t;

                while (*strValue == ' ') {  // skip leading blanks
                    strValue++;
                }
                t =  wcstok(NULL,   L"]" );

                if (t != NULL) {
                    Index = _wtoi(t);
                }

                if(! _wcsicmp(s,STR_ItemChar)) type = ItemChar;
                else if(! _wcsicmp(s,STR_ItemCharHidden)) type = ItemCharHidden;
                else if(! _wcsicmp(s,STR_ItemUChar)) type = ItemUChar;
                else if(! _wcsicmp(s,STR_ItemWChar)) type = ItemWChar;
                else if(! _wcsicmp(s,STR_ItemCharShort))type = ItemCharShort;
                else if(! _wcsicmp(s,STR_ItemCharSign)) type = ItemCharSign;
                else if(! _wcsicmp(s,STR_ItemShort)) type = ItemShort;
                else if(! _wcsicmp(s,STR_ItemUShort)) type = ItemUShort;
                else if(! _wcsicmp(s,STR_ItemLong)) type = ItemLong;
                else if(! _wcsicmp(s,STR_ItemULong)) type = ItemULong;
                else if(! _wcsicmp(s,STR_ItemULongX)) type = ItemULongX;
                else if(! _wcsicmp(s,STR_ItemLongLong)) type = ItemLongLong;
                else if(! _wcsicmp(s,STR_ItemULongLong)) type = ItemULongLong;
                else if(! _wcsicmp(s,STR_ItemString)) type = ItemString;
                else if(! _wcsicmp(s,STR_ItemWString)) type = ItemWString;
                else if(! _wcsicmp(s,STR_ItemRString)) type = ItemRString;
                else if(! _wcsicmp(s,STR_ItemRWString)) type = ItemRWString;
                else if(! _wcsicmp(s,STR_ItemPString)) type = ItemPString;
                else if(! _wcsicmp(s,STR_ItemMLString)) type = ItemMLString;
                else if(! _wcsicmp(s,STR_ItemNWString)) type = ItemNWString;
                else if(! _wcsicmp(s,STR_ItemPWString)) type = ItemPWString;
                else if(! _wcsicmp(s,STR_ItemDSString)) type = ItemDSString;
                else if(! _wcsicmp(s,STR_ItemDSWString)) type = ItemDSWString;
                else if(! _wcsicmp(s,STR_ItemSid)) type = ItemSid;
                else if(! _wcsicmp(s,STR_ItemChar4)) type = ItemChar4;
                else if(! _wcsicmp(s,STR_ItemIPAddr)) type = ItemIPAddr;
                else if(! _wcsicmp(s,STR_ItemTDIAddr)) type = ItemTDIAddr;
                else if(! _wcsicmp(s,STR_ItemPort)) type = ItemPort;
                else if(! _wcsicmp(s,STR_ItemPtr)) type = ItemPtr;
                else if(! _wcsicmp(s,STR_ItemSizeT)) type = ItemSizeT;
                else if(! _wcsicmp(s,STR_ItemGuid)) type = ItemGuid;
                else if(! _wcsicmp(s,STR_ItemOptArgs)) type = ItemOptArgs;
                else if(! _wcsicmp(s,STR_ItemCPUTime)) type = ItemCPUTime;
                else if(! _wcsicmp(s,STR_ItemVariant)) type = ItemVariant;
                else if(! _wcsicmp(s,STR_ItemBool)) type = ItemBool;
                else type = ItemUnknown;

                AddMofInfo( &ListHead, strValue, (SHORT)type, Index, NULL );
            }
        } 
        else if( line[0] == '#' && bInGuid ){
            LPWSTR strType;
            LPWSTR strValue;

            s =  wcstok( line,   L" \t");
            if( NULL == s ){
                continue;
            }

            if( line[1] == 'l' || line[1] == 'L' ){ // level
                
                strValue =  wcstok( NULL,  L" \t\n\r" );
                if